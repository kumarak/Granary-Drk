struct e820entry;
struct ff_ramp_effect;
struct e820map;
struct match_token;
struct setup_data;
struct scsi_target;
struct user_namespace;
struct resource;
struct sg_io_v4;
struct udphdr;
struct ustat;
struct device;
struct cdrom_mcn;
struct rt6_info;
struct ist_info;
struct edid_info;
struct acpi_resource_uart_serialbus;
struct setup_header;
struct input_absinfo;
struct nf_exp_event_notifier;
struct netdev_hw_addr_list;
struct kstat;
struct bsg_class_device;
struct olpc_ofw_header;
struct ifla_vf_spoofchk;
struct acpi_resource_dma;
struct request_list;
struct fprop_local_percpu;
struct acpi_madt_generic_interrupt;
struct tc_sfb_qopt;
struct x86_init_irqs;
struct llist_head;
struct __wait_queue;
struct x86_init_oem;
struct phy_c45_device_ids;
struct x86_init_mapping;
struct file_system_type;
struct x86_init_paging;
struct acpi_device_perf_flags;
union tcp_word_hdr;
struct mode_page_header;
struct bvec_merge_data;
struct x86_init_iommu;
struct tc_gred_qopt;
struct x86_init_pci;
struct header_ops;
struct file_lock;
struct elevator_queue;
struct x86_init_ops;
struct x86_cpuinit_ops;
struct x86_platform_ops;
struct gnet_stats_queue;
struct nda_cacheinfo;
struct pci_dev;
struct x86_msi_ops;
struct x86_io_apic_ops;
struct user32_fxsr_struct;
struct rt6_statistics;
struct local_apic;
struct request_pm_state;
struct acpi_table_pcct;
struct udp_sock;
struct futex_pi_state;
struct __wait_queue_head;
struct cdrom_blk;
struct blk_trace;
struct kthread_work;
struct Scsi_Host;
struct acpi_resource_start_dependent;
struct tcp_options_received;
struct ifaddrmsg;
struct parisc_device_id;
struct netns_nf_frag;
struct css_device_id;
struct dmi_strmatch;
struct acpi_madt_generic_distributor;
struct ifla_port_vsi;
struct cpu_vfs_cap_data;
struct mm_struct;
struct ethtool_ts_info;
struct compat_timeval;
struct nodemask_scratch;
struct aead_alg;
struct phy_driver;
struct block_device;
struct atomic_notifier_head;
struct packet_command;
struct proto;
struct compat_stat;
struct free_area;
struct sock_common;
struct gnet_estimator;
union IO_APIC_reg_01;
struct poll_table_page;
struct pglist_data;
struct blkcg_gq;
struct kthread_worker;
struct msr_info;
struct xfrm_user_sec_ctx;
struct ff_periodic_effect;
struct acpi_madt_io_apic;
struct compat_ustat;
struct compat_sigevent;
struct scsi_host_cmd_pool;
struct in_addr;
struct acpi_memory_list;
struct efi_info;
struct ipv6_mreq;
struct inet6_skb_parm;
struct pid_link;
struct cdrom_generic_command;
struct pid_namespace;
struct xfrmu_spdinfo;
struct nf_sockopt_ops;
struct xfrm_usersa_info;
struct zone_reclaim_stat;
struct boot_params;
struct ifla_vf_info;
struct acpi_resource_io;
struct ifa_cacheinfo;
struct kernel_cap_struct;
struct xfrm_userspi_info;
struct mempool_s;
struct thread_info;
struct acpi_table_msct;
struct semaphore;
struct tc_qfq_stats;
struct nameidata;
struct crypto_comp;
union acpi_name_union;
struct xfrm_user_acquire;
struct desc_struct;
struct ip_mreqn;
struct x86_init_mpparse;
struct xfrm_user_polexpire;
struct compat_msghdr;
struct nf_queue_entry;
struct phy_driver;
struct io_context;
struct xfrm_user_report;
struct compat_sysinfo;
struct acpi_uuid;
struct bio_integrity_payload;
struct per_cpu_pages;
struct x86_init_resources;
struct inode;
struct xfrm_policy_hash;
struct nf_conn;
struct gnet_dump;
struct neigh_ops;
struct pm_qos_request;
struct dentry_operations;
struct inode;
struct msr_regs_info;
struct lock_manager;
struct super_block;
struct hd_geometry;
struct acpi_table_header;
struct tcp_sock_af_ops;
struct inet6_request_sock;
struct ff_rumble_effect;
struct group_req;
struct elevator_ops;
struct scsi_transport_template;
struct inet_timewait_death_row;
struct tc_cbq_police;
struct device_attribute;
struct acpi_resource_fixed_io;
struct rtattr;
struct zonelist_cache;
struct elv_fs_entry;
struct pnp_device_id;
struct platform_device_id;
struct acpi_msct_proximity;
struct tc_police;
struct modversion_info;
struct crypto_attr_alg;
struct sigpending;
struct compat_ethtool_rxnfc;
struct preempt_notifier;
struct nfs_lock_info;
struct elevator_type;
struct cipher_alg;
struct phy_fixup;
struct xfrm_usersa_id;
struct compat_sysctl_args;
struct tcp_md5sig;
struct cdrom_device_ops;
struct zonelist;
struct x86_init_timers;
struct tcp_request_sock_ops;
struct Qdisc_ops;
union IO_APIC_reg_02;
struct blk_queue_tag;
struct shash_desc;
struct static_key;
struct linux_binprm;
struct ff_effect;
struct va_alignment;
struct dynamic;
struct blk_queue_tags;
struct acpi_generic_address;
struct queue_limits;
struct rps_dev_flow;
struct tcp6_request_sock;
struct sctp_mib;
struct elf32_rel;
struct elf64_rel;
struct elf32_rela;
struct throtl_data;
struct rps_dev_flow_table;
struct driver_attribute;
struct elf64_rela;
struct acpi_resource_fixed_dma;
struct rtmsg;
struct elf32_sym;
struct cdrom_changer_info;
struct klist_node;
struct elf64_sym;
struct preempt_ops;
struct blkcipher_tfm;
struct acpi_table_sbst;
struct elf32_hdr;
struct tcf_t;
struct jbd2_inode;
struct elf64_hdr;
struct module_kobject;
struct crypto_attr_type;
struct elf32_phdr;
struct req_iterator;
struct elf64_phdr;
struct rps_sock_flow_table;
struct compat_kexec_segment;
struct ablkcipher_tfm;
struct elf64_shdr;
struct radix_tree_root;
struct fstrim_range;
struct elf32_note;
struct xfrm_aevent_id;
struct elf64_note;
struct acpi_resource_generic_register;
struct sock;
struct blk_plug_cb;
struct ipc64_perm;
struct kobject;
struct gnet_stats_basic_packed;
struct kobj_ns_type_operations;
struct attribute;
struct attribute_group;
struct flowi_common;
struct dev_pm_qos_request;
struct bin_attribute;
struct sysfs_ops;
struct sysfs_dirent;
struct ipc_kludge;
struct kref;
struct dsa_platform_data;
struct acpi_table_rsdp;
struct dsa_switch_tree;
struct ipv6_mc_socklist;
struct ethtool_usrip4_spec;
struct dsa_switch;
struct rtable;
struct xps_dev_maps;
struct bsd_partition;
struct dsa_switch;
struct scsi_host_template;
struct dsa_switch_driver;
struct mii_bus;
struct netns_sctp;
struct dsa_switch_driver;
struct subsys_dev_iter;
struct dvd_layer;
struct acpi_io_attribute;
struct acpi_resource_vendor;
struct rtnexthop;
struct ieee_ets;
struct blk_integrity;
struct ieee_pfc;
struct zorro_device_id;
struct acpi_table_slit;
struct cee_pg;
struct cee_pfc;
struct module_param_attrs;
struct crypto_attr_u32;
struct dcb_app;
struct klist;
struct prot_inuse;
struct dcb_peer_app_info;
struct dcbmsg;
struct transaction_s;
struct netdev_fcoe_hbainfo;
struct dcb_app_type;
struct rng_alg;
struct files_stat_struct;
struct dcbnl_rtnl_ops;
struct ieee_maxrate;
struct acpi_resource_gpio;
struct taskstats;
union flowi_uli;
struct cgroupstats;
struct ptr_heap;
struct journal_head;
struct idr_layer;
struct tcf_walker;
union IO_APIC_reg_03;
struct idr;
struct ida_bitmap;
struct ida;
struct tcp_cookie_transactions;
struct ip_esp_hdr;
struct xattr_handler;
struct xattr;
struct iw_handler_def;
struct simple_xattrs;
struct seq_operations;
struct simple_xattr;
struct acpi_pci_routing_table;
struct acpi_srat_cpu_affinity;
struct acpi_srat_mem_affinity;
struct cleancache_filekey;
struct class_container;
struct acpi_table_rsdt;
struct sem_undo;
struct acpi_table_asf;
struct netns_dccp;
struct acpi_asf_info;
struct acpi_asf_alert;
struct acpi_dock_ops;
struct itimerspec;
struct acpi_asf_alert_data;
struct xfrm_lifetime_cur;
struct isapnp_device_id;
struct ctl_table_set;
struct acpi_asf_remote;
struct semid64_ds;
struct device_type;
struct nla_policy;
struct net_device_stats;
struct acpi_asf_control_data;
struct rta_cacheinfo;
struct acpi_asf_rmcp;
struct bio_pair;
struct acpi_table_srat;
struct acpi_table_boot;
struct module_attribute;
struct acpi_table_csrt;
struct compat_utimbuf;
struct crypto_ahash;
struct compress_alg;
struct acpi_csrt_group;
struct netns_core;
struct in_device;
struct acpi_csrt_descriptor;
struct nl_info;
struct inode_operations;
struct compat_msgbuf;
struct acpi_table_dbg2;
struct module;
struct acpi_dbg2_device;
struct inodes_stat_t;
struct acpi_table_dbgp;
struct xfrm_userpolicy_info;
struct acpi_table_dmar;
struct acpi_resource_common_serialbus;
struct acpi_dmar_header;
struct dn_dev;
struct rtnl_link_ops;
struct acpi_dmar_device_scope;
struct xfrm_state;
struct inode_operations;
struct blk_scsi_cmd_filter;
struct acpi_dmar_pci_path;
struct ip_comp_hdr;
struct qdisc_rate_table;
struct acpi_dmar_hardware_unit;
struct acpi_dmar_reserved_memory;
struct pm_qos_constraints;
struct acpi_dmar_atsr;
struct x86_hw_tss;
struct seminfo;
struct acpi_table_hpet;
struct rtnl_af_ops;
struct uprobes_state;
struct blk_plug;
struct qdisc_walker;
struct netlink_skb_parms;
struct acpi_table_xsdt;
struct netlink_kernel_cfg;
struct ipv6_fl_socklist;
struct input_dev;
struct netlink_callback;
struct cpu_rmap;
struct neigh_table;
struct netlink_notify;
struct acpi_sleep_functions;
struct netlink_dump_control;
struct cgroup_map_cb;
struct itimerval;
struct acpi_device_ops;
struct ctl_table_set;
struct cftype;
struct eventfd_ctx;
struct acpi_resource_end_tag;
struct rta_session;
struct ndtmsg;
struct Qdisc;
struct ndt_config;
struct amba_id;
struct linux_binfmt;
struct sockaddr_pkt;
struct neighbour;
struct cgroup_iter;
struct sched_group_power;
struct shmid_kernel;
struct sg_iovec;
struct msg_msg;
struct blk_integrity_exchg;
struct msg_queue;
struct neigh_table;
struct audit_krule;
struct export_operations;
struct xfrm_policy;
struct tpacket2_hdr;
struct epoll_event;
struct cdrom_device_ops;
struct tpacket_hdr_variant1;
struct tpacket3_hdr;
struct cdrom_slot;
struct mnt_namespace;
struct sysv_sem;
struct ipc_namespace;
struct IO_APIC_route_entry;
struct tpacket_stats_v3;
struct pm_qos_flags;
struct kset_uevent_ops;
struct zap_details;
struct scm_fp_list;
union tpacket_bd_header_u;
struct ip_beet_phdr;
struct tpacket_block_desc;
struct builtin_fw;
struct tpacket_req;
struct posix_acl_entry;
struct sem_undo_list;
struct inet_timewait_sock;
struct neigh_ops;
struct nlmsgerr;
struct rt_mutex;
struct orig_ist;
struct nl_pktinfo;
struct slab;
struct flowi6;
struct task_migration_notifier;
struct ff_device;
struct input_event;
union acpi_object;
struct acpi_table_facs;
struct pcpu_dstats;
struct compress_tfm;
struct pneigh_entry;
struct gate_struct64;
struct socket;
struct ldttss_desc64;
struct tasklet_hrtimer;
struct acpi_device_perf_state;
struct tms;
struct pgprot;
struct garp_port;
struct of_device_id;
struct proto_ops;
struct acpi_resource_memory24;
struct pm_qos_flags_request;
struct event_header;
struct rq_map_data;
struct file;
struct seq_file;
struct thread_struct;
struct ahash_request;
struct tss_struct;
struct rtnl_link_ops;
struct neigh_table;
struct cpumask;
struct proto_ops;
struct pollfd;
struct paravirt_callee_save;
struct cipher_desc;
struct text_poke_param;
struct pv_init_ops;
struct pv_lazy_ops;
struct acpi_resource_spi_serialbus;
struct module_sect_attrs;
struct pv_time_ops;
struct napi_gro_cb;
struct neigh_seq_state;
struct mutex_waiter;
struct pv_cpu_ops;
struct pv_irq_ops;
struct in6_pktinfo;
struct Qdisc_class_ops;
struct pv_apic_ops;
struct pv_mmu_ops;
struct xps_map;
struct arch_spinlock;
struct i387_fsave_struct;
struct pv_lock_ops;
struct packet_type;
struct neighbour_cb;
struct paravirt_patch_template;
struct rw_semaphore;
struct cfs_rq;
struct IR_IO_APIC_route_entry;
struct tcp_request_sock;
struct acpi_table_fadt;
struct input_mt;
struct cipher_tfm;
struct offload_callbacks;
struct ts_state;
struct dvd_lu_send_agid;
struct cred;
struct ethtool_sset_info;
struct acpi_resource_memory32;
struct media_event_desc;
struct packet_offload;
struct rtable;
struct ts_ops;
struct netdev_hw_addr;
struct ahash_alg;
struct biovec_slab;
struct tc_gred_sopt;
struct tc_estimator;
struct softnet_data;
struct rt6_info;
struct in6_addr;
struct obs_kernel_param;
struct xfrm_user_expire;
struct rand_pool_info;
struct Qdisc;
struct dn_route;
struct sk_buff;
struct ip6_mtuinfo;
struct tc_mqprio_qopt;
struct net_device;
struct rusage;
struct tcamsg;
struct pnp_driver;
struct task_group;
struct input_handle;
struct dql;
struct compat_flock64;
struct __kernel_sockaddr_storage;
struct sockaddr;
struct ipv6_txoptions;
struct tvec_base;
struct rlimit;
struct mp_ioapic_gsi;
struct msghdr;
struct icmp6_filter;
struct task_io_accounting;
struct cmsghdr;
struct acpi_device_perf;
struct ucred;
struct pci_slot;
struct acpi_predefined_names;
struct signal_struct;
struct driver_attribute;
struct nf_bridge_info;
struct acpi_resource_fixed_memory32;
struct io_apic_irq_attr;
struct key_type;
struct ata_port_operations;
struct key_owner;
struct raw_spinlock;
struct keyring_name;
struct module_ref;
struct __key_reference_with_attributes;
struct tc_choke_qopt;
struct hrtimer;
struct ifmap;
struct smp_ops;
struct if_settings;
struct flowi4;
struct va_format;
struct selinux_audit_rule;
struct crypto_type;
struct audit_context;
struct workqueue_struct;
struct css_id;
struct group_info;
struct in6_ifreq;
struct tcf_result;
struct user_i387_ia32_struct;
struct dma_interleaved_template;
struct llist_node;
struct user_regs_struct32;
struct robust_list_head;
struct bio_list;
struct call_single_data;
struct fs_struct;
struct acpi_hardware_id;
struct acpi_table_desc;
struct input_handle;
struct tcp_fastopen_cookie;
struct delayed_work;
struct ata_bmdma_prd;
struct pcpu_group_info;
struct acpi_device_wakeup_flags;
struct input_value;
struct ip_msfilter;
struct subsys_interface;
struct acpi_memory_attribute;
struct rta_mfc_stats;
struct ata_port;
struct ubuf_info;
struct hh_cache;
struct crypto_shash;
struct acpi_hest_ia_machine_check;
struct icmpmsg_mib;
struct tc_choke_xstats;
struct skb_shared_info;
struct rb_node;
struct vmcore;
struct physid_mask;
struct xfrm_usersa_flush;
struct raw6_sock;
struct pm_message;
struct acpi_resource;
struct symsearch;
struct tcp_md5sig_info;
struct dev_pm_ops;
struct wakeup_source;
struct acpi_resource_address64;
struct pm_domain_data;
struct tcf_proto_ops;
struct rcu_batch;
struct pm_subsys_data;
struct dvd_physical;
struct dev_pm_info;
struct dev_pm_qos;
struct ipv6_rt_hdr;
struct dev_pm_domain;
struct pci_bus;
struct __sysctl_args;
struct vm_area_struct;
struct vm_struct;
struct acpi_osc_context;
struct ip_options_data;
struct input_handler;
struct rtgenmsg;
struct node_active_region;
struct ata_taskfile;
struct bootmem_data;
struct acpi_subtable_header;
struct mutex;
struct blocking_notifier_head;
struct nsproxy;
struct net_proto_family;
struct sockaddr_in;
struct ts_config;
struct debug_obj_descr;
struct list_head;
struct debug_obj;
struct acpi_device_wakeup;
struct notifier_block;
struct address_space_operations;
struct user_regs_struct;
struct timex;
struct class_attribute;
struct raw_notifier_head;
struct sockaddr_ll;
struct module_notes_attrs;
union ktime;
struct ff_constant_effect;
struct ata_link;
struct nf_conntrack;
struct acpi_hest_generic_status;
struct timer_list;
struct tcp_timewait_sock;
struct sk_buff_head;
struct shash_alg;
struct tty_driver;
struct skb_frag_struct;
struct acpi_hest_ia_corrected;
struct icmpv6_mib;
struct work_struct;
struct srcu_notifier_head;
struct tpacket_stats;
struct skb_shared_hwtstamps;
struct ftrace_event_call;
struct execute_work;
struct flowidn;
struct srcu_struct_array;
struct sec_path;
struct exec_domain;
struct srcu_struct;
struct timerqueue_node;
struct radix_tree_node;
struct mem_section;
struct netns_ct;
struct pid_namespace;
struct dst_entry;
struct tcf_proto;
struct skb_seq_state;
struct ethhdr;
struct compat_mmsghdr;
struct ethtool_cmd;
struct ethtool_drvinfo;
struct memory_block;
struct _ddebug;
union tpacket_stats_u;
struct mpc_table;
struct mpc_cpu;
struct pnp_dev;
struct acpi_drtm_vtl_list;
struct perf_event_context;
struct udp6_sock;
struct pci_bus_region;
struct ff_device;
struct pci_dynids;
struct ctl_table;
struct tpacket_auxdata;
struct compat_ifmap;
struct vm86_struct;
struct vm86plus_info_struct;
struct acpi_device_physical_node;
struct tcphdr;
struct io_event;
struct group_source_req;
struct iocb;
struct device_attribute;
union acpi_resource_attribute;
struct scatterlist;
struct ifinfomsg;
struct ata_queued_cmd;
struct dma_pool;
struct mpf_intel;
struct pci_cap_saved_state;
struct tpacket_hdr;
struct __user_cap_header_struct;
struct user_struct;
struct request_sense;
struct arch_uprobe;
struct poll_table_entry;
struct _fpstate;
struct acpi_hest_ia_nmi;
struct tc_htb_glob;
struct _xsave_hdr;
struct simple_transaction_argresp;
struct acpi_mem_space_context;
struct cpu_itimer;
struct ethtool_wolinfo;
struct xfrmu_spdhinfo;
struct xfrm_user_kmaddress;
struct acpi_signal_fatal_info;
struct timerqueue_head;
struct radix_tree_iter;
struct acpi_table_ibft;
struct ipv6_ac_socklist;
struct taskstats;
struct qdisc_skb_cb;
struct ethtool_value;
struct tcp_sock;
struct request_sock;
struct tty_audit_buf;
struct dvd_disckey;
struct dma_chan;
struct reclaim_state;
struct spi_device_id;
struct rt0_hdr;
struct page_frag;
struct vm_region;
struct security_mnt_opts;
struct latency_record;
struct sched_domain_attr;
struct anon_vma;
struct sched_domain;
struct pnp_protocol;
struct user_desc;
struct scsi_varlen_cdb_hdr;
struct acpi_table_bert;
struct tc_netem_corr;
struct tcp6_sock;
struct xfrm_selector;
struct nf_afinfo;
struct proc_dir_entry;
struct group_filter;
struct acpi_bus_event;
struct request_queue;
struct vm_fault;
struct napi_struct;
struct tpacket_bd_ts;
struct acpi_resource_source;
struct hlist_bl_node;
struct vm86_regs;
struct prefixmsg;
struct ata_ioports;
struct ipv6_opt_hdr;
struct hash_tfm;
struct jbd2_journal_handle;
union proc_op;
struct disk_stats;
struct icmpv6msg_mib;
struct tc_htb_xstats;
struct scm_creds;
struct hlist_node;
struct hlist_bl_node;
struct kset;
struct compat_ethtool_rx_flow_spec;
struct xfrm_user_migrate;
struct acpi_fde_info;
struct hrtimer_clock_base;
struct upid;
struct pnp_card_driver;
struct user_i387_struct;
struct sockaddr_nl;
struct xfrm_userpolicy_id;
struct kobj_uevent_env;
struct rt2_hdr;
struct Qdisc_class_common;
struct dma_device;
struct dom0_vga_console_info;
struct scm_cookie;
struct path;
struct ethtool_ops;
struct eventfd_ctx;
struct acpi_madt_local_apic_nmi;
struct acpi_drtm_id_list;
struct acpi_bert_region;
struct acpi_table_wdrt;
struct inet6_timewait_sock;
struct acpi_table_bgrt;
struct acpi_table_drtm;
struct user_ymmh_regs;
struct vfsmount;
struct hotplug_slot;
struct acpi_drtm_resource_list;
struct acpi_eject_event;
struct in_pktinfo;
struct user_xstateregs;
struct acpi_table_fpdt;
struct class_compat;
struct acpi_resource_address;
struct prefix_cacheinfo;
struct ata_host;
struct acpi_fpdt_boot;
struct user_xsave_hdr;
struct shrinker;
struct kernel_vm86_regs;
struct acpi_table_s3pt;
struct journal_s;
struct acpi_s3pt_header;
struct acpi_hest_aer;
struct icmpv6msg_mib_device;
struct acpi_s3pt_resume;
struct tc_hfsc_qopt;
struct hlist_node;
struct acpi_s3pt_suspend;
struct kobj_type;
struct acpi_table_gtdt;
struct tpacket_req3;
struct pt_regs;
struct kioctx;
struct partition_meta_info;
struct xfrm_user_mapping;
struct acpi_mpst_power_node;
struct hrtimer_cpu_base;
struct flow_cache_object;
struct proc_ns_operations;
struct acpi_mpst_power_state;
struct acpi_mpst_component;
struct compat_dirent;
struct acpi_mpst_data_hdr;
struct acpi_table_mchi;
struct Qdisc_class_hash;
struct xfrm_stats;
struct paravirt_patch_site;
struct siginfo;
struct dvd_manufact;
struct dma_chan_dev;
struct acpi_mpst_shared;
struct nlmsghdr;
struct tcp_sack_block_wire;
struct ipv6_destopt_hao;
struct ifconf;
struct acpi_pcct_subspace;
struct acpi_resource_vendor_typed;
struct acpi_pcct_shared_memory;
struct acpi_table_pmtt;
struct dentry_stat_t;
struct sigaction;
struct acpi_pmtt_header;
struct acpi_pmtt_socket;
struct dvd_copyright;
struct aio_ring;
struct pnp_card;
struct revectored_struct;
struct cg_proto;
struct acpi_object_list;
struct acpi_table_cpep;
struct request_sock_ops;
struct tcp6_timewait_sock;
struct dentry;
struct icmp_mib;
struct timewait_sock_ops;
struct irq_chip_regs;
struct inet_hashinfo;
struct raw_hashinfo;
struct mii_if_info;
struct acpi_pci_root;
struct udp_table;
struct Qdisc;
struct acpi_resource_address16;
struct flow_cache_ops;
struct aio_ring_info;
struct tcmsg;
struct irq_chip_type;
struct socket_alloc;
struct ata_device;
struct __una_u16;
struct modesel_head;
struct __una_u32;
struct __una_u64;
struct journal_header_s;
struct request_values;
struct crypto_alg;
struct acpi_hest_aer_bridge;
struct listen_sock;
struct tc_service_curve;
struct compat_mq_attr;
struct kobj_type;
struct kparam_string;
struct fastopen_queue;
struct hv_vmbus_device_id;
struct request_sock_queue;
struct ip_options;
struct scsi_ioctl_command;
struct ip_options_rcu;
struct acpi_gtm_info;
struct jbd2_buffer_trigger_type;
struct hrtimer_sleeper;
struct inet_request_sock;
struct cgroup_subsys_state;
struct pacct_struct;
struct inet_cork;
struct acpi_dmar_rhsa;
struct ipv6hdr;
struct qdisc_watchdog;
struct inet_cork_full;
struct ip_mc_socklist;
struct ipv6_pinfo;
struct inet_sock;
struct net_generic;
struct inet_bind_bucket;
struct task_rss_stat;
struct tcp_congestion_ops;
struct acpi_fpdt_header;
struct acpi_cpep_polling;
struct mpc_bus;
struct tc_stats;
struct netdev_boot_setup;
struct pnp_id;
struct mpc_ioapic;
struct mpc_intsrc;
struct netns_ipvs;
struct _xstate;
struct device_private;
struct acpi_buffer;
struct mpc_lintsrc;
struct acpi_whea_header;
struct mpc_oemtable;
struct screen_info;
struct scsi_cmnd;
struct apm_bios_info;
struct acpi_resource_address32;
struct nduseroptmsg;
struct apm_info;
struct ata_port_stats;
struct edd_device_params;
struct nfq_ct_nat_hook;
struct rps_map;
struct commit_header;
struct acpi_hest_generic;
struct tc_hfsc_stats;
struct callback_head;
struct neigh_hash_table;
struct rnd_state;
struct udp_mib;
struct dmi_system_id;
struct netns_xfrm;
struct acpi_pld_info;
struct crypto_ablkcipher;
struct clock_event_device;
struct cdrom_mechstat_header;
struct nlattr;
struct socket_wq;
struct tpacket_hdr_v1;
struct client_extension;
struct ipv6_devconf;
struct mdio_device_id;
struct edd_info;
struct edd;
struct sighand_struct;
struct pnp_card_link;
struct pci_ops;
struct ethtool_regs;
struct ethtool_eeprom;
struct poll_wqueues;
struct acpi_table_ecdt;
struct ethtool_eee;
struct mod_arch_specific;
struct anon_vma;
struct ethtool_modinfo;
struct ethtool_coalesce;
struct ethtool_ringparam;
struct acpi_pci_driver;
struct ethtool_channels;
struct pci_driver;
struct ethtool_pauseparam;
struct ethtool_gstrings;
struct swap_extent;
struct ethtool_test;
struct ethtool_stats;
struct ethtool_perm_addr;
struct journal_block_tag_s;
struct disk_part_tbl;
struct ethtool_tcpip4_spec;
struct linux_mib;
struct ethtool_ah_espip4_spec;
struct alt_instr;
struct io_cq;
struct trampoline_header;
struct fid;
struct ablkcipher_alg;
struct nfq_ct_hook;
struct pid;
union ethtool_flow_union;
struct ethtool_flow_ext;
struct ethtool_rx_flow_spec;
struct acpi_handle_list;
struct crypto_async_request;
struct hlist_bl_head;
struct ethtool_rxnfc;
struct dvd_host_send_challenge;
struct ethtool_rxfh_indir;
struct map_segment;
struct iommu_group;
struct ethtool_rx_ntuple_flow_spec;
struct ipv6_params;
struct vfs_cap_data;
struct ethtool_rx_ntuple;
struct partition;
struct ethtool_flash;
struct tmem_op;
struct ethtool_dump;
struct ethtool_get_features_block;
struct sigqueue;
struct arch_clocksource_data;
struct ethtool_gfeatures;
struct vm86plus_struct;
struct ethtool_set_features_block;
struct acpi_fpdt_s3pt_ptr;
struct acpi_table_einj;
struct tc_ratespec;
struct pnp_card_driver;
struct module_version_attribute;
struct data_chunk;
struct acpi_system_info;
struct resource_list_entry;
struct transaction_stats_s;
struct acpi_resource_extended_address64;
struct vlan_ioctl_args;
struct nf_ct_tcp_flags;
struct lock_class_key;
struct vm_event_state;
struct jbd2_journal_block_tail;
struct acpi_hest_generic_data;
struct linux_xfrm_mib;
struct tc_cbq_wrropt;
struct stat;
struct k_sigaction;
struct ipv4_devconf;
struct pv_info;
struct pcie_link_state;
struct __user_cap_data_struct;
struct tcp_fastopen_request;
struct i387_fxsave_struct;
struct dma_chan_percpu;
struct dvd_send_key;
struct dma_tx_state;
struct icmp6hdr;
struct kvec;
struct inet_connection_sock;
struct disk_events;
struct pnp_driver;
struct acpi_pmtt_physical_component;
struct acpi_connection_info;
struct uts_namespace;
struct acpi_einj_entry;
struct tc_sizespec;
struct rq;
struct jbd2_buffer_trigger_type;
struct sched_class;
struct res_counter;
struct load_weight;
struct sched_avg;
struct lockdep_map;
struct sock_iocb;
struct netns_ipv4;
struct zone_padding;
struct sched_statistics;
struct tcp_repair_opt;
struct sched_entity;
struct acpi_resource_extended_irq;
struct sched_rt_entity;
struct acpi_device_id;
struct ata_device;
struct rt_rq;
struct rcu_node;
struct klist_iter;
struct css_set;
struct compat_robust_list_head;
struct jbd2_journal_revoke_header_s;
struct sigaltstack;
struct timer_rand_state;
struct ymmh_struct;
struct ftrace_ret_stack;
struct acpi_table_madt;
struct netns_mib;
struct tc_cbq_ovl;
union thread_union;
struct kobj_attribute;
struct dma_chan_dev;
struct irq_desc;
struct ebt_table;
struct irq_data;
struct msi_desc;
struct request;
struct seq_net_private;
struct skcipher_givcrypt_request;
struct irq_domain;
struct acpi_device;
struct crypto_blkcipher;
struct irq_chip;
struct hash_alg_common;
struct irq_chip;
struct dma_slave_config;
struct irq_affinity_notify;
struct irqaction;
struct cdrom_device_info;
struct __large_struct;
struct irq_2_iommu;
struct tc_cnt;
struct intel_iommu;
struct irq_cfg;
struct dma_async_tx_descriptor;
struct irq_pin_list;
struct kernel_vm86_struct;
struct pci_error_handlers;
struct irqaction;
struct acpi_einj_error_type_with_addr;
struct writeback_control;
struct pnp_id;
struct tcp_sack_block;
struct ata_ering;
struct inet_peer_base;
struct pci_host_bridge_window;
struct acpi_pnp_device_id;
struct seqcount;
struct cdrom_msf0;
struct mr_table;
struct bgl_lock;
struct timezone;
struct dst_ops;
struct vlan_hdr;
struct neighbour;
struct kern_ipc_perm;
struct gendisk;
struct ratelimit_state;
struct dma_device;
struct tm;
struct ipv6_devconf;
struct jbd2_journal_revoke_tail;
struct acpi_madt_local_apic;
struct kernel_param;
struct wait_bit_key;
struct bug_entry;
union sigval;
struct wait_bit_queue;
struct dma_page_list;
struct blk_integrity;
struct xsave_hdr_struct;
struct fib6_table;
struct sg_io_hdr;
struct pernet_operations;
struct cputime;
struct acpi_bus_ops;
struct crypto_hash;
struct file_ra_state;
struct netns_xt;
struct qdisc_size_table;
struct file_handle;
struct compat_if_settings;
struct files_struct;
struct user32;
struct cpuinfo_x86;
struct dvd_lu_send_title_key;
struct ip_mreq;
struct lruvec;
struct tc_u32_key;
struct neigh_parms;
struct ip_mreq_source;
struct per_cpu_pageset;
struct cgroupfs_root;
struct net;
struct nlm_lockowner;
struct zoneref;
struct tc_htb_opt;
struct nfs4_lock_state;
struct task_cputime;
struct pnp_fixup;
struct tc_sfb_xstats;
struct math_emu_info;
struct pci_driver;
struct pci_fixup;
struct acpi_pnp_device_id_list;
struct sched_param;
struct tc_prio_qopt;
struct ipc_perm;
struct blockgroup_lock;
struct netdev_rx_queue;
struct flowi;
struct msgbuf;
union cdrom_addr;
struct xt_table;
struct netdev_tc_txq;
struct miscdevice;
struct pci_sysdata;
struct semid_ds;
struct acpi_resource_i2c_serialbus;
struct ff_condition_effect;
struct net_device_ops;
struct vlan_ethhdr;
struct ata_eh_info;
struct nf_conntrack_ecache;
struct sem_queue;
struct iw_public_data;
struct rtnl_link_stats;
struct vlan_info;
struct journal_superblock_s;
struct sembuf;
struct disk_part_iter;
struct xsave_struct;
union semun;
struct netns_packet;
struct tc_cbq_fopt;
struct ctl_table_poll;
struct inet6_dev;
struct kernel_param_ops;
struct seminfo;
struct timespec;
struct sem_array;
struct sem;
struct bsg_job;
struct dsa_chip_data;
struct compat_ifreq;
struct pcpu_lstats;
struct crypto_rng;
struct dvd_lu_send_asf;
struct pcpu_tstats;
struct prop_global;
struct prop_descriptor;
struct icmpv6_nd_advt;
union tpacket_req_u;
struct prop_local_percpu;
struct crypto_cipher;
struct pci_host_bridge;
struct dma_pinned_list;
struct prop_local_single;
struct seccomp_data;
struct tc_u32_sel;
struct bio_vec;
struct seccomp_filter;
struct seccomp;
struct thread_group_cputimer;
struct plist_head;
struct acpi_hest_notify;
struct dev_ext_attribute;
struct plist_node;
struct acpi_einj_trigger;
struct ndt_stats;
struct tc_multiq_qopt;
struct hlist_nulls_head;
struct pnp_id;
struct vm_unmapped_area_info;
struct hlist_nulls_node;
struct hlist_nulls_node;
struct acpi_device_info;
struct page_cgroup;
struct cdrom_msf;
struct ip_ct_tcp_state;
struct node;
struct cdev;
struct ip_ct_tcp;
struct pcpu_alloc_info;
struct firmware;
struct ata_eh_context;
struct nf_proto_net;
struct sem;
struct pci_ops;
struct nf_generic_net;
struct dma_map_ops;
struct acpi_table_spcr;
struct irq_routing_table;
struct bio_set;
struct nf_tcp_net;
struct acpi_dev_node;
struct nf_udp_net;
struct nf_icmp_net;
struct acpi_madt_interrupt_override;
struct netns_frags;
struct tc_cbq_xstats;
struct ctl_table_header;
struct ctl_dir;
struct compat_timespec;
struct ip_conntrack_stat;
union thread_xstate;
struct ctl_node;
struct acpi_device_status;
struct crypto_tfm;
struct crypto_aead;
struct fown_struct;
struct xfrm_id;
struct xfrm_sec_ctx;
struct solaris_x86_slice;
struct ctl_path;
struct dvd_host_send_rpcstate;
struct bus_attribute;
struct xfrm_lifetime_cfg;
struct subprocess_info;
struct tc_u32_mark;
struct real_mode_header;
struct icmpv6_nd_ra;
struct xfrm_replay_state;
struct xfrm_replay_state_esn;
struct cgroup;
struct dvd_lu_send_challenge;
struct xfrm_algo;
struct xfrm_algo_auth;
struct xfrm_algo_aead;
struct autogroup;
struct _fpx_sw_bytes;
struct pci_saved_state;
struct vm_operations_struct;
struct acpi_pci_id;
struct acpi_table_erst;
struct mempolicy;
struct tc_tbf_qopt;
struct tc_netem_corrupt;
struct core_thread;
union swap_header;
struct core_state;
struct acpi_ibft_header;
struct tc_fifo_qopt;
struct pdev_archdata;
struct mm_rss_stat;
struct cdrom_ti;
struct kmem_cachep;
struct device_driver;
struct tc_u32_pcnt;
struct mmu_notifier_mm;
struct range;
struct cleancache_ops;
struct ata_acpi_drive;
struct acpi_ibft_control;
struct mempolicy;
struct bus_type;
struct acpi_pmtt_controller;
struct perf_event;
struct anon_vma_chain;
struct jbd2_revoke_table_s;
struct iommu_ops;
struct solaris_x86_vtoc;
struct fpu;
struct acpi_madt_nmi_source;
struct x86_cpu_id;
struct tc_netem_qopt;
struct kparam_string;
struct mmu_gather;
struct acpi_ibft_initiator;
struct restart_block;
struct hotplug_slot;
struct pci_cap_saved_data;
struct acpi_asf_address;
struct acpi_device_flags;
struct mm_walk;
struct qstr;
struct dvd_lu_send_rpcstate;
struct device_type;
struct pci_vpd;
struct acpi_ibft_nic;
struct pci_sriov;
struct pci_ats;
struct dma_attrs;
struct acpi_srat_x2apic_cpu_affinity;
struct sg_table;
struct sg_mapping_iter;
struct class_dev_iter;
struct tty_struct;
struct pci_bus_resource;
struct acpi_ibft_target;
struct class_attribute;
struct memcg_cache_params;
struct acpi_table_mpst;
struct acpi_erst_entry;
struct tc_sfq_qopt;
struct quotactl_ops;
struct acpi_table_ivrs;
struct vm_operations_struct;
struct cdrom_tochdr;
struct zone;
struct iphdr;
struct ata_acpi_gtm;
struct acpi_pmtt_domain;
struct acpi_ivrs_header;
struct transaction_chp_stats_s;
struct inet_frags;
struct dev_pm_qos;
struct ifla_cacheinfo;
struct bsd_disklabel;
struct acpi_ivrs_hardware;
struct acpi_device_dir;
struct aead_givcrypt_request;
struct fiemap_extent;
struct compat_ifconf;
struct inet_connection_sock_af_ops;
struct acpi_ivrs_de_header;
struct tc_rsvp_gpi;
struct clocksource;
struct mem_cgroup_reclaim_cookie;
struct css_set;
struct tc_cbq_lssopt;
struct acpi_ivrs_device4;
struct dvd_bca;
struct acpi_device_pnp;
struct packet_mreq;
struct acpi_mpst_channel;
struct acpi_erst_info;
struct class_interface;
struct tc_sfq_xstats;
struct device_attribute;
struct acpi_ivrs_device8a;
struct rtnl_link_ifmap;
struct nfs4_lock_info;
struct device_dma_parameters;
struct cdrom_volctrl;
struct ifla_vlan_flags;
struct dma_coherent_mem;
struct tick_device;
struct ip_auth_hdr;
struct tick_sched;
struct ata_port_info;
struct acpi_ivrs_device8b;
struct pci_device_id;
struct ieee1394_device_id;
struct usb_device_id;
struct transaction_run_stats_s;
struct hid_device_id;
struct acpi_madt_local_apic_override;
struct tcpm_hash_bucket;
struct ccw_device_id;
struct tc_netem_reorder;
struct ap_device_id;
struct acpi_ivrs_device8c;
struct phy_device;
struct compat_statfs;
struct acpi_device_id;
struct compat_robust_list;
struct pnp_card_device_id;
struct fiemap;
struct acpi_hest_aer_root;
struct serio_device_id;
struct acpi_ivrs_memory;
union compat_sigval;
struct of_device_id;
struct vio_device_id;
struct pcmcia_device_id;
struct acpi_asf_header;
struct tc_rsvp_pinfo;
struct input_device_id;
struct eisa_device_id;
struct tcp_md5sig_key;
struct netdev_queue;
struct acpi_table_mcfg;
struct sdio_device_id;
struct compat_siginfo;
struct ipack_device_id;
struct msix_entry;
struct ssb_device_id;
struct acpi_table_hest;
struct tc_red_qopt;
struct acpi_driver;
struct acpi_mcfg_allocation;
struct file_operations;
struct input_keymap_entry;
struct cdrom_subchnl;
struct acpi_bus_type;
struct ata_timing;
struct driver_private;
struct dma_map_ops;
struct acpi_table_rasf;
struct elf32_shdr;
struct fasync_struct;
struct bcma_device_id;
struct acpi_madt_io_sapic;
struct ifla_vlan_qos_mapping;
struct kparam_array;
struct unixware_slice;
struct acpi_table_slic;
struct sysinfo;
struct icmpv6_echo;
struct ablkcipher_request;
struct shrink_control;
struct sys_desc_table;
struct xfrm_user_tmpl;
struct neigh_statistics;
struct compat_robust_list_head;
struct sockaddr_in6;
struct mrw_feature_desc;
struct acpi_slic_header;
struct completion;
struct tcf_ematch_tree_hdr;
struct cyclecounter;
struct sock_filter;
struct desc_ptr;
struct tcp_info;
struct dev_archdata;
struct acpi_slic_key;
struct super_operations;
struct _ymmh_state;
struct aead_tfm;
struct trap_info;
struct acpi_hest_header;
struct ff_replay;
struct arch_shared_info;
struct tc_red_xstats;
struct iret_context;
union acpi_resource_data;
struct acpi_slic_marker;
struct user;
struct cpu_user_regs;
struct class_attribute_string;
struct cdrom_tocentry;
struct netns_ipv6;
struct cma;
struct pci_bits;
struct nf_ip_net;
struct virtio_device_id;
struct rb_root;
struct rt_mutex_waiter;
struct class_;
struct ifla_vxlan_port_range;
struct acpi_rasf_shared_memory;
struct unixware_disklabel;
struct acpi_madt_local_sapic;
struct fib_rules_ops;
struct tc_netem_gimodel;
struct arch_vcpu_info;
struct blkcipher_alg;
struct acpi_table_spmi;
struct fiemap_extent_info;
struct pvclock_vcpu_time_info;
struct rtnl_link_stats64;
struct pvclock_wall_clock;
struct compat_statfs64;
struct vcpu_guest_context;
struct aead_request;
struct rwrt_feature_desc;
struct mmuext_op;
struct xfrm_encap_tmpl;
struct acpi_table_tcpa;
struct ftrace_branch_data;
struct sock_fprog;
struct linger;
struct mmu_update;
struct multicall_entry;
struct tcf_ematch_hdr;
struct timecounter;
struct vcpu_time_info;
struct vcpu_info;
struct irq_chip_generic;
struct shared_info;
struct sched_info;
struct acpi_table_uefi;
struct __old_kernel_stat;
struct start_info;
struct rlimit64;
struct arch_uprobe_task;
struct acpi_hest_ia_error_bank;
struct ethtool_sfeatures;
struct kcore_list;
struct acpi_table_waet;
struct super_operations;
struct ff_trigger;
struct mmsghdr;
struct cdrom_read;
struct hd_struct;
struct mtd_info;
struct swap_list_t;
struct file_lock_operations;
struct i387_soft_struct;
struct ccs_modesel_head;
struct kset;
struct proc_inode;
struct platform_device;
struct snmp_mib;
struct subsys_private;
struct pci_setup_rom;
struct u64_stats_sync;
struct acpi_table_wdat;
struct file_system_type;
struct ipstats_mib;
union irq_stack_union;
struct acpi_madt_interrupt_source;
struct kparam_array;
struct tc_netem_gemodel;
struct ifla_vf_mac;
struct tracepoint;
struct kmem_cache;
struct icmpv6_mib_device;
struct pollfd;
struct unixware_vtoc;
struct static_key_deferred;
struct acpi_wdat_entry;
struct audit_names;
struct crypto_shash;
struct key;
struct ata_ering_entry;
struct acpi_device_power_state;
struct blkcipher_desc;
struct tcp_mib;
struct percpu_rw_semaphore;
struct xfrm_userpolicy_type;
struct tracepoint_iter;
struct compat_old_linux_dirent;
struct kernel_symbol;
struct in6_flowlabel_req;
struct bdi_writeback;
struct acpi_table_wddt;
struct compat_sigaltstack;
struct netns_unix;
struct gnet_stats_basic;
struct compat_sock_fprog;
struct cftype_set;
struct inet_frag_queue;
struct user_struct;
struct exception_table_entry;
struct compat_sel_arg_struct;
struct module_use;
struct task_delay_info;
struct spinlock;
struct sigcontext;
struct uprobe_consumer;
struct iovec;
struct acpi_hest_aer_common;
struct ff_envelope;
struct kiocb;
struct statfs;
struct pipe_inode_info;
struct compat_itimerspec;
struct scsi_lun;
struct poll_table_struct;
struct fib_table;
struct kstatfs;
struct acpi_grt_info;
struct cdrom_read_audio;
struct inet_peer_base;
struct swap_info_struct;
struct file_lock;
struct buffer_head;
struct iattr;
struct percpu_counter;
struct rpmsg_device_id;
struct keyring_list;
struct acpi_einj_vendor;
struct iov_iter;
struct fs_disk_quota;
struct ifla_vf_vlan;
struct acpi_vendor_uuid;
struct fs_qfilestat;
struct Qdisc;
struct fs_quota_stat;
struct sigevent;
struct fprop_global;
struct aperfmperf;
struct dquot;
struct acpi_madt_local_x2apic;
struct qtree_fmt_operations;
struct tc_drr_stats;
struct tracepoint_func;
struct qtree_mem_dqinfo;
struct mem_cgroup;
struct page;
struct if_dqblk;
struct if_dqinfo;
struct compat_linux_dirent;
struct kqid;
union nf_inet_addr;
struct dentry_operations;
struct mem_dqblk;
struct xfrm_mark;
struct quota_format_type;
struct hlist_head;
struct sk_filter;
struct mem_dqinfo;
struct cgroup_scanner;
struct dqstats;
struct quota_format_ops;
struct llist_node;
struct apic;
struct dquot_operations;
struct softirq_action;
struct quota_info;
struct msr;
struct netpoll_info;
struct quota_module_name;
struct timeval;
struct address_space;
struct acpi_mpst_power_data;
struct compat_flock;
struct tcp_cookie_values;
struct fasync_struct;
struct key_user;
struct backing_dev_info;
struct cdrom_multisession;
struct statfs64;
struct lock_manager_operations;
struct f_owner_ex;
struct scsi_device;
struct flock;
struct input_id;
struct nf_ct_event_notifier;
struct xt_table;
struct ctl_table_root;
struct acpi_device_power_flags;
struct device_node;
struct acpi_resource_irq;
struct mii_ioctl_data;
struct compat_iovec;
struct wireless_dev;
struct i2c_device_id;
struct xattr_handler;
struct acpi_madt_local_x2apic_nmi;
struct ifla_vf_tx_rate;
struct tp_module;
struct rng_tfm;
struct task_struct;
struct block_device_operations;
struct fprop_local_single;
struct dyn_arch_ftrace;
struct compat_ipc64_perm;
struct kmem_cache_node;
struct sb_writers;
struct hd_struct;
struct compat_semid64_ds;
struct acpi_device_power;
struct hash_desc;
struct super_block;
struct compat_msqid64_ds;
struct bio;
struct compat_shmid64_ds;
struct xfrmu_sadhinfo;
struct tcf_proto;
struct filename;
struct linux_dirent64;
struct pvclock_vsyscall_time_info;
struct gendisk;
struct nf_hook_ops;
struct feature_header;
struct tree_descr;
struct mii_bus;
struct kmem_cache_order_objects;
struct ifreq;
struct netns_sysctl_ipv6;
struct gnet_stats_rate_est;
union IO_APIC_reg_00;
struct compat_itimerval;
struct ndmsg;
struct compat_tms;
struct tasklet_struct;
struct cgroup_taskset;
struct compat_timex;
struct kmem_cache_cpu;
struct posix_acl;
struct compat_rlimit;
struct cgroup_subsys;
struct sched_group;
struct compat_rusage;
struct request_sense;

enum { false_ = 0 , true_ = 1 } ;
enum { DUMP_PREFIX_NONE , DUMP_PREFIX_ADDRESS , DUMP_PREFIX_OFFSET } ;
enum ftrace_dump_mode { DUMP_NONE , DUMP_ALL , DUMP_ORIG , } ;
enum bug_trap_type { BUG_TRAP_TYPE_NONE = 0 , BUG_TRAP_TYPE_WARN = 1 , BUG_TRAP_TYPE_BUG = 2 , } ;
enum { GATE_INTERRUPT = 0xE , GATE_TRAP = 0xF , GATE_CALL = 0xC , GATE_TASK = 0x5 , } ;
enum { DESC_TSS = 0x9 , DESC_LDT = 0x2 , DESCTYPE_S = 0x10 , } ;
enum { PG_LEVEL_NONE , PG_LEVEL_4K , PG_LEVEL_2M , PG_LEVEL_1G , PG_LEVEL_NUM } ;
enum paravirt_lazy_mode { PARAVIRT_LAZY_NONE , PARAVIRT_LAZY_MMU , PARAVIRT_LAZY_CPU , } ;
struct user_desc ;
enum { UNAME26 = 0x0020000 , ADDR_NO_RANDOMIZE = 0x0040000 , FDPIC_FUNCPTRS = 0x0080000 , MMAP_PAGE_ZERO = 0x0100000 , ADDR_COMPAT_LAYOUT = 0x0200000 , READ_IMPLIES_EXEC = 0x0400000 , ADDR_LIMIT_32BIT = 0x0800000 , SHORT_INODE = 0x1000000 , WHOLE_SECONDS = 0x2000000 , STICKY_TIMEOUTS = 0x4000000 , ADDR_LIMIT_3GB = 0x8000000 , } ;
enum { PER_LINUX = 0x0000 , PER_LINUX_32BIT = 0x0000 | ADDR_LIMIT_32BIT , PER_LINUX_FDPIC = 0x0000 | FDPIC_FUNCPTRS , PER_SVR4 = 0x0001 | STICKY_TIMEOUTS | MMAP_PAGE_ZERO , PER_SVR3 = 0x0002 | STICKY_TIMEOUTS | SHORT_INODE , PER_SCOSVR3 = 0x0003 | STICKY_TIMEOUTS | WHOLE_SECONDS | SHORT_INODE , PER_OSR5 = 0x0003 | STICKY_TIMEOUTS | WHOLE_SECONDS , PER_WYSEV386 = 0x0004 | STICKY_TIMEOUTS | SHORT_INODE , PER_ISCR4 = 0x0005 | STICKY_TIMEOUTS , PER_BSD = 0x0006 , PER_SUNOS = 0x0006 | STICKY_TIMEOUTS , PER_XENIX = 0x0007 | STICKY_TIMEOUTS | SHORT_INODE , PER_LINUX32 = 0x0008 , PER_LINUX32_3GB = 0x0008 | ADDR_LIMIT_3GB , PER_IRIX32 = 0x0009 | STICKY_TIMEOUTS , PER_IRIXN32 = 0x000a | STICKY_TIMEOUTS , PER_IRIX64 = 0x000b | STICKY_TIMEOUTS , PER_RISCOS = 0x000c , PER_SOLARIS = 0x000d | STICKY_TIMEOUTS , PER_UW7 = 0x000e | STICKY_TIMEOUTS | MMAP_PAGE_ZERO , PER_OSF4 = 0x000f , PER_HPUX = 0x0010 , PER_MASK = 0x00ff , } ;
enum tlb_infos { ENTRIES , NR_INFO } ;
struct perf_event ;
enum idle_boot_override { IDLE_NO_OVERRIDE = 0 , IDLE_HALT , IDLE_NOMWAIT , IDLE_POLL , IDLE_FORCE_MWAIT } ;
struct dyn_arch_ftrace { } ;
struct lockdep_map ;
struct lock_class_key { } ;
struct tms ;
struct user_namespace ;
enum node_states { N_POSSIBLE , N_ONLINE , N_NORMAL_MEMORY , N_HIGH_MEMORY = N_NORMAL_MEMORY , N_MEMORY = N_HIGH_MEMORY , N_CPU , NR_NODE_STATES } ;
enum pageblock_bits { PB_migrate , PB_migrate_end = PB_migrate + 3 - 1 , PB_migrate_skip , NR_PAGEBLOCK_BITS } ;
enum { MIGRATE_UNMOVABLE , MIGRATE_RECLAIMABLE , MIGRATE_MOVABLE , MIGRATE_PCPTYPES , MIGRATE_RESERVE = MIGRATE_PCPTYPES , MIGRATE_ISOLATE , MIGRATE_TYPES } ;
enum zone_stat_item { NR_FREE_PAGES , NR_LRU_BASE , NR_INACTIVE_ANON = NR_LRU_BASE , NR_ACTIVE_ANON , NR_INACTIVE_FILE , NR_ACTIVE_FILE , NR_UNEVICTABLE , NR_MLOCK , NR_ANON_PAGES , NR_FILE_MAPPED , NR_FILE_PAGES , NR_FILE_DIRTY , NR_WRITEBACK , NR_SLAB_RECLAIMABLE , NR_SLAB_UNRECLAIMABLE , NR_PAGETABLE , NR_KERNEL_STACK , NR_UNSTABLE_NFS , NR_BOUNCE , NR_VMSCAN_WRITE , NR_VMSCAN_IMMEDIATE , NR_WRITEBACK_TEMP , NR_ISOLATED_ANON , NR_ISOLATED_FILE , NR_SHMEM , NR_DIRTIED , NR_WRITTEN , NUMA_HIT , NUMA_MISS , NUMA_FOREIGN , NUMA_INTERLEAVE_HIT , NUMA_LOCAL , NUMA_OTHER , NR_ANON_TRANSPARENT_HUGEPAGES , NR_FREE_CMA_PAGES , NR_VM_ZONE_STAT_ITEMS } ;
enum lru_list { LRU_INACTIVE_ANON = 0 , LRU_ACTIVE_ANON = 0 + 1 , LRU_INACTIVE_FILE = 0 + 2 , LRU_ACTIVE_FILE = 0 + 2 + 1 , LRU_UNEVICTABLE , NR_LRU_LISTS } ;
enum zone_watermarks { WMARK_MIN , WMARK_LOW , WMARK_HIGH , NR_WMARK } ;
enum zone_type { ZONE_DMA , ZONE_DMA32 , ZONE_NORMAL , ZONE_MOVABLE , __MAX_NR_ZONES } ;
struct bootmem_data ;
enum debug_obj_state { ODEBUG_STATE_NONE , ODEBUG_STATE_INIT , ODEBUG_STATE_INACTIVE , ODEBUG_STATE_ACTIVE , ODEBUG_STATE_DESTROYED , ODEBUG_STATE_NOTAVAILABLE , ODEBUG_STATE_MAX , } ;
struct tvec_base ;
struct workqueue_struct ;
enum { WORK_STRUCT_PENDING_BIT = 0 , WORK_STRUCT_DELAYED_BIT = 1 , WORK_STRUCT_CWQ_BIT = 2 , WORK_STRUCT_LINKED_BIT = 3 , WORK_STRUCT_COLOR_SHIFT = 4 , WORK_STRUCT_COLOR_BITS = 4 , WORK_STRUCT_PENDING = 1 << WORK_STRUCT_PENDING_BIT , WORK_STRUCT_DELAYED = 1 << WORK_STRUCT_DELAYED_BIT , WORK_STRUCT_CWQ = 1 << WORK_STRUCT_CWQ_BIT , WORK_STRUCT_LINKED = 1 << WORK_STRUCT_LINKED_BIT , WORK_STRUCT_STATIC = 0 , WORK_NR_COLORS = ( 1 << WORK_STRUCT_COLOR_BITS ) - 1 , WORK_NO_COLOR = WORK_NR_COLORS , WORK_CPU_UNBOUND = 256 , WORK_CPU_NONE = 256 + 1 , WORK_CPU_LAST = WORK_CPU_NONE , WORK_STRUCT_FLAG_BITS = WORK_STRUCT_COLOR_SHIFT + WORK_STRUCT_COLOR_BITS , WORK_OFFQ_FLAG_BASE = WORK_STRUCT_FLAG_BITS , WORK_OFFQ_CANCELING = ( 1 << WORK_OFFQ_FLAG_BASE ) , WORK_OFFQ_FLAG_BITS = 1 , WORK_OFFQ_CPU_SHIFT = WORK_OFFQ_FLAG_BASE + WORK_OFFQ_FLAG_BITS , WORK_STRUCT_FLAG_MASK = ( 1UL << WORK_STRUCT_FLAG_BITS ) - 1 , WORK_STRUCT_WQ_DATA_MASK = ~ WORK_STRUCT_FLAG_MASK , WORK_STRUCT_NO_CPU = ( unsigned long ) WORK_CPU_NONE << WORK_OFFQ_CPU_SHIFT , WORK_BUSY_PENDING = 1 << 0 , WORK_BUSY_RUNNING = 1 << 1 , } ;
enum { WQ_NON_REENTRANT = 1 << 0 , WQ_UNBOUND = 1 << 1 , WQ_FREEZABLE = 1 << 2 , WQ_MEM_RECLAIM = 1 << 3 , WQ_HIGHPRI = 1 << 4 , WQ_CPU_INTENSIVE = 1 << 5 , WQ_DRAINING = 1 << 6 , WQ_RESCUER = 1 << 7 , WQ_MAX_ACTIVE = 512 , WQ_MAX_UNBOUND_PER_CPU = 4 , WQ_DFL_ACTIVE = WQ_MAX_ACTIVE / 2 , } ;
struct memory_block ;
enum { MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE = 12 , SECTION_INFO = MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE , MIX_SECTION_INFO , NODE_INFO , MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE = NODE_INFO , } ;
enum { ONLINE_KEEP , ONLINE_KERNEL , ONLINE_MOVABLE , } ;
enum memmap_context { MEMMAP_EARLY , MEMMAP_HOTPLUG , } ;
enum mp_irq_source_types { mp_INT = 0 , mp_NMI = 1 , mp_SMI = 2 , mp_ExtINT = 3 } ;
enum mp_bustype { MP_BUS_ISA = 1 , MP_BUS_EISA , MP_BUS_PCI , } ;
enum { X86_SUBARCH_PC = 0 , X86_SUBARCH_LGUEST , X86_SUBARCH_XEN , X86_SUBARCH_MRST , X86_SUBARCH_CE4100 , X86_NR_SUBARCHS , } ;
enum ioapic_irq_destination_types { dest_Fixed = 0 , dest_LowestPrio = 1 , dest_SMI = 2 , dest__reserved_1 = 3 , dest_NMI = 4 , dest_INIT = 5 , dest__reserved_2 = 6 , dest_ExtINT = 7 } ;
enum rpm_status { RPM_ACTIVE = 0 , RPM_RESUMING , RPM_SUSPENDED , RPM_SUSPENDING , } ;
enum rpm_request { RPM_REQ_NONE = 0 , RPM_REQ_IDLE , RPM_REQ_SUSPEND , RPM_REQ_AUTOSUSPEND , RPM_REQ_RESUME , } ;
enum dpm_order { DPM_ORDER_NONE , DPM_ORDER_DEV_AFTER_PARENT , DPM_ORDER_PARENT_BEFORE_DEV , DPM_ORDER_DEV_LAST , } ;
enum xen_domain_type { XEN_NATIVE , XEN_PV_DOMAIN , XEN_HVM_DOMAIN , } ;
enum vsyscall_num { __NR_vgettimeofday , __NR_vtime , __NR_vgetcpu , } ;
struct page_cgroup ;
enum pcpu_fc { PCPU_FC_AUTO , PCPU_FC_EMBED , PCPU_FC_PAGE , PCPU_FC_NR , } ;
enum { CTL_KERN = 1 , CTL_VM = 2 , CTL_NET = 3 , CTL_PROC = 4 , CTL_FS = 5 , CTL_DEBUG = 6 , CTL_DEV = 7 , CTL_BUS = 8 , CTL_ABI = 9 , CTL_CPU = 10 , CTL_ARLAN = 254 , CTL_S390DBF = 5677 , CTL_SUNRPC = 7249 , CTL_PM = 9899 , CTL_FRV = 9898 , } ;
enum { CTL_BUS_ISA = 1 } ;
enum { INOTIFY_MAX_USER_INSTANCES = 1 , INOTIFY_MAX_USER_WATCHES = 2 , INOTIFY_MAX_QUEUED_EVENTS = 3 } ;
enum { KERN_OSTYPE = 1 , KERN_OSRELEASE = 2 , KERN_OSREV = 3 , KERN_VERSION = 4 , KERN_SECUREMASK = 5 , KERN_PROF = 6 , KERN_NODENAME = 7 , KERN_DOMAINNAME = 8 , KERN_PANIC = 15 , KERN_REALROOTDEV = 16 , KERN_SPARC_REBOOT = 21 , KERN_CTLALTDEL = 22 , KERN_PRINTK = 23 , KERN_NAMETRANS = 24 , KERN_PPC_HTABRECLAIM = 25 , KERN_PPC_ZEROPAGED = 26 , KERN_PPC_POWERSAVE_NAP = 27 , KERN_MODPROBE = 28 , KERN_SG_BIG_BUFF = 29 , KERN_ACCT = 30 , KERN_PPC_L2CR = 31 , KERN_RTSIGNR = 32 , KERN_RTSIGMAX = 33 , KERN_SHMMAX = 34 , KERN_MSGMAX = 35 , KERN_MSGMNB = 36 , KERN_MSGPOOL = 37 , KERN_SYSRQ = 38 , KERN_MAX_THREADS = 39 , KERN_RANDOM = 40 , KERN_SHMALL = 41 , KERN_MSGMNI = 42 , KERN_SEM = 43 , KERN_SPARC_STOP_A = 44 , KERN_SHMMNI = 45 , KERN_OVERFLOWUID = 46 , KERN_OVERFLOWGID = 47 , KERN_SHMPATH = 48 , KERN_HOTPLUG = 49 , KERN_IEEE_EMULATION_WARNINGS = 50 , KERN_S390_USER_DEBUG_LOGGING = 51 , KERN_CORE_USES_PID = 52 , KERN_TAINTED = 53 , KERN_CADPID = 54 , KERN_PIDMAX = 55 , KERN_CORE_PATTERN = 56 , KERN_PANIC_ON_OOPS = 57 , KERN_HPPA_PWRSW = 58 , KERN_HPPA_UNALIGNED = 59 , KERN_PRINTK_RATELIMIT = 60 , KERN_PRINTK_RATELIMIT_BURST = 61 , KERN_PTY = 62 , KERN_NGROUPS_MAX = 63 , KERN_SPARC_SCONS_PWROFF = 64 , KERN_HZ_TIMER = 65 , KERN_UNKNOWN_NMI_PANIC = 66 , KERN_BOOTLOADER_TYPE = 67 , KERN_RANDOMIZE = 68 , KERN_SETUID_DUMPABLE = 69 , KERN_SPIN_RETRY = 70 , KERN_ACPI_VIDEO_FLAGS = 71 , KERN_IA64_UNALIGNED = 72 , KERN_COMPAT_LOG = 73 , KERN_MAX_LOCK_DEPTH = 74 , KERN_NMI_WATCHDOG = 75 , KERN_PANIC_ON_NMI = 76 , } ;
enum { VM_UNUSED1 = 1 , VM_UNUSED2 = 2 , VM_UNUSED3 = 3 , VM_UNUSED4 = 4 , VM_OVERCOMMIT_MEMORY = 5 , VM_UNUSED5 = 6 , VM_UNUSED7 = 7 , VM_UNUSED8 = 8 , VM_UNUSED9 = 9 , VM_PAGE_CLUSTER = 10 , VM_DIRTY_BACKGROUND = 11 , VM_DIRTY_RATIO = 12 , VM_DIRTY_WB_CS = 13 , VM_DIRTY_EXPIRE_CS = 14 , VM_NR_PDFLUSH_THREADS = 15 , VM_OVERCOMMIT_RATIO = 16 , VM_PAGEBUF = 17 , VM_HUGETLB_PAGES = 18 , VM_SWAPPINESS = 19 , VM_LOWMEM_RESERVE_RATIO = 20 , VM_MIN_FREE_KBYTES = 21 , VM_MAX_MAP_COUNT = 22 , VM_LAPTOP_MODE = 23 , VM_BLOCK_DUMP = 24 , VM_HUGETLB_GROUP = 25 , VM_VFS_CACHE_PRESSURE = 26 , VM_LEGACY_VA_LAYOUT = 27 , VM_SWAP_TOKEN_TIMEOUT = 28 , VM_DROP_PAGECACHE = 29 , VM_PERCPU_PAGELIST_FRACTION = 30 , VM_ZONE_RECLAIM_MODE = 31 , VM_MIN_UNMAPPED = 32 , VM_PANIC_ON_OOM = 33 , VM_VDSO_ENABLED = 34 , VM_MIN_SLAB = 35 , } ;
enum { NET_CORE = 1 , NET_ETHER = 2 , NET_802 = 3 , NET_UNIX = 4 , NET_IPV4 = 5 , NET_IPX = 6 , NET_ATALK = 7 , NET_NETROM = 8 , NET_AX25 = 9 , NET_BRIDGE = 10 , NET_ROSE = 11 , NET_IPV6 = 12 , NET_X25 = 13 , NET_TR = 14 , NET_DECNET = 15 , NET_ECONET = 16 , NET_SCTP = 17 , NET_LLC = 18 , NET_NETFILTER = 19 , NET_DCCP = 20 , NET_IRDA = 412 , } ;
enum { RANDOM_POOLSIZE = 1 , RANDOM_ENTROPY_COUNT = 2 , RANDOM_READ_THRESH = 3 , RANDOM_WRITE_THRESH = 4 , RANDOM_BOOT_ID = 5 , RANDOM_UUID = 6 } ;
enum { PTY_MAX = 1 , PTY_NR = 2 } ;
enum { BUS_ISA_MEM_BASE = 1 , BUS_ISA_PORT_BASE = 2 , BUS_ISA_PORT_SHIFT = 3 } ;
enum { NET_CORE_WMEM_MAX = 1 , NET_CORE_RMEM_MAX = 2 , NET_CORE_WMEM_DEFAULT = 3 , NET_CORE_RMEM_DEFAULT = 4 , NET_CORE_MAX_BACKLOG = 6 , NET_CORE_FASTROUTE = 7 , NET_CORE_MSG_COST = 8 , NET_CORE_MSG_BURST = 9 , NET_CORE_OPTMEM_MAX = 10 , NET_CORE_HOT_LIST_LENGTH = 11 , NET_CORE_DIVERT_VERSION = 12 , NET_CORE_NO_CONG_THRESH = 13 , NET_CORE_NO_CONG = 14 , NET_CORE_LO_CONG = 15 , NET_CORE_MOD_CONG = 16 , NET_CORE_DEV_WEIGHT = 17 , NET_CORE_SOMAXCONN = 18 , NET_CORE_BUDGET = 19 , NET_CORE_AEVENT_ETIME = 20 , NET_CORE_AEVENT_RSEQTH = 21 , NET_CORE_WARNINGS = 22 , } ;
enum { NET_UNIX_DESTROY_DELAY = 1 , NET_UNIX_DELETE_DELAY = 2 , NET_UNIX_MAX_DGRAM_QLEN = 3 , } ;
enum { NET_NF_CONNTRACK_MAX = 1 , NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2 , NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3 , NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4 , NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5 , NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6 , NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7 , NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8 , NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9 , NET_NF_CONNTRACK_UDP_TIMEOUT = 10 , NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11 , NET_NF_CONNTRACK_ICMP_TIMEOUT = 12 , NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13 , NET_NF_CONNTRACK_BUCKETS = 14 , NET_NF_CONNTRACK_LOG_INVALID = 15 , NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16 , NET_NF_CONNTRACK_TCP_LOOSE = 17 , NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18 , NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19 , NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20 , NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21 , NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22 , NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23 , NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24 , NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25 , NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26 , NET_NF_CONNTRACK_COUNT = 27 , NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28 , NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29 , NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30 , NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31 , NET_NF_CONNTRACK_CHECKSUM = 32 , } ;
enum { NET_IPV4_FORWARD = 8 , NET_IPV4_DYNADDR = 9 , NET_IPV4_CONF = 16 , NET_IPV4_NEIGH = 17 , NET_IPV4_ROUTE = 18 , NET_IPV4_FIB_HASH = 19 , NET_IPV4_NETFILTER = 20 , NET_IPV4_TCP_TIMESTAMPS = 33 , NET_IPV4_TCP_WINDOW_SCALING = 34 , NET_IPV4_TCP_SACK = 35 , NET_IPV4_TCP_RETRANS_COLLAPSE = 36 , NET_IPV4_DEFAULT_TTL = 37 , NET_IPV4_AUTOCONFIG = 38 , NET_IPV4_NO_PMTU_DISC = 39 , NET_IPV4_TCP_SYN_RETRIES = 40 , NET_IPV4_IPFRAG_HIGH_THRESH = 41 , NET_IPV4_IPFRAG_LOW_THRESH = 42 , NET_IPV4_IPFRAG_TIME = 43 , NET_IPV4_TCP_MAX_KA_PROBES = 44 , NET_IPV4_TCP_KEEPALIVE_TIME = 45 , NET_IPV4_TCP_KEEPALIVE_PROBES = 46 , NET_IPV4_TCP_RETRIES1 = 47 , NET_IPV4_TCP_RETRIES2 = 48 , NET_IPV4_TCP_FIN_TIMEOUT = 49 , NET_IPV4_IP_MASQ_DEBUG = 50 , NET_TCP_SYNCOOKIES = 51 , NET_TCP_STDURG = 52 , NET_TCP_RFC1337 = 53 , NET_TCP_SYN_TAILDROP = 54 , NET_TCP_MAX_SYN_BACKLOG = 55 , NET_IPV4_LOCAL_PORT_RANGE = 56 , NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57 , NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58 , NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59 , NET_IPV4_ICMP_DESTUNREACH_RATE = 60 , NET_IPV4_ICMP_TIMEEXCEED_RATE = 61 , NET_IPV4_ICMP_PARAMPROB_RATE = 62 , NET_IPV4_ICMP_ECHOREPLY_RATE = 63 , NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64 , NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65 , NET_TCP_TW_RECYCLE = 66 , NET_IPV4_ALWAYS_DEFRAG = 67 , NET_IPV4_TCP_KEEPALIVE_INTVL = 68 , NET_IPV4_INET_PEER_THRESHOLD = 69 , NET_IPV4_INET_PEER_MINTTL = 70 , NET_IPV4_INET_PEER_MAXTTL = 71 , NET_IPV4_INET_PEER_GC_MINTIME = 72 , NET_IPV4_INET_PEER_GC_MAXTIME = 73 , NET_TCP_ORPHAN_RETRIES = 74 , NET_TCP_ABORT_ON_OVERFLOW = 75 , NET_TCP_SYNACK_RETRIES = 76 , NET_TCP_MAX_ORPHANS = 77 , NET_TCP_MAX_TW_BUCKETS = 78 , NET_TCP_FACK = 79 , NET_TCP_REORDERING = 80 , NET_TCP_ECN = 81 , NET_TCP_DSACK = 82 , NET_TCP_MEM = 83 , NET_TCP_WMEM = 84 , NET_TCP_RMEM = 85 , NET_TCP_APP_WIN = 86 , NET_TCP_ADV_WIN_SCALE = 87 , NET_IPV4_NONLOCAL_BIND = 88 , NET_IPV4_ICMP_RATELIMIT = 89 , NET_IPV4_ICMP_RATEMASK = 90 , NET_TCP_TW_REUSE = 91 , NET_TCP_FRTO = 92 , NET_TCP_LOW_LATENCY = 93 , NET_IPV4_IPFRAG_SECRET_INTERVAL = 94 , NET_IPV4_IGMP_MAX_MSF = 96 , NET_TCP_NO_METRICS_SAVE = 97 , NET_TCP_DEFAULT_WIN_SCALE = 105 , NET_TCP_MODERATE_RCVBUF = 106 , NET_TCP_TSO_WIN_DIVISOR = 107 , NET_TCP_BIC_BETA = 108 , NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109 , NET_TCP_CONG_CONTROL = 110 , NET_TCP_ABC = 111 , NET_IPV4_IPFRAG_MAX_DIST = 112 , NET_TCP_MTU_PROBING = 113 , NET_TCP_BASE_MSS = 114 , NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115 , NET_TCP_DMA_COPYBREAK = 116 , NET_TCP_SLOW_START_AFTER_IDLE = 117 , NET_CIPSOV4_CACHE_ENABLE = 118 , NET_CIPSOV4_CACHE_BUCKET_SIZE = 119 , NET_CIPSOV4_RBM_OPTFMT = 120 , NET_CIPSOV4_RBM_STRICTVALID = 121 , NET_TCP_AVAIL_CONG_CONTROL = 122 , NET_TCP_ALLOWED_CONG_CONTROL = 123 , NET_TCP_MAX_SSTHRESH = 124 , NET_TCP_FRTO_RESPONSE = 125 , } ;
enum { NET_IPV4_ROUTE_FLUSH = 1 , NET_IPV4_ROUTE_MIN_DELAY = 2 , NET_IPV4_ROUTE_MAX_DELAY = 3 , NET_IPV4_ROUTE_GC_THRESH = 4 , NET_IPV4_ROUTE_MAX_SIZE = 5 , NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6 , NET_IPV4_ROUTE_GC_TIMEOUT = 7 , NET_IPV4_ROUTE_GC_INTERVAL = 8 , NET_IPV4_ROUTE_REDIRECT_LOAD = 9 , NET_IPV4_ROUTE_REDIRECT_NUMBER = 10 , NET_IPV4_ROUTE_REDIRECT_SILENCE = 11 , NET_IPV4_ROUTE_ERROR_COST = 12 , NET_IPV4_ROUTE_ERROR_BURST = 13 , NET_IPV4_ROUTE_GC_ELASTICITY = 14 , NET_IPV4_ROUTE_MTU_EXPIRES = 15 , NET_IPV4_ROUTE_MIN_PMTU = 16 , NET_IPV4_ROUTE_MIN_ADVMSS = 17 , NET_IPV4_ROUTE_SECRET_INTERVAL = 18 , NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19 , } ;
enum { NET_PROTO_CONF_ALL = - 2 , NET_PROTO_CONF_DEFAULT = - 3 } ;
enum { NET_IPV4_CONF_FORWARDING = 1 , NET_IPV4_CONF_MC_FORWARDING = 2 , NET_IPV4_CONF_PROXY_ARP = 3 , NET_IPV4_CONF_ACCEPT_REDIRECTS = 4 , NET_IPV4_CONF_SECURE_REDIRECTS = 5 , NET_IPV4_CONF_SEND_REDIRECTS = 6 , NET_IPV4_CONF_SHARED_MEDIA = 7 , NET_IPV4_CONF_RP_FILTER = 8 , NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9 , NET_IPV4_CONF_BOOTP_RELAY = 10 , NET_IPV4_CONF_LOG_MARTIANS = 11 , NET_IPV4_CONF_TAG = 12 , NET_IPV4_CONF_ARPFILTER = 13 , NET_IPV4_CONF_MEDIUM_ID = 14 , NET_IPV4_CONF_NOXFRM = 15 , NET_IPV4_CONF_NOPOLICY = 16 , NET_IPV4_CONF_FORCE_IGMP_VERSION = 17 , NET_IPV4_CONF_ARP_ANNOUNCE = 18 , NET_IPV4_CONF_ARP_IGNORE = 19 , NET_IPV4_CONF_PROMOTE_SECONDARIES = 20 , NET_IPV4_CONF_ARP_ACCEPT = 21 , NET_IPV4_CONF_ARP_NOTIFY = 22 , } ;
enum { NET_IPV4_NF_CONNTRACK_MAX = 1 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9 , NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10 , NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11 , NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12 , NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13 , NET_IPV4_NF_CONNTRACK_BUCKETS = 14 , NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16 , NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17 , NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18 , NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26 , NET_IPV4_NF_CONNTRACK_COUNT = 27 , NET_IPV4_NF_CONNTRACK_CHECKSUM = 28 , } ;
enum { NET_IPV6_CONF = 16 , NET_IPV6_NEIGH = 17 , NET_IPV6_ROUTE = 18 , NET_IPV6_ICMP = 19 , NET_IPV6_BINDV6ONLY = 20 , NET_IPV6_IP6FRAG_HIGH_THRESH = 21 , NET_IPV6_IP6FRAG_LOW_THRESH = 22 , NET_IPV6_IP6FRAG_TIME = 23 , NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24 , NET_IPV6_MLD_MAX_MSF = 25 , } ;
enum { NET_IPV6_ROUTE_FLUSH = 1 , NET_IPV6_ROUTE_GC_THRESH = 2 , NET_IPV6_ROUTE_MAX_SIZE = 3 , NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4 , NET_IPV6_ROUTE_GC_TIMEOUT = 5 , NET_IPV6_ROUTE_GC_INTERVAL = 6 , NET_IPV6_ROUTE_GC_ELASTICITY = 7 , NET_IPV6_ROUTE_MTU_EXPIRES = 8 , NET_IPV6_ROUTE_MIN_ADVMSS = 9 , NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10 } ;
enum { NET_IPV6_FORWARDING = 1 , NET_IPV6_HOP_LIMIT = 2 , NET_IPV6_MTU = 3 , NET_IPV6_ACCEPT_RA = 4 , NET_IPV6_ACCEPT_REDIRECTS = 5 , NET_IPV6_AUTOCONF = 6 , NET_IPV6_DAD_TRANSMITS = 7 , NET_IPV6_RTR_SOLICITS = 8 , NET_IPV6_RTR_SOLICIT_INTERVAL = 9 , NET_IPV6_RTR_SOLICIT_DELAY = 10 , NET_IPV6_USE_TEMPADDR = 11 , NET_IPV6_TEMP_VALID_LFT = 12 , NET_IPV6_TEMP_PREFERED_LFT = 13 , NET_IPV6_REGEN_MAX_RETRY = 14 , NET_IPV6_MAX_DESYNC_FACTOR = 15 , NET_IPV6_MAX_ADDRESSES = 16 , NET_IPV6_FORCE_MLD_VERSION = 17 , NET_IPV6_ACCEPT_RA_DEFRTR = 18 , NET_IPV6_ACCEPT_RA_PINFO = 19 , NET_IPV6_ACCEPT_RA_RTR_PREF = 20 , NET_IPV6_RTR_PROBE_INTERVAL = 21 , NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22 , NET_IPV6_PROXY_NDP = 23 , NET_IPV6_ACCEPT_SOURCE_ROUTE = 25 , __NET_IPV6_MAX } ;
enum { NET_IPV6_ICMP_RATELIMIT = 1 } ;
enum { NET_NEIGH_MCAST_SOLICIT = 1 , NET_NEIGH_UCAST_SOLICIT = 2 , NET_NEIGH_APP_SOLICIT = 3 , NET_NEIGH_RETRANS_TIME = 4 , NET_NEIGH_REACHABLE_TIME = 5 , NET_NEIGH_DELAY_PROBE_TIME = 6 , NET_NEIGH_GC_STALE_TIME = 7 , NET_NEIGH_UNRES_QLEN = 8 , NET_NEIGH_PROXY_QLEN = 9 , NET_NEIGH_ANYCAST_DELAY = 10 , NET_NEIGH_PROXY_DELAY = 11 , NET_NEIGH_LOCKTIME = 12 , NET_NEIGH_GC_INTERVAL = 13 , NET_NEIGH_GC_THRESH1 = 14 , NET_NEIGH_GC_THRESH2 = 15 , NET_NEIGH_GC_THRESH3 = 16 , NET_NEIGH_RETRANS_TIME_MS = 17 , NET_NEIGH_REACHABLE_TIME_MS = 18 , } ;
enum { NET_DCCP_DEFAULT = 1 , } ;
enum { NET_IPX_PPROP_BROADCASTING = 1 , NET_IPX_FORWARDING = 2 } ;
enum { NET_LLC2 = 1 , NET_LLC_STATION = 2 , } ;
enum { NET_LLC2_TIMEOUT = 1 , } ;
enum { NET_LLC_STATION_ACK_TIMEOUT = 1 , } ;
enum { NET_LLC2_ACK_TIMEOUT = 1 , NET_LLC2_P_TIMEOUT = 2 , NET_LLC2_REJ_TIMEOUT = 3 , NET_LLC2_BUSY_TIMEOUT = 4 , } ;
enum { NET_ATALK_AARP_EXPIRY_TIME = 1 , NET_ATALK_AARP_TICK_TIME = 2 , NET_ATALK_AARP_RETRANSMIT_LIMIT = 3 , NET_ATALK_AARP_RESOLVE_TIME = 4 } ;
enum { NET_NETROM_DEFAULT_PATH_QUALITY = 1 , NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2 , NET_NETROM_NETWORK_TTL_INITIALISER = 3 , NET_NETROM_TRANSPORT_TIMEOUT = 4 , NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5 , NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6 , NET_NETROM_TRANSPORT_BUSY_DELAY = 7 , NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8 , NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9 , NET_NETROM_ROUTING_CONTROL = 10 , NET_NETROM_LINK_FAILS_COUNT = 11 , NET_NETROM_RESET = 12 } ;
enum { NET_AX25_IP_DEFAULT_MODE = 1 , NET_AX25_DEFAULT_MODE = 2 , NET_AX25_BACKOFF_TYPE = 3 , NET_AX25_CONNECT_MODE = 4 , NET_AX25_STANDARD_WINDOW = 5 , NET_AX25_EXTENDED_WINDOW = 6 , NET_AX25_T1_TIMEOUT = 7 , NET_AX25_T2_TIMEOUT = 8 , NET_AX25_T3_TIMEOUT = 9 , NET_AX25_IDLE_TIMEOUT = 10 , NET_AX25_N2 = 11 , NET_AX25_PACLEN = 12 , NET_AX25_PROTOCOL = 13 , NET_AX25_DAMA_SLAVE_TIMEOUT = 14 } ;
enum { NET_ROSE_RESTART_REQUEST_TIMEOUT = 1 , NET_ROSE_CALL_REQUEST_TIMEOUT = 2 , NET_ROSE_RESET_REQUEST_TIMEOUT = 3 , NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4 , NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5 , NET_ROSE_ROUTING_CONTROL = 6 , NET_ROSE_LINK_FAIL_TIMEOUT = 7 , NET_ROSE_MAX_VCS = 8 , NET_ROSE_WINDOW_SIZE = 9 , NET_ROSE_NO_ACTIVITY_TIMEOUT = 10 } ;
enum { NET_X25_RESTART_REQUEST_TIMEOUT = 1 , NET_X25_CALL_REQUEST_TIMEOUT = 2 , NET_X25_RESET_REQUEST_TIMEOUT = 3 , NET_X25_CLEAR_REQUEST_TIMEOUT = 4 , NET_X25_ACK_HOLD_BACK_TIMEOUT = 5 , NET_X25_FORWARD = 6 } ;
enum { NET_TR_RIF_TIMEOUT = 1 } ;
enum { NET_DECNET_NODE_TYPE = 1 , NET_DECNET_NODE_ADDRESS = 2 , NET_DECNET_NODE_NAME = 3 , NET_DECNET_DEFAULT_DEVICE = 4 , NET_DECNET_TIME_WAIT = 5 , NET_DECNET_DN_COUNT = 6 , NET_DECNET_DI_COUNT = 7 , NET_DECNET_DR_COUNT = 8 , NET_DECNET_DST_GC_INTERVAL = 9 , NET_DECNET_CONF = 10 , NET_DECNET_NO_FC_MAX_CWND = 11 , NET_DECNET_MEM = 12 , NET_DECNET_RMEM = 13 , NET_DECNET_WMEM = 14 , NET_DECNET_DEBUG_LEVEL = 255 } ;
enum { NET_DECNET_CONF_LOOPBACK = - 2 , NET_DECNET_CONF_DDCMP = - 3 , NET_DECNET_CONF_PPP = - 4 , NET_DECNET_CONF_X25 = - 5 , NET_DECNET_CONF_GRE = - 6 , NET_DECNET_CONF_ETHER = - 7 } ;
enum { NET_DECNET_CONF_DEV_PRIORITY = 1 , NET_DECNET_CONF_DEV_T1 = 2 , NET_DECNET_CONF_DEV_T2 = 3 , NET_DECNET_CONF_DEV_T3 = 4 , NET_DECNET_CONF_DEV_FORWARDING = 5 , NET_DECNET_CONF_DEV_BLKSIZE = 6 , NET_DECNET_CONF_DEV_STATE = 7 } ;
enum { NET_SCTP_RTO_INITIAL = 1 , NET_SCTP_RTO_MIN = 2 , NET_SCTP_RTO_MAX = 3 , NET_SCTP_RTO_ALPHA = 4 , NET_SCTP_RTO_BETA = 5 , NET_SCTP_VALID_COOKIE_LIFE = 6 , NET_SCTP_ASSOCIATION_MAX_RETRANS = 7 , NET_SCTP_PATH_MAX_RETRANS = 8 , NET_SCTP_MAX_INIT_RETRANSMITS = 9 , NET_SCTP_HB_INTERVAL = 10 , NET_SCTP_PRESERVE_ENABLE = 11 , NET_SCTP_MAX_BURST = 12 , NET_SCTP_ADDIP_ENABLE = 13 , NET_SCTP_PRSCTP_ENABLE = 14 , NET_SCTP_SNDBUF_POLICY = 15 , NET_SCTP_SACK_TIMEOUT = 16 , NET_SCTP_RCVBUF_POLICY = 17 , } ;
enum { NET_BRIDGE_NF_CALL_ARPTABLES = 1 , NET_BRIDGE_NF_CALL_IPTABLES = 2 , NET_BRIDGE_NF_CALL_IP6TABLES = 3 , NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4 , NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5 , } ;
enum { NET_IRDA_DISCOVERY = 1 , NET_IRDA_DEVNAME = 2 , NET_IRDA_DEBUG = 3 , NET_IRDA_FAST_POLL = 4 , NET_IRDA_DISCOVERY_SLOTS = 5 , NET_IRDA_DISCOVERY_TIMEOUT = 6 , NET_IRDA_SLOT_TIMEOUT = 7 , NET_IRDA_MAX_BAUD_RATE = 8 , NET_IRDA_MIN_TX_TURN_TIME = 9 , NET_IRDA_MAX_TX_DATA_SIZE = 10 , NET_IRDA_MAX_TX_WINDOW = 11 , NET_IRDA_MAX_NOREPLY_TIME = 12 , NET_IRDA_WARN_NOREPLY_TIME = 13 , NET_IRDA_LAP_KEEPALIVE_TIME = 14 , } ;
enum { FS_NRINODE = 1 , FS_STATINODE = 2 , FS_MAXINODE = 3 , FS_NRDQUOT = 4 , FS_MAXDQUOT = 5 , FS_NRFILE = 6 , FS_MAXFILE = 7 , FS_DENTRY = 8 , FS_NRSUPER = 9 , FS_MAXSUPER = 10 , FS_OVERFLOWUID = 11 , FS_OVERFLOWGID = 12 , FS_LEASES = 13 , FS_DIR_NOTIFY = 14 , FS_LEASE_TIME = 15 , FS_DQSTATS = 16 , FS_XFS = 17 , FS_AIO_NR = 18 , FS_AIO_MAX_NR = 19 , FS_INOTIFY = 20 , FS_OCFS2 = 988 , } ;
enum { FS_DQ_LOOKUPS = 1 , FS_DQ_DROPS = 2 , FS_DQ_READS = 3 , FS_DQ_WRITES = 4 , FS_DQ_CACHE_HITS = 5 , FS_DQ_ALLOCATED = 6 , FS_DQ_FREE = 7 , FS_DQ_SYNCS = 8 , FS_DQ_WARNINGS = 9 , } ;
enum { DEV_CDROM = 1 , DEV_HWMON = 2 , DEV_PARPORT = 3 , DEV_RAID = 4 , DEV_MAC_HID = 5 , DEV_SCSI = 6 , DEV_IPMI = 7 , } ;
enum { DEV_CDROM_INFO = 1 , DEV_CDROM_AUTOCLOSE = 2 , DEV_CDROM_AUTOEJECT = 3 , DEV_CDROM_DEBUG = 4 , DEV_CDROM_LOCK = 5 , DEV_CDROM_CHECK_MEDIA = 6 } ;
enum { DEV_PARPORT_DEFAULT = - 3 } ;
enum { DEV_RAID_SPEED_LIMIT_MIN = 1 , DEV_RAID_SPEED_LIMIT_MAX = 2 } ;
enum { DEV_PARPORT_DEFAULT_TIMESLICE = 1 , DEV_PARPORT_DEFAULT_SPINTIME = 2 } ;
enum { DEV_PARPORT_SPINTIME = 1 , DEV_PARPORT_BASE_ADDR = 2 , DEV_PARPORT_IRQ = 3 , DEV_PARPORT_DMA = 4 , DEV_PARPORT_MODES = 5 , DEV_PARPORT_DEVICES = 6 , DEV_PARPORT_AUTOPROBE = 16 } ;
enum { DEV_PARPORT_DEVICES_ACTIVE = - 3 , } ;
enum { DEV_PARPORT_DEVICE_TIMESLICE = 1 , } ;
enum { DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1 , DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2 , DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3 , DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4 , DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5 , DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6 } ;
enum { DEV_SCSI_LOGGING_LEVEL = 1 , } ;
enum { DEV_IPMI_POWEROFF_POWERCYCLE = 1 , } ;
enum { ABI_DEFHANDLER_COFF = 1 , ABI_DEFHANDLER_ELF = 2 , ABI_DEFHANDLER_LCALL7 = 3 , ABI_DEFHANDLER_LIBCSO = 4 , ABI_TRACE = 5 , ABI_FAKE_UTSNAME = 6 , } ;
enum umh_disable_depth { UMH_ENABLED = 0 , UMH_FREEZING , UMH_DISABLED , } ;
struct linux_binprm ;
enum align_flags { ALIGN_VA_32 = ( 1UL << ( 0 ) ) , ALIGN_VA_64 = ( 1UL << ( 1 ) ) , } ;
enum kobj_ns_type { KOBJ_NS_TYPE_NONE = 0 , KOBJ_NS_TYPE_NET , KOBJ_NS_TYPES } ;
enum kobj_ns_type ;
struct sysfs_dirent ;
enum kobject_action { KOBJ_ADD , KOBJ_REMOVE , KOBJ_CHANGE , KOBJ_MOVE , KOBJ_ONLINE , KOBJ_OFFLINE , KOBJ_MAX } ;
enum jump_label_type { JUMP_LABEL_DISABLE = 0 , JUMP_LABEL_ENABLE , } ;
struct mod_arch_specific { } ;
enum module_state { MODULE_STATE_LIVE , MODULE_STATE_COMING , MODULE_STATE_GOING , MODULE_STATE_UNFORMED , } ;
enum hrtimer_mode { HRTIMER_MODE_ABS = 0x0 , HRTIMER_MODE_REL = 0x1 , HRTIMER_MODE_PINNED = 0x02 , HRTIMER_MODE_ABS_PINNED = 0x02 , HRTIMER_MODE_REL_PINNED = 0x03 , } ;
enum hrtimer_restart { HRTIMER_NORESTART , HRTIMER_RESTART , } ;
enum hrtimer_base_type { HRTIMER_BASE_MONOTONIC , HRTIMER_BASE_REALTIME , HRTIMER_BASE_BOOTTIME , HRTIMER_MAX_CLOCK_BASES , } ;
enum dentry_d_lock_class { DENTRY_D_LOCK_NORMAL , DENTRY_D_LOCK_NESTED } ;
enum pid_type { PIDTYPE_PID , PIDTYPE_PGID , PIDTYPE_SID , PIDTYPE_MAX } ;
struct pid_namespace ;
struct user_namespace ;
enum migrate_mode { MIGRATE_ASYNC , MIGRATE_SYNC_LIGHT , MIGRATE_SYNC , } ;
enum rq_flag_bits { __REQ_WRITE , __REQ_FAILFAST_DEV , __REQ_FAILFAST_TRANSPORT , __REQ_FAILFAST_DRIVER , __REQ_SYNC , __REQ_META , __REQ_PRIO , __REQ_DISCARD , __REQ_SECURE , __REQ_WRITE_SAME , __REQ_NOIDLE , __REQ_FUA , __REQ_FLUSH , __REQ_RAHEAD , __REQ_THROTTLED , __REQ_SORTED , __REQ_SOFTBARRIER , __REQ_NOMERGE , __REQ_STARTED , __REQ_DONTPREP , __REQ_QUEUED , __REQ_ELVPRIV , __REQ_FAILED , __REQ_QUIET , __REQ_PREEMPT , __REQ_ALLOCED , __REQ_COPY_USER , __REQ_FLUSH_SEQ , __REQ_IO_STAT , __REQ_MIXED_MERGE , __REQ_KERNEL , __REQ_NR_BITS , } ;
struct hd_geometry ;
struct pipe_inode_info ;
struct user_namespace ;
enum { QIF_BLIMITS_B = 0 , QIF_SPACE_B , QIF_ILIMITS_B , QIF_INODES_B , QIF_BTIME_B , QIF_ITIME_B , } ;
enum { QUOTA_NL_C_UNSPEC , QUOTA_NL_C_WARNING , __QUOTA_NL_C_MAX , } ;
enum { QUOTA_NL_A_UNSPEC , QUOTA_NL_A_QTYPE , QUOTA_NL_A_EXCESS_ID , QUOTA_NL_A_WARNING , QUOTA_NL_A_DEV_MAJOR , QUOTA_NL_A_DEV_MINOR , QUOTA_NL_A_CAUSED_ID , __QUOTA_NL_A_MAX , } ;
enum quota_type { USRQUOTA = 0 , GRPQUOTA = 1 , PRJQUOTA = 2 , } ;
enum { DQST_LOOKUPS , DQST_DROPS , DQST_READS , DQST_WRITES , DQST_CACHE_HITS , DQST_ALLOC_DQUOTS , DQST_FREE_DQUOTS , DQST_SYNCS , _DQST_DQSTAT_LAST } ;
enum { _DQUOT_USAGE_ENABLED = 0 , _DQUOT_LIMITS_ENABLED , _DQUOT_SUSPENDED , _DQUOT_STATE_FLAGS } ;
enum positive_aop_returns { AOP_WRITEPAGE_ACTIVATE = 0x80000 , AOP_TRUNCATED_PAGE = 0x80001 , } ;
enum inode_i_mutex_lock_class { I_MUTEX_NORMAL , I_MUTEX_PARENT , I_MUTEX_CHILD , I_MUTEX_XATTR , I_MUTEX_QUOTA } ;
struct nlm_lockowner ;
struct nfs4_lock_state ;
enum { SB_UNFROZEN = 0 , SB_FREEZE_WRITE = 1 , SB_FREEZE_PAGEFAULT = 2 , SB_FREEZE_FS = 3 , SB_FREEZE_COMPLETE = 4 , } ;
enum file_time_flags { S_ATIME = 1 , S_MTIME = 2 , S_CTIME = 4 , S_VERSION = 8 , } ;
struct audit_names ;
enum { FILE_CREATED = 1 , FILE_OPENED = 2 } ;
enum { DIO_LOCKING = 0x01 , DIO_SKIP_HOLES = 0x02 , } ;
struct mem_cgroup ;
enum stat_item { ALLOC_FASTPATH , ALLOC_SLOWPATH , FREE_FASTPATH , FREE_SLOWPATH , FREE_FROZEN , FREE_ADD_PARTIAL , FREE_REMOVE_PARTIAL , ALLOC_FROM_PARTIAL , ALLOC_SLAB , ALLOC_REFILL , ALLOC_NODE_MISMATCH , FREE_SLAB , CPUSLAB_FLUSH , DEACTIVATE_FULL , DEACTIVATE_EMPTY , DEACTIVATE_TO_HEAD , DEACTIVATE_TO_TAIL , DEACTIVATE_REMOTE_FREES , DEACTIVATE_BYPASS , ORDER_FALLBACK , CMPXCHG_DOUBLE_CPU_FAIL , CMPXCHG_DOUBLE_FAIL , CPU_PARTIAL_ALLOC , CPU_PARTIAL_FREE , CPU_PARTIAL_NODE , CPU_PARTIAL_DRAIN , NR_SLUB_STAT_ITEMS } ;
enum { PROC_ROOT_INO = 1 , PROC_IPC_INIT_INO = 0xEFFFFFFFU , PROC_UTS_INIT_INO = 0xEFFFFFFEU , PROC_USER_INIT_INO = 0xEFFFFFFDU , PROC_PID_INIT_INO = 0xEFFFFFFCU , } ;
enum kcore_type { KCORE_TEXT , KCORE_VMALLOC , KCORE_RAM , KCORE_VMEMMAP , KCORE_OTHER , } ;
struct pid_namespace ;
struct tty_driver ;
struct pdev_archdata { } ;
struct device_private ;
struct driver_private ;
struct subsys_private ;
struct device_node ;
struct iommu_ops ;
struct iommu_group ;
struct class_compat ;
enum clock_event_mode { CLOCK_EVT_MODE_UNUSED = 0 , CLOCK_EVT_MODE_SHUTDOWN , CLOCK_EVT_MODE_PERIODIC , CLOCK_EVT_MODE_ONESHOT , CLOCK_EVT_MODE_RESUME , } ;
enum clock_event_nofitiers { CLOCK_EVT_NOTIFY_ADD , CLOCK_EVT_NOTIFY_BROADCAST_ON , CLOCK_EVT_NOTIFY_BROADCAST_OFF , CLOCK_EVT_NOTIFY_BROADCAST_FORCE , CLOCK_EVT_NOTIFY_BROADCAST_ENTER , CLOCK_EVT_NOTIFY_BROADCAST_EXIT , CLOCK_EVT_NOTIFY_SUSPEND , CLOCK_EVT_NOTIFY_RESUME , CLOCK_EVT_NOTIFY_CPU_DYING , CLOCK_EVT_NOTIFY_CPU_DEAD , } ;
enum tick_device_mode { TICKDEV_MODE_PERIODIC , TICKDEV_MODE_ONESHOT , } ;
enum tick_nohz_mode { NOHZ_MODE_INACTIVE , NOHZ_MODE_LOWRES , NOHZ_MODE_HIGHRES , } ;
enum dmi_field { DMI_NONE , DMI_BIOS_VENDOR , DMI_BIOS_VERSION , DMI_BIOS_DATE , DMI_SYS_VENDOR , DMI_PRODUCT_NAME , DMI_PRODUCT_VERSION , DMI_PRODUCT_SERIAL , DMI_PRODUCT_UUID , DMI_BOARD_VENDOR , DMI_BOARD_NAME , DMI_BOARD_VERSION , DMI_BOARD_SERIAL , DMI_BOARD_ASSET_TAG , DMI_CHASSIS_VENDOR , DMI_CHASSIS_TYPE , DMI_CHASSIS_VERSION , DMI_CHASSIS_SERIAL , DMI_CHASSIS_ASSET_TAG , DMI_STRING_MAX , } ;
enum irqreturn { IRQ_NONE = ( 0 << 0 ) , IRQ_HANDLED = ( 1 << 0 ) , IRQ_WAKE_THREAD = ( 1 << 1 ) , } ;
enum pci_mmap_state { pci_mmap_io , pci_mmap_mem } ;
enum { PCI_STD_RESOURCES , PCI_STD_RESOURCE_END = 5 , PCI_ROM_RESOURCE , PCI_IOV_RESOURCES , PCI_IOV_RESOURCE_END = PCI_IOV_RESOURCES + 6 - 1 , PCI_BRIDGE_RESOURCES , PCI_BRIDGE_RESOURCE_END = PCI_BRIDGE_RESOURCES + 4 - 1 , PCI_NUM_RESOURCES , DEVICE_COUNT_RESOURCE = PCI_NUM_RESOURCES , } ;
enum pci_irq_reroute_variant { INTEL_IRQ_REROUTE_VARIANT = 1 , MAX_IRQ_REROUTE_VARIANTS = 3 } ;
enum pci_bus_speed { PCI_SPEED_33MHz = 0x00 , PCI_SPEED_66MHz = 0x01 , PCI_SPEED_66MHz_PCIX = 0x02 , PCI_SPEED_100MHz_PCIX = 0x03 , PCI_SPEED_133MHz_PCIX = 0x04 , PCI_SPEED_66MHz_PCIX_ECC = 0x05 , PCI_SPEED_100MHz_PCIX_ECC = 0x06 , PCI_SPEED_133MHz_PCIX_ECC = 0x07 , PCI_SPEED_66MHz_PCIX_266 = 0x09 , PCI_SPEED_100MHz_PCIX_266 = 0x0a , PCI_SPEED_133MHz_PCIX_266 = 0x0b , AGP_UNKNOWN = 0x0c , AGP_1X = 0x0d , AGP_2X = 0x0e , AGP_4X = 0x0f , AGP_8X = 0x10 , PCI_SPEED_66MHz_PCIX_533 = 0x11 , PCI_SPEED_100MHz_PCIX_533 = 0x12 , PCI_SPEED_133MHz_PCIX_533 = 0x13 , PCIE_SPEED_2_5GT = 0x14 , PCIE_SPEED_5_0GT = 0x15 , PCIE_SPEED_8_0GT = 0x16 , PCI_SPEED_UNKNOWN = 0xff , } ;
struct pcie_link_state ;
struct pci_vpd ;
struct pci_sriov ;
struct pci_ats ;
enum pcie_bus_config_types { PCIE_BUS_TUNE_OFF , PCIE_BUS_SAFE , PCIE_BUS_PERFORMANCE , PCIE_BUS_PEER2PEER , } ;
enum pci_lost_interrupt_reason { PCI_LOST_IRQ_NO_INFORMATION = 0 , PCI_LOST_IRQ_DISABLE_MSI , PCI_LOST_IRQ_DISABLE_MSIX , PCI_LOST_IRQ_DISABLE_ACPI , } ;
enum pci_obff_signal_type { PCI_EXP_OBFF_SIGNAL_L0 = 0 , PCI_EXP_OBFF_SIGNAL_ALWAYS = 1 , } ;
enum pci_dma_burst_strategy { PCI_DMA_BURST_INFINITY , PCI_DMA_BURST_BOUNDARY , PCI_DMA_BURST_MULTIPLE , } ;
enum page_debug_flags { PAGE_DEBUG_FLAG_POISON , PAGE_DEBUG_FLAG_GUARD , } ;
struct uprobes_state { } ;
enum { MM_FILEPAGES , MM_ANONPAGES , MM_SWAPENTS , NR_MM_COUNTERS } ;
struct mempolicy ;
struct anon_vma ;
struct anon_vma_chain ;
struct mmu_gather ;
enum pageflags { PG_locked , PG_error , PG_referenced , PG_uptodate , PG_dirty , PG_lru , PG_active , PG_slab , PG_owner_priv_1 , PG_arch_1 , PG_reserved , PG_private , PG_private_2 , PG_writeback , PG_head , PG_tail , PG_swapcache , PG_mappedtodisk , PG_reclaim , PG_swapbacked , PG_unevictable , PG_mlocked , PG_uncached , PG_hwpoison , PG_compound_lock , __NR_PAGEFLAGS , PG_checked = PG_owner_priv_1 , PG_fscache = PG_private_2 , PG_pinned = PG_owner_priv_1 , PG_savepinned = PG_dirty , PG_slob_free = PG_private , } ;
enum transparent_hugepage_flag { TRANSPARENT_HUGEPAGE_FLAG , TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG , TRANSPARENT_HUGEPAGE_DEFRAG_FLAG , TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG , TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG , TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG , } ;
enum page_check_address_pmd_flag { PAGE_CHECK_ADDRESS_PMD_FLAG , PAGE_CHECK_ADDRESS_PMD_NOTSPLITTING_FLAG , PAGE_CHECK_ADDRESS_PMD_SPLITTING_FLAG , } ;
enum vm_event_item { PGPGIN , PGPGOUT , PSWPIN , PSWPOUT , PGALLOC_DMA , PGALLOC_DMA32 , PGALLOC_NORMAL , PGALLOC_MOVABLE , PGFREE , PGACTIVATE , PGDEACTIVATE , PGFAULT , PGMAJFAULT , PGREFILL_DMA , PGREFILL_DMA32 , PGREFILL_NORMAL , PGREFILL_MOVABLE , PGSTEAL_KSWAPD_DMA , PGSTEAL_KSWAPD_DMA32 , PGSTEAL_KSWAPD_NORMAL , PGSTEAL_KSWAPD_MOVABLE , PGSTEAL_DIRECT_DMA , PGSTEAL_DIRECT_DMA32 , PGSTEAL_DIRECT_NORMAL , PGSTEAL_DIRECT_MOVABLE , PGSCAN_KSWAPD_DMA , PGSCAN_KSWAPD_DMA32 , PGSCAN_KSWAPD_NORMAL , PGSCAN_KSWAPD_MOVABLE , PGSCAN_DIRECT_DMA , PGSCAN_DIRECT_DMA32 , PGSCAN_DIRECT_NORMAL , PGSCAN_DIRECT_MOVABLE , PGSCAN_DIRECT_THROTTLE , PGSCAN_ZONE_RECLAIM_FAILED , PGINODESTEAL , SLABS_SCANNED , KSWAPD_INODESTEAL , KSWAPD_LOW_WMARK_HIT_QUICKLY , KSWAPD_HIGH_WMARK_HIT_QUICKLY , KSWAPD_SKIP_CONGESTION_WAIT , PAGEOUTRUN , ALLOCSTALL , PGROTATED , PGMIGRATE_SUCCESS , PGMIGRATE_FAIL , COMPACTMIGRATE_SCANNED , COMPACTFREE_SCANNED , COMPACTISOLATED , COMPACTSTALL , COMPACTFAIL , COMPACTSUCCESS , HTLB_BUDDY_PGALLOC , HTLB_BUDDY_PGALLOC_FAIL , UNEVICTABLE_PGCULLED , UNEVICTABLE_PGSCANNED , UNEVICTABLE_PGRESCUED , UNEVICTABLE_PGMLOCKED , UNEVICTABLE_PGMUNLOCKED , UNEVICTABLE_PGCLEARED , UNEVICTABLE_PGSTRANDED , THP_FAULT_ALLOC , THP_FAULT_FALLBACK , THP_COLLAPSE_ALLOC , THP_COLLAPSE_ALLOC_FAILED , THP_SPLIT , THP_ZERO_PAGE_ALLOC , THP_ZERO_PAGE_ALLOC_FAILED , NR_VM_EVENT_ITEMS } ;
enum mf_flags { MF_COUNT_INCREASED = 1 << 0 , MF_ACTION_REQUIRED = 1 << 1 , MF_MUST_KILL = 1 << 2 , } ;
enum dma_attr { DMA_ATTR_WRITE_BARRIER , DMA_ATTR_WEAK_ORDERING , DMA_ATTR_WRITE_COMBINE , DMA_ATTR_NON_CONSISTENT , DMA_ATTR_NO_KERNEL_MAPPING , DMA_ATTR_SKIP_CPU_SYNC , DMA_ATTR_FORCE_CONTIGUOUS , DMA_ATTR_MAX , } ;
enum dma_data_direction { DMA_BIDIRECTIONAL = 0 , DMA_TO_DEVICE = 1 , DMA_FROM_DEVICE = 2 , DMA_NONE = 3 , } ;
enum dma_sync_target { SYNC_FOR_CPU = 0 , SYNC_FOR_DEVICE = 1 , } ;
struct cma ;
enum pci_fixup_pass { pci_fixup_early , pci_fixup_header , pci_fixup_final , pci_fixup_enable , pci_fixup_resume , pci_fixup_suspend , pci_fixup_resume_early , } ;
struct seccomp_filter ;
struct rt_mutex_waiter ;
struct key_type ;
struct key_owner ;
struct keyring_list ;
struct keyring_name ;
struct selinux_audit_rule ;
struct audit_context ;
struct futex_pi_state ;
struct robust_list_head ;
struct fs_struct ;
struct perf_event_context ;
struct cfs_rq ;
struct task_group ;
struct user_namespace ;
enum { IOCB_CMD_PREAD = 0 , IOCB_CMD_PWRITE = 1 , IOCB_CMD_FSYNC = 2 , IOCB_CMD_FDSYNC = 3 , IOCB_CMD_NOOP = 6 , IOCB_CMD_PREADV = 7 , IOCB_CMD_PWRITEV = 8 , } ;
struct autogroup ;
enum cpu_idle_type { CPU_IDLE , CPU_NOT_IDLE , CPU_NEWLY_IDLE , CPU_MAX_IDLE_TYPES } ;
struct audit_context ;
struct mempolicy ;
struct pipe_inode_info ;
struct uts_namespace ;
struct rq ;
struct rcu_node ;
enum perf_event_task_context { perf_invalid_context = - 1 , perf_hw_context = 0 , perf_sw_context , perf_nr_task_contexts , } ;
struct pid_namespace ;
enum sched_tunable_scaling { SCHED_TUNABLESCALING_NONE , SCHED_TUNABLESCALING_LOG , SCHED_TUNABLESCALING_LINEAR , SCHED_TUNABLESCALING_END , } ;
enum { IRQ_TYPE_NONE = 0x00000000 , IRQ_TYPE_EDGE_RISING = 0x00000001 , IRQ_TYPE_EDGE_FALLING = 0x00000002 , IRQ_TYPE_EDGE_BOTH = ( IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING ) , IRQ_TYPE_LEVEL_HIGH = 0x00000004 , IRQ_TYPE_LEVEL_LOW = 0x00000008 , IRQ_TYPE_LEVEL_MASK = ( IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH ) , IRQ_TYPE_SENSE_MASK = 0x0000000f , IRQ_TYPE_DEFAULT = IRQ_TYPE_SENSE_MASK , IRQ_TYPE_PROBE = 0x00000010 , IRQ_LEVEL = ( 1 << 8 ) , IRQ_PER_CPU = ( 1 << 9 ) , IRQ_NOPROBE = ( 1 << 10 ) , IRQ_NOREQUEST = ( 1 << 11 ) , IRQ_NOAUTOEN = ( 1 << 12 ) , IRQ_NO_BALANCING = ( 1 << 13 ) , IRQ_MOVE_PCNTXT = ( 1 << 14 ) , IRQ_NESTED_THREAD = ( 1 << 15 ) , IRQ_NOTHREAD = ( 1 << 16 ) , IRQ_PER_CPU_DEVID = ( 1 << 17 ) , } ;
enum { IRQ_SET_MASK_OK = 0 , IRQ_SET_MASK_OK_NOCOPY , } ;
struct msi_desc ;
struct irq_domain ;
enum { IRQD_TRIGGER_MASK = 0xf , IRQD_SETAFFINITY_PENDING = ( 1 << 8 ) , IRQD_NO_BALANCING = ( 1 << 10 ) , IRQD_PER_CPU = ( 1 << 11 ) , IRQD_AFFINITY_SET = ( 1 << 12 ) , IRQD_LEVEL = ( 1 << 13 ) , IRQD_WAKEUP_STATE = ( 1 << 14 ) , IRQD_MOVE_PCNTXT = ( 1 << 15 ) , IRQD_IRQ_DISABLED = ( 1 << 16 ) , IRQD_IRQ_MASKED = ( 1 << 17 ) , IRQD_IRQ_INPROGRESS = ( 1 << 18 ) , } ;
enum { IRQCHIP_SET_TYPE_MASKED = ( 1 << 0 ) , IRQCHIP_EOI_IF_HANDLED = ( 1 << 1 ) , IRQCHIP_MASK_ON_SUSPEND = ( 1 << 2 ) , IRQCHIP_ONOFFLINE_ENABLED = ( 1 << 3 ) , IRQCHIP_SKIP_SET_WAKE = ( 1 << 4 ) , IRQCHIP_ONESHOT_SAFE = ( 1 << 5 ) , } ;
enum profile_type { PROFILE_TASK_EXIT , PROFILE_MUNMAP } ;
enum irq_gc_flags { IRQ_GC_INIT_MASK_CACHE = 1 << 0 , IRQ_GC_INIT_NESTED_LOCK = 1 << 1 , } ;
enum { IRQC_IS_HARDIRQ = 0 , IRQC_IS_NESTED , } ;
enum { HI_SOFTIRQ = 0 , TIMER_SOFTIRQ , NET_TX_SOFTIRQ , NET_RX_SOFTIRQ , BLOCK_SOFTIRQ , BLOCK_IOPOLL_SOFTIRQ , TASKLET_SOFTIRQ , SCHED_SOFTIRQ , HRTIMER_SOFTIRQ , RCU_SOFTIRQ , NR_SOFTIRQS } ;
enum { TASKLET_STATE_SCHED , TASKLET_STATE_RUN } ;
enum { PM_QOS_RESERVED = 0 , PM_QOS_CPU_DMA_LATENCY , PM_QOS_NETWORK_LATENCY , PM_QOS_NETWORK_THROUGHPUT , PM_QOS_NUM_CLASSES , } ;
enum pm_qos_flags_status { PM_QOS_FLAGS_UNDEFINED = - 1 , PM_QOS_FLAGS_NONE , PM_QOS_FLAGS_SOME , PM_QOS_FLAGS_ALL , } ;
enum dev_pm_qos_req_type { DEV_PM_QOS_LATENCY = 1 , DEV_PM_QOS_FLAGS , } ;
enum pm_qos_type { PM_QOS_UNITIALIZED , PM_QOS_MAX , PM_QOS_MIN } ;
enum pm_qos_req_action { PM_QOS_ADD_REQ , PM_QOS_UPDATE_REQ , PM_QOS_REMOVE_REQ } ;
enum dma_status { DMA_SUCCESS , DMA_IN_PROGRESS , DMA_PAUSED , DMA_ERROR , } ;
enum dma_transaction_type { DMA_MEMCPY , DMA_XOR , DMA_PQ , DMA_XOR_VAL , DMA_PQ_VAL , DMA_MEMSET , DMA_INTERRUPT , DMA_SG , DMA_PRIVATE , DMA_ASYNC_TX , DMA_SLAVE , DMA_CYCLIC , DMA_INTERLEAVE , DMA_TX_TYPE_END , } ;
enum dma_transfer_direction { DMA_MEM_TO_MEM , DMA_MEM_TO_DEV , DMA_DEV_TO_MEM , DMA_DEV_TO_DEV , DMA_TRANS_NONE , } ;
enum dma_ctrl_flags { DMA_PREP_INTERRUPT = ( 1 << 0 ) , DMA_CTRL_ACK = ( 1 << 1 ) , DMA_COMPL_SKIP_SRC_UNMAP = ( 1 << 2 ) , DMA_COMPL_SKIP_DEST_UNMAP = ( 1 << 3 ) , DMA_COMPL_SRC_UNMAP_SINGLE = ( 1 << 4 ) , DMA_COMPL_DEST_UNMAP_SINGLE = ( 1 << 5 ) , DMA_PREP_PQ_DISABLE_P = ( 1 << 6 ) , DMA_PREP_PQ_DISABLE_Q = ( 1 << 7 ) , DMA_PREP_CONTINUE = ( 1 << 8 ) , DMA_PREP_FENCE = ( 1 << 9 ) , } ;
enum dma_ctrl_cmd { DMA_TERMINATE_ALL , DMA_PAUSE , DMA_RESUME , DMA_SLAVE_CONFIG , FSLDMA_EXTERNAL_START , } ;
enum sum_check_bits { SUM_CHECK_P = 0 , SUM_CHECK_Q = 1 , } ;
enum dma_slave_buswidth { DMA_SLAVE_BUSWIDTH_UNDEFINED = 0 , DMA_SLAVE_BUSWIDTH_1_BYTE = 1 , DMA_SLAVE_BUSWIDTH_2_BYTES = 2 , DMA_SLAVE_BUSWIDTH_4_BYTES = 4 , DMA_SLAVE_BUSWIDTH_8_BYTES = 8 , } ;
enum { IF_OPER_UNKNOWN , IF_OPER_NOTPRESENT , IF_OPER_DOWN , IF_OPER_LOWERLAYERDOWN , IF_OPER_TESTING , IF_OPER_DORMANT , IF_OPER_UP , } ;
enum { IF_LINK_MODE_DEFAULT , IF_LINK_MODE_DORMANT , } ;
struct compat_sel_arg_struct ;
struct compat_old_linux_dirent ;
struct compat_linux_dirent ;
struct linux_dirent64 ;
struct compat_msghdr ;
struct compat_mmsghdr ;
struct compat_sysinfo ;
struct compat_sysctl_args ;
struct compat_kexec_segment ;
struct compat_mq_attr ;
struct compat_msgbuf ;
struct epoll_event ;
struct pipe_inode_info ;
enum sock_type { SOCK_STREAM = 1 , SOCK_DGRAM = 2 , SOCK_RAW = 3 , SOCK_RDM = 4 , SOCK_SEQPACKET = 5 , SOCK_DCCP = 6 , SOCK_PACKET = 10 , } ;
enum sock_shutdown_cmd { SHUT_RD = 0 , SHUT_WR = 1 , SHUT_RDWR = 2 , } ;
enum { SOCK_WAKE_IO , SOCK_WAKE_WAITD , SOCK_WAKE_SPACE , SOCK_WAKE_URG , } ;
enum { NETIF_F_SG_BIT , NETIF_F_IP_CSUM_BIT , __UNUSED_NETIF_F_1 , NETIF_F_HW_CSUM_BIT , NETIF_F_IPV6_CSUM_BIT , NETIF_F_HIGHDMA_BIT , NETIF_F_FRAGLIST_BIT , NETIF_F_HW_VLAN_TX_BIT , NETIF_F_HW_VLAN_RX_BIT , NETIF_F_HW_VLAN_FILTER_BIT , NETIF_F_VLAN_CHALLENGED_BIT , NETIF_F_GSO_BIT , NETIF_F_LLTX_BIT , NETIF_F_NETNS_LOCAL_BIT , NETIF_F_GRO_BIT , NETIF_F_LRO_BIT , NETIF_F_GSO_SHIFT , NETIF_F_TSO_BIT = NETIF_F_GSO_SHIFT , NETIF_F_UFO_BIT , NETIF_F_GSO_ROBUST_BIT , NETIF_F_TSO_ECN_BIT , NETIF_F_TSO6_BIT , NETIF_F_FSO_BIT , NETIF_F_GSO_RESERVED1 , NETIF_F_GSO_LAST , NETIF_F_GSO_RESERVED2 = NETIF_F_GSO_LAST , NETIF_F_FCOE_CRC_BIT , NETIF_F_SCTP_CSUM_BIT , NETIF_F_FCOE_MTU_BIT , NETIF_F_NTUPLE_BIT , NETIF_F_RXHASH_BIT , NETIF_F_RXCSUM_BIT , NETIF_F_NOCACHE_COPY_BIT , NETIF_F_LOOPBACK_BIT , NETIF_F_RXFCS_BIT , NETIF_F_RXALL_BIT , NETDEV_FEATURE_COUNT } ;
struct pipe_inode_info ;
enum { SKBTX_HW_TSTAMP = 1 << 0 , SKBTX_SW_TSTAMP = 1 << 1 , SKBTX_IN_PROGRESS = 1 << 2 , SKBTX_DEV_ZEROCOPY = 1 << 3 , SKBTX_WIFI_STATUS = 1 << 4 , } ;
enum { SKB_FCLONE_UNAVAILABLE , SKB_FCLONE_ORIG , SKB_FCLONE_CLONE , } ;
enum { SKB_GSO_TCPV4 = 1 << 0 , SKB_GSO_UDP = 1 << 1 , SKB_GSO_DODGY = 1 << 2 , SKB_GSO_TCP_ECN = 1 << 3 , SKB_GSO_TCPV6 = 1 << 4 , SKB_GSO_FCOE = 1 << 5 , } ;
enum ethtool_stringset { ETH_SS_TEST = 0 , ETH_SS_STATS , ETH_SS_PRIV_FLAGS , ETH_SS_NTUPLE_FILTERS , ETH_SS_FEATURES , } ;
enum ethtool_test_flags { ETH_TEST_FL_OFFLINE = ( 1 << 0 ) , ETH_TEST_FL_FAILED = ( 1 << 1 ) , ETH_TEST_FL_EXTERNAL_LB = ( 1 << 2 ) , ETH_TEST_FL_EXTERNAL_LB_DONE = ( 1 << 3 ) , } ;
enum ethtool_flags { ETH_FLAG_TXVLAN = ( 1 << 7 ) , ETH_FLAG_RXVLAN = ( 1 << 8 ) , ETH_FLAG_LRO = ( 1 << 15 ) , ETH_FLAG_NTUPLE = ( 1 << 27 ) , ETH_FLAG_RXHASH = ( 1 << 28 ) , } ;
enum ethtool_flash_op_type { ETHTOOL_FLASH_ALL_REGIONS = 0 , } ;
enum ethtool_sfeatures_retval_bits { ETHTOOL_F_UNSUPPORTED__BIT , ETHTOOL_F_WISH__BIT , ETHTOOL_F_COMPAT__BIT , } ;
enum ethtool_reset_flags { ETH_RESET_MGMT = 1 << 0 , ETH_RESET_IRQ = 1 << 1 , ETH_RESET_DMA = 1 << 2 , ETH_RESET_FILTER = 1 << 3 , ETH_RESET_OFFLOAD = 1 << 4 , ETH_RESET_MAC = 1 << 5 , ETH_RESET_PHY = 1 << 6 , ETH_RESET_RAM = 1 << 7 , ETH_RESET_DEDICATED = 0x0000ffff , ETH_RESET_ALL = 0xffffffff , } ;
enum ethtool_phys_id_state { ETHTOOL_ID_INACTIVE , ETHTOOL_ID_ACTIVE , ETHTOOL_ID_ON , ETHTOOL_ID_OFF } ;
struct prot_inuse ;
enum { IPSTATS_MIB_NUM = 0 , IPSTATS_MIB_INPKTS , IPSTATS_MIB_INHDRERRORS , IPSTATS_MIB_INTOOBIGERRORS , IPSTATS_MIB_INNOROUTES , IPSTATS_MIB_INADDRERRORS , IPSTATS_MIB_INUNKNOWNPROTOS , IPSTATS_MIB_INTRUNCATEDPKTS , IPSTATS_MIB_INDISCARDS , IPSTATS_MIB_INDELIVERS , IPSTATS_MIB_OUTFORWDATAGRAMS , IPSTATS_MIB_OUTPKTS , IPSTATS_MIB_OUTDISCARDS , IPSTATS_MIB_OUTNOROUTES , IPSTATS_MIB_REASMTIMEOUT , IPSTATS_MIB_REASMREQDS , IPSTATS_MIB_REASMOKS , IPSTATS_MIB_REASMFAILS , IPSTATS_MIB_FRAGOKS , IPSTATS_MIB_FRAGFAILS , IPSTATS_MIB_FRAGCREATES , IPSTATS_MIB_INMCASTPKTS , IPSTATS_MIB_OUTMCASTPKTS , IPSTATS_MIB_INBCASTPKTS , IPSTATS_MIB_OUTBCASTPKTS , IPSTATS_MIB_INOCTETS , IPSTATS_MIB_OUTOCTETS , IPSTATS_MIB_INMCASTOCTETS , IPSTATS_MIB_OUTMCASTOCTETS , IPSTATS_MIB_INBCASTOCTETS , IPSTATS_MIB_OUTBCASTOCTETS , __IPSTATS_MIB_MAX } ;
enum { ICMP_MIB_NUM = 0 , ICMP_MIB_INMSGS , ICMP_MIB_INERRORS , ICMP_MIB_INDESTUNREACHS , ICMP_MIB_INTIMEEXCDS , ICMP_MIB_INPARMPROBS , ICMP_MIB_INSRCQUENCHS , ICMP_MIB_INREDIRECTS , ICMP_MIB_INECHOS , ICMP_MIB_INECHOREPS , ICMP_MIB_INTIMESTAMPS , ICMP_MIB_INTIMESTAMPREPS , ICMP_MIB_INADDRMASKS , ICMP_MIB_INADDRMASKREPS , ICMP_MIB_OUTMSGS , ICMP_MIB_OUTERRORS , ICMP_MIB_OUTDESTUNREACHS , ICMP_MIB_OUTTIMEEXCDS , ICMP_MIB_OUTPARMPROBS , ICMP_MIB_OUTSRCQUENCHS , ICMP_MIB_OUTREDIRECTS , ICMP_MIB_OUTECHOS , ICMP_MIB_OUTECHOREPS , ICMP_MIB_OUTTIMESTAMPS , ICMP_MIB_OUTTIMESTAMPREPS , ICMP_MIB_OUTADDRMASKS , ICMP_MIB_OUTADDRMASKREPS , __ICMP_MIB_MAX } ;
enum { ICMP6_MIB_NUM = 0 , ICMP6_MIB_INMSGS , ICMP6_MIB_INERRORS , ICMP6_MIB_OUTMSGS , ICMP6_MIB_OUTERRORS , __ICMP6_MIB_MAX } ;
enum { TCP_MIB_NUM = 0 , TCP_MIB_RTOALGORITHM , TCP_MIB_RTOMIN , TCP_MIB_RTOMAX , TCP_MIB_MAXCONN , TCP_MIB_ACTIVEOPENS , TCP_MIB_PASSIVEOPENS , TCP_MIB_ATTEMPTFAILS , TCP_MIB_ESTABRESETS , TCP_MIB_CURRESTAB , TCP_MIB_INSEGS , TCP_MIB_OUTSEGS , TCP_MIB_RETRANSSEGS , TCP_MIB_INERRS , TCP_MIB_OUTRSTS , __TCP_MIB_MAX } ;
enum { UDP_MIB_NUM = 0 , UDP_MIB_INDATAGRAMS , UDP_MIB_NOPORTS , UDP_MIB_INERRORS , UDP_MIB_OUTDATAGRAMS , UDP_MIB_RCVBUFERRORS , UDP_MIB_SNDBUFERRORS , __UDP_MIB_MAX } ;
enum { LINUX_MIB_NUM = 0 , LINUX_MIB_SYNCOOKIESSENT , LINUX_MIB_SYNCOOKIESRECV , LINUX_MIB_SYNCOOKIESFAILED , LINUX_MIB_EMBRYONICRSTS , LINUX_MIB_PRUNECALLED , LINUX_MIB_RCVPRUNED , LINUX_MIB_OFOPRUNED , LINUX_MIB_OUTOFWINDOWICMPS , LINUX_MIB_LOCKDROPPEDICMPS , LINUX_MIB_ARPFILTER , LINUX_MIB_TIMEWAITED , LINUX_MIB_TIMEWAITRECYCLED , LINUX_MIB_TIMEWAITKILLED , LINUX_MIB_PAWSPASSIVEREJECTED , LINUX_MIB_PAWSACTIVEREJECTED , LINUX_MIB_PAWSESTABREJECTED , LINUX_MIB_DELAYEDACKS , LINUX_MIB_DELAYEDACKLOCKED , LINUX_MIB_DELAYEDACKLOST , LINUX_MIB_LISTENOVERFLOWS , LINUX_MIB_LISTENDROPS , LINUX_MIB_TCPPREQUEUED , LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG , LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE , LINUX_MIB_TCPPREQUEUEDROPPED , LINUX_MIB_TCPHPHITS , LINUX_MIB_TCPHPHITSTOUSER , LINUX_MIB_TCPPUREACKS , LINUX_MIB_TCPHPACKS , LINUX_MIB_TCPRENORECOVERY , LINUX_MIB_TCPSACKRECOVERY , LINUX_MIB_TCPSACKRENEGING , LINUX_MIB_TCPFACKREORDER , LINUX_MIB_TCPSACKREORDER , LINUX_MIB_TCPRENOREORDER , LINUX_MIB_TCPTSREORDER , LINUX_MIB_TCPFULLUNDO , LINUX_MIB_TCPPARTIALUNDO , LINUX_MIB_TCPDSACKUNDO , LINUX_MIB_TCPLOSSUNDO , LINUX_MIB_TCPLOSS , LINUX_MIB_TCPLOSTRETRANSMIT , LINUX_MIB_TCPRENOFAILURES , LINUX_MIB_TCPSACKFAILURES , LINUX_MIB_TCPLOSSFAILURES , LINUX_MIB_TCPFASTRETRANS , LINUX_MIB_TCPFORWARDRETRANS , LINUX_MIB_TCPSLOWSTARTRETRANS , LINUX_MIB_TCPTIMEOUTS , LINUX_MIB_TCPRENORECOVERYFAIL , LINUX_MIB_TCPSACKRECOVERYFAIL , LINUX_MIB_TCPSCHEDULERFAILED , LINUX_MIB_TCPRCVCOLLAPSED , LINUX_MIB_TCPDSACKOLDSENT , LINUX_MIB_TCPDSACKOFOSENT , LINUX_MIB_TCPDSACKRECV , LINUX_MIB_TCPDSACKOFORECV , LINUX_MIB_TCPABORTONDATA , LINUX_MIB_TCPABORTONCLOSE , LINUX_MIB_TCPABORTONMEMORY , LINUX_MIB_TCPABORTONTIMEOUT , LINUX_MIB_TCPABORTONLINGER , LINUX_MIB_TCPABORTFAILED , LINUX_MIB_TCPMEMORYPRESSURES , LINUX_MIB_TCPSACKDISCARD , LINUX_MIB_TCPDSACKIGNOREDOLD , LINUX_MIB_TCPDSACKIGNOREDNOUNDO , LINUX_MIB_TCPSPURIOUSRTOS , LINUX_MIB_TCPMD5NOTFOUND , LINUX_MIB_TCPMD5UNEXPECTED , LINUX_MIB_SACKSHIFTED , LINUX_MIB_SACKMERGED , LINUX_MIB_SACKSHIFTFALLBACK , LINUX_MIB_TCPBACKLOGDROP , LINUX_MIB_TCPMINTTLDROP , LINUX_MIB_TCPDEFERACCEPTDROP , LINUX_MIB_IPRPFILTER , LINUX_MIB_TCPTIMEWAITOVERFLOW , LINUX_MIB_TCPREQQFULLDOCOOKIES , LINUX_MIB_TCPREQQFULLDROP , LINUX_MIB_TCPCHALLENGEACK , LINUX_MIB_TCPSYNCHALLENGE , __LINUX_MIB_MAX } ;
enum { LINUX_MIB_XFRMNUM = 0 , LINUX_MIB_XFRMINERROR , LINUX_MIB_XFRMINBUFFERERROR , LINUX_MIB_XFRMINHDRERROR , LINUX_MIB_XFRMINNOSTATES , LINUX_MIB_XFRMINSTATEPROTOERROR , LINUX_MIB_XFRMINSTATEMODEERROR , LINUX_MIB_XFRMINSTATESEQERROR , LINUX_MIB_XFRMINSTATEEXPIRED , LINUX_MIB_XFRMINSTATEMISMATCH , LINUX_MIB_XFRMINSTATEINVALID , LINUX_MIB_XFRMINTMPLMISMATCH , LINUX_MIB_XFRMINNOPOLS , LINUX_MIB_XFRMINPOLBLOCK , LINUX_MIB_XFRMINPOLERROR , LINUX_MIB_XFRMOUTERROR , LINUX_MIB_XFRMOUTBUNDLEGENERROR , LINUX_MIB_XFRMOUTBUNDLECHECKERROR , LINUX_MIB_XFRMOUTNOSTATES , LINUX_MIB_XFRMOUTSTATEPROTOERROR , LINUX_MIB_XFRMOUTSTATEMODEERROR , LINUX_MIB_XFRMOUTSTATESEQERROR , LINUX_MIB_XFRMOUTSTATEEXPIRED , LINUX_MIB_XFRMOUTPOLBLOCK , LINUX_MIB_XFRMOUTPOLDEAD , LINUX_MIB_XFRMOUTPOLERROR , LINUX_MIB_XFRMFWDHDRERROR , __LINUX_MIB_XFRMMAX } ;
struct u64_stats_sync { } ;
struct tcpm_hash_bucket ;
struct ipv4_devconf ;
struct fib_rules_ops ;
struct fib_table ;
struct kmem_cachep ;
struct sctp_mib ;
enum { IPPROTO_IP = 0 , IPPROTO_ICMP = 1 , IPPROTO_IGMP = 2 , IPPROTO_IPIP = 4 , IPPROTO_TCP = 6 , IPPROTO_EGP = 8 , IPPROTO_PUP = 12 , IPPROTO_UDP = 17 , IPPROTO_IDP = 22 , IPPROTO_DCCP = 33 , IPPROTO_RSVP = 46 , IPPROTO_GRE = 47 , IPPROTO_IPV6 = 41 , IPPROTO_ESP = 50 , IPPROTO_AH = 51 , IPPROTO_BEETPH = 94 , IPPROTO_PIM = 103 , IPPROTO_COMP = 108 , IPPROTO_SCTP = 132 , IPPROTO_UDPLITE = 136 , IPPROTO_RAW = 255 , IPPROTO_MAX } ;
enum nf_inet_hooks { NF_INET_PRE_ROUTING , NF_INET_LOCAL_IN , NF_INET_FORWARD , NF_INET_LOCAL_OUT , NF_INET_POST_ROUTING , NF_INET_NUMHOOKS } ;
enum { NFPROTO_UNSPEC = 0 , NFPROTO_IPV4 = 2 , NFPROTO_ARP = 3 , NFPROTO_BRIDGE = 7 , NFPROTO_IPV6 = 10 , NFPROTO_DECNET = 12 , NFPROTO_NUMPROTO , } ;
struct nf_queue_entry ;
struct nf_conn ;
struct ebt_table ;
enum tcp_conntrack { TCP_CONNTRACK_NONE , TCP_CONNTRACK_SYN_SENT , TCP_CONNTRACK_SYN_RECV , TCP_CONNTRACK_ESTABLISHED , TCP_CONNTRACK_FIN_WAIT , TCP_CONNTRACK_CLOSE_WAIT , TCP_CONNTRACK_LAST_ACK , TCP_CONNTRACK_TIME_WAIT , TCP_CONNTRACK_CLOSE , TCP_CONNTRACK_LISTEN , TCP_CONNTRACK_MAX , TCP_CONNTRACK_IGNORE , TCP_CONNTRACK_RETRANS , TCP_CONNTRACK_UNACK , TCP_CONNTRACK_TIMEOUT_MAX } ;
struct nf_conntrack_ecache ;
enum udp_conntrack { UDP_CT_UNREPLIED , UDP_CT_REPLIED , UDP_CT_MAX } ;
enum { XFRM_POLICY_TYPE_MAIN = 0 , XFRM_POLICY_TYPE_SUB = 1 , XFRM_POLICY_TYPE_MAX = 2 , XFRM_POLICY_TYPE_ANY = 255 } ;
enum { XFRM_POLICY_IN = 0 , XFRM_POLICY_OUT = 1 , XFRM_POLICY_FWD = 2 , XFRM_POLICY_MASK = 3 , XFRM_POLICY_MAX = 3 } ;
enum { XFRM_SHARE_ANY , XFRM_SHARE_SESSION , XFRM_SHARE_USER , XFRM_SHARE_UNIQUE } ;
enum { XFRM_MSG_BASE = 0x10 , XFRM_MSG_NEWSA = 0x10 , XFRM_MSG_DELSA , XFRM_MSG_GETSA , XFRM_MSG_NEWPOLICY , XFRM_MSG_DELPOLICY , XFRM_MSG_GETPOLICY , XFRM_MSG_ALLOCSPI , XFRM_MSG_ACQUIRE , XFRM_MSG_EXPIRE , XFRM_MSG_UPDPOLICY , XFRM_MSG_UPDSA , XFRM_MSG_POLEXPIRE , XFRM_MSG_FLUSHSA , XFRM_MSG_FLUSHPOLICY , XFRM_MSG_NEWAE , XFRM_MSG_GETAE , XFRM_MSG_REPORT , XFRM_MSG_MIGRATE , XFRM_MSG_NEWSADINFO , XFRM_MSG_GETSADINFO , XFRM_MSG_NEWSPDINFO , XFRM_MSG_GETSPDINFO , XFRM_MSG_MAPPING , __XFRM_MSG_MAX } ;
enum xfrm_ae_ftype_t { XFRM_AE_UNSPEC , XFRM_AE_RTHR = 1 , XFRM_AE_RVAL = 2 , XFRM_AE_LVAL = 4 , XFRM_AE_ETHR = 8 , XFRM_AE_CR = 16 , XFRM_AE_CE = 32 , XFRM_AE_CU = 64 , __XFRM_AE_MAX } ;
enum xfrm_attr_type_t { XFRMA_UNSPEC , XFRMA_ALG_AUTH , XFRMA_ALG_CRYPT , XFRMA_ALG_COMP , XFRMA_ENCAP , XFRMA_TMPL , XFRMA_SA , XFRMA_POLICY , XFRMA_SEC_CTX , XFRMA_LTIME_VAL , XFRMA_REPLAY_VAL , XFRMA_REPLAY_THRESH , XFRMA_ETIMER_THRESH , XFRMA_SRCADDR , XFRMA_COADDR , XFRMA_LASTUSED , XFRMA_POLICY_TYPE , XFRMA_MIGRATE , XFRMA_ALG_AEAD , XFRMA_KMADDRESS , XFRMA_ALG_AUTH_TRUNC , XFRMA_MARK , XFRMA_TFCPAD , XFRMA_REPLAY_ESN_VAL , __XFRMA_MAX } ;
enum xfrm_sadattr_type_t { XFRMA_SAD_UNSPEC , XFRMA_SAD_CNT , XFRMA_SAD_HINFO , __XFRMA_SAD_MAX } ;
enum xfrm_spdattr_type_t { XFRMA_SPD_UNSPEC , XFRMA_SPD_INFO , XFRMA_SPD_HINFO , __XFRMA_SPD_MAX } ;
enum xfrm_nlgroups { XFRMNLGRP_NONE , XFRMNLGRP_ACQUIRE , XFRMNLGRP_EXPIRE , XFRMNLGRP_SA , XFRMNLGRP_POLICY , XFRMNLGRP_AEVENTS , XFRMNLGRP_REPORT , XFRMNLGRP_MIGRATE , XFRMNLGRP_MAPPING , __XFRMNLGRP_MAX } ;
struct user_namespace ;
struct net_generic ;
struct netns_ipvs ;
struct user_namespace ;
enum dcbnl_commands { DCB_CMD_UNDEFINED , DCB_CMD_GSTATE , DCB_CMD_SSTATE , DCB_CMD_PGTX_GCFG , DCB_CMD_PGTX_SCFG , DCB_CMD_PGRX_GCFG , DCB_CMD_PGRX_SCFG , DCB_CMD_PFC_GCFG , DCB_CMD_PFC_SCFG , DCB_CMD_SET_ALL , DCB_CMD_GPERM_HWADDR , DCB_CMD_GCAP , DCB_CMD_GNUMTCS , DCB_CMD_SNUMTCS , DCB_CMD_PFC_GSTATE , DCB_CMD_PFC_SSTATE , DCB_CMD_BCN_GCFG , DCB_CMD_BCN_SCFG , DCB_CMD_GAPP , DCB_CMD_SAPP , DCB_CMD_IEEE_SET , DCB_CMD_IEEE_GET , DCB_CMD_GDCBX , DCB_CMD_SDCBX , DCB_CMD_GFEATCFG , DCB_CMD_SFEATCFG , DCB_CMD_CEE_GET , DCB_CMD_IEEE_DEL , __DCB_CMD_ENUM_MAX , DCB_CMD_MAX = __DCB_CMD_ENUM_MAX - 1 , } ;
enum dcbnl_attrs { DCB_ATTR_UNDEFINED , DCB_ATTR_IFNAME , DCB_ATTR_STATE , DCB_ATTR_PFC_STATE , DCB_ATTR_PFC_CFG , DCB_ATTR_NUM_TC , DCB_ATTR_PG_CFG , DCB_ATTR_SET_ALL , DCB_ATTR_PERM_HWADDR , DCB_ATTR_CAP , DCB_ATTR_NUMTCS , DCB_ATTR_BCN , DCB_ATTR_APP , DCB_ATTR_IEEE , DCB_ATTR_DCBX , DCB_ATTR_FEATCFG , DCB_ATTR_CEE , __DCB_ATTR_ENUM_MAX , DCB_ATTR_MAX = __DCB_ATTR_ENUM_MAX - 1 , } ;
enum ieee_attrs { DCB_ATTR_IEEE_UNSPEC , DCB_ATTR_IEEE_ETS , DCB_ATTR_IEEE_PFC , DCB_ATTR_IEEE_APP_TABLE , DCB_ATTR_IEEE_PEER_ETS , DCB_ATTR_IEEE_PEER_PFC , DCB_ATTR_IEEE_PEER_APP , __DCB_ATTR_IEEE_MAX } ;
enum ieee_attrs_app { DCB_ATTR_IEEE_APP_UNSPEC , DCB_ATTR_IEEE_APP , __DCB_ATTR_IEEE_APP_MAX } ;
enum cee_attrs { DCB_ATTR_CEE_UNSPEC , DCB_ATTR_CEE_PEER_PG , DCB_ATTR_CEE_PEER_PFC , DCB_ATTR_CEE_PEER_APP_TABLE , DCB_ATTR_CEE_TX_PG , DCB_ATTR_CEE_RX_PG , DCB_ATTR_CEE_PFC , DCB_ATTR_CEE_APP_TABLE , DCB_ATTR_CEE_FEAT , __DCB_ATTR_CEE_MAX } ;
enum peer_app_attr { DCB_ATTR_CEE_PEER_APP_UNSPEC , DCB_ATTR_CEE_PEER_APP_INFO , DCB_ATTR_CEE_PEER_APP , __DCB_ATTR_CEE_PEER_APP_MAX } ;
enum cee_attrs_app { DCB_ATTR_CEE_APP_UNSPEC , DCB_ATTR_CEE_APP , __DCB_ATTR_CEE_APP_MAX } ;
enum dcbnl_pfc_up_attrs { DCB_PFC_UP_ATTR_UNDEFINED , DCB_PFC_UP_ATTR_0 , DCB_PFC_UP_ATTR_1 , DCB_PFC_UP_ATTR_2 , DCB_PFC_UP_ATTR_3 , DCB_PFC_UP_ATTR_4 , DCB_PFC_UP_ATTR_5 , DCB_PFC_UP_ATTR_6 , DCB_PFC_UP_ATTR_7 , DCB_PFC_UP_ATTR_ALL , __DCB_PFC_UP_ATTR_ENUM_MAX , DCB_PFC_UP_ATTR_MAX = __DCB_PFC_UP_ATTR_ENUM_MAX - 1 , } ;
enum dcbnl_pg_attrs { DCB_PG_ATTR_UNDEFINED , DCB_PG_ATTR_TC_0 , DCB_PG_ATTR_TC_1 , DCB_PG_ATTR_TC_2 , DCB_PG_ATTR_TC_3 , DCB_PG_ATTR_TC_4 , DCB_PG_ATTR_TC_5 , DCB_PG_ATTR_TC_6 , DCB_PG_ATTR_TC_7 , DCB_PG_ATTR_TC_MAX , DCB_PG_ATTR_TC_ALL , DCB_PG_ATTR_BW_ID_0 , DCB_PG_ATTR_BW_ID_1 , DCB_PG_ATTR_BW_ID_2 , DCB_PG_ATTR_BW_ID_3 , DCB_PG_ATTR_BW_ID_4 , DCB_PG_ATTR_BW_ID_5 , DCB_PG_ATTR_BW_ID_6 , DCB_PG_ATTR_BW_ID_7 , DCB_PG_ATTR_BW_ID_MAX , DCB_PG_ATTR_BW_ID_ALL , __DCB_PG_ATTR_ENUM_MAX , DCB_PG_ATTR_MAX = __DCB_PG_ATTR_ENUM_MAX - 1 , } ;
enum dcbnl_tc_attrs { DCB_TC_ATTR_PARAM_UNDEFINED , DCB_TC_ATTR_PARAM_PGID , DCB_TC_ATTR_PARAM_UP_MAPPING , DCB_TC_ATTR_PARAM_STRICT_PRIO , DCB_TC_ATTR_PARAM_BW_PCT , DCB_TC_ATTR_PARAM_ALL , __DCB_TC_ATTR_PARAM_ENUM_MAX , DCB_TC_ATTR_PARAM_MAX = __DCB_TC_ATTR_PARAM_ENUM_MAX - 1 , } ;
enum dcbnl_cap_attrs { DCB_CAP_ATTR_UNDEFINED , DCB_CAP_ATTR_ALL , DCB_CAP_ATTR_PG , DCB_CAP_ATTR_PFC , DCB_CAP_ATTR_UP2TC , DCB_CAP_ATTR_PG_TCS , DCB_CAP_ATTR_PFC_TCS , DCB_CAP_ATTR_GSP , DCB_CAP_ATTR_BCN , DCB_CAP_ATTR_DCBX , __DCB_CAP_ATTR_ENUM_MAX , DCB_CAP_ATTR_MAX = __DCB_CAP_ATTR_ENUM_MAX - 1 , } ;
enum dcbnl_numtcs_attrs { DCB_NUMTCS_ATTR_UNDEFINED , DCB_NUMTCS_ATTR_ALL , DCB_NUMTCS_ATTR_PG , DCB_NUMTCS_ATTR_PFC , __DCB_NUMTCS_ATTR_ENUM_MAX , DCB_NUMTCS_ATTR_MAX = __DCB_NUMTCS_ATTR_ENUM_MAX - 1 , } ;
enum dcbnl_bcn_attrs { DCB_BCN_ATTR_UNDEFINED = 0 , DCB_BCN_ATTR_RP_0 , DCB_BCN_ATTR_RP_1 , DCB_BCN_ATTR_RP_2 , DCB_BCN_ATTR_RP_3 , DCB_BCN_ATTR_RP_4 , DCB_BCN_ATTR_RP_5 , DCB_BCN_ATTR_RP_6 , DCB_BCN_ATTR_RP_7 , DCB_BCN_ATTR_RP_ALL , DCB_BCN_ATTR_BCNA_0 , DCB_BCN_ATTR_BCNA_1 , DCB_BCN_ATTR_ALPHA , DCB_BCN_ATTR_BETA , DCB_BCN_ATTR_GD , DCB_BCN_ATTR_GI , DCB_BCN_ATTR_TMAX , DCB_BCN_ATTR_TD , DCB_BCN_ATTR_RMIN , DCB_BCN_ATTR_W , DCB_BCN_ATTR_RD , DCB_BCN_ATTR_RU , DCB_BCN_ATTR_WRTT , DCB_BCN_ATTR_RI , DCB_BCN_ATTR_C , DCB_BCN_ATTR_ALL , __DCB_BCN_ATTR_ENUM_MAX , DCB_BCN_ATTR_MAX = __DCB_BCN_ATTR_ENUM_MAX - 1 , } ;
enum dcb_general_attr_values { DCB_ATTR_VALUE_UNDEFINED = 0xff } ;
enum dcbnl_app_attrs { DCB_APP_ATTR_UNDEFINED , DCB_APP_ATTR_IDTYPE , DCB_APP_ATTR_ID , DCB_APP_ATTR_PRIORITY , __DCB_APP_ATTR_ENUM_MAX , DCB_APP_ATTR_MAX = __DCB_APP_ATTR_ENUM_MAX - 1 , } ;
enum dcbnl_featcfg_attrs { DCB_FEATCFG_ATTR_UNDEFINED , DCB_FEATCFG_ATTR_ALL , DCB_FEATCFG_ATTR_PG , DCB_FEATCFG_ATTR_PFC , DCB_FEATCFG_ATTR_APP , __DCB_FEATCFG_ATTR_ENUM_MAX , DCB_FEATCFG_ATTR_MAX = __DCB_FEATCFG_ATTR_ENUM_MAX - 1 , } ;
enum { TASKSTATS_CMD_UNSPEC = 0 , TASKSTATS_CMD_GET , TASKSTATS_CMD_NEW , __TASKSTATS_CMD_MAX , } ;
enum { TASKSTATS_TYPE_UNSPEC = 0 , TASKSTATS_TYPE_PID , TASKSTATS_TYPE_TGID , TASKSTATS_TYPE_STATS , TASKSTATS_TYPE_AGGR_PID , TASKSTATS_TYPE_AGGR_TGID , TASKSTATS_TYPE_NULL , __TASKSTATS_TYPE_MAX , } ;
enum { TASKSTATS_CMD_ATTR_UNSPEC = 0 , TASKSTATS_CMD_ATTR_PID , TASKSTATS_CMD_ATTR_TGID , TASKSTATS_CMD_ATTR_REGISTER_CPUMASK , TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK , __TASKSTATS_CMD_ATTR_MAX , } ;
enum { CGROUPSTATS_CMD_UNSPEC = __TASKSTATS_CMD_MAX , CGROUPSTATS_CMD_GET , CGROUPSTATS_CMD_NEW , __CGROUPSTATS_CMD_MAX , } ;
enum { CGROUPSTATS_TYPE_UNSPEC = 0 , CGROUPSTATS_TYPE_CGROUP_STATS , __CGROUPSTATS_TYPE_MAX , } ;
enum { CGROUPSTATS_CMD_ATTR_UNSPEC = 0 , CGROUPSTATS_CMD_ATTR_FD , __CGROUPSTATS_CMD_ATTR_MAX , } ;
struct cgroupfs_root ;
struct css_id ;
enum cgroup_subsys_id { cpuset_subsys_id , cpu_cgroup_subsys_id , devices_subsys_id , freezer_subsys_id , net_cls_subsys_id , blkio_subsys_id , perf_subsys_id , CGROUP_SUBSYS_COUNT , } ;
enum { CSS_ROOT = ( 1 << 0 ) , CSS_ONLINE = ( 1 << 1 ) , } ;
enum { CGRP_REMOVED , CGRP_RELEASABLE , CGRP_NOTIFY_ON_RELEASE , CGRP_CPUSET_CLONE_CHILDREN , } ;
struct cgroup_taskset ;
struct linux_binprm ;
struct audit_context ;
struct shmid_kernel ;
struct msg_msg ;
struct msg_queue ;
struct audit_krule ;
struct user_namespace ;
struct xfrm_policy ;
struct xfrm_state ;
struct security_mnt_opts { } ;
struct mnt_namespace ;
struct uts_namespace ;
struct ipc_namespace ;
struct pid_namespace ;
struct fs_struct ;
enum { NETLINK_UNCONNECTED = 0 , NETLINK_CONNECTED , } ;
enum { NDA_UNSPEC , NDA_DST , NDA_LLADDR , NDA_CACHEINFO , NDA_PROBES , __NDA_MAX } ;
enum { NDTPA_UNSPEC , NDTPA_IFINDEX , NDTPA_REFCNT , NDTPA_REACHABLE_TIME , NDTPA_BASE_REACHABLE_TIME , NDTPA_RETRANS_TIME , NDTPA_GC_STALETIME , NDTPA_DELAY_PROBE_TIME , NDTPA_QUEUE_LEN , NDTPA_APP_PROBES , NDTPA_UCAST_PROBES , NDTPA_MCAST_PROBES , NDTPA_ANYCAST_DELAY , NDTPA_PROXY_DELAY , NDTPA_PROXY_QLEN , NDTPA_LOCKTIME , __NDTPA_MAX } ;
enum { NDTA_UNSPEC , NDTA_NAME , NDTA_THRESH1 , NDTA_THRESH2 , NDTA_THRESH3 , NDTA_CONFIG , NDTA_PARMS , NDTA_STATS , NDTA_GC_INTERVAL , __NDTA_MAX } ;
enum tpacket_versions { TPACKET_V1 , TPACKET_V2 , TPACKET_V3 } ;
enum { IFLA_UNSPEC , IFLA_ADDRESS , IFLA_BROADCAST , IFLA_IFNAME , IFLA_MTU , IFLA_LINK , IFLA_QDISC , IFLA_STATS , IFLA_COST , IFLA_PRIORITY , IFLA_MASTER , IFLA_WIRELESS , IFLA_PROTINFO , IFLA_TXQLEN , IFLA_MAP , IFLA_WEIGHT , IFLA_OPERSTATE , IFLA_LINKMODE , IFLA_LINKINFO , IFLA_NET_NS_PID , IFLA_IFALIAS , IFLA_NUM_VF , IFLA_VFINFO_LIST , IFLA_STATS64 , IFLA_VF_PORTS , IFLA_PORT_SELF , IFLA_AF_SPEC , IFLA_GROUP , IFLA_NET_NS_FD , IFLA_EXT_MASK , IFLA_PROMISCUITY , IFLA_NUM_TX_QUEUES , IFLA_NUM_RX_QUEUES , __IFLA_MAX } ;
enum { IFLA_INET_UNSPEC , IFLA_INET_CONF , __IFLA_INET_MAX , } ;
enum { IFLA_INET6_UNSPEC , IFLA_INET6_FLAGS , IFLA_INET6_CONF , IFLA_INET6_STATS , IFLA_INET6_MCAST , IFLA_INET6_CACHEINFO , IFLA_INET6_ICMP6STATS , __IFLA_INET6_MAX } ;
enum { BRIDGE_MODE_UNSPEC , BRIDGE_MODE_HAIRPIN , } ;
enum { IFLA_BRPORT_UNSPEC , IFLA_BRPORT_STATE , IFLA_BRPORT_PRIORITY , IFLA_BRPORT_COST , IFLA_BRPORT_MODE , IFLA_BRPORT_GUARD , IFLA_BRPORT_PROTECT , IFLA_BRPORT_FAST_LEAVE , __IFLA_BRPORT_MAX } ;
enum { IFLA_INFO_UNSPEC , IFLA_INFO_KIND , IFLA_INFO_DATA , IFLA_INFO_XSTATS , __IFLA_INFO_MAX , } ;
enum { IFLA_VLAN_UNSPEC , IFLA_VLAN_ID , IFLA_VLAN_FLAGS , IFLA_VLAN_EGRESS_QOS , IFLA_VLAN_INGRESS_QOS , __IFLA_VLAN_MAX , } ;
enum { IFLA_VLAN_QOS_UNSPEC , IFLA_VLAN_QOS_MAPPING , __IFLA_VLAN_QOS_MAX } ;
enum { IFLA_MACVLAN_UNSPEC , IFLA_MACVLAN_MODE , IFLA_MACVLAN_FLAGS , __IFLA_MACVLAN_MAX , } ;
enum macvlan_mode { MACVLAN_MODE_PRIVATE = 1 , MACVLAN_MODE_VEPA = 2 , MACVLAN_MODE_BRIDGE = 4 , MACVLAN_MODE_PASSTHRU = 8 , } ;
enum { IFLA_VXLAN_UNSPEC , IFLA_VXLAN_ID , IFLA_VXLAN_GROUP , IFLA_VXLAN_LINK , IFLA_VXLAN_LOCAL , IFLA_VXLAN_TTL , IFLA_VXLAN_TOS , IFLA_VXLAN_LEARNING , IFLA_VXLAN_AGEING , IFLA_VXLAN_LIMIT , IFLA_VXLAN_PORT_RANGE , IFLA_VXLAN_PROXY , IFLA_VXLAN_RSC , IFLA_VXLAN_L2MISS , IFLA_VXLAN_L3MISS , __IFLA_VXLAN_MAX } ;
enum { IFLA_VF_INFO_UNSPEC , IFLA_VF_INFO , __IFLA_VF_INFO_MAX , } ;
enum { IFLA_VF_UNSPEC , IFLA_VF_MAC , IFLA_VF_VLAN , IFLA_VF_TX_RATE , IFLA_VF_SPOOFCHK , __IFLA_VF_MAX , } ;
enum { IFLA_VF_PORT_UNSPEC , IFLA_VF_PORT , __IFLA_VF_PORT_MAX , } ;
enum { IFLA_PORT_UNSPEC , IFLA_PORT_VF , IFLA_PORT_PROFILE , IFLA_PORT_VSI_TYPE , IFLA_PORT_INSTANCE_UUID , IFLA_PORT_HOST_UUID , IFLA_PORT_REQUEST , IFLA_PORT_RESPONSE , __IFLA_PORT_MAX , } ;
enum { PORT_REQUEST_PREASSOCIATE = 0 , PORT_REQUEST_PREASSOCIATE_RR , PORT_REQUEST_ASSOCIATE , PORT_REQUEST_DISASSOCIATE , } ;
enum { PORT_VDP_RESPONSE_SUCCESS = 0 , PORT_VDP_RESPONSE_INVALID_FORMAT , PORT_VDP_RESPONSE_INSUFFICIENT_RESOURCES , PORT_VDP_RESPONSE_UNUSED_VTID , PORT_VDP_RESPONSE_VTID_VIOLATION , PORT_VDP_RESPONSE_VTID_VERSION_VIOALTION , PORT_VDP_RESPONSE_OUT_OF_SYNC , PORT_PROFILE_RESPONSE_SUCCESS = 0x100 , PORT_PROFILE_RESPONSE_INPROGRESS , PORT_PROFILE_RESPONSE_INVALID , PORT_PROFILE_RESPONSE_BADSTATE , PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES , PORT_PROFILE_RESPONSE_ERROR , } ;
enum { IFLA_IPOIB_UNSPEC , IFLA_IPOIB_PKEY , IFLA_IPOIB_MODE , IFLA_IPOIB_UMCAST , __IFLA_IPOIB_MAX } ;
enum { IPOIB_MODE_DATAGRAM = 0 , IPOIB_MODE_CONNECTED = 1 , } ;
enum { IF_PORT_UNKNOWN = 0 , IF_PORT_10BASE2 , IF_PORT_10BASET , IF_PORT_AUI , IF_PORT_100BASET , IF_PORT_100BASETX , IF_PORT_100BASEFX } ;
struct netpoll_info ;
struct wireless_dev ;
enum netdev_tx { __NETDEV_TX_MIN = ( - ( ( int ) ( ~ 0U >> 1 ) ) - 1 ) , NETDEV_TX_OK = 0x00 , NETDEV_TX_BUSY = 0x10 , NETDEV_TX_LOCKED = 0x20 , } ;
enum netdev_state_t { __LINK_STATE_START , __LINK_STATE_PRESENT , __LINK_STATE_NOCARRIER , __LINK_STATE_LINKWATCH_PENDING , __LINK_STATE_DORMANT , } ;
enum { NAPI_STATE_SCHED , NAPI_STATE_DISABLE , NAPI_STATE_NPSVC , } ;
enum gro_result { GRO_MERGED , GRO_MERGED_FREE , GRO_HELD , GRO_NORMAL , GRO_DROP , } ;
enum rx_handler_result { RX_HANDLER_CONSUMED , RX_HANDLER_ANOTHER , RX_HANDLER_EXACT , RX_HANDLER_PASS , } ;
enum netdev_queue_state_t { __QUEUE_STATE_DRV_XOFF , __QUEUE_STATE_STACK_XOFF , __QUEUE_STATE_FROZEN , } ;
enum { NETIF_MSG_DRV = 0x0001 , NETIF_MSG_PROBE = 0x0002 , NETIF_MSG_LINK = 0x0004 , NETIF_MSG_TIMER = 0x0008 , NETIF_MSG_IFDOWN = 0x0010 , NETIF_MSG_IFUP = 0x0020 , NETIF_MSG_RX_ERR = 0x0040 , NETIF_MSG_TX_ERR = 0x0080 , NETIF_MSG_TX_QUEUED = 0x0100 , NETIF_MSG_INTR = 0x0200 , NETIF_MSG_TX_DONE = 0x0400 , NETIF_MSG_RX_STATUS = 0x0800 , NETIF_MSG_PKTDATA = 0x1000 , NETIF_MSG_HW = 0x2000 , NETIF_MSG_WOL = 0x4000 , } ;
enum { IFA_UNSPEC , IFA_ADDRESS , IFA_LOCAL , IFA_LABEL , IFA_BROADCAST , IFA_ANYCAST , IFA_CACHEINFO , IFA_MULTICAST , __IFA_MAX , } ;
enum { RTM_BASE = 16 , RTM_NEWLINK = 16 , RTM_DELLINK , RTM_GETLINK , RTM_SETLINK , RTM_NEWADDR = 20 , RTM_DELADDR , RTM_GETADDR , RTM_NEWROUTE = 24 , RTM_DELROUTE , RTM_GETROUTE , RTM_NEWNEIGH = 28 , RTM_DELNEIGH , RTM_GETNEIGH , RTM_NEWRULE = 32 , RTM_DELRULE , RTM_GETRULE , RTM_NEWQDISC = 36 , RTM_DELQDISC , RTM_GETQDISC , RTM_NEWTCLASS = 40 , RTM_DELTCLASS , RTM_GETTCLASS , RTM_NEWTFILTER = 44 , RTM_DELTFILTER , RTM_GETTFILTER , RTM_NEWACTION = 48 , RTM_DELACTION , RTM_GETACTION , RTM_NEWPREFIX = 52 , RTM_GETMULTICAST = 58 , RTM_GETANYCAST = 62 , RTM_NEWNEIGHTBL = 64 , RTM_GETNEIGHTBL = 66 , RTM_SETNEIGHTBL , RTM_NEWNDUSEROPT = 68 , RTM_NEWADDRLABEL = 72 , RTM_DELADDRLABEL , RTM_GETADDRLABEL , RTM_GETDCB = 78 , RTM_SETDCB , RTM_NEWNETCONF = 80 , RTM_GETNETCONF = 82 , RTM_NEWMDB = 84 , RTM_DELMDB = 85 , RTM_GETMDB = 86 , __RTM_MAX , } ;
enum { RTN_UNSPEC , RTN_UNICAST , RTN_LOCAL , RTN_BROADCAST , RTN_ANYCAST , RTN_MULTICAST , RTN_BLACKHOLE , RTN_UNREACHABLE , RTN_PROHIBIT , RTN_THROW , RTN_NAT , RTN_XRESOLVE , __RTN_MAX } ;
enum rt_scope_t { RT_SCOPE_UNIVERSE = 0 , RT_SCOPE_SITE = 200 , RT_SCOPE_LINK = 253 , RT_SCOPE_HOST = 254 , RT_SCOPE_NOWHERE = 255 } ;
enum rt_class_t { RT_TABLE_UNSPEC = 0 , RT_TABLE_COMPAT = 252 , RT_TABLE_DEFAULT = 253 , RT_TABLE_MAIN = 254 , RT_TABLE_LOCAL = 255 , RT_TABLE_MAX = 0xFFFFFFFF } ;
enum rtattr_type_t { RTA_UNSPEC , RTA_DST , RTA_SRC , RTA_IIF , RTA_OIF , RTA_GATEWAY , RTA_PRIORITY , RTA_PREFSRC , RTA_METRICS , RTA_MULTIPATH , RTA_PROTOINFO , RTA_FLOW , RTA_CACHEINFO , RTA_SESSION , RTA_MP_ALGO , RTA_TABLE , RTA_MARK , RTA_MFC_STATS , __RTA_MAX } ;
enum { RTAX_UNSPEC , RTAX_LOCK , RTAX_MTU , RTAX_WINDOW , RTAX_RTT , RTAX_RTTVAR , RTAX_SSTHRESH , RTAX_CWND , RTAX_ADVMSS , RTAX_REORDERING , RTAX_HOPLIMIT , RTAX_INITCWND , RTAX_FEATURES , RTAX_RTO_MIN , RTAX_INITRWND , __RTAX_MAX } ;
enum { PREFIX_UNSPEC , PREFIX_ADDRESS , PREFIX_CACHEINFO , __PREFIX_MAX } ;
enum { TCA_UNSPEC , TCA_KIND , TCA_OPTIONS , TCA_STATS , TCA_XSTATS , TCA_RATE , TCA_FCNT , TCA_STATS2 , TCA_STAB , __TCA_MAX } ;
enum { NDUSEROPT_UNSPEC , NDUSEROPT_SRCADDR , __NDUSEROPT_MAX } ;
enum rtnetlink_groups { RTNLGRP_NONE , RTNLGRP_LINK , RTNLGRP_NOTIFY , RTNLGRP_NEIGH , RTNLGRP_TC , RTNLGRP_IPV4_IFADDR , RTNLGRP_IPV4_MROUTE , RTNLGRP_IPV4_ROUTE , RTNLGRP_IPV4_RULE , RTNLGRP_IPV6_IFADDR , RTNLGRP_IPV6_MROUTE , RTNLGRP_IPV6_ROUTE , RTNLGRP_IPV6_IFINFO , RTNLGRP_DECnet_IFADDR , RTNLGRP_NOP2 , RTNLGRP_DECnet_ROUTE , RTNLGRP_DECnet_RULE , RTNLGRP_NOP4 , RTNLGRP_IPV6_PREFIX , RTNLGRP_IPV6_RULE , RTNLGRP_ND_USEROPT , RTNLGRP_PHONET_IFADDR , RTNLGRP_PHONET_ROUTE , RTNLGRP_DCB , RTNLGRP_IPV4_NETCONF , RTNLGRP_IPV6_NETCONF , RTNLGRP_MDB , __RTNLGRP_MAX } ;
enum vlan_ioctl_cmds { ADD_VLAN_CMD , DEL_VLAN_CMD , SET_VLAN_INGRESS_PRIORITY_CMD , SET_VLAN_EGRESS_PRIORITY_CMD , GET_VLAN_INGRESS_PRIORITY_CMD , GET_VLAN_EGRESS_PRIORITY_CMD , SET_VLAN_NAME_TYPE_CMD , SET_VLAN_FLAG_CMD , GET_VLAN_REALDEV_NAME_CMD , GET_VLAN_VID_CMD } ;
enum vlan_flags { VLAN_FLAG_REORDER_HDR = 0x1 , VLAN_FLAG_GVRP = 0x2 , VLAN_FLAG_LOOSE_BINDING = 0x4 , } ;
enum vlan_name_types { VLAN_NAME_TYPE_PLUS_VID , VLAN_NAME_TYPE_RAW_PLUS_VID , VLAN_NAME_TYPE_PLUS_VID_NO_PAD , VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD , VLAN_NAME_TYPE_HIGHEST } ;
enum mapping_flags { AS_EIO = 25 + 0 , AS_ENOSPC = 25 + 1 , AS_MM_ALL_LOCKS = 25 + 2 , AS_UNEVICTABLE = 25 + 3 , AS_BALLOON_MAP = 25 + 4 , } ;
enum { DEVCONF_FORWARDING = 0 , DEVCONF_HOPLIMIT , DEVCONF_MTU6 , DEVCONF_ACCEPT_RA , DEVCONF_ACCEPT_REDIRECTS , DEVCONF_AUTOCONF , DEVCONF_DAD_TRANSMITS , DEVCONF_RTR_SOLICITS , DEVCONF_RTR_SOLICIT_INTERVAL , DEVCONF_RTR_SOLICIT_DELAY , DEVCONF_USE_TEMPADDR , DEVCONF_TEMP_VALID_LFT , DEVCONF_TEMP_PREFERED_LFT , DEVCONF_REGEN_MAX_RETRY , DEVCONF_MAX_DESYNC_FACTOR , DEVCONF_MAX_ADDRESSES , DEVCONF_FORCE_MLD_VERSION , DEVCONF_ACCEPT_RA_DEFRTR , DEVCONF_ACCEPT_RA_PINFO , DEVCONF_ACCEPT_RA_RTR_PREF , DEVCONF_RTR_PROBE_INTERVAL , DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN , DEVCONF_PROXY_NDP , DEVCONF_OPTIMISTIC_DAD , DEVCONF_ACCEPT_SOURCE_ROUTE , DEVCONF_MC_FORWARDING , DEVCONF_DISABLE_IPV6 , DEVCONF_ACCEPT_DAD , DEVCONF_FORCE_TLLAO , DEVCONF_NDISC_NOTIFY , DEVCONF_MAX } ;
struct mem_cgroup ;
struct page_cgroup ;
enum mem_cgroup_page_stat_item { MEMCG_NR_FILE_MAPPED , } ;
struct mem_cgroup ;
enum { UNDER_LIMIT , SOFT_LIMIT , OVER_LIMIT , } ;
enum { RES_USAGE , RES_MAX_USAGE , RES_LIMIT , RES_FAILCNT , RES_SOFT_LIMIT , } ;
enum { BPF_S_RET_K = 1 , BPF_S_RET_A , BPF_S_ALU_ADD_K , BPF_S_ALU_ADD_X , BPF_S_ALU_SUB_K , BPF_S_ALU_SUB_X , BPF_S_ALU_MUL_K , BPF_S_ALU_MUL_X , BPF_S_ALU_DIV_X , BPF_S_ALU_MOD_K , BPF_S_ALU_MOD_X , BPF_S_ALU_AND_K , BPF_S_ALU_AND_X , BPF_S_ALU_OR_K , BPF_S_ALU_OR_X , BPF_S_ALU_XOR_K , BPF_S_ALU_XOR_X , BPF_S_ALU_LSH_K , BPF_S_ALU_LSH_X , BPF_S_ALU_RSH_K , BPF_S_ALU_RSH_X , BPF_S_ALU_NEG , BPF_S_LD_W_ABS , BPF_S_LD_H_ABS , BPF_S_LD_B_ABS , BPF_S_LD_W_LEN , BPF_S_LD_W_IND , BPF_S_LD_H_IND , BPF_S_LD_B_IND , BPF_S_LD_IMM , BPF_S_LDX_W_LEN , BPF_S_LDX_B_MSH , BPF_S_LDX_IMM , BPF_S_MISC_TAX , BPF_S_MISC_TXA , BPF_S_ALU_DIV_K , BPF_S_LD_MEM , BPF_S_LDX_MEM , BPF_S_ST , BPF_S_STX , BPF_S_JMP_JA , BPF_S_JMP_JEQ_K , BPF_S_JMP_JEQ_X , BPF_S_JMP_JGE_K , BPF_S_JMP_JGE_X , BPF_S_JMP_JGT_K , BPF_S_JMP_JGT_X , BPF_S_JMP_JSET_K , BPF_S_JMP_JSET_X , BPF_S_ANC_PROTOCOL , BPF_S_ANC_PKTTYPE , BPF_S_ANC_IFINDEX , BPF_S_ANC_NLATTR , BPF_S_ANC_NLATTR_NEST , BPF_S_ANC_MARK , BPF_S_ANC_QUEUE , BPF_S_ANC_HATYPE , BPF_S_ANC_RXHASH , BPF_S_ANC_CPU , BPF_S_ANC_ALU_XOR_X , BPF_S_ANC_SECCOMP_LD_W , BPF_S_ANC_VLAN_TAG , BPF_S_ANC_VLAN_TAG_PRESENT , } ;
enum { NLA_UNSPEC , NLA_U8 , NLA_U16 , NLA_U32 , NLA_U64 , NLA_STRING , NLA_FLAG , NLA_MSECS , NLA_NESTED , NLA_NESTED_COMPAT , NLA_NUL_STRING , NLA_BINARY , NLA_S8 , NLA_S16 , NLA_S32 , NLA_S64 , __NLA_TYPE_MAX , } ;
enum { XFRM_LOOKUP_ICMP = 1 << 0 , } ;
enum sock_flags { SOCK_DEAD , SOCK_DONE , SOCK_URGINLINE , SOCK_KEEPOPEN , SOCK_LINGER , SOCK_DESTROY , SOCK_BROADCAST , SOCK_TIMESTAMP , SOCK_ZAPPED , SOCK_USE_WRITE_QUEUE , SOCK_DBG , SOCK_RCVTSTAMP , SOCK_RCVTSTAMPNS , SOCK_LOCALROUTE , SOCK_QUEUE_SHRUNK , SOCK_MEMALLOC , SOCK_TIMESTAMPING_TX_HARDWARE , SOCK_TIMESTAMPING_TX_SOFTWARE , SOCK_TIMESTAMPING_RX_HARDWARE , SOCK_TIMESTAMPING_RX_SOFTWARE , SOCK_TIMESTAMPING_SOFTWARE , SOCK_TIMESTAMPING_RAW_HARDWARE , SOCK_TIMESTAMPING_SYS_HARDWARE , SOCK_FASYNC , SOCK_RXQ_OVFL , SOCK_ZEROCOPY , SOCK_WIFI_STATUS , SOCK_NOFCS , } ;
struct inet_hashinfo ;
struct raw_hashinfo ;
enum cg_proto_flags { MEMCG_SOCK_ACTIVE , MEMCG_SOCK_ACTIVATED , } ;
struct request_values { } ;
struct ip_mc_socklist ;
struct rtable ;
struct inet_bind_bucket ;
struct tcp_congestion_ops ;
enum inet_csk_ack_state_t { ICSK_ACK_SCHED = 1 , ICSK_ACK_TIMER = 2 , ICSK_ACK_PUSHED = 4 , ICSK_ACK_PUSHED2 = 8 } ;
enum { TCP_ESTABLISHED = 1 , TCP_SYN_SENT , TCP_SYN_RECV , TCP_FIN_WAIT1 , TCP_FIN_WAIT2 , TCP_TIME_WAIT , TCP_CLOSE , TCP_CLOSE_WAIT , TCP_LAST_ACK , TCP_LISTEN , TCP_CLOSING , TCP_MAX_STATES } ;
enum { TCPF_ESTABLISHED = ( 1 << 1 ) , TCPF_SYN_SENT = ( 1 << 2 ) , TCPF_SYN_RECV = ( 1 << 3 ) , TCPF_FIN_WAIT1 = ( 1 << 4 ) , TCPF_FIN_WAIT2 = ( 1 << 5 ) , TCPF_TIME_WAIT = ( 1 << 6 ) , TCPF_CLOSE = ( 1 << 7 ) , TCPF_CLOSE_WAIT = ( 1 << 8 ) , TCPF_LAST_ACK = ( 1 << 9 ) , TCPF_LISTEN = ( 1 << 10 ) , TCPF_CLOSING = ( 1 << 11 ) } ;
struct inet_hashinfo ;
struct inet_bind_bucket ;
enum { TCP_NO_QUEUE , TCP_RECV_QUEUE , TCP_SEND_QUEUE , TCP_QUEUES_NR , } ;
enum tcp_ca_state { TCP_CA_Open = 0 , TCP_CA_Disorder = 1 , TCP_CA_CWR = 2 , TCP_CA_Recovery = 3 , TCP_CA_Loss = 4 } ;
struct tcp_cookie_values ;
struct tcp_request_sock_ops ;
enum tsq_flags { TSQ_THROTTLED , TSQ_QUEUED , TCP_TSQ_DEFERRED , TCP_WRITE_TIMER_DEFERRED , TCP_DELACK_TIMER_DEFERRED , TCP_MTU_REDUCED_DEFERRED , } ;
struct ipv6_mc_socklist ;
struct ipv6_ac_socklist ;
struct ipv6_fl_socklist ;
enum { TCA_STAB_UNSPEC , TCA_STAB_BASE , TCA_STAB_DATA , __TCA_STAB_MAX } ;
enum { TCA_TBF_UNSPEC , TCA_TBF_PARMS , TCA_TBF_RTAB , TCA_TBF_PTAB , __TCA_TBF_MAX , } ;
enum { TCA_RED_UNSPEC , TCA_RED_PARMS , TCA_RED_STAB , __TCA_RED_MAX , } ;
enum { TCA_GRED_UNSPEC , TCA_GRED_PARMS , TCA_GRED_STAB , TCA_GRED_DPS , __TCA_GRED_MAX , } ;
enum { TCA_CHOKE_UNSPEC , TCA_CHOKE_PARMS , TCA_CHOKE_STAB , __TCA_CHOKE_MAX , } ;
enum { TCA_HTB_UNSPEC , TCA_HTB_PARMS , TCA_HTB_INIT , TCA_HTB_CTAB , TCA_HTB_RTAB , __TCA_HTB_MAX , } ;
enum { TCA_HFSC_UNSPEC , TCA_HFSC_RSC , TCA_HFSC_FSC , TCA_HFSC_USC , __TCA_HFSC_MAX , } ;
enum { TCA_CBQ_UNSPEC , TCA_CBQ_LSSOPT , TCA_CBQ_WRROPT , TCA_CBQ_FOPT , TCA_CBQ_OVL_STRATEGY , TCA_CBQ_RATE , TCA_CBQ_RTAB , TCA_CBQ_POLICE , __TCA_CBQ_MAX , } ;
enum { TCA_DSMARK_UNSPEC , TCA_DSMARK_INDICES , TCA_DSMARK_DEFAULT_INDEX , TCA_DSMARK_SET_TC_INDEX , TCA_DSMARK_MASK , TCA_DSMARK_VALUE , __TCA_DSMARK_MAX , } ;
enum { TCA_ATM_UNSPEC , TCA_ATM_FD , TCA_ATM_PTR , TCA_ATM_HDR , TCA_ATM_EXCESS , TCA_ATM_ADDR , TCA_ATM_STATE , __TCA_ATM_MAX , } ;
enum { TCA_NETEM_UNSPEC , TCA_NETEM_CORR , TCA_NETEM_DELAY_DIST , TCA_NETEM_REORDER , TCA_NETEM_CORRUPT , TCA_NETEM_LOSS , __TCA_NETEM_MAX , } ;
enum { NETEM_LOSS_UNSPEC , NETEM_LOSS_GI , NETEM_LOSS_GE , __NETEM_LOSS_MAX } ;
enum { TCA_DRR_UNSPEC , TCA_DRR_QUANTUM , __TCA_DRR_MAX } ;
enum { TCA_SFB_UNSPEC , TCA_SFB_PARMS , __TCA_SFB_MAX , } ;
enum { TCA_QFQ_UNSPEC , TCA_QFQ_WEIGHT , TCA_QFQ_LMAX , __TCA_QFQ_MAX } ;
enum { TCA_ACT_UNSPEC , TCA_ACT_KIND , TCA_ACT_OPTIONS , TCA_ACT_INDEX , TCA_ACT_STATS , __TCA_ACT_MAX } ;
enum { TCA_ID_UNSPEC = 0 , TCA_ID_POLICE = 1 , __TCA_ID_MAX = 255 } ;
enum { TCA_POLICE_UNSPEC , TCA_POLICE_TBF , TCA_POLICE_RATE , TCA_POLICE_PEAKRATE , TCA_POLICE_AVRATE , TCA_POLICE_RESULT , __TCA_POLICE_MAX } ;
enum { TCA_U32_UNSPEC , TCA_U32_CLASSID , TCA_U32_HASH , TCA_U32_LINK , TCA_U32_DIVISOR , TCA_U32_SEL , TCA_U32_POLICE , TCA_U32_ACT , TCA_U32_INDEV , TCA_U32_PCNT , TCA_U32_MARK , __TCA_U32_MAX } ;
enum { TCA_RSVP_UNSPEC , TCA_RSVP_CLASSID , TCA_RSVP_DST , TCA_RSVP_SRC , TCA_RSVP_PINFO , TCA_RSVP_POLICE , TCA_RSVP_ACT , __TCA_RSVP_MAX } ;
enum { TCA_ROUTE4_UNSPEC , TCA_ROUTE4_CLASSID , TCA_ROUTE4_TO , TCA_ROUTE4_FROM , TCA_ROUTE4_IIF , TCA_ROUTE4_POLICE , TCA_ROUTE4_ACT , __TCA_ROUTE4_MAX } ;
enum { TCA_FW_UNSPEC , TCA_FW_CLASSID , TCA_FW_POLICE , TCA_FW_INDEV , TCA_FW_ACT , TCA_FW_MASK , __TCA_FW_MAX } ;
enum { TCA_TCINDEX_UNSPEC , TCA_TCINDEX_HASH , TCA_TCINDEX_MASK , TCA_TCINDEX_SHIFT , TCA_TCINDEX_FALL_THROUGH , TCA_TCINDEX_CLASSID , TCA_TCINDEX_POLICE , TCA_TCINDEX_ACT , __TCA_TCINDEX_MAX } ;
enum { FLOW_KEY_SRC , FLOW_KEY_DST , FLOW_KEY_PROTO , FLOW_KEY_PROTO_SRC , FLOW_KEY_PROTO_DST , FLOW_KEY_IIF , FLOW_KEY_PRIORITY , FLOW_KEY_MARK , FLOW_KEY_NFCT , FLOW_KEY_NFCT_SRC , FLOW_KEY_NFCT_DST , FLOW_KEY_NFCT_PROTO_SRC , FLOW_KEY_NFCT_PROTO_DST , FLOW_KEY_RTCLASSID , FLOW_KEY_SKUID , FLOW_KEY_SKGID , FLOW_KEY_VLAN_TAG , FLOW_KEY_RXHASH , __FLOW_KEY_MAX , } ;
enum { FLOW_MODE_MAP , FLOW_MODE_HASH , } ;
enum { TCA_FLOW_UNSPEC , TCA_FLOW_KEYS , TCA_FLOW_MODE , TCA_FLOW_BASECLASS , TCA_FLOW_RSHIFT , TCA_FLOW_ADDEND , TCA_FLOW_MASK , TCA_FLOW_XOR , TCA_FLOW_DIVISOR , TCA_FLOW_ACT , TCA_FLOW_POLICE , TCA_FLOW_EMATCHES , TCA_FLOW_PERTURB , __TCA_FLOW_MAX } ;
enum { TCA_BASIC_UNSPEC , TCA_BASIC_CLASSID , TCA_BASIC_EMATCHES , TCA_BASIC_ACT , TCA_BASIC_POLICE , __TCA_BASIC_MAX } ;
enum { TCA_CGROUP_UNSPEC , TCA_CGROUP_ACT , TCA_CGROUP_POLICE , TCA_CGROUP_EMATCHES , __TCA_CGROUP_MAX , } ;
enum { TCA_EMATCH_TREE_UNSPEC , TCA_EMATCH_TREE_HDR , TCA_EMATCH_TREE_LIST , __TCA_EMATCH_TREE_MAX } ;
enum { TCF_LAYER_LINK , TCF_LAYER_NETWORK , TCF_LAYER_TRANSPORT , __TCF_LAYER_MAX } ;
enum { TCF_EM_PROG_TC } ;
enum { TCF_EM_OPND_EQ , TCF_EM_OPND_GT , TCF_EM_OPND_LT } ;
enum { TCA_STATS_UNSPEC , TCA_STATS_BASIC , TCA_STATS_RATE_EST , TCA_STATS_QUEUE , TCA_STATS_APP , __TCA_STATS_MAX , } ;
struct tcf_walker ;
enum qdisc_state_t { __QDISC_STATE_SCHED , __QDISC_STATE_DEACTIVATED , __QDISC_STATE_THROTTLED , } ;
enum qdisc___state_t { __QDISC___STATE_RUNNING = 1 , } ;
enum net_xmit_qdisc_t { __NET_XMIT_STOLEN = 0x00010000 , __NET_XMIT_BYPASS = 0x00020000 , } ;
enum reboot_type { BOOT_TRIPLE = 't' , BOOT_KBD = 'k' , BOOT_BIOS = 'b' , BOOT_ACPI = 'a' , BOOT_EFI = 'e' , BOOT_CF9 = 'p' , BOOT_CF9_COND = 'q' , } ;
enum { DOS_EXTENDED_PARTITION = 5 , LINUX_EXTENDED_PARTITION = 0x85 , WIN98_EXTENDED_PARTITION = 0x0f , SUN_WHOLE_DISK = DOS_EXTENDED_PARTITION , LINUX_SWAP_PARTITION = 0x82 , LINUX_DATA_PARTITION = 0x83 , LINUX_LVM_PARTITION = 0x8e , LINUX_RAID_PARTITION = 0xfd , SOLARIS_X86_PARTITION = LINUX_SWAP_PARTITION , NEW_SOLARIS_X86_PARTITION = 0xbf , DM6_AUX1PARTITION = 0x51 , DM6_AUX3PARTITION = 0x53 , DM6_PARTITION = 0x54 , EZD_PARTITION = 0x55 , FREEBSD_PARTITION = 0xa5 , OPENBSD_PARTITION = 0xa6 , NETBSD_PARTITION = 0xa9 , BSDI_PARTITION = 0xb7 , MINIX_PARTITION = 0x81 , UNIXWARE_PARTITION = 0x63 , } ;
enum { DISK_EVENT_MEDIA_CHANGE = 1 << 0 , DISK_EVENT_EJECT_REQUEST = 1 << 1 , } ;
struct disk_events ;
enum writeback_sync_modes { WB_SYNC_NONE , WB_SYNC_ALL , } ;
enum wb_reason { WB_REASON_BACKGROUND , WB_REASON_TRY_TO_FREE_PAGES , WB_REASON_SYNC , WB_REASON_PERIODIC , WB_REASON_LAPTOP_TIMER , WB_REASON_FREE_MORE_MEM , WB_REASON_FS_FREE_SPACE , WB_REASON_FORKER_THREAD , WB_REASON_MAX , } ;
enum bdi_state { BDI_pending , BDI_wb_alloc , BDI_async_congested , BDI_sync_congested , BDI_registered , BDI_writeback_running , BDI_unused , } ;
enum bdi_stat_item { BDI_RECLAIMABLE , BDI_WRITEBACK , BDI_DIRTIED , BDI_WRITTEN , NR_BDI_STAT_ITEMS } ;
enum { BLK_RW_ASYNC = 0 , BLK_RW_SYNC = 1 , } ;
enum { ICQ_EXITED = 1 << 2 , } ;
enum { IOPRIO_CLASS_NONE , IOPRIO_CLASS_RT , IOPRIO_CLASS_BE , IOPRIO_CLASS_IDLE , } ;
enum { IOPRIO_WHO_PROCESS = 1 , IOPRIO_WHO_PGRP , IOPRIO_WHO_USER , } ;
struct sg_iovec ;
struct scsi_ioctl_command ;
struct blk_trace ;
struct sg_io_hdr ;
struct bsg_job ;
struct blkcg_gq ;
enum rq_cmd_type_bits { REQ_TYPE_FS = 1 , REQ_TYPE_BLOCK_PC , REQ_TYPE_SENSE , REQ_TYPE_PM_SUSPEND , REQ_TYPE_PM_RESUME , REQ_TYPE_PM_SHUTDOWN , REQ_TYPE_SPECIAL , REQ_TYPE_ATA_TASKFILE , REQ_TYPE_ATA_PC , } ;
enum { ELV_MQUEUE_MAY , ELV_MQUEUE_NO , ELV_MQUEUE_MUST , } ;
enum blk_eh_timer_return { BLK_EH_NOT_HANDLED , BLK_EH_HANDLED , BLK_EH_RESET_TIMER , } ;
enum blk_queue_state { Queue_down , Queue_up , } ;
enum blk_default_limits { BLK_MAX_SEGMENTS = 128 , BLK_SAFE_MAX_SECTORS = 255 , BLK_DEF_MAX_SECTORS = 1024 , BLK_MAX_SEGMENT_SIZE = 65536 , BLK_SEG_BOUNDARY_MASK = 0xFFFFFFFFUL , } ;
enum bh_state_bits { BH_Uptodate , BH_Dirty , BH_Lock , BH_Req , BH_Uptodate_Lock , BH_Mapped , BH_New , BH_Async_Read , BH_Async_Write , BH_Delay , BH_Boundary , BH_Write_EIO , BH_Unwritten , BH_Quiet , BH_PrivateStart , } ;
struct crypto_type ;
struct aead_givcrypt_request ;
struct skcipher_givcrypt_request ;
enum { CRYPTOA_UNSPEC , CRYPTOA_ALG , CRYPTOA_TYPE , CRYPTOA_U32 , __CRYPTOA_MAX , } ;
enum jbd_state_bits { BH_JBD = BH_PrivateStart , BH_JWrite , BH_Freed , BH_Revoked , BH_RevokeValid , BH_JBDDirty , BH_State , BH_JournalHead , BH_Unshadow , BH_Verified , BH_JBDPrivateStart , } ;
struct jbd2_revoke_table_s ;
struct mnt_namespace ;
struct memory_block ;
enum { SWP_USED = ( 1 << 0 ) , SWP_WRITEOK = ( 1 << 1 ) , SWP_DISCARDABLE = ( 1 << 2 ) , SWP_DISCARDING = ( 1 << 3 ) , SWP_SOLIDSTATE = ( 1 << 4 ) , SWP_CONTINUED = ( 1 << 5 ) , SWP_BLKDEV = ( 1 << 6 ) , SWP_FILE = ( 1 << 7 ) , SWP_SCANNING = ( 1 << 8 ) , } ;
enum { MAX_OPT_ARGS = 3 } ;
enum { MAX_NESTED_LINKS = 8 } ;
enum { LAST_NORM , LAST_ROOT , LAST_DOT , LAST_DOTDOT , LAST_BIND } ;
enum fid_type { FILEID_ROOT = 0 , FILEID_INO32_GEN = 1 , FILEID_INO32_GEN_PARENT = 2 , FILEID_BTRFS_WITHOUT_PARENT = 0x4d , FILEID_BTRFS_WITH_PARENT = 0x4e , FILEID_BTRFS_WITH_PARENT_ROOT = 0x4f , FILEID_UDF_WITHOUT_PARENT = 0x51 , FILEID_UDF_WITH_PARENT = 0x52 , FILEID_NILFS_WITHOUT_PARENT = 0x61 , FILEID_NILFS_WITH_PARENT = 0x62 , FILEID_INVALID = 0xff , } ;

enum { ATA_MAX_DEVICES = 2 , ATA_MAX_PRD = 256 , ATA_SECT_SIZE = 512 , ATA_MAX_SECTORS_128 = 128 , ATA_MAX_SECTORS = 256 , ATA_MAX_SECTORS_LBA48 = 65535 , ATA_MAX_SECTORS_TAPE = 65535 , ATA_ID_WORDS = 256 , ATA_ID_CONFIG = 0 , ATA_ID_CYLS = 1 , ATA_ID_HEADS = 3 , ATA_ID_SECTORS = 6 , ATA_ID_SERNO = 10 , ATA_ID_BUF_SIZE = 21 , ATA_ID_FW_REV = 23 , ATA_ID_PROD = 27 , ATA_ID_MAX_MULTSECT = 47 , ATA_ID_DWORD_IO = 48 , ATA_ID_CAPABILITY = 49 , ATA_ID_OLD_PIO_MODES = 51 , ATA_ID_OLD_DMA_MODES = 52 , ATA_ID_FIELD_VALID = 53 , ATA_ID_CUR_CYLS = 54 , ATA_ID_CUR_HEADS = 55 , ATA_ID_CUR_SECTORS = 56 , ATA_ID_MULTSECT = 59 , ATA_ID_LBA_CAPACITY = 60 , ATA_ID_SWDMA_MODES = 62 , ATA_ID_MWDMA_MODES = 63 , ATA_ID_PIO_MODES = 64 , ATA_ID_EIDE_DMA_MIN = 65 , ATA_ID_EIDE_DMA_TIME = 66 , ATA_ID_EIDE_PIO = 67 , ATA_ID_EIDE_PIO_IORDY = 68 , ATA_ID_ADDITIONAL_SUPP = 69 , ATA_ID_QUEUE_DEPTH = 75 , ATA_ID_SATA_CAPABILITY = 76 , ATA_ID_SATA_CAPABILITY_2 = 77 , ATA_ID_FEATURE_SUPP = 78 , ATA_ID_MAJOR_VER = 80 , ATA_ID_COMMAND_SET_1 = 82 , ATA_ID_COMMAND_SET_2 = 83 , ATA_ID_CFSSE = 84 , ATA_ID_CFS_ENABLE_1 = 85 , ATA_ID_CFS_ENABLE_2 = 86 , ATA_ID_CSF_DEFAULT = 87 , ATA_ID_UDMA_MODES = 88 , ATA_ID_HW_CONFIG = 93 , ATA_ID_SPG = 98 , ATA_ID_LBA_CAPACITY_2 = 100 , ATA_ID_SECTOR_SIZE = 106 , ATA_ID_WWN = 108 , ATA_ID_LOGICAL_SECTOR_SIZE = 117 , ATA_ID_LAST_LUN = 126 , ATA_ID_DLF = 128 , ATA_ID_CSFO = 129 , ATA_ID_CFA_POWER = 160 , ATA_ID_CFA_KEY_MGMT = 162 , ATA_ID_CFA_MODES = 163 , ATA_ID_DATA_SET_MGMT = 169 , ATA_ID_ROT_SPEED = 217 , ATA_ID_PIO4 = ( 1 << 1 ) , ATA_ID_SERNO_LEN = 20 , ATA_ID_FW_REV_LEN = 8 , ATA_ID_PROD_LEN = 40 , ATA_ID_WWN_LEN = 8 , ATA_PCI_CTL_OFS = 2 , ATA_PIO0 = ( 1 << 0 ) , ATA_PIO1 = ATA_PIO0 | ( 1 << 1 ) , ATA_PIO2 = ATA_PIO1 | ( 1 << 2 ) , ATA_PIO3 = ATA_PIO2 | ( 1 << 3 ) , ATA_PIO4 = ATA_PIO3 | ( 1 << 4 ) , ATA_PIO5 = ATA_PIO4 | ( 1 << 5 ) , ATA_PIO6 = ATA_PIO5 | ( 1 << 6 ) , ATA_PIO4_ONLY = ( 1 << 4 ) , ATA_SWDMA0 = ( 1 << 0 ) , ATA_SWDMA1 = ATA_SWDMA0 | ( 1 << 1 ) , ATA_SWDMA2 = ATA_SWDMA1 | ( 1 << 2 ) , ATA_SWDMA2_ONLY = ( 1 << 2 ) , ATA_MWDMA0 = ( 1 << 0 ) , ATA_MWDMA1 = ATA_MWDMA0 | ( 1 << 1 ) , ATA_MWDMA2 = ATA_MWDMA1 | ( 1 << 2 ) , ATA_MWDMA3 = ATA_MWDMA2 | ( 1 << 3 ) , ATA_MWDMA4 = ATA_MWDMA3 | ( 1 << 4 ) , ATA_MWDMA12_ONLY = ( 1 << 1 ) | ( 1 << 2 ) , ATA_MWDMA2_ONLY = ( 1 << 2 ) , ATA_UDMA0 = ( 1 << 0 ) , ATA_UDMA1 = ATA_UDMA0 | ( 1 << 1 ) , ATA_UDMA2 = ATA_UDMA1 | ( 1 << 2 ) , ATA_UDMA3 = ATA_UDMA2 | ( 1 << 3 ) , ATA_UDMA4 = ATA_UDMA3 | ( 1 << 4 ) , ATA_UDMA5 = ATA_UDMA4 | ( 1 << 5 ) , ATA_UDMA6 = ATA_UDMA5 | ( 1 << 6 ) , ATA_UDMA7 = ATA_UDMA6 | ( 1 << 7 ) , ATA_UDMA24_ONLY = ( 1 << 2 ) | ( 1 << 4 ) , ATA_UDMA_MASK_40C = ATA_UDMA2 , ATA_PRD_SZ = 8 , ATA_PRD_TBL_SZ = ( ATA_MAX_PRD * ATA_PRD_SZ ) , ATA_PRD_EOT = ( 1 << 31 ) , ATA_DMA_TABLE_OFS = 4 , ATA_DMA_STATUS = 2 , ATA_DMA_CMD = 0 , ATA_DMA_WR = ( 1 << 3 ) , ATA_DMA_START = ( 1 << 0 ) , ATA_DMA_INTR = ( 1 << 2 ) , ATA_DMA_ERR = ( 1 << 1 ) , ATA_DMA_ACTIVE = ( 1 << 0 ) , ATA_HOB = ( 1 << 7 ) , ATA_NIEN = ( 1 << 1 ) , ATA_LBA = ( 1 << 6 ) , ATA_DEV1 = ( 1 << 4 ) , ATA_DEVICE_OBS = ( 1 << 7 ) | ( 1 << 5 ) , ATA_DEVCTL_OBS = ( 1 << 3 ) , ATA_BUSY = ( 1 << 7 ) , ATA_DRDY = ( 1 << 6 ) , ATA_DF = ( 1 << 5 ) , ATA_DSC = ( 1 << 4 ) , ATA_DRQ = ( 1 << 3 ) , ATA_CORR = ( 1 << 2 ) , ATA_IDX = ( 1 << 1 ) , ATA_ERR = ( 1 << 0 ) , ATA_SRST = ( 1 << 2 ) , ATA_ICRC = ( 1 << 7 ) , ATA_BBK = ATA_ICRC , ATA_UNC = ( 1 << 6 ) , ATA_MC = ( 1 << 5 ) , ATA_IDNF = ( 1 << 4 ) , ATA_MCR = ( 1 << 3 ) , ATA_ABORTED = ( 1 << 2 ) , ATA_TRK0NF = ( 1 << 1 ) , ATA_AMNF = ( 1 << 0 ) , ATAPI_LFS = 0xF0 , ATAPI_EOM = ATA_TRK0NF , ATAPI_ILI = ATA_AMNF , ATAPI_IO = ( 1 << 1 ) , ATAPI_COD = ( 1 << 0 ) , ATA_REG_DATA = 0x00 , ATA_REG_ERR = 0x01 , ATA_REG_NSECT = 0x02 , ATA_REG_LBAL = 0x03 , ATA_REG_LBAM = 0x04 , ATA_REG_LBAH = 0x05 , ATA_REG_DEVICE = 0x06 , ATA_REG_STATUS = 0x07 , ATA_REG_FEATURE = ATA_REG_ERR , ATA_REG_CMD = ATA_REG_STATUS , ATA_REG_BYTEL = ATA_REG_LBAM , ATA_REG_BYTEH = ATA_REG_LBAH , ATA_REG_DEVSEL = ATA_REG_DEVICE , ATA_REG_IRQ = ATA_REG_NSECT , ATA_CMD_DEV_RESET = 0x08 , ATA_CMD_CHK_POWER = 0xE5 , ATA_CMD_STANDBY = 0xE2 , ATA_CMD_IDLE = 0xE3 , ATA_CMD_EDD = 0x90 , ATA_CMD_DOWNLOAD_MICRO = 0x92 , ATA_CMD_NOP = 0x00 , ATA_CMD_FLUSH = 0xE7 , ATA_CMD_FLUSH_EXT = 0xEA , ATA_CMD_ID_ATA = 0xEC , ATA_CMD_ID_ATAPI = 0xA1 , ATA_CMD_SERVICE = 0xA2 , ATA_CMD_READ = 0xC8 , ATA_CMD_READ_EXT = 0x25 , ATA_CMD_READ_QUEUED = 0x26 , ATA_CMD_READ_STREAM_EXT = 0x2B , ATA_CMD_READ_STREAM_DMA_EXT = 0x2A , ATA_CMD_WRITE = 0xCA , ATA_CMD_WRITE_EXT = 0x35 , ATA_CMD_WRITE_QUEUED = 0x36 , ATA_CMD_WRITE_STREAM_EXT = 0x3B , ATA_CMD_WRITE_STREAM_DMA_EXT = 0x3A , ATA_CMD_WRITE_FUA_EXT = 0x3D , ATA_CMD_WRITE_QUEUED_FUA_EXT = 0x3E , ATA_CMD_FPDMA_READ = 0x60 , ATA_CMD_FPDMA_WRITE = 0x61 , ATA_CMD_PIO_READ = 0x20 , ATA_CMD_PIO_READ_EXT = 0x24 , ATA_CMD_PIO_WRITE = 0x30 , ATA_CMD_PIO_WRITE_EXT = 0x34 , ATA_CMD_READ_MULTI = 0xC4 , ATA_CMD_READ_MULTI_EXT = 0x29 , ATA_CMD_WRITE_MULTI = 0xC5 , ATA_CMD_WRITE_MULTI_EXT = 0x39 , ATA_CMD_WRITE_MULTI_FUA_EXT = 0xCE , ATA_CMD_SET_FEATURES = 0xEF , ATA_CMD_SET_MULTI = 0xC6 , ATA_CMD_PACKET = 0xA0 , ATA_CMD_VERIFY = 0x40 , ATA_CMD_VERIFY_EXT = 0x42 , ATA_CMD_WRITE_UNCORR_EXT = 0x45 , ATA_CMD_STANDBYNOW1 = 0xE0 , ATA_CMD_IDLEIMMEDIATE = 0xE1 , ATA_CMD_SLEEP = 0xE6 , ATA_CMD_INIT_DEV_PARAMS = 0x91 , ATA_CMD_READ_NATIVE_MAX = 0xF8 , ATA_CMD_READ_NATIVE_MAX_EXT = 0x27 , ATA_CMD_SET_MAX = 0xF9 , ATA_CMD_SET_MAX_EXT = 0x37 , ATA_CMD_READ_LOG_EXT = 0x2F , ATA_CMD_WRITE_LOG_EXT = 0x3F , ATA_CMD_READ_LOG_DMA_EXT = 0x47 , ATA_CMD_WRITE_LOG_DMA_EXT = 0x57 , ATA_CMD_TRUSTED_RCV = 0x5C , ATA_CMD_TRUSTED_RCV_DMA = 0x5D , ATA_CMD_TRUSTED_SND = 0x5E , ATA_CMD_TRUSTED_SND_DMA = 0x5F , ATA_CMD_PMP_READ = 0xE4 , ATA_CMD_PMP_WRITE = 0xE8 , ATA_CMD_CONF_OVERLAY = 0xB1 , ATA_CMD_SEC_SET_PASS = 0xF1 , ATA_CMD_SEC_UNLOCK = 0xF2 , ATA_CMD_SEC_ERASE_PREP = 0xF3 , ATA_CMD_SEC_ERASE_UNIT = 0xF4 , ATA_CMD_SEC_FREEZE_LOCK = 0xF5 , ATA_CMD_SEC_DISABLE_PASS = 0xF6 , ATA_CMD_CONFIG_STREAM = 0x51 , ATA_CMD_SMART = 0xB0 , ATA_CMD_MEDIA_LOCK = 0xDE , ATA_CMD_MEDIA_UNLOCK = 0xDF , ATA_CMD_DSM = 0x06 , ATA_CMD_CHK_MED_CRD_TYP = 0xD1 , ATA_CMD_CFA_REQ_EXT_ERR = 0x03 , ATA_CMD_CFA_WRITE_NE = 0x38 , ATA_CMD_CFA_TRANS_SECT = 0x87 , ATA_CMD_CFA_ERASE = 0xC0 , ATA_CMD_CFA_WRITE_MULT_NE = 0xCD , ATA_CMD_RESTORE = 0x10 , ATA_LOG_SATA_NCQ = 0x10 , ATA_LOG_SATA_ID_DEV_DATA = 0x30 , ATA_LOG_SATA_SETTINGS = 0x08 , ATA_LOG_DEVSLP_OFFSET = 0x30 , ATA_LOG_DEVSLP_SIZE = 0x08 , ATA_LOG_DEVSLP_MDAT = 0x00 , ATA_LOG_DEVSLP_MDAT_MASK = 0x1F , ATA_LOG_DEVSLP_DETO = 0x01 , ATA_LOG_DEVSLP_VALID = 0x07 , ATA_LOG_DEVSLP_VALID_MASK = 0x80 , ATA_CMD_READ_LONG = 0x22 , ATA_CMD_READ_LONG_ONCE = 0x23 , ATA_CMD_WRITE_LONG = 0x32 , ATA_CMD_WRITE_LONG_ONCE = 0x33 , SETFEATURES_XFER = 0x03 , XFER_UDMA_7 = 0x47 , XFER_UDMA_6 = 0x46 , XFER_UDMA_5 = 0x45 , XFER_UDMA_4 = 0x44 , XFER_UDMA_3 = 0x43 , XFER_UDMA_2 = 0x42 , XFER_UDMA_1 = 0x41 , XFER_UDMA_0 = 0x40 , XFER_MW_DMA_4 = 0x24 , XFER_MW_DMA_3 = 0x23 , XFER_MW_DMA_2 = 0x22 , XFER_MW_DMA_1 = 0x21 , XFER_MW_DMA_0 = 0x20 , XFER_SW_DMA_2 = 0x12 , XFER_SW_DMA_1 = 0x11 , XFER_SW_DMA_0 = 0x10 , XFER_PIO_6 = 0x0E , XFER_PIO_5 = 0x0D , XFER_PIO_4 = 0x0C , XFER_PIO_3 = 0x0B , XFER_PIO_2 = 0x0A , XFER_PIO_1 = 0x09 , XFER_PIO_0 = 0x08 , XFER_PIO_SLOW = 0x00 , SETFEATURES_WC_ON = 0x02 , SETFEATURES_WC_OFF = 0x82 , SETFEATURES_AAM_ON = 0x42 , SETFEATURES_AAM_OFF = 0xC2 , SETFEATURES_SPINUP = 0x07 , SETFEATURES_SATA_ENABLE = 0x10 , SETFEATURES_SATA_DISABLE = 0x90 , SATA_FPDMA_OFFSET = 0x01 , SATA_FPDMA_AA = 0x02 , SATA_DIPM = 0x03 , SATA_FPDMA_IN_ORDER = 0x04 , SATA_AN = 0x05 , SATA_SSP = 0x06 , SATA_DEVSLP = 0x09 , ATA_SET_MAX_ADDR = 0x00 , ATA_SET_MAX_PASSWD = 0x01 , ATA_SET_MAX_LOCK = 0x02 , ATA_SET_MAX_UNLOCK = 0x03 , ATA_SET_MAX_FREEZE_LOCK = 0x04 , ATA_DCO_RESTORE = 0xC0 , ATA_DCO_FREEZE_LOCK = 0xC1 , ATA_DCO_IDENTIFY = 0xC2 , ATA_DCO_SET = 0xC3 , ATA_SMART_ENABLE = 0xD8 , ATA_SMART_READ_VALUES = 0xD0 , ATA_SMART_READ_THRESHOLDS = 0xD1 , ATA_DSM_TRIM = 0x01 , ATA_SMART_LBAM_PASS = 0x4F , ATA_SMART_LBAH_PASS = 0xC2 , ATAPI_PKT_DMA = ( 1 << 0 ) , ATAPI_DMADIR = ( 1 << 2 ) , ATAPI_CDB_LEN = 16 , SATA_PMP_MAX_PORTS = 15 , SATA_PMP_CTRL_PORT = 15 , SATA_PMP_GSCR_DWORDS = 128 , SATA_PMP_GSCR_PROD_ID = 0 , SATA_PMP_GSCR_REV = 1 , SATA_PMP_GSCR_PORT_INFO = 2 , SATA_PMP_GSCR_ERROR = 32 , SATA_PMP_GSCR_ERROR_EN = 33 , SATA_PMP_GSCR_FEAT = 64 , SATA_PMP_GSCR_FEAT_EN = 96 , SATA_PMP_PSCR_STATUS = 0 , SATA_PMP_PSCR_ERROR = 1 , SATA_PMP_PSCR_CONTROL = 2 , SATA_PMP_FEAT_BIST = ( 1 << 0 ) , SATA_PMP_FEAT_PMREQ = ( 1 << 1 ) , SATA_PMP_FEAT_DYNSSC = ( 1 << 2 ) , SATA_PMP_FEAT_NOTIFY = ( 1 << 3 ) , ATA_CBL_NONE = 0 , ATA_CBL_PATA40 = 1 , ATA_CBL_PATA80 = 2 , ATA_CBL_PATA40_SHORT = 3 , ATA_CBL_PATA_UNK = 4 , ATA_CBL_PATA_IGN = 5 , ATA_CBL_SATA = 6 , SCR_STATUS = 0 , SCR_ERROR = 1 , SCR_CONTROL = 2 , SCR_ACTIVE = 3 , SCR_NOTIFICATION = 4 , SERR_DATA_RECOVERED = ( 1 << 0 ) , SERR_COMM_RECOVERED = ( 1 << 1 ) , SERR_DATA = ( 1 << 8 ) , SERR_PERSISTENT = ( 1 << 9 ) , SERR_PROTOCOL = ( 1 << 10 ) , SERR_INTERNAL = ( 1 << 11 ) , SERR_PHYRDY_CHG = ( 1 << 16 ) , SERR_PHY_INT_ERR = ( 1 << 17 ) , SERR_COMM_WAKE = ( 1 << 18 ) , SERR_10B_8B_ERR = ( 1 << 19 ) , SERR_DISPARITY = ( 1 << 20 ) , SERR_CRC = ( 1 << 21 ) , SERR_HANDSHAKE = ( 1 << 22 ) , SERR_LINK_SEQ_ERR = ( 1 << 23 ) , SERR_TRANS_ST_ERROR = ( 1 << 24 ) , SERR_UNRECOG_FIS = ( 1 << 25 ) , SERR_DEV_XCHG = ( 1 << 26 ) , ATA_TFLAG_LBA48 = ( 1 << 0 ) , ATA_TFLAG_ISADDR = ( 1 << 1 ) , ATA_TFLAG_DEVICE = ( 1 << 2 ) , ATA_TFLAG_WRITE = ( 1 << 3 ) , ATA_TFLAG_LBA = ( 1 << 4 ) , ATA_TFLAG_FUA = ( 1 << 5 ) , ATA_TFLAG_POLLING = ( 1 << 6 ) , ATA_PROT_FLAG_PIO = ( 1 << 0 ) , ATA_PROT_FLAG_DMA = ( 1 << 1 ) , ATA_PROT_FLAG_DATA = ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA , ATA_PROT_FLAG_NCQ = ( 1 << 2 ) , ATA_PROT_FLAG_ATAPI = ( 1 << 3 ) , } ;
enum ata_tf_protocols { ATA_PROT_UNKNOWN , ATA_PROT_NODATA , ATA_PROT_PIO , ATA_PROT_DMA , ATA_PROT_NCQ , ATAPI_PROT_NODATA , ATAPI_PROT_PIO , ATAPI_PROT_DMA , } ;
enum ata_ioctls { ATA_IOC_GET_IO32 = 0x309 , ATA_IOC_SET_IO32 = 0x324 , } ;
struct scsi_cmnd ;
enum scsi_protocol { SCSI_PROTOCOL_FCP = 0 , SCSI_PROTOCOL_SPI = 1 , SCSI_PROTOCOL_SSA = 2 , SCSI_PROTOCOL_SBP = 3 , SCSI_PROTOCOL_SRP = 4 , SCSI_PROTOCOL_ISCSI = 5 , SCSI_PROTOCOL_SAS = 6 , SCSI_PROTOCOL_ADT = 7 , SCSI_PROTOCOL_ATA = 8 , SCSI_PROTOCOL_UNSPEC = 0xf , } ;
struct scsi_cmnd ;
struct scsi_device ;
struct scsi_target ;
struct scsi_host_cmd_pool ;
struct scsi_transport_template ;
struct blk_queue_tags ;
enum { SCSI_QDEPTH_DEFAULT , SCSI_QDEPTH_QFULL , SCSI_QDEPTH_RAMP_UP , } ;
enum scsi_host_state { SHOST_CREATED = 1 , SHOST_RUNNING , SHOST_CANCEL , SHOST_DEL , SHOST_RECOVERY , SHOST_CANCEL_RECOVERY , SHOST_DEL_RECOVERY , } ;
struct class_container ;
enum scsi_host_prot_capabilities { SHOST_DIF_TYPE1_PROTECTION = 1 << 0 , SHOST_DIF_TYPE2_PROTECTION = 1 << 1 , SHOST_DIF_TYPE3_PROTECTION = 1 << 2 , SHOST_DIX_TYPE0_PROTECTION = 1 << 3 , SHOST_DIX_TYPE1_PROTECTION = 1 << 4 , SHOST_DIX_TYPE2_PROTECTION = 1 << 5 , SHOST_DIX_TYPE3_PROTECTION = 1 << 6 , } ;
enum scsi_host_guard_type { SHOST_DIX_GUARD_CRC = 1 << 0 , SHOST_DIX_GUARD_IP = 1 << 1 , } ;
enum acpi_preferred_pm_profiles { PM_UNSPECIFIED = 0 , PM_DESKTOP = 1 , PM_MOBILE = 2 , PM_WORKSTATION = 3 , PM_ENTERPRISE_SERVER = 4 , PM_SOHO_SERVER = 5 , PM_APPLIANCE_PC = 6 , PM_PERFORMANCE_SERVER = 7 , PM_TABLET = 8 } ;
enum acpi_bert_error_severity { ACPI_BERT_ERROR_CORRECTABLE = 0 , ACPI_BERT_ERROR_FATAL = 1 , ACPI_BERT_ERROR_CORRECTED = 2 , ACPI_BERT_ERROR_NONE = 3 , ACPI_BERT_ERROR_RESERVED = 4 } ;
enum acpi_einj_actions { ACPI_EINJ_BEGIN_OPERATION = 0 , ACPI_EINJ_GET_TRIGGER_TABLE = 1 , ACPI_EINJ_SET_ERROR_TYPE = 2 , ACPI_EINJ_GET_ERROR_TYPE = 3 , ACPI_EINJ_END_OPERATION = 4 , ACPI_EINJ_EXECUTE_OPERATION = 5 , ACPI_EINJ_CHECK_BUSY_STATUS = 6 , ACPI_EINJ_GET_COMMAND_STATUS = 7 , ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS = 8 , ACPI_EINJ_ACTION_RESERVED = 9 , ACPI_EINJ_TRIGGER_ERROR = 0xFF } ;
enum acpi_einj_instructions { ACPI_EINJ_READ_REGISTER = 0 , ACPI_EINJ_READ_REGISTER_VALUE = 1 , ACPI_EINJ_WRITE_REGISTER = 2 , ACPI_EINJ_WRITE_REGISTER_VALUE = 3 , ACPI_EINJ_NOOP = 4 , ACPI_EINJ_FLUSH_CACHELINE = 5 , ACPI_EINJ_INSTRUCTION_RESERVED = 6 } ;
enum acpi_einj_command_status { ACPI_EINJ_SUCCESS = 0 , ACPI_EINJ_FAILURE = 1 , ACPI_EINJ_INVALID_ACCESS = 2 , ACPI_EINJ_STATUS_RESERVED = 3 } ;
enum acpi_erst_actions { ACPI_ERST_BEGIN_WRITE = 0 , ACPI_ERST_BEGIN_READ = 1 , ACPI_ERST_BEGIN_CLEAR = 2 , ACPI_ERST_END = 3 , ACPI_ERST_SET_RECORD_OFFSET = 4 , ACPI_ERST_EXECUTE_OPERATION = 5 , ACPI_ERST_CHECK_BUSY_STATUS = 6 , ACPI_ERST_GET_COMMAND_STATUS = 7 , ACPI_ERST_GET_RECORD_ID = 8 , ACPI_ERST_SET_RECORD_ID = 9 , ACPI_ERST_GET_RECORD_COUNT = 10 , ACPI_ERST_BEGIN_DUMMY_WRIITE = 11 , ACPI_ERST_NOT_USED = 12 , ACPI_ERST_GET_ERROR_RANGE = 13 , ACPI_ERST_GET_ERROR_LENGTH = 14 , ACPI_ERST_GET_ERROR_ATTRIBUTES = 15 , ACPI_ERST_ACTION_RESERVED = 16 } ;
enum acpi_erst_instructions { ACPI_ERST_READ_REGISTER = 0 , ACPI_ERST_READ_REGISTER_VALUE = 1 , ACPI_ERST_WRITE_REGISTER = 2 , ACPI_ERST_WRITE_REGISTER_VALUE = 3 , ACPI_ERST_NOOP = 4 , ACPI_ERST_LOAD_VAR1 = 5 , ACPI_ERST_LOAD_VAR2 = 6 , ACPI_ERST_STORE_VAR1 = 7 , ACPI_ERST_ADD = 8 , ACPI_ERST_SUBTRACT = 9 , ACPI_ERST_ADD_VALUE = 10 , ACPI_ERST_SUBTRACT_VALUE = 11 , ACPI_ERST_STALL = 12 , ACPI_ERST_STALL_WHILE_TRUE = 13 , ACPI_ERST_SKIP_NEXT_IF_TRUE = 14 , ACPI_ERST_GOTO = 15 , ACPI_ERST_SET_SRC_ADDRESS_BASE = 16 , ACPI_ERST_SET_DST_ADDRESS_BASE = 17 , ACPI_ERST_MOVE_DATA = 18 , ACPI_ERST_INSTRUCTION_RESERVED = 19 } ;
enum acpi_erst_command_status { ACPI_ERST_SUCESS = 0 , ACPI_ERST_NO_SPACE = 1 , ACPI_ERST_NOT_AVAILABLE = 2 , ACPI_ERST_FAILURE = 3 , ACPI_ERST_RECORD_EMPTY = 4 , ACPI_ERST_NOT_FOUND = 5 , ACPI_ERST_STATUS_RESERVED = 6 } ;
enum acpi_hest_types { ACPI_HEST_TYPE_IA32_CHECK = 0 , ACPI_HEST_TYPE_IA32_CORRECTED_CHECK = 1 , ACPI_HEST_TYPE_IA32_NMI = 2 , ACPI_HEST_TYPE_NOT_USED3 = 3 , ACPI_HEST_TYPE_NOT_USED4 = 4 , ACPI_HEST_TYPE_NOT_USED5 = 5 , ACPI_HEST_TYPE_AER_ROOT_PORT = 6 , ACPI_HEST_TYPE_AER_ENDPOINT = 7 , ACPI_HEST_TYPE_AER_BRIDGE = 8 , ACPI_HEST_TYPE_GENERIC_ERROR = 9 , ACPI_HEST_TYPE_RESERVED = 10 } ;
enum acpi_hest_notify_types { ACPI_HEST_NOTIFY_POLLED = 0 , ACPI_HEST_NOTIFY_EXTERNAL = 1 , ACPI_HEST_NOTIFY_LOCAL = 2 , ACPI_HEST_NOTIFY_SCI = 3 , ACPI_HEST_NOTIFY_NMI = 4 , ACPI_HEST_NOTIFY_CMCI = 5 , ACPI_HEST_NOTIFY_MCE = 6 , ACPI_HEST_NOTIFY_RESERVED = 7 } ;
enum acpi_madt_type { ACPI_MADT_TYPE_LOCAL_APIC = 0 , ACPI_MADT_TYPE_IO_APIC = 1 , ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 2 , ACPI_MADT_TYPE_NMI_SOURCE = 3 , ACPI_MADT_TYPE_LOCAL_APIC_NMI = 4 , ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 5 , ACPI_MADT_TYPE_IO_SAPIC = 6 , ACPI_MADT_TYPE_LOCAL_SAPIC = 7 , ACPI_MADT_TYPE_INTERRUPT_SOURCE = 8 , ACPI_MADT_TYPE_LOCAL_X2APIC = 9 , ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 10 , ACPI_MADT_TYPE_GENERIC_INTERRUPT = 11 , ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR = 12 , ACPI_MADT_TYPE_RESERVED = 13 } ;
enum acpi_srat_type { ACPI_SRAT_TYPE_CPU_AFFINITY = 0 , ACPI_SRAT_TYPE_MEMORY_AFFINITY = 1 , ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 2 , ACPI_SRAT_TYPE_RESERVED = 3 } ;
enum acpi_asf_type { ACPI_ASF_TYPE_INFO = 0 , ACPI_ASF_TYPE_ALERT = 1 , ACPI_ASF_TYPE_CONTROL = 2 , ACPI_ASF_TYPE_BOOT = 3 , ACPI_ASF_TYPE_ADDRESS = 4 , ACPI_ASF_TYPE_RESERVED = 5 } ;
enum acpi_dmar_type { ACPI_DMAR_TYPE_HARDWARE_UNIT = 0 , ACPI_DMAR_TYPE_RESERVED_MEMORY = 1 , ACPI_DMAR_TYPE_ATSR = 2 , ACPI_DMAR_HARDWARE_AFFINITY = 3 , ACPI_DMAR_TYPE_RESERVED = 4 } ;
enum acpi_dmar_scope_type { ACPI_DMAR_SCOPE_TYPE_NOT_USED = 0 , ACPI_DMAR_SCOPE_TYPE_ENDPOINT = 1 , ACPI_DMAR_SCOPE_TYPE_BRIDGE = 2 , ACPI_DMAR_SCOPE_TYPE_IOAPIC = 3 , ACPI_DMAR_SCOPE_TYPE_HPET = 4 , ACPI_DMAR_SCOPE_TYPE_RESERVED = 5 } ;
enum acpi_hpet_page_protect { ACPI_HPET_NO_PAGE_PROTECT = 0 , ACPI_HPET_PAGE_PROTECT4 = 1 , ACPI_HPET_PAGE_PROTECT64 = 2 } ;
enum acpi_ibft_type { ACPI_IBFT_TYPE_NOT_USED = 0 , ACPI_IBFT_TYPE_CONTROL = 1 , ACPI_IBFT_TYPE_INITIATOR = 2 , ACPI_IBFT_TYPE_NIC = 3 , ACPI_IBFT_TYPE_TARGET = 4 , ACPI_IBFT_TYPE_EXTENSIONS = 5 , ACPI_IBFT_TYPE_RESERVED = 6 } ;
enum acpi_ivrs_type { ACPI_IVRS_TYPE_HARDWARE = 0x10 , ACPI_IVRS_TYPE_MEMORY1 = 0x20 , ACPI_IVRS_TYPE_MEMORY2 = 0x21 , ACPI_IVRS_TYPE_MEMORY3 = 0x22 } ;
enum acpi_ivrs_device_entry_type { ACPI_IVRS_TYPE_PAD4 = 0 , ACPI_IVRS_TYPE_ALL = 1 , ACPI_IVRS_TYPE_SELECT = 2 , ACPI_IVRS_TYPE_START = 3 , ACPI_IVRS_TYPE_END = 4 , ACPI_IVRS_TYPE_PAD8 = 64 , ACPI_IVRS_TYPE_NOT_USED = 65 , ACPI_IVRS_TYPE_ALIAS_SELECT = 66 , ACPI_IVRS_TYPE_ALIAS_START = 67 , ACPI_IVRS_TYPE_EXT_SELECT = 70 , ACPI_IVRS_TYPE_EXT_START = 71 , ACPI_IVRS_TYPE_SPECIAL = 72 } ;
enum acpi_slic_type { ACPI_SLIC_TYPE_PUBLIC_KEY = 0 , ACPI_SLIC_TYPE_WINDOWS_MARKER = 1 , ACPI_SLIC_TYPE_RESERVED = 2 } ;
enum acpi_spmi_interface_types { ACPI_SPMI_NOT_USED = 0 , ACPI_SPMI_KEYBOARD = 1 , ACPI_SPMI_SMI = 2 , ACPI_SPMI_BLOCK_TRANSFER = 3 , ACPI_SPMI_SMBUS = 4 , ACPI_SPMI_RESERVED = 5 } ;
enum acpi_wdat_actions { ACPI_WDAT_RESET = 1 , ACPI_WDAT_GET_CURRENT_COUNTDOWN = 4 , ACPI_WDAT_GET_COUNTDOWN = 5 , ACPI_WDAT_SET_COUNTDOWN = 6 , ACPI_WDAT_GET_RUNNING_STATE = 8 , ACPI_WDAT_SET_RUNNING_STATE = 9 , ACPI_WDAT_GET_STOPPED_STATE = 10 , ACPI_WDAT_SET_STOPPED_STATE = 11 , ACPI_WDAT_GET_REBOOT = 16 , ACPI_WDAT_SET_REBOOT = 17 , ACPI_WDAT_GET_SHUTDOWN = 18 , ACPI_WDAT_SET_SHUTDOWN = 19 , ACPI_WDAT_GET_STATUS = 32 , ACPI_WDAT_SET_STATUS = 33 , ACPI_WDAT_ACTION_RESERVED = 34 } ;
enum acpi_wdat_instructions { ACPI_WDAT_READ_VALUE = 0 , ACPI_WDAT_READ_COUNTDOWN = 1 , ACPI_WDAT_WRITE_VALUE = 2 , ACPI_WDAT_WRITE_COUNTDOWN = 3 , ACPI_WDAT_INSTRUCTION_RESERVED = 4 , ACPI_WDAT_PRESERVE_REGISTER = 0x80 } ;
enum acpi_fpdt_type { ACPI_FPDT_TYPE_BOOT = 0 , ACPI_FPDT_TYPE_S3PERF = 1 , } ;
enum acpi_s3pt_type { ACPI_S3PT_TYPE_RESUME = 0 , ACPI_S3PT_TYPE_SUSPEND = 1 , } ;
enum acpi_rasf_commands { ACPI_RASF_GET_RAS_CAPABILITIES = 1 , ACPI_RASF_GET_PATROL_PARAMETERS = 2 , ACPI_RASF_START_PATROL_SCRUBBER = 3 , ACPI_RASF_STOP_PATROL_SCRUBBER = 4 } ;
enum acpi_rasf_status { ACPI_RASF_SUCCESS = 0 , ACPI_RASF_NOT_VALID = 1 , ACPI_RASF_NOT_SUPPORTED = 2 , ACPI_RASF_BUSY = 3 , ACPI_RASF_FAILED = 4 , ACPI_RASF_ABORTED = 5 , ACPI_RASF_INVALID_DATA = 6 } ;
enum acpi_bus_removal_type { ACPI_BUS_REMOVAL_NORMAL = 0 , ACPI_BUS_REMOVAL_EJECT , ACPI_BUS_REMOVAL_SUPRISE , ACPI_BUS_REMOVAL_TYPE_COUNT } ;
enum acpi_bus_device_type { ACPI_BUS_TYPE_DEVICE = 0 , ACPI_BUS_TYPE_POWER , ACPI_BUS_TYPE_PROCESSOR , ACPI_BUS_TYPE_THERMAL , ACPI_BUS_TYPE_POWER_BUTTON , ACPI_BUS_TYPE_SLEEP_BUTTON , ACPI_BUS_DEVICE_TYPE_COUNT } ;
enum acpi_irq_model_id { ACPI_IRQ_MODEL_PIC = 0 , ACPI_IRQ_MODEL_IOAPIC , ACPI_IRQ_MODEL_IOSAPIC , ACPI_IRQ_MODEL_PLATFORM , ACPI_IRQ_MODEL_COUNT } ;
enum acpi_interrupt_id { ACPI_INTERRUPT_PMI = 1 , ACPI_INTERRUPT_INIT , ACPI_INTERRUPT_CPEI , ACPI_INTERRUPT_COUNT } ;
enum acpi_address_range_id { ACPI_ADDRESS_RANGE_MEMORY = 1 , ACPI_ADDRESS_RANGE_RESERVED = 2 , ACPI_ADDRESS_RANGE_ACPI = 3 , ACPI_ADDRESS_RANGE_NVS = 4 , ACPI_ADDRESS_RANGE_COUNT } ;
enum { ATA_MSG_DRV = 0x0001 , ATA_MSG_INFO = 0x0002 , ATA_MSG_PROBE = 0x0004 , ATA_MSG_WARN = 0x0008 , ATA_MSG_MALLOC = 0x0010 , ATA_MSG_CTL = 0x0020 , ATA_MSG_INTR = 0x0040 , ATA_MSG_ERR = 0x0080 , } ;
enum hsm_task_states { HSM_ST_IDLE , HSM_ST_FIRST , HSM_ST , HSM_ST_LAST , HSM_ST_ERR , } ;
enum ata_completion_errors { AC_ERR_DEV = ( 1 << 0 ) , AC_ERR_HSM = ( 1 << 1 ) , AC_ERR_TIMEOUT = ( 1 << 2 ) , AC_ERR_MEDIA = ( 1 << 3 ) , AC_ERR_ATA_BUS = ( 1 << 4 ) , AC_ERR_HOST_BUS = ( 1 << 5 ) , AC_ERR_SYSTEM = ( 1 << 6 ) , AC_ERR_INVALID = ( 1 << 7 ) , AC_ERR_OTHER = ( 1 << 8 ) , AC_ERR_NODEV_HINT = ( 1 << 9 ) , AC_ERR_NCQ = ( 1 << 10 ) , } ;
enum ata_lpm_policy { ATA_LPM_UNKNOWN , ATA_LPM_MAX_POWER , ATA_LPM_MED_POWER , ATA_LPM_MIN_POWER , } ;
enum ata_lpm_hints { ATA_LPM_EMPTY = ( 1 << 0 ) , ATA_LPM_HIPM = ( 1 << 1 ) , } ;
struct scsi_device ;
enum sw_activity { OFF , BLINK_ON , BLINK_OFF , } ;
struct platform_device ;
enum ata_link_iter_mode { ATA_LITER_EDGE , ATA_LITER_HOST_FIRST , ATA_LITER_PMP_FIRST , } ;
enum ata_dev_iter_mode { ATA_DITER_ENABLED , ATA_DITER_ENABLED_REVERSE , ATA_DITER_ALL , ATA_DITER_ALL_REVERSE , } ;
enum phy_state { PHY_DOWN = 0 , PHY_STARTING , PHY_READY , PHY_PENDING , PHY_UP , PHY_AN , PHY_RUNNING , PHY_NOLINK , PHY_FORCING , PHY_CHANGELINK , PHY_HALTED , PHY_RESUMING } ;
struct list_head { struct list_head * next , * prev ; } ;
struct hlist_head { struct hlist_node * first ; } ;
struct hlist_node { struct hlist_node * next , * * pprev ; } ;
typedef struct gate_struct64 gate_desc ;
typedef struct ldttss_desc64 ldt_desc ;
typedef struct ldttss_desc64 tss_desc ;
typedef struct page * pgtable_t ;
typedef struct __wait_queue wait_queue_t ;
typedef struct __wait_queue_head wait_queue_head_t ;
typedef enum { ZONE_RECLAIM_LOCKED , ZONE_OOM_LOCKED , ZONE_CONGESTED , } zone_flags_t ;
typedef union ktime ktime_t ;
struct rcu_batch { struct callback_head * head , * * tail ; } ;
struct raw_notifier_head { struct notifier_block * head ; } ;
typedef struct physid_mask physid_mask_t ;
typedef struct trap_info * __guest_handle_trap_info ;
typedef struct cpu_user_regs * __guest_handle_cpu_user_regs ;
typedef struct vcpu_guest_context * __guest_handle_vcpu_guest_context ;
typedef struct mmuext_op * __guest_handle_mmuext_op ;
typedef struct mmu_update * __guest_handle_mmu_update ;
typedef struct multicall_entry * __guest_handle_multicall_entry ;
extern struct clocksource * clocksource_default_clock ( void ) ;
struct rb_root { struct rb_node * rb_node ; } ;

typedef struct user_i387_struct elf_fpregset_t ;
struct tracepoint_iter { struct tp_module * module ; struct tracepoint * const * tracepoint ; } ;
struct hlist_bl_head { struct hlist_bl_node * first ; } ;
struct hlist_bl_node { struct hlist_bl_node * next , * * pprev ; } ;
struct path ;
struct path { struct vfsmount * mnt ; struct dentry * dentry ; } ;
struct path ;
typedef struct files_struct * fl_owner_t ;
struct nfs4_lock_info { struct nfs4_lock_state * owner ; } ;
struct klist_iter { struct klist * i_klist ; struct klist_node * i_cur ; } ;
struct tick_device { struct clock_event_device * evtdev ; enum tick_device_mode mode ; } ;
typedef enum irqreturn irqreturn_t ;
struct core_thread { struct task_struct * task ; struct core_thread * next ; } ;
struct sysv_sem { struct sem_undo_list * undo_list ; } ;
typedef struct __key_reference_with_attributes * key_ref_t ;
struct llist_head { struct llist_node * first ; } ;
struct llist_node { struct llist_node * next ; } ;
struct bio_list ;
enum sum_check_flags { SUM_CHECK_P_RESULT = ( 1 << SUM_CHECK_P ) , SUM_CHECK_Q_RESULT = ( 1 << SUM_CHECK_Q ) , } ;
typedef struct user_regs_struct32 compat_elf_gregset_t ;
typedef enum { SS_FREE = 0 , SS_UNCONNECTED , SS_CONNECTING , SS_CONNECTED , SS_DISCONNECTING } socket_state ;
typedef struct skb_frag_struct skb_frag_t ;
struct hlist_head ;
struct netns_dccp { struct sock * v4_ctl_sk ; struct sock * v6_ctl_sk ; } ;
struct flow_cache_object { const struct flow_cache_ops * ops ; } ;
struct hlist_nulls_head { struct hlist_nulls_node * first ; } ;
struct hlist_nulls_node { struct hlist_nulls_node * next , * * pprev ; } ;
struct path ;
struct seq_net_private { struct net * net ; } ;
struct cgroup_iter { struct list_head * cg_link ; struct list_head * task ; } ;
struct path ;
typedef enum netdev_tx netdev_tx_t ;
typedef enum gro_result gro_result_t ;
typedef enum rx_handler_result rx_handler_result_t ;
struct bio_list { struct bio * head ; struct bio * tail ; } ;
typedef struct transaction_s transaction_t ;
typedef struct jbd2_journal_handle handle_t ;
typedef struct journal_s journal_t ;
typedef enum { OSL_GLOBAL_LOCK_HANDLER , OSL_NOTIFY_HANDLER , OSL_GPE_HANDLER , OSL_DEBUGGER_THREAD , OSL_EC_POLL_HANDLER , OSL_EC_BURST_HANDLER } acpi_execute_type ;
struct acpi_device_dir { struct proc_dir_entry * entry ; } ;
typedef enum { mechtype_caddy = 0 , mechtype_tray = 1 , mechtype_popup = 2 , mechtype_individual_changer = 4 , mechtype_cartridge_changer = 5 } mechtype_t ;
enum { LIBATA_MAX_PRD = ATA_MAX_PRD / 2 , LIBATA_DUMB_MAX_PRD = ATA_MAX_PRD / 4 , ATA_DEF_QUEUE = 1 , ATA_MAX_QUEUE = 32 , ATA_TAG_INTERNAL = ATA_MAX_QUEUE - 1 , ATA_SHORT_PAUSE = 16 , ATAPI_MAX_DRAIN = 16 << 10 , ATA_ALL_DEVICES = ( 1 << ATA_MAX_DEVICES ) - 1 , ATA_SHT_EMULATED = 1 , ATA_SHT_CMD_PER_LUN = 1 , ATA_SHT_THIS_ID = - 1 , ATA_SHT_USE_CLUSTERING = 1 , ATA_DFLAG_LBA = ( 1 << 0 ) , ATA_DFLAG_LBA48 = ( 1 << 1 ) , ATA_DFLAG_CDB_INTR = ( 1 << 2 ) , ATA_DFLAG_NCQ = ( 1 << 3 ) , ATA_DFLAG_FLUSH_EXT = ( 1 << 4 ) , ATA_DFLAG_ACPI_PENDING = ( 1 << 5 ) , ATA_DFLAG_ACPI_FAILED = ( 1 << 6 ) , ATA_DFLAG_AN = ( 1 << 7 ) , ATA_DFLAG_DMADIR = ( 1 << 10 ) , ATA_DFLAG_CFG_MASK = ( 1 << 12 ) - 1 , ATA_DFLAG_PIO = ( 1 << 12 ) , ATA_DFLAG_NCQ_OFF = ( 1 << 13 ) , ATA_DFLAG_SLEEPING = ( 1 << 15 ) , ATA_DFLAG_DUBIOUS_XFER = ( 1 << 16 ) , ATA_DFLAG_NO_UNLOAD = ( 1 << 17 ) , ATA_DFLAG_UNLOCK_HPA = ( 1 << 18 ) , ATA_DFLAG_INIT_MASK = ( 1 << 24 ) - 1 , ATA_DFLAG_DETACH = ( 1 << 24 ) , ATA_DFLAG_DETACHED = ( 1 << 25 ) , ATA_DFLAG_DA = ( 1 << 26 ) , ATA_DFLAG_DEVSLP = ( 1 << 27 ) , ATA_DFLAG_ACPI_DISABLED = ( 1 << 28 ) , ATA_DEV_UNKNOWN = 0 , ATA_DEV_ATA = 1 , ATA_DEV_ATA_UNSUP = 2 , ATA_DEV_ATAPI = 3 , ATA_DEV_ATAPI_UNSUP = 4 , ATA_DEV_PMP = 5 , ATA_DEV_PMP_UNSUP = 6 , ATA_DEV_SEMB = 7 , ATA_DEV_SEMB_UNSUP = 8 , ATA_DEV_NONE = 9 , ATA_LFLAG_NO_HRST = ( 1 << 1 ) , ATA_LFLAG_NO_SRST = ( 1 << 2 ) , ATA_LFLAG_ASSUME_ATA = ( 1 << 3 ) , ATA_LFLAG_ASSUME_SEMB = ( 1 << 4 ) , ATA_LFLAG_ASSUME_CLASS = ATA_LFLAG_ASSUME_ATA | ATA_LFLAG_ASSUME_SEMB , ATA_LFLAG_NO_RETRY = ( 1 << 5 ) , ATA_LFLAG_DISABLED = ( 1 << 6 ) , ATA_LFLAG_SW_ACTIVITY = ( 1 << 7 ) , ATA_LFLAG_NO_LPM = ( 1 << 8 ) , ATA_LFLAG_RST_ONCE = ( 1 << 9 ) , ATA_FLAG_SLAVE_POSS = ( 1 << 0 ) , ATA_FLAG_SATA = ( 1 << 1 ) , ATA_FLAG_NO_ATAPI = ( 1 << 6 ) , ATA_FLAG_PIO_DMA = ( 1 << 7 ) , ATA_FLAG_PIO_LBA48 = ( 1 << 8 ) , ATA_FLAG_PIO_POLLING = ( 1 << 9 ) , ATA_FLAG_NCQ = ( 1 << 10 ) , ATA_FLAG_NO_POWEROFF_SPINDOWN = ( 1 << 11 ) , ATA_FLAG_NO_HIBERNATE_SPINDOWN = ( 1 << 12 ) , ATA_FLAG_DEBUGMSG = ( 1 << 13 ) , ATA_FLAG_FPDMA_AA = ( 1 << 14 ) , ATA_FLAG_IGN_SIMPLEX = ( 1 << 15 ) , ATA_FLAG_NO_IORDY = ( 1 << 16 ) , ATA_FLAG_ACPI_SATA = ( 1 << 17 ) , ATA_FLAG_AN = ( 1 << 18 ) , ATA_FLAG_PMP = ( 1 << 19 ) , ATA_FLAG_EM = ( 1 << 21 ) , ATA_FLAG_SW_ACTIVITY = ( 1 << 22 ) , ATA_FLAG_NO_DIPM = ( 1 << 23 ) , ATA_PFLAG_EH_PENDING = ( 1 << 0 ) , ATA_PFLAG_EH_IN_PROGRESS = ( 1 << 1 ) , ATA_PFLAG_FROZEN = ( 1 << 2 ) , ATA_PFLAG_RECOVERED = ( 1 << 3 ) , ATA_PFLAG_LOADING = ( 1 << 4 ) , ATA_PFLAG_SCSI_HOTPLUG = ( 1 << 6 ) , ATA_PFLAG_INITIALIZING = ( 1 << 7 ) , ATA_PFLAG_RESETTING = ( 1 << 8 ) , ATA_PFLAG_UNLOADING = ( 1 << 9 ) , ATA_PFLAG_UNLOADED = ( 1 << 10 ) , ATA_PFLAG_SUSPENDED = ( 1 << 17 ) , ATA_PFLAG_PM_PENDING = ( 1 << 18 ) , ATA_PFLAG_INIT_GTM_VALID = ( 1 << 19 ) , ATA_PFLAG_PIO32 = ( 1 << 20 ) , ATA_PFLAG_PIO32CHANGE = ( 1 << 21 ) , ATA_QCFLAG_ACTIVE = ( 1 << 0 ) , ATA_QCFLAG_DMAMAP = ( 1 << 1 ) , ATA_QCFLAG_IO = ( 1 << 3 ) , ATA_QCFLAG_RESULT_TF = ( 1 << 4 ) , ATA_QCFLAG_CLEAR_EXCL = ( 1 << 5 ) , ATA_QCFLAG_QUIET = ( 1 << 6 ) , ATA_QCFLAG_RETRY = ( 1 << 7 ) , ATA_QCFLAG_FAILED = ( 1 << 16 ) , ATA_QCFLAG_SENSE_VALID = ( 1 << 17 ) , ATA_QCFLAG_EH_SCHEDULED = ( 1 << 18 ) , ATA_HOST_SIMPLEX = ( 1 << 0 ) , ATA_HOST_STARTED = ( 1 << 1 ) , ATA_HOST_PARALLEL_SCAN = ( 1 << 2 ) , ATA_HOST_IGNORE_ATA = ( 1 << 3 ) , ATA_TMOUT_BOOT = 30000 , ATA_TMOUT_BOOT_QUICK = 7000 , ATA_TMOUT_INTERNAL_QUICK = 5000 , ATA_TMOUT_MAX_PARK = 30000 , ATA_TMOUT_FF_WAIT_LONG = 2000 , ATA_TMOUT_FF_WAIT = 800 , ATA_WAIT_AFTER_RESET = 150 , ATA_TMOUT_PMP_SRST_WAIT = 5000 , BUS_UNKNOWN = 0 , BUS_DMA = 1 , BUS_IDLE = 2 , BUS_NOINTR = 3 , BUS_NODATA = 4 , BUS_TIMER = 5 , BUS_PIO = 6 , BUS_EDD = 7 , BUS_IDENTIFY = 8 , BUS_PACKET = 9 , PORT_UNKNOWN = 0 , PORT_ENABLED = 1 , PORT_DISABLED = 2 , ATA_NR_PIO_MODES = 7 , ATA_NR_MWDMA_MODES = 5 , ATA_NR_UDMA_MODES = 8 , ATA_SHIFT_PIO = 0 , ATA_SHIFT_MWDMA = ATA_SHIFT_PIO + ATA_NR_PIO_MODES , ATA_SHIFT_UDMA = ATA_SHIFT_MWDMA + ATA_NR_MWDMA_MODES , ATA_DMA_PAD_SZ = 4 , ATA_ERING_SIZE = 32 , ATA_DEFER_LINK = 1 , ATA_DEFER_PORT = 2 , ATA_EH_DESC_LEN = 80 , ATA_EH_REVALIDATE = ( 1 << 0 ) , ATA_EH_SOFTRESET = ( 1 << 1 ) , ATA_EH_HARDRESET = ( 1 << 2 ) , ATA_EH_RESET = ATA_EH_SOFTRESET | ATA_EH_HARDRESET , ATA_EH_ENABLE_LINK = ( 1 << 3 ) , ATA_EH_PARK = ( 1 << 5 ) , ATA_EH_PERDEV_MASK = ATA_EH_REVALIDATE | ATA_EH_PARK , ATA_EH_ALL_ACTIONS = ATA_EH_REVALIDATE | ATA_EH_RESET | ATA_EH_ENABLE_LINK , ATA_EHI_HOTPLUGGED = ( 1 << 0 ) , ATA_EHI_NO_AUTOPSY = ( 1 << 2 ) , ATA_EHI_QUIET = ( 1 << 3 ) , ATA_EHI_NO_RECOVERY = ( 1 << 4 ) , ATA_EHI_DID_SOFTRESET = ( 1 << 16 ) , ATA_EHI_DID_HARDRESET = ( 1 << 17 ) , ATA_EHI_PRINTINFO = ( 1 << 18 ) , ATA_EHI_SETMODE = ( 1 << 19 ) , ATA_EHI_POST_SETMODE = ( 1 << 20 ) , ATA_EHI_DID_RESET = ATA_EHI_DID_SOFTRESET | ATA_EHI_DID_HARDRESET , ATA_EHI_TO_SLAVE_MASK = ATA_EHI_NO_AUTOPSY | ATA_EHI_QUIET , ATA_EH_MAX_TRIES = 5 , ATA_LINK_RESUME_TRIES = 5 , ATA_PROBE_MAX_TRIES = 3 , ATA_EH_DEV_TRIES = 3 , ATA_EH_PMP_TRIES = 5 , ATA_EH_PMP_LINK_TRIES = 3 , SATA_PMP_RW_TIMEOUT = 3000 , ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 6 , ATA_HORKAGE_DIAGNOSTIC = ( 1 << 0 ) , ATA_HORKAGE_NODMA = ( 1 << 1 ) , ATA_HORKAGE_NONCQ = ( 1 << 2 ) , ATA_HORKAGE_MAX_SEC_128 = ( 1 << 3 ) , ATA_HORKAGE_BROKEN_HPA = ( 1 << 4 ) , ATA_HORKAGE_DISABLE = ( 1 << 5 ) , ATA_HORKAGE_HPA_SIZE = ( 1 << 6 ) , ATA_HORKAGE_IVB = ( 1 << 8 ) , ATA_HORKAGE_STUCK_ERR = ( 1 << 9 ) , ATA_HORKAGE_BRIDGE_OK = ( 1 << 10 ) , ATA_HORKAGE_ATAPI_MOD16_DMA = ( 1 << 11 ) , ATA_HORKAGE_FIRMWARE_WARN = ( 1 << 12 ) , ATA_HORKAGE_1_5_GBPS = ( 1 << 13 ) , ATA_HORKAGE_NOSETXFER = ( 1 << 14 ) , ATA_HORKAGE_BROKEN_FPDMA_AA = ( 1 << 15 ) , ATA_HORKAGE_DUMP_ID = ( 1 << 16 ) , ATA_DMA_MASK_ATA = ( 1 << 0 ) , ATA_DMA_MASK_ATAPI = ( 1 << 1 ) , ATA_DMA_MASK_CFA = ( 1 << 2 ) , ATAPI_READ = 0 , ATAPI_WRITE = 1 , ATAPI_READ_CD = 2 , ATAPI_PASS_THRU = 3 , ATAPI_MISC = 4 , ATA_TIMING_SETUP = ( 1 << 0 ) , ATA_TIMING_ACT8B = ( 1 << 1 ) , ATA_TIMING_REC8B = ( 1 << 2 ) , ATA_TIMING_CYC8B = ( 1 << 3 ) , ATA_TIMING_8BIT = ATA_TIMING_ACT8B | ATA_TIMING_REC8B | ATA_TIMING_CYC8B , ATA_TIMING_ACTIVE = ( 1 << 4 ) , ATA_TIMING_RECOVER = ( 1 << 5 ) , ATA_TIMING_DMACK_HOLD = ( 1 << 6 ) , ATA_TIMING_CYCLE = ( 1 << 7 ) , ATA_TIMING_UDMA = ( 1 << 8 ) , ATA_TIMING_ALL = ATA_TIMING_SETUP | ATA_TIMING_ACT8B | ATA_TIMING_REC8B | ATA_TIMING_CYC8B | ATA_TIMING_ACTIVE | ATA_TIMING_RECOVER | ATA_TIMING_DMACK_HOLD | ATA_TIMING_CYCLE | ATA_TIMING_UDMA , ATA_ACPI_FILTER_SETXFER = 1 << 0 , ATA_ACPI_FILTER_LOCK = 1 << 1 , ATA_ACPI_FILTER_DIPM = 1 << 2 , ATA_ACPI_FILTER_FPDMA_OFFSET = 1 << 3 , ATA_ACPI_FILTER_FPDMA_AA = 1 << 4 , ATA_ACPI_FILTER_DEFAULT = ATA_ACPI_FILTER_SETXFER | ATA_ACPI_FILTER_LOCK | ATA_ACPI_FILTER_DIPM , } ;
typedef enum { PHY_INTERFACE_MODE_NA , PHY_INTERFACE_MODE_MII , PHY_INTERFACE_MODE_GMII , PHY_INTERFACE_MODE_SGMII , PHY_INTERFACE_MODE_TBI , PHY_INTERFACE_MODE_RMII , PHY_INTERFACE_MODE_RGMII , PHY_INTERFACE_MODE_RGMII_ID , PHY_INTERFACE_MODE_RGMII_RXID , PHY_INTERFACE_MODE_RGMII_TXID , PHY_INTERFACE_MODE_RTBI , PHY_INTERFACE_MODE_SMII , } phy_interface_t ;
typedef __builtin_va_list __gnuc_va_list ;
typedef __signed__ char __s8 ;
typedef unsigned char __u8 ;
typedef __signed__ short __s16 ;
typedef unsigned short __u16 ;
typedef __signed__ int __s32 ;
typedef unsigned int __u32 ;
__extension__ typedef __signed__ long long __s64 ;
__extension__ typedef unsigned long long __u64 ;
typedef signed char s8 ;
typedef unsigned char u8 ;
typedef signed short s16 ;
typedef unsigned short u16 ;
typedef signed int s32 ;
typedef unsigned int u32 ;
typedef signed long long s64 ;
typedef unsigned long long u64 ;
typedef int __kernel_key_t ;
typedef int __kernel_mqd_t ;
typedef unsigned long __kernel_ino_t ;
typedef unsigned int __kernel_mode_t ;
typedef unsigned long __kernel_nlink_t ;
typedef long __kernel_off_t ;
typedef int __kernel_pid_t ;
typedef int __kernel_ipc_pid_t ;
typedef unsigned int __kernel_uid_t ;
typedef unsigned int __kernel_gid_t ;
typedef unsigned long __kernel_size_t ;
typedef long __kernel_ssize_t ;
typedef long __kernel_ptrdiff_t ;
typedef long __kernel_time_t ;
typedef long __kernel_suseconds_t ;
typedef long __kernel_clock_t ;
typedef int __kernel_timer_t ;
typedef int __kernel_clockid_t ;
typedef int __kernel_daddr_t ;
typedef char * __kernel_caddr_t ;
typedef unsigned short __kernel_uid16_t ;
typedef unsigned short __kernel_gid16_t ;
typedef long long __kernel_loff_t ;
typedef unsigned short __kernel_old_uid_t ;
typedef unsigned short __kernel_old_gid_t ;
typedef unsigned long __kernel_old_dev_t ;
typedef unsigned short umode_t ;
typedef unsigned long uintptr_t ;
typedef unsigned char u_char ;
typedef unsigned short u_short ;
typedef unsigned int u_int ;
typedef unsigned long u_long ;
typedef unsigned char unchar ;
typedef unsigned short ushort ;
typedef unsigned int uint ;
typedef unsigned long ulong ;
typedef unsigned long sector_t ;
typedef unsigned long blkcnt_t ;
typedef unsigned gfp_t ;
typedef unsigned fmode_t ;
typedef unsigned oom_flags_t ;
typedef unsigned long irq_hw_number_t ;
struct _ddebug { const char * modname ; const char * function ; const char * filename ; const char * format ; unsigned int lineno : 18 ; unsigned int flags : 8 ; } __attribute__ ( ( aligned ( 8 ) ) ) ;
struct pt_regs ;
struct stat { unsigned long st_dev ; unsigned long st_ino ; unsigned long st_nlink ; unsigned int st_mode ; unsigned int st_uid ; unsigned int st_gid ; unsigned int __pad0 ; unsigned long st_rdev ; long st_size ; long st_blksize ; long st_blocks ; unsigned long st_atime ; unsigned long st_atime_nsec ; unsigned long st_mtime ; unsigned long st_mtime_nsec ; unsigned long st_ctime ; unsigned long st_ctime_nsec ; long __unused [ 3 ] ; } ;
struct __old_kernel_stat { unsigned short st_dev ; unsigned short st_ino ; unsigned short st_mode ; unsigned short st_nlink ; unsigned short st_uid ; unsigned short st_gid ; unsigned short st_rdev ; unsigned int st_size ; unsigned int st_atime ; unsigned int st_mtime ; unsigned int st_ctime ; } ;
struct bug_entry { signed int bug_addr_disp ; signed int file_disp ; unsigned short line ; unsigned short flags ; } ;
struct pt_regs ;
struct pt_regs { unsigned long r15 ; unsigned long r14 ; unsigned long r13 ; unsigned long r12 ; unsigned long bp ; unsigned long bx ; unsigned long r11 ; unsigned long r10 ; unsigned long r9 ; unsigned long r8 ; unsigned long ax ; unsigned long cx ; unsigned long dx ; unsigned long si ; unsigned long di ; unsigned long orig_ax ; unsigned long ip ; unsigned long cs ; unsigned long flags ; unsigned long sp ; unsigned long ss ; } ;
struct desc_ptr { unsigned short size ; unsigned long address ; } __attribute__ ( ( packed ) ) ;
typedef unsigned long pteval_t ;
typedef unsigned long pmdval_t ;
typedef unsigned long pudval_t ;
typedef unsigned long pgdval_t ;
typedef unsigned long pgprotval_t ;
struct desc_ptr ;
struct cpumask ;
struct paravirt_callee_save { void * func ; } ;
struct vm86_regs { long ebx ; long ecx ; long edx ; long esi ; long edi ; long ebp ; long eax ; long __null_ds ; long __null_es ; long __null_fs ; long __null_gs ; long orig_eax ; long eip ; unsigned short cs , __csh ; long eflags ; long esp ; unsigned short ss , __ssh ; unsigned short es , __esh ; unsigned short ds , __dsh ; unsigned short fs , __fsh ; unsigned short gs , __gsh ; } ;
struct revectored_struct { unsigned long __map [ 8 ] ; } ;
struct vm86plus_info_struct { unsigned long force_return_for_pic : 1 ; unsigned long vm86dbg_active : 1 ; unsigned long vm86dbg_TFpendig : 1 ; unsigned long unused : 28 ; unsigned long is_vm86pus : 1 ; unsigned char vm86dbg_intxxtab [ 32 ] ; } ;
struct math_emu_info { long ___orig_eip ; union { struct pt_regs * regs ; struct kernel_vm86_regs * vm86 ; } ; } ;
struct sigcontext { unsigned long r8 ; unsigned long r9 ; unsigned long r10 ; unsigned long r11 ; unsigned long r12 ; unsigned long r13 ; unsigned long r14 ; unsigned long r15 ; unsigned long di ; unsigned long si ; unsigned long bp ; unsigned long bx ; unsigned long dx ; unsigned long ax ; unsigned long cx ; unsigned long sp ; unsigned long ip ; unsigned long flags ; unsigned short cs ; unsigned short gs ; unsigned short fs ; unsigned short __pad0 ; unsigned long err ; unsigned long trapno ; unsigned long oldmask ; unsigned long cr2 ; void * fpstate ; unsigned long reserved1 [ 8 ] ; } ;
struct pt_regs ;
struct orig_ist { unsigned long ist [ 7 ] ; } ;
struct fpu { unsigned int last_cpu ; unsigned int has_fpu ; union thread_xstate * state ; } ;
struct preempt_notifier ;
struct preempt_notifier { struct hlist_node link ; struct preempt_ops * ops ; } ;
struct timezone { int tz_minuteswest ; int tz_dsttime ; } ;
struct tm { int tm_sec ; int tm_min ; int tm_hour ; int tm_mday ; int tm_mon ; long tm_year ; int tm_wday ; int tm_yday ; } ;
struct wait_bit_key { void * flags ; int bit_nr ; } ;
struct free_area { struct list_head free_list [ MIGRATE_TYPES ] ; unsigned long nr_free ; } ;
struct zone_padding { char x [ 0 ] ; } __attribute__ ( ( __aligned__ ( 1 << ( 6 ) ) ) ) ;
struct zone_reclaim_stat { unsigned long recent_rotated [ 2 ] ; unsigned long recent_scanned [ 2 ] ; } ;
typedef unsigned isolate_mode_t ;
struct per_cpu_pages { int count ; int high ; int batch ; struct list_head lists [ MIGRATE_PCPTYPES ] ; } ;
struct zonelist_cache { unsigned short z_to_n [ ( ( 1 << 6 ) * 4 ) ] ; unsigned long fullzones [ ( ( ( ( ( 1 << 6 ) * 4 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long last_full_zap ; } ;
struct zoneref { struct zone * zone ; int zone_idx ; } ;
struct node_active_region { unsigned long start_pfn ; unsigned long end_pfn ; int nid ; } ;
struct mutex_waiter { struct list_head list ; struct task_struct * task ; } ;
struct debug_obj { struct hlist_node node ; enum debug_obj_state state ; unsigned int astate ; void * object ; struct debug_obj_descr * descr ; } ;
typedef unsigned long long cycles_t ;
struct srcu_struct_array { unsigned long c [ 2 ] ; unsigned long seq [ 2 ] ; } ;
struct mem_section ;
struct mpf_intel { char signature [ 4 ] ; unsigned int physptr ; unsigned char length ; unsigned char specification ; unsigned char checksum ; unsigned char feature1 ; unsigned char feature2 ; unsigned char feature3 ; unsigned char feature4 ; unsigned char feature5 ; } ;
struct mpc_table { char signature [ 4 ] ; unsigned short length ; char spec ; char checksum ; char oem [ 8 ] ; char productid [ 12 ] ; unsigned int oemptr ; unsigned short oemsize ; unsigned short oemcount ; unsigned int lapic ; unsigned int reserved ; } ;
struct mpc_cpu { unsigned char type ; unsigned char apicid ; unsigned char apicver ; unsigned char cpuflag ; unsigned int cpufeature ; unsigned int featureflag ; unsigned int reserved [ 2 ] ; } ;
struct mpc_bus { unsigned char type ; unsigned char busid ; unsigned char bustype [ 6 ] ; } ;
struct mpc_ioapic { unsigned char type ; unsigned char apicid ; unsigned char apicver ; unsigned char flags ; unsigned int apicaddr ; } ;
struct mpc_intsrc { unsigned char type ; unsigned char irqtype ; unsigned short irqflag ; unsigned char srcbus ; unsigned char srcbusirq ; unsigned char dstapic ; unsigned char dstirq ; } ;
struct mpc_lintsrc { unsigned char type ; unsigned char irqtype ; unsigned short irqflag ; unsigned char srcbusid ; unsigned char srcbusirq ; unsigned char destapic ; unsigned char destapiclint ; } ;
struct mpc_oemtable { char signature [ 4 ] ; unsigned short length ; char rev ; char checksum ; char mpc [ 8 ] ; } ;
typedef unsigned short apm_event_t ;
typedef unsigned short apm_eventinfo_t ;
struct edid_info { unsigned char dummy [ 128 ] ; } ;
struct mpc_bus ;
struct mpc_cpu ;
struct mpc_table ;
struct physid_mask { unsigned long mask [ ( ( ( 32768 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;
struct pm_domain_data { struct list_head list_node ; struct device * dev ; } ;
typedef unsigned long xen_pfn_t ;
typedef unsigned long xen_ulong_t ;
typedef unsigned char * __guest_handle_uchar ;
typedef unsigned int * __guest_handle_uint ;
typedef char * __guest_handle_char ;
typedef int * __guest_handle_int ;
typedef void * __guest_handle_void ;
struct arch_shared_info { unsigned long max_pfn ; unsigned long pfn_to_mfn_frame_list_list ; unsigned long nmi_reason ; } ;
struct arch_vcpu_info { unsigned long cr2 ; unsigned long pad ; } ;
typedef unsigned long xen_callback_t ;
struct multicall_entry { unsigned long op ; long result ; unsigned long args [ 6 ] ; } ;
struct bio_vec ;
struct arch_clocksource_data { int vclock_mode ; } ;
struct io_apic_irq_attr ;
struct mem_section { unsigned long section_mem_map ; unsigned long * pageblock_flags ; } ;
struct pcpu_group_info { int nr_units ; unsigned long base_offset ; unsigned int * cpu_map ; } ;
extern struct pcpu_alloc_info * pcpu_alloc_alloc_info ( int nr_groups , int nr_units ) ;
struct rb_node { unsigned long __rb_parent_color ; struct rb_node * rb_right ; struct rb_node * rb_left ; } __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ;
struct ctl_path { const char * procname ; } ;
struct user_regs_struct { unsigned long r15 ; unsigned long r14 ; unsigned long r13 ; unsigned long r12 ; unsigned long bp ; unsigned long bx ; unsigned long r11 ; unsigned long r10 ; unsigned long r9 ; unsigned long r8 ; unsigned long ax ; unsigned long cx ; unsigned long dx ; unsigned long si ; unsigned long di ; unsigned long orig_ax ; unsigned long ip ; unsigned long cs ; unsigned long flags ; unsigned long sp ; unsigned long ss ; unsigned long fs_base ; unsigned long gs_base ; unsigned long ds ; unsigned long es ; unsigned long fs ; unsigned long gs ; } ;
typedef unsigned long elf_greg_t ;
struct va_alignment { int flags ; unsigned long mask ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct kobj_uevent_env { char * envp [ 32 ] ; int envp_idx ; char buf [ 2048 ] ; int buflen ; } ;
struct kparam_string { unsigned int maxlen ; char * string ; } ;
struct kparam_array { unsigned int max ; unsigned int elemsize ; unsigned int * num ; const struct kernel_param_ops * ops ; void * elem ; } ;
struct tracepoint_func { void * func ; void * data ; } ;
struct tp_module { struct list_head list ; unsigned int num_tracepoints ; struct tracepoint * const * tracepoints_ptrs ; } ;
struct kernel_symbol { unsigned long value ; const char * name ; } ;
struct modversion_info { unsigned long crc ; char name [ ( 64 - sizeof ( unsigned long ) ) ] ; } ;
struct exception_table_entry ;
struct module_use { struct list_head source_list ; struct list_head target_list ; struct module * source , * target ; } ;
struct module_ref { unsigned long incs ; unsigned long decs ; } __attribute ( ( aligned ( 2 * sizeof ( unsigned long ) ) ) ) ;
struct timerqueue_head { struct rb_root head ; struct timerqueue_node * next ; } ;
struct vfsmount ;
struct dentry_stat_t { int nr_dentry ; int nr_unused ; int age_limit ; int want_pages ; int dummy [ 2 ] ; } ;
struct vfsmount ;
struct radix_tree_iter { unsigned long index ; unsigned long next_index ; unsigned long tags ; } ;
struct upid { int nr ; struct pid_namespace * ns ; struct hlist_node pid_chain ; } ;
struct pid_link { struct hlist_node node ; struct pid * pid ; } ;
struct bio_vec { struct page * bv_page ; unsigned int bv_len ; unsigned int bv_offset ; } ;
struct files_stat_struct { unsigned long nr_files ; unsigned long nr_free_files ; unsigned long max_files ; } ;
struct inodes_stat_t { int nr_inodes ; int nr_unused ; int dummy [ 5 ] ; } ;
struct vfsmount ;
struct qtree_mem_dqinfo { struct super_block * dqi_sb ; int dqi_type ; unsigned int dqi_blocks ; unsigned int dqi_free_blk ; unsigned int dqi_free_entry ; unsigned int dqi_blocksize_bits ; unsigned int dqi_entry_size ; unsigned int dqi_usable_bs ; unsigned int dqi_qtree_depth ; struct qtree_fmt_operations * dqi_ops ; } ;
typedef long long qsize_t ;
struct quota_format_type ;
struct quota_format_type { int qf_fmt_id ; const struct quota_format_ops * qf_ops ; struct module * qf_owner ; struct quota_format_type * qf_next ; } ;
struct quota_module_name { int qm_fmt_id ; char * qm_mod_name ; } ;
struct lock_manager { struct list_head list ; } ;
struct fiemap_extent_info { unsigned int fi_flags ; unsigned int fi_extents_mapped ; unsigned int fi_extents_max ; struct fiemap_extent * fi_extents_start ; } ;
struct tree_descr { char * name ; const struct file_operations * ops ; int mode ; } ;
struct kmem_cache_cpu { void * * freelist ; unsigned long tid ; struct page * page ; struct page * partial ; } ;
struct kmem_cache_order_objects { unsigned long x ; } ;
typedef unsigned long old_sigset_t ;
struct pt_regs ;
struct dev_archdata { struct dma_map_ops * dma_ops ; void * iommu ; } ;
struct subsys_dev_iter { struct klist_iter ki ; const struct device_type * type ; } ;
struct class_dev_iter { struct klist_iter ki ; const struct device_type * type ; } ;
struct device_dma_parameters { unsigned int max_segment_size ; unsigned long segment_boundary_mask ; } ;
struct acpi_dev_node { void * handle ; } ;
typedef unsigned long kernel_ulong_t ;
struct of_device_id { char name [ 32 ] ; char type [ 32 ] ; char compatible [ 128 ] ; const void * data ; } ;
struct vio_device_id { char type [ 32 ] ; char compat [ 32 ] ; } ;
struct rpmsg_device_id { char name [ 32 ] ; } ;
struct dmi_strmatch { unsigned char slot ; char substr [ 79 ] ; } ;
struct amba_id { unsigned int id ; unsigned int mask ; void * data ; } ;
typedef int pci_power_t ;
typedef unsigned int pci_channel_state_t ;
typedef unsigned int pcie_reset_state_t ;
typedef unsigned short pci_dev_flags_t ;
typedef unsigned short pci_bus_flags_t ;
struct pci_bus_resource { struct list_head list ; struct resource * res ; unsigned int flags ; } ;
typedef unsigned int pci_ers_result_t ;
struct arch_uprobe_task { unsigned long saved_scratch_register ; unsigned int saved_trap_nr ; unsigned int saved_tf ; } ;
typedef unsigned long vm_flags_t ;
struct task_rss_stat { int events ; int count [ NR_MM_COUNTERS ] ; } ;
struct vm_fault { unsigned int flags ; unsigned long pgoff ; void * virtual_address ; struct page * page ; } ;
struct vm_event_state { unsigned long event [ NR_VM_EVENT_ITEMS ] ; } ;
struct zap_details { struct vm_area_struct * nonlinear_vma ; struct address_space * check_mapping ; unsigned long first_index ; unsigned long last_index ; } ;
struct vm_unmapped_area_info { unsigned long flags ; unsigned long length ; unsigned long low_limit ; unsigned long high_limit ; unsigned long align_mask ; unsigned long align_offset ; } ;
struct pci_sysdata { int domain ; int node ; void * iommu ; } ;
struct dma_attrs { unsigned long flags [ ( ( ( DMA_ATTR_MAX ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;
struct sg_table { struct scatterlist * sgl ; unsigned int nents ; unsigned int orig_nents ; } ;
struct dma_attrs ;
struct sched_param { int sched_priority ; } ;
typedef unsigned long cputime_t ;
struct ipc_kludge { struct msgbuf * msgp ; long msgtyp ; } ;
struct sembuf { unsigned short sem_num ; short sem_op ; short sem_flg ; } ;
union semun { int val ; struct semid_ds * buf ; unsigned short * array ; struct seminfo * __buf ; void * __pad ; } ;
struct seminfo { int semmap ; int semmni ; int semmns ; int semmnu ; int semmsl ; int semopm ; int semume ; int semusz ; int semvmx ; int semaem ; } ;
struct seccomp { int mode ; struct seccomp_filter * filter ; } ;
struct plist_head { struct list_head node_list ; } ;
struct plist_node { int prio ; struct list_head prio_list ; struct list_head node_list ; } ;
struct rlimit { unsigned long rlim_cur ; unsigned long rlim_max ; } ;
struct latency_record { unsigned long backtrace [ 12 ] ; unsigned int count ; unsigned long time ; unsigned long max ; } ;
struct blk_plug ;
struct task_migration_notifier { struct task_struct * task ; int from_cpu ; int to_cpu ; } ;
typedef unsigned long aio_context_t ;
struct reclaim_state ;
struct sched_info { unsigned long pcount ; unsigned long long run_delay ; unsigned long long last_arrival , last_queued ; } ;
struct sched_domain_attr { int relax_domain_level ; } ;
struct load_weight { unsigned long weight , inv_weight ; } ;
struct sched_rt_entity { struct list_head run_list ; unsigned long timeout ; unsigned int time_slice ; struct sched_rt_entity * back ; struct sched_rt_entity * parent ; struct rt_rq * rt_rq ; struct rt_rq * my_q ; } ;
struct pt_regs ;
struct pt_regs ;
struct exception_table_entry { int insn , fixup ; } ;
struct __large_struct { unsigned long buf [ 100 ] ; } ;
struct io_apic_irq_attr { int ioapic ; int ioapic_pin ; int trigger ; int polarity ; } ;
extern void ( * __attribute__ ( ( __section__ ( ".init.rodata" ) ) ) interrupt [ 256 - 0x20 ] ) ( void ) ;
typedef int vector_irq_t [ 256 ] ;
struct irq_chip_regs { unsigned long enable ; unsigned long disable ; unsigned long mask ; unsigned long ack ; unsigned long eoi ; unsigned long type ; unsigned long polarity ; } ;
struct dma_chan_percpu { unsigned long memcpy_count ; unsigned long bytes_transferred ; } ;
struct dma_page_list { char * base_address ; int nr_pages ; struct page * * pages ; } ;
struct dql { unsigned int num_queued ; unsigned int adj_limit ; unsigned int last_obj_cnt ; unsigned int limit __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; unsigned int num_completed ; unsigned int prev_ovlimit ; unsigned int prev_num_queued ; unsigned int prev_last_obj_cnt ; unsigned int lowest_slack ; unsigned long slack_start_time ; unsigned int max_limit ; unsigned int min_limit ; unsigned int slack_hold_time ; } ;
typedef unsigned short __kernel_sa_family_t ;
struct linger { int l_onoff ; int l_linger ; } ;
struct ifmap { unsigned long mem_start ; unsigned long mem_end ; unsigned short base_addr ; unsigned char irq ; unsigned char dma ; unsigned char port ; } ;
struct user32_fxsr_struct { unsigned short cwd ; unsigned short swd ; unsigned short twd ; unsigned short fop ; int fip ; int fcs ; int foo ; int fos ; int mxcsr ; int reserved ; int st_space [ 32 ] ; int xmm_space [ 32 ] ; int padding [ 56 ] ; } ;
struct socket { socket_state state ; ; short type ; ; unsigned long flags ; struct socket_wq * wq ; struct file * file ; struct sock * sk ; const struct proto_ops * ops ; } ;
struct ts_state { unsigned int offset ; char cb [ 40 ] ; } ;
typedef unsigned int sk_buff_data_t ;
struct netns_core { struct ctl_table_header * sysctl_hdr ; int sysctl_somaxconn ; struct prot_inuse * inuse ; } ;
struct snmp_mib { const char * name ; int entry ; } ;
struct icmp_mib { unsigned long mibs [ __ICMP_MIB_MAX ] ; } ;
struct icmpv6_mib { unsigned long mibs [ __ICMP6_MIB_MAX ] ; } ;
struct tcp_mib { unsigned long mibs [ __TCP_MIB_MAX ] ; } ;
struct udp_mib { unsigned long mibs [ __UDP_MIB_MAX ] ; } ;
struct linux_mib { unsigned long mibs [ __LINUX_MIB_MAX ] ; } ;
struct linux_xfrm_mib { unsigned long mibs [ __LINUX_MIB_XFRMMAX ] ; } ;
struct netns_unix { int sysctl_max_dgram_qlen ; struct ctl_table_header * ctl ; } ;
struct netns_sysctl_ipv6 { struct ctl_table_header * hdr ; struct ctl_table_header * route_hdr ; struct ctl_table_header * icmp_hdr ; struct ctl_table_header * frags_hdr ; int bindv6only ; int flush_delay ; int ip6_rt_max_size ; int ip6_rt_gc_min_interval ; int ip6_rt_gc_timeout ; int ip6_rt_gc_interval ; int ip6_rt_gc_elasticity ; int ip6_rt_mtu_expires ; int ip6_rt_min_advmss ; int icmpv6_time ; } ;
typedef unsigned long flow_compare_t ;
struct nf_proto_net { struct ctl_table_header * ctl_table_header ; struct ctl_table * ctl_table ; struct ctl_table_header * ctl_compat_header ; struct ctl_table * ctl_compat_table ; unsigned int users ; } ;
struct xfrm_algo { char alg_name [ 64 ] ; unsigned int alg_key_len ; char alg_key [ 0 ] ; } ;
struct xfrm_algo_auth { char alg_name [ 64 ] ; unsigned int alg_key_len ; unsigned int alg_trunc_len ; char alg_key [ 0 ] ; } ;
struct xfrm_algo_aead { char alg_name [ 64 ] ; unsigned int alg_key_len ; unsigned int alg_icv_len ; char alg_key [ 0 ] ; } ;
struct xfrm_policy_hash { struct hlist_head * table ; unsigned int hmask ; } ;
struct dsa_platform_data { struct device * netdev ; int nr_chips ; struct dsa_chip_data * chip ; } ;
struct ida_bitmap { long nr_busy ; unsigned long bitmap [ ( 128 / sizeof ( long ) - 1 ) ] ; } ;
struct cftype_set { struct list_head node ; struct cftype * cfts ; } ;
struct rlimit ;
struct sembuf ;
struct vfsmount ;
struct timezone ;
struct socket ;
struct sched_param ;
struct scm_fp_list { short count ; short max ; struct file * fp [ 253 ] ; } ;
struct netlink_notify { struct net * net ; int portid ; int protocol ; } ;
struct tpacket_stats { unsigned int tp_packets ; unsigned int tp_drops ; } ;
struct tpacket_stats_v3 { unsigned int tp_packets ; unsigned int tp_drops ; unsigned int tp_freeze_q_cnt ; } ;
struct tpacket_hdr { unsigned long tp_status ; unsigned int tp_len ; unsigned int tp_snaplen ; unsigned short tp_mac ; unsigned short tp_net ; unsigned int tp_sec ; unsigned int tp_usec ; } ;
struct tpacket_req { unsigned int tp_block_size ; unsigned int tp_block_nr ; unsigned int tp_frame_size ; unsigned int tp_frame_nr ; } ;
struct tpacket_req3 { unsigned int tp_block_size ; unsigned int tp_block_nr ; unsigned int tp_frame_size ; unsigned int tp_frame_nr ; unsigned int tp_retire_blk_tov ; unsigned int tp_sizeof_priv ; unsigned int tp_feature_req_word ; } ;
struct packet_mreq { int mr_ifindex ; unsigned short mr_type ; unsigned short mr_alen ; unsigned char mr_address [ 8 ] ; } ;
struct net_device_stats { unsigned long rx_packets ; unsigned long tx_packets ; unsigned long rx_bytes ; unsigned long tx_bytes ; unsigned long rx_errors ; unsigned long tx_errors ; unsigned long rx_dropped ; unsigned long tx_dropped ; unsigned long multicast ; unsigned long collisions ; unsigned long rx_length_errors ; unsigned long rx_over_errors ; unsigned long rx_crc_errors ; unsigned long rx_frame_errors ; unsigned long rx_fifo_errors ; unsigned long rx_missed_errors ; unsigned long tx_aborted_errors ; unsigned long tx_carrier_errors ; unsigned long tx_fifo_errors ; unsigned long tx_heartbeat_errors ; unsigned long tx_window_errors ; unsigned long rx_compressed ; unsigned long tx_compressed ; } ;
struct netdev_hw_addr_list { struct list_head list ; int count ; } ;
struct netdev_fcoe_hbainfo { char manufacturer [ 64 ] ; char serial_number [ 64 ] ; char hardware_version [ 64 ] ; char driver_version [ 64 ] ; char optionrom_version [ 64 ] ; char firmware_version [ 64 ] ; char model [ 256 ] ; char model_description [ 256 ] ; } ;
struct rtattr { unsigned short rta_len ; unsigned short rta_type ; } ;
struct rtmsg { unsigned char rtm_family ; unsigned char rtm_dst_len ; unsigned char rtm_src_len ; unsigned char rtm_tos ; unsigned char rtm_table ; unsigned char rtm_protocol ; unsigned char rtm_scope ; unsigned char rtm_type ; unsigned rtm_flags ; } ;
struct rtnexthop { unsigned short rtnh_len ; unsigned char rtnh_flags ; unsigned char rtnh_hops ; int rtnh_ifindex ; } ;
struct rtgenmsg { unsigned char rtgen_family ; } ;
struct ifinfomsg { unsigned char ifi_family ; unsigned char __ifi_pad ; unsigned short ifi_type ; int ifi_index ; unsigned ifi_flags ; unsigned ifi_change ; } ;
struct prefixmsg { unsigned char prefix_family ; unsigned char prefix_pad1 ; unsigned short prefix_pad2 ; int prefix_ifindex ; unsigned char prefix_type ; unsigned char prefix_len ; unsigned char prefix_flags ; unsigned char prefix_pad3 ; } ;
struct tcamsg { unsigned char tca_family ; unsigned char tca__pad1 ; unsigned short tca__pad2 ; } ;
struct builtin_fw { char * name ; void * data ; unsigned long size ; } ;
struct mem_cgroup_reclaim_cookie { struct zone * zone ; int priority ; unsigned int generation ; } ;
struct sock_fprog { unsigned short len ; struct sock_filter * filter ; } ;
struct pollfd { int fd ; short events ; short revents ; } ;
struct neigh_statistics { unsigned long allocs ; unsigned long destroys ; unsigned long hash_grows ; unsigned long res_failed ; unsigned long lookups ; unsigned long hits ; unsigned long rcv_probes_mcast ; unsigned long rcv_probes_ucast ; unsigned long periodic_gc_runs ; unsigned long forced_gc_runs ; unsigned long unres_discards ; } ;
struct neighbour_cb { unsigned long sched_next ; unsigned int flags ; } ;
struct tc_estimator { signed char interval ; unsigned char ewma_log ; } ;
struct tc_sizespec { unsigned char cell_log ; unsigned char size_log ; short cell_align ; int overhead ; unsigned int linklayer ; unsigned int mpu ; unsigned int mtu ; unsigned int tsize ; } ;
struct tc_cbq_police { unsigned char police ; unsigned char __res1 ; unsigned short __res2 ; } ;
struct tc_cnt { int refcnt ; int bindcnt ; } ;
struct gnet_estimator { signed char interval ; unsigned char ewma_log ; } ;
struct Qdisc_class_hash { struct hlist_head * hash ; unsigned int hashsize ; unsigned int hashmask ; unsigned int hashelems ; } ;
typedef long psched_tdiff_t ;
struct pt_regs ;
struct disk_stats { unsigned long sectors [ 2 ] ; unsigned long ios [ 2 ] ; unsigned long merges [ 2 ] ; unsigned long ticks [ 2 ] ; unsigned long io_ticks ; unsigned long time_in_queue ; } ;
struct disk_part_iter { struct gendisk * disk ; struct hd_struct * part ; int idx ; unsigned int flags ; } ;
struct rq_map_data ;
struct biovec_slab { int nr_vecs ; char * name ; struct kmem_cache * slab ; } ;
typedef struct request * ( elevator_request_list_fn ) ( struct request_queue * , struct request * ) ;
struct bio_vec ;
typedef enum blk_eh_timer_return ( rq_timed_out_fn ) ( struct request * ) ;
struct queue_limits { unsigned long bounce_pfn ; unsigned long seg_boundary_mask ; unsigned int max_hw_sectors ; unsigned int max_sectors ; unsigned int max_segment_size ; unsigned int physical_block_size ; unsigned int alignment_offset ; unsigned int io_min ; unsigned int io_opt ; unsigned int max_discard_sectors ; unsigned int max_write_same_sectors ; unsigned int discard_granularity ; unsigned int discard_alignment ; unsigned short logical_block_size ; unsigned short max_segments ; unsigned short max_integrity_segments ; unsigned char misaligned ; unsigned char discard_misaligned ; unsigned char cluster ; unsigned char discard_zeroes_data ; } ;
struct rq_map_data { struct page * * pages ; int page_order ; int nr_entries ; unsigned long offset ; int null_mapped ; int from_user ; } ;
struct req_iterator { int i ; struct bio * bio ; } ;
struct blk_plug { unsigned long magic ; struct list_head list ; struct list_head cb_list ; unsigned int should_sort ; } ;
typedef struct { struct page * v ; } Sector ;
typedef unsigned int tid_t ;
struct crypto_attr_alg { char name [ 64 ] ; } ;
struct jbd2_inode { transaction_t * i_transaction ; transaction_t * i_next_transaction ; struct list_head i_list ; struct inode * i_vfs_inode ; unsigned long i_flags ; } ;
struct jbd2_journal_handle { transaction_t * h_transaction ; int h_buffer_credits ; int h_ref ; int h_err ; unsigned int h_sync : 1 ; unsigned int h_jdata : 1 ; unsigned int h_aborted : 1 ; unsigned int h_cowing : 1 ; unsigned int h_base_credits : 14 ; unsigned int h_user_credits : 14 ; } ;
struct vfsmount ;
struct vfsmount { struct dentry * mnt_root ; struct super_block * mnt_sb ; int mnt_flags ; } ;
struct reclaim_state { unsigned long reclaimed_slab ; } ;
struct swap_list_t { int head ; int next ; } ;
struct match_token { int token ; const char * pattern ; } ;
struct vfsmount ;
struct vfsmount ;

typedef unsigned char BOOLEAN ;
typedef unsigned char UINT8 ;
typedef unsigned short UINT16 ;
typedef unsigned long long UINT64 ;
typedef long long INT64 ;
typedef unsigned int UINT32 ;
typedef int INT32 ;
typedef char * acpi_string ;
typedef void * acpi_handle ;
typedef char acpi_bus_id [ 8 ] ;
typedef unsigned long acpi_bus_address ;
typedef char acpi_device_name [ 40 ] ;
typedef char acpi_device_class [ 20 ] ;
struct acpi_hardware_id { struct list_head list ; char * id ; } ;
struct cdrom_read { int cdread_lba ; char * cdread_bufaddr ; int cdread_buflen ; } ;
struct cdrom_blk { unsigned from ; unsigned short len ; } ;
struct cdrom_generic_command { unsigned char cmd [ 12 ] ; unsigned char * buffer ; unsigned int buflen ; int stat ; struct request_sense * sense ; unsigned char data_direction ; int quiet ; int timeout ; void * reserved [ 1 ] ; } ;
struct packet_command { unsigned char cmd [ 12 ] ; unsigned char * buffer ; unsigned int buflen ; int stat ; struct request_sense * sense ; unsigned char data_direction ; int quiet ; int timeout ; void * reserved [ 1 ] ; } ;
enum ata_xfer_mask { ATA_MASK_PIO = ( ( 1LU << ATA_NR_PIO_MODES ) - 1 ) << ATA_SHIFT_PIO , ATA_MASK_MWDMA = ( ( 1LU << ATA_NR_MWDMA_MODES ) - 1 ) << ATA_SHIFT_MWDMA , ATA_MASK_UDMA = ( ( 1LU << ATA_NR_UDMA_MODES ) - 1 ) << ATA_SHIFT_UDMA , } ;
struct ata_ioports { void * cmd_addr ; void * data_addr ; void * error_addr ; void * feature_addr ; void * nsect_addr ; void * lbal_addr ; void * lbam_addr ; void * lbah_addr ; void * device_addr ; void * status_addr ; void * command_addr ; void * altstatus_addr ; void * ctl_addr ; void * bmdma_addr ; void * scr_addr ; } ;
struct ata_port_stats { unsigned long unhandled_irq ; unsigned long idle_irq ; unsigned long rw_reqbuf ; } ;
struct ata_port_info { unsigned long flags ; unsigned long link_flags ; unsigned long pio_mask ; unsigned long mwdma_mask ; unsigned long udma_mask ; struct ata_port_operations * port_ops ; void * private_data ; } ;
struct ata_timing { unsigned short mode ; unsigned short setup ; unsigned short act8b ; unsigned short rec8b ; unsigned short cyc8b ; unsigned short active ; unsigned short recover ; unsigned short dmack_hold ; unsigned short cycle ; unsigned short udma ; } ;
struct pci_bits { unsigned int reg ; unsigned int width ; unsigned long mask ; unsigned long val ; } ;
struct input_handle ;
struct input_handle { void * private_ ; int open ; const char * name ; struct input_dev * dev ; struct input_handler * handler ; struct list_head d_node ; struct list_head h_node ; } ;
struct pnp_id { char id [ 8 ] ; struct pnp_id * next ; } ;
typedef __gnuc_va_list va_list ;
typedef unsigned short umode_t ;
typedef struct { unsigned long fds_bits [ ( 1024 / ( 8 * sizeof ( unsigned long ) ) ) ] ; } __kernel_fd_set ;
typedef void ( * __kernel_sighandler_t ) ( int ) ;
typedef struct { int val [ 2 ] ; } __kernel_fsid_t ;
typedef __kernel_uid_t __kernel_uid32_t ;
typedef __kernel_gid_t __kernel_gid32_t ;
typedef __u16 __le16 ;
typedef __u16 __be16 ;
typedef __u32 __le32 ;
typedef __u32 __be32 ;
typedef __u64 __le64 ;
typedef __u64 __be64 ;
typedef __u16 __sum16 ;
typedef __u32 __wsum ;
typedef __u32 __kernel_dev_t ;
typedef __kernel_ino_t ino_t ;
typedef __kernel_mode_t mode_t ;
typedef __u32 nlink_t ;
typedef __kernel_off_t off_t ;
typedef __kernel_pid_t pid_t ;
typedef __kernel_daddr_t daddr_t ;
typedef __kernel_key_t key_t ;
typedef __kernel_suseconds_t suseconds_t ;
typedef __kernel_timer_t timer_t ;
typedef __kernel_clockid_t clockid_t ;
typedef __kernel_mqd_t mqd_t ;
typedef K_Bool K_bool ;
typedef __kernel_uid16_t uid16_t ;
typedef __kernel_gid16_t gid16_t ;
typedef __kernel_old_uid_t old_uid_t ;
typedef __kernel_old_gid_t old_gid_t ;
typedef __kernel_loff_t loff_t ;
typedef __kernel_size_t size_t ;
typedef __kernel_ssize_t ssize_t ;
typedef __kernel_ptrdiff_t ptrdiff_t ;
typedef __kernel_time_t time_t ;
typedef __kernel_clock_t clock_t ;
typedef __kernel_caddr_t caddr_t ;
typedef __u8 u_int8_t ;
typedef __s8 K_int8_t ;
typedef __u16 u_int16_t ;
typedef __s16 K_int16_t ;
typedef __u32 u_int32_t ;
typedef __s32 K_int32_t ;
typedef __u8 K_uint8_t ;
typedef __u16 K_uint16_t ;
typedef __u32 K_uint32_t ;
typedef __u64 K_uint64_t ;
typedef __u64 u_int64_t ;
typedef __s64 K_int64_t ;
typedef u64 dma_addr_t ;
typedef u64 phys_addr_t ;
typedef struct { int counter ; } atomic_t ;
typedef struct { long counter ; } atomic64_t ;
struct ustat { __kernel_daddr_t f_tfree ; __kernel_ino_t f_tinode ; char f_fname [ 6 ] ; char f_fpack [ 6 ] ; } ;
struct callback_head { struct callback_head * next ; void ( * func ) ( struct callback_head * head ) ; } ;
struct alt_instr { s32 instr_offset ; s32 repl_offset ; u16 cpuid ; u8 instrlen ; u8 replacementlen ; } ;
struct paravirt_patch_site ;
typedef int ( * initcall_t ) ( void ) ;
typedef void ( * exitcall_t ) ( void ) ;
typedef void ( * ctor_fn_t ) ( void ) ;
struct obs_kernel_param { const char * str ; int ( * setup_func ) ( char * ) ; int early ; } ;
struct sysinfo { __kernel_long_t uptime ; __kernel_ulong_t loads [ 3 ] ; __kernel_ulong_t totalram ; __kernel_ulong_t freeram ; __kernel_ulong_t sharedram ; __kernel_ulong_t bufferram ; __kernel_ulong_t totalswap ; __kernel_ulong_t freeswap ; __u16 procs ; __u16 pad ; __kernel_ulong_t totalhigh ; __kernel_ulong_t freehigh ; __u32 mem_unit ; char _f [ 20 - 2 * sizeof ( __kernel_ulong_t ) - sizeof ( __u32 ) ] ; } ;
struct timespec ;
struct gate_struct64 { u16 offset_low ; u16 segment ; unsigned ist : 3 , zero0 : 5 , type : 5 , dpl : 2 , p : 1 ; u16 offset_middle ; u32 offset_high ; u32 zero1 ; } __attribute__ ( ( packed ) ) ;
struct ldttss_desc64 { u16 limit0 ; u16 base0 ; unsigned base1 : 8 , type : 5 , dpl : 2 , p : 1 ; unsigned limit1 : 4 , zero0 : 3 , g : 1 , base2 : 8 ; u32 base3 ; u32 zero1 ; } __attribute__ ( ( packed ) ) ;
struct pv_info { unsigned int kernel_rpl ; int shared_kernel_pmd ; u16 extra_user_64bit_cs ; int paravirt_enabled ; const char * name ; } ;
struct pv_lazy_ops { void ( * enter ) ( void ) ; void ( * leave ) ( void ) ; } ;
struct pv_time_ops { unsigned long long ( * sched_clock ) ( void ) ; unsigned long long ( * steal_clock ) ( int cpu ) ; unsigned long ( * get_tsc_khz ) ( void ) ; } ;
struct pv_irq_ops { struct paravirt_callee_save save_fl ; struct paravirt_callee_save restore_fl ; struct paravirt_callee_save irq_disable ; struct paravirt_callee_save irq_enable ; void ( * safe_halt ) ( void ) ; void ( * halt ) ( void ) ; void ( * adjust_exception_frame ) ( void ) ; } ;
struct pv_apic_ops { void ( * startup_ipi_hook ) ( int phys_apicid , unsigned long start_eip , unsigned long start_esp ) ; } ;
struct pv_lock_ops { int ( * spin_is_locked ) ( struct arch_spinlock * lock ) ; int ( * spin_is_contended ) ( struct arch_spinlock * lock ) ; void ( * spin_lock ) ( struct arch_spinlock * lock ) ; void ( * spin_lock_flags ) ( struct arch_spinlock * lock , unsigned long flags ) ; int ( * spin_trylock ) ( struct arch_spinlock * lock ) ; void ( * spin_unlock ) ( struct arch_spinlock * lock ) ; } ;
struct paravirt_patch_site { u8 * instr ; u8 instrtype ; u8 len ; u16 clobbers ; } ;
struct cpuinfo_x86 ;
struct vm86_struct { struct vm86_regs regs ; unsigned long flags ; unsigned long screen_bitmap ; unsigned long cpu_type ; struct revectored_struct int_revectored ; struct revectored_struct int21_revectored ; } ;
struct vm86plus_struct { struct vm86_regs regs ; unsigned long flags ; unsigned long screen_bitmap ; unsigned long cpu_type ; struct revectored_struct int_revectored ; struct revectored_struct int21_revectored ; struct vm86plus_info_struct vm86plus ; } ;
struct kernel_vm86_regs { struct pt_regs pt ; unsigned short es , __esh ; unsigned short ds , __dsh ; unsigned short fs , __fsh ; unsigned short gs , __gsh ; } ;
struct _fpx_sw_bytes { __u32 magic1 ; __u32 extended_size ; __u64 xstate_bv ; __u32 xstate_size ; __u32 padding [ 7 ] ; } ;
struct _xsave_hdr { __u64 xstate_bv ; __u64 reserved1 [ 2 ] ; __u64 reserved2 [ 5 ] ; } ;
struct _ymmh_state { __u32 ymmh_space [ 64 ] ; } ;
typedef struct cpumask { unsigned long bits [ ( ( ( 256 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } cpumask_t ;
typedef struct cpumask cpumask_var_t [ 1 ] ;
struct msr_regs_info { u32 * regs ; int err ; } ;
typedef void ( * handler_t ) ( int , struct pt_regs * ) ;
struct cpuinfo_x86 { __u8 x86 ; __u8 x86_vendor ; __u8 x86_model ; __u8 x86_mask ; int x86_tlbsize ; __u8 x86_virt_bits ; __u8 x86_phys_bits ; __u8 x86_coreid_bits ; __u32 extended_cpuid_level ; int cpuid_level ; __u32 x86_capability [ 10 ] ; char x86_vendor_id [ 16 ] ; char x86_model_id [ 64 ] ; int x86_cache_size ; int x86_cache_alignment ; int x86_power ; unsigned long loops_per_jiffy ; u16 x86_max_cores ; u16 apicid ; u16 initial_apicid ; u16 x86_clflush_size ; u16 booted_cores ; u16 phys_proc_id ; u16 cpu_core_id ; u8 compute_unit_id ; u16 cpu_index ; u32 microcode ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct x86_hw_tss { u32 reserved1 ; u64 sp0 ; u64 sp1 ; u64 sp2 ; u64 reserved2 ; u64 ist [ 7 ] ; u32 reserved3 ; u32 reserved4 ; u16 reserved5 ; u16 io_bitmap_base ; } __attribute__ ( ( packed ) ) __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct i387_fsave_struct { u32 cwd ; u32 swd ; u32 twd ; u32 fip ; u32 fcs ; u32 foo ; u32 fos ; u32 st_space [ 20 ] ; u32 status ; } ;
struct i387_soft_struct { u32 cwd ; u32 swd ; u32 twd ; u32 fip ; u32 fcs ; u32 foo ; u32 fos ; u32 st_space [ 20 ] ; u8 ftop ; u8 changed ; u8 lookahead ; u8 no_update ; u8 rm ; u8 alimit ; struct math_emu_info * info ; u32 entry_eip ; } ;
struct ymmh_struct { u32 ymmh_space [ 64 ] ; } ;
struct xsave_hdr_struct { u64 xstate_bv ; u64 reserved1 [ 2 ] ; u64 reserved2 [ 5 ] ; } __attribute__ ( ( packed ) ) ;
union irq_stack_union { char irq_stack [ ( ( ( 1UL ) << 12 ) << 2 ) ] ; struct { char gs_base [ 40 ] ; unsigned long stack_canary ; } ; } ;
typedef struct { unsigned long seg ; } mm_segment_t ;
struct aperfmperf { u64 aperf , mperf ; } ;
typedef struct { unsigned long int error_code ; unsigned char * xip ; unsigned long int cs ; unsigned long int xflags ; unsigned long int xsp ; unsigned long int ss ; } interrupt_stack_frame ;
struct preempt_ops { void ( * sched_in ) ( struct preempt_notifier * notifier , int cpu ) ; void ( * sched_out ) ( struct preempt_notifier * notifier , struct task_struct * next ) ; } ;
typedef u16 __ticket_t ;
typedef u32 __ticketpair_t ;
typedef struct seqcount { unsigned sequence ; } seqcount_t ;
struct timespec { __kernel_time_t tv_sec ; long tv_nsec ; } ;
struct timeval { __kernel_time_t tv_sec ; __kernel_suseconds_t tv_usec ; } ;
typedef int ( * wait_queue_func_t ) ( wait_queue_t * wait , unsigned mode , int flags , void * key ) ;
typedef struct { unsigned long bits [ ( ( ( ( 1 << 6 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } nodemask_t ;
struct lruvec { struct list_head lists [ NR_LRU_LISTS ] ; struct zone_reclaim_stat reclaim_stat ; } ;
struct per_cpu_pageset { struct per_cpu_pages pcp ; s8 expire ; s8 stat_threshold ; s8 vm_stat_diff [ NR_VM_ZONE_STAT_ITEMS ] ; } ;
struct zonelist { struct zonelist_cache * zlcache_ptr ; struct zoneref _zonerefs [ ( ( 1 << 6 ) * 4 ) + 1 ] ; struct zonelist_cache zlcache ; } ;
struct debug_obj_descr ;
struct debug_obj_descr { const char * name ; void * ( * debug_hint ) ( void * addr ) ; int ( * fixup_init ) ( void * addr , enum debug_obj_state state ) ; int ( * fixup_activate ) ( void * addr , enum debug_obj_state state ) ; int ( * fixup_destroy ) ( void * addr , enum debug_obj_state state ) ; int ( * fixup_free ) ( void * addr , enum debug_obj_state state ) ; int ( * fixup_assert_init ) ( void * addr , enum debug_obj_state state ) ; } ;
struct notifier_block ;
union ktime { s64 tv64 ; } ;
struct timer_list { struct list_head entry ; unsigned long expires ; struct tvec_base * base ; void ( * function ) ( unsigned long ) ; unsigned long data ; int slack ; int start_pid ; void * start_site ; char start_comm [ 16 ] ; } ;
typedef void ( * work_func_t ) ( struct work_struct * work ) ;
struct notifier_block { int ( * notifier_call ) ( struct notifier_block * , unsigned long , void * ) ; struct notifier_block * next ; int priority ; } ;
typedef void ( * online_page_callback_t ) ( struct page * page ) ;
struct screen_info { __u8 orig_x ; __u8 orig_y ; __u16 ext_mem_k ; __u16 orig_video_page ; __u8 orig_video_mode ; __u8 orig_video_cols ; __u8 flags ; __u8 unused2 ; __u16 orig_video_ega_bx ; __u16 unused3 ; __u8 orig_video_lines ; __u8 orig_video_isVGA ; __u16 orig_video_points ; __u16 lfb_width ; __u16 lfb_height ; __u16 lfb_depth ; __u32 lfb_base ; __u32 lfb_size ; __u16 cl_magic , cl_offset ; __u16 lfb_linelength ; __u8 red_size ; __u8 red_pos ; __u8 green_size ; __u8 green_pos ; __u8 blue_size ; __u8 blue_pos ; __u8 rsvd_size ; __u8 rsvd_pos ; __u16 vesapm_seg ; __u16 vesapm_off ; __u16 pages ; __u16 vesa_attributes ; __u32 capabilities ; __u8 _reserved [ 6 ] ; } __attribute__ ( ( packed ) ) ;
struct apm_bios_info { __u16 version ; __u16 cseg ; __u32 offset ; __u16 cseg_16 ; __u16 dseg ; __u16 flags ; __u16 cseg_len ; __u16 cseg_16_len ; __u16 dseg_len ; } ;
struct e820entry { __u64 addr ; __u64 size ; __u32 type ; } __attribute__ ( ( packed ) ) ;
struct setup_data ;
struct ist_info { __u32 signature ; __u32 command ; __u32 event ; __u32 perf_level ; } ;
struct setup_data { __u64 next ; __u32 type ; __u32 len ; __u8 data [ 0 ] ; } ;
struct setup_header { __u8 setup_sects ; __u16 root_flags ; __u32 syssize ; __u16 ram_size ; __u16 vid_mode ; __u16 root_dev ; __u16 boot_flag ; __u16 jump ; __u32 header ; __u16 version ; __u32 realmode_swtch ; __u16 start_sys ; __u16 kernel_version ; __u8 type_of_loader ; __u8 loadflags ; __u16 setup_move_size ; __u32 code32_start ; __u32 ramdisk_image ; __u32 ramdisk_size ; __u32 bootsect_kludge ; __u16 heap_end_ptr ; __u8 ext_loader_ver ; __u8 ext_loader_type ; __u32 cmd_line_ptr ; __u32 initrd_addr_max ; __u32 kernel_alignment ; __u8 relocatable_kernel ; __u8 _pad2 [ 3 ] ; __u32 cmdline_size ; __u32 hardware_subarch ; __u64 hardware_subarch_data ; __u32 payload_offset ; __u32 payload_length ; __u64 setup_data ; } __attribute__ ( ( packed ) ) ;
struct sys_desc_table { __u16 length ; __u8 table [ 14 ] ; } ;
struct olpc_ofw_header { __u32 ofw_magic ; __u32 ofw_version ; __u32 cif_handler ; __u32 irq_desc_table ; } __attribute__ ( ( packed ) ) ;
struct efi_info { __u32 efi_loader_signature ; __u32 efi_systab ; __u32 efi_memdesc_size ; __u32 efi_memdesc_version ; __u32 efi_memmap ; __u32 efi_memmap_size ; __u32 efi_systab_hi ; __u32 efi_memmap_hi ; } ;
struct cpuinfo_x86 ;
struct x86_init_mpparse { void ( * mpc_record ) ( unsigned int mode ) ; void ( * setup_ioapic_ids ) ( void ) ; int ( * mpc_apic_id ) ( struct mpc_cpu * m ) ; void ( * smp_read_mpc_oem ) ( struct mpc_table * mpc ) ; void ( * mpc_oem_pci_bus ) ( struct mpc_bus * m ) ; void ( * mpc_oem_bus_info ) ( struct mpc_bus * m , char * name ) ; void ( * find_smp_config ) ( void ) ; void ( * get_smp_config ) ( unsigned int early ) ; } ;
struct x86_init_resources { void ( * probe_roms ) ( void ) ; void ( * reserve_resources ) ( void ) ; char * ( * memory_setup ) ( void ) ; } ;
struct x86_init_irqs { void ( * pre_vector_init ) ( void ) ; void ( * intr_init ) ( void ) ; void ( * trap_init ) ( void ) ; } ;
struct x86_init_oem { void ( * arch_setup ) ( void ) ; void ( * banner ) ( void ) ; } ;
struct x86_init_paging { void ( * pagetable_init ) ( void ) ; } ;
struct x86_init_timers { void ( * setup_percpu_clockev ) ( void ) ; void ( * tsc_pre_init ) ( void ) ; void ( * timer_init ) ( void ) ; void ( * wallclock_init ) ( void ) ; } ;
struct x86_init_iommu { int ( * iommu_init ) ( void ) ; } ;
struct x86_init_pci { int ( * arch_init ) ( void ) ; int ( * init ) ( void ) ; void ( * init_irq ) ( void ) ; void ( * fixup_irqs ) ( void ) ; } ;
struct x86_cpuinit_ops { void ( * setup_percpu_clockev ) ( void ) ; void ( * early_percpu_clock_init ) ( void ) ; void ( * fixup_cpu_id ) ( struct cpuinfo_x86 * c , int node ) ; } ;
struct x86_msi_ops { int ( * setup_msi_irqs ) ( struct pci_dev * dev , int nvec , int type ) ; void ( * teardown_msi_irq ) ( unsigned int irq ) ; void ( * teardown_msi_irqs ) ( struct pci_dev * dev ) ; void ( * restore_msi_irqs ) ( struct pci_dev * dev , int irq ) ; } ;
struct x86_io_apic_ops { void ( * init ) ( void ) ; unsigned int ( * read ) ( unsigned int apic , unsigned int reg ) ; void ( * write ) ( unsigned int apic , unsigned int reg , unsigned int value ) ; void ( * modify ) ( unsigned int apic , unsigned int reg , unsigned int value ) ; } ;
typedef struct pm_message { int event ; } pm_message_t ;
struct dev_pm_ops { int ( * prepare ) ( struct device * dev ) ; void ( * complete ) ( struct device * dev ) ; int ( * suspend ) ( struct device * dev ) ; int ( * resume ) ( struct device * dev ) ; int ( * freeze ) ( struct device * dev ) ; int ( * thaw ) ( struct device * dev ) ; int ( * poweroff ) ( struct device * dev ) ; int ( * restore ) ( struct device * dev ) ; int ( * suspend_late ) ( struct device * dev ) ; int ( * resume_early ) ( struct device * dev ) ; int ( * freeze_late ) ( struct device * dev ) ; int ( * thaw_early ) ( struct device * dev ) ; int ( * poweroff_late ) ( struct device * dev ) ; int ( * restore_early ) ( struct device * dev ) ; int ( * suspend_noirq ) ( struct device * dev ) ; int ( * resume_noirq ) ( struct device * dev ) ; int ( * freeze_noirq ) ( struct device * dev ) ; int ( * thaw_noirq ) ( struct device * dev ) ; int ( * poweroff_noirq ) ( struct device * dev ) ; int ( * restore_noirq ) ( struct device * dev ) ; int ( * runtime_suspend ) ( struct device * dev ) ; int ( * runtime_resume ) ( struct device * dev ) ; int ( * runtime_idle ) ( struct device * dev ) ; } ;
typedef xen_pfn_t * __guest_handle_xen_pfn_t ;
typedef xen_ulong_t * __guest_handle_xen_ulong_t ;
struct pvclock_vcpu_time_info { u32 version ; u32 pad0 ; u64 tsc_timestamp ; u64 system_time ; u32 tsc_to_system_mul ; s8 tsc_shift ; u8 flags ; u8 pad [ 2 ] ; } __attribute__ ( ( __packed__ ) ) ;
struct pvclock_wall_clock { u32 version ; u32 sec ; u32 nsec ; } __attribute__ ( ( __packed__ ) ) ;
typedef u64 * __guest_handle_u64 ;
struct real_mode_header { u32 text_start ; u32 ro_end ; u32 trampoline_start ; u32 trampoline_status ; u32 trampoline_header ; u32 trampoline_pgd ; u32 wakeup_start ; u32 wakeup_header ; u32 machine_real_restart_asm ; u32 machine_real_restart_seg ; } ;
struct trampoline_header { u64 start ; u64 efer ; u32 cr4 ; } ;
typedef u64 cycle_t ;
struct IO_APIC_route_entry { __u32 vector : 8 , delivery_mode : 3 , dest_mode : 1 , delivery_status : 1 , polarity : 1 , irr : 1 , trigger : 1 , mask : 1 , __reserved_2 : 15 ; __u32 __reserved_3 : 24 , dest : 8 ; } __attribute__ ( ( packed ) ) ;
struct IR_IO_APIC_route_entry { __u64 vector : 8 , zero : 3 , index2 : 1 , delivery_status : 1 , polarity : 1 , irr : 1 , trigger : 1 , mask : 1 , reserved : 31 , format : 1 , index : 15 ; } __attribute__ ( ( packed ) ) ;
struct mp_ioapic_gsi { u32 gsi_base ; u32 gsi_end ; } ;
struct smp_ops { void ( * smp_prepare_boot_cpu ) ( void ) ; void ( * smp_prepare_cpus ) ( unsigned max_cpus ) ; void ( * smp_cpus_done ) ( unsigned max_cpus ) ; void ( * stop_other_cpus ) ( int wait ) ; void ( * smp_send_reschedule ) ( int cpu ) ; int ( * cpu_up ) ( unsigned cpu , struct task_struct * tidle ) ; int ( * cpu_disable ) ( void ) ; void ( * cpu_die ) ( unsigned int cpu ) ; void ( * play_dead ) ( void ) ; void ( * send_call_func_ipi ) ( const struct cpumask * mask ) ; void ( * send_call_func_single_ipi ) ( int cpu ) ; } ;
typedef void ( * smp_call_func_t ) ( void * info ) ;
typedef void ( * pcpu_fc_populate_pte_fn_t ) ( unsigned long addr ) ;
typedef int ( pcpu_fc_cpu_distance_fn_t ) ( unsigned int from , unsigned int to ) ;
struct ctl_node { struct rb_node node ; struct ctl_table_header * header ; } ;
struct user_i387_struct { unsigned short cwd ; unsigned short swd ; unsigned short twd ; unsigned short fop ; __u64 rip ; __u64 rdp ; __u32 mxcsr ; __u32 mxcsr_mask ; __u32 st_space [ 32 ] ; __u32 xmm_space [ 64 ] ; __u32 padding [ 24 ] ; } ;
struct user_ymmh_regs { __u32 ymmh_space [ 64 ] ; } ;
struct user_xsave_hdr { __u64 xstate_bv ; __u64 reserved1 [ 2 ] ; __u64 reserved2 [ 5 ] ; } ;
typedef elf_greg_t elf_gregset_t [ ( sizeof ( struct user_regs_struct ) / sizeof ( elf_greg_t ) ) ] ;
typedef __u32 Elf32_Addr ;
typedef __u16 Elf32_Half ;
typedef __u32 Elf32_Off ;
typedef __s32 Elf32_Sword ;
typedef __u32 Elf32_Word ;
typedef __u64 Elf64_Addr ;
typedef __u16 Elf64_Half ;
typedef __s16 Elf64_SHalf ;
typedef __u64 Elf64_Off ;
typedef __s32 Elf64_Sword ;
typedef __u32 Elf64_Word ;
typedef __u64 Elf64_Xword ;
typedef __s64 Elf64_Sxword ;
struct kobj_ns_type_operations { enum kobj_ns_type type ; void * ( * grab_current_ns ) ( void ) ; const void * ( * netlink_ns ) ( struct sock * sk ) ; const void * ( * initial_ns ) ( void ) ; void ( * drop_ns ) ( void * ) ; } ;
struct kobj_type { void ( * release ) ( struct kobject * kobj ) ; const struct sysfs_ops * sysfs_ops ; struct attribute * * default_attrs ; const struct kobj_ns_type_operations * ( * child_ns_type ) ( struct kobject * kobj ) ; const void * ( * namespace_ ) ( struct kobject * kobj ) ; } ;
struct kset_uevent_ops { int ( * const filter ) ( struct kset * kset , struct kobject * kobj ) ; const char * ( * const name ) ( struct kset * kset , struct kobject * kobj ) ; int ( * const uevent ) ( struct kset * kset , struct kobject * kobj , struct kobj_uevent_env * env ) ; } ;
struct kernel_param ;
struct kernel_param_ops { int ( * set ) ( const char * val , const struct kernel_param * kp ) ; int ( * get ) ( char * buffer , const struct kernel_param * kp ) ; void ( * free ) ( void * arg ) ; } ;
struct kernel_param { const char * name ; const struct kernel_param_ops * ops ; u16 perm ; s16 level ; union { void * arg ; const struct kparam_string * str ; const struct kparam_array * arr ; } ; } ;
struct notifier_block ;
struct radix_tree_root { unsigned int height ; gfp_t gfp_mask ; struct radix_tree_node * rnode ; } ;
struct fiemap_extent { __u64 fe_logical ; __u64 fe_physical ; __u64 fe_length ; __u64 fe_reserved64 [ 2 ] ; __u32 fe_flags ; __u32 fe_reserved [ 3 ] ; } ;
struct shrink_control { gfp_t gfp_mask ; unsigned long nr_to_scan ; } ;
typedef void ( bio_end_io_t ) ( struct bio * , int ) ;
typedef void ( bio_destructor_t ) ( struct bio * ) ;
struct fstrim_range { __u64 start ; __u64 len ; __u64 minlen ; } ;
struct iovec ;
struct qtree_fmt_operations { void ( * mem2disk_dqblk ) ( void * disk , struct dquot * dquot ) ; void ( * disk2mem_dqblk ) ( struct dquot * dquot , void * disk ) ; int ( * is_id ) ( void * disk , struct dquot * dquot ) ; } ;
struct if_dqblk { __u64 dqb_bhardlimit ; __u64 dqb_bsoftlimit ; __u64 dqb_curspace ; __u64 dqb_ihardlimit ; __u64 dqb_isoftlimit ; __u64 dqb_curinodes ; __u64 dqb_btime ; __u64 dqb_itime ; __u32 dqb_valid ; } ;
struct if_dqinfo { __u64 dqi_bgrace ; __u64 dqi_igrace ; __u32 dqi_flags ; __u32 dqi_valid ; } ;
struct mem_dqinfo { struct quota_format_type * dqi_format ; int dqi_fmt_id ; struct list_head dqi_dirty_list ; unsigned long dqi_flags ; unsigned int dqi_bgrace ; unsigned int dqi_igrace ; qsize_t dqi_maxblimit ; qsize_t dqi_maxilimit ; void * dqi_priv ; } ;
struct quota_format_ops { int ( * check_quota_file ) ( struct super_block * sb , int type ) ; int ( * read_file_info ) ( struct super_block * sb , int type ) ; int ( * write_file_info ) ( struct super_block * sb , int type ) ; int ( * free_file_info ) ( struct super_block * sb , int type ) ; int ( * read_dqblk ) ( struct dquot * dquot ) ; int ( * commit_dqblk ) ( struct dquot * dquot ) ; int ( * release_dqblk ) ( struct dquot * dquot ) ; } ;
struct file_handle { __u32 handle_bytes ; int handle_type ; unsigned char f_handle [ 0 ] ; } ;
struct file_lock_operations { void ( * fl_copy_lock ) ( struct file_lock * , struct file_lock * ) ; void ( * fl_release_private ) ( struct file_lock * ) ; } ;
struct lock_manager_operations { int ( * lm_compare_owner ) ( struct file_lock * , struct file_lock * ) ; void ( * lm_notify ) ( struct file_lock * ) ; int ( * lm_grant ) ( struct file_lock * , struct file_lock * , int ) ; void ( * lm_break ) ( struct file_lock * ) ; int ( * lm_change ) ( struct file_lock * * , int ) ; } ;
struct nfs_lock_info { u32 state ; struct nlm_lockowner * owner ; struct list_head list ; } ;
struct f_owner_ex { int type ; __kernel_pid_t pid ; } ;
struct flock { short l_type ; short l_whence ; __kernel_off_t l_start ; __kernel_off_t l_len ; __kernel_pid_t l_pid ; } ;
struct file_system_type { const char * name ; int fs_flags ; struct dentry * ( * mount ) ( struct file_system_type * , int , const char * , void * ) ; void ( * kill_sb ) ( struct super_block * ) ; struct module * owner ; struct file_system_type * next ; struct hlist_head fs_supers ; struct lock_class_key s_lock_key ; struct lock_class_key s_umount_key ; struct lock_class_key s_vfs_rename_key ; struct lock_class_key s_writers_key [ ( SB_FREEZE_COMPLETE - 1 ) ] ; struct lock_class_key i_lock_key ; struct lock_class_key i_mutex_key ; struct lock_class_key i_mutex_dir_key ; } ;
typedef int ( write_proc_t ) ( struct file * file , const char * buffer , unsigned long count , void * data ) ;
struct proc_ns_operations { const char * name ; int type ; void * ( * get ) ( struct task_struct * task ) ; void ( * put ) ( void * ns ) ; int ( * install ) ( struct nsproxy * nsproxy , void * ns ) ; unsigned int ( * inum ) ( void * ns ) ; } ;
union proc_op { int ( * proc_get_link ) ( struct dentry * , struct path * ) ; int ( * proc_read ) ( struct task_struct * task , char * page ) ; int ( * proc_show ) ( struct seq_file * m , struct pid_namespace * ns , struct pid * pid , struct task_struct * task ) ; } ;
typedef struct { unsigned long sig [ ( 64 / 64 ) ] ; } sigset_t ;
typedef void __signalfn_t ( int ) ;
typedef void __restorefn_t ( void ) ;
typedef union sigval { int sival_int ; void * sival_ptr ; } sigval_t ;
struct timespec ;
struct notifier_block ;
struct subsys_interface { const char * name ; struct bus_type * subsys ; struct list_head node ; int ( * add_dev ) ( struct device * dev , struct subsys_interface * sif ) ; int ( * remove_dev ) ( struct device * dev , struct subsys_interface * sif ) ; } ;
struct class_interface { struct list_head node ; struct class_ * class_ ; int ( * add_dev ) ( struct device * , struct class_interface * ) ; void ( * remove_dev ) ( struct device * , struct class_interface * ) ; } ;
typedef void ( * dr_release_t ) ( struct device * dev , void * res ) ;
typedef int ( * dr_match_t ) ( struct device * dev , void * res , void * match_data ) ;
struct pci_device_id { __u32 vendor , device ; __u32 subvendor , subdevice ; __u32 class_ , class_mask ; kernel_ulong_t driver_data ; } ;
struct ieee1394_device_id { __u32 match_flags ; __u32 vendor_id ; __u32 model_id ; __u32 specifier_id ; __u32 version ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;
struct usb_device_id { __u16 match_flags ; __u16 idVendor ; __u16 idProduct ; __u16 bcdDevice_lo ; __u16 bcdDevice_hi ; __u8 bDeviceClass ; __u8 bDeviceSubClass ; __u8 bDeviceProtocol ; __u8 bInterfaceClass ; __u8 bInterfaceSubClass ; __u8 bInterfaceProtocol ; __u8 bInterfaceNumber ; kernel_ulong_t driver_info __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;
struct hid_device_id { __u16 bus ; __u16 group ; __u32 vendor ; __u32 product ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;
struct ccw_device_id { __u16 match_flags ; __u16 cu_type ; __u16 dev_type ; __u8 cu_model ; __u8 dev_model ; kernel_ulong_t driver_info ; } ;
struct ap_device_id { __u16 match_flags ; __u8 dev_type ; __u8 pad1 ; __u32 pad2 ; kernel_ulong_t driver_info ; } ;
struct css_device_id { __u8 match_flags ; __u8 type ; __u16 pad2 ; __u32 pad3 ; kernel_ulong_t driver_data ; } ;
struct acpi_device_id { __u8 id [ 16 ] ; kernel_ulong_t driver_data ; } ;
struct pnp_device_id { __u8 id [ 8 ] ; kernel_ulong_t driver_data ; } ;
struct serio_device_id { __u8 type ; __u8 extra ; __u8 id ; __u8 proto ; } ;
struct pcmcia_device_id { __u16 match_flags ; __u16 manf_id ; __u16 card_id ; __u8 func_id ; __u8 function ; __u8 device_no ; __u32 prod_id_hash [ 4 ] __attribute__ ( ( aligned ( sizeof ( __u32 ) ) ) ) ; const char * prod_id [ 4 ] ; kernel_ulong_t driver_info ; char * cisfile ; } ;
struct input_device_id { kernel_ulong_t flags ; __u16 bustype ; __u16 vendor ; __u16 product ; __u16 version ; kernel_ulong_t evbit [ 0x1f / 64 + 1 ] ; kernel_ulong_t keybit [ 0x2ff / 64 + 1 ] ; kernel_ulong_t relbit [ 0x0f / 64 + 1 ] ; kernel_ulong_t absbit [ 0x3f / 64 + 1 ] ; kernel_ulong_t mscbit [ 0x07 / 64 + 1 ] ; kernel_ulong_t ledbit [ 0x0f / 64 + 1 ] ; kernel_ulong_t sndbit [ 0x07 / 64 + 1 ] ; kernel_ulong_t ffbit [ 0x7f / 64 + 1 ] ; kernel_ulong_t swbit [ 0x0f / 64 + 1 ] ; kernel_ulong_t driver_info ; } ;
struct eisa_device_id { char sig [ 8 ] ; kernel_ulong_t driver_data ; } ;
struct parisc_device_id { __u8 hw_type ; __u8 hversion_rev ; __u16 hversion ; __u32 sversion ; } ;
struct sdio_device_id { __u8 class_ ; __u16 vendor ; __u16 device ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;
struct ssb_device_id { __u16 vendor ; __u16 coreid ; __u8 revision ; } ;
struct bcma_device_id { __u16 manuf ; __u16 id ; __u8 rev ; __u8 class_ ; } ;
struct virtio_device_id { __u32 device ; __u32 vendor ; } ;
struct hv_vmbus_device_id { __u8 guid [ 16 ] ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;
struct i2c_device_id { char name [ 20 ] ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;
struct spi_device_id { char name [ 32 ] ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;
struct dmi_system_id { int ( * callback ) ( const struct dmi_system_id * ) ; const char * ident ; struct dmi_strmatch matches [ 4 ] ; void * driver_data ; } ;
struct platform_device_id { char name [ 20 ] ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;
struct mdio_device_id { __u32 phy_id ; __u32 phy_id_mask ; } ;
struct zorro_device_id { __u32 id ; kernel_ulong_t driver_data ; } ;
struct isapnp_device_id { unsigned short card_vendor , card_device ; unsigned short vendor , function ; kernel_ulong_t driver_data ; } ;
struct x86_cpu_id { __u16 vendor ; __u16 family ; __u16 model ; __u16 feature ; kernel_ulong_t driver_data ; } ;
struct ipack_device_id { __u8 format ; __u32 vendor ; __u32 device ; } ;
enum pci_channel_state { pci_channel_io_normal = ( pci_channel_state_t ) 1 , pci_channel_io_frozen = ( pci_channel_state_t ) 2 , pci_channel_io_perm_failure = ( pci_channel_state_t ) 3 , } ;
enum pcie_reset_state { pcie_deassert_reset = ( pcie_reset_state_t ) 1 , pcie_warm_reset = ( pcie_reset_state_t ) 2 , pcie_hot_reset = ( pcie_reset_state_t ) 3 } ;
enum pci_dev_flags { PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = ( pci_dev_flags_t ) 1 , PCI_DEV_FLAGS_NO_D3 = ( pci_dev_flags_t ) 2 , PCI_DEV_FLAGS_ASSIGNED = ( pci_dev_flags_t ) 4 , } ;
enum pci_bus_flags { PCI_BUS_FLAGS_NO_MSI = ( pci_bus_flags_t ) 1 , PCI_BUS_FLAGS_NO_MMRBC = ( pci_bus_flags_t ) 2 , } ;
struct pci_cap_saved_data { char cap_nr ; unsigned int size ; u32 data [ 0 ] ; } ;
enum pci_ers_result { PCI_ERS_RESULT_NONE = ( pci_ers_result_t ) 1 , PCI_ERS_RESULT_CAN_RECOVER = ( pci_ers_result_t ) 2 , PCI_ERS_RESULT_NEED_RESET = ( pci_ers_result_t ) 3 , PCI_ERS_RESULT_DISCONNECT = ( pci_ers_result_t ) 4 , PCI_ERS_RESULT_RECOVERED = ( pci_ers_result_t ) 5 , PCI_ERS_RESULT_NO_AER_DRIVER = ( pci_ers_result_t ) 6 , } ;
struct msix_entry { u32 vector ; u16 entry ; } ;
typedef u8 uprobe_opcode_t ;
struct arch_uprobe { u16 fixups ; u8 insn [ 16 ] ; unsigned long rip_rela_target_address ; } ;
struct page_frag { struct page * page ; __u32 offset ; __u32 size ; } ;
struct range { u64 start ; u64 end ; } ;
typedef void compound_page_dtor ( struct page * ) ;
typedef void ( sg_free_fn ) ( struct scatterlist * , unsigned int ) ;
struct pci_fixup { u16 vendor ; u16 device ; u32 class_ ; unsigned int class_shift ; void ( * hook ) ( struct pci_dev * dev ) ; } ;
typedef u64 cputime64_t ;
struct ipc_perm { __kernel_key_t key ; __kernel_uid_t uid ; __kernel_gid_t gid ; __kernel_uid_t cuid ; __kernel_gid_t cgid ; __kernel_mode_t mode ; unsigned short seq ; } ;
struct seccomp_data { int nr ; __u32 arch ; __u64 instruction_pointer ; __u64 args [ 6 ] ; } ;
struct rlimit64 { __u64 rlim_cur ; __u64 rlim_max ; } ;
struct task_io_accounting { u64 rchar ; u64 wchar ; u64 syscr ; u64 syscw ; u64 read_bytes ; u64 write_bytes ; u64 cancelled_write_bytes ; } ;
struct io_event { __u64 data ; __u64 obj ; __s64 res ; __s64 res2 ; } ;
struct iocb { __u64 aio_data ; __u32 aio_key , aio_reserved1 ; __u16 aio_lio_opcode ; __s16 aio_reqprio ; __u32 aio_fildes ; __u64 aio_buf ; __u64 aio_nbytes ; __s64 aio_offset ; __u64 aio_reserved2 ; __u32 aio_flags ; __u32 aio_resfd ; } ;
struct iovec { void * iov_base ; __kernel_size_t iov_len ; } ;
struct pacct_struct { int ac_flag ; long ac_exitcode ; unsigned long ac_mem ; cputime_t ac_utime , ac_stime ; unsigned long ac_minflt , ac_majflt ; } ;
struct cpu_itimer { cputime_t expires ; cputime_t incr ; u32 error ; u32 incr_error ; } ;
struct cputime { cputime_t utime ; cputime_t stime ; } ;
struct task_cputime { cputime_t utime ; cputime_t stime ; unsigned long long sum_exec_runtime ; } ;
struct sched_avg { u32 runnable_avg_sum , runnable_avg_period ; u64 last_runnable_update ; s64 decay_count ; unsigned long load_avg_contrib ; } ;
struct sched_statistics { u64 wait_start ; u64 wait_max ; u64 wait_count ; u64 wait_sum ; u64 iowait_count ; u64 iowait_sum ; u64 sleep_start ; u64 sleep_max ; s64 sum_sleep_runtime ; u64 block_start ; u64 block_max ; u64 exec_max ; u64 slice_max ; u64 nr_migrations_cold ; u64 nr_failed_migrations_affine ; u64 nr_failed_migrations_running ; u64 nr_failed_migrations_hot ; u64 nr_forced_migrations ; u64 nr_wakeups ; u64 nr_wakeups_sync ; u64 nr_wakeups_migrate ; u64 nr_wakeups_local ; u64 nr_wakeups_remote ; u64 nr_wakeups_affine ; u64 nr_wakeups_affine_attempts ; u64 nr_wakeups_passive ; u64 nr_wakeups_idle ; } ;
typedef void ( * irq_flow_handler_t ) ( unsigned int irq , struct irq_desc * desc ) ;
typedef void ( * irq_preflow_handler_t ) ( struct irq_data * data ) ;
struct notifier_block ;
struct irq_2_iommu { struct intel_iommu * iommu ; u16 irte_index ; u16 sub_handle ; u8 irte_mask ; } ;
typedef struct { unsigned int __softirq_pending ; unsigned int __nmi_count ; unsigned int apic_timer_irqs ; unsigned int irq_spurious_count ; unsigned int icr_read_retry_count ; unsigned int x86_platform_ipis ; unsigned int apic_perf_irqs ; unsigned int apic_irq_work_irqs ; unsigned int irq_resched_count ; unsigned int irq_call_count ; unsigned int irq_tlb_count ; unsigned int irq_thermal_count ; unsigned int irq_threshold_count ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) irq_cpustat_t ;
typedef irqreturn_t ( * irq_handler_t ) ( int , void * ) ;
struct softirq_action { void ( * action ) ( struct softirq_action * ) ; } ;
struct pm_qos_flags_request { struct list_head node ; s32 flags ; } ;
struct pm_qos_constraints { struct plist_head list ; s32 target_value ; s32 default_value ; enum pm_qos_type type ; struct blocking_notifier_head * notifiers ; } ;
struct pm_qos_flags { struct list_head list ; s32 effective_flags ; } ;
typedef s32 dma_cookie_t ;
typedef struct { unsigned long bits [ ( ( ( DMA_TX_TYPE_END ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } dma_cap_mask_t ;
typedef void ( * dma_async_tx_callback ) ( void * dma_async_param ) ;
struct dma_pinned_list { int nr_iovecs ; struct dma_page_list page_list [ 0 ] ; } ;
struct __kernel_sockaddr_storage { __kernel_sa_family_t ss_family ; char __data [ 128 - sizeof ( unsigned short ) ] ; } __attribute__ ( ( aligned ( ( __alignof__ ( struct sockaddr * ) ) ) ) ) ;
typedef __kernel_sa_family_t sa_family_t ;
struct msghdr { void * msg_name ; int msg_namelen ; struct iovec * msg_iov ; __kernel_size_t msg_iovlen ; void * msg_control ; __kernel_size_t msg_controllen ; unsigned int msg_flags ; } ;
struct cmsghdr { __kernel_size_t cmsg_len ; int cmsg_level ; int cmsg_type ; } ;
struct ucred { __u32 pid ; __u32 uid ; __u32 gid ; } ;
struct timespec ;
typedef struct { unsigned int clock_rate ; unsigned int clock_type ; unsigned short loopback ; } sync_serial_settings ;
typedef struct { unsigned int clock_rate ; unsigned int clock_type ; unsigned short loopback ; unsigned int slot_map ; } te1_settings ;
typedef struct { unsigned short encoding ; unsigned short parity ; } raw_hdlc_proto ;
typedef struct { unsigned int t391 ; unsigned int t392 ; unsigned int n391 ; unsigned int n392 ; unsigned int n393 ; unsigned short lmi ; unsigned short dce ; } fr_proto ;
typedef struct { unsigned int dlci ; } fr_proto_pvc ;
typedef struct { unsigned int dlci ; char master [ 16 ] ; } fr_proto_pvc_info ;
typedef struct { unsigned int interval ; unsigned int timeout ; } cisco_proto ;
struct ifconf { int ifc_len ; union { char * ifcu_buf ; struct ifreq * ifcu_req ; } ifc_ifcu ; } ;
struct user_i387_ia32_struct { u32 cwd ; u32 swd ; u32 twd ; u32 fip ; u32 fcs ; u32 foo ; u32 fos ; u32 st_space [ 20 ] ; } ;
struct user_regs_struct32 { __u32 ebx , ecx , edx , esi , edi , ebp , eax ; unsigned short ds , __ds , es , __es ; unsigned short fs , __fs , gs , __gs ; __u32 orig_eax , eip ; unsigned short cs , __cs ; __u32 eflags , esp ; unsigned short ss , __ss ; } ;
typedef u32 compat_size_t ;
typedef s32 compat_ssize_t ;
typedef s32 compat_time_t ;
typedef s32 compat_clock_t ;
typedef s32 compat_pid_t ;
typedef u16 __compat_uid_t ;
typedef u16 __compat_gid_t ;
typedef u32 __compat_uid32_t ;
typedef u32 __compat_gid32_t ;
typedef u16 compat_mode_t ;
typedef u32 compat_ino_t ;
typedef u16 compat_dev_t ;
typedef s32 compat_off_t ;
typedef s64 compat_loff_t ;
typedef u16 compat_nlink_t ;
typedef u16 compat_ipc_pid_t ;
typedef s32 compat_daddr_t ;
typedef u32 compat_caddr_t ;
typedef s32 compat_timer_t ;
typedef s32 compat_key_t ;
typedef s32 compat_int_t ;
typedef s32 compat_long_t ;
typedef s64 __attribute__ ( ( aligned ( 4 ) ) ) compat_s64 ;
typedef u32 compat_uint_t ;
typedef u32 compat_ulong_t ;
typedef u64 __attribute__ ( ( aligned ( 4 ) ) ) compat_u64 ;
typedef u32 compat_uptr_t ;
typedef u32 compat_old_sigset_t ;
typedef u32 compat_sigset_word ;
struct rand_pool_info { int entropy_count ; int buf_size ; __u32 buf [ 0 ] ; } ;
struct rnd_state { __u32 s1 , s2 , s3 ; } ;
struct msghdr ;
struct net_proto_family { int family ; int ( * create ) ( struct net * net , struct socket * sock , int protocol , int kern ) ; struct module * owner ; } ;
struct iovec ;
typedef u64 netdev_features_t ;
struct skb_frag_struct { struct { struct page * p ; } page ; __u32 page_offset ; __u32 size ; } ;
struct skb_seq_state { __u32 lower_offset ; __u32 upper_offset ; __u32 frag_idx ; __u32 stepped_offset ; struct sk_buff * root_skb ; struct sk_buff * cur_skb ; __u8 * frag_data ; } ;
struct ethtool_cmd { __u32 cmd ; __u32 supported ; __u32 advertising ; __u16 speed ; __u8 duplex ; __u8 port ; __u8 phy_address ; __u8 transceiver ; __u8 autoneg ; __u8 mdio_support ; __u32 maxtxpkt ; __u32 maxrxpkt ; __u16 speed_hi ; __u8 eth_tp_mdix ; __u8 eth_tp_mdix_ctrl ; __u32 lp_advertising ; __u32 reserved [ 2 ] ; } ;
struct ethtool_drvinfo { __u32 cmd ; char driver [ 32 ] ; char version [ 32 ] ; char fw_version [ 32 ] ; char bus_info [ 32 ] ; char reserved1 [ 32 ] ; char reserved2 [ 12 ] ; __u32 n_priv_flags ; __u32 n_stats ; __u32 testinfo_len ; __u32 eedump_len ; __u32 regdump_len ; } ;
struct ethtool_wolinfo { __u32 cmd ; __u32 supported ; __u32 wolopts ; __u8 sopass [ 6 ] ; } ;
struct ethtool_value { __u32 cmd ; __u32 data ; } ;
struct ethtool_regs { __u32 cmd ; __u32 version ; __u32 len ; __u8 data [ 0 ] ; } ;
struct ethtool_eeprom { __u32 cmd ; __u32 magic ; __u32 offset ; __u32 len ; __u8 data [ 0 ] ; } ;
struct ethtool_eee { __u32 cmd ; __u32 supported ; __u32 advertised ; __u32 lp_advertised ; __u32 eee_active ; __u32 eee_enabled ; __u32 tx_lpi_enabled ; __u32 tx_lpi_timer ; __u32 reserved [ 2 ] ; } ;
struct ethtool_modinfo { __u32 cmd ; __u32 type ; __u32 eeprom_len ; __u32 reserved [ 8 ] ; } ;
struct ethtool_coalesce { __u32 cmd ; __u32 rx_coalesce_usecs ; __u32 rx_max_coalesced_frames ; __u32 rx_coalesce_usecs_irq ; __u32 rx_max_coalesced_frames_irq ; __u32 tx_coalesce_usecs ; __u32 tx_max_coalesced_frames ; __u32 tx_coalesce_usecs_irq ; __u32 tx_max_coalesced_frames_irq ; __u32 stats_block_coalesce_usecs ; __u32 use_adaptive_rx_coalesce ; __u32 use_adaptive_tx_coalesce ; __u32 pkt_rate_low ; __u32 rx_coalesce_usecs_low ; __u32 rx_max_coalesced_frames_low ; __u32 tx_coalesce_usecs_low ; __u32 tx_max_coalesced_frames_low ; __u32 pkt_rate_high ; __u32 rx_coalesce_usecs_high ; __u32 rx_max_coalesced_frames_high ; __u32 tx_coalesce_usecs_high ; __u32 tx_max_coalesced_frames_high ; __u32 rate_sample_interval ; } ;
struct ethtool_ringparam { __u32 cmd ; __u32 rx_max_pending ; __u32 rx_mini_max_pending ; __u32 rx_jumbo_max_pending ; __u32 tx_max_pending ; __u32 rx_pending ; __u32 rx_mini_pending ; __u32 rx_jumbo_pending ; __u32 tx_pending ; } ;
struct ethtool_channels { __u32 cmd ; __u32 max_rx ; __u32 max_tx ; __u32 max_other ; __u32 max_combined ; __u32 rx_count ; __u32 tx_count ; __u32 other_count ; __u32 combined_count ; } ;
struct ethtool_pauseparam { __u32 cmd ; __u32 autoneg ; __u32 rx_pause ; __u32 tx_pause ; } ;
struct ethtool_gstrings { __u32 cmd ; __u32 string_set ; __u32 len ; __u8 data [ 0 ] ; } ;
struct ethtool_sset_info { __u32 cmd ; __u32 reserved ; __u64 sset_mask ; __u32 data [ 0 ] ; } ;
struct ethtool_test { __u32 cmd ; __u32 flags ; __u32 reserved ; __u32 len ; __u64 data [ 0 ] ; } ;
struct ethtool_stats { __u32 cmd ; __u32 n_stats ; __u64 data [ 0 ] ; } ;
struct ethtool_perm_addr { __u32 cmd ; __u32 size ; __u8 data [ 0 ] ; } ;
struct ethtool_rxfh_indir { __u32 cmd ; __u32 size ; __u32 ring_index [ 0 ] ; } ;
struct ethtool_flash { __u32 cmd ; __u32 region ; char data [ 128 ] ; } ;
struct ethtool_dump { __u32 cmd ; __u32 version ; __u32 flag ; __u32 len ; __u8 data [ 0 ] ; } ;
struct ethtool_get_features_block { __u32 available ; __u32 requested ; __u32 active ; __u32 never_changed ; } ;
struct ethtool_set_features_block { __u32 valid ; __u32 requested ; } ;
struct ethtool_ts_info { __u32 cmd ; __u32 so_timestamping ; __s32 phc_index ; __u32 tx_types ; __u32 tx_reserved [ 3 ] ; __u32 rx_filters ; __u32 rx_reserved [ 3 ] ; } ;
struct ipstats_mib { u64 mibs [ __IPSTATS_MIB_MAX ] ; struct u64_stats_sync syncp ; } ;
struct flowi_common { int flowic_oif ; int flowic_iif ; __u32 flowic_mark ; __u8 flowic_tos ; __u8 flowic_scope ; __u8 flowic_proto ; __u8 flowic_flags ; __u32 flowic_secid ; } ;
struct flow_cache_ops ;
struct flow_cache_ops { struct flow_cache_object * ( * get ) ( struct flow_cache_object * ) ; int ( * check ) ( struct flow_cache_object * ) ; void ( * delete_ ) ( struct flow_cache_object * ) ; } ;
struct nlattr ;
struct nf_ct_tcp_flags { __u8 flags ; __u8 mask ; } ;
struct nf_generic_net { struct nf_proto_net pn ; unsigned int timeout ; } ;
struct nf_tcp_net { struct nf_proto_net pn ; unsigned int timeouts [ TCP_CONNTRACK_TIMEOUT_MAX ] ; unsigned int tcp_loose ; unsigned int tcp_be_liberal ; unsigned int tcp_max_retrans ; } ;
struct nf_udp_net { struct nf_proto_net pn ; unsigned int timeouts [ UDP_CT_MAX ] ; } ;
struct nf_icmp_net { struct nf_proto_net pn ; unsigned int timeout ; } ;
struct xfrm_sec_ctx { __u8 ctx_doi ; __u8 ctx_alg ; __u16 ctx_len ; __u32 ctx_sid ; char ctx_str [ 0 ] ; } ;
struct xfrm_lifetime_cfg { __u64 soft_byte_limit ; __u64 hard_byte_limit ; __u64 soft_packet_limit ; __u64 hard_packet_limit ; __u64 soft_add_expires_seconds ; __u64 hard_add_expires_seconds ; __u64 soft_use_expires_seconds ; __u64 hard_use_expires_seconds ; } ;
struct xfrm_lifetime_cur { __u64 bytes ; __u64 packets ; __u64 add_time ; __u64 use_time ; } ;
struct xfrm_replay_state { __u32 oseq ; __u32 seq ; __u32 bitmap ; } ;
struct xfrm_replay_state_esn { unsigned int bmp_len ; __u32 oseq ; __u32 seq ; __u32 oseq_hi ; __u32 seq_hi ; __u32 replay_window ; __u32 bmp [ 0 ] ; } ;
struct xfrm_stats { __u32 replay_window ; __u32 replay ; __u32 integrity_failed ; } ;
struct xfrm_user_sec_ctx { __u16 len ; __u16 exttype ; __u8 ctx_alg ; __u8 ctx_doi ; __u16 ctx_len ; } ;
struct xfrm_userpolicy_type { __u8 type ; __u16 reserved1 ; __u8 reserved2 ; } ;
struct xfrm_mark { __u32 v ; __u32 m ; } ;
struct xfrmu_sadhinfo { __u32 sadhcnt ; __u32 sadhmcnt ; } ;
struct xfrmu_spdinfo { __u32 incnt ; __u32 outcnt ; __u32 fwdcnt ; __u32 inscnt ; __u32 outscnt ; __u32 fwdscnt ; } ;
struct xfrmu_spdhinfo { __u32 spdhcnt ; __u32 spdhmcnt ; } ;
struct xfrm_usersa_flush { __u8 proto ; } ;
struct dsa_chip_data { struct device * mii_bus ; int sw_addr ; char * port_names [ 12 ] ; s8 * rtable ; } ;
struct dsa_switch { struct dsa_switch_tree * dst ; int index ; struct dsa_chip_data * pd ; struct dsa_switch_driver * drv ; struct mii_bus * master_mii_bus ; u32 dsa_port_mask ; u32 phys_port_mask ; struct mii_bus * slave_mii_bus ; struct net_device * ports [ 12 ] ; } ;
struct ieee_ets { __u8 willing ; __u8 ets_cap ; __u8 cbs ; __u8 tc_tx_bw [ 8 ] ; __u8 tc_rx_bw [ 8 ] ; __u8 tc_tsa [ 8 ] ; __u8 prio_tc [ 8 ] ; __u8 tc_reco_bw [ 8 ] ; __u8 tc_reco_tsa [ 8 ] ; __u8 reco_prio_tc [ 8 ] ; } ;
struct ieee_pfc { __u8 pfc_cap ; __u8 pfc_en ; __u8 mbc ; __u16 delay ; __u64 requests [ 8 ] ; __u64 indications [ 8 ] ; } ;
struct cee_pg { __u8 willing ; __u8 error ; __u8 pg_en ; __u8 tcs_supported ; __u8 pg_bw [ 8 ] ; __u8 prio_pg [ 8 ] ; } ;
struct cee_pfc { __u8 willing ; __u8 error ; __u8 pfc_en ; __u8 tcs_supported ; } ;
struct dcb_app { __u8 selector ; __u8 priority ; __u16 protocol ; } ;
struct dcb_peer_app_info { __u8 willing ; __u8 error ; } ;
struct dcbmsg { __u8 dcb_family ; __u8 cmd ; __u16 dcb_pad ; } ;
struct taskstats { __u16 version ; __u32 ac_exitcode ; __u8 ac_flag ; __u8 ac_nice ; __u64 cpu_count __attribute__ ( ( aligned ( 8 ) ) ) ; __u64 cpu_delay_total ; __u64 blkio_count ; __u64 blkio_delay_total ; __u64 swapin_count ; __u64 swapin_delay_total ; __u64 cpu_run_real_total ; __u64 cpu_run_virtual_total ; char ac_comm [ 32 ] ; __u8 ac_sched __attribute__ ( ( aligned ( 8 ) ) ) ; __u8 ac_pad [ 3 ] ; __u32 ac_uid __attribute__ ( ( aligned ( 8 ) ) ) ; __u32 ac_gid ; __u32 ac_pid ; __u32 ac_ppid ; __u32 ac_btime ; __u64 ac_etime __attribute__ ( ( aligned ( 8 ) ) ) ; __u64 ac_utime ; __u64 ac_stime ; __u64 ac_minflt ; __u64 ac_majflt ; __u64 coremem ; __u64 virtmem ; __u64 hiwater_rss ; __u64 hiwater_vm ; __u64 read_char ; __u64 write_char ; __u64 read_syscalls ; __u64 write_syscalls ; __u64 read_bytes ; __u64 write_bytes ; __u64 cancelled_write_bytes ; __u64 nvcsw ; __u64 nivcsw ; __u64 ac_utimescaled ; __u64 ac_stimescaled ; __u64 cpu_scaled_run_real_total ; __u64 freepages_count ; __u64 freepages_delay_total ; } ;
struct cgroupstats { __u64 nr_sleeping ; __u64 nr_running ; __u64 nr_stopped ; __u64 nr_uninterruptible ; __u64 nr_io_wait ; } ;
struct ptr_heap { void * * ptrs ; int max ; int size ; int ( * gt ) ( void * , void * ) ; } ;
struct cgroup_scanner { struct cgroup * cg ; int ( * test_task ) ( struct task_struct * p , struct cgroup_scanner * scan ) ; void ( * process_task ) ( struct task_struct * p , struct cgroup_scanner * scan ) ; struct ptr_heap * heap ; void * data ; } ;
struct xfrm_sec_ctx ;
struct msghdr ;
struct xfrm_user_sec_ctx ;
struct request_sock ;
typedef int ( * initxattrs ) ( struct inode * inode , const struct xattr * xattr_array , void * fs_data ) ;
struct sockaddr_nl { __kernel_sa_family_t nl_family ; unsigned short nl_pad ; __u32 nl_pid ; __u32 nl_groups ; } ;
struct nlmsghdr { __u32 nlmsg_len ; __u16 nlmsg_type ; __u16 nlmsg_flags ; __u32 nlmsg_seq ; __u32 nlmsg_pid ; } ;
struct nl_pktinfo { __u32 group ; } ;
struct nlattr { __u16 nla_len ; __u16 nla_type ; } ;
struct netlink_kernel_cfg { unsigned int groups ; unsigned int flags ; void ( * input ) ( struct sk_buff * skb ) ; struct mutex * cb_mutex ; void ( * bind ) ( int group ) ; } ;
struct netlink_callback { struct sk_buff * skb ; const struct nlmsghdr * nlh ; int ( * dump ) ( struct sk_buff * skb , struct netlink_callback * cb ) ; int ( * done ) ( struct netlink_callback * cb ) ; void * data ; struct module * module ; u16 family ; u16 min_dump_alloc ; unsigned int prev_seq , seq ; long args [ 6 ] ; } ;
struct netlink_dump_control { int ( * dump ) ( struct sk_buff * skb , struct netlink_callback * ) ; int ( * done ) ( struct netlink_callback * ) ; void * data ; struct module * module ; u16 min_dump_alloc ; } ;
struct ndmsg { __u8 ndm_family ; __u8 ndm_pad1 ; __u16 ndm_pad2 ; __s32 ndm_ifindex ; __u16 ndm_state ; __u8 ndm_flags ; __u8 ndm_type ; } ;
struct nda_cacheinfo { __u32 ndm_confirmed ; __u32 ndm_used ; __u32 ndm_updated ; __u32 ndm_refcnt ; } ;
struct ndt_stats { __u64 ndts_allocs ; __u64 ndts_destroys ; __u64 ndts_hash_grows ; __u64 ndts_res_failed ; __u64 ndts_lookups ; __u64 ndts_hits ; __u64 ndts_rcv_probes_mcast ; __u64 ndts_rcv_probes_ucast ; __u64 ndts_periodic_gc_runs ; __u64 ndts_forced_gc_runs ; } ;
struct ndtmsg { __u8 ndtm_family ; __u8 ndtm_pad1 ; __u16 ndtm_pad2 ; } ;
struct ndt_config { __u16 ndtc_key_len ; __u16 ndtc_entry_size ; __u32 ndtc_entries ; __u32 ndtc_last_flush ; __u32 ndtc_last_rand ; __u32 ndtc_hash_rnd ; __u32 ndtc_hash_mask ; __u32 ndtc_hash_chain_gc ; __u32 ndtc_proxy_qlen ; } ;
union tpacket_stats_u { struct tpacket_stats stats1 ; struct tpacket_stats_v3 stats3 ; } ;
struct tpacket_auxdata { __u32 tp_status ; __u32 tp_len ; __u32 tp_snaplen ; __u16 tp_mac ; __u16 tp_net ; __u16 tp_vlan_tci ; __u16 tp_padding ; } ;
struct tpacket2_hdr { __u32 tp_status ; __u32 tp_len ; __u32 tp_snaplen ; __u16 tp_mac ; __u16 tp_net ; __u32 tp_sec ; __u32 tp_nsec ; __u16 tp_vlan_tci ; __u16 tp_padding ; } ;
struct tpacket_hdr_variant1 { __u32 tp_rxhash ; __u32 tp_vlan_tci ; } ;
struct tpacket_bd_ts { unsigned int ts_sec ; union { unsigned int ts_usec ; unsigned int ts_nsec ; } ; } ;
union tpacket_req_u { struct tpacket_req req ; struct tpacket_req3 req3 ; } ;
struct rtnl_link_stats { __u32 rx_packets ; __u32 tx_packets ; __u32 rx_bytes ; __u32 tx_bytes ; __u32 rx_errors ; __u32 tx_errors ; __u32 rx_dropped ; __u32 tx_dropped ; __u32 multicast ; __u32 collisions ; __u32 rx_length_errors ; __u32 rx_over_errors ; __u32 rx_crc_errors ; __u32 rx_frame_errors ; __u32 rx_fifo_errors ; __u32 rx_missed_errors ; __u32 tx_aborted_errors ; __u32 tx_carrier_errors ; __u32 tx_fifo_errors ; __u32 tx_heartbeat_errors ; __u32 tx_window_errors ; __u32 rx_compressed ; __u32 tx_compressed ; } ;
struct rtnl_link_stats64 { __u64 rx_packets ; __u64 tx_packets ; __u64 rx_bytes ; __u64 tx_bytes ; __u64 rx_errors ; __u64 tx_errors ; __u64 rx_dropped ; __u64 tx_dropped ; __u64 multicast ; __u64 collisions ; __u64 rx_length_errors ; __u64 rx_over_errors ; __u64 rx_crc_errors ; __u64 rx_frame_errors ; __u64 rx_fifo_errors ; __u64 rx_missed_errors ; __u64 tx_aborted_errors ; __u64 tx_carrier_errors ; __u64 tx_fifo_errors ; __u64 tx_heartbeat_errors ; __u64 tx_window_errors ; __u64 rx_compressed ; __u64 tx_compressed ; } ;
struct rtnl_link_ifmap { __u64 mem_start ; __u64 mem_end ; __u64 base_addr ; __u16 irq ; __u8 dma ; __u8 port ; } ;
struct ifla_cacheinfo { __u32 max_reasm_len ; __u32 tstamp ; __u32 reachable_time ; __u32 retrans_time ; } ;
struct ifla_vlan_flags { __u32 flags ; __u32 mask ; } ;
struct ifla_vlan_qos_mapping { __u32 from ; __u32 to ; } ;
struct ifla_vf_mac { __u32 vf ; __u8 mac [ 32 ] ; } ;
struct ifla_vf_vlan { __u32 vf ; __u32 vlan ; __u32 qos ; } ;
struct ifla_vf_tx_rate { __u32 vf ; __u32 rate ; } ;
struct ifla_vf_spoofchk { __u32 vf ; __u32 setting ; } ;
struct ifla_port_vsi { __u8 vsi_mgr_id ; __u8 vsi_type_id [ 3 ] ; __u8 vsi_type_version ; __u8 pad [ 3 ] ; } ;
struct ifla_vf_info { __u32 vf ; __u8 mac [ 32 ] ; __u32 vlan ; __u32 qos ; __u32 tx_rate ; __u32 spoofchk ; } ;
struct netdev_boot_setup { char name [ 16 ] ; struct ifmap map ; } ;
typedef rx_handler_result_t rx_handler_func_t ( struct sk_buff * * pskb ) ;
struct rps_dev_flow { u16 cpu ; u16 filter ; unsigned int last_qtail ; } ;
struct rps_sock_flow_table { unsigned int mask ; u16 ents [ 0 ] ; } ;
struct netdev_tc_txq { u16 count ; u16 offset ; } ;
struct napi_gro_cb { void * frag0 ; unsigned int frag0_len ; int data_offset ; int flush ; u16 count ; u8 same_flow ; u8 free ; unsigned long age ; int proto ; struct sk_buff * last ; } ;
typedef int gifconf_func_t ( struct net_device * dev , char * bufptr , int len ) ;
struct mii_ioctl_data { __u16 phy_id ; __u16 reg_num ; __u16 val_in ; __u16 val_out ; } ;
struct ethtool_cmd ;
struct mii_if_info { int phy_id ; int advertising ; int phy_id_mask ; int reg_num_mask ; unsigned int full_duplex : 1 ; unsigned int force_media : 1 ; unsigned int supports_gmii : 1 ; struct net_device * dev ; int ( * mdio_read ) ( struct net_device * dev , int phy_id , int location ) ; void ( * mdio_write ) ( struct net_device * dev , int phy_id , int location , int val ) ; } ;
struct ifaddrmsg { __u8 ifa_family ; __u8 ifa_prefixlen ; __u8 ifa_flags ; __u8 ifa_scope ; __u32 ifa_index ; } ;
struct ifa_cacheinfo { __u32 ifa_prefered ; __u32 ifa_valid ; __u32 cstamp ; __u32 tstamp ; } ;
struct rta_cacheinfo { __u32 rta_clntref ; __u32 rta_lastuse ; __s32 rta_expires ; __u32 rta_error ; __u32 rta_used ; __u32 rta_id ; __u32 rta_ts ; __u32 rta_tsage ; } ;
struct rta_mfc_stats { __u64 mfcs_packets ; __u64 mfcs_bytes ; __u64 mfcs_wrong_if ; } ;
struct prefix_cacheinfo { __u32 preferred_time ; __u32 valid_time ; } ;
struct tcmsg { unsigned char tcm_family ; unsigned char tcm__pad1 ; unsigned short tcm__pad2 ; int tcm_ifindex ; __u32 tcm_handle ; __u32 tcm_parent ; __u32 tcm_info ; } ;
struct nduseroptmsg { unsigned char nduseropt_family ; unsigned char nduseropt_pad1 ; unsigned short nduseropt_opts_len ; int nduseropt_ifindex ; __u8 nduseropt_icmp_type ; __u8 nduseropt_icmp_code ; unsigned short nduseropt_pad2 ; unsigned int nduseropt_pad3 ; } ;
struct vlan_ioctl_args { int cmd ; char device1 [ 24 ] ; union { char device2 [ 24 ] ; int VID ; unsigned int skb_priority ; unsigned int name_type ; unsigned int bind_type ; unsigned int flag ; } u ; short vlan_qos ; } ;
typedef int filler_t ( void * , struct page * ) ;
struct ip_beet_phdr { __u8 nexthdr ; __u8 hdrlen ; __u8 padlen ; __u8 reserved ; } ;
struct ipv6_rt_hdr { __u8 nexthdr ; __u8 hdrlen ; __u8 type ; __u8 segments_left ; } ;
struct ipv6_opt_hdr { __u8 nexthdr ; __u8 hdrlen ; } __attribute__ ( ( packed ) ) ;
struct ipv6_devconf { __s32 forwarding ; __s32 hop_limit ; __s32 mtu6 ; __s32 accept_ra ; __s32 accept_redirects ; __s32 autoconf ; __s32 dad_transmits ; __s32 rtr_solicits ; __s32 rtr_solicit_interval ; __s32 rtr_solicit_delay ; __s32 force_mld_version ; __s32 use_tempaddr ; __s32 temp_valid_lft ; __s32 temp_prefered_lft ; __s32 regen_max_retry ; __s32 max_desync_factor ; __s32 max_addresses ; __s32 accept_ra_defrtr ; __s32 accept_ra_pinfo ; __s32 accept_ra_rtr_pref ; __s32 rtr_probe_interval ; __s32 accept_ra_rt_info_max_plen ; __s32 proxy_ndp ; __s32 accept_source_route ; __s32 mc_forwarding ; __s32 disable_ipv6 ; __s32 accept_dad ; __s32 force_tllao ; __s32 ndisc_notify ; void * sysctl ; } ;
struct ipv6_params { __s32 disable_ipv6 ; __s32 autoconf ; } ;
struct icmp6_filter { __u32 data [ 8 ] ; } ;
struct sock_filter { __u16 code ; __u8 jt ; __u8 jf ; __u32 k ; } ;
typedef void ( * poll_queue_proc ) ( struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
typedef struct { unsigned long * in , * out , * ex ; unsigned long * res_in , * res_out , * res_ex ; } fd_set_bits ;
struct nla_policy { u16 type ; u16 len ; } ;
struct nl_info { struct nlmsghdr * nlh ; struct net * nl_net ; u32 portid ; } ;
typedef int ( * rtnl_doit_func ) ( struct sk_buff * , struct nlmsghdr * , void * ) ;
typedef int ( * rtnl_dumpit_func ) ( struct sk_buff * , struct netlink_callback * ) ;
struct neigh_ops { int family ; void ( * solicit ) ( struct neighbour * , struct sk_buff * ) ; void ( * error_report ) ( struct neighbour * , struct sk_buff * ) ; int ( * output ) ( struct neighbour * , struct sk_buff * ) ; int ( * connected_output ) ( struct neighbour * , struct sk_buff * ) ; } ;
struct pneigh_entry { struct pneigh_entry * next ; struct net * net ; struct net_device * dev ; u8 flags ; u8 key [ 0 ] ; } ;
typedef __u32 __portpair ;
typedef __u64 __addrpair ;
struct cg_proto ;
struct request_sock_ops ;
struct timewait_sock_ops ;
struct cg_proto { void ( * enter_memory_pressure ) ( struct sock * sk ) ; struct res_counter * memory_allocated ; struct percpu_counter * sockets_allocated ; int * memory_pressure ; long * sysctl_mem ; unsigned long flags ; struct mem_cgroup * memcg ; } ;
struct __una_u16 { u16 x ; } __attribute__ ( ( packed ) ) ;
struct __una_u32 { u32 x ; } __attribute__ ( ( packed ) ) ;
struct __una_u64 { u64 x ; } __attribute__ ( ( packed ) ) ;
struct request_sock ;
struct request_sock_ops { int family ; int obj_size ; struct kmem_cache * slab ; char * slab_name ; int ( * rtx_syn_ack ) ( struct sock * sk , struct request_sock * req , struct request_values * rvp ) ; void ( * send_ack ) ( struct sock * sk , struct sk_buff * skb , struct request_sock * req ) ; void ( * send_reset ) ( struct sock * sk , struct sk_buff * skb ) ; void ( * destructor ) ( struct request_sock * req ) ; void ( * syn_ack_timeout ) ( struct sock * sk , struct request_sock * req ) ; } ;
struct request_sock { struct request_sock * dl_next ; u16 mss ; u8 num_retrans ; u8 cookie_ts : 1 ; u8 num_timeout : 7 ; u32 window_clamp ; u32 rcv_wnd ; u32 ts_recent ; unsigned long expires ; const struct request_sock_ops * rsk_ops ; struct sock * sk ; u32 secid ; u32 peer_secid ; } ;
struct listen_sock { u8 max_qlen_log ; u8 synflood_warned ; int qlen ; int qlen_young ; int clock_hand ; u32 hash_rnd ; u32 nr_table_entries ; struct request_sock * syn_table [ 0 ] ; } ;
struct timewait_sock_ops { struct kmem_cache * twsk_slab ; char * twsk_slab_name ; unsigned int twsk_obj_size ; int ( * twsk_unique ) ( struct sock * sk , struct sock * sktw , void * twp ) ; void ( * twsk_destructor ) ( struct sock * sk ) ; } ;
struct tcp_repair_opt { __u32 opt_code ; __u32 opt_val ; } ;
struct tcp_info { __u8 tcpi_state ; __u8 tcpi_ca_state ; __u8 tcpi_retransmits ; __u8 tcpi_probes ; __u8 tcpi_backoff ; __u8 tcpi_options ; __u8 tcpi_snd_wscale : 4 , tcpi_rcv_wscale : 4 ; __u32 tcpi_rto ; __u32 tcpi_ato ; __u32 tcpi_snd_mss ; __u32 tcpi_rcv_mss ; __u32 tcpi_unacked ; __u32 tcpi_sacked ; __u32 tcpi_lost ; __u32 tcpi_retrans ; __u32 tcpi_fackets ; __u32 tcpi_last_data_sent ; __u32 tcpi_last_ack_sent ; __u32 tcpi_last_data_recv ; __u32 tcpi_last_ack_recv ; __u32 tcpi_pmtu ; __u32 tcpi_rcv_ssthresh ; __u32 tcpi_rtt ; __u32 tcpi_rttvar ; __u32 tcpi_snd_ssthresh ; __u32 tcpi_snd_cwnd ; __u32 tcpi_advmss ; __u32 tcpi_reordering ; __u32 tcpi_rcv_rtt ; __u32 tcpi_rcv_space ; __u32 tcpi_total_retrans ; } ;
struct tcp_cookie_transactions { __u16 tcpct_flags ; __u8 __tcpct_pad1 ; __u8 tcpct_cookie_desired ; __u16 tcpct_s_data_desired ; __u16 tcpct_used ; __u8 tcpct_value [ 536U ] ; } ;
struct tcp_fastopen_cookie { s8 len ; u8 val [ 16 ] ; } ;
struct tcp_sack_block { u32 start_seq ; u32 end_seq ; } ;
struct tcp_options_received { long ts_recent_stamp ; u32 ts_recent ; u32 rcv_tsval ; u32 rcv_tsecr ; u16 saw_tstamp : 1 , tstamp_ok : 1 , dsack : 1 , wscale_ok : 1 , sack_ok : 4 , snd_wscale : 4 , rcv_wscale : 4 ; u8 cookie_plus : 6 , cookie_out_never : 1 , cookie_in_always : 1 ; u8 num_sacks ; u16 user_mss ; u16 mss_clamp ; } ;
struct inet6_skb_parm { int iif ; __u16 ra ; __u16 hop ; __u16 dst0 ; __u16 srcrt ; __u16 dst1 ; __u16 lastopt ; __u16 nhoff ; __u16 flags ; __u16 dsthao ; __u16 frag_max_size ; } ;
struct tc_stats { __u64 bytes ; __u32 packets ; __u32 drops ; __u32 overlimits ; __u32 bps ; __u32 pps ; __u32 qlen ; __u32 backlog ; } ;
struct tc_ratespec { unsigned char cell_log ; unsigned char __reserved ; unsigned short overhead ; short cell_align ; unsigned short mpu ; __u32 rate ; } ;
struct tc_fifo_qopt { __u32 limit ; } ;
struct tc_prio_qopt { int bands ; __u8 priomap [ 15 + 1 ] ; } ;
struct tc_multiq_qopt { __u16 bands ; __u16 max_bands ; } ;
struct tc_sfq_qopt { unsigned quantum ; int perturb_period ; __u32 limit ; unsigned divisor ; unsigned flows ; } ;
struct tc_sfq_xstats { __s32 allot ; } ;
struct tc_red_qopt { __u32 limit ; __u32 qth_min ; __u32 qth_max ; unsigned char Wlog ; unsigned char Plog ; unsigned char Scell_log ; unsigned char flags ; } ;
struct tc_red_xstats { __u32 early ; __u32 pdrop ; __u32 other ; __u32 marked ; } ;
struct tc_gred_qopt { __u32 limit ; __u32 qth_min ; __u32 qth_max ; __u32 DP ; __u32 backlog ; __u32 qave ; __u32 forced ; __u32 early ; __u32 other ; __u32 pdrop ; __u8 Wlog ; __u8 Plog ; __u8 Scell_log ; __u8 prio ; __u32 packets ; __u32 bytesin ; } ;
struct tc_gred_sopt { __u32 DPs ; __u32 def_DP ; __u8 grio ; __u8 flags ; __u16 pad1 ; } ;
struct tc_choke_qopt { __u32 limit ; __u32 qth_min ; __u32 qth_max ; unsigned char Wlog ; unsigned char Plog ; unsigned char Scell_log ; unsigned char flags ; } ;
struct tc_choke_xstats { __u32 early ; __u32 pdrop ; __u32 other ; __u32 marked ; __u32 matched ; } ;
struct tc_htb_glob { __u32 version ; __u32 rate2quantum ; __u32 defcls ; __u32 debug ; __u32 direct_pkts ; } ;
struct tc_htb_xstats { __u32 lends ; __u32 borrows ; __u32 giants ; __u32 tokens ; __u32 ctokens ; } ;
struct tc_hfsc_qopt { __u16 defcls ; } ;
struct tc_service_curve { __u32 m1 ; __u32 d ; __u32 m2 ; } ;
struct tc_hfsc_stats { __u64 work ; __u64 rtwork ; __u32 period ; __u32 level ; } ;
struct tc_cbq_lssopt { unsigned char change ; unsigned char flags ; unsigned char ewma_log ; unsigned char level ; __u32 maxidle ; __u32 minidle ; __u32 offtime ; __u32 avpkt ; } ;
struct tc_cbq_wrropt { unsigned char flags ; unsigned char priority ; unsigned char cpriority ; unsigned char __reserved ; __u32 allot ; __u32 weight ; } ;
struct tc_cbq_ovl { unsigned char strategy ; unsigned char priority2 ; __u16 pad ; __u32 penalty ; } ;
struct tc_cbq_fopt { __u32 split ; __u32 defmap ; __u32 defchange ; } ;
struct tc_cbq_xstats { __u32 borrows ; __u32 overactions ; __s32 avgidle ; __s32 undertime ; } ;
struct tc_netem_qopt { __u32 latency ; __u32 limit ; __u32 loss ; __u32 gap ; __u32 duplicate ; __u32 jitter ; } ;
struct tc_netem_corr { __u32 delay_corr ; __u32 loss_corr ; __u32 dup_corr ; } ;
struct tc_netem_reorder { __u32 probability ; __u32 correlation ; } ;
struct tc_netem_corrupt { __u32 probability ; __u32 correlation ; } ;
struct tc_netem_gimodel { __u32 p13 ; __u32 p31 ; __u32 p32 ; __u32 p14 ; __u32 p23 ; } ;
struct tc_netem_gemodel { __u32 p ; __u32 r ; __u32 h ; __u32 k1 ; } ;
struct tc_drr_stats { __u32 deficit ; } ;
struct tc_mqprio_qopt { __u8 num_tc ; __u8 prio_tc_map [ 15 + 1 ] ; __u8 hw ; __u16 count [ 16 ] ; __u16 offset [ 16 ] ; } ;
struct tc_sfb_qopt { __u32 rehash_interval ; __u32 warmup_time ; __u32 max ; __u32 bin_size ; __u32 increment ; __u32 decrement ; __u32 limit ; __u32 penalty_rate ; __u32 penalty_burst ; } ;
struct tc_sfb_xstats { __u32 earlydrop ; __u32 penaltydrop ; __u32 bucketdrop ; __u32 queuedrop ; __u32 childdrop ; __u32 marked ; __u32 maxqlen ; __u32 maxprob ; __u32 avgprob ; } ;
struct tc_qfq_stats { __u32 weight ; __u32 lmax ; } ;
struct tcf_t { __u64 install ; __u64 lastuse ; __u64 expires ; } ;
struct tc_u32_mark { __u32 val ; __u32 mask ; __u32 success ; } ;
struct tc_u32_pcnt { __u64 rcnt ; __u64 rhit ; __u64 kcnts [ 0 ] ; } ;
struct tc_rsvp_gpi { __u32 key ; __u32 mask ; int offset ; } ;
struct tcf_ematch_tree_hdr { __u16 nmatches ; __u16 progid ; } ;
struct tcf_ematch_hdr { __u16 matchid ; __u16 kind ; __u16 flags ; __u16 pad ; } ;
struct gnet_stats_basic { __u64 bytes ; __u32 packets ; } ;
struct gnet_stats_basic_packed { __u64 bytes ; __u32 packets ; } __attribute__ ( ( packed ) ) ;
struct gnet_stats_rate_est { __u32 bps ; __u32 pps ; } ;
struct gnet_stats_queue { __u32 qlen ; __u32 backlog ; __u32 drops ; __u32 requeues ; __u32 overlimits ; } ;
struct Qdisc_ops ;
struct qdisc_walker ;
struct Qdisc_ops { struct Qdisc_ops * next ; const struct Qdisc_class_ops * cl_ops ; char id [ 16 ] ; int priv_size ; int ( * enqueue ) ( struct sk_buff * , struct Qdisc * ) ; struct sk_buff * ( * dequeue ) ( struct Qdisc * ) ; struct sk_buff * ( * peek ) ( struct Qdisc * ) ; unsigned int ( * drop ) ( struct Qdisc * ) ; int ( * init ) ( struct Qdisc * , struct nlattr * arg ) ; void ( * reset ) ( struct Qdisc * ) ; void ( * destroy ) ( struct Qdisc * ) ; int ( * change ) ( struct Qdisc * , struct nlattr * arg ) ; void ( * attach ) ( struct Qdisc * ) ; int ( * dump ) ( struct Qdisc * , struct sk_buff * ) ; int ( * dump_stats ) ( struct Qdisc * , struct gnet_dump * ) ; struct module * owner ; } ;
struct tcf_result { unsigned long class_ ; u32 classid ; } ;
struct qdisc_skb_cb { unsigned int pkt_len ; u16 slave_dev_queue_mapping ; u16 _pad ; unsigned char data [ 20 ] ; } ;
struct Qdisc_class_common { u32 classid ; struct hlist_node hnode ; } ;
struct qdisc_walker { int stop ; int skip ; int count ; int ( * fn ) ( struct Qdisc * , unsigned long cl , struct qdisc_walker * ) ; } ;
typedef u64 psched_time_t ;
struct partition_meta_info { char uuid [ 37 ] ; u8 volname [ 64 ] ; } ;
typedef int ( * writepage_t ) ( struct page * page , struct writeback_control * wbc , void * data ) ;
typedef int ( congested_fn ) ( void * , int ) ;
typedef void ( mempool_free_t ) ( void * element , void * pool_data ) ;
struct sg_io_v4 { __s32 guard ; __u32 protocol ; __u32 subprotocol ; __u32 request_len ; __u64 request ; __u64 request_tag ; __u32 request_attr ; __u32 request_priority ; __u32 request_extra ; __u32 max_response_len ; __u64 response ; __u32 dout_iovec_count ; __u32 dout_xfer_len ; __u32 din_iovec_count ; __u32 din_xfer_len ; __u64 dout_xferp ; __u64 din_xferp ; __u32 timeout ; __u32 flags ; __u64 usr_ptr ; __u32 spare_in ; __u32 driver_status ; __u32 transport_status ; __u32 device_status ; __u32 retry_delay ; __u32 info ; __u32 duration ; __u32 response_len ; __s32 din_resid ; __s32 dout_resid ; __u64 generated_tag ; __u32 spare_out ; __u32 padding ; } ;
struct request_pm_state ;
typedef void ( rq_end_io_fn ) ( struct request * , int ) ;
struct request_pm_state { int pm_step ; u32 pm_state ; void * data ; } ;
typedef int ( elevator_merge_fn ) ( struct request_queue * , struct request * * , struct bio * ) ;
typedef void ( elevator_merge_req_fn ) ( struct request_queue * , struct request * , struct request * ) ;
typedef void ( elevator_merged_fn ) ( struct request_queue * , struct request * , int ) ;
typedef int ( elevator_allow_merge_fn ) ( struct request_queue * , struct request * , struct bio * ) ;
typedef void ( elevator_bio_merged_fn ) ( struct request_queue * , struct request * , struct bio * ) ;
typedef int ( elevator_dispatch_fn ) ( struct request_queue * , int ) ;
typedef void ( elevator_add_req_fn ) ( struct request_queue * , struct request * ) ;
typedef void ( elevator_completed_req_fn ) ( struct request_queue * , struct request * ) ;
typedef int ( elevator_may_queue_fn ) ( struct request_queue * , int ) ;
typedef void ( elevator_init_icq_fn ) ( struct io_cq * ) ;
typedef void ( elevator_exit_icq_fn ) ( struct io_cq * ) ;
typedef void ( elevator_put_req_fn ) ( struct request * ) ;
typedef void ( elevator_activate_req_fn ) ( struct request_queue * , struct request * ) ;
typedef void ( elevator_deactivate_req_fn ) ( struct request_queue * , struct request * ) ;
typedef int ( elevator_init_fn ) ( struct request_queue * ) ;
typedef void ( elevator_exit_fn ) ( struct elevator_queue * ) ;
typedef void ( request_fn_proc ) ( struct request_queue * q ) ;
typedef void ( make_request_fn ) ( struct request_queue * q , struct bio * bio ) ;
typedef int ( prep_rq_fn ) ( struct request_queue * , struct request * ) ;
typedef void ( unprep_rq_fn ) ( struct request_queue * , struct request * ) ;
struct bvec_merge_data { struct block_device * bi_bdev ; sector_t bi_sector ; unsigned bi_size ; unsigned long bi_rw ; } ;
typedef int ( merge_bvec_fn ) ( struct request_queue * , struct bvec_merge_data * , struct bio_vec * ) ;
typedef void ( softirq_done_fn ) ( struct request * ) ;
typedef int ( dma_drain_needed_fn ) ( struct request * ) ;
typedef int ( lld_busy_fn ) ( struct request_queue * q ) ;
typedef int ( bsg_job_fn ) ( struct bsg_job * ) ;
struct blk_integrity_exchg { void * prot_buf ; void * data_buf ; sector_t sector ; unsigned int data_size ; unsigned short sector_size ; const char * disk_name ; } ;
typedef void ( integrity_gen_fn ) ( struct blk_integrity_exchg * ) ;
typedef int ( integrity_vrfy_fn ) ( struct blk_integrity_exchg * ) ;
typedef void ( integrity_set_tag_fn ) ( void * , void * , unsigned int ) ;
typedef void ( integrity_get_tag_fn ) ( void * , void * , unsigned int ) ;
typedef void ( bh_end_io_t ) ( struct buffer_head * bh , int uptodate ) ;
struct journal_head { struct buffer_head * b_bh ; int b_jcount ; unsigned b_jlist ; unsigned b_modified ; tid_t b_cow_tid ; char * b_frozen_data ; char * b_committed_data ; transaction_t * b_transaction ; transaction_t * b_next_transaction ; struct journal_head * b_tnext , * b_tprev ; transaction_t * b_cp_transaction ; struct journal_head * b_cpnext , * b_cpprev ; struct jbd2_buffer_trigger_type * b_triggers ; struct jbd2_buffer_trigger_type * b_frozen_triggers ; } ;
typedef void ( * crypto_completion_t ) ( struct crypto_async_request * req , int err ) ;
struct blkcipher_desc { struct crypto_blkcipher * tfm ; void * info ; u32 flags ; } ;
struct hash_desc { struct crypto_hash * tfm ; u32 flags ; } ;
struct crypto_attr_type { u32 type ; u32 mask ; } ;
struct crypto_attr_u32 { u32 num ; } ;
struct shash_desc { struct crypto_shash * tfm ; u32 flags ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;
struct transaction_chp_stats_s { unsigned long cs_chp_time ; __u32 cs_forced_to_close ; __u32 cs_written ; __u32 cs_dropped ; } ;
struct transaction_run_stats_s { unsigned long rs_wait ; unsigned long rs_running ; unsigned long rs_locked ; unsigned long rs_flushing ; unsigned long rs_logging ; __u32 rs_handle_count ; __u32 rs_blocks ; __u32 rs_blocks_logged ; } ;
struct file_system_type ;
typedef void ( * node_registration_func_t ) ( struct node * ) ;
struct notifier_block ;
typedef struct { unsigned long val ; } swp_entry_t ;
struct sysinfo ;
struct swap_extent { struct list_head list ; unsigned long start_page ; unsigned long nr_pages ; sector_t start_block ; } ;
typedef struct match_token match_table_t [ ] ;

typedef void ( * kthread_work_func_t ) ( struct kthread_work * work ) ;
struct ata_taskfile { unsigned long flags ; u8 protocol ; u8 ctl ; u8 hob_feature ; u8 hob_nsect ; u8 hob_lbal ; u8 hob_lbam ; u8 hob_lbah ; u8 feature ; u8 nsect ; u8 lbal ; u8 lbam ; u8 lbah ; u8 device ; u8 command ; } ;
struct ccs_modesel_head { __u8 _r1 ; __u8 medium ; __u8 _r2 ; __u8 block_desc_length ; __u8 density ; __u8 number_blocks_hi ; __u8 number_blocks_med ; __u8 number_blocks_lo ; __u8 _r3 ; __u8 block_length_hi ; __u8 block_length_med ; __u8 block_length_lo ; } ;
struct scsi_lun { __u8 scsi_lun [ 8 ] ; } ;
typedef s64 acpi_native_int ;
typedef u64 acpi_size ;
typedef u64 acpi_io_address ;
typedef u64 acpi_physical_address ;
typedef u32 acpi_status ;
typedef u32 acpi_name ;
typedef u8 acpi_owner_id ;
typedef u64 acpi_integer ;
typedef u32 acpi_object_type ;
typedef u32 acpi_event_type ;
typedef u32 acpi_event_status ;
typedef u8 acpi_adr_space_type ;
struct acpi_object_list { u32 count ; union acpi_object * pointer ; } ;
struct acpi_predefined_names { char * name ; u8 type ; char * val ; } ;
struct acpi_system_info { u32 acpi_ca_version ; u32 flags ; u32 timer_resolution ; u32 reserved1 ; u32 reserved2 ; u32 debug_level ; u32 debug_layer ; } ;
typedef void ( * acpi_osd_exec_callback ) ( void * context ) ;
struct acpi_connection_info { u8 * connection ; u16 length ; u8 access_length ; } ;
struct acpi_pnp_device_id { u32 length ; char * string ; } ;
struct acpi_pci_id { u16 segment ; u16 bus ; u16 device ; u16 function ; } ;
struct acpi_memory_list { char * list_name ; void * list_head ; u16 object_size ; u16 max_depth ; u16 current_depth ; u16 link_offset ; } ;
struct acpi_table_header { char signature [ 4 ] ; u32 length ; u8 revision ; u8 checksum ; char oem_id [ 6 ] ; char oem_table_id [ 8 ] ; u32 oem_revision ; char asl_compiler_id [ 4 ] ; u32 asl_compiler_revision ; } ;
struct acpi_generic_address { u8 space_id ; u8 bit_width ; u8 bit_offset ; u8 access_width ; u64 address ; } ;
struct acpi_table_rsdp { char signature [ 8 ] ; u8 checksum ; char oem_id [ 6 ] ; u8 revision ; u32 rsdt_physical_address ; u32 length ; u64 xsdt_physical_address ; u8 extended_checksum ; u8 reserved [ 3 ] ; } ;
struct acpi_table_facs { char signature [ 4 ] ; u32 length ; u32 hardware_signature ; u32 firmware_waking_vector ; u32 global_lock ; u32 flags ; u64 xfirmware_waking_vector ; u8 version ; u8 reserved [ 3 ] ; u32 ospm_flags ; u8 reserved1 [ 24 ] ; } ;
union acpi_name_union { u32 integer ; char ascii [ 4 ] ; } ;
struct acpi_subtable_header { u8 type ; u8 length ; } ;
struct acpi_bert_region { u32 block_status ; u32 raw_data_offset ; u32 raw_data_length ; u32 data_length ; u32 error_severity ; } ;
struct acpi_einj_error_type_with_addr { u32 error_type ; u32 vendor_struct_offset ; u32 flags ; u32 apic_id ; u64 address ; u64 range ; u32 pcie_id ; } ;
struct acpi_einj_vendor { u32 length ; u32 pcie_id ; u16 vendor_id ; u16 device_id ; u8 revision_id ; u8 reserved [ 3 ] ; } ;
struct acpi_einj_trigger { u32 header_size ; u32 revision ; u32 table_size ; u32 entry_count ; } ;
struct acpi_erst_info { u16 signature ; u8 data [ 48 ] ; } ;
struct acpi_hest_header { u16 type ; u16 source_id ; } ;
struct acpi_hest_ia_error_bank { u8 bank_number ; u8 clear_status_on_init ; u8 status_format ; u8 reserved ; u32 control_register ; u64 control_data ; u32 status_register ; u32 address_register ; u32 misc_register ; } ;
struct acpi_hest_aer_common { u16 reserved1 ; u8 flags ; u8 enabled ; u32 records_to_preallocate ; u32 max_sections_per_record ; u32 bus ; u16 device ; u16 function ; u16 device_control ; u16 reserved2 ; u32 uncorrectable_mask ; u32 uncorrectable_severity ; u32 correctable_mask ; u32 advanced_capabilities ; } ;
struct acpi_hest_notify { u8 type ; u8 length ; u16 config_write_enable ; u32 poll_interval ; u32 vector ; u32 polling_threshold_value ; u32 polling_threshold_window ; u32 error_threshold_value ; u32 error_threshold_window ; } ;
struct acpi_hest_generic_status { u32 block_status ; u32 raw_data_offset ; u32 raw_data_length ; u32 data_length ; u32 error_severity ; } ;
struct acpi_hest_generic_data { u8 section_type [ 16 ] ; u32 error_severity ; u16 revision ; u8 validation_bits ; u8 flags ; u32 error_data_length ; u8 fru_id [ 16 ] ; u8 fru_text [ 20 ] ; } ;
struct acpi_msct_proximity { u8 revision ; u8 length ; u32 range_start ; u32 range_end ; u32 processor_capacity ; u64 memory_capacity ; } ;
struct acpi_asf_header { u8 type ; u8 reserved ; u16 length ; } ;
struct acpi_asf_alert_data { u8 address ; u8 command ; u8 mask ; u8 value ; u8 sensor_type ; u8 type ; u8 offset ; u8 source_type ; u8 severity ; u8 sensor_number ; u8 entity ; u8 instance ; } ;
struct acpi_asf_control_data { u8 function ; u8 address ; u8 command ; u8 value ; } ;
struct acpi_csrt_group { u32 length ; u32 vendor_id ; u32 subvendor_id ; u16 device_id ; u16 subdevice_id ; u16 revision ; u16 reserved ; u32 info_length ; } ;
struct acpi_csrt_descriptor { u32 length ; u16 type ; u16 subtype ; u32 uid ; } ;
struct acpi_dbg2_device { u8 revision ; u16 length ; u8 register_count ; u16 namepath_length ; u16 namepath_offset ; u16 oem_data_length ; u16 oem_data_offset ; u16 port_type ; u16 port_subtype ; u16 reserved ; u16 base_address_offset ; u16 address_size_offset ; } ;
struct acpi_dmar_header { u16 type ; u16 length ; } ;
struct acpi_dmar_device_scope { u8 entry_type ; u8 length ; u16 reserved ; u8 enumeration_id ; u8 bus ; } ;
struct acpi_dmar_pci_path { u8 dev ; u8 fn ; } ;
struct acpi_ibft_header { u8 type ; u8 version ; u16 length ; u8 index ; u8 flags ; } ;
struct acpi_ivrs_header { u8 type ; u8 flags ; u16 length ; u16 device_id ; } ;
struct acpi_ivrs_de_header { u8 type ; u16 id ; u8 data_setting ; } ;
struct acpi_mcfg_allocation { u64 address ; u16 pci_segment ; u8 start_bus_number ; u8 end_bus_number ; u32 reserved ; } ;
struct acpi_slic_header { u32 type ; u32 length ; } ;
struct acpi_drtm_vtl_list { u32 validated_table_list_count ; } ;
struct acpi_drtm_resource_list { u32 resource_list_count ; } ;
struct acpi_drtm_id_list { u32 id_list_count ; } ;
struct acpi_fpdt_header { u16 type ; u8 length ; u8 revision ; } ;
struct acpi_table_s3pt { u8 signature [ 4 ] ; u32 length ; } ;
struct acpi_s3pt_header { u16 type ; u8 length ; u8 revision ; } ;
struct acpi_mpst_channel { u8 channel_id ; u8 reserved1 [ 3 ] ; u16 power_node_count ; u16 reserved2 ; } ;
struct acpi_mpst_power_node { u8 flags ; u8 reserved1 ; u16 node_id ; u32 length ; u64 range_address ; u64 range_length ; u32 num_power_states ; u32 num_physical_components ; } ;
struct acpi_mpst_power_state { u8 power_state ; u8 info_index ; } ;
struct acpi_mpst_component { u16 component_id ; } ;
struct acpi_mpst_data_hdr { u16 characteristics_count ; u16 reserved ; } ;
struct acpi_mpst_power_data { u8 structure_id ; u8 flags ; u16 reserved1 ; u32 average_power ; u32 power_saving ; u64 exit_latency ; u64 reserved2 ; } ;
struct acpi_mpst_shared { u32 signature ; u16 pcc_command ; u16 pcc_status ; u32 command_register ; u32 status_register ; u32 power_state_id ; u32 power_node_id ; u64 energy_consumed ; u64 average_power ; } ;
struct acpi_pcct_shared_memory { u32 signature ; u16 command ; u16 status ; } ;
struct acpi_pmtt_header { u8 type ; u8 reserved1 ; u16 length ; u16 flags ; u16 reserved2 ; } ;
struct acpi_pmtt_domain { u32 proximity_domain ; } ;
struct acpi_rasf_shared_memory { u32 signature ; u16 command ; u16 status ; u64 requested_address ; u64 requested_length ; u64 actual_address ; u64 actual_length ; u16 flags ; u8 speed ; } ;
typedef u16 acpi_rs_length ;
typedef u32 acpi_rsdesc_size ;
struct acpi_uuid { u8 data [ 16 ] ; } ;
struct acpi_vendor_uuid { u8 subtype ; u8 data [ 16 ] ; } ;
struct acpi_resource_irq { u8 descriptor_length ; u8 triggering ; u8 polarity ; u8 sharable ; u8 interrupt_count ; u8 interrupts [ 1 ] ; } ;
struct acpi_resource_dma { u8 type ; u8 bus_master ; u8 transfer ; u8 channel_count ; u8 channels [ 1 ] ; } ;
struct acpi_resource_start_dependent { u8 descriptor_length ; u8 compatibility_priority ; u8 performance_robustness ; } ;
struct acpi_resource_io { u8 io_decode ; u8 alignment ; u8 address_length ; u16 minimum ; u16 maximum ; } ;
struct acpi_resource_fixed_io { u16 address ; u8 address_length ; } ;
struct acpi_resource_fixed_dma { u16 request_lines ; u16 channels ; u8 width ; } ;
struct acpi_resource_vendor { u16 byte_length ; u8 byte_data [ 1 ] ; } ;
struct acpi_resource_vendor_typed { u16 byte_length ; u8 uuid_subtype ; u8 uuid [ 16 ] ; u8 byte_data [ 1 ] ; } ;
struct acpi_resource_end_tag { u8 checksum ; } ;
struct acpi_resource_memory24 { u8 write_protect ; u16 minimum ; u16 maximum ; u16 alignment ; u16 address_length ; } ;
struct acpi_resource_memory32 { u8 write_protect ; u32 minimum ; u32 maximum ; u32 alignment ; u32 address_length ; } ;
struct acpi_resource_fixed_memory32 { u8 write_protect ; u32 address ; u32 address_length ; } ;
struct acpi_memory_attribute { u8 write_protect ; u8 caching ; u8 range_type ; u8 translation ; } ;
struct acpi_io_attribute { u8 range_type ; u8 translation ; u8 translation_type ; u8 reserved1 ; } ;
struct acpi_resource_source { u8 index ; u16 string_length ; char * string_ptr ; } ;
struct acpi_resource_generic_register { u8 space_id ; u8 bit_width ; u8 bit_offset ; u8 access_size ; u64 address ; } ;
struct acpi_pci_routing_table { u32 length ; u32 pin ; u64 address ; u32 source_index ; char source [ 4 ] ; } ;
struct acpi_signal_fatal_info { u32 type ; u32 code ; u32 argument ; } ;
struct acpi_fde_info { u32 floppy0 ; u32 floppy1 ; u32 floppy2 ; u32 floppy3 ; u32 tape ; } ;
struct acpi_grt_info { u16 year ; u8 month ; u8 day ; u8 hour ; u8 minute ; u8 second ; u8 valid ; u16 milliseconds ; u16 timezone ; u8 daylight ; u8 reserved [ 3 ] ; } ;
struct acpi_gtm_info { u32 pio_speed0 ; u32 dma_speed0 ; u32 pio_speed1 ; u32 dma_speed1 ; u32 flags ; } ;
struct acpi_pld_info { u8 revision ; u8 ignore_color ; u32 color ; u16 width ; u16 height ; u8 user_visible ; u8 dock ; u8 lid ; u8 panel ; u8 vertical_position ; u8 horizontal_position ; u8 shape ; u8 group_orientation ; u8 group_token ; u8 group_position ; u8 bay ; u8 ejectable ; u8 ospm_eject_required ; u8 cabinet_number ; u8 card_cage_number ; u8 reference ; u8 rotation ; u8 order ; u8 reserved ; u16 vertical_offset ; u16 horizontal_offset ; } ;
struct acpi_handle_list { u32 count ; acpi_handle handles [ 10 ] ; } ;
typedef int ( * acpi_op_add ) ( struct acpi_device * device ) ;
typedef int ( * acpi_op_remove ) ( struct acpi_device * device , int type ) ;
typedef int ( * acpi_op_start ) ( struct acpi_device * device ) ;
typedef int ( * acpi_op_bind ) ( struct acpi_device * device ) ;
typedef int ( * acpi_op_unbind ) ( struct acpi_device * device ) ;
struct acpi_device_status { u32 present : 1 ; u32 enabled : 1 ; u32 show_in_ui : 1 ; u32 functional : 1 ; u32 battery_present : 1 ; u32 reserved : 27 ; } ;
struct acpi_device_flags { u32 dynamic_status : 1 ; u32 bus_address : 1 ; u32 removable : 1 ; u32 ejectable : 1 ; u32 suprise_removal_ok : 1 ; u32 power_manageable : 1 ; u32 performance_manageable : 1 ; u32 eject_pending : 1 ; u32 reserved : 24 ; } ;
struct acpi_device_pnp { acpi_bus_id bus_id ; acpi_bus_address bus_address ; char * unique_id ; struct list_head ids ; acpi_device_name device_name ; acpi_device_class device_class ; union acpi_object * str_obj ; unsigned long sun ; } ;
struct acpi_device_power_flags { u32 explicit_get : 1 ; u32 power_resources : 1 ; u32 inrush_current : 1 ; u32 power_removed : 1 ; u32 reserved : 28 ; } ;
struct acpi_device_perf_flags { u8 reserved : 8 ; } ;
struct acpi_device_wakeup_flags { u8 valid : 1 ; u8 run_wake : 1 ; u8 notifier_present : 1 ; } ;
struct acpi_device_physical_node { u8 node_id ; struct list_head node ; struct device * dev ; } ;
struct acpi_bus_event { struct list_head node ; acpi_device_class device_class ; acpi_bus_id bus_id ; u32 type ; u32 data ; } ;
struct acpi_eject_event { acpi_handle handle ; u32 event ; } ;
typedef int ( * acpi_table_handler ) ( struct acpi_table_header * table ) ;
typedef int ( * acpi_table_entry_handler ) ( struct acpi_subtable_header * header , const unsigned long end ) ;
struct acpi_pci_driver { struct list_head node ; int ( * add ) ( struct acpi_pci_root * root ) ; void ( * remove ) ( struct acpi_pci_root * root ) ; } ;
struct cdrom_msf0 { __u8 minute ; __u8 second ; __u8 frame ; } ;
struct cdrom_msf { __u8 cdmsf_min0 ; __u8 cdmsf_sec0 ; __u8 cdmsf_frame0 ; __u8 cdmsf_min1 ; __u8 cdmsf_sec1 ; __u8 cdmsf_frame1 ; } ;
struct cdrom_ti { __u8 cdti_trk0 ; __u8 cdti_ind0 ; __u8 cdti_trk1 ; __u8 cdti_ind1 ; } ;
struct cdrom_tochdr { __u8 cdth_trk0 ; __u8 cdth_trk1 ; } ;
struct cdrom_volctrl { __u8 channel0 ; __u8 channel1 ; __u8 channel2 ; __u8 channel3 ; } ;
struct cdrom_mcn { __u8 medium_catalog_number [ 14 ] ; } ;
struct dvd_layer { __u8 book_version : 4 ; __u8 book_type : 4 ; __u8 min_rate : 4 ; __u8 disc_size : 4 ; __u8 layer_type : 4 ; __u8 track_path : 1 ; __u8 nlayers : 2 ; __u8 track_density : 4 ; __u8 linear_density : 4 ; __u8 bca : 1 ; __u32 start_sector ; __u32 end_sector ; __u32 end_sector_l0 ; } ;
struct dvd_copyright { __u8 type ; __u8 layer_num ; __u8 cpst ; __u8 rmi ; } ;
struct dvd_disckey { __u8 type ; unsigned agid : 2 ; __u8 value [ 2048 ] ; } ;
struct dvd_bca { __u8 type ; int len ; __u8 value [ 188 ] ; } ;
struct dvd_manufact { __u8 type ; __u8 layer_num ; int len ; __u8 value [ 2048 ] ; } ;
typedef __u8 dvd_key [ 5 ] ;
typedef __u8 dvd_challenge [ 10 ] ;
struct dvd_lu_send_agid { __u8 type ; unsigned agid : 2 ; } ;
struct dvd_lu_send_asf { __u8 type ; unsigned agid : 2 ; unsigned asf : 1 ; } ;
struct dvd_host_send_rpcstate { __u8 type ; __u8 pdrc ; } ;
struct dvd_lu_send_rpcstate { __u8 type : 2 ; __u8 vra : 3 ; __u8 ucca : 3 ; __u8 region_mask ; __u8 rpc_scheme ; } ;
struct request_sense { __u8 error_code : 7 ; __u8 valid : 1 ; __u8 segment_number ; __u8 sense_key : 4 ; __u8 reserved2 : 1 ; __u8 ili : 1 ; __u8 reserved1 : 2 ; __u8 information [ 4 ] ; __u8 add_sense_len ; __u8 command_info [ 4 ] ; __u8 asc ; __u8 ascq ; __u8 fruc ; __u8 sks [ 3 ] ; __u8 asb [ 46 ] ; } ;
struct feature_header { __u32 data_len ; __u8 reserved1 ; __u8 reserved2 ; __u16 curr_profile ; } ;
struct cdrom_device_info { struct cdrom_device_ops * ops ; struct list_head list ; struct gendisk * disk ; void * handle ; int mask ; int speed ; int capacity ; unsigned int options : 30 ; unsigned mc_flags : 2 ; unsigned int vfs_events ; unsigned int ioctl_events ; int use_count ; char name [ 20 ] ; __u8 sanyo_slot : 2 ; __u8 keeplocked : 1 ; __u8 reserved : 5 ; int cdda_method ; __u8 last_sense ; __u8 media_written ; unsigned short mmc3_profile ; int for_data ; int ( * exit ) ( struct cdrom_device_info * ) ; int mrw_mode_page ; } ;
struct cdrom_device_ops { int ( * open ) ( struct cdrom_device_info * , int ) ; void ( * release ) ( struct cdrom_device_info * ) ; int ( * drive_status ) ( struct cdrom_device_info * , int ) ; unsigned int ( * check_events ) ( struct cdrom_device_info * cdi , unsigned int clearing , int slot ) ; int ( * media_changed ) ( struct cdrom_device_info * , int ) ; int ( * tray_move ) ( struct cdrom_device_info * , int ) ; int ( * lock_door ) ( struct cdrom_device_info * , int ) ; int ( * select_speed ) ( struct cdrom_device_info * , int ) ; int ( * select_disc ) ( struct cdrom_device_info * , int ) ; int ( * get_last_session ) ( struct cdrom_device_info * , struct cdrom_multisession * ) ; int ( * get_mcn ) ( struct cdrom_device_info * , struct cdrom_mcn * ) ; int ( * reset ) ( struct cdrom_device_info * ) ; int ( * audio_ioctl ) ( struct cdrom_device_info * , unsigned int , void * ) ; const int capability ; int n_minors ; int ( * generic_packet ) ( struct cdrom_device_info * , struct packet_command * ) ; } ;
typedef struct { int data ; int audio ; int cdi ; int xa ; long error ; } tracktype ;
struct cdrom_mechstat_header { __u8 curslot : 5 ; __u8 changer_state : 2 ; __u8 fault : 1 ; __u8 reserved1 : 4 ; __u8 door_open : 1 ; __u8 mech_state : 3 ; __u8 curlba [ 3 ] ; __u8 nslots ; __u16 slot_tablelen ; } ;
struct cdrom_slot { __u8 change : 1 ; __u8 reserved1 : 6 ; __u8 disc_present : 1 ; __u8 reserved2 [ 3 ] ; } ;
struct modesel_head { __u8 reserved1 ; __u8 medium ; __u8 reserved2 ; __u8 block_desc_length ; __u8 density ; __u8 number_of_blocks_hi ; __u8 number_of_blocks_med ; __u8 number_of_blocks_lo ; __u8 reserved3 ; __u8 block_length_hi ; __u8 block_length_med ; __u8 block_length_lo ; } ;
struct media_event_desc { __u8 media_event_code : 4 ; __u8 reserved1 : 4 ; __u8 door_open : 1 ; __u8 media_present : 1 ; __u8 reserved2 : 6 ; __u8 start_slot ; __u8 end_slot ; } ;
typedef void ( * ata_qc_cb_t ) ( struct ata_queued_cmd * qc ) ;
typedef int ( * ata_prereset_fn_t ) ( struct ata_link * link , unsigned long deadline ) ;
typedef int ( * ata_reset_fn_t ) ( struct ata_link * link , unsigned int * classes , unsigned long deadline ) ;
typedef void ( * ata_postreset_fn_t ) ( struct ata_link * link , unsigned int * classes ) ;
struct ata_ering_entry { unsigned int eflags ; unsigned int err_mask ; u64 timestamp ; } ;
struct ata_eh_info { struct ata_device * dev ; u32 serror ; unsigned int err_mask ; unsigned int action ; unsigned int dev_action [ ATA_MAX_DEVICES ] ; unsigned int flags ; unsigned int probe_mask ; char desc [ ATA_EH_DESC_LEN ] ; int desc_len ; } ;
struct ata_acpi_drive { u32 pio ; u32 dma ; } __attribute__ ( ( packed ) ) ;
struct input_id { __u16 bustype ; __u16 vendor ; __u16 product ; __u16 version ; } ;
struct input_absinfo { __s32 value ; __s32 minimum ; __s32 maximum ; __s32 fuzz ; __s32 flat ; __s32 resolution ; } ;
struct input_keymap_entry { __u8 flags ; __u8 len ; __u16 index ; __u32 keycode ; __u8 scancode [ 32 ] ; } ;
struct ff_replay { __u16 length ; __u16 delay ; } ;
struct ff_trigger { __u16 button ; __u16 interval ; } ;
struct ff_envelope { __u16 attack_length ; __u16 attack_level ; __u16 fade_length ; __u16 fade_level ; } ;
struct ff_condition_effect { __u16 right_saturation ; __u16 left_saturation ; __s16 right_coeff ; __s16 left_coeff ; __u16 deadband ; __s16 center ; } ;
struct ff_rumble_effect { __u16 strong_magnitude ; __u16 weak_magnitude ; } ;
struct input_value { __u16 type ; __u16 code ; __s32 value ; } ;
struct pnp_fixup { char id [ 7 ] ; void ( * quirk_function ) ( struct pnp_dev * dev ) ; } ;
struct phy_c45_device_ids { u32 devices_in_package ; u32 device_ids [ 8 ] ; } ;
struct phy_fixup { struct list_head list ; char bus_id [ 20 ] ; u32 phy_uid ; u32 phy_uid_mask ; int ( * run ) ( struct phy_device * phydev ) ; } ;
struct ftrace_branch_data { const char * func ; const char * file ; unsigned line ; union { struct { unsigned long correct ; unsigned long incorrect ; } ; struct { unsigned long miss ; unsigned long hit ; } ; unsigned long miss_hit [ 2 ] ; } ; } ;
typedef __kernel_fd_set fd_set ;
typedef __kernel_dev_t dev_t ;
typedef __kernel_uid32_t uid_t ;
typedef __kernel_gid32_t gid_t ;
typedef phys_addr_t resource_size_t ;
struct text_poke_param { void * addr ; const void * opcode ; size_t len ; } ;
struct va_format { const char * fmt ; va_list * va ; } ;
struct user ;
struct pid ;
struct compat_timespec ;
struct exec_domain ;
typedef struct { pteval_t pte ; } pte_t ;
typedef struct pgprot { pgprotval_t pgprot ; } pgprot_t ;
typedef struct { pgdval_t pgd ; } pgd_t ;
typedef struct { pudval_t pud ; } pud_t ;
typedef struct { pmdval_t pmd ; } pmd_t ;
struct tss_struct ;
struct pv_init_ops { unsigned ( * patch ) ( u8 type , u16 clobber , void * insnbuf , unsigned long addr , unsigned len ) ; } ;
struct pv_cpu_ops { unsigned long ( * get_debugreg ) ( int regno ) ; void ( * set_debugreg ) ( int regno , unsigned long value ) ; void ( * clts ) ( void ) ; unsigned long ( * read_cr0 ) ( void ) ; void ( * write_cr0 ) ( unsigned long ) ; unsigned long ( * read_cr4_safe ) ( void ) ; unsigned long ( * read_cr4 ) ( void ) ; void ( * write_cr4 ) ( unsigned long ) ; unsigned long ( * read_cr8 ) ( void ) ; void ( * write_cr8 ) ( unsigned long ) ; void ( * load_tr_desc ) ( void ) ; void ( * load_gdt ) ( const struct desc_ptr * ) ; void ( * load_idt ) ( const struct desc_ptr * ) ; void ( * store_gdt ) ( struct desc_ptr * ) ; void ( * store_idt ) ( struct desc_ptr * ) ; void ( * set_ldt ) ( const void * desc , unsigned entries ) ; unsigned long ( * store_tr ) ( void ) ; void ( * load_tls ) ( struct thread_struct * t , unsigned int cpu ) ; void ( * load_gs_index ) ( unsigned int idx ) ; void ( * write_ldt_entry ) ( struct desc_struct * ldt , int entrynum , const void * desc ) ; void ( * write_gdt_entry ) ( struct desc_struct * , int entrynum , const void * desc , int size ) ; void ( * write_idt_entry ) ( gate_desc * , int entrynum , const gate_desc * gate ) ; void ( * alloc_ldt ) ( struct desc_struct * ldt , unsigned entries ) ; void ( * free_ldt ) ( struct desc_struct * ldt , unsigned entries ) ; void ( * load_sp0 ) ( struct tss_struct * tss , struct thread_struct * t ) ; void ( * set_iopl_mask ) ( unsigned mask ) ; void ( * wbinvd ) ( void ) ; void ( * io_delay ) ( void ) ; void ( * cpuid ) ( unsigned int * eax , unsigned int * ebx , unsigned int * ecx , unsigned int * edx ) ; u64 ( * read_msr ) ( unsigned int msr , int * err ) ; int ( * write_msr ) ( unsigned int msr , unsigned low , unsigned high ) ; u64 ( * read_tsc ) ( void ) ; u64 ( * read_pmc ) ( int counter ) ; unsigned long long ( * read_tscp ) ( unsigned int * aux ) ; void ( * irq_enable_sysexit ) ( void ) ; void ( * usergs_sysret64 ) ( void ) ; void ( * usergs_sysret32 ) ( void ) ; void ( * iret ) ( void ) ; void ( * swapgs ) ( void ) ; void ( * start_context_switch ) ( struct task_struct * prev ) ; void ( * end_context_switch ) ( struct task_struct * next ) ; } ;
struct kernel_vm86_struct { struct kernel_vm86_regs regs ; unsigned long flags ; unsigned long screen_bitmap ; unsigned long cpu_type ; struct revectored_struct int_revectored ; struct revectored_struct int21_revectored ; struct vm86plus_info_struct vm86plus ; struct pt_regs * regs32 ; } ;
struct static_key ;
struct exec_domain ;
struct exec_domain { const char * name ; handler_t handler ; unsigned char pers_low ; unsigned char pers_high ; unsigned long * signal_map ; unsigned long * signal_invmap ; struct map_segment * err_map ; struct map_segment * socktype_map ; struct map_segment * sockopt_map ; struct map_segment * af_map ; struct module * module ; struct exec_domain * next ; } ;
struct tss_struct { struct x86_hw_tss x86_tss ; unsigned long io_bitmap [ ( ( 65536 / 8 ) / sizeof ( long ) ) + 1 ] ; unsigned long stack [ 64 ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
typedef atomic64_t atomic_long_t ;
struct client_extension { void * return_address_stack [ 8 ] ; unsigned return_stack_size ; void * exit_address ; void ( * iret_handler ) ( void ) ; interrupt_stack_frame pending ; } ;
typedef union { s32 lock ; s32 write ; } arch_rwlock_t ;
struct itimerspec { struct timespec it_interval ; struct timespec it_value ; } ;
struct itimerval { struct timeval it_interval ; struct timeval it_value ; } ;
struct itimerval ;
struct __wait_queue { unsigned int flags ; void * private_ ; wait_queue_func_t func ; struct list_head task_list ; } ;
struct nodemask_scratch { nodemask_t mask1 ; nodemask_t mask2 ; } ;
typedef void call_rcu_func_t ( struct callback_head * head , void ( * func ) ( struct callback_head * head ) ) ;
struct timex { unsigned int modes ; long offset ; long freq ; long maxerror ; long esterror ; int status ; long constant ; long precision ; long tolerance ; struct timeval time ; long tick ; long ppsfreq ; long jitter ; int shift ; long stabil ; long jitcnt ; long calcnt ; long errcnt ; long stbcnt ; int tai ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; } ;
struct apm_info { struct apm_bios_info bios ; unsigned short connection_version ; int get_power_status_broken ; int get_power_status_swabinminutes ; int allow_ints ; int forbid_idle ; int realmode_power_off ; int disabled ; } ;
struct e820map { __u32 nr_map ; struct e820entry map [ ( 128 + 3 * ( 1 << 6 ) ) ] ; } ;
struct x86_init_mapping { void ( * pagetable_reserve ) ( u64 start , u64 end ) ; } ;
struct local_apic { struct { unsigned int __reserved [ 4 ] ; } __reserved_01 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_02 ; struct { unsigned int __reserved_1 : 24 , phys_apic_id : 4 , __reserved_2 : 4 ; unsigned int __reserved [ 3 ] ; } id ; const struct { unsigned int version : 8 , __reserved_1 : 8 , max_lvt : 8 , __reserved_2 : 8 ; unsigned int __reserved [ 3 ] ; } version ; struct { unsigned int __reserved [ 4 ] ; } __reserved_03 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_04 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_05 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_06 ; struct { unsigned int priority : 8 , __reserved_1 : 24 ; unsigned int __reserved_2 [ 3 ] ; } tpr ; const struct { unsigned int priority : 8 , __reserved_1 : 24 ; unsigned int __reserved_2 [ 3 ] ; } apr ; const struct { unsigned int priority : 8 , __reserved_1 : 24 ; unsigned int __reserved_2 [ 3 ] ; } ppr ; struct { unsigned int eoi ; unsigned int __reserved [ 3 ] ; } eoi ; struct { unsigned int __reserved [ 4 ] ; } __reserved_07 ; struct { unsigned int __reserved_1 : 24 , logical_dest : 8 ; unsigned int __reserved_2 [ 3 ] ; } ldr ; struct { unsigned int __reserved_1 : 28 , model : 4 ; unsigned int __reserved_2 [ 3 ] ; } dfr ; struct { unsigned int spurious_vector : 8 , apic_enabled : 1 , focus_cpu : 1 , __reserved_2 : 22 ; unsigned int __reserved_3 [ 3 ] ; } svr ; struct { unsigned int bitfield ; unsigned int __reserved [ 3 ] ; } isr [ 8 ] ; struct { unsigned int bitfield ; unsigned int __reserved [ 3 ] ; } tmr [ 8 ] ; struct { unsigned int bitfield ; unsigned int __reserved [ 3 ] ; } irr [ 8 ] ; union { struct { unsigned int send_cs_error : 1 , receive_cs_error : 1 , send_accept_error : 1 , receive_accept_error : 1 , __reserved_1 : 1 , send_illegal_vector : 1 , receive_illegal_vector : 1 , illegal_register_address : 1 , __reserved_2 : 24 ; unsigned int __reserved_3 [ 3 ] ; } error_bits ; struct { unsigned int errors ; unsigned int __reserved_3 [ 3 ] ; } all_errors ; } esr ; struct { unsigned int __reserved [ 4 ] ; } __reserved_08 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_09 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_10 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_11 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_12 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_13 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_14 ; struct { unsigned int vector : 8 , delivery_mode : 3 , destination_mode : 1 , delivery_status : 1 , __reserved_1 : 1 , level : 1 , trigger : 1 , __reserved_2 : 2 , shorthand : 2 , __reserved_3 : 12 ; unsigned int __reserved_4 [ 3 ] ; } icr1 ; struct { union { unsigned int __reserved_1 : 24 , phys_dest : 4 , __reserved_2 : 4 ; unsigned int __reserved_3 : 24 , logical_dest : 8 ; } dest ; unsigned int __reserved_4 [ 3 ] ; } icr2 ; struct { unsigned int vector : 8 , __reserved_1 : 4 , delivery_status : 1 , __reserved_2 : 3 , mask : 1 , timer_mode : 1 , __reserved_3 : 14 ; unsigned int __reserved_4 [ 3 ] ; } lvt_timer ; struct { unsigned int vector : 8 , delivery_mode : 3 , __reserved_1 : 1 , delivery_status : 1 , __reserved_2 : 3 , mask : 1 , __reserved_3 : 15 ; unsigned int __reserved_4 [ 3 ] ; } lvt_thermal ; struct { unsigned int vector : 8 , delivery_mode : 3 , __reserved_1 : 1 , delivery_status : 1 , __reserved_2 : 3 , mask : 1 , __reserved_3 : 15 ; unsigned int __reserved_4 [ 3 ] ; } lvt_pc ; struct { unsigned int vector : 8 , delivery_mode : 3 , __reserved_1 : 1 , delivery_status : 1 , polarity : 1 , remote_irr : 1 , trigger : 1 , mask : 1 , __reserved_2 : 15 ; unsigned int __reserved_3 [ 3 ] ; } lvt_lint0 ; struct { unsigned int vector : 8 , delivery_mode : 3 , __reserved_1 : 1 , delivery_status : 1 , polarity : 1 , remote_irr : 1 , trigger : 1 , mask : 1 , __reserved_2 : 15 ; unsigned int __reserved_3 [ 3 ] ; } lvt_lint1 ; struct { unsigned int vector : 8 , __reserved_1 : 4 , delivery_status : 1 , __reserved_2 : 3 , mask : 1 , __reserved_3 : 15 ; unsigned int __reserved_4 [ 3 ] ; } lvt_error ; struct { unsigned int initial_count ; unsigned int __reserved_2 [ 3 ] ; } timer_icr ; const struct { unsigned int curr_count ; unsigned int __reserved_2 [ 3 ] ; } timer_ccr ; struct { unsigned int __reserved [ 4 ] ; } __reserved_16 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_17 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_18 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_19 ; struct { unsigned int divisor : 4 , __reserved_1 : 28 ; unsigned int __reserved_2 [ 3 ] ; } timer_dcr ; struct { unsigned int __reserved [ 4 ] ; } __reserved_20 ; } __attribute__ ( ( packed ) ) ;
struct dev_pm_domain { struct dev_pm_ops ops ; } ;
struct vm_struct { struct vm_struct * next ; void * addr ; unsigned long size ; unsigned long flags ; struct page * * pages ; unsigned int nr_pages ; phys_addr_t phys_addr ; const void * caller ; } ;
typedef K_uint64_t * __guest_handle_K_uint64_t ;
typedef K_uint32_t * __guest_handle_K_uint32_t ;
struct trap_info { K_uint8_t vector ; K_uint8_t flags ; K_uint16_t cs ; unsigned long address ; } ;
struct iret_context { K_uint64_t rax , r11 , rcx , flags , rip , cs , rflags , rsp , ss ; } ;
struct mmuext_op { unsigned int cmd ; union { xen_pfn_t mfn ; unsigned long linear_addr ; } arg1 ; union { unsigned int nr_ents ; void * vcpumask ; } arg2 ; } ;
typedef K_uint16_t domid_t ;
struct mmu_update { K_uint64_t ptr ; K_uint64_t val ; } ;
struct vcpu_time_info { K_uint32_t version ; K_uint32_t pad0 ; K_uint64_t tsc_timestamp ; K_uint64_t system_time ; K_uint32_t tsc_to_system_mul ; K_int8_t tsc_shift ; K_int8_t pad1 [ 3 ] ; } ;
struct vcpu_info { K_uint8_t evtchn_upcall_pending ; K_uint8_t evtchn_upcall_mask ; unsigned long evtchn_pending_sel ; struct arch_vcpu_info arch ; struct pvclock_vcpu_time_info time ; } ;
typedef K_uint64_t cpumap_t ;
typedef K_uint8_t xen_domain_handle_t [ 16 ] ;
struct timecounter { const struct cyclecounter * cc ; cycle_t cycle_last ; u64 nsec ; } ;
struct pvclock_vsyscall_time_info { struct pvclock_vcpu_time_info pvti ; u32 migrate_count ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
union IO_APIC_reg_00 { u32 raw ; struct { u32 __reserved_2 : 14 , LTS : 1 , delivery_type : 1 , __reserved_1 : 8 , ID : 8 ; } __attribute__ ( ( packed ) ) bits ; } ;
union IO_APIC_reg_01 { u32 raw ; struct { u32 version : 8 , __reserved_2 : 7 , PRQ : 1 , entries : 8 , __reserved_1 : 8 ; } __attribute__ ( ( packed ) ) bits ; } ;
union IO_APIC_reg_02 { u32 raw ; struct { u32 __reserved_2 : 24 , arbitration : 4 , __reserved_1 : 4 ; } __attribute__ ( ( packed ) ) bits ; } ;
union IO_APIC_reg_03 { u32 raw ; struct { u32 boot_DT : 1 , __reserved_1 : 31 ; } __attribute__ ( ( packed ) ) bits ; } ;
struct call_single_data { struct list_head list ; smp_call_func_t func ; void * info ; u16 flags ; u16 priv ; } ;
struct pcpu_alloc_info { size_t static_size ; size_t reserved_size ; size_t dyn_size ; size_t unit_size ; size_t atom_size ; size_t alloc_size ; size_t __ai_size ; int nr_groups ; struct pcpu_group_info groups [ ] ; } ;
struct __sysctl_args { int * name ; int nlen ; void * oldval ; size_t * oldlenp ; void * newval ; size_t newlen ; unsigned long __unused [ 4 ] ; } ;
struct nsproxy ;
struct user { struct user_regs_struct regs ; int u_fpvalid ; int pad0 ; struct user_i387_struct i387 ; unsigned long int u_tsize ; unsigned long int u_dsize ; unsigned long int u_ssize ; unsigned long start_code ; unsigned long start_stack ; long int signal ; int reserved ; int pad1 ; unsigned long u_ar0 ; struct user_i387_struct * u_fpstate ; unsigned long magic ; char u_comm [ 32 ] ; unsigned long u_debugreg [ 8 ] ; unsigned long error_code ; unsigned long fault_address ; } ;
struct user_xstateregs { struct { __u64 fpx_space [ 58 ] ; __u64 xstate_fx_sw [ 6 ] ; } i387 ; struct user_xsave_hdr xsave_hdr ; struct user_ymmh_regs ymmh ; } ;
struct attribute { const char * name ; umode_t mode ; } ;
struct kref { atomic_t refcount ; } ;
struct static_key { atomic_t enabled ; } ;
struct symsearch { const struct kernel_symbol * start , * stop ; const unsigned long * crcs ; enum { NOT_GPL_ONLY , GPL_ONLY , WILL_BE_GPL_ONLY , } licence ; K_bool unused ; } ;
struct pid { atomic_t count ; unsigned int level ; struct hlist_head tasks [ PIDTYPE_MAX ] ; struct callback_head rcu ; struct upid numbers [ 1 ] ; } ;
typedef struct __user_cap_header_struct { __u32 version ; int pid ; } * cap_user_header_t ;
typedef struct __user_cap_data_struct { __u32 effective ; __u32 permitted ; __u32 inheritable ; } * cap_user_data_t ;
typedef struct kernel_cap_struct { __u32 cap [ 2 ] ; } kernel_cap_t ;
struct fiemap { __u64 fm_start ; __u64 fm_length ; __u32 fm_flags ; __u32 fm_mapped_extents ; __u32 fm_extent_count ; __u32 fm_reserved ; struct fiemap_extent fm_extents [ 0 ] ; } ;
struct bio ;
struct bio { sector_t bi_sector ; struct bio * bi_next ; struct block_device * bi_bdev ; unsigned long bi_flags ; unsigned long bi_rw ; unsigned short bi_vcnt ; unsigned short bi_idx ; unsigned int bi_phys_segments ; unsigned int bi_size ; unsigned int bi_seg_front_size ; unsigned int bi_seg_back_size ; bio_end_io_t * bi_end_io ; void * bi_private ; struct io_context * bi_ioc ; struct cgroup_subsys_state * bi_css ; struct bio_integrity_payload * bi_integrity ; unsigned int bi_max_vecs ; atomic_t bi_cnt ; struct bio_vec * bi_io_vec ; struct bio_set * bi_pool ; struct bio_vec bi_inline_vecs [ 0 ] ; } ;
struct export_operations ;
struct poll_table_struct ;
struct kstatfs ;
struct swap_info_struct ;
struct buffer_head ;
typedef int ( get_block_t ) ( struct inode * inode , sector_t iblock , struct buffer_head * bh_result , int create ) ;
typedef struct fs_disk_quota { __s8 d_version ; __s8 d_flags ; __u16 d_fieldmask ; __u32 d_id ; __u64 d_blk_hardlimit ; __u64 d_blk_softlimit ; __u64 d_ino_hardlimit ; __u64 d_ino_softlimit ; __u64 d_bcount ; __u64 d_icount ; __s32 d_itimer ; __s32 d_btimer ; __u16 d_iwarns ; __u16 d_bwarns ; __s32 d_padding2 ; __u64 d_rtb_hardlimit ; __u64 d_rtb_softlimit ; __u64 d_rtbcount ; __s32 d_rtbtimer ; __u16 d_rtbwarns ; __s16 d_padding3 ; char d_padding4 [ 8 ] ; } fs_disk_quota_t ;
typedef struct fs_qfilestat { __u64 qfs_ino ; __u64 qfs_nblks ; __u32 qfs_nextents ; } fs_qfilestat_t ;
typedef __kernel_uid32_t projid_t ;
typedef __kernel_uid32_t qid_t ;
struct mem_dqblk { qsize_t dqb_bhardlimit ; qsize_t dqb_bsoftlimit ; qsize_t dqb_curspace ; qsize_t dqb_rsvspace ; qsize_t dqb_ihardlimit ; qsize_t dqb_isoftlimit ; qsize_t dqb_curinodes ; time_t dqb_btime ; time_t dqb_itime ; } ;
struct dquot_operations { int ( * write_dquot ) ( struct dquot * ) ; struct dquot * ( * alloc_dquot ) ( struct super_block * , int ) ; void ( * destroy_dquot ) ( struct dquot * ) ; int ( * acquire_dquot ) ( struct dquot * ) ; int ( * release_dquot ) ( struct dquot * ) ; int ( * mark_dirty ) ( struct dquot * ) ; int ( * write_info ) ( struct super_block * , int ) ; qsize_t * ( * get_reserved_space ) ( struct inode * ) ; } ;
struct writeback_control ;
struct iov_iter { const struct iovec * iov ; unsigned long nr_segs ; size_t iov_offset ; size_t count ; } ;
struct file_ra_state { unsigned long start ; unsigned int size ; unsigned int async_size ; unsigned int ra_pages ; unsigned int mmap_miss ; loff_t prev_pos ; } ;
struct block_device_operations ;
struct filename { const char * name ; const char * uptr ; struct audit_names * aname ; K_bool separate ; } ;
struct simple_transaction_argresp { ssize_t size ; char data [ 0 ] ; } ;
struct kcore_list { struct list_head list ; unsigned long addr ; size_t size ; int type ; } ;
struct vmcore { struct list_head list ; unsigned long long paddr ; unsigned long long size ; loff_t offset ; } ;
struct nsproxy ;
typedef __signalfn_t * __sighandler_t ;
typedef __restorefn_t * __sigrestore_t ;
struct sigpending { struct list_head list ; sigset_t signal ; } ;
struct pnp_card_device_id { __u8 id [ 8 ] ; kernel_ulong_t driver_data ; struct { __u8 id [ 8 ] ; } devs [ 8 ] ; } ;
struct pci_cap_saved_state { struct hlist_node next ; struct pci_cap_saved_data cap ; } ;
struct pci_ops { int ( * read ) ( struct pci_bus * bus , unsigned int devfn , int where , int size , u32 * val ) ; int ( * write ) ( struct pci_bus * bus , unsigned int devfn , int where , int size , u32 val ) ; } ;
struct scatterlist { unsigned long page_link ; unsigned int offset ; unsigned int length ; dma_addr_t dma_address ; unsigned int dma_length ; } ;
struct vm_region { struct rb_node vm_rb ; vm_flags_t vm_flags ; unsigned long vm_start ; unsigned long vm_end ; unsigned long vm_top ; unsigned long vm_pgoff ; struct file * vm_file ; int vm_usage ; K_bool vm_icache_flushed : 1 ; } ;
struct file_ra_state ;
struct writeback_control ;
struct kvec ;
typedef struct scatterlist * ( sg_alloc_fn ) ( unsigned int , gfp_t ) ;
struct sg_mapping_iter { struct page * page ; void * addr ; size_t length ; size_t consumed ; struct scatterlist * __sg ; unsigned int __nents ; unsigned int __offset ; unsigned int __flags ; } ;
struct scatterlist ;
struct scatterlist ;
struct pci_setup_rom { struct setup_data data ; K_uint16_t vendor ; K_uint16_t devid ; K_uint64_t pcilen ; unsigned long segment ; unsigned long bus ; unsigned long device ; unsigned long function ; K_uint8_t romdata [ 0 ] ; } ;
struct ipc64_perm { __kernel_key_t key ; __kernel_uid32_t uid ; __kernel_gid32_t gid ; __kernel_uid32_t cuid ; __kernel_gid32_t cgid ; __kernel_mode_t mode ; unsigned char __pad1 [ 4 - sizeof ( __kernel_mode_t ) ] ; unsigned short seq ; unsigned short __pad2 ; unsigned long __unused1 ; unsigned long __unused2 ; } ;
struct semid_ds { struct ipc_perm sem_perm ; __kernel_time_t sem_otime ; __kernel_time_t sem_ctime ; struct sem * sem_base ; struct sem_queue * sem_pending ; struct sem_queue * * sem_pending_last ; struct sem_undo * undo ; unsigned short sem_nsems ; } ;
struct rusage { struct timeval ru_utime ; struct timeval ru_stime ; long ru_maxrss ; long ru_ixrss ; long ru_idrss ; long ru_isrss ; long ru_minflt ; long ru_majflt ; long ru_nswap ; long ru_inblock ; long ru_oublock ; long ru_msgsnd ; long ru_msgrcv ; long ru_nsignals ; long ru_nvcsw ; long ru_nivcsw ; } ;
typedef K_int32_t key_serial_t ;
typedef K_uint32_t key_perm_t ;
struct exec_domain ;
struct nsproxy ;
struct kvec { void * iov_base ; size_t iov_len ; } ;
struct aio_ring { unsigned id ; unsigned nr ; unsigned head ; unsigned tail ; unsigned magic ; unsigned compat_features ; unsigned incompat_features ; unsigned header_length ; struct io_event io_events [ 0 ] ; } ;
struct sched_group_power { atomic_t ref ; unsigned int power , power_orig ; unsigned long next_update ; atomic_t nr_busy_cpus ; unsigned long cpumask [ 0 ] ; } ;
struct sched_group { struct sched_group * next ; atomic_t ref ; unsigned int group_weight ; struct sched_group_power * sgp ; unsigned long cpumask [ 0 ] ; } ;
struct sched_entity { struct load_weight load ; struct rb_node run_node ; struct list_head group_node ; unsigned int on_rq ; u64 exec_start ; u64 sum_exec_runtime ; u64 vruntime ; u64 prev_sum_exec_runtime ; u64 nr_migrations ; struct sched_statistics statistics ; struct sched_entity * parent ; struct cfs_rq * cfs_rq ; struct cfs_rq * my_q ; struct sched_avg avg ; } ;
struct irq_data ;
struct irq_data { unsigned int irq ; unsigned long hwirq ; unsigned int node ; unsigned int state_use_accessors ; struct irq_chip * chip ; struct irq_domain * domain ; void * handler_data ; void * chip_data ; struct msi_desc * msi_desc ; cpumask_var_t affinity ; } ;
struct irq_cfg { struct irq_pin_list * irq_2_pin ; cpumask_var_t domain ; cpumask_var_t old_domain ; u8 vector ; u8 move_in_progress : 1 ; struct irq_2_iommu irq_2_iommu ; } ;
struct irq_data ;
struct irqaction ;
struct irqaction { irq_handler_t handler ; void * dev_id ; void * percpu_dev_id ; struct irqaction * next ; irq_handler_t thread_fn ; struct task_struct * thread ; unsigned int irq ; unsigned int flags ; unsigned long thread_flags ; unsigned long thread_mask ; const char * name ; struct proc_dir_entry * dir ; } __attribute__ ( ( __aligned__ ( 1 << ( 6 ) ) ) ) ;
struct tasklet_struct { struct tasklet_struct * next ; unsigned long state ; atomic_t count ; void ( * func ) ( unsigned long ) ; unsigned long data ; } ;
struct miscdevice { int minor ; const char * name ; const struct file_operations * fops ; struct list_head list ; struct device * parent ; struct device * this_device ; const char * nodename ; umode_t mode ; } ;
struct dev_pm_qos { struct pm_qos_constraints latency ; struct pm_qos_flags flags ; struct dev_pm_qos_request * latency_req ; struct dev_pm_qos_request * flags_req ; } ;
struct data_chunk { size_t size ; size_t icg ; } ;
struct dma_chan { struct dma_device * device ; dma_cookie_t cookie ; dma_cookie_t completed_cookie ; int chan_id ; struct dma_chan_dev * dev ; struct list_head device_node ; struct dma_chan_percpu * local ; int client_count ; int table_count ; void * private_ ; } ;
struct dma_slave_config { enum dma_transfer_direction direction ; dma_addr_t src_addr ; dma_addr_t dst_addr ; enum dma_slave_buswidth src_addr_width ; enum dma_slave_buswidth dst_addr_width ; u32 src_maxburst ; u32 dst_maxburst ; K_bool device_fc ; unsigned int slave_id ; } ;
struct dma_tx_state { dma_cookie_t last ; dma_cookie_t used ; u32 residue ; } ;
struct pid ;
struct sockaddr { sa_family_t sa_family ; char sa_data [ 14 ] ; } ;
struct mmsghdr { struct msghdr msg_hdr ; unsigned int msg_len ; } ;
struct user32 { struct user_regs_struct32 regs ; int u_fpvalid ; struct user_i387_ia32_struct i387 ; __u32 u_tsize ; __u32 u_dsize ; __u32 u_ssize ; __u32 start_code ; __u32 start_stack ; __u32 signal ; int reserved ; __u32 u_ar0 ; __u32 u_fpstate ; __u32 magic ; char u_comm [ 32 ] ; int u_debugreg [ 8 ] ; } ;
typedef __kernel_fsid_t compat_fsid_t ;
struct compat_timespec { compat_time_t tv_sec ; s32 tv_nsec ; } ;
struct compat_timeval { compat_time_t tv_sec ; s32 tv_usec ; } ;
struct compat_stat { compat_dev_t st_dev ; u16 __pad1 ; compat_ino_t st_ino ; compat_mode_t st_mode ; compat_nlink_t st_nlink ; __compat_uid_t st_uid ; __compat_gid_t st_gid ; compat_dev_t st_rdev ; u16 __pad2 ; u32 st_size ; u32 st_blksize ; u32 st_blocks ; u32 st_atime ; u32 st_atime_nsec ; u32 st_mtime ; u32 st_mtime_nsec ; u32 st_ctime ; u32 st_ctime_nsec ; u32 __unused4 ; u32 __unused5 ; } ;
struct compat_flock { short l_type ; short l_whence ; compat_off_t l_start ; compat_off_t l_len ; compat_pid_t l_pid ; } ;
struct compat_flock64 { short l_type ; short l_whence ; compat_loff_t l_start ; compat_loff_t l_len ; compat_pid_t l_pid ; } __attribute__ ( ( packed ) ) ;
struct compat_ipc64_perm { compat_key_t key ; __compat_uid32_t uid ; __compat_gid32_t gid ; __compat_uid32_t cuid ; __compat_gid32_t cgid ; unsigned short mode ; unsigned short __pad1 ; unsigned short seq ; unsigned short __pad2 ; compat_ulong_t unused1 ; compat_ulong_t unused2 ; } ;
typedef __compat_uid32_t compat_uid_t ;
typedef __compat_gid32_t compat_gid_t ;
struct rusage ;
struct compat_utimbuf { compat_time_t actime ; compat_time_t modtime ; } ;
struct compat_tms { compat_clock_t tms_utime ; compat_clock_t tms_stime ; compat_clock_t tms_cutime ; compat_clock_t tms_cstime ; } ;
struct compat_iovec { compat_uptr_t iov_base ; compat_size_t iov_len ; } ;
struct compat_rlimit { compat_ulong_t rlim_cur ; compat_ulong_t rlim_max ; } ;
struct compat_dirent { u32 d_ino ; compat_off_t d_off ; u16 d_reclen ; char d_name [ 256 ] ; } ;
struct compat_ustat { compat_daddr_t f_tfree ; compat_ino_t f_tinode ; char f_fname [ 6 ] ; char f_fpack [ 6 ] ; } ;
struct compat_ifmap { compat_ulong_t mem_start ; compat_ulong_t mem_end ; unsigned short base_addr ; unsigned char irq ; unsigned char dma ; unsigned char port ; } ;
struct compat_if_settings { unsigned int type ; unsigned int size ; compat_uptr_t ifs_ifsu ; } ;
struct compat_ifconf { compat_int_t ifc_len ; compat_caddr_t ifcbuf ; } ;
struct compat_robust_list { compat_uptr_t next ; } ;
struct compat_statfs64 ;
struct poll_table_struct ;
struct sockaddr ;
struct kvec ;
struct ts_config ;
struct ts_ops { const char * name ; struct ts_config * ( * init ) ( const void * , unsigned int , gfp_t , int ) ; unsigned int ( * find ) ( struct ts_config * , struct ts_state * ) ; void ( * destroy ) ( struct ts_config * ) ; void * ( * get_pattern ) ( struct ts_config * ) ; unsigned int ( * get_pattern_len ) ( struct ts_config * ) ; struct module * owner ; struct list_head list ; } ;
struct ts_config { struct ts_ops * ops ; int flags ; unsigned int ( * get_next_block ) ( unsigned int consumed , const u8 * * dst , struct ts_config * conf , struct ts_state * state ) ; void ( * finish ) ( struct ts_config * conf , struct ts_state * state ) ; } ;
struct scatterlist ;
struct nf_conntrack { atomic_t use ; } ;
struct nf_bridge_info { atomic_t use ; unsigned int mask ; struct net_device * physindev ; struct net_device * physoutdev ; unsigned long data [ 32 / sizeof ( unsigned long ) ] ; } ;
struct ethhdr { unsigned char h_dest [ 6 ] ; unsigned char h_source [ 6 ] ; __be16 h_proto ; } __attribute__ ( ( packed ) ) ;
struct ethtool_tcpip4_spec { __be32 ip4src ; __be32 ip4dst ; __be16 psrc ; __be16 pdst ; __u8 tos ; } ;
struct ethtool_ah_espip4_spec { __be32 ip4src ; __be32 ip4dst ; __be32 spi ; __u8 tos ; } ;
struct ethtool_usrip4_spec { __be32 ip4src ; __be32 ip4dst ; __be32 l4_4_bytes ; __u8 tos ; __u8 ip_ver ; __u8 proto ; } ;
struct ethtool_flow_ext { __u8 padding [ 2 ] ; unsigned char h_dest [ 6 ] ; __be16 vlan_etype ; __be16 vlan_tci ; __be32 data [ 2 ] ; } ;
struct ethtool_gfeatures { __u32 cmd ; __u32 size ; struct ethtool_get_features_block features [ 0 ] ; } ;
struct ethtool_sfeatures { __u32 cmd ; __u32 size ; struct ethtool_set_features_block features [ 0 ] ; } ;
struct ethtool_ops { int ( * get_settings ) ( struct net_device * , struct ethtool_cmd * ) ; int ( * set_settings ) ( struct net_device * , struct ethtool_cmd * ) ; void ( * get_drvinfo ) ( struct net_device * , struct ethtool_drvinfo * ) ; int ( * get_regs_len ) ( struct net_device * ) ; void ( * get_regs ) ( struct net_device * , struct ethtool_regs * , void * ) ; void ( * get_wol ) ( struct net_device * , struct ethtool_wolinfo * ) ; int ( * set_wol ) ( struct net_device * , struct ethtool_wolinfo * ) ; u32 ( * get_msglevel ) ( struct net_device * ) ; void ( * set_msglevel ) ( struct net_device * , u32 ) ; int ( * nway_reset ) ( struct net_device * ) ; u32 ( * get_link ) ( struct net_device * ) ; int ( * get_eeprom_len ) ( struct net_device * ) ; int ( * get_eeprom ) ( struct net_device * , struct ethtool_eeprom * , u8 * ) ; int ( * set_eeprom ) ( struct net_device * , struct ethtool_eeprom * , u8 * ) ; int ( * get_coalesce ) ( struct net_device * , struct ethtool_coalesce * ) ; int ( * set_coalesce ) ( struct net_device * , struct ethtool_coalesce * ) ; void ( * get_ringparam ) ( struct net_device * , struct ethtool_ringparam * ) ; int ( * set_ringparam ) ( struct net_device * , struct ethtool_ringparam * ) ; void ( * get_pauseparam ) ( struct net_device * , struct ethtool_pauseparam * ) ; int ( * set_pauseparam ) ( struct net_device * , struct ethtool_pauseparam * ) ; void ( * self_test ) ( struct net_device * , struct ethtool_test * , u64 * ) ; void ( * get_strings ) ( struct net_device * , u32 stringset , u8 * ) ; int ( * set_phys_id ) ( struct net_device * , enum ethtool_phys_id_state ) ; void ( * get_ethtool_stats ) ( struct net_device * , struct ethtool_stats * , u64 * ) ; int ( * begin ) ( struct net_device * ) ; void ( * complete ) ( struct net_device * ) ; u32 ( * get_priv_flags ) ( struct net_device * ) ; int ( * set_priv_flags ) ( struct net_device * , u32 ) ; int ( * get_sset_count ) ( struct net_device * , int ) ; int ( * get_rxnfc ) ( struct net_device * , struct ethtool_rxnfc * , u32 * rule_locs ) ; int ( * set_rxnfc ) ( struct net_device * , struct ethtool_rxnfc * ) ; int ( * flash_device ) ( struct net_device * , struct ethtool_flash * ) ; int ( * reset ) ( struct net_device * , u32 * ) ; u32 ( * get_rxfh_indir_size ) ( struct net_device * ) ; int ( * get_rxfh_indir ) ( struct net_device * , u32 * ) ; int ( * set_rxfh_indir ) ( struct net_device * , const u32 * ) ; void ( * get_channels ) ( struct net_device * , struct ethtool_channels * ) ; int ( * set_channels ) ( struct net_device * , struct ethtool_channels * ) ; int ( * get_dump_flag ) ( struct net_device * , struct ethtool_dump * ) ; int ( * get_dump_data ) ( struct net_device * , struct ethtool_dump * , void * ) ; int ( * set_dump ) ( struct net_device * , struct ethtool_dump * ) ; int ( * get_ts_info ) ( struct net_device * , struct ethtool_ts_info * ) ; int ( * get_module_info ) ( struct net_device * , struct ethtool_modinfo * ) ; int ( * get_module_eeprom ) ( struct net_device * , struct ethtool_eeprom * , u8 * ) ; int ( * get_eee ) ( struct net_device * , struct ethtool_eee * ) ; int ( * set_eee ) ( struct net_device * , struct ethtool_eee * ) ; } ;
struct netns_frags { int nqueues ; atomic_t mem ; struct list_head lru_list ; int timeout ; int high_thresh ; int low_thresh ; } ;
struct dst_entry ;
struct in_addr { __be32 s_addr ; } ;
struct ip_mreq_source { __be32 imr_multiaddr ; __be32 imr_interface ; __be32 imr_sourceaddr ; } ;
struct ip_msfilter { __be32 imsf_multiaddr ; __be32 imsf_interface ; __u32 imsf_fmode ; __u32 imsf_numsrc ; __be32 imsf_slist [ 1 ] ; } ;
struct group_req { __u32 gr_interface ; struct __kernel_sockaddr_storage gr_group ; } ;
struct group_source_req { __u32 gsr_interface ; struct __kernel_sockaddr_storage gsr_group ; struct __kernel_sockaddr_storage gsr_source ; } ;
struct group_filter { __u32 gf_interface ; struct __kernel_sockaddr_storage gf_group ; __u32 gf_fmode ; __u32 gf_numsrc ; struct __kernel_sockaddr_storage gf_slist [ 1 ] ; } ;
typedef unsigned int nf_hookfn ( unsigned int hooknum , struct sk_buff * skb , const struct net_device * in , const struct net_device * out , int ( * okfn ) ( struct sk_buff * ) ) ;
struct nf_sockopt_ops { struct list_head list ; u_int8_t pf ; int set_optmin ; int set_optmax ; int ( * set ) ( struct sock * sk , int optval , void * user , unsigned int len ) ; int ( * compat_set ) ( struct sock * sk , int optval , void * user , unsigned int len ) ; int get_optmin ; int get_optmax ; int ( * get ) ( struct sock * sk , int optval , void * user , int * len ) ; int ( * compat_get ) ( struct sock * sk , int optval , void * user , int * len ) ; struct module * owner ; } ;
typedef struct flow_cache_object * ( * flow_resolve_t ) ( struct net * net , const struct flowi * key , u16 family , u8 dir , struct flow_cache_object * oldobj , void * ctx ) ;
struct nfq_ct_nat_hook { void ( * seq_adjust ) ( struct sk_buff * skb , struct nf_conn * ct , u32 ctinfo , int off ) ; } ;
struct netns_xt { struct list_head tables [ NFPROTO_NUMPROTO ] ; K_bool notrack_deprecated_warning ; struct ebt_table * broute_table ; struct ebt_table * frame_filter ; struct ebt_table * frame_nat ; } ;
struct ip_ct_tcp_state { u_int32_t td_end ; u_int32_t td_maxend ; u_int32_t td_maxwin ; u_int32_t td_maxack ; u_int8_t td_scale ; u_int8_t flags ; } ;
struct nf_ip_net { struct nf_generic_net generic ; struct nf_tcp_net tcp ; struct nf_udp_net udp ; struct nf_icmp_net icmp ; struct nf_icmp_net icmpv6 ; struct ctl_table_header * ctl_table_header ; struct ctl_table * ctl_table ; } ;
struct pernet_operations { struct list_head list ; int ( * init ) ( struct net * net ) ; void ( * exit ) ( struct net * net ) ; void ( * exit_batch ) ( struct list_head * net_exit_list ) ; int * id ; size_t size ; } ;
struct dcb_app_type { int ifindex ; struct dcb_app app ; struct list_head list ; u8 dcbx ; } ;
struct dcbnl_rtnl_ops { int ( * ieee_getets ) ( struct net_device * , struct ieee_ets * ) ; int ( * ieee_setets ) ( struct net_device * , struct ieee_ets * ) ; int ( * ieee_getmaxrate ) ( struct net_device * , struct ieee_maxrate * ) ; int ( * ieee_setmaxrate ) ( struct net_device * , struct ieee_maxrate * ) ; int ( * ieee_getpfc ) ( struct net_device * , struct ieee_pfc * ) ; int ( * ieee_setpfc ) ( struct net_device * , struct ieee_pfc * ) ; int ( * ieee_getapp ) ( struct net_device * , struct dcb_app * ) ; int ( * ieee_setapp ) ( struct net_device * , struct dcb_app * ) ; int ( * ieee_delapp ) ( struct net_device * , struct dcb_app * ) ; int ( * ieee_peer_getets ) ( struct net_device * , struct ieee_ets * ) ; int ( * ieee_peer_getpfc ) ( struct net_device * , struct ieee_pfc * ) ; u8 ( * getstate ) ( struct net_device * ) ; u8 ( * setstate ) ( struct net_device * , u8 ) ; void ( * getpermhwaddr ) ( struct net_device * , u8 * ) ; void ( * setpgtccfgtx ) ( struct net_device * , int , u8 , u8 , u8 , u8 ) ; void ( * setpgbwgcfgtx ) ( struct net_device * , int , u8 ) ; void ( * setpgtccfgrx ) ( struct net_device * , int , u8 , u8 , u8 , u8 ) ; void ( * setpgbwgcfgrx ) ( struct net_device * , int , u8 ) ; void ( * getpgtccfgtx ) ( struct net_device * , int , u8 * , u8 * , u8 * , u8 * ) ; void ( * getpgbwgcfgtx ) ( struct net_device * , int , u8 * ) ; void ( * getpgtccfgrx ) ( struct net_device * , int , u8 * , u8 * , u8 * , u8 * ) ; void ( * getpgbwgcfgrx ) ( struct net_device * , int , u8 * ) ; void ( * setpfccfg ) ( struct net_device * , int , u8 ) ; void ( * getpfccfg ) ( struct net_device * , int , u8 * ) ; u8 ( * setall ) ( struct net_device * ) ; u8 ( * getcap ) ( struct net_device * , int , u8 * ) ; int ( * getnumtcs ) ( struct net_device * , int , u8 * ) ; int ( * setnumtcs ) ( struct net_device * , int , u8 ) ; u8 ( * getpfcstate ) ( struct net_device * ) ; void ( * setpfcstate ) ( struct net_device * , u8 ) ; void ( * getbcncfg ) ( struct net_device * , int , u32 * ) ; void ( * setbcncfg ) ( struct net_device * , int , u32 ) ; void ( * getbcnrp ) ( struct net_device * , int , u8 * ) ; void ( * setbcnrp ) ( struct net_device * , int , u8 ) ; u8 ( * setapp ) ( struct net_device * , u8 , u16 , u8 ) ; u8 ( * getapp ) ( struct net_device * , u8 , u16 ) ; u8 ( * getfeatcfg ) ( struct net_device * , int , u8 * ) ; u8 ( * setfeatcfg ) ( struct net_device * , int , u8 ) ; u8 ( * getdcbx ) ( struct net_device * ) ; u8 ( * setdcbx ) ( struct net_device * , u8 ) ; int ( * peer_getappinfo ) ( struct net_device * , struct dcb_peer_app_info * , u16 * ) ; int ( * peer_getapptable ) ( struct net_device * , struct dcb_app * ) ; int ( * cee_peer_getpg ) ( struct net_device * , struct cee_pg * ) ; int ( * cee_peer_getpfc ) ( struct net_device * , struct cee_pfc * ) ; } ;
struct idr_layer { unsigned long bitmap ; struct idr_layer * ary [ 1 << 6 ] ; int count ; int layer ; struct callback_head callback_head ; } ;
struct xattr { char * name ; void * value ; size_t value_len ; } ;
struct simple_xattr { struct list_head list ; char * name ; size_t size ; char value [ 0 ] ; } ;
struct css_set { atomic_t refcount ; struct hlist_node hlist ; struct list_head tasks ; struct list_head cg_links ; struct cgroup_subsys_state * subsys [ CGROUP_SUBSYS_COUNT ] ; struct callback_head callback_head ; } ;
struct cgroup_map_cb { int ( * fill ) ( struct cgroup_map_cb * cb , const char * key , u64 value ) ; void * state ; } ;
struct xattr ;
struct sockaddr ;
struct dst_entry ;
struct nsproxy { atomic_t count ; struct uts_namespace * uts_ns ; struct ipc_namespace * ipc_ns ; struct mnt_namespace * mnt_ns ; struct pid_namespace * pid_ns ; struct net * net_ns ; } ;
struct nlmsgerr { int error ; struct nlmsghdr msg ; } ;
struct sockaddr_pkt { unsigned short spkt_family ; unsigned char spkt_device [ 14 ] ; __be16 spkt_protocol ; } ;
struct sockaddr_ll { unsigned short sll_family ; __be16 sll_protocol ; int sll_ifindex ; unsigned short sll_hatype ; unsigned char sll_pkttype ; unsigned char sll_halen ; unsigned char sll_addr [ 8 ] ; } ;
struct tpacket_hdr_v1 { __u32 block_status ; __u32 num_pkts ; __u32 offset_to_first_pkt ; __u32 blk_len ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) seq_num ; struct tpacket_bd_ts ts_first_pkt , ts_last_pkt ; } ;
struct ifla_vxlan_port_range { __be16 low ; __be16 high ; } ;
struct neigh_parms ;
struct netdev_hw_addr { struct list_head list ; unsigned char addr [ 32 ] ; unsigned char type ; K_bool synced ; K_bool global_use ; int refcount ; struct callback_head callback_head ; } ;
struct rps_map { unsigned int len ; struct callback_head rcu ; u16 cpus [ 0 ] ; } ;
struct xps_map { unsigned int len ; unsigned int alloc_len ; struct callback_head rcu ; u16 queues [ 0 ] ; } ;
struct xps_dev_maps { struct callback_head rcu ; struct xps_map * cpu_map [ 0 ] ; } ;
struct vlan_hdr { __be16 h_vlan_TCI ; __be16 h_vlan_encapsulated_proto ; } ;
struct vlan_ethhdr { unsigned char h_dest [ 6 ] ; unsigned char h_source [ 6 ] ; __be16 h_vlan_proto ; __be16 h_vlan_TCI ; __be16 h_vlan_encapsulated_proto ; } ;
struct firmware { size_t size ; const u8 * data ; struct page * * pages ; void * priv ; } ;
struct iphdr { __u8 ihl : 4 , version : 4 ; __u8 tos ; __be16 tot_len ; __be16 id ; __be16 frag_off ; __u8 ttl ; __u8 protocol ; __sum16 check ; __be32 saddr ; __be32 daddr ; } ;
struct ip_auth_hdr { __u8 nexthdr ; __u8 hdrlen ; __be16 reserved ; __be32 spi ; __be32 seq_no ; __u8 auth_data [ 0 ] ; } ;
struct ip_esp_hdr { __be32 spi ; __be32 seq_no ; __u8 enc_data [ 0 ] ; } ;
struct ip_comp_hdr { __u8 nexthdr ; __u8 flags ; __be16 cpi ; } ;
struct compat_sock_fprog { u16 len ; compat_uptr_t filter ; } ;
struct sk_filter { atomic_t refcnt ; unsigned int len ; unsigned int ( * bpf_func ) ( const struct sk_buff * skb , const struct sock_filter * filter ) ; struct callback_head rcu ; struct sock_filter insns [ 0 ] ; } ;
struct poll_table_struct ;
typedef u16 ( * rtnl_calcit_func ) ( struct sk_buff * , struct nlmsghdr * ) ;
struct neigh_parms { struct net * net ; struct net_device * dev ; struct neigh_parms * next ; int ( * neigh_setup ) ( struct neighbour * ) ; void ( * neigh_cleanup ) ( struct neighbour * ) ; struct neigh_table * tbl ; void * sysctl_table ; int dead ; atomic_t refcnt ; struct callback_head callback_head ; int base_reachable_time ; int retrans_time ; int gc_staletime ; int reachable_time ; int delay_probe_time ; int queue_len_bytes ; int ucast_probes ; int app_probes ; int mcast_probes ; int anycast_delay ; int proxy_delay ; int proxy_qlen ; int locktime ; } ;
struct neigh_hash_table { struct neighbour * * hash_buckets ; unsigned int hash_shift ; __u32 hash_rnd [ 4 ] ; struct callback_head rcu ; } ;
struct dst_entry { struct callback_head callback_head ; struct dst_entry * child ; struct net_device * dev ; struct dst_ops * ops ; unsigned long _metrics ; unsigned long expires ; struct dst_entry * path ; struct dst_entry * from ; struct xfrm_state * xfrm ; int ( * input ) ( struct sk_buff * ) ; int ( * output ) ( struct sk_buff * ) ; unsigned short flags ; unsigned short pending_confirm ; short error ; short obsolete ; unsigned short header_len ; unsigned short trailer_len ; __u32 tclassid ; long __pad_to_align_refcnt [ 2 ] ; atomic_t __refcnt ; int __use ; unsigned long lastuse ; union { struct dst_entry * next ; struct rtable * rt_next ; struct rt6_info * rt6_next ; struct dn_route * dn_next ; } ; } ;
struct sock_iocb { struct list_head list ; int flags ; int size ; struct socket * sock ; struct sock * sk ; struct scm_cookie * scm ; struct msghdr * msg , async_msg ; struct kiocb * kiocb ; } ;
struct dst_entry ;
struct ip_options { __be32 faddr ; __be32 nexthop ; unsigned char optlen ; unsigned char srr ; unsigned char rr ; unsigned char ts ; unsigned char is_strictroute : 1 , srr_is_hit : 1 , is_changed : 1 , rr_needaddr : 1 , ts_needtime : 1 , ts_needaddr : 1 ; unsigned char router_alert ; unsigned char cipso ; unsigned char __pad2 ; unsigned char __data [ 0 ] ; } ;
struct inet_request_sock { struct request_sock req ; u16 inet6_rsk_offset ; __be16 loc_port ; __be32 loc_addr ; __be32 rmt_addr ; __be16 rmt_port ; ; u16 snd_wscale : 4 , rcv_wscale : 4 , tstamp_ok : 1 , sack_ok : 1 , wscale_ok : 1 , ecn_ok : 1 , acked : 1 , no_srccheck : 1 ; ; struct ip_options_rcu * opt ; } ;
struct inet_cork { unsigned int flags ; __be32 addr ; struct ip_options * opt ; unsigned int fragsize ; int length ; struct dst_entry * dst ; u8 tx_flags ; } ;
struct tcphdr { __be16 source ; __be16 dest ; __be32 seq ; __be32 ack_seq ; __u16 res1 : 4 , doff : 4 , fin : 1 , syn : 1 , rst : 1 , psh : 1 , ack : 1 , urg : 1 , ece : 1 , cwr : 1 ; __be16 window ; __sum16 check ; __be16 urg_ptr ; } ;
enum { TCP_FLAG_CWR = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00800000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00800000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00800000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00800000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) , TCP_FLAG_ECE = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00400000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00400000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00400000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00400000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) , TCP_FLAG_URG = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00200000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00200000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00200000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00200000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) , TCP_FLAG_ACK = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00100000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00100000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00100000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00100000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) , TCP_FLAG_PSH = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00080000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00080000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00080000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00080000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) , TCP_FLAG_RST = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00040000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00040000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00040000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00040000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) , TCP_FLAG_SYN = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00020000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00020000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00020000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00020000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) , TCP_FLAG_FIN = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00010000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00010000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00010000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00010000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) , TCP_RESERVED_BITS = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x0F000000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x0F000000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x0F000000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x0F000000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) , TCP_DATA_OFFSET = ( ( __be32 ) ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0xF0000000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0xF0000000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0xF0000000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0xF0000000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) ) } ;
struct tcp_md5sig { struct __kernel_sockaddr_storage tcpm_addr ; __u16 __tcpm_pad1 ; __u16 tcpm_keylen ; __u32 __tcpm_pad2 ; __u8 tcpm_key [ 80 ] ; } ;
struct tcp_sack_block_wire { __be32 start_seq ; __be32 end_seq ; } ;
struct udphdr { __be16 source ; __be16 dest ; __be16 len ; __sum16 check ; } ;
struct tc_tbf_qopt { struct tc_ratespec rate ; struct tc_ratespec peakrate ; __u32 limit ; __u32 buffer ; __u32 mtu ; } ;
struct tc_htb_opt { struct tc_ratespec rate ; struct tc_ratespec ceil ; __u32 buffer ; __u32 cbuffer ; __u32 quantum ; __u32 level ; __u32 prio ; } ;
struct tc_police { __u32 index ; int action ; __u32 limit ; __u32 burst ; __u32 mtu ; struct tc_ratespec rate ; struct tc_ratespec peakrate ; int refcnt ; int bindcnt ; __u32 capab ; } ;
struct tc_u32_key { __be32 mask ; __be32 val ; int off ; int offmask ; } ;
struct tc_rsvp_pinfo { struct tc_rsvp_gpi dpi ; struct tc_rsvp_gpi spi ; __u8 protocol ; __u8 tunnelid ; __u8 tunnelhdr ; __u8 pad ; } ;
struct qdisc_rate_table { struct tc_ratespec rate ; u32 data [ 256 ] ; struct qdisc_rate_table * next ; int refcnt ; } ;
struct qdisc_size_table { struct callback_head rcu ; struct list_head list ; struct tc_sizespec szopts ; int refcnt ; u16 data [ ] ; } ;
struct Qdisc_class_ops { struct netdev_queue * ( * select_queue ) ( struct Qdisc * , struct tcmsg * ) ; int ( * graft ) ( struct Qdisc * , unsigned long cl , struct Qdisc * , struct Qdisc * * ) ; struct Qdisc * ( * leaf ) ( struct Qdisc * , unsigned long cl ) ; void ( * qlen_notify ) ( struct Qdisc * , unsigned long ) ; unsigned long ( * get ) ( struct Qdisc * , u32 classid ) ; void ( * put ) ( struct Qdisc * , unsigned long ) ; int ( * change ) ( struct Qdisc * , u32 , u32 , struct nlattr * * , unsigned long * ) ; int ( * delete_ ) ( struct Qdisc * , unsigned long ) ; void ( * walk ) ( struct Qdisc * , struct qdisc_walker * arg ) ; struct tcf_proto * * ( * tcf_chain ) ( struct Qdisc * , unsigned long ) ; unsigned long ( * bind_tcf ) ( struct Qdisc * , unsigned long , u32 classid ) ; void ( * unbind_tcf ) ( struct Qdisc * , unsigned long ) ; int ( * dump ) ( struct Qdisc * , unsigned long , struct sk_buff * skb , struct tcmsg * ) ; int ( * dump_stats ) ( struct Qdisc * , unsigned long , struct gnet_dump * ) ; } ;
struct tcf_proto_ops { struct tcf_proto_ops * next ; char kind [ 16 ] ; int ( * classify ) ( struct sk_buff * , const struct tcf_proto * , struct tcf_result * ) ; int ( * init ) ( struct tcf_proto * ) ; void ( * destroy ) ( struct tcf_proto * ) ; unsigned long ( * get ) ( struct tcf_proto * , u32 handle ) ; void ( * put ) ( struct tcf_proto * , unsigned long ) ; int ( * change ) ( struct sk_buff * , struct tcf_proto * , unsigned long , u32 handle , struct nlattr * * , unsigned long * ) ; int ( * delete_ ) ( struct tcf_proto * , unsigned long ) ; void ( * walk ) ( struct tcf_proto * , struct tcf_walker * arg ) ; int ( * dump ) ( struct tcf_proto * , unsigned long , struct sk_buff * skb , struct tcmsg * ) ; struct module * owner ; } ;
struct tcf_proto { struct tcf_proto * next ; void * root ; int ( * classify ) ( struct sk_buff * , const struct tcf_proto * , struct tcf_result * ) ; __be16 protocol ; u32 prio ; u32 classid ; struct Qdisc * q ; void * data ; const struct tcf_proto_ops * ops ; } ;
struct partition { unsigned char boot_ind ; unsigned char head ; unsigned char sector ; unsigned char cyl ; unsigned char sys_ind ; unsigned char end_head ; unsigned char end_sector ; unsigned char end_cyl ; __le32 start_sect ; __le32 nr_sects ; } __attribute__ ( ( packed ) ) ;
struct disk_part_tbl { struct callback_head callback_head ; int len ; struct hd_struct * last_lookup ; struct hd_struct * part [ ] ; } ;
struct solaris_x86_slice { __le16 s_tag ; __le16 s_flag ; __le32 s_start ; __le32 s_size ; } ;
struct unixware_slice { __le16 s_label ; __le16 s_flags ; __le32 start_sect ; __le32 nr_sects ; } ;
struct writeback_control { long nr_to_write ; long pages_skipped ; loff_t range_start ; loff_t range_end ; enum writeback_sync_modes sync_mode ; unsigned for_kupdate : 1 ; unsigned for_background : 1 ; unsigned tagged_writepages : 1 ; unsigned for_reclaim : 1 ; unsigned range_cyclic : 1 ; } ;
typedef void * ( mempool_alloc_t ) ( gfp_t gfp_mask , void * pool_data ) ;
typedef int ( elevator_set_req_fn ) ( struct request_queue * , struct request * , struct bio * , gfp_t ) ;
struct blk_queue_tag { struct request * * tag_index ; unsigned long * tag_map ; int busy ; int max_depth ; int real_max_depth ; atomic_t refcnt ; } ;
struct block_device_operations { int ( * open ) ( struct block_device * , fmode_t ) ; int ( * release ) ( struct gendisk * , fmode_t ) ; int ( * ioctl ) ( struct block_device * , fmode_t , unsigned , unsigned long ) ; int ( * compat_ioctl ) ( struct block_device * , fmode_t , unsigned , unsigned long ) ; int ( * direct_access ) ( struct block_device * , sector_t , void * * , unsigned long * ) ; unsigned int ( * check_events ) ( struct gendisk * disk , unsigned int clearing ) ; int ( * media_changed ) ( struct gendisk * ) ; void ( * unlock_native_capacity ) ( struct gendisk * ) ; int ( * revalidate_disk ) ( struct gendisk * ) ; int ( * getgeo ) ( struct block_device * , struct hd_geometry * ) ; void ( * swap_slot_free_notify ) ( struct block_device * , unsigned long ) ; struct module * owner ; } ;
struct buffer_head ;
struct buffer_head { unsigned long b_state ; struct buffer_head * b_this_page ; struct page * b_page ; sector_t b_blocknr ; size_t b_size ; char * b_data ; struct block_device * b_bdev ; bh_end_io_t * b_end_io ; void * b_private ; struct list_head b_assoc_buffers ; struct address_space * b_assoc_map ; atomic_t b_count ; } ;
struct buffer_head ;
struct scatterlist ;
struct crypto_async_request ;
struct crypto_async_request { struct list_head list ; crypto_completion_t complete ; void * data ; struct crypto_tfm * tfm ; u32 flags ; } ;
struct cipher_desc { struct crypto_tfm * tfm ; void ( * crfn ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; unsigned int ( * prfn ) ( const struct cipher_desc * desc , u8 * dst , const u8 * src , unsigned int nbytes ) ; void * info ; } ;
struct ablkcipher_alg { int ( * setkey ) ( struct crypto_ablkcipher * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct ablkcipher_request * req ) ; int ( * decrypt ) ( struct ablkcipher_request * req ) ; int ( * givencrypt ) ( struct skcipher_givcrypt_request * req ) ; int ( * givdecrypt ) ( struct skcipher_givcrypt_request * req ) ; const char * geniv ; unsigned int min_keysize ; unsigned int max_keysize ; unsigned int ivsize ; } ;
struct aead_alg { int ( * setkey ) ( struct crypto_aead * tfm , const u8 * key , unsigned int keylen ) ; int ( * setauthsize ) ( struct crypto_aead * tfm , unsigned int authsize ) ; int ( * encrypt ) ( struct aead_request * req ) ; int ( * decrypt ) ( struct aead_request * req ) ; int ( * givencrypt ) ( struct aead_givcrypt_request * req ) ; int ( * givdecrypt ) ( struct aead_givcrypt_request * req ) ; const char * geniv ; unsigned int ivsize ; unsigned int maxauthsize ; } ;
struct blkcipher_alg { int ( * setkey ) ( struct crypto_tfm * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) ; int ( * decrypt ) ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) ; const char * geniv ; unsigned int min_keysize ; unsigned int max_keysize ; unsigned int ivsize ; } ;
struct cipher_alg { unsigned int cia_min_keysize ; unsigned int cia_max_keysize ; int ( * cia_setkey ) ( struct crypto_tfm * tfm , const u8 * key , unsigned int keylen ) ; void ( * cia_encrypt ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; void ( * cia_decrypt ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; } ;
struct compress_alg { int ( * coa_compress ) ( struct crypto_tfm * tfm , const u8 * src , unsigned int slen , u8 * dst , unsigned int * dlen ) ; int ( * coa_decompress ) ( struct crypto_tfm * tfm , const u8 * src , unsigned int slen , u8 * dst , unsigned int * dlen ) ; } ;
struct rng_alg { int ( * rng_make_random ) ( struct crypto_rng * tfm , u8 * rdata , unsigned int dlen ) ; int ( * rng_reset ) ( struct crypto_rng * tfm , u8 * seed , unsigned int slen ) ; unsigned int seedsize ; } ;
struct ablkcipher_tfm { int ( * setkey ) ( struct crypto_ablkcipher * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct ablkcipher_request * req ) ; int ( * decrypt ) ( struct ablkcipher_request * req ) ; int ( * givencrypt ) ( struct skcipher_givcrypt_request * req ) ; int ( * givdecrypt ) ( struct skcipher_givcrypt_request * req ) ; struct crypto_ablkcipher * base ; unsigned int ivsize ; unsigned int reqsize ; } ;
struct aead_tfm { int ( * setkey ) ( struct crypto_aead * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct aead_request * req ) ; int ( * decrypt ) ( struct aead_request * req ) ; int ( * givencrypt ) ( struct aead_givcrypt_request * req ) ; int ( * givdecrypt ) ( struct aead_givcrypt_request * req ) ; struct crypto_aead * base ; unsigned int ivsize ; unsigned int authsize ; unsigned int reqsize ; } ;
struct blkcipher_tfm { void * iv ; int ( * setkey ) ( struct crypto_tfm * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) ; int ( * decrypt ) ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) ; } ;
struct cipher_tfm { int ( * cit_setkey ) ( struct crypto_tfm * tfm , const u8 * key , unsigned int keylen ) ; void ( * cit_encrypt_one ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; void ( * cit_decrypt_one ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; } ;
struct hash_tfm { int ( * init ) ( struct hash_desc * desc ) ; int ( * update ) ( struct hash_desc * desc , struct scatterlist * sg , unsigned int nsg ) ; int ( * final ) ( struct hash_desc * desc , u8 * out ) ; int ( * digest ) ( struct hash_desc * desc , struct scatterlist * sg , unsigned int nsg , u8 * out ) ; int ( * setkey ) ( struct crypto_hash * tfm , const u8 * key , unsigned int keylen ) ; unsigned int digestsize ; } ;
struct compress_tfm { int ( * cot_compress ) ( struct crypto_tfm * tfm , const u8 * src , unsigned int slen , u8 * dst , unsigned int * dlen ) ; int ( * cot_decompress ) ( struct crypto_tfm * tfm , const u8 * src , unsigned int slen , u8 * dst , unsigned int * dlen ) ; } ;
struct rng_tfm { int ( * rng_gen_random ) ( struct crypto_rng * tfm , u8 * rdata , unsigned int dlen ) ; int ( * rng_reset ) ( struct crypto_rng * tfm , u8 * seed , unsigned int slen ) ; } ;
struct commit_header { __be32 h_magic ; __be32 h_blocktype ; __be32 h_sequence ; unsigned char h_chksum_type ; unsigned char h_chksum_size ; unsigned char h_padding [ 2 ] ; __be32 h_chksum [ ( 32 / sizeof ( u32 ) ) ] ; __be64 h_commit_sec ; __be32 h_commit_nsec ; } ;
struct jbd2_journal_block_tail { __be32 t_checksum ; } ;
struct jbd2_journal_revoke_tail { __be32 r_checksum ; } ;
struct transaction_stats_s { unsigned long ts_tid ; struct transaction_run_stats_s run ; } ;
struct writeback_control ;
struct bio ;
union swap_header { struct { char reserved [ ( ( 1UL ) << 12 ) - 10 ] ; char magic [ 10 ] ; } magic ; struct { char bootbits [ 1024 ] ; __u32 version ; __u32 last_page ; __u32 nr_badpages ; unsigned char sws_uuid [ 16 ] ; unsigned char sws_volume [ 16 ] ; __u32 padding [ 117 ] ; __u32 badpages [ 1 ] ; } info ; } ;
struct writeback_control ;
struct swap_info_struct { unsigned long flags ; signed short prio ; signed char type ; signed char next ; unsigned int max ; unsigned char * swap_map ; unsigned int lowest_bit ; unsigned int highest_bit ; unsigned int pages ; unsigned int inuse_pages ; unsigned int cluster_next ; unsigned int cluster_nr ; unsigned int lowest_alloc ; unsigned int highest_alloc ; struct swap_extent * curr_swap_extent ; struct swap_extent first_swap_extent ; struct block_device * bdev ; struct file * swap_file ; unsigned int old_block_size ; } ;
struct statfs { long f_type ; long f_bsize ; long f_blocks ; long f_bfree ; long f_bavail ; long f_files ; long f_ffree ; __kernel_fsid_t f_fsid ; long f_namelen ; long f_frsize ; long f_flags ; long f_spare [ 4 ] ; } ;
struct statfs64 { long f_type ; long f_bsize ; __u64 f_blocks ; __u64 f_bfree ; __u64 f_bavail ; __u64 f_files ; __u64 f_ffree ; __kernel_fsid_t f_fsid ; long f_namelen ; long f_frsize ; long f_flags ; long f_spare [ 4 ] ; } ;
struct compat_statfs64 { __u32 f_type ; __u32 f_bsize ; __u64 f_blocks ; __u64 f_bfree ; __u64 f_bavail ; __u64 f_files ; __u64 f_ffree ; __kernel_fsid_t f_fsid ; __u32 f_namelen ; __u32 f_frsize ; __u32 f_flags ; __u32 f_spare [ 4 ] ; } __attribute__ ( ( packed , aligned ( 4 ) ) ) ;
typedef __kernel_fsid_t fsid_t ;
struct kstatfs { long f_type ; long f_bsize ; u64 f_blocks ; u64 f_bfree ; u64 f_bavail ; u64 f_files ; u64 f_ffree ; __kernel_fsid_t f_fsid ; long f_namelen ; long f_frsize ; long f_flags ; long f_spare [ 4 ] ; } ;
typedef struct match_token match_table_t [ ] ;
typedef struct { char * from ; char * to ; } substring_t ;
struct export_operations { int ( * encode_fh ) ( struct inode * inode , __u32 * fh , int * max_len , struct inode * parent ) ; struct dentry * ( * fh_to_dentry ) ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type ) ; struct dentry * ( * fh_to_parent ) ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type ) ; int ( * get_name ) ( struct dentry * parent , char * name , struct dentry * child ) ; struct dentry * ( * get_parent ) ( struct dentry * child ) ; int ( * commit_metadata ) ( struct inode * inode ) ; } ;
struct ata_bmdma_prd { __le32 addr ; __le32 flags_len ; } ;
struct scsi_varlen_cdb_hdr { __u8 opcode ; __u8 control ; __u8 misc [ 5 ] ; __u8 additional_cdb_length ; __be16 service_action ; } ;
struct acpi_bus_type ;
struct acpi_buffer { acpi_size length ; void * pointer ; } ;
typedef u32 ( * acpi_osd_handler ) ( void * context ) ;
typedef void ( * acpi_gbl_event_handler ) ( u32 event_type , acpi_handle device , u32 event_number , void * context ) ;
typedef u32 ( * acpi_event_handler ) ( void * context ) ;
typedef u32 ( * acpi_gpe_handler ) ( acpi_handle gpe_device , u32 gpe_number , void * context ) ;
typedef void ( * acpi_notify_handler ) ( acpi_handle device , u32 value , void * context ) ;
typedef void ( * acpi_object_handler ) ( acpi_handle object , void * data ) ;
typedef u32 ( * acpi_interface_handler ) ( acpi_string interface_name , u32 supported ) ;
struct acpi_pnp_device_id_list { u32 count ; u32 list_size ; struct acpi_pnp_device_id ids [ 1 ] ; } ;
struct acpi_mem_space_context { u32 length ; acpi_physical_address address ; acpi_physical_address mapped_physical_address ; u8 * mapped_logical_address ; acpi_size mapped_length ; } ;
struct acpi_table_rsdt { struct acpi_table_header header ; u32 table_offset_entry [ 1 ] ; } ;
struct acpi_table_xsdt { struct acpi_table_header header ; u64 table_offset_entry [ 1 ] ; } ;
struct acpi_table_fadt { struct acpi_table_header header ; u32 facs ; u32 dsdt ; u8 model ; u8 preferred_profile ; u16 sci_interrupt ; u32 smi_command ; u8 acpi_enable ; u8 acpi_disable ; u8 s4_bios_request ; u8 pstate_control ; u32 pm1a_event_block ; u32 pm1b_event_block ; u32 pm1a_control_block ; u32 pm1b_control_block ; u32 pm2_control_block ; u32 pm_timer_block ; u32 gpe0_block ; u32 gpe1_block ; u8 pm1_event_length ; u8 pm1_control_length ; u8 pm2_control_length ; u8 pm_timer_length ; u8 gpe0_block_length ; u8 gpe1_block_length ; u8 gpe1_base ; u8 cst_control ; u16 c2_latency ; u16 c3_latency ; u16 flush_size ; u16 flush_stride ; u8 duty_offset ; u8 duty_width ; u8 day_alarm ; u8 month_alarm ; u8 century ; u16 boot_flags ; u8 reserved ; u32 flags ; struct acpi_generic_address reset_register ; u8 reset_value ; u8 reserved4 [ 3 ] ; u64 Xfacs ; u64 Xdsdt ; struct acpi_generic_address xpm1a_event_block ; struct acpi_generic_address xpm1b_event_block ; struct acpi_generic_address xpm1a_control_block ; struct acpi_generic_address xpm1b_control_block ; struct acpi_generic_address xpm2_control_block ; struct acpi_generic_address xpm_timer_block ; struct acpi_generic_address xgpe0_block ; struct acpi_generic_address xgpe1_block ; struct acpi_generic_address sleep_control ; struct acpi_generic_address sleep_status ; } ;
struct acpi_table_desc { acpi_physical_address address ; struct acpi_table_header * pointer ; u32 length ; union acpi_name_union signature ; acpi_owner_id owner_id ; u8 flags ; } ;
struct acpi_whea_header { u8 action ; u8 instruction ; u8 flags ; u8 reserved ; struct acpi_generic_address register_region ; u64 value ; u64 mask ; } ;
struct acpi_table_bert { struct acpi_table_header header ; u32 region_length ; u64 address ; } ;
struct acpi_table_cpep { struct acpi_table_header header ; u64 reserved ; } ;
struct acpi_cpep_polling { struct acpi_subtable_header header ; u8 id ; u8 eid ; u32 interval ; } ;
struct acpi_table_ecdt { struct acpi_table_header header ; struct acpi_generic_address control ; struct acpi_generic_address data ; u32 uid ; u8 gpe ; u8 id [ 1 ] ; } ;
struct acpi_table_einj { struct acpi_table_header header ; u32 header_length ; u8 flags ; u8 reserved [ 3 ] ; u32 entries ; } ;
struct acpi_table_erst { struct acpi_table_header header ; u32 header_length ; u32 reserved ; u32 entries ; } ;
struct acpi_table_hest { struct acpi_table_header header ; u32 error_source_count ; } ;
struct acpi_hest_ia_machine_check { struct acpi_hest_header header ; u16 reserved1 ; u8 flags ; u8 enabled ; u32 records_to_preallocate ; u32 max_sections_per_record ; u64 global_capability_data ; u64 global_control_data ; u8 num_hardware_banks ; u8 reserved3 [ 7 ] ; } ;
struct acpi_hest_ia_corrected { struct acpi_hest_header header ; u16 reserved1 ; u8 flags ; u8 enabled ; u32 records_to_preallocate ; u32 max_sections_per_record ; struct acpi_hest_notify notify ; u8 num_hardware_banks ; u8 reserved2 [ 3 ] ; } ;
struct acpi_hest_ia_nmi { struct acpi_hest_header header ; u32 reserved ; u32 records_to_preallocate ; u32 max_sections_per_record ; u32 max_raw_data_length ; } ;
struct acpi_hest_aer_root { struct acpi_hest_header header ; struct acpi_hest_aer_common aer ; u32 root_error_command ; } ;
struct acpi_hest_aer { struct acpi_hest_header header ; struct acpi_hest_aer_common aer ; } ;
struct acpi_hest_aer_bridge { struct acpi_hest_header header ; struct acpi_hest_aer_common aer ; u32 uncorrectable_mask2 ; u32 uncorrectable_severity2 ; u32 advanced_capabilities2 ; } ;
struct acpi_hest_generic { struct acpi_hest_header header ; u16 related_source_id ; u8 reserved ; u8 enabled ; u32 records_to_preallocate ; u32 max_sections_per_record ; u32 max_raw_data_length ; struct acpi_generic_address error_status_address ; struct acpi_hest_notify notify ; u32 error_block_length ; } ;
struct acpi_table_madt { struct acpi_table_header header ; u32 address ; u32 flags ; } ;
struct acpi_madt_local_apic { struct acpi_subtable_header header ; u8 processor_id ; u8 id ; u32 lapic_flags ; } ;
struct acpi_madt_io_apic { struct acpi_subtable_header header ; u8 id ; u8 reserved ; u32 address ; u32 global_irq_base ; } ;
struct acpi_madt_interrupt_override { struct acpi_subtable_header header ; u8 bus ; u8 source_irq ; u32 global_irq ; u16 inti_flags ; } ;
struct acpi_madt_nmi_source { struct acpi_subtable_header header ; u16 inti_flags ; u32 global_irq ; } ;
struct acpi_madt_local_apic_nmi { struct acpi_subtable_header header ; u8 processor_id ; u16 inti_flags ; u8 lint ; } ;
struct acpi_madt_local_apic_override { struct acpi_subtable_header header ; u16 reserved ; u64 address ; } ;
struct acpi_madt_io_sapic { struct acpi_subtable_header header ; u8 id ; u8 reserved ; u32 global_irq_base ; u64 address ; } ;
struct acpi_madt_local_sapic { struct acpi_subtable_header header ; u8 processor_id ; u8 id ; u8 eid ; u8 reserved [ 3 ] ; u32 lapic_flags ; u32 uid ; char uid_string [ 1 ] ; } ;
struct acpi_madt_interrupt_source { struct acpi_subtable_header header ; u16 inti_flags ; u8 type ; u8 id ; u8 eid ; u8 io_sapic_vector ; u32 global_irq ; u32 flags ; } ;
struct acpi_madt_local_x2apic { struct acpi_subtable_header header ; u16 reserved ; u32 local_apic_id ; u32 lapic_flags ; u32 uid ; } ;
struct acpi_madt_local_x2apic_nmi { struct acpi_subtable_header header ; u16 inti_flags ; u32 uid ; u8 lint ; u8 reserved [ 3 ] ; } ;
struct acpi_madt_generic_interrupt { struct acpi_subtable_header header ; u16 reserved ; u32 gic_id ; u32 uid ; u32 flags ; u32 parking_version ; u32 performance_interrupt ; u64 parked_address ; u64 base_address ; } ;
struct acpi_madt_generic_distributor { struct acpi_subtable_header header ; u16 reserved ; u32 gic_id ; u64 base_address ; u32 global_irq_base ; u32 reserved2 ; } ;
struct acpi_table_msct { struct acpi_table_header header ; u32 proximity_offset ; u32 max_proximity_domains ; u32 max_clock_domains ; u64 max_address ; } ;
struct acpi_table_sbst { struct acpi_table_header header ; u32 warning_level ; u32 low_level ; u32 critical_level ; } ;
struct acpi_table_slit { struct acpi_table_header header ; u64 locality_count ; u8 entry [ 1 ] ; } ;
struct acpi_table_srat { struct acpi_table_header header ; u32 table_revision ; u64 reserved ; } ;
struct acpi_srat_cpu_affinity { struct acpi_subtable_header header ; u8 proximity_domain_lo ; u8 apic_id ; u32 flags ; u8 local_sapic_eid ; u8 proximity_domain_hi [ 3 ] ; u32 reserved ; } ;
struct acpi_srat_mem_affinity { struct acpi_subtable_header header ; u32 proximity_domain ; u16 reserved ; u64 base_address ; u64 length ; u32 reserved1 ; u32 flags ; u64 reserved2 ; } ;
struct acpi_srat_x2apic_cpu_affinity { struct acpi_subtable_header header ; u16 reserved ; u32 proximity_domain ; u32 apic_id ; u32 flags ; u32 clock_domain ; u32 reserved2 ; } ;
struct acpi_table_asf { struct acpi_table_header header ; } ;
struct acpi_asf_info { struct acpi_asf_header header ; u8 min_reset_value ; u8 min_poll_interval ; u16 system_id ; u32 mfg_id ; u8 flags ; u8 reserved2 [ 3 ] ; } ;
struct acpi_asf_alert { struct acpi_asf_header header ; u8 assert_mask ; u8 deassert_mask ; u8 alerts ; u8 data_length ; } ;
struct acpi_asf_remote { struct acpi_asf_header header ; u8 controls ; u8 data_length ; u16 reserved2 ; } ;
struct acpi_asf_rmcp { struct acpi_asf_header header ; u8 capabilities [ 7 ] ; u8 completion_code ; u32 enterprise_id ; u8 command ; u16 parameter ; u16 boot_options ; u16 oem_parameters ; } ;
struct acpi_asf_address { struct acpi_asf_header header ; u8 eprom_address ; u8 devices ; } ;
struct acpi_table_boot { struct acpi_table_header header ; u8 cmos_index ; u8 reserved [ 3 ] ; } ;
struct acpi_table_csrt { struct acpi_table_header header ; } ;
struct acpi_table_dbg2 { struct acpi_table_header header ; u32 info_offset ; u32 info_count ; } ;
struct acpi_table_dbgp { struct acpi_table_header header ; u8 type ; u8 reserved [ 3 ] ; struct acpi_generic_address debug_port ; } ;
struct acpi_table_dmar { struct acpi_table_header header ; u8 width ; u8 flags ; u8 reserved [ 10 ] ; } ;
struct acpi_dmar_hardware_unit { struct acpi_dmar_header header ; u8 flags ; u8 reserved ; u16 segment ; u64 address ; } ;
struct acpi_dmar_reserved_memory { struct acpi_dmar_header header ; u16 reserved ; u16 segment ; u64 base_address ; u64 end_address ; } ;
struct acpi_dmar_atsr { struct acpi_dmar_header header ; u8 flags ; u8 reserved ; u16 segment ; } ;
struct acpi_dmar_rhsa { struct acpi_dmar_header header ; u32 reserved ; u64 base_address ; u32 proximity_domain ; } ;
struct acpi_table_hpet { struct acpi_table_header header ; u32 id ; struct acpi_generic_address address ; u8 sequence ; u16 minimum_tick ; u8 flags ; } ;
struct acpi_table_ibft { struct acpi_table_header header ; u8 reserved [ 12 ] ; } ;
struct acpi_ibft_control { struct acpi_ibft_header header ; u16 extensions ; u16 initiator_offset ; u16 nic0_offset ; u16 target0_offset ; u16 nic1_offset ; u16 target1_offset ; } ;
struct acpi_ibft_initiator { struct acpi_ibft_header header ; u8 sns_server [ 16 ] ; u8 slp_server [ 16 ] ; u8 primary_server [ 16 ] ; u8 secondary_server [ 16 ] ; u16 name_length ; u16 name_offset ; } ;
struct acpi_ibft_nic { struct acpi_ibft_header header ; u8 ip_address [ 16 ] ; u8 subnet_mask_prefix ; u8 origin ; u8 gateway [ 16 ] ; u8 primary_dns [ 16 ] ; u8 secondary_dns [ 16 ] ; u8 dhcp [ 16 ] ; u16 vlan ; u8 mac_address [ 6 ] ; u16 pci_address ; u16 name_length ; u16 name_offset ; } ;
struct acpi_ibft_target { struct acpi_ibft_header header ; u8 target_ip_address [ 16 ] ; u16 target_ip_socket ; u8 target_boot_lun [ 8 ] ; u8 chap_type ; u8 nic_association ; u16 target_name_length ; u16 target_name_offset ; u16 chap_name_length ; u16 chap_name_offset ; u16 chap_secret_length ; u16 chap_secret_offset ; u16 reverse_chap_name_length ; u16 reverse_chap_name_offset ; u16 reverse_chap_secret_length ; u16 reverse_chap_secret_offset ; } ;
struct acpi_table_ivrs { struct acpi_table_header header ; u32 info ; u64 reserved ; } ;
struct acpi_ivrs_hardware { struct acpi_ivrs_header header ; u16 capability_offset ; u64 base_address ; u16 pci_segment_group ; u16 info ; u32 reserved ; } ;
struct acpi_ivrs_device4 { struct acpi_ivrs_de_header header ; } ;
struct acpi_ivrs_device8a { struct acpi_ivrs_de_header header ; u8 reserved1 ; u16 used_id ; u8 reserved2 ; } ;
struct acpi_ivrs_device8b { struct acpi_ivrs_de_header header ; u32 extended_data ; } ;
struct acpi_ivrs_device8c { struct acpi_ivrs_de_header header ; u8 handle ; u16 used_id ; u8 variety ; } ;
struct acpi_ivrs_memory { struct acpi_ivrs_header header ; u16 aux_data ; u64 reserved ; u64 start_address ; u64 memory_length ; } ;
struct acpi_table_mcfg { struct acpi_table_header header ; u8 reserved [ 8 ] ; } ;
struct acpi_table_mchi { struct acpi_table_header header ; u8 interface_type ; u8 protocol ; u64 protocol_data ; u8 interrupt_type ; u8 gpe ; u8 pci_device_flag ; u32 global_interrupt ; struct acpi_generic_address control_register ; u8 pci_segment ; u8 pci_bus ; u8 pci_device ; u8 pci_function ; } ;
struct acpi_table_slic { struct acpi_table_header header ; } ;
struct acpi_slic_key { struct acpi_slic_header header ; u8 key_type ; u8 version ; u16 reserved ; u32 algorithm ; char magic [ 4 ] ; u32 bit_length ; u32 exponent ; u8 modulus [ 128 ] ; } ;
struct acpi_slic_marker { struct acpi_slic_header header ; u32 version ; char oem_id [ 6 ] ; char oem_table_id [ 8 ] ; char windows_flag [ 8 ] ; u32 slic_version ; u8 reserved [ 16 ] ; u8 signature [ 128 ] ; } ;
struct acpi_table_spcr { struct acpi_table_header header ; u8 interface_type ; u8 reserved [ 3 ] ; struct acpi_generic_address serial_port ; u8 interrupt_type ; u8 pc_interrupt ; u32 interrupt ; u8 baud_rate ; u8 parity ; u8 stop_bits ; u8 flow_control ; u8 terminal_type ; u8 reserved1 ; u16 pci_device_id ; u16 pci_vendor_id ; u8 pci_bus ; u8 pci_device ; u8 pci_function ; u32 pci_flags ; u8 pci_segment ; u32 reserved2 ; } ;
struct acpi_table_spmi { struct acpi_table_header header ; u8 interface_type ; u8 reserved ; u16 spec_revision ; u8 interrupt_type ; u8 gpe_number ; u8 reserved1 ; u8 pci_device_flag ; u32 interrupt ; struct acpi_generic_address ipmi_register ; u8 pci_segment ; u8 pci_bus ; u8 pci_device ; u8 pci_function ; u8 reserved2 ; } ;
struct acpi_table_tcpa { struct acpi_table_header header ; u16 reserved ; u32 max_log_length ; u64 log_address ; } ;
struct acpi_table_uefi { struct acpi_table_header header ; u8 identifier [ 16 ] ; u16 data_offset ; } ;
struct acpi_table_waet { struct acpi_table_header header ; u32 flags ; } ;
struct acpi_table_wdat { struct acpi_table_header header ; u32 header_length ; u16 pci_segment ; u8 pci_bus ; u8 pci_device ; u8 pci_function ; u8 reserved [ 3 ] ; u32 timer_period ; u32 max_count ; u32 min_count ; u8 flags ; u8 reserved2 [ 3 ] ; u32 entries ; } ;
struct acpi_wdat_entry { u8 action ; u8 instruction ; u16 reserved ; struct acpi_generic_address register_region ; u32 value ; u32 mask ; } ;
struct acpi_table_wddt { struct acpi_table_header header ; u16 spec_version ; u16 table_version ; u16 pci_vendor_id ; struct acpi_generic_address address ; u16 max_count ; u16 min_count ; u16 period ; u16 status ; u16 capability ; } ;
struct acpi_table_wdrt { struct acpi_table_header header ; struct acpi_generic_address control_register ; struct acpi_generic_address count_register ; u16 pci_device_id ; u16 pci_vendor_id ; u8 pci_bus ; u8 pci_device ; u8 pci_function ; u8 pci_segment ; u16 max_count ; u8 units ; } ;
struct acpi_table_bgrt { struct acpi_table_header header ; u16 version ; u8 status ; u8 image_type ; u64 image_address ; u32 image_offset_x ; u32 image_offset_y ; } ;
struct acpi_table_drtm { struct acpi_table_header header ; u64 entry_base_address ; u64 entry_length ; u32 entry_address32 ; u64 entry_address64 ; u64 exit_address ; u64 log_area_address ; u32 log_area_length ; u64 arch_dependent_address ; u32 flags ; } ;
struct acpi_table_fpdt { struct acpi_table_header header ; } ;
struct acpi_fpdt_boot { struct acpi_fpdt_header header ; u8 reserved [ 4 ] ; u64 reset_end ; u64 load_start ; u64 startup_start ; u64 exit_services_entry ; u64 exit_services_exit ; } ;
struct acpi_fpdt_s3pt_ptr { struct acpi_fpdt_header header ; u8 reserved [ 4 ] ; u64 address ; } ;
struct acpi_s3pt_resume { struct acpi_s3pt_header header ; u32 resume_count ; u64 full_resume ; u64 average_resume ; } ;
struct acpi_s3pt_suspend { struct acpi_s3pt_header header ; u64 suspend_start ; u64 suspend_end ; } ;
struct acpi_table_gtdt { struct acpi_table_header header ; u64 address ; u32 flags ; u32 secure_pl1_interrupt ; u32 secure_pl1_flags ; u32 non_secure_pl1_interrupt ; u32 non_secure_pl1_flags ; u32 virtual_timer_interrupt ; u32 virtual_timer_flags ; u32 non_secure_pl2_interrupt ; u32 non_secure_pl2_flags ; } ;
struct acpi_table_mpst { struct acpi_table_header header ; u8 channel_id ; u8 reserved1 [ 3 ] ; u16 power_node_count ; u16 reserved2 ; } ;
struct acpi_table_pcct { struct acpi_table_header header ; u32 flags ; u32 latency ; u32 reserved ; } ;
struct acpi_pcct_subspace { struct acpi_subtable_header header ; u8 reserved [ 6 ] ; u64 base_address ; u64 length ; struct acpi_generic_address doorbell_register ; u64 preserve_mask ; u64 write_mask ; } ;
struct acpi_table_pmtt { struct acpi_table_header header ; u32 reserved ; } ;
struct acpi_pmtt_socket { struct acpi_pmtt_header header ; u16 socket_id ; u16 reserved ; } ;
struct acpi_pmtt_controller { struct acpi_pmtt_header header ; u32 read_latency ; u32 write_latency ; u32 read_bandwidth ; u32 write_bandwidth ; u16 access_width ; u16 alignment ; u16 reserved ; u16 domain_count ; } ;
struct acpi_pmtt_physical_component { struct acpi_pmtt_header header ; u16 component_id ; u16 reserved ; u32 memory_size ; u32 bios_handle ; } ;
struct acpi_table_rasf { struct acpi_table_header header ; u8 channel_id [ 12 ] ; } ;
union acpi_resource_attribute { struct acpi_memory_attribute mem ; struct acpi_io_attribute io ; u8 type_specific ; } ;
struct acpi_resource_extended_irq { u8 producer_consumer ; u8 triggering ; u8 polarity ; u8 sharable ; u8 interrupt_count ; struct acpi_resource_source resource_source ; u32 interrupts [ 1 ] ; } ;
struct acpi_resource_gpio { u8 revision_id ; u8 connection_type ; u8 producer_consumer ; u8 pin_config ; u8 sharable ; u8 io_restriction ; u8 triggering ; u8 polarity ; u16 drive_strength ; u16 debounce_timeout ; u16 pin_table_length ; u16 vendor_length ; struct acpi_resource_source resource_source ; u16 * pin_table ; u8 * vendor_data ; } ;
struct acpi_resource_common_serialbus { u8 revision_id ; u8 type ; u8 producer_consumer ; u8 slave_mode ; u8 type_revision_id ; u16 type_data_length ; u16 vendor_length ; struct acpi_resource_source resource_source ; u8 * vendor_data ; } ;
struct acpi_resource_i2c_serialbus { u8 revision_id ; u8 type ; u8 producer_consumer ; u8 slave_mode ; u8 type_revision_id ; u16 type_data_length ; u16 vendor_length ; struct acpi_resource_source resource_source ; u8 * vendor_data ; u8 access_mode ; u16 slave_address ; u32 connection_speed ; } ;
struct acpi_resource_spi_serialbus { u8 revision_id ; u8 type ; u8 producer_consumer ; u8 slave_mode ; u8 type_revision_id ; u16 type_data_length ; u16 vendor_length ; struct acpi_resource_source resource_source ; u8 * vendor_data ; u8 wire_mode ; u8 device_polarity ; u8 data_bit_length ; u8 clock_phase ; u8 clock_polarity ; u16 device_selection ; u32 connection_speed ; } ;
struct acpi_resource_uart_serialbus { u8 revision_id ; u8 type ; u8 producer_consumer ; u8 slave_mode ; u8 type_revision_id ; u16 type_data_length ; u16 vendor_length ; struct acpi_resource_source resource_source ; u8 * vendor_data ; u8 endian ; u8 data_bits ; u8 stop_bits ; u8 flow_control ; u8 parity ; u8 lines_enabled ; u16 rx_fifo_size ; u16 tx_fifo_size ; u32 default_baud_rate ; } ;
typedef void ( * acpi_op_notify ) ( struct acpi_device * device , u32 event ) ;
struct acpi_bus_ops { u32 acpi_op_add : 1 ; u32 acpi_op_start : 1 ; } ;
struct acpi_device_power_state { struct { u8 valid : 1 ; u8 os_accessible : 1 ; u8 explicit_set : 1 ; u8 reserved : 6 ; } flags ; int power ; int latency ; struct acpi_handle_list resources ; } ;
struct acpi_device_perf_state { struct { u8 valid : 1 ; u8 reserved : 7 ; } flags ; u8 power ; u8 performance ; int latency ; } ;
struct acpi_device_perf { int state ; struct acpi_device_perf_flags flags ; int state_count ; struct acpi_device_perf_state * states ; } ;
struct acpi_device_wakeup { acpi_handle gpe_device ; u64 gpe_number ; u64 sleep_state ; struct acpi_handle_list resources ; struct acpi_device_wakeup_flags flags ; int prepare_count ; } ;
struct acpi_bus_type { struct list_head list ; struct bus_type * bus ; int ( * find_device ) ( struct device * , acpi_handle * ) ; int ( * find_bridge ) ( struct device * , acpi_handle * ) ; } ;
typedef void ( * wmi_notify_handler ) ( u32 value , void * context ) ;
union cdrom_addr { struct cdrom_msf0 msf ; int lba ; } ;
struct dvd_physical { __u8 type ; __u8 layer_num ; struct dvd_layer layer [ 4 ] ; } ;
struct dvd_host_send_challenge { __u8 type ; unsigned agid : 2 ; dvd_challenge chal ; } ;
struct dvd_send_key { __u8 type ; unsigned agid : 2 ; dvd_key key ; } ;
struct dvd_lu_send_challenge { __u8 type ; unsigned agid : 2 ; dvd_challenge chal ; } ;
struct dvd_lu_send_title_key { __u8 type ; unsigned agid : 2 ; dvd_key title_key ; int lba ; unsigned cpm : 1 ; unsigned cp_sec : 1 ; unsigned cgms : 2 ; } ;
struct mrw_feature_desc { __be16 feature_code ; __u8 curr : 1 ; __u8 persistent : 1 ; __u8 feature_version : 4 ; __u8 reserved1 : 2 ; __u8 add_len ; __u8 write : 1 ; __u8 reserved2 : 7 ; __u8 reserved3 ; __u8 reserved4 ; __u8 reserved5 ; } ;
struct rwrt_feature_desc { __be16 feature_code ; __u8 curr : 1 ; __u8 persistent : 1 ; __u8 feature_version : 4 ; __u8 reserved1 : 2 ; __u8 add_len ; __u32 last_lba ; __u32 block_size ; __u16 blocking ; __u8 page_present : 1 ; __u8 reserved2 : 7 ; __u8 reserved3 ; } ;
struct mode_page_header { __be16 mode_data_length ; __u8 medium_type ; __u8 reserved1 ; __u8 reserved2 ; __u8 reserved3 ; __be16 desc_length ; } ;
struct cdrom_changer_info { struct cdrom_mechstat_header hdr ; struct cdrom_slot slots [ 256 ] ; } ;
typedef struct { __u16 report_key_length ; __u8 reserved1 ; __u8 reserved2 ; __u8 ucca : 3 ; __u8 vra : 3 ; __u8 type_code : 2 ; __u8 region_mask ; __u8 rpc_scheme ; __u8 reserved3 ; } rpc_state_t ;
struct event_header { __be16 data_len ; __u8 notification_class : 3 ; __u8 reserved1 : 4 ; __u8 nea : 1 ; __u8 supp_event_class ; } ;
struct ata_ering { int cursor ; struct ata_ering_entry ring [ ATA_ERING_SIZE ] ; } ;
struct ata_eh_context { struct ata_eh_info i ; int tries [ ATA_MAX_DEVICES ] ; int cmd_timeout_idx [ ATA_MAX_DEVICES ] [ ATA_EH_CMD_TIMEOUT_TABLE_SIZE ] ; unsigned int classes [ ATA_MAX_DEVICES ] ; unsigned int did_probe_mask ; unsigned int unloaded_mask ; unsigned int saved_ncq_enabled ; u8 saved_xfer_mode [ ATA_MAX_DEVICES ] ; unsigned long last_reset ; } ;
struct ata_acpi_gtm { struct ata_acpi_drive drive [ 2 ] ; u32 flags ; } __attribute__ ( ( packed ) ) ;
struct input_event { struct timeval time ; __u16 type ; __u16 code ; __s32 value ; } ;
struct ff_constant_effect { __s16 level ; struct ff_envelope envelope ; } ;
struct ff_ramp_effect { __s16 start_level ; __s16 end_level ; struct ff_envelope envelope ; } ;
struct ff_periodic_effect { __u16 waveform ; __u16 period ; __s16 magnitude ; __s16 offset ; __u16 phase ; struct ff_envelope envelope ; __u32 custom_len ; __s16 * custom_data ; } ;
struct pnp_card_link { struct pnp_card * card ; struct pnp_card_driver * driver ; void * driver_data ; pm_message_t pm_state ; } ;
struct desc_struct { union { struct { unsigned int a ; unsigned int b ; } ; struct { u16 limit0 ; u16 base0 ; unsigned base1 : 8 , type : 4 , s : 1 , dpl : 2 , p : 1 ; unsigned limit : 4 , avl : 1 , l : 1 , d : 1 , g : 1 , base2 : 8 ; } ; } ; } __attribute__ ( ( packed ) ) ;
struct desc_struct ;
struct _fpstate { __u16 cwd ; __u16 swd ; __u16 twd ; __u16 fop ; __u64 rip ; __u64 rdp ; __u32 mxcsr ; __u32 mxcsr_mask ; __u32 st_space [ 32 ] ; __u32 xmm_space [ 64 ] ; __u32 reserved2 [ 12 ] ; union { __u32 reserved3 [ 12 ] ; struct _fpx_sw_bytes sw_reserved ; } ; } ;
struct msr { union { struct { u32 l ; u32 h ; } ; u64 q ; } ; } ;
struct i387_fxsave_struct { u16 cwd ; u16 swd ; u16 twd ; u16 fop ; union { struct { u64 rip ; u64 rdp ; } ; struct { u32 fip ; u32 fcs ; u32 foo ; u32 fos ; } ; } ; u32 mxcsr ; u32 mxcsr_mask ; u32 st_space [ 32 ] ; u32 xmm_space [ 64 ] ; u32 padding [ 12 ] ; union { u32 padding1 [ 12 ] ; u32 sw_reserved [ 12 ] ; } ; } __attribute__ ( ( aligned ( 16 ) ) ) ;
typedef uid_t kuid_t ;
typedef gid_t kgid_t ;
struct work_struct ;
struct work_struct { atomic_long_t data ; struct list_head entry ; work_func_t func ; } ;
struct edd_device_params { __u16 length ; __u16 info_flags ; __u32 num_default_cylinders ; __u32 num_default_heads ; __u32 sectors_per_track ; __u64 number_of_sectors ; __u16 bytes_per_sector ; __u32 dpte_ptr ; __u16 key ; __u8 device_path_info_length ; __u8 reserved2 ; __u16 reserved3 ; __u8 host_bus_type [ 4 ] ; __u8 interface_type [ 8 ] ; union { struct { __u16 base_address ; __u16 reserved1 ; __u32 reserved2 ; } __attribute__ ( ( packed ) ) isa ; struct { __u8 bus ; __u8 slot ; __u8 function ; __u8 channel ; __u32 reserved ; } __attribute__ ( ( packed ) ) pci ; struct { __u64 reserved ; } __attribute__ ( ( packed ) ) ibnd ; struct { __u64 reserved ; } __attribute__ ( ( packed ) ) xprs ; struct { __u64 reserved ; } __attribute__ ( ( packed ) ) htpt ; struct { __u64 reserved ; } __attribute__ ( ( packed ) ) unknown ; } interface_path ; union { struct { __u8 device ; __u8 reserved1 ; __u16 reserved2 ; __u32 reserved3 ; __u64 reserved4 ; } __attribute__ ( ( packed ) ) ata ; struct { __u8 device ; __u8 lun ; __u8 reserved1 ; __u8 reserved2 ; __u32 reserved3 ; __u64 reserved4 ; } __attribute__ ( ( packed ) ) atapi ; struct { __u16 id ; __u64 lun ; __u16 reserved1 ; __u32 reserved2 ; } __attribute__ ( ( packed ) ) scsi ; struct { __u64 serial_number ; __u64 reserved ; } __attribute__ ( ( packed ) ) usb ; struct { __u64 eui ; __u64 reserved ; } __attribute__ ( ( packed ) ) i1394 ; struct { __u64 wwid ; __u64 lun ; } __attribute__ ( ( packed ) ) fibre ; struct { __u64 identity_tag ; __u64 reserved ; } __attribute__ ( ( packed ) ) i2o ; struct { __u32 array_number ; __u32 reserved1 ; __u64 reserved2 ; } __attribute__ ( ( packed ) ) raid ; struct { __u8 device ; __u8 reserved1 ; __u16 reserved2 ; __u32 reserved3 ; __u64 reserved4 ; } __attribute__ ( ( packed ) ) sata ; struct { __u64 reserved1 ; __u64 reserved2 ; } __attribute__ ( ( packed ) ) unknown ; } device_path ; __u8 reserved4 ; __u8 checksum ; } __attribute__ ( ( packed ) ) ;
struct resource { resource_size_t start ; resource_size_t end ; const char * name ; unsigned long flags ; struct resource * parent , * sibling , * child ; } ;
struct x86_init_ops { struct x86_init_resources resources ; struct x86_init_mpparse mpparse ; struct x86_init_irqs irqs ; struct x86_init_oem oem ; struct x86_init_mapping mapping ; struct x86_init_paging paging ; struct x86_init_timers timers ; struct x86_init_iommu iommu ; struct x86_init_pci pci ; } ;
struct x86_platform_ops { unsigned long ( * calibrate_tsc ) ( void ) ; unsigned long ( * get_wallclock ) ( void ) ; int ( * set_wallclock ) ( unsigned long nowtime ) ; void ( * iommu_shutdown ) ( void ) ; K_bool ( * is_untracked_pat_range ) ( u64 start , u64 end ) ; void ( * nmi_init ) ( void ) ; unsigned char ( * get_nmi_reason ) ( void ) ; int ( * i8042_detect ) ( void ) ; void ( * save_sched_clock_state ) ( void ) ; void ( * restore_sched_clock_state ) ( void ) ; void ( * apic_post_init ) ( void ) ; } ;
struct vm_area_struct ;
struct cpu_user_regs { K_uint64_t r15 ; K_uint64_t r14 ; K_uint64_t r13 ; K_uint64_t r12 ; union { K_uint64_t rbp , ebp ; K_uint32_t _ebp ; } ; union { K_uint64_t rbx , ebx ; K_uint32_t _ebx ; } ; K_uint64_t r11 ; K_uint64_t r10 ; K_uint64_t r9 ; K_uint64_t r8 ; union { K_uint64_t rax , eax ; K_uint32_t _eax ; } ; union { K_uint64_t rcx , ecx ; K_uint32_t _ecx ; } ; union { K_uint64_t rdx , edx ; K_uint32_t _edx ; } ; union { K_uint64_t rsi , esi ; K_uint32_t _esi ; } ; union { K_uint64_t rdi , edi ; K_uint32_t _edi ; } ; K_uint32_t error_code ; K_uint32_t entry_vector ; union { K_uint64_t rip , eip ; K_uint32_t _eip ; } ; K_uint16_t cs , _pad0 [ 1 ] ; K_uint8_t saved_upcall_mask ; K_uint8_t _pad1 [ 3 ] ; union { K_uint64_t rflags , eflags ; K_uint32_t _eflags ; } ; union { K_uint64_t rsp , esp ; K_uint32_t _esp ; } ; K_uint16_t ss , _pad2 [ 3 ] ; K_uint16_t es , _pad3 [ 3 ] ; K_uint16_t ds , _pad4 [ 3 ] ; K_uint16_t fs , _pad5 [ 3 ] ; K_uint16_t gs , _pad6 [ 3 ] ; } ;
struct shared_info { struct vcpu_info vcpu_info [ 32 ] ; unsigned long evtchn_pending [ sizeof ( unsigned long ) * 8 ] ; unsigned long evtchn_mask [ sizeof ( unsigned long ) * 8 ] ; struct pvclock_wall_clock wc ; struct arch_shared_info arch ; } ;
struct clocksource ;
struct cyclecounter { cycle_t ( * read ) ( const struct cyclecounter * cc ) ; cycle_t mask ; u32 mult ; u32 shift ; } ;
struct clocksource { cycle_t ( * read ) ( struct clocksource * cs ) ; cycle_t cycle_last ; cycle_t mask ; u32 mult ; u32 shift ; u64 max_idle_ns ; u32 maxadj ; struct arch_clocksource_data archdata ; const char * name ; struct list_head list ; int rating ; int ( * enable ) ( struct clocksource * cs ) ; void ( * disable ) ( struct clocksource * cs ) ; unsigned long flags ; void ( * suspend ) ( struct clocksource * cs ) ; void ( * resume ) ( struct clocksource * cs ) ; struct list_head wd_list ; cycle_t cs_last ; cycle_t wd_last ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
enum fixed_addresses { VSYSCALL_LAST_PAGE , VSYSCALL_FIRST_PAGE = VSYSCALL_LAST_PAGE + ( ( ( - 2UL << 20 ) - ( - 10UL << 20 ) ) >> 12 ) - 1 , VVAR_PAGE , VSYSCALL_HPET , PVCLOCK_FIXMAP_BEGIN , PVCLOCK_FIXMAP_END = PVCLOCK_FIXMAP_BEGIN + ( ( ( 256 - 1 ) / ( ( ( 1UL ) << 12 ) / sizeof ( struct pvclock_vsyscall_time_info ) ) ) + 1 ) - 1 , FIX_DBGP_BASE , FIX_EARLYCON_MEM_BASE , FIX_APIC_BASE , FIX_IO_APIC_BASE_0 , FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 128 - 1 , FIX_PARAVIRT_BOOTMAP , FIX_TEXT_POKE1 , FIX_TEXT_POKE0 , __end_of_permanent_fixed_addresses , FIX_BTMAP_END = ( __end_of_permanent_fixed_addresses ^ ( __end_of_permanent_fixed_addresses + ( 64 * 4 ) - 1 ) ) & - 512 ? __end_of_permanent_fixed_addresses + ( 64 * 4 ) - ( __end_of_permanent_fixed_addresses & ( ( 64 * 4 ) - 1 ) ) : __end_of_permanent_fixed_addresses , FIX_BTMAP_BEGIN = FIX_BTMAP_END + ( 64 * 4 ) - 1 , __end_of_fixed_addresses } ;
struct apic { char * name ; int ( * probe ) ( void ) ; int ( * acpi_madt_oem_check ) ( char * oem_id , char * oem_table_id ) ; int ( * apic_id_valid ) ( int apicid ) ; int ( * apic_id_registered ) ( void ) ; u32 irq_delivery_mode ; u32 irq_dest_mode ; const struct cpumask * ( * target_cpus ) ( void ) ; int disable_esr ; int dest_logical ; unsigned long ( * check_apicid_used ) ( physid_mask_t * map , int apicid ) ; unsigned long ( * check_apicid_present ) ( int apicid ) ; void ( * vector_allocation_domain ) ( int cpu , struct cpumask * retmask , const struct cpumask * mask ) ; void ( * init_apic_ldr ) ( void ) ; void ( * ioapic_phys_id_map ) ( physid_mask_t * phys_map , physid_mask_t * retmap ) ; void ( * setup_apic_routing ) ( void ) ; int ( * multi_timer_check ) ( int apic , int irq ) ; int ( * cpu_present_to_apicid ) ( int mps_cpu ) ; void ( * apicid_to_cpu_present ) ( int phys_apicid , physid_mask_t * retmap ) ; void ( * setup_portio_remap ) ( void ) ; int ( * check_phys_apicid_present ) ( int phys_apicid ) ; void ( * enable_apic_mode ) ( void ) ; int ( * phys_pkg_id ) ( int cpuid_apic , int index_msb ) ; int ( * mps_oem_check ) ( struct mpc_table * mpc , char * oem , char * productid ) ; unsigned int ( * get_apic_id ) ( unsigned long x ) ; unsigned long ( * set_apic_id ) ( unsigned int id ) ; unsigned long apic_id_mask ; int ( * cpu_mask_to_apicid_and ) ( const struct cpumask * cpumask , const struct cpumask * andmask , unsigned int * apicid ) ; void ( * send_IPI_mask ) ( const struct cpumask * mask , int vector ) ; void ( * send_IPI_mask_allbutself ) ( const struct cpumask * mask , int vector ) ; void ( * send_IPI_allbutself ) ( int vector ) ; void ( * send_IPI_all ) ( int vector ) ; void ( * send_IPI_self ) ( int vector ) ; int ( * wakeup_secondary_cpu ) ( int apicid , unsigned long start_eip ) ; int trampoline_phys_low ; int trampoline_phys_high ; void ( * wait_for_init_deassert ) ( atomic_t * deassert ) ; void ( * smp_callin_clear_local_apic ) ( void ) ; void ( * inquire_remote_apic ) ( int apicid ) ; u32 ( * read ) ( u32 reg ) ; void ( * write ) ( u32 reg , u32 v ) ; void ( * eoi_write ) ( u32 reg , u32 v ) ; u64 ( * icr_read ) ( void ) ; void ( * icr_write ) ( u32 low , u32 high ) ; void ( * wait_icr_idle ) ( void ) ; u32 ( * safe_wait_icr_idle ) ( void ) ; } ;
typedef void * ( * pcpu_fc_alloc_fn_t ) ( unsigned int cpu , size_t size , size_t align ) ;
typedef void ( * pcpu_fc_free_fn_t ) ( void * ptr , size_t size ) ;
struct vm_area_struct ;
struct ctl_table_header ;
typedef int proc_handler ( struct ctl_table * ctl , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;
struct ctl_table_header { union { struct { struct ctl_table * ctl_table ; int used ; int count ; int nreg ; } ; struct callback_head rcu ; } ; struct completion * unregistering ; struct ctl_table * ctl_table_arg ; struct ctl_table_root * root ; struct ctl_table_set * set ; struct ctl_dir * parent ; struct ctl_node * node ; } ;
typedef struct elf32_rel { Elf32_Addr r_offset ; Elf32_Word r_info ; } Elf32_Rel ;
typedef struct elf64_rel { Elf64_Addr r_offset ; Elf64_Xword r_info ; } Elf64_Rel ;
typedef struct elf32_rela { Elf32_Addr r_offset ; Elf32_Word r_info ; Elf32_Sword r_addend ; } Elf32_Rela ;
typedef struct elf64_rela { Elf64_Addr r_offset ; Elf64_Xword r_info ; Elf64_Sxword r_addend ; } Elf64_Rela ;
typedef struct elf32_sym { Elf32_Word st_name ; Elf32_Addr st_value ; Elf32_Word st_size ; unsigned char st_info ; unsigned char st_other ; Elf32_Half st_shndx ; } Elf32_Sym ;
typedef struct elf64_sym { Elf64_Word st_name ; unsigned char st_info ; unsigned char st_other ; Elf64_Half st_shndx ; Elf64_Addr st_value ; Elf64_Xword st_size ; } Elf64_Sym ;
typedef struct elf32_hdr { unsigned char e_ident [ 16 ] ; Elf32_Half e_type ; Elf32_Half e_machine ; Elf32_Word e_version ; Elf32_Addr e_entry ; Elf32_Off e_phoff ; Elf32_Off e_shoff ; Elf32_Word e_flags ; Elf32_Half e_ehsize ; Elf32_Half e_phentsize ; Elf32_Half e_phnum ; Elf32_Half e_shentsize ; Elf32_Half e_shnum ; Elf32_Half e_shstrndx ; } Elf32_Ehdr ;
typedef struct elf64_hdr { unsigned char e_ident [ 16 ] ; Elf64_Half e_type ; Elf64_Half e_machine ; Elf64_Word e_version ; Elf64_Addr e_entry ; Elf64_Off e_phoff ; Elf64_Off e_shoff ; Elf64_Word e_flags ; Elf64_Half e_ehsize ; Elf64_Half e_phentsize ; Elf64_Half e_phnum ; Elf64_Half e_shentsize ; Elf64_Half e_shnum ; Elf64_Half e_shstrndx ; } Elf64_Ehdr ;
typedef struct elf32_phdr { Elf32_Word p_type ; Elf32_Off p_offset ; Elf32_Addr p_vaddr ; Elf32_Addr p_paddr ; Elf32_Word p_filesz ; Elf32_Word p_memsz ; Elf32_Word p_flags ; Elf32_Word p_align ; } Elf32_Phdr ;
typedef struct elf64_phdr { Elf64_Word p_type ; Elf64_Word p_flags ; Elf64_Off p_offset ; Elf64_Addr p_vaddr ; Elf64_Addr p_paddr ; Elf64_Xword p_filesz ; Elf64_Xword p_memsz ; Elf64_Xword p_align ; } Elf64_Phdr ;
typedef struct elf32_shdr { Elf32_Word sh_name ; Elf32_Word sh_type ; Elf32_Word sh_flags ; Elf32_Addr sh_addr ; Elf32_Off sh_offset ; Elf32_Word sh_size ; Elf32_Word sh_link ; Elf32_Word sh_info ; Elf32_Word sh_addralign ; Elf32_Word sh_entsize ; } Elf32_Shdr ;
typedef struct elf64_shdr { Elf64_Word sh_name ; Elf64_Word sh_type ; Elf64_Xword sh_flags ; Elf64_Addr sh_addr ; Elf64_Off sh_offset ; Elf64_Xword sh_size ; Elf64_Word sh_link ; Elf64_Word sh_info ; Elf64_Xword sh_addralign ; Elf64_Xword sh_entsize ; } Elf64_Shdr ;
typedef struct elf32_note { Elf32_Word n_namesz ; Elf32_Word n_descsz ; Elf32_Word n_type ; } Elf32_Nhdr ;
typedef struct elf64_note { Elf64_Word n_namesz ; Elf64_Word n_descsz ; Elf64_Word n_type ; } Elf64_Nhdr ;
struct kobject ;
struct kobject ;
struct attribute_group { const char * name ; umode_t ( * is_visible ) ( struct kobject * , struct attribute * , int ) ; struct attribute * * attrs ; } ;
struct vm_area_struct ;
struct bin_attribute { struct attribute attr ; size_t size ; void * private_ ; ssize_t ( * read ) ( struct file * , struct kobject * , struct bin_attribute * , char * , loff_t , size_t ) ; ssize_t ( * write ) ( struct file * , struct kobject * , struct bin_attribute * , char * , loff_t , size_t ) ; int ( * mmap ) ( struct file * , struct kobject * , struct bin_attribute * attr , struct vm_area_struct * vma ) ; } ;
struct sysfs_ops { ssize_t ( * show ) ( struct kobject * , struct attribute * , char * ) ; ssize_t ( * store ) ( struct kobject * , struct attribute * , const char * , size_t ) ; const void * ( * namespace_ ) ( struct kobject * , const struct attribute * ) ; } ;
struct kobject { const char * name ; struct list_head entry ; struct kobject * parent ; struct kset * kset ; struct kobj_type * ktype ; struct sysfs_dirent * sd ; struct kref kref ; unsigned int state_initialized : 1 ; unsigned int state_in_sysfs : 1 ; unsigned int state_add_uevent_sent : 1 ; unsigned int state_remove_uevent_sent : 1 ; unsigned int uevent_suppress : 1 ; } ;
struct kobj_attribute { struct attribute attr ; ssize_t ( * show ) ( struct kobject * kobj , struct kobj_attribute * attr , char * buf ) ; ssize_t ( * store ) ( struct kobject * kobj , struct kobj_attribute * attr , const char * buf , size_t count ) ; } ;
struct static_key_deferred { struct static_key key ; } ;
struct tracepoint ;
struct tracepoint { const char * name ; struct static_key key ; void ( * regfunc ) ( void ) ; void ( * unregfunc ) ( void ) ; struct tracepoint_func * funcs ; } ;
struct module_attribute { struct attribute attr ; ssize_t ( * show ) ( struct module_attribute * , struct module_kobject * , char * ) ; ssize_t ( * store ) ( struct module_attribute * , struct module_kobject * , const char * , size_t count ) ; void ( * setup ) ( struct module * , const char * ) ; int ( * test ) ( struct module * ) ; void ( * free ) ( struct module * ) ; } ;
struct timerqueue_node { struct rb_node node ; ktime_t expires ; } ;
struct qstr { union { struct { u32 hash ; u32 len ; ; } ; u64 hash_len ; } ; const unsigned char * name ; } ;
struct dentry_operations { int ( * d_revalidate ) ( struct dentry * , unsigned int ) ; int ( * d_hash ) ( const struct dentry * , const struct inode * , struct qstr * ) ; int ( * d_compare ) ( const struct dentry * , const struct inode * , const struct dentry * , const struct inode * , unsigned int , const char * , const struct qstr * ) ; int ( * d_delete ) ( const struct dentry * ) ; void ( * d_release ) ( struct dentry * ) ; void ( * d_prune ) ( struct dentry * ) ; void ( * d_iput ) ( struct dentry * , struct inode * ) ; char * ( * d_dname ) ( struct dentry * , char * , int ) ; struct vfsmount * ( * d_automount ) ( struct path * ) ; int ( * d_manage ) ( struct dentry * , K_bool ) ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct vfs_cap_data { __le32 magic_etc ; struct { __le32 permitted ; __le32 inheritable ; } data [ 2 ] ; } ;
struct cpu_vfs_cap_data { __u32 magic_etc ; kernel_cap_t permitted ; kernel_cap_t inheritable ; } ;
struct shrinker { int ( * shrink ) ( struct shrinker * , struct shrink_control * sc ) ; int seeks ; long batch ; struct list_head list ; atomic_long_t nr_in_batch ; } ;
struct kiocb ;
struct kobject ;
struct vm_area_struct ;
typedef void ( dio_iodone_t ) ( struct kiocb * iocb , loff_t offset , ssize_t bytes , void * private_ , int ret , K_bool is_async ) ;
typedef projid_t kprojid_t ;
typedef struct { size_t written ; size_t count ; union { char * buf ; void * data ; } arg ; int error ; } read_descriptor_t ;
typedef int ( * filldir_t ) ( void * , const char * , int , loff_t , u64 , unsigned ) ;
struct super_operations { struct inode * ( * alloc_inode ) ( struct super_block * sb ) ; void ( * destroy_inode ) ( struct inode * ) ; void ( * dirty_inode ) ( struct inode * , int flags ) ; int ( * write_inode ) ( struct inode * , struct writeback_control * wbc ) ; int ( * drop_inode ) ( struct inode * ) ; void ( * evict_inode ) ( struct inode * ) ; void ( * put_super ) ( struct super_block * ) ; int ( * sync_fs ) ( struct super_block * sb , int wait ) ; int ( * freeze_fs ) ( struct super_block * ) ; int ( * unfreeze_fs ) ( struct super_block * ) ; int ( * statfs ) ( struct dentry * , struct kstatfs * ) ; int ( * remount_fs ) ( struct super_block * , int * , char * ) ; void ( * umount_begin ) ( struct super_block * ) ; int ( * show_options ) ( struct seq_file * , struct dentry * ) ; int ( * show_devname ) ( struct seq_file * , struct dentry * ) ; int ( * show_path ) ( struct seq_file * , struct dentry * ) ; int ( * show_stats ) ( struct seq_file * , struct dentry * ) ; ssize_t ( * quota_read ) ( struct super_block * , int , char * , size_t , loff_t ) ; ssize_t ( * quota_write ) ( struct super_block * , int , const char * , size_t , loff_t ) ; int ( * bdev_try_to_free_page ) ( struct super_block * , struct page * , gfp_t ) ; int ( * nr_cached_objects ) ( struct super_block * ) ; void ( * free_cached_objects ) ( struct super_block * , int ) ; } ;
typedef void ( dio_submit_t ) ( int rw , struct bio * bio , struct inode * inode , loff_t file_offset ) ;
typedef int ( read_proc_t ) ( char * page , char * * start , off_t off , int count , int * eof , void * data ) ;
struct ctl_table_header ;
struct sigaction { __sighandler_t sa_handler ; unsigned long sa_flags ; __sigrestore_t sa_restorer ; sigset_t sa_mask ; } ;
typedef struct sigaltstack { void * ss_sp ; int ss_flags ; size_t ss_size ; } stack_t ;
struct klist_node ;
struct klist_node { void * n_klist ; struct list_head n_node ; struct kref n_ref ; } ;
struct device_driver ;
struct class_ ;
struct bus_type ;
struct bus_attribute { struct attribute attr ; ssize_t ( * show ) ( struct bus_type * bus , char * buf ) ; ssize_t ( * store ) ( struct bus_type * bus , const char * buf , size_t count ) ; } ;
struct bus_type { const char * name ; const char * dev_name ; struct device * dev_root ; struct bus_attribute * bus_attrs ; struct device_attribute * dev_attrs ; struct driver_attribute * drv_attrs ; int ( * match ) ( struct device * dev , struct device_driver * drv ) ; int ( * uevent ) ( struct device * dev , struct kobj_uevent_env * env ) ; int ( * probe ) ( struct device * dev ) ; int ( * remove ) ( struct device * dev ) ; void ( * shutdown ) ( struct device * dev ) ; int ( * suspend ) ( struct device * dev , pm_message_t state ) ; int ( * resume ) ( struct device * dev ) ; const struct dev_pm_ops * pm ; struct iommu_ops * iommu_ops ; struct subsys_private * p ; } ;
struct device_driver { const char * name ; struct bus_type * bus ; struct module * owner ; const char * mod_name ; K_bool suppress_bind_attrs ; const struct of_device_id * of_match_table ; const struct acpi_device_id * acpi_match_table ; int ( * probe ) ( struct device * dev ) ; int ( * remove ) ( struct device * dev ) ; void ( * shutdown ) ( struct device * dev ) ; int ( * suspend ) ( struct device * dev , pm_message_t state ) ; int ( * resume ) ( struct device * dev ) ; const struct attribute_group * * groups ; const struct dev_pm_ops * pm ; struct driver_private * p ; } ;
struct driver_attribute { struct attribute attr ; ssize_t ( * show ) ( struct device_driver * driver , char * buf ) ; ssize_t ( * store ) ( struct device_driver * driver , const char * buf , size_t count ) ; } ;
struct class_ { const char * name ; struct module * owner ; struct class_attribute * class_attrs ; struct device_attribute * dev_attrs ; struct bin_attribute * dev_bin_attrs ; struct kobject * dev_kobj ; int ( * dev_uevent ) ( struct device * dev , struct kobj_uevent_env * env ) ; char * ( * devnode ) ( struct device * dev , umode_t * mode ) ; void ( * class_release ) ( struct class_ * class_ ) ; void ( * dev_release ) ( struct device * dev ) ; int ( * suspend ) ( struct device * dev , pm_message_t state ) ; int ( * resume ) ( struct device * dev ) ; const struct kobj_ns_type_operations * ns_type ; const void * ( * namespace_ ) ( struct device * dev ) ; const struct dev_pm_ops * pm ; struct subsys_private * p ; } ;
struct class_attribute { struct attribute attr ; ssize_t ( * show ) ( struct class_ * class_ , struct class_attribute * attr , char * buf ) ; ssize_t ( * store ) ( struct class_ * class_ , struct class_attribute * attr , const char * buf , size_t count ) ; const void * ( * namespace_ ) ( struct class_ * class_ , const struct class_attribute * attr ) ; } ;
struct device_type { const char * name ; const struct attribute_group * * groups ; int ( * uevent ) ( struct device * dev , struct kobj_uevent_env * env ) ; char * ( * devnode ) ( struct device * dev , umode_t * mode ) ; void ( * release ) ( struct device * dev ) ; const struct dev_pm_ops * pm ; } ;
struct device_attribute { struct attribute attr ; ssize_t ( * show ) ( struct device * dev , struct device_attribute * attr , char * buf ) ; ssize_t ( * store ) ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) ; } ;
struct pci_host_bridge_window { struct list_head list ; struct resource * res ; resource_size_t offset ; } ;
struct pci_bus_region { resource_size_t start ; resource_size_t end ; } ;
struct pci_error_handlers { pci_ers_result_t ( * error_detected ) ( struct pci_dev * dev , enum pci_channel_state error ) ; pci_ers_result_t ( * mmio_enabled ) ( struct pci_dev * dev ) ; pci_ers_result_t ( * link_reset ) ( struct pci_dev * dev ) ; pci_ers_result_t ( * slot_reset ) ( struct pci_dev * dev ) ; void ( * resume ) ( struct pci_dev * dev ) ; } ;
typedef int ( * arch_set_vga_state_t ) ( struct pci_dev * pdev , K_bool decode , unsigned int command_bits , u32 flags ) ;
struct vm_area_struct ;
struct uprobe_consumer { int ( * handler ) ( struct uprobe_consumer * self , struct pt_regs * regs ) ; K_bool ( * filter ) ( struct uprobe_consumer * self , struct task_struct * task ) ; struct uprobe_consumer * next ; } ;
struct vm_area_struct { unsigned long vm_start ; unsigned long vm_end ; struct vm_area_struct * vm_next , * vm_prev ; struct rb_node vm_rb ; unsigned long rb_subtree_gap ; struct mm_struct * vm_mm ; pgprot_t vm_page_prot ; unsigned long vm_flags ; union { struct { struct rb_node rb ; unsigned long rb_subtree_last ; } linear ; struct list_head nonlinear ; } shared ; struct list_head anon_vma_chain ; struct anon_vma * anon_vma ; const struct vm_operations_struct * vm_ops ; unsigned long vm_pgoff ; struct file * vm_file ; void * vm_private_data ; struct mempolicy * vm_policy ; } ;
struct mm_rss_stat { atomic_long_t count [ NR_MM_COUNTERS ] ; } ;
struct vm_area_struct ;
struct vm_operations_struct { void ( * open ) ( struct vm_area_struct * area ) ; void ( * close ) ( struct vm_area_struct * area ) ; int ( * fault ) ( struct vm_area_struct * vma , struct vm_fault * vmf ) ; int ( * page_mkwrite ) ( struct vm_area_struct * vma , struct vm_fault * vmf ) ; int ( * access ) ( struct vm_area_struct * vma , unsigned long addr , void * buf , int len , int write ) ; int ( * set_policy ) ( struct vm_area_struct * vma , struct mempolicy * new_ ) ; struct mempolicy * ( * get_policy ) ( struct vm_area_struct * vma , unsigned long addr ) ; int ( * migrate ) ( struct vm_area_struct * vma , const nodemask_t * from , const nodemask_t * to , unsigned long flags ) ; int ( * remap_pages ) ( struct vm_area_struct * vma , unsigned long addr , unsigned long size , unsigned long pgoff ) ; } ;
struct dma_map_ops { void * ( * alloc ) ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t gfp , struct dma_attrs * attrs ) ; void ( * free ) ( struct device * dev , size_t size , void * vaddr , dma_addr_t dma_handle , struct dma_attrs * attrs ) ; int ( * mmap ) ( struct device * , struct vm_area_struct * , void * , dma_addr_t , size_t , struct dma_attrs * attrs ) ; int ( * get_sgtable ) ( struct device * dev , struct sg_table * sgt , void * , dma_addr_t , size_t , struct dma_attrs * attrs ) ; dma_addr_t ( * map_page ) ( struct device * dev , struct page * page , unsigned long offset , size_t size , enum dma_data_direction dir , struct dma_attrs * attrs ) ; void ( * unmap_page ) ( struct device * dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir , struct dma_attrs * attrs ) ; int ( * map_sg ) ( struct device * dev , struct scatterlist * sg , int nents , enum dma_data_direction dir , struct dma_attrs * attrs ) ; void ( * unmap_sg ) ( struct device * dev , struct scatterlist * sg , int nents , enum dma_data_direction dir , struct dma_attrs * attrs ) ; void ( * sync_single_for_cpu ) ( struct device * dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ) ; void ( * sync_single_for_device ) ( struct device * dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ) ; void ( * sync_sg_for_cpu ) ( struct device * dev , struct scatterlist * sg , int nents , enum dma_data_direction dir ) ; void ( * sync_sg_for_device ) ( struct device * dev , struct scatterlist * sg , int nents , enum dma_data_direction dir ) ; int ( * mapping_error ) ( struct device * dev , dma_addr_t dma_addr ) ; int ( * dma_supported ) ( struct device * dev , u64 mask ) ; int ( * set_dma_mask ) ( struct device * dev , u64 mask ) ; int is_phys ; } ;
struct bus_type ;
struct semid64_ds { struct ipc64_perm sem_perm ; __kernel_time_t sem_otime ; unsigned long __unused1 ; __kernel_time_t sem_ctime ; unsigned long __unused2 ; unsigned long sem_nsems ; unsigned long __unused3 ; unsigned long __unused4 ; } ;
struct kiocb { struct list_head ki_run_list ; unsigned long ki_flags ; int ki_users ; unsigned ki_key ; struct file * ki_filp ; struct kioctx * ki_ctx ; int ( * ki_cancel ) ( struct kiocb * , struct io_event * ) ; ssize_t ( * ki_retry ) ( struct kiocb * ) ; void ( * ki_dtor ) ( struct kiocb * ) ; union { void * user ; struct task_struct * tsk ; } ki_obj ; __u64 ki_user_data ; loff_t ki_pos ; void * private_ ; unsigned short ki_opcode ; size_t ki_nbytes ; char * ki_buf ; size_t ki_left ; struct iovec ki_inline_vec ; struct iovec * ki_iovec ; unsigned long ki_nr_segs ; unsigned long ki_cur_seg ; struct list_head ki_list ; struct list_head ki_batch ; struct eventfd_ctx * ki_eventfd ; } ;
struct sched_domain { struct sched_domain * parent ; struct sched_domain * child ; struct sched_group * groups ; unsigned long min_interval ; unsigned long max_interval ; unsigned int busy_factor ; unsigned int imbalance_pct ; unsigned int cache_nice_tries ; unsigned int busy_idx ; unsigned int idle_idx ; unsigned int newidle_idx ; unsigned int wake_idx ; unsigned int forkexec_idx ; unsigned int smt_gain ; int flags ; int level ; unsigned long last_balance ; unsigned int balance_interval ; unsigned int nr_balance_failed ; u64 last_update ; unsigned int lb_count [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_failed [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_balanced [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_imbalance [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_gained [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_hot_gained [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_nobusyg [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_nobusyq [ CPU_MAX_IDLE_TYPES ] ; unsigned int alb_count ; unsigned int alb_failed ; unsigned int alb_pushed ; unsigned int sbe_count ; unsigned int sbe_balanced ; unsigned int sbe_pushed ; unsigned int sbf_count ; unsigned int sbf_balanced ; unsigned int sbf_pushed ; unsigned int ttwu_wake_remote ; unsigned int ttwu_move_affine ; unsigned int ttwu_move_balance ; char * name ; union { void * private_ ; struct callback_head rcu ; } ; unsigned int span_weight ; unsigned long span [ 0 ] ; } ;
struct sched_domain ;
struct sched_class { const struct sched_class * next ; void ( * enqueue_task ) ( struct rq * rq , struct task_struct * p , int flags ) ; void ( * dequeue_task ) ( struct rq * rq , struct task_struct * p , int flags ) ; void ( * yield_task ) ( struct rq * rq ) ; K_bool ( * yield_to_task ) ( struct rq * rq , struct task_struct * p , K_bool preempt ) ; void ( * check_preempt_curr ) ( struct rq * rq , struct task_struct * p , int flags ) ; struct task_struct * ( * pick_next_task ) ( struct rq * rq ) ; void ( * put_prev_task ) ( struct rq * rq , struct task_struct * p ) ; int ( * select_task_rq ) ( struct task_struct * p , int sd_flag , int flags ) ; void ( * migrate_task_rq ) ( struct task_struct * p , int next_cpu ) ; void ( * pre_schedule ) ( struct rq * this_rq , struct task_struct * task ) ; void ( * post_schedule ) ( struct rq * this_rq ) ; void ( * task_waking ) ( struct task_struct * task ) ; void ( * task_woken ) ( struct rq * this_rq , struct task_struct * task ) ; void ( * set_cpus_allowed ) ( struct task_struct * p , const struct cpumask * newmask ) ; void ( * rq_online ) ( struct rq * rq ) ; void ( * rq_offline ) ( struct rq * rq ) ; void ( * set_curr_task ) ( struct rq * rq ) ; void ( * task_tick ) ( struct rq * rq , struct task_struct * p , int queued ) ; void ( * task_fork ) ( struct task_struct * p ) ; void ( * switched_from ) ( struct rq * this_rq , struct task_struct * task ) ; void ( * switched_to ) ( struct rq * this_rq , struct task_struct * task ) ; void ( * prio_changed ) ( struct rq * this_rq , struct task_struct * task , int oldprio ) ; unsigned int ( * get_rr_interval ) ( struct rq * rq , struct task_struct * task ) ; void ( * task_move_group ) ( struct task_struct * p , int on_rq ) ; } ;
struct irq_chip { const char * name ; unsigned int ( * irq_startup ) ( struct irq_data * data ) ; void ( * irq_shutdown ) ( struct irq_data * data ) ; void ( * irq_enable ) ( struct irq_data * data ) ; void ( * irq_disable ) ( struct irq_data * data ) ; void ( * irq_ack ) ( struct irq_data * data ) ; void ( * irq_mask ) ( struct irq_data * data ) ; void ( * irq_mask_ack ) ( struct irq_data * data ) ; void ( * irq_unmask ) ( struct irq_data * data ) ; void ( * irq_eoi ) ( struct irq_data * data ) ; int ( * irq_set_affinity ) ( struct irq_data * data , const struct cpumask * dest , K_bool force ) ; int ( * irq_retrigger ) ( struct irq_data * data ) ; int ( * irq_set_type ) ( struct irq_data * data , unsigned int flow_type ) ; int ( * irq_set_wake ) ( struct irq_data * data , unsigned int on ) ; void ( * irq_bus_lock ) ( struct irq_data * data ) ; void ( * irq_bus_sync_unlock ) ( struct irq_data * data ) ; void ( * irq_cpu_online ) ( struct irq_data * data ) ; void ( * irq_cpu_offline ) ( struct irq_data * data ) ; void ( * irq_suspend ) ( struct irq_data * data ) ; void ( * irq_resume ) ( struct irq_data * data ) ; void ( * irq_pm_shutdown ) ( struct irq_data * data ) ; void ( * irq_print_chip ) ( struct irq_data * data , struct seq_file * p ) ; unsigned long flags ; } ;
struct dev_pm_qos_request { enum dev_pm_qos_req_type type ; union { struct plist_node pnode ; struct pm_qos_flags_request flr ; } data ; struct device * dev ; } ;
struct dma_interleaved_template { dma_addr_t src_start ; dma_addr_t dst_start ; enum dma_transfer_direction dir ; K_bool src_inc ; K_bool dst_inc ; K_bool src_sgl ; K_bool dst_sgl ; size_t numf ; size_t frame_size ; struct data_chunk sgl [ 0 ] ; } ;
typedef K_bool ( * dma_filter_fn ) ( struct dma_chan * chan , void * filter_param ) ;
struct dma_async_tx_descriptor { dma_cookie_t cookie ; enum dma_ctrl_flags flags ; dma_addr_t phys ; struct dma_chan * chan ; dma_cookie_t ( * tx_submit ) ( struct dma_async_tx_descriptor * tx ) ; dma_async_tx_callback callback ; void * callback_param ; } ;
struct dma_device { unsigned int chancnt ; unsigned int privatecnt ; struct list_head channels ; struct list_head global_node ; dma_cap_mask_t cap_mask ; unsigned short max_xor ; unsigned short max_pq ; u8 copy_align ; u8 xor_align ; u8 pq_align ; u8 fill_align ; int dev_id ; struct device * dev ; int ( * device_alloc_chan_resources ) ( struct dma_chan * chan ) ; void ( * device_free_chan_resources ) ( struct dma_chan * chan ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_memcpy ) ( struct dma_chan * chan , dma_addr_t dest , dma_addr_t src , size_t len , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_xor ) ( struct dma_chan * chan , dma_addr_t dest , dma_addr_t * src , unsigned int src_cnt , size_t len , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_xor_val ) ( struct dma_chan * chan , dma_addr_t * src , unsigned int src_cnt , size_t len , enum sum_check_flags * result , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_pq ) ( struct dma_chan * chan , dma_addr_t * dst , dma_addr_t * src , unsigned int src_cnt , const unsigned char * scf , size_t len , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_pq_val ) ( struct dma_chan * chan , dma_addr_t * pq , dma_addr_t * src , unsigned int src_cnt , const unsigned char * scf , size_t len , enum sum_check_flags * pqres , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_memset ) ( struct dma_chan * chan , dma_addr_t dest , int value , size_t len , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_interrupt ) ( struct dma_chan * chan , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_sg ) ( struct dma_chan * chan , struct scatterlist * dst_sg , unsigned int dst_nents , struct scatterlist * src_sg , unsigned int src_nents , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_slave_sg ) ( struct dma_chan * chan , struct scatterlist * sgl , unsigned int sg_len , enum dma_transfer_direction direction , unsigned long flags , void * context ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_cyclic ) ( struct dma_chan * chan , dma_addr_t buf_addr , size_t buf_len , size_t period_len , enum dma_transfer_direction direction , unsigned long flags , void * context ) ; struct dma_async_tx_descriptor * ( * device_prep_interleaved_dma ) ( struct dma_chan * chan , struct dma_interleaved_template * xt , unsigned long flags ) ; int ( * device_control ) ( struct dma_chan * chan , enum dma_ctrl_cmd cmd , unsigned long arg ) ; enum dma_status ( * device_tx_status ) ( struct dma_chan * chan , dma_cookie_t cookie , struct dma_tx_state * txstate ) ; void ( * device_issue_pending ) ( struct dma_chan * chan ) ; } ;
struct if_settings { unsigned int type ; unsigned int size ; union { raw_hdlc_proto * raw_hdlc ; cisco_proto * cisco ; fr_proto * fr ; fr_proto_pvc * fr_pvc ; fr_proto_pvc_info * fr_pvc_info ; sync_serial_settings * sync ; te1_settings * te1 ; } ifs_ifsu ; } ;
struct compat_statfs { int f_type ; int f_bsize ; int f_blocks ; int f_bfree ; int f_bavail ; int f_files ; int f_ffree ; compat_fsid_t f_fsid ; int f_namelen ; int f_frsize ; int f_flags ; int f_spare [ 4 ] ; } ;
typedef union compat_sigval { compat_int_t sival_int ; compat_uptr_t sival_ptr ; } compat_sigval_t ;
struct compat_semid64_ds { struct compat_ipc64_perm sem_perm ; compat_time_t sem_otime ; compat_ulong_t __unused1 ; compat_time_t sem_ctime ; compat_ulong_t __unused2 ; compat_ulong_t sem_nsems ; compat_ulong_t __unused3 ; compat_ulong_t __unused4 ; } ;
struct compat_msqid64_ds { struct compat_ipc64_perm msg_perm ; compat_time_t msg_stime ; compat_ulong_t __unused1 ; compat_time_t msg_rtime ; compat_ulong_t __unused2 ; compat_time_t msg_ctime ; compat_ulong_t __unused3 ; compat_ulong_t msg_cbytes ; compat_ulong_t msg_qnum ; compat_ulong_t msg_qbytes ; compat_pid_t msg_lspid ; compat_pid_t msg_lrpid ; compat_ulong_t __unused4 ; compat_ulong_t __unused5 ; } ;
struct compat_shmid64_ds { struct compat_ipc64_perm shm_perm ; compat_size_t shm_segsz ; compat_time_t shm_atime ; compat_ulong_t __unused1 ; compat_time_t shm_dtime ; compat_ulong_t __unused2 ; compat_time_t shm_ctime ; compat_ulong_t __unused3 ; compat_pid_t shm_cpid ; compat_pid_t shm_lpid ; compat_ulong_t shm_nattch ; compat_ulong_t __unused4 ; compat_ulong_t __unused5 ; } ;
typedef struct compat_sigaltstack { compat_uptr_t ss_sp ; int ss_flags ; compat_size_t ss_size ; } compat_stack_t ;
struct compat_itimerspec { struct compat_timespec it_interval ; struct compat_timespec it_value ; } ;
struct compat_itimerval { struct compat_timeval it_interval ; struct compat_timeval it_value ; } ;
struct compat_timex { compat_uint_t modes ; compat_long_t offset ; compat_long_t freq ; compat_long_t maxerror ; compat_long_t esterror ; compat_int_t status ; compat_long_t constant ; compat_long_t precision ; compat_long_t tolerance ; struct compat_timeval time ; compat_long_t tick ; compat_long_t ppsfreq ; compat_long_t jitter ; compat_int_t shift ; compat_long_t stabil ; compat_long_t jitcnt ; compat_long_t calcnt ; compat_long_t errcnt ; compat_long_t stbcnt ; compat_int_t tai ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; } ;
typedef struct { compat_sigset_word sig [ ( 64 / 32 ) ] ; } compat_sigset_t ;
struct compat_rusage { struct compat_timeval ru_utime ; struct compat_timeval ru_stime ; compat_long_t ru_maxrss ; compat_long_t ru_ixrss ; compat_long_t ru_idrss ; compat_long_t ru_isrss ; compat_long_t ru_minflt ; compat_long_t ru_majflt ; compat_long_t ru_nswap ; compat_long_t ru_inblock ; compat_long_t ru_oublock ; compat_long_t ru_msgsnd ; compat_long_t ru_msgrcv ; compat_long_t ru_nsignals ; compat_long_t ru_nvcsw ; compat_long_t ru_nivcsw ; } ;
struct compat_robust_list_head { struct compat_robust_list list ; compat_long_t futex_offset ; compat_uptr_t list_op_pending ; } ;
struct compat_statfs ;
struct vm_area_struct ;
struct kiocb ;
struct proto_ops { int family ; struct module * owner ; int ( * release ) ( struct socket * sock ) ; int ( * bind ) ( struct socket * sock , struct sockaddr * myaddr , int sockaddr_len ) ; int ( * connect ) ( struct socket * sock , struct sockaddr * vaddr , int sockaddr_len , int flags ) ; int ( * socketpair ) ( struct socket * sock1 , struct socket * sock2 ) ; int ( * accept ) ( struct socket * sock , struct socket * newsock , int flags ) ; int ( * getname ) ( struct socket * sock , struct sockaddr * addr , int * sockaddr_len , int peer ) ; unsigned int ( * poll ) ( struct file * file , struct socket * sock , struct poll_table_struct * wait ) ; int ( * ioctl ) ( struct socket * sock , unsigned int cmd , unsigned long arg ) ; int ( * compat_ioctl ) ( struct socket * sock , unsigned int cmd , unsigned long arg ) ; int ( * listen ) ( struct socket * sock , int len ) ; int ( * shutdown ) ( struct socket * sock , int flags ) ; int ( * setsockopt ) ( struct socket * sock , int level , int optname , char * optval , unsigned int optlen ) ; int ( * getsockopt ) ( struct socket * sock , int level , int optname , char * optval , int * optlen ) ; int ( * compat_setsockopt ) ( struct socket * sock , int level , int optname , char * optval , unsigned int optlen ) ; int ( * compat_getsockopt ) ( struct socket * sock , int level , int optname , char * optval , int * optlen ) ; int ( * sendmsg ) ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t total_len ) ; int ( * recvmsg ) ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t total_len , int flags ) ; int ( * mmap ) ( struct file * file , struct socket * sock , struct vm_area_struct * vma ) ; ssize_t ( * sendpage ) ( struct socket * sock , struct page * page , int offset , size_t size , int flags ) ; ssize_t ( * splice_read ) ( struct socket * sock , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) ; void ( * set_peek_off ) ( struct sock * sk , int val ) ; } ;
struct in6_addr ;
struct sk_buff ;
struct sk_buff ;
struct skb_shared_hwtstamps { ktime_t hwtstamp ; ktime_t syststamp ; } ;
struct ubuf_info { void ( * callback ) ( struct ubuf_info * , K_bool zerocopy_success ) ; void * ctx ; unsigned long desc ; } ;
struct sk_buff { struct sk_buff * next ; struct sk_buff * prev ; ktime_t tstamp ; struct sock * sk ; struct net_device * dev ; char cb [ 48 ] __attribute__ ( ( aligned ( 8 ) ) ) ; unsigned long _skb_refdst ; struct sec_path * sp ; unsigned int len , data_len ; __u16 mac_len , hdr_len ; union { __wsum csum ; struct { __u16 csum_start ; __u16 csum_offset ; } ; } ; __u32 priority ; ; __u8 local_df : 1 , cloned : 1 , ip_summed : 2 , nohdr : 1 , nfctinfo : 3 ; __u8 pkt_type : 3 , fclone : 2 , ipvs_property : 1 , peeked : 1 , nf_trace : 1 ; ; __be16 protocol ; void ( * destructor ) ( struct sk_buff * skb ) ; struct nf_conntrack * nfct ; struct sk_buff * nfct_reasm ; struct nf_bridge_info * nf_bridge ; int skb_iif ; __u32 rxhash ; __u16 vlan_tci ; __u16 tc_index ; __u16 tc_verd ; __u16 queue_mapping ; ; __u8 ndisc_nodetype : 2 ; __u8 pfmemalloc : 1 ; __u8 ooo_okay : 1 ; __u8 l4_rxhash : 1 ; __u8 wifi_acked_valid : 1 ; __u8 wifi_acked : 1 ; __u8 no_fcs : 1 ; __u8 head_frag : 1 ; __u8 encapsulation : 1 ; ; dma_cookie_t dma_cookie ; __u32 secmark ; union { __u32 mark ; __u32 dropcount ; __u32 avail_size ; } ; sk_buff_data_t inner_transport_header ; sk_buff_data_t inner_network_header ; sk_buff_data_t transport_header ; sk_buff_data_t network_header ; sk_buff_data_t mac_header ; sk_buff_data_t tail ; sk_buff_data_t end ; unsigned char * head , * data ; unsigned int truesize ; atomic_t users ; } ;
union ethtool_flow_union { struct ethtool_tcpip4_spec tcp_ip4_spec ; struct ethtool_tcpip4_spec udp_ip4_spec ; struct ethtool_tcpip4_spec sctp_ip4_spec ; struct ethtool_ah_espip4_spec ah_ip4_spec ; struct ethtool_ah_espip4_spec esp_ip4_spec ; struct ethtool_usrip4_spec usr_ip4_spec ; struct ethhdr ether_spec ; __u8 hdata [ 52 ] ; } ;
struct ctl_table_header ;
struct icmpmsg_mib { atomic_long_t mibs [ 512 ] ; } ;
struct icmpv6_mib_device { atomic_long_t mibs [ __ICMP6_MIB_MAX ] ; } ;
struct icmpv6msg_mib { atomic_long_t mibs [ 512 ] ; } ;
struct icmpv6msg_mib_device { atomic_long_t mibs [ 512 ] ; } ;
struct ctl_table_header ;
struct ctl_table_header ;
struct sk_buff ;
struct ctl_table_header ;
struct netns_nf_frag { struct netns_sysctl_ipv6 sysctl ; struct netns_frags frags ; } ;
struct ctl_table_header ;
struct ip_mreq { struct in_addr imr_multiaddr ; struct in_addr imr_interface ; } ;
struct ip_mreqn { struct in_addr imr_multiaddr ; struct in_addr imr_address ; int imr_ifindex ; } ;
struct in_pktinfo { int ipi_ifindex ; struct in_addr ipi_spec_dst ; struct in_addr ipi_addr ; } ;
struct sockaddr_in { __kernel_sa_family_t sin_family ; __be16 sin_port ; struct in_addr sin_addr ; unsigned char __pad [ 16 - sizeof ( short int ) - sizeof ( unsigned short int ) - sizeof ( struct in_addr ) ] ; } ;
struct in6_addr { union { __u8 u6_addr8 [ 16 ] ; __be16 u6_addr16 [ 8 ] ; __be32 u6_addr32 [ 4 ] ; } in6_u ; } ;
struct sk_buff ;
struct nf_hook_ops { struct list_head list ; nf_hookfn * hook ; struct module * owner ; u_int8_t pf ; unsigned int hooknum ; int priority ; } ;
struct nf_afinfo { unsigned short family ; __sum16 ( * checksum ) ( struct sk_buff * skb , unsigned int hook , unsigned int dataoff , u_int8_t protocol ) ; __sum16 ( * checksum_partial ) ( struct sk_buff * skb , unsigned int hook , unsigned int dataoff , unsigned int len , u_int8_t protocol ) ; int ( * route ) ( struct net * net , struct dst_entry * * dst , struct flowi * fl , K_bool strict ) ; void ( * saveroute ) ( const struct sk_buff * skb , struct nf_queue_entry * entry ) ; int ( * reroute ) ( struct sk_buff * skb , const struct nf_queue_entry * entry ) ; int route_key_size ; } ;
union flowi_uli { struct { __be16 dport ; __be16 sport ; } ports ; struct { __u8 type ; __u8 code ; } icmpt ; struct { __le16 dport ; __le16 sport ; } dnports ; __be32 spi ; __be32 gre_key ; struct { __u8 type ; } mht ; } ;
struct nfq_ct_hook { size_t ( * build_size ) ( const struct nf_conn * ct ) ; int ( * build ) ( struct sk_buff * skb , struct nf_conn * ct ) ; int ( * parse ) ( const struct nlattr * attr , struct nf_conn * ct ) ; } ;
struct ip_ct_tcp { struct ip_ct_tcp_state seen [ 2 ] ; u_int8_t state ; u_int8_t last_dir ; u_int8_t retrans ; u_int8_t last_index ; u_int32_t last_seq ; u_int32_t last_ack ; u_int32_t last_end ; u_int16_t last_win ; u_int8_t last_wscale ; u_int8_t last_flags ; } ;
struct ctl_table_header ;
struct netns_ct { atomic_t count ; unsigned int expect_count ; unsigned int htable_size ; struct kmem_cache * nf_conntrack_cachep ; struct hlist_nulls_head * hash ; struct hlist_head * expect_hash ; struct hlist_nulls_head unconfirmed ; struct hlist_nulls_head dying ; struct hlist_nulls_head tmpl ; struct ip_conntrack_stat * stat ; struct nf_ct_event_notifier * nf_conntrack_event_cb ; struct nf_exp_event_notifier * nf_expect_event_cb ; int sysctl_events ; unsigned int sysctl_events_retry_timeout ; int sysctl_acct ; int sysctl_tstamp ; int sysctl_checksum ; unsigned int sysctl_log_invalid ; int sysctl_auto_assign_helper ; K_bool auto_assign_helper_warned ; struct nf_ip_net nf_ct_proto ; struct ctl_table_header * sysctl_header ; struct ctl_table_header * acct_sysctl_header ; struct ctl_table_header * tstamp_sysctl_header ; struct ctl_table_header * event_sysctl_header ; struct ctl_table_header * helper_sysctl_header ; char * slabname ; } ;
typedef union { __be32 a4 ; __be32 a6 [ 4 ] ; } xfrm_address_t ;
struct ctl_table_header ;
struct ctl_table_header ;
struct seq_operations ;
struct seq_operations { void * ( * start ) ( struct seq_file * m , loff_t * pos ) ; void ( * stop ) ( struct seq_file * m , void * v ) ; void * ( * next ) ( struct seq_file * m , void * v , loff_t * pos ) ; int ( * show ) ( struct seq_file * m , void * v ) ; } ;
struct ctl_table_header ;
struct dsa_switch_driver { struct list_head list ; __be16 tag_protocol ; int priv_size ; char * ( * probe ) ( struct mii_bus * bus , int sw_addr ) ; int ( * setup ) ( struct dsa_switch * ds ) ; int ( * set_addr ) ( struct dsa_switch * ds , u8 * addr ) ; int ( * phy_read ) ( struct dsa_switch * ds , int port , int regnum ) ; int ( * phy_write ) ( struct dsa_switch * ds , int port , int regnum , u16 val ) ; void ( * poll_link ) ( struct dsa_switch * ds ) ; void ( * get_strings ) ( struct dsa_switch * ds , int port , K_uint8_t * data ) ; void ( * get_ethtool_stats ) ( struct dsa_switch * ds , int port , K_uint64_t * data ) ; int ( * get_sset_count ) ( struct dsa_switch * ds ) ; } ;
struct xattr_handler { const char * prefix ; int flags ; size_t ( * list ) ( struct dentry * dentry , char * list , size_t list_size , const char * name , size_t name_len , int handler_flags ) ; int ( * get ) ( struct dentry * dentry , const char * name , void * buffer , size_t size , int handler_flags ) ; int ( * set ) ( struct dentry * dentry , const char * name , const void * buffer , size_t size , int flags , int handler_flags ) ; } ;
struct qstr ;
struct sk_buff ;
struct tpacket3_hdr { __u32 tp_next_offset ; __u32 tp_sec ; __u32 tp_nsec ; __u32 tp_snaplen ; __u32 tp_len ; __u32 tp_status ; __u16 tp_mac ; __u16 tp_net ; union { struct tpacket_hdr_variant1 hv1 ; } ; } ;
union tpacket_bd_header_u { struct tpacket_hdr_v1 bh1 ; } ;
struct sk_buff ;
struct header_ops { int ( * create ) ( struct sk_buff * skb , struct net_device * dev , unsigned short type , const void * daddr , const void * saddr , unsigned int len ) ; int ( * parse ) ( const struct sk_buff * skb , unsigned char * haddr ) ; int ( * rebuild ) ( struct sk_buff * skb ) ; int ( * cache ) ( const struct neighbour * neigh , struct hh_cache * hh , __be16 type ) ; void ( * cache_update ) ( struct hh_cache * hh , const struct net_device * dev , const unsigned char * haddr ) ; } ;
struct net_device_ops { int ( * ndo_init ) ( struct net_device * dev ) ; void ( * ndo_uninit ) ( struct net_device * dev ) ; int ( * ndo_open ) ( struct net_device * dev ) ; int ( * ndo_stop ) ( struct net_device * dev ) ; netdev_tx_t ( * ndo_start_xmit ) ( struct sk_buff * skb , struct net_device * dev ) ; u16 ( * ndo_select_queue ) ( struct net_device * dev , struct sk_buff * skb ) ; void ( * ndo_change_rx_flags ) ( struct net_device * dev , int flags ) ; void ( * ndo_set_rx_mode ) ( struct net_device * dev ) ; int ( * ndo_set_mac_address ) ( struct net_device * dev , void * addr ) ; int ( * ndo_validate_addr ) ( struct net_device * dev ) ; int ( * ndo_do_ioctl ) ( struct net_device * dev , struct ifreq * ifr , int cmd ) ; int ( * ndo_set_config ) ( struct net_device * dev , struct ifmap * map ) ; int ( * ndo_change_mtu ) ( struct net_device * dev , int new_mtu ) ; int ( * ndo_neigh_setup ) ( struct net_device * dev , struct neigh_parms * ) ; void ( * ndo_tx_timeout ) ( struct net_device * dev ) ; struct rtnl_link_stats64 * ( * ndo_get_stats64 ) ( struct net_device * dev , struct rtnl_link_stats64 * storage ) ; struct net_device_stats * ( * ndo_get_stats ) ( struct net_device * dev ) ; int ( * ndo_vlan_rx_add_vid ) ( struct net_device * dev , unsigned short vid ) ; int ( * ndo_vlan_rx_kill_vid ) ( struct net_device * dev , unsigned short vid ) ; void ( * ndo_poll_controller ) ( struct net_device * dev ) ; int ( * ndo_netpoll_setup ) ( struct net_device * dev , struct netpoll_info * info , gfp_t gfp ) ; void ( * ndo_netpoll_cleanup ) ( struct net_device * dev ) ; int ( * ndo_set_vf_mac ) ( struct net_device * dev , int queue , u8 * mac ) ; int ( * ndo_set_vf_vlan ) ( struct net_device * dev , int queue , u16 vlan , u8 qos ) ; int ( * ndo_set_vf_tx_rate ) ( struct net_device * dev , int vf , int rate ) ; int ( * ndo_set_vf_spoofchk ) ( struct net_device * dev , int vf , K_bool setting ) ; int ( * ndo_get_vf_config ) ( struct net_device * dev , int vf , struct ifla_vf_info * ivf ) ; int ( * ndo_set_vf_port ) ( struct net_device * dev , int vf , struct nlattr * port [ ] ) ; int ( * ndo_get_vf_port ) ( struct net_device * dev , int vf , struct sk_buff * skb ) ; int ( * ndo_setup_tc ) ( struct net_device * dev , u8 tc ) ; int ( * ndo_fcoe_enable ) ( struct net_device * dev ) ; int ( * ndo_fcoe_disable ) ( struct net_device * dev ) ; int ( * ndo_fcoe_ddp_setup ) ( struct net_device * dev , u16 xid , struct scatterlist * sgl , unsigned int sgc ) ; int ( * ndo_fcoe_ddp_done ) ( struct net_device * dev , u16 xid ) ; int ( * ndo_fcoe_ddp_target ) ( struct net_device * dev , u16 xid , struct scatterlist * sgl , unsigned int sgc ) ; int ( * ndo_fcoe_get_hbainfo ) ( struct net_device * dev , struct netdev_fcoe_hbainfo * hbainfo ) ; int ( * ndo_fcoe_get_wwn ) ( struct net_device * dev , u64 * wwn , int type ) ; int ( * ndo_rx_flow_steer ) ( struct net_device * dev , const struct sk_buff * skb , u16 rxq_index , u32 flow_id ) ; int ( * ndo_add_slave ) ( struct net_device * dev , struct net_device * slave_dev ) ; int ( * ndo_del_slave ) ( struct net_device * dev , struct net_device * slave_dev ) ; netdev_features_t ( * ndo_fix_features ) ( struct net_device * dev , netdev_features_t features ) ; int ( * ndo_set_features ) ( struct net_device * dev , netdev_features_t features ) ; int ( * ndo_neigh_construct ) ( struct neighbour * n ) ; void ( * ndo_neigh_destroy ) ( struct neighbour * n ) ; int ( * ndo_fdb_add ) ( struct ndmsg * ndm , struct nlattr * tb [ ] , struct net_device * dev , const unsigned char * addr , u16 flags ) ; int ( * ndo_fdb_del ) ( struct ndmsg * ndm , struct net_device * dev , const unsigned char * addr ) ; int ( * ndo_fdb_dump ) ( struct sk_buff * skb , struct netlink_callback * cb , struct net_device * dev , int idx ) ; int ( * ndo_bridge_setlink ) ( struct net_device * dev , struct nlmsghdr * nlh ) ; int ( * ndo_bridge_getlink ) ( struct sk_buff * skb , u32 pid , u32 seq , struct net_device * dev ) ; } ;
struct packet_type { __be16 type ; struct net_device * dev ; int ( * func ) ( struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ; K_bool ( * id_match ) ( struct packet_type * ptype , struct sock * sk ) ; void * af_packet_priv ; struct list_head list ; } ;
struct offload_callbacks { struct sk_buff * ( * gso_segment ) ( struct sk_buff * skb , netdev_features_t features ) ; int ( * gso_send_check ) ( struct sk_buff * skb ) ; struct sk_buff * * ( * gro_receive ) ( struct sk_buff * * head , struct sk_buff * skb ) ; int ( * gro_complete ) ( struct sk_buff * skb ) ; } ;
struct rta_session { __u8 proto ; __u8 pad1 ; __u16 pad2 ; union { struct { __u16 sport ; __u16 dport ; } ports ; struct { __u8 type ; __u8 code ; __u16 ident ; } icmpt ; __u32 spi ; } u ; } ;
struct in6_addr ;
struct sk_buff ;
typedef struct poll_table_struct { poll_queue_proc _qproc ; unsigned long _key ; } poll_table ;
struct rtnl_link_ops { struct list_head list ; const char * kind ; size_t priv_size ; void ( * setup ) ( struct net_device * dev ) ; int maxtype ; const struct nla_policy * policy ; int ( * validate ) ( struct nlattr * tb [ ] , struct nlattr * data [ ] ) ; int ( * newlink ) ( struct net * src_net , struct net_device * dev , struct nlattr * tb [ ] , struct nlattr * data [ ] ) ; int ( * changelink ) ( struct net_device * dev , struct nlattr * tb [ ] , struct nlattr * data [ ] ) ; void ( * dellink ) ( struct net_device * dev , struct list_head * head ) ; size_t ( * get_size ) ( const struct net_device * dev ) ; int ( * fill_info ) ( struct sk_buff * skb , const struct net_device * dev ) ; size_t ( * get_xstats_size ) ( const struct net_device * dev ) ; int ( * fill_xstats ) ( struct sk_buff * skb , const struct net_device * dev ) ; unsigned int ( * get_num_tx_queues ) ( void ) ; unsigned int ( * get_num_rx_queues ) ( void ) ; } ;
struct rtnl_af_ops { struct list_head list ; int family ; int ( * fill_link_af ) ( struct sk_buff * skb , const struct net_device * dev ) ; size_t ( * get_link_af_size ) ( const struct net_device * dev ) ; int ( * validate_link_af ) ( const struct net_device * dev , const struct nlattr * attr ) ; int ( * set_link_af ) ( struct net_device * dev , const struct nlattr * attr ) ; } ;
struct neigh_seq_state { struct seq_net_private p ; struct neigh_table * tbl ; struct neigh_hash_table * nht ; void * ( * neigh_sub_iter ) ( struct neigh_seq_state * state , struct neighbour * n , loff_t * pos ) ; unsigned int bucket ; unsigned int flags ; } ;
struct sk_buff ;
struct proto ;
struct proto { void ( * close ) ( struct sock * sk , long timeout ) ; int ( * connect ) ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) ; int ( * disconnect ) ( struct sock * sk , int flags ) ; struct sock * ( * accept ) ( struct sock * sk , int flags , int * err ) ; int ( * ioctl ) ( struct sock * sk , int cmd , unsigned long arg ) ; int ( * init ) ( struct sock * sk ) ; void ( * destroy ) ( struct sock * sk ) ; void ( * shutdown ) ( struct sock * sk , int how ) ; int ( * setsockopt ) ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ; int ( * getsockopt ) ( struct sock * sk , int level , int optname , char * optval , int * option ) ; int ( * compat_setsockopt ) ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ; int ( * compat_getsockopt ) ( struct sock * sk , int level , int optname , char * optval , int * option ) ; int ( * compat_ioctl ) ( struct sock * sk , unsigned int cmd , unsigned long arg ) ; int ( * sendmsg ) ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) ; int ( * recvmsg ) ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) ; int ( * sendpage ) ( struct sock * sk , struct page * page , int offset , size_t size , int flags ) ; int ( * bind ) ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) ; int ( * backlog_rcv ) ( struct sock * sk , struct sk_buff * skb ) ; void ( * release_cb ) ( struct sock * sk ) ; void ( * mtu_reduced ) ( struct sock * sk ) ; void ( * hash ) ( struct sock * sk ) ; void ( * unhash ) ( struct sock * sk ) ; void ( * rehash ) ( struct sock * sk ) ; int ( * get_port ) ( struct sock * sk , unsigned short snum ) ; void ( * clear_sk ) ( struct sock * sk , int size ) ; unsigned int inuse_idx ; void ( * enter_memory_pressure ) ( struct sock * sk ) ; atomic_long_t * memory_allocated ; struct percpu_counter * sockets_allocated ; int * memory_pressure ; long * sysctl_mem ; int * sysctl_wmem ; int * sysctl_rmem ; int max_header ; K_bool no_autobind ; struct kmem_cache * slab ; unsigned int obj_size ; int slab_flags ; struct percpu_counter * orphan_count ; struct request_sock_ops * rsk_prot ; struct timewait_sock_ops * twsk_prot ; union { struct inet_hashinfo * hashinfo ; struct udp_table * udp_table ; struct raw_hashinfo * raw_hash ; } h ; struct module * owner ; char name [ 32 ] ; struct list_head node ; } ;
struct sk_buff ;
struct proto ;
struct ip_options_rcu { struct callback_head rcu ; struct ip_options opt ; } ;
struct inet_connection_sock_af_ops { int ( * queue_xmit ) ( struct sk_buff * skb , struct flowi * fl ) ; void ( * send_check ) ( struct sock * sk , struct sk_buff * skb ) ; int ( * rebuild_header ) ( struct sock * sk ) ; void ( * sk_rx_dst_set ) ( struct sock * sk , const struct sk_buff * skb ) ; int ( * conn_request ) ( struct sock * sk , struct sk_buff * skb ) ; struct sock * ( * syn_recv_sock ) ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) ; u16 net_header_len ; u16 net_frag_header_len ; u16 sockaddr_len ; int ( * setsockopt ) ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ; int ( * getsockopt ) ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ; int ( * compat_setsockopt ) ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ; int ( * compat_getsockopt ) ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ; void ( * addr2sockaddr ) ( struct sock * sk , struct sockaddr * ) ; int ( * bind_conflict ) ( const struct sock * sk , const struct inet_bind_bucket * tb , K_bool relax ) ; } ;
union tcp_word_hdr { struct tcphdr hdr ; __be32 words [ 5 ] ; } ;
struct tcp_request_sock { struct inet_request_sock req ; const struct tcp_request_sock_ops * af_specific ; struct sock * listener ; u32 rcv_isn ; u32 snt_isn ; u32 snt_synack ; u32 rcv_nxt ; } ;
struct tc_u32_sel { unsigned char flags ; unsigned char offshift ; unsigned char nkeys ; __be16 offmask ; __u16 off ; short offoff ; short hoff ; __be32 hmask ; struct tc_u32_key keys [ 0 ] ; } ;
struct solaris_x86_vtoc { unsigned int v_bootinfo [ 3 ] ; __le32 v_sanity ; __le32 v_version ; char v_volume [ 8 ] ; __le16 v_sectorsz ; __le16 v_nparts ; unsigned int v_reserved [ 10 ] ; struct solaris_x86_slice v_slice [ 16 ] ; unsigned int timestamp [ 16 ] ; char v_asciilabel [ 128 ] ; } ;
struct bsd_disklabel { __le32 d_magic ; __s16 d_type ; __s16 d_subtype ; char d_typename [ 16 ] ; char d_packname [ 16 ] ; __u32 d_secsize ; __u32 d_nsectors ; __u32 d_ntracks ; __u32 d_ncylinders ; __u32 d_secpercyl ; __u32 d_secperunit ; __u16 d_sparespertrack ; __u16 d_sparespercyl ; __u32 d_acylinders ; __u16 d_rpm ; __u16 d_interleave ; __u16 d_trackskew ; __u16 d_cylskew ; __u32 d_headswitch ; __u32 d_trkseek ; __u32 d_flags ; __u32 d_drivedata [ 5 ] ; __u32 d_spare [ 5 ] ; __le32 d_magic2 ; __le16 d_checksum ; __le16 d_npartitions ; __le32 d_bbsize ; __le32 d_sbsize ; struct bsd_partition { __le32 p_size ; __le32 p_offset ; __le32 p_fsize ; __u8 p_fstype ; __u8 p_frag ; __le16 p_cpg ; } d_partitions [ 16 ] ; } ;
struct io_cq { struct request_queue * q ; struct io_context * ioc ; union { struct list_head q_node ; struct kmem_cache * __rcu_icq_cache ; } ; union { struct hlist_node ioc_node ; struct callback_head __rcu_head ; } ; unsigned int flags ; } ;
struct bsg_class_device { struct device * class_dev ; struct device * parent ; int minor ; struct request_queue * queue ; struct kref ref ; void ( * release ) ( struct device * ) ; } ;
struct io_cq ;
struct elevator_ops { elevator_merge_fn * elevator_merge_fn ; elevator_merged_fn * elevator_merged_fn ; elevator_merge_req_fn * elevator_merge_req_fn ; elevator_allow_merge_fn * elevator_allow_merge_fn ; elevator_bio_merged_fn * elevator_bio_merged_fn ; elevator_dispatch_fn * elevator_dispatch_fn ; elevator_add_req_fn * elevator_add_req_fn ; elevator_activate_req_fn * elevator_activate_req_fn ; elevator_deactivate_req_fn * elevator_deactivate_req_fn ; elevator_completed_req_fn * elevator_completed_req_fn ; elevator_request_list_fn * elevator_former_req_fn ; elevator_request_list_fn * elevator_latter_req_fn ; elevator_init_icq_fn * elevator_init_icq_fn ; elevator_exit_icq_fn * elevator_exit_icq_fn ; elevator_set_req_fn * elevator_set_req_fn ; elevator_put_req_fn * elevator_put_req_fn ; elevator_may_queue_fn * elevator_may_queue_fn ; elevator_init_fn * elevator_init_fn ; elevator_exit_fn * elevator_exit_fn ; } ;
struct elv_fs_entry { struct attribute attr ; ssize_t ( * show ) ( struct elevator_queue * , char * ) ; ssize_t ( * store ) ( struct elevator_queue * , const char * , size_t ) ; } ;
typedef void ( * blk_plug_cb_fn ) ( struct blk_plug_cb * , K_bool ) ;
struct work_struct ;
struct ablkcipher_request { struct crypto_async_request base ; unsigned int nbytes ; void * info ; struct scatterlist * src ; struct scatterlist * dst ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;
struct aead_request { struct crypto_async_request base ; unsigned int assoclen ; unsigned int cryptlen ; u8 * iv ; struct scatterlist * assoc ; struct scatterlist * src ; struct scatterlist * dst ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;
struct ahash_request { struct crypto_async_request base ; unsigned int nbytes ; struct scatterlist * src ; u8 * result ; void * priv ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;
typedef struct journal_header_s { __be32 h_magic ; __be32 h_blocktype ; __be32 h_sequence ; } journal_header_t ;
typedef struct journal_block_tag_s { __be32 t_blocknr ; __be16 t_checksum ; __be16 t_flags ; __be32 t_blocknr_high ; } journal_block_tag_t ;
struct jbd2_buffer_trigger_type { void ( * t_frozen ) ( struct jbd2_buffer_trigger_type * type , struct buffer_head * bh , void * mapped_data , size_t size ) ; void ( * t_abort ) ( struct jbd2_buffer_trigger_type * type , struct buffer_head * bh ) ; } ;
struct fid { union { struct { u32 ino ; u32 gen ; u32 parent_ino ; u32 parent_gen ; } i32 ; struct { u32 block ; u16 partref ; u16 parent_partref ; u32 generation ; u32 parent_block ; u32 parent_generation ; } udf ; __u32 raw [ 0 ] ; } ; } ;
struct cleancache_filekey { union { ino_t ino ; __u32 fh [ 6 ] ; u32 key [ 6 ] ; } u ; } ;
struct scsi_host_template { struct module * module ; const char * name ; int ( * detect ) ( struct scsi_host_template * ) ; int ( * release ) ( struct Scsi_Host * ) ; const char * ( * info ) ( struct Scsi_Host * ) ; int ( * ioctl ) ( struct scsi_device * dev , int cmd , void * arg ) ; int ( * compat_ioctl ) ( struct scsi_device * dev , int cmd , void * arg ) ; int ( * queuecommand ) ( struct Scsi_Host * , struct scsi_cmnd * ) ; int ( * transfer_response ) ( struct scsi_cmnd * , void ( * done ) ( struct scsi_cmnd * ) ) ; int ( * eh_abort_handler ) ( struct scsi_cmnd * ) ; int ( * eh_device_reset_handler ) ( struct scsi_cmnd * ) ; int ( * eh_target_reset_handler ) ( struct scsi_cmnd * ) ; int ( * eh_bus_reset_handler ) ( struct scsi_cmnd * ) ; int ( * eh_host_reset_handler ) ( struct scsi_cmnd * ) ; int ( * slave_alloc ) ( struct scsi_device * ) ; int ( * slave_configure ) ( struct scsi_device * ) ; void ( * slave_destroy ) ( struct scsi_device * ) ; int ( * target_alloc ) ( struct scsi_target * ) ; void ( * target_destroy ) ( struct scsi_target * ) ; int ( * scan_finished ) ( struct Scsi_Host * , unsigned long ) ; void ( * scan_start ) ( struct Scsi_Host * ) ; int ( * change_queue_depth ) ( struct scsi_device * , int , int ) ; int ( * change_queue_type ) ( struct scsi_device * , int ) ; int ( * bios_param ) ( struct scsi_device * , struct block_device * , sector_t , int [ ] ) ; void ( * unlock_native_capacity ) ( struct scsi_device * ) ; int ( * proc_info ) ( struct Scsi_Host * , char * , char * * , off_t , int , int ) ; enum blk_eh_timer_return ( * eh_timed_out ) ( struct scsi_cmnd * ) ; int ( * host_reset ) ( struct Scsi_Host * shost , int reset_type ) ; const char * proc_name ; struct proc_dir_entry * proc_dir ; int can_queue ; int this_id ; unsigned short sg_tablesize ; unsigned short sg_prot_tablesize ; unsigned short max_sectors ; unsigned long dma_boundary ; short cmd_per_lun ; unsigned char present ; unsigned supported_mode : 2 ; unsigned unchecked_isa_dma : 1 ; unsigned use_clustering : 1 ; unsigned emulated : 1 ; unsigned skip_settle_delay : 1 ; unsigned ordered_tag : 1 ; unsigned int max_host_blocked ; struct device_attribute * * shost_attrs ; struct device_attribute * * sdev_attrs ; struct list_head legacy_hosts ; u64 vendor_id ; } ;
typedef acpi_status ( * acpi_sleep_function ) ( u8 sleep_state ) ;
union acpi_object { acpi_object_type type ; struct { acpi_object_type type ; u64 value ; } integer ; struct { acpi_object_type type ; u32 length ; char * pointer ; } string ; struct { acpi_object_type type ; u32 length ; u8 * pointer ; } buffer ; struct { acpi_object_type type ; u32 count ; union acpi_object * elements ; } package ; struct { acpi_object_type type ; acpi_object_type actual_type ; acpi_handle handle ; } reference ; struct { acpi_object_type type ; u32 proc_id ; acpi_io_address pblk_address ; u32 pblk_length ; } processor ; struct { acpi_object_type type ; u32 system_level ; u32 resource_order ; } power_resource ; } ;
typedef acpi_status ( * acpi_init_handler ) ( acpi_handle object , u32 function ) ;
typedef acpi_status ( * acpi_exception_handler ) ( acpi_status aml_status , acpi_name name , u16 opcode , u32 aml_offset , void * context ) ;
typedef acpi_status ( * acpi_tbl_handler ) ( u32 event , void * table , void * context ) ;
typedef acpi_status ( * acpi_adr_space_handler ) ( u32 function , acpi_physical_address address , u32 bit_width , u64 * value , void * handler_context , void * region_context ) ;
typedef acpi_status ( * acpi_adr_space_setup ) ( acpi_handle region_handle , u32 function , void * handler_context , void * * region_context ) ;
typedef acpi_status ( * acpi_walk_callback ) ( acpi_handle object , u32 nesting_level , void * context , void * * return_value ) ;
struct acpi_device_info { u32 info_size ; u32 name ; acpi_object_type type ; u8 param_count ; u8 valid ; u8 flags ; u8 highest_dstates [ 4 ] ; u8 lowest_dstates [ 5 ] ; u32 current_status ; u64 address ; struct acpi_pnp_device_id hardware_id ; struct acpi_pnp_device_id unique_id ; struct acpi_pnp_device_id subsystem_id ; struct acpi_pnp_device_id_list compatible_id_list ; } ;
struct acpi_einj_entry { struct acpi_whea_header whea_header ; } ;
struct acpi_erst_entry { struct acpi_whea_header whea_header ; } ;
struct acpi_resource_address { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; } ;
struct acpi_resource_address16 { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; u16 granularity ; u16 minimum ; u16 maximum ; u16 translation_offset ; u16 address_length ; struct acpi_resource_source resource_source ; } ;
struct acpi_resource_address32 { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; u32 granularity ; u32 minimum ; u32 maximum ; u32 translation_offset ; u32 address_length ; struct acpi_resource_source resource_source ; } ;
struct acpi_resource_address64 { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; u64 granularity ; u64 minimum ; u64 maximum ; u64 translation_offset ; u64 address_length ; struct acpi_resource_source resource_source ; } ;
struct acpi_resource_extended_address64 { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; u8 revision_ID ; u64 granularity ; u64 minimum ; u64 maximum ; u64 translation_offset ; u64 address_length ; u64 type_specific ; } ;
typedef acpi_status ( * acpi_walk_resource_callback ) ( struct acpi_resource * resource , void * context ) ;
struct acpi_device_ops { acpi_op_add add ; acpi_op_remove remove ; acpi_op_start start ; acpi_op_bind bind ; acpi_op_unbind unbind ; acpi_op_notify notify ; } ;
struct acpi_device_power { int state ; struct acpi_device_power_flags flags ; struct acpi_device_power_state states [ 5 ] ; } ;
struct acpi_dock_ops { acpi_notify_handler handler ; acpi_notify_handler uevent ; } ;
struct acpi_osc_context { char * uuid_str ; int rev ; struct acpi_buffer cap ; struct acpi_buffer ret ; } ;
struct cdrom_subchnl { __u8 cdsc_format ; __u8 cdsc_audiostatus ; __u8 cdsc_adr : 4 ; __u8 cdsc_ctrl : 4 ; __u8 cdsc_trk ; __u8 cdsc_ind ; union cdrom_addr cdsc_absaddr ; union cdrom_addr cdsc_reladdr ; } ;
struct cdrom_tocentry { __u8 cdte_track ; __u8 cdte_adr : 4 ; __u8 cdte_ctrl : 4 ; __u8 cdte_format ; union cdrom_addr cdte_addr ; __u8 cdte_datamode ; } ;
struct cdrom_read_audio { union cdrom_addr addr ; __u8 addr_format ; int nframes ; __u8 * buf ; } ;
struct cdrom_multisession { union cdrom_addr addr ; __u8 xa_flag ; __u8 addr_format ; } ;
typedef struct { __be16 disc_information_length ; __u8 disc_status : 2 ; __u8 border_status : 2 ; __u8 erasable : 1 ; __u8 reserved1 : 3 ; __u8 n_first_track ; __u8 n_sessions_lsb ; __u8 first_track_lsb ; __u8 last_track_lsb ; __u8 mrw_status : 2 ; __u8 dbit : 1 ; __u8 reserved2 : 2 ; __u8 uru : 1 ; __u8 dbc_v : 1 ; __u8 did_v : 1 ; __u8 disc_type ; __u8 n_sessions_msb ; __u8 first_track_msb ; __u8 last_track_msb ; __u32 disc_id ; __u32 lead_in ; __u32 lead_out ; __u8 disc_bar_code [ 8 ] ; __u8 reserved3 ; __u8 n_opc ; } disc_information ;
typedef struct { __be16 track_information_length ; __u8 track_lsb ; __u8 session_lsb ; __u8 reserved1 ; __u8 track_mode : 4 ; __u8 copy : 1 ; __u8 damage : 1 ; __u8 reserved2 : 2 ; __u8 data_mode : 4 ; __u8 fp : 1 ; __u8 packet : 1 ; __u8 blank : 1 ; __u8 rt : 1 ; __u8 nwa_v : 1 ; __u8 lra_v : 1 ; __u8 reserved3 : 6 ; __be32 track_start ; __be32 next_writable ; __be32 free_blocks ; __be32 fixed_packet_size ; __be32 track_size ; __be32 last_rec_address ; } track_information ;
typedef struct { __u8 page_code : 6 ; __u8 reserved1 : 1 ; __u8 ps : 1 ; __u8 page_length ; __u8 write_type : 4 ; __u8 test_write : 1 ; __u8 ls_v : 1 ; __u8 bufe : 1 ; __u8 reserved2 : 1 ; __u8 track_mode : 4 ; __u8 copy : 1 ; __u8 fp : 1 ; __u8 multi_session : 2 ; __u8 data_block_type : 4 ; __u8 reserved3 : 4 ; __u8 link_size ; __u8 reserved4 ; __u8 app_code : 6 ; __u8 reserved5 : 2 ; __u8 session_format ; __u8 reserved6 ; __be32 packet_size ; __u16 audio_pause ; __u8 mcn [ 16 ] ; __u8 isrc [ 16 ] ; __u8 subhdr0 ; __u8 subhdr1 ; __u8 subhdr2 ; __u8 subhdr3 ; } __attribute__ ( ( packed ) ) write_param_page ;
struct ata_port_operations ;
struct ata_queued_cmd ;
struct ata_queued_cmd { struct ata_port * ap ; struct ata_device * dev ; struct scsi_cmnd * scsicmd ; void ( * scsidone ) ( struct scsi_cmnd * ) ; struct ata_taskfile tf ; u8 cdb [ ATAPI_CDB_LEN ] ; unsigned long flags ; unsigned int tag ; unsigned int n_elem ; unsigned int orig_n_elem ; int dma_dir ; unsigned int sect_size ; unsigned int nbytes ; unsigned int extrabytes ; unsigned int curbytes ; struct scatterlist sgent ; struct scatterlist * sg ; struct scatterlist * cursg ; unsigned int cursg_ofs ; unsigned int err_mask ; struct ata_taskfile result_tf ; ata_qc_cb_t complete_fn ; void * private_data ; void * lldd_task ; } ;
struct ata_port_operations { int ( * qc_defer ) ( struct ata_queued_cmd * qc ) ; int ( * check_atapi_dma ) ( struct ata_queued_cmd * qc ) ; void ( * qc_prep ) ( struct ata_queued_cmd * qc ) ; unsigned int ( * qc_issue ) ( struct ata_queued_cmd * qc ) ; K_bool ( * qc_fill_rtf ) ( struct ata_queued_cmd * qc ) ; int ( * cable_detect ) ( struct ata_port * ap ) ; unsigned long ( * mode_filter ) ( struct ata_device * dev , unsigned long xfer_mask ) ; void ( * set_piomode ) ( struct ata_port * ap , struct ata_device * dev ) ; void ( * set_dmamode ) ( struct ata_port * ap , struct ata_device * dev ) ; int ( * set_mode ) ( struct ata_link * link , struct ata_device * * r_failed_dev ) ; unsigned int ( * read_id ) ( struct ata_device * dev , struct ata_taskfile * tf , u16 * id ) ; void ( * dev_config ) ( struct ata_device * dev ) ; void ( * freeze ) ( struct ata_port * ap ) ; void ( * thaw ) ( struct ata_port * ap ) ; ata_prereset_fn_t prereset ; ata_reset_fn_t softreset ; ata_reset_fn_t hardreset ; ata_postreset_fn_t postreset ; ata_prereset_fn_t pmp_prereset ; ata_reset_fn_t pmp_softreset ; ata_reset_fn_t pmp_hardreset ; ata_postreset_fn_t pmp_postreset ; void ( * error_handler ) ( struct ata_port * ap ) ; void ( * lost_interrupt ) ( struct ata_port * ap ) ; void ( * post_internal_cmd ) ( struct ata_queued_cmd * qc ) ; void ( * sched_eh ) ( struct ata_port * ap ) ; void ( * end_eh ) ( struct ata_port * ap ) ; int ( * scr_read ) ( struct ata_link * link , unsigned int sc_reg , u32 * val ) ; int ( * scr_write ) ( struct ata_link * link , unsigned int sc_reg , u32 val ) ; void ( * pmp_attach ) ( struct ata_port * ap ) ; void ( * pmp_detach ) ( struct ata_port * ap ) ; int ( * set_lpm ) ( struct ata_link * link , enum ata_lpm_policy policy , unsigned hints ) ; int ( * port_suspend ) ( struct ata_port * ap , pm_message_t mesg ) ; int ( * port_resume ) ( struct ata_port * ap ) ; int ( * port_start ) ( struct ata_port * ap ) ; void ( * port_stop ) ( struct ata_port * ap ) ; void ( * host_stop ) ( struct ata_host * host ) ; void ( * sff_dev_select ) ( struct ata_port * ap , unsigned int device ) ; void ( * sff_set_devctl ) ( struct ata_port * ap , u8 ctl ) ; u8 ( * sff_check_status ) ( struct ata_port * ap ) ; u8 ( * sff_check_altstatus ) ( struct ata_port * ap ) ; void ( * sff_tf_load ) ( struct ata_port * ap , const struct ata_taskfile * tf ) ; void ( * sff_tf_read ) ( struct ata_port * ap , struct ata_taskfile * tf ) ; void ( * sff_exec_command ) ( struct ata_port * ap , const struct ata_taskfile * tf ) ; unsigned int ( * sff_data_xfer ) ( struct ata_device * dev , unsigned char * buf , unsigned int buflen , int rw ) ; void ( * sff_irq_on ) ( struct ata_port * ) ; K_bool ( * sff_irq_check ) ( struct ata_port * ) ; void ( * sff_irq_clear ) ( struct ata_port * ) ; void ( * sff_drain_fifo ) ( struct ata_queued_cmd * qc ) ; void ( * bmdma_setup ) ( struct ata_queued_cmd * qc ) ; void ( * bmdma_start ) ( struct ata_queued_cmd * qc ) ; void ( * bmdma_stop ) ( struct ata_queued_cmd * qc ) ; u8 ( * bmdma_status ) ( struct ata_port * ap ) ; ssize_t ( * em_show ) ( struct ata_port * ap , char * buf ) ; ssize_t ( * em_store ) ( struct ata_port * ap , const char * message , size_t size ) ; ssize_t ( * sw_activity_show ) ( struct ata_device * dev , char * buf ) ; ssize_t ( * sw_activity_store ) ( struct ata_device * dev , enum sw_activity val ) ; void ( * phy_reset ) ( struct ata_port * ap ) ; void ( * eng_timeout ) ( struct ata_port * ap ) ; const struct ata_port_operations * inherits ; } ;
struct input_handler { void * private_ ; void ( * event ) ( struct input_handle * handle , unsigned int type , unsigned int code , int value ) ; void ( * events ) ( struct input_handle * handle , const struct input_value * vals , unsigned int count ) ; K_bool ( * filter ) ( struct input_handle * handle , unsigned int type , unsigned int code , int value ) ; K_bool ( * match ) ( struct input_handler * handler , struct input_dev * dev ) ; int ( * connect ) ( struct input_handler * handler , struct input_dev * dev , const struct input_device_id * id ) ; void ( * disconnect ) ( struct input_handle * handle ) ; void ( * start ) ( struct input_handle * handle ) ; K_bool legacy_minors ; int minor ; const char * name ; const struct input_device_id * id_table ; struct list_head h_list ; struct list_head node ; } ;
struct sk_buff ;
struct restart_block { long ( * fn ) ( struct restart_block * ) ; union { struct { u32 * uaddr ; u32 val ; u32 flags ; u32 bitset ; u64 time ; u32 * uaddr2 ; } futex ; struct { clockid_t clockid ; struct timespec * rmtp ; struct compat_timespec * compat_rmtp ; u64 expires ; } nanosleep ; struct { struct pollfd * ufds ; int nfds ; int has_timeout ; unsigned long tv_sec ; unsigned long tv_nsec ; } poll ; } ; } ;
struct thread_struct ;
struct pv_mmu_ops { unsigned long ( * read_cr2 ) ( void ) ; void ( * write_cr2 ) ( unsigned long ) ; unsigned long ( * read_cr3 ) ( void ) ; void ( * write_cr3 ) ( unsigned long ) ; void ( * activate_mm ) ( struct mm_struct * prev , struct mm_struct * next ) ; void ( * dup_mmap ) ( struct mm_struct * oldmm , struct mm_struct * mm ) ; void ( * exit_mmap ) ( struct mm_struct * mm ) ; void ( * flush_tlb_user ) ( void ) ; void ( * flush_tlb_kernel ) ( void ) ; void ( * flush_tlb_single ) ( unsigned long addr ) ; void ( * flush_tlb_others ) ( const struct cpumask * cpus , struct mm_struct * mm , unsigned long start , unsigned long end ) ; int ( * pgd_alloc ) ( struct mm_struct * mm ) ; void ( * pgd_free ) ( struct mm_struct * mm , pgd_t * pgd ) ; void ( * alloc_pte ) ( struct mm_struct * mm , unsigned long pfn ) ; void ( * alloc_pmd ) ( struct mm_struct * mm , unsigned long pfn ) ; void ( * alloc_pud ) ( struct mm_struct * mm , unsigned long pfn ) ; void ( * release_pte ) ( unsigned long pfn ) ; void ( * release_pmd ) ( unsigned long pfn ) ; void ( * release_pud ) ( unsigned long pfn ) ; void ( * set_pte ) ( pte_t * ptep , pte_t pteval ) ; void ( * set_pte_at ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep , pte_t pteval ) ; void ( * set_pmd ) ( pmd_t * pmdp , pmd_t pmdval ) ; void ( * set_pmd_at ) ( struct mm_struct * mm , unsigned long addr , pmd_t * pmdp , pmd_t pmdval ) ; void ( * pte_update ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep ) ; void ( * pte_update_defer ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep ) ; void ( * pmd_update ) ( struct mm_struct * mm , unsigned long addr , pmd_t * pmdp ) ; void ( * pmd_update_defer ) ( struct mm_struct * mm , unsigned long addr , pmd_t * pmdp ) ; pte_t ( * ptep_modify_prot_start ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep ) ; void ( * ptep_modify_prot_commit ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep , pte_t pte ) ; struct paravirt_callee_save pte_val ; struct paravirt_callee_save make_pte ; struct paravirt_callee_save pgd_val ; struct paravirt_callee_save make_pgd ; void ( * set_pud ) ( pud_t * pudp , pud_t pudval ) ; struct paravirt_callee_save pmd_val ; struct paravirt_callee_save make_pmd ; struct paravirt_callee_save pud_val ; struct paravirt_callee_save make_pud ; void ( * set_pgd ) ( pgd_t * pudp , pgd_t pgdval ) ; struct pv_lazy_ops lazy_mode ; void ( * set_fixmap ) ( unsigned idx , phys_addr_t phys , pgprot_t flags ) ; } ;
struct arch_spinlock ;
struct _xstate { struct _fpstate fpstate ; struct _xsave_hdr xstate_hdr ; struct _ymmh_state ymmh ; } ;
struct msr_info { u32 msr_no ; struct msr reg ; struct msr * msrs ; int err ; } ;
struct xsave_struct { struct i387_fxsave_struct i387 ; struct xsave_hdr_struct xsave_hdr ; struct ymmh_struct ymmh ; } __attribute__ ( ( packed , aligned ( 64 ) ) ) ;
struct thread_struct { struct desc_struct tls_array [ 3 ] ; unsigned long sp0 ; unsigned long sp ; unsigned long usersp ; unsigned short es ; unsigned short ds ; unsigned short fsindex ; unsigned short gsindex ; unsigned long fs ; unsigned long gs ; struct perf_event * ptrace_bps [ 4 ] ; unsigned long debugreg6 ; unsigned long ptrace_dr7 ; unsigned long cr2 ; unsigned long trap_nr ; unsigned long error_code ; struct fpu fpu ; unsigned long * io_bitmap_ptr ; unsigned long iopl ; unsigned io_bitmap_max ; } ;
typedef struct { arch_rwlock_t raw_lock ; } rwlock_t ;
struct kstat { u64 ino ; dev_t dev ; umode_t mode ; unsigned int nlink ; kuid_t uid ; kgid_t gid ; dev_t rdev ; loff_t size ; struct timespec atime ; struct timespec mtime ; struct timespec ctime ; unsigned long blksize ; unsigned long long blocks ; } ;
struct wait_bit_queue { struct wait_bit_key key ; wait_queue_t wait ; } ;
struct hrtimer ;
struct delayed_work { struct work_struct work ; struct timer_list timer ; int cpu ; } ;
struct execute_work { struct work_struct work ; } ;
struct ctl_table ;
struct edd_info { __u8 device ; __u8 version ; __u16 interface_support ; __u16 legacy_max_cylinder ; __u8 legacy_max_head ; __u8 legacy_sectors_per_track ; struct edd_device_params params ; } __attribute__ ( ( packed ) ) ;
struct vcpu_guest_context { struct { char x [ 512 ] ; } fpu_ctxt ; unsigned long flags ; struct cpu_user_regs user_regs ; struct trap_info trap_ctxt [ 256 ] ; unsigned long ldt_base , ldt_ents ; unsigned long gdt_frames [ 16 ] , gdt_ents ; unsigned long kernel_ss , kernel_sp ; unsigned long ctrlreg [ 8 ] ; unsigned long debugreg [ 8 ] ; unsigned long event_callback_eip ; unsigned long failsafe_callback_eip ; unsigned long syscall_callback_eip ; unsigned long vm_assist ; K_uint64_t fs_base ; K_uint64_t gs_base_kernel ; K_uint64_t gs_base_user ; } ;
struct start_info { char magic [ 32 ] ; unsigned long nr_pages ; unsigned long shared_info ; K_uint32_t flags ; xen_pfn_t store_mfn ; K_uint32_t store_evtchn ; union { struct { xen_pfn_t mfn ; K_uint32_t evtchn ; } domU ; struct { K_uint32_t info_off ; K_uint32_t info_size ; } dom0 ; } console ; unsigned long pt_base ; unsigned long nr_pt_frames ; unsigned long mfn_list ; unsigned long mod_start ; unsigned long mod_len ; K_int8_t cmd_line [ 1024 ] ; } ;
struct dom0_vga_console_info { K_uint8_t video_type ; union { struct { K_uint16_t font_height ; K_uint16_t cursor_x , cursor_y ; K_uint16_t rows , columns ; } text_mode_3 ; struct { K_uint16_t width , height ; K_uint16_t bytes_per_line ; K_uint16_t bits_per_pixel ; K_uint32_t lfb_base ; K_uint32_t lfb_size ; K_uint8_t red_pos , red_size ; K_uint8_t green_pos , green_size ; K_uint8_t blue_pos , blue_size ; K_uint8_t rsvd_pos , rsvd_size ; K_uint32_t gbl_caps ; K_uint16_t mode_attrs ; } vesa_lfb ; } u ; } ;
struct tmem_op { K_uint32_t cmd ; K_int32_t pool_id ; union { struct { K_uint64_t uuid [ 2 ] ; K_uint32_t flags ; } new_ ; struct { K_uint64_t oid [ 3 ] ; K_uint32_t index ; K_uint32_t tmem_offset ; K_uint32_t pfn_offset ; K_uint32_t len ; __guest_handle_void gmfn ; } gen ; } u ; } ;
struct ctl_table ;
struct ctl_dir ;
struct ctl_table { const char * procname ; void * data ; int maxlen ; umode_t mode ; struct ctl_table * child ; proc_handler * proc_handler ; struct ctl_table_poll * poll ; void * extra1 ; void * extra2 ; } ;
struct ctl_dir { struct ctl_table_header header ; struct rb_root root ; } ;
struct cred ;
struct subprocess_info { struct work_struct work ; struct completion * complete ; char * path ; char * * argv ; char * * envp ; int wait ; int retval ; int ( * init ) ( struct subprocess_info * info , struct cred * new_ ) ; void ( * cleanup ) ( struct subprocess_info * info ) ; void * data ; } ;
typedef struct dynamic { Elf32_Sword d_tag ; union { Elf32_Sword d_val ; Elf32_Addr d_ptr ; } d_un ; } Elf32_Dyn ;
typedef struct { Elf64_Sxword d_tag ; union { Elf64_Xword d_val ; Elf64_Addr d_ptr ; } d_un ; } Elf64_Dyn ;
struct module_kobject { struct kobject kobj ; struct module * mod ; struct kobject * drivers_dir ; struct module_param_attrs * mp ; } ;
struct module_version_attribute { struct module_attribute mattr ; const char * module_name ; const char * version ; } __attribute__ ( ( __aligned__ ( sizeof ( void * ) ) ) ) ;
struct hrtimer_clock_base ;
struct hrtimer { struct timerqueue_node node ; ktime_t _softexpires ; enum hrtimer_restart ( * function ) ( struct hrtimer * ) ; struct hrtimer_clock_base * base ; unsigned long state ; int start_pid ; void * start_site ; char start_comm [ 16 ] ; } ;
struct hrtimer_clock_base { struct hrtimer_cpu_base * cpu_base ; int index ; clockid_t clockid ; struct timerqueue_head active ; ktime_t resolution ; ktime_t ( * get_time ) ( void ) ; ktime_t softirq_time ; ktime_t offset ; } ;
struct clock_event_device ;
struct nameidata ;
struct bio_integrity_payload ;
struct cgroup_subsys_state ;
struct nameidata ;
struct cred ;
struct iattr { unsigned int ia_valid ; umode_t ia_mode ; kuid_t ia_uid ; kgid_t ia_gid ; loff_t ia_size ; struct timespec ia_atime ; struct timespec ia_mtime ; struct timespec ia_ctime ; struct file * ia_file ; } ;
typedef struct fs_quota_stat { __s8 qs_version ; __u16 qs_flags ; __s8 qs_pad ; fs_qfilestat_t qs_uquota ; fs_qfilestat_t qs_gquota ; __u32 qs_incoredqs ; __s32 qs_btimelimit ; __s32 qs_itimelimit ; __s32 qs_rtbtimelimit ; __u16 qs_bwarnlimit ; __u16 qs_iwarnlimit ; } fs_quota_stat_t ;
struct inode_operations { struct dentry * ( * lookup ) ( struct inode * , struct dentry * , unsigned int ) ; void * ( * follow_link ) ( struct dentry * , struct nameidata * ) ; int ( * permission ) ( struct inode * , int ) ; struct posix_acl * ( * get_acl ) ( struct inode * , int ) ; int ( * readlink ) ( struct dentry * , char * , int ) ; void ( * put_link ) ( struct dentry * , struct nameidata * , void * ) ; int ( * create ) ( struct inode * , struct dentry * , umode_t , K_bool ) ; int ( * link ) ( struct dentry * , struct inode * , struct dentry * ) ; int ( * unlink ) ( struct inode * , struct dentry * ) ; int ( * symlink ) ( struct inode * , struct dentry * , const char * ) ; int ( * mkdir ) ( struct inode * , struct dentry * , umode_t ) ; int ( * rmdir ) ( struct inode * , struct dentry * ) ; int ( * mknod ) ( struct inode * , struct dentry * , umode_t , dev_t ) ; int ( * rename ) ( struct inode * , struct dentry * , struct inode * , struct dentry * ) ; int ( * setattr ) ( struct dentry * , struct iattr * ) ; int ( * getattr ) ( struct vfsmount * mnt , struct dentry * , struct kstat * ) ; int ( * setxattr ) ( struct dentry * , const char * , const void * , size_t , int ) ; ssize_t ( * getxattr ) ( struct dentry * , const char * , void * , size_t ) ; ssize_t ( * listxattr ) ( struct dentry * , char * , size_t ) ; int ( * removexattr ) ( struct dentry * , const char * ) ; int ( * fiemap ) ( struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ; int ( * update_time ) ( struct inode * , struct timespec * , int ) ; int ( * atomic_open ) ( struct inode * , struct dentry * , struct file * , unsigned open_flag , umode_t create_mode , int * opened ) ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct ctl_table ;
struct kmem_cache { struct kmem_cache_cpu * cpu_slab ; unsigned long flags ; unsigned long min_partial ; int size ; int object_size ; int offset ; int cpu_partial ; struct kmem_cache_order_objects oo ; struct kmem_cache_order_objects max ; struct kmem_cache_order_objects min ; gfp_t allocflags ; int refcount ; void ( * ctor ) ( void * ) ; int inuse ; int align ; int reserved ; const char * name ; struct list_head list ; struct kobject kobj ; int remote_node_defrag_ratio ; struct kmem_cache_node * node [ ( 1 << 6 ) ] ; } ;
struct ctl_table ;
struct siginfo ;
struct k_sigaction { struct sigaction sa ; } ;
struct siginfo ;
struct class_attribute_string { struct class_attribute attr ; char * str ; } ;
struct dev_ext_attribute { struct device_attribute attr ; void * var ; } ;
struct clock_event_device ;
struct clock_event_device { void ( * event_handler ) ( struct clock_event_device * ) ; int ( * set_next_event ) ( unsigned long evt , struct clock_event_device * ) ; int ( * set_next_ktime ) ( ktime_t expires , struct clock_event_device * ) ; ktime_t next_event ; u64 max_delta_ns ; u64 min_delta_ns ; u32 mult ; u32 shift ; enum clock_event_mode mode ; unsigned int features ; unsigned long retries ; void ( * broadcast ) ( const struct cpumask * mask ) ; void ( * set_mode ) ( enum clock_event_mode mode , struct clock_event_device * ) ; void ( * suspend ) ( struct clock_event_device * ) ; void ( * resume ) ( struct clock_event_device * ) ; unsigned long min_delta_ticks ; unsigned long max_delta_ticks ; const char * name ; int rating ; int irq ; const struct cpumask * cpumask ; struct list_head list ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct pci_slot { struct pci_bus * bus ; struct list_head list ; struct hotplug_slot * hotplug ; unsigned char number ; struct kobject kobj ; } ;
struct user_struct ;
struct mm_walk { int ( * pgd_entry ) ( pgd_t * , unsigned long , unsigned long , struct mm_walk * ) ; int ( * pud_entry ) ( pud_t * , unsigned long , unsigned long , struct mm_walk * ) ; int ( * pmd_entry ) ( pmd_t * , unsigned long , unsigned long , struct mm_walk * ) ; int ( * pte_entry ) ( pte_t * , unsigned long , unsigned long , struct mm_walk * ) ; int ( * pte_hole ) ( unsigned long , unsigned long , struct mm_walk * ) ; int ( * hugetlb_entry ) ( pte_t * , unsigned long , unsigned long , unsigned long , struct mm_walk * ) ; struct mm_struct * mm ; void * private_ ; } ;
typedef int ( * pte_fn_t ) ( pte_t * pte , pgtable_t token , unsigned long addr , void * data ) ;
struct user_struct ;
struct cred ;
struct user_struct ;
struct cred ;
struct group_info { atomic_t usage ; int ngroups ; int nblocks ; kgid_t small_block [ 32 ] ; kgid_t * blocks [ 0 ] ; } ;
struct cred { atomic_t usage ; kuid_t uid ; kgid_t gid ; kuid_t suid ; kgid_t sgid ; kuid_t euid ; kgid_t egid ; kuid_t fsuid ; kgid_t fsgid ; unsigned securebits ; kernel_cap_t cap_inheritable ; kernel_cap_t cap_permitted ; kernel_cap_t cap_effective ; kernel_cap_t cap_bset ; unsigned char jit_keyring ; struct key * session_keyring ; struct key * process_keyring ; struct key * thread_keyring ; struct key * request_key_auth ; struct user_struct * user ; struct user_namespace * user_ns ; struct group_info * group_info ; struct callback_head rcu ; } ;
struct user_struct { atomic_t __count ; atomic_t processes ; atomic_t files ; atomic_t sigpending ; atomic_t inotify_watches ; atomic_t inotify_devs ; atomic_t fanotify_listeners ; atomic_long_t epoll_watches ; unsigned long mq_bytes ; unsigned long locked_shm ; struct key * uid_keyring ; struct key * session_keyring ; struct hlist_node uidhash_node ; kuid_t uid ; atomic_long_t locked_vm ; } ;
struct irq_affinity_notify ;
struct irq_chip_type { struct irq_chip chip ; struct irq_chip_regs regs ; irq_flow_handler_t handler ; u32 type ; } ;
struct irq_affinity_notify { unsigned int irq ; struct kref kref ; struct work_struct work ; void ( * notify ) ( struct irq_affinity_notify * , const cpumask_t * mask ) ; void ( * release ) ( struct kref * ref ) ; } ;
struct cred ;
struct compat_ifreq { union { char ifrn_name [ 16 ] ; } ifr_ifrn ; union { struct sockaddr ifru_addr ; struct sockaddr ifru_dstaddr ; struct sockaddr ifru_broadaddr ; struct sockaddr ifru_netmask ; struct sockaddr ifru_hwaddr ; short ifru_flags ; compat_int_t ifru_ivalue ; compat_int_t ifru_mtu ; struct compat_ifmap ifru_map ; char ifru_slave [ 16 ] ; char ifru_newname [ 16 ] ; compat_caddr_t ifru_data ; struct compat_if_settings ifru_settings ; } ifr_ifru ; } ;
struct skb_shared_info { unsigned char nr_frags ; __u8 tx_flags ; unsigned short gso_size ; unsigned short gso_segs ; unsigned short gso_type ; struct sk_buff * frag_list ; struct skb_shared_hwtstamps hwtstamps ; __be32 ip6_frag_id ; atomic_t dataref ; void * destructor_arg ; skb_frag_t frags [ ( 65536 / ( ( 1UL ) << 12 ) + 1 ) ] ; } ;
struct ethtool_rx_flow_spec { __u32 flow_type ; union ethtool_flow_union h_u ; struct ethtool_flow_ext h_ext ; union ethtool_flow_union m_u ; struct ethtool_flow_ext m_ext ; __u64 ring_cookie ; __u32 location ; } ;
struct ethtool_rx_ntuple_flow_spec { __u32 flow_type ; union { struct ethtool_tcpip4_spec tcp_ip4_spec ; struct ethtool_tcpip4_spec udp_ip4_spec ; struct ethtool_tcpip4_spec sctp_ip4_spec ; struct ethtool_ah_espip4_spec ah_ip4_spec ; struct ethtool_ah_espip4_spec esp_ip4_spec ; struct ethtool_usrip4_spec usr_ip4_spec ; struct ethhdr ether_spec ; __u8 hdata [ 72 ] ; } h_u , m_u ; __u16 vlan_tag ; __u16 vlan_tag_mask ; __u64 data ; __u64 data_mask ; __s32 action ; } ;
struct compat_ethtool_rx_flow_spec { u32 flow_type ; union ethtool_flow_union h_u ; struct ethtool_flow_ext h_ext ; union ethtool_flow_union m_u ; struct ethtool_flow_ext m_ext ; compat_u64 ring_cookie ; u32 location ; } ;
struct netns_ipv4 { struct ctl_table_header * forw_hdr ; struct ctl_table_header * frags_hdr ; struct ctl_table_header * ipv4_hdr ; struct ctl_table_header * route_hdr ; struct ipv4_devconf * devconf_all ; struct ipv4_devconf * devconf_dflt ; struct fib_rules_ops * rules_ops ; K_bool fib_has_custom_rules ; struct fib_table * fib_local ; struct fib_table * fib_main ; struct fib_table * fib_default ; int fib_num_tclassid_users ; struct hlist_head * fib_table_hash ; struct sock * fibnl ; struct sock * * icmp_sk ; struct inet_peer_base * peers ; struct tcpm_hash_bucket * tcp_metrics_hash ; unsigned int tcp_metrics_hash_log ; struct netns_frags frags ; struct xt_table * iptable_filter ; struct xt_table * iptable_mangle ; struct xt_table * iptable_raw ; struct xt_table * arptable_filter ; struct xt_table * nat_table ; int sysctl_icmp_echo_ignore_all ; int sysctl_icmp_echo_ignore_broadcasts ; int sysctl_icmp_ignore_bogus_error_responses ; int sysctl_icmp_ratelimit ; int sysctl_icmp_ratemask ; int sysctl_icmp_errors_use_inbound_ifaddr ; kgid_t sysctl_ping_group_range [ 2 ] ; long sysctl_tcp_mem [ 3 ] ; atomic_t dev_addr_genid ; struct mr_table * mrt ; } ;
struct sockaddr_in6 { unsigned short int sin6_family ; __be16 sin6_port ; __be32 sin6_flowinfo ; struct in6_addr sin6_addr ; __u32 sin6_scope_id ; } ;
struct ipv6_mreq { struct in6_addr ipv6mr_multiaddr ; int ipv6mr_ifindex ; } ;
struct in6_flowlabel_req { struct in6_addr flr_dst ; __be32 flr_label ; __u8 flr_action ; __u8 flr_share ; __u16 flr_flags ; __u16 flr_expires ; __u16 flr_linger ; __u32 __flr_pad ; } ;
union nf_inet_addr { __u32 all [ 4 ] ; __be32 ip ; __be32 ip6 [ 4 ] ; struct in_addr in ; struct in6_addr in6 ; } ;
struct flowi4 { struct flowi_common __fl_common ; __be32 saddr ; __be32 daddr ; union flowi_uli uli ; } __attribute__ ( ( __aligned__ ( 64 / 8 ) ) ) ;
struct flowi6 { struct flowi_common __fl_common ; struct in6_addr daddr ; struct in6_addr saddr ; __be32 flowlabel ; union flowi_uli uli ; } __attribute__ ( ( __aligned__ ( 64 / 8 ) ) ) ;
struct flowidn { struct flowi_common __fl_common ; __le16 daddr ; __le16 saddr ; union flowi_uli uli ; } __attribute__ ( ( __aligned__ ( 64 / 8 ) ) ) ;
struct xfrm_id { xfrm_address_t daddr ; __be32 spi ; __u8 proto ; } ;
struct xfrm_selector { xfrm_address_t daddr ; xfrm_address_t saddr ; __be16 dport ; __be16 dport_mask ; __be16 sport ; __be16 sport_mask ; __u16 family ; __u8 prefixlen_d ; __u8 prefixlen_s ; __u8 proto ; int ifindex ; __kernel_uid32_t user ; } ;
struct xfrm_encap_tmpl { __u16 encap_type ; __be16 encap_sport ; __be16 encap_dport ; xfrm_address_t encap_oa ; } ;
struct xfrm_usersa_id { xfrm_address_t daddr ; __be32 spi ; __u16 family ; __u8 proto ; } ;
struct xfrm_user_kmaddress { xfrm_address_t local ; xfrm_address_t remote ; __u32 reserved ; __u16 family ; } ;
struct xfrm_user_migrate { xfrm_address_t old_daddr ; xfrm_address_t old_saddr ; xfrm_address_t new_daddr ; xfrm_address_t new_saddr ; __u8 proto ; __u8 mode ; __u16 reserved ; __u32 reqid ; __u16 old_family ; __u16 new_family ; } ;
struct ctl_table ;
struct dsa_switch_tree { struct dsa_platform_data * pd ; struct net_device * master_netdev ; __be16 tag_protocol ; s8 cpu_switch ; s8 cpu_port ; int link_poll_needed ; struct work_struct link_poll_work ; struct timer_list link_poll_timer ; struct dsa_switch * ds [ 4 ] ; } ;
struct cgroup_subsys_state { struct cgroup * cgroup ; atomic_t refcnt ; unsigned long flags ; struct css_id * id ; struct work_struct dput_work ; } ;
struct cred ;
struct siginfo ;
struct nameidata ;
struct iattr ;
struct ctl_table ;
struct xfrm_selector ;
struct scm_creds { u32 pid ; kuid_t uid ; kgid_t gid ; } ;
struct tpacket_block_desc { __u32 version ; __u32 offset_to_priv ; union tpacket_bd_header_u hdr ; } ;
struct rps_dev_flow_table { unsigned int mask ; struct callback_head rcu ; struct work_struct free_work ; struct rps_dev_flow flows [ 0 ] ; } ;
struct netdev_rx_queue { struct rps_map * rps_map ; struct rps_dev_flow_table * rps_flow_table ; struct kobject kobj ; struct net_device * dev ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct packet_offload { __be16 type ; struct offload_callbacks callbacks ; struct list_head list ; } ;
struct in6_pktinfo { struct in6_addr ipi6_addr ; int ipi6_ifindex ; } ;
struct in6_ifreq { struct in6_addr ifr6_addr ; __u32 ifr6_prefixlen ; int ifr6_ifindex ; } ;
struct rt0_hdr { struct ipv6_rt_hdr rt_hdr ; __u32 reserved ; struct in6_addr addr [ 0 ] ; } ;
struct rt2_hdr { struct ipv6_rt_hdr rt_hdr ; __u32 reserved ; struct in6_addr addr ; } ;
struct ipv6_destopt_hao { __u8 type ; __u8 length ; struct in6_addr addr ; } __attribute__ ( ( packed ) ) ;
struct ipv6hdr { __u8 priority : 4 , version : 4 ; __u8 flow_lbl [ 3 ] ; __be16 payload_len ; __u8 nexthdr ; __u8 hop_limit ; struct in6_addr saddr ; struct in6_addr daddr ; } ;
struct icmp6hdr { __u8 icmp6_type ; __u8 icmp6_code ; __sum16 icmp6_cksum ; union { __be32 un_data32 [ 1 ] ; __be16 un_data16 [ 2 ] ; __u8 un_data8 [ 4 ] ; struct icmpv6_echo { __be16 identifier ; __be16 sequence ; } u_echo ; struct icmpv6_nd_advt { __u32 reserved : 5 , override : 1 , solicited : 1 , router : 1 , reserved2 : 24 ; } u_nd_advt ; struct icmpv6_nd_ra { __u8 hop_limit ; __u8 reserved : 3 , router_pref : 2 , home_agent : 1 , other : 1 , managed : 1 ; __be16 rt_lifetime ; } u_nd_ra ; } icmp6_dataun ; } ;
struct flowi6 ;
struct kmem_cache ;
struct poll_table_entry { struct file * filp ; unsigned long key ; wait_queue_t wait ; wait_queue_head_t * wait_address ; } ;
struct sock_common { union { __addrpair skc_addrpair ; struct { __be32 skc_daddr ; __be32 skc_rcv_saddr ; } ; } ; union { unsigned int skc_hash ; __u16 skc_u16hashes [ 2 ] ; } ; union { __portpair skc_portpair ; struct { __be16 skc_dport ; __u16 skc_num ; } ; } ; unsigned short skc_family ; volatile unsigned char skc_state ; unsigned char skc_reuse ; int skc_bound_dev_if ; union { struct hlist_node skc_bind_node ; struct hlist_nulls_node skc_portaddr_node ; } ; struct proto * skc_prot ; struct net * skc_net ; int skc_dontcopy_begin [ 0 ] ; union { struct hlist_node skc_node ; struct hlist_nulls_node skc_nulls_node ; } ; int skc_tx_queue_mapping ; atomic_t skc_refcnt ; int skc_dontcopy_end [ 0 ] ; } ;
struct ip_options_data { struct ip_options_rcu opt ; char data [ 40 ] ; } ;
struct inet6_request_sock { struct in6_addr loc_addr ; struct in6_addr rmt_addr ; struct sk_buff * pktopts ; int iif ; } ;
struct inet6_timewait_sock { struct in6_addr tw_v6_daddr ; struct in6_addr tw_v6_rcv_saddr ; } ;
struct blk_scsi_cmd_filter { unsigned long read_ok [ ( ( 256 ) / ( sizeof ( long ) * 8 ) ) ] ; unsigned long write_ok [ ( ( 256 ) / ( sizeof ( long ) * 8 ) ) ] ; struct kobject kobj ; } ;
struct unixware_disklabel { __le32 d_type ; __le32 d_magic ; __le32 d_version ; char d_serial [ 12 ] ; __le32 d_ncylinders ; __le32 d_ntracks ; __le32 d_nsectors ; __le32 d_secsize ; __le32 d_part_start ; __le32 d_unknown1 [ 12 ] ; __le32 d_alt_tbl ; __le32 d_alt_len ; __le32 d_phys_cyl ; __le32 d_phys_trk ; __le32 d_phys_sec ; __le32 d_phys_bytes ; __le32 d_unknown2 ; __le32 d_unknown3 ; __le32 d_pad [ 8 ] ; struct unixware_vtoc { __le32 v_magic ; __le32 v_version ; char v_name [ 8 ] ; __le16 v_nslices ; __le16 v_unknown1 ; __le32 v_reserved [ 10 ] ; struct unixware_slice v_slice [ 16 ] ; } vtoc ; } ;
struct ctl_table ;
struct kmem_cache ;
struct bio_integrity_payload { struct bio * bip_bio ; sector_t bip_sector ; void * bip_buf ; bio_end_io_t * bip_end_io ; unsigned int bip_size ; unsigned short bip_slab ; unsigned short bip_vcnt ; unsigned short bip_idx ; struct work_struct bip_work ; struct bio_vec bip_vec [ 0 ] ; } ;
struct request ;
struct request ;
struct request { struct list_head queuelist ; struct call_single_data csd ; struct request_queue * q ; unsigned int cmd_flags ; enum rq_cmd_type_bits cmd_type ; unsigned long atomic_flags ; int cpu ; unsigned int __data_len ; sector_t __sector ; struct bio * bio ; struct bio * biotail ; struct hlist_node hash ; union { struct rb_node rb_node ; void * completion_data ; } ; union { struct { struct io_cq * icq ; void * priv [ 2 ] ; } elv ; struct { unsigned int seq ; struct list_head list ; rq_end_io_fn * saved_end_io ; } flush ; } ; struct gendisk * rq_disk ; struct hd_struct * part ; unsigned long start_time ; struct request_list * rl ; unsigned long long start_time_ns ; unsigned long long io_start_time_ns ; unsigned short nr_phys_segments ; unsigned short nr_integrity_segments ; unsigned short ioprio ; int ref_count ; void * special ; char * buffer ; int tag ; int errors ; unsigned char __cmd [ 16 ] ; unsigned char * cmd ; unsigned short cmd_len ; unsigned int extra_len ; unsigned int sense_len ; unsigned int resid_len ; void * sense ; unsigned long deadline ; struct list_head timeout_list ; unsigned int timeout ; int retries ; rq_end_io_fn * end_io ; void * end_io_data ; struct request * next_rq ; } ;
struct elevator_type { struct kmem_cache * icq_cache ; struct elevator_ops ops ; size_t icq_size ; size_t icq_align ; struct elv_fs_entry * elevator_attrs ; char elevator_name [ ( 16 ) ] ; struct module * elevator_owner ; char icq_cache_name [ ( 16 ) + 5 ] ; struct list_head list ; } ;
struct blk_plug_cb ;
struct blk_plug_cb { struct list_head list ; blk_plug_cb_fn callback ; void * data ; } ;
struct blk_integrity { integrity_gen_fn * generate_fn ; integrity_vrfy_fn * verify_fn ; integrity_set_tag_fn * set_tag_fn ; integrity_get_tag_fn * get_tag_fn ; unsigned short flags ; unsigned short tuple_size ; unsigned short sector_size ; unsigned short tag_size ; const char * name ; struct kobject kobj ; } ;
struct crypto_tfm ;
struct crypto_alg { struct list_head cra_list ; struct list_head cra_users ; u32 cra_flags ; unsigned int cra_blocksize ; unsigned int cra_ctxsize ; unsigned int cra_alignmask ; int cra_priority ; atomic_t cra_refcnt ; char cra_name [ 64 ] ; char cra_driver_name [ 64 ] ; const struct crypto_type * cra_type ; union { struct ablkcipher_alg ablkcipher ; struct aead_alg aead ; struct blkcipher_alg blkcipher ; struct cipher_alg cipher ; struct compress_alg compress ; struct rng_alg rng ; } cra_u ; int ( * cra_init ) ( struct crypto_tfm * tfm ) ; void ( * cra_exit ) ( struct crypto_tfm * tfm ) ; void ( * cra_destroy ) ( struct crypto_alg * alg ) ; struct module * cra_module ; } ;
struct crypto_tfm { u32 crt_flags ; union { struct ablkcipher_tfm ablkcipher ; struct aead_tfm aead ; struct blkcipher_tfm blkcipher ; struct cipher_tfm cipher ; struct hash_tfm hash ; struct compress_tfm compress ; struct rng_tfm rng ; } crt_u ; void ( * exit ) ( struct crypto_tfm * tfm ) ; struct crypto_alg * __crt_alg ; void * __crt_ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;
struct nameidata { struct path path ; struct qstr last ; struct path root ; struct inode * inode ; unsigned int flags ; unsigned seq ; int last_type ; unsigned depth ; char * saved_names [ MAX_NESTED_LINKS + 1 ] ; } ;
struct acpi_sleep_functions { acpi_sleep_function legacy_function ; acpi_sleep_function extended_function ; } ;
union acpi_resource_data { struct acpi_resource_irq irq ; struct acpi_resource_dma dma ; struct acpi_resource_start_dependent start_dpf ; struct acpi_resource_io io ; struct acpi_resource_fixed_io fixed_io ; struct acpi_resource_fixed_dma fixed_dma ; struct acpi_resource_vendor vendor ; struct acpi_resource_vendor_typed vendor_typed ; struct acpi_resource_end_tag end_tag ; struct acpi_resource_memory24 memory24 ; struct acpi_resource_memory32 memory32 ; struct acpi_resource_fixed_memory32 fixed_memory32 ; struct acpi_resource_address16 address16 ; struct acpi_resource_address32 address32 ; struct acpi_resource_address64 address64 ; struct acpi_resource_extended_address64 ext_address64 ; struct acpi_resource_extended_irq extended_irq ; struct acpi_resource_generic_register generic_reg ; struct acpi_resource_gpio gpio ; struct acpi_resource_i2c_serialbus i2c_serial_bus ; struct acpi_resource_spi_serialbus spi_serial_bus ; struct acpi_resource_uart_serialbus uart_serial_bus ; struct acpi_resource_common_serialbus common_serial_bus ; struct acpi_resource_address address ; } ;
struct acpi_driver ;
struct acpi_driver { char name [ 80 ] ; char class_ [ 80 ] ; const struct acpi_device_id * ids ; unsigned int flags ; struct acpi_device_ops ops ; struct device_driver drv ; struct module * owner ; } ;
struct acpi_pci_root { struct list_head node ; struct acpi_device * device ; struct acpi_pci_id id ; struct pci_bus * bus ; u16 segment ; struct resource secondary ; u32 osc_support_set ; u32 osc_control_set ; phys_addr_t mcfg_addr ; } ;
struct resource_list_entry { struct list_head node ; struct resource res ; } ;
typedef union { __u8 type ; struct dvd_physical physical ; struct dvd_copyright copyright ; struct dvd_disckey disckey ; struct dvd_bca bca ; struct dvd_manufact manufact ; } dvd_struct ;
typedef union { __u8 type ; struct dvd_lu_send_agid lsa ; struct dvd_host_send_challenge hsc ; struct dvd_send_key lsk ; struct dvd_lu_send_challenge lsc ; struct dvd_send_key hsk ; struct dvd_lu_send_title_key lstk ; struct dvd_lu_send_asf lsasf ; struct dvd_host_send_rpcstate hrpcs ; struct dvd_lu_send_rpcstate lrpcs ; } dvd_authinfo ;
struct ff_effect { __u16 type ; __s16 id ; __u16 direction ; struct ff_trigger trigger ; struct ff_replay replay ; union { struct ff_constant_effect constant ; struct ff_ramp_effect ramp ; struct ff_periodic_effect periodic ; struct ff_condition_effect condition [ 2 ] ; struct ff_rumble_effect rumble ; } u ; } ;
struct pnp_driver { char * name ; const struct pnp_device_id * id_table ; unsigned int flags ; int ( * probe ) ( struct pnp_dev * dev , const struct pnp_device_id * dev_id ) ; void ( * remove ) ( struct pnp_dev * dev ) ; void ( * shutdown ) ( struct pnp_dev * dev ) ; int ( * suspend ) ( struct pnp_dev * dev , pm_message_t state ) ; int ( * resume ) ( struct pnp_dev * dev ) ; struct device_driver driver ; } ;
struct phy_driver { u32 phy_id ; char * name ; unsigned int phy_id_mask ; u32 features ; u32 flags ; int ( * config_init ) ( struct phy_device * phydev ) ; int ( * probe ) ( struct phy_device * phydev ) ; int ( * suspend ) ( struct phy_device * phydev ) ; int ( * resume ) ( struct phy_device * phydev ) ; int ( * config_aneg ) ( struct phy_device * phydev ) ; int ( * read_status ) ( struct phy_device * phydev ) ; int ( * ack_interrupt ) ( struct phy_device * phydev ) ; int ( * config_intr ) ( struct phy_device * phydev ) ; int ( * did_interrupt ) ( struct phy_device * phydev ) ; void ( * remove ) ( struct phy_device * phydev ) ; int ( * match_phy_device ) ( struct phy_device * phydev ) ; int ( * ts_info ) ( struct phy_device * phydev , struct ethtool_ts_info * ti ) ; int ( * hwtstamp ) ( struct phy_device * phydev , struct ifreq * ifr ) ; K_bool ( * rxtstamp ) ( struct phy_device * dev , struct sk_buff * skb , int type ) ; void ( * txtstamp ) ( struct phy_device * dev , struct sk_buff * skb , int type ) ; struct device_driver driver ; } ;
struct module ;
struct paravirt_patch_template { struct pv_init_ops pv_init_ops ; struct pv_time_ops pv_time_ops ; struct pv_cpu_ops pv_cpu_ops ; struct pv_irq_ops pv_irq_ops ; struct pv_apic_ops pv_apic_ops ; struct pv_mmu_ops pv_mmu_ops ; struct pv_lock_ops pv_lock_ops ; } ;
union thread_xstate { struct i387_fsave_struct fsave ; struct i387_fxsave_struct fxsave ; struct i387_soft_struct soft ; struct xsave_struct xsave ; } ;
struct thread_info { unsigned long int spill_slot [ 4 ] ; struct task_struct * task ; struct exec_domain * exec_domain ; __u32 flags ; __u32 status ; __u32 cpu ; int preempt_count ; mm_segment_t addr_limit ; struct restart_block restart_block ; void * sysenter_return ; unsigned int sig_on_uaccess_error : 1 ; unsigned int uaccess_err : 1 ; struct client_extension client_data ; } ;
typedef struct arch_spinlock { union { __ticketpair_t head_tail ; struct { __ticket_t head , tail ; } tickets ; } ; } arch_spinlock_t ;
struct edd { unsigned int mbr_signature [ 16 ] ; struct edd_info edd_info [ 6 ] ; unsigned char mbr_signature_nr ; unsigned char edd_info_nr ; } ;
struct boot_params { struct screen_info screen_info ; struct apm_bios_info apm_bios_info ; __u8 _pad2 [ 4 ] ; __u64 tboot_addr ; struct ist_info ist_info ; __u8 _pad3 [ 16 ] ; __u8 hd0_info [ 16 ] ; __u8 hd1_info [ 16 ] ; struct sys_desc_table sys_desc_table ; struct olpc_ofw_header olpc_ofw_header ; __u8 _pad4 [ 128 ] ; struct edid_info edid_info ; struct efi_info efi_info ; __u32 alt_mem_k ; __u32 scratch ; __u8 e820_entries ; __u8 eddbuf_entries ; __u8 edd_mbr_sig_buf_entries ; __u8 _pad6 [ 6 ] ; struct setup_header hdr ; __u8 _pad7 [ 0x290 - 0x1f1 - sizeof ( struct setup_header ) ] ; __u32 edd_mbr_sig_buffer [ 16 ] ; struct e820entry e820_map [ 128 ] ; __u8 _pad8 [ 48 ] ; struct edd_info eddbuf [ 6 ] ; __u8 _pad9 [ 276 ] ; } __attribute__ ( ( packed ) ) ;
struct ctl_table_set { int ( * is_seen ) ( struct ctl_table_set * ) ; struct ctl_dir dir ; } ;
struct module ;
struct module ;
struct module ;
struct module ;
struct module ;
struct module { enum module_state state ; struct list_head list ; char name [ ( 64 - sizeof ( unsigned long ) ) ] ; struct module_kobject mkobj ; struct module_attribute * modinfo_attrs ; const char * version ; const char * srcversion ; struct kobject * holders_dir ; const struct kernel_symbol * syms ; const unsigned long * crcs ; unsigned int num_syms ; struct kernel_param * kp ; unsigned int num_kp ; unsigned int num_gpl_syms ; const struct kernel_symbol * gpl_syms ; const unsigned long * gpl_crcs ; const struct kernel_symbol * unused_syms ; const unsigned long * unused_crcs ; unsigned int num_unused_syms ; unsigned int num_unused_gpl_syms ; const struct kernel_symbol * unused_gpl_syms ; const unsigned long * unused_gpl_crcs ; const struct kernel_symbol * gpl_future_syms ; const unsigned long * gpl_future_crcs ; unsigned int num_gpl_future_syms ; unsigned int num_exentries ; struct exception_table_entry * extable ; int ( * init ) ( void ) ; void * module_init ; void * module_core ; unsigned int init_size , core_size ; unsigned int init_text_size , core_text_size ; unsigned int init_ro_size , core_ro_size ; struct mod_arch_specific arch ; unsigned int taints ; unsigned num_bugs ; struct list_head bug_list ; struct bug_entry * bug_table ; Elf64_Sym * symtab , * core_symtab ; unsigned int num_symtab , core_num_syms ; char * strtab , * core_strtab ; struct module_sect_attrs * sect_attrs ; struct module_notes_attrs * notes_attrs ; char * args ; void * percpu ; unsigned int percpu_size ; unsigned int num_tracepoints ; struct tracepoint * const * tracepoints_ptrs ; unsigned int num_trace_bprintk_fmt ; const char * * trace_bprintk_fmt_start ; struct ftrace_event_call * * trace_events ; unsigned int num_trace_events ; unsigned int num_ftrace_callsites ; unsigned long * ftrace_callsites ; struct list_head source_list ; struct list_head target_list ; struct task_struct * waiter ; void ( * exit ) ( void ) ; struct module_ref * refptr ; } ;
struct hrtimer_sleeper { struct hrtimer timer ; struct task_struct * task ; } ;
struct kqid { union { kuid_t uid ; kgid_t gid ; kprojid_t projid ; } ; enum quota_type type ; } ;
typedef int ( * read_actor_t ) ( read_descriptor_t * , struct page * , unsigned long , unsigned long ) ;
struct address_space_operations { int ( * writepage ) ( struct page * page , struct writeback_control * wbc ) ; int ( * readpage ) ( struct file * , struct page * ) ; int ( * writepages ) ( struct address_space * , struct writeback_control * ) ; int ( * set_page_dirty ) ( struct page * page ) ; int ( * readpages ) ( struct file * filp , struct address_space * mapping , struct list_head * pages , unsigned nr_pages ) ; int ( * write_begin ) ( struct file * , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata ) ; int ( * write_end ) ( struct file * , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) ; sector_t ( * bmap ) ( struct address_space * , sector_t ) ; void ( * invalidatepage ) ( struct page * , unsigned long ) ; int ( * releasepage ) ( struct page * , gfp_t ) ; void ( * freepage ) ( struct page * ) ; ssize_t ( * direct_IO ) ( int , struct kiocb * , const struct iovec * iov , loff_t offset , unsigned long nr_segs ) ; int ( * get_xip_mem ) ( struct address_space * , unsigned long , int , void * * , unsigned long * ) ; int ( * migratepage ) ( struct address_space * , struct page * , struct page * , enum migrate_mode ) ; int ( * launder_page ) ( struct page * ) ; int ( * is_partially_uptodate ) ( struct page * , read_descriptor_t * , unsigned long ) ; int ( * error_remove_page ) ( struct address_space * , struct page * ) ; int ( * swap_activate ) ( struct swap_info_struct * sis , struct file * file , sector_t * span ) ; void ( * swap_deactivate ) ( struct file * file ) ; } ;
struct fown_struct { rwlock_t lock ; struct pid * pid ; enum pid_type pid_type ; kuid_t uid , euid ; int signum ; } ;
struct file_operations { struct module * owner ; loff_t ( * llseek ) ( struct file * , loff_t , int ) ; ssize_t ( * read ) ( struct file * , char * , size_t , loff_t * ) ; ssize_t ( * write ) ( struct file * , const char * , size_t , loff_t * ) ; ssize_t ( * aio_read ) ( struct kiocb * , const struct iovec * , unsigned long , loff_t ) ; ssize_t ( * aio_write ) ( struct kiocb * , const struct iovec * , unsigned long , loff_t ) ; int ( * readdir ) ( struct file * , void * , filldir_t ) ; unsigned int ( * poll ) ( struct file * , struct poll_table_struct * ) ; long ( * unlocked_ioctl ) ( struct file * , unsigned int , unsigned long ) ; long ( * compat_ioctl ) ( struct file * , unsigned int , unsigned long ) ; int ( * mmap ) ( struct file * , struct vm_area_struct * ) ; int ( * open ) ( struct inode * , struct file * ) ; int ( * flush ) ( struct file * , fl_owner_t id ) ; int ( * release ) ( struct inode * , struct file * ) ; int ( * fsync ) ( struct file * , loff_t , loff_t , int datasync ) ; int ( * aio_fsync ) ( struct kiocb * , int datasync ) ; int ( * fasync ) ( int , struct file * , int ) ; int ( * lock ) ( struct file * , int , struct file_lock * ) ; ssize_t ( * sendpage ) ( struct file * , struct page * , int , size_t , loff_t * , int ) ; unsigned long ( * get_unmapped_area ) ( struct file * , unsigned long , unsigned long , unsigned long , unsigned long ) ; int ( * check_flags ) ( int ) ; int ( * flock ) ( struct file * , int , struct file_lock * ) ; ssize_t ( * splice_write ) ( struct pipe_inode_info * , struct file * , loff_t * , size_t , unsigned int ) ; ssize_t ( * splice_read ) ( struct file * , loff_t * , struct pipe_inode_info * , size_t , unsigned int ) ; int ( * setlease ) ( struct file * , long , struct file_lock * * ) ; long ( * fallocate ) ( struct file * file , int mode , loff_t offset , loff_t len ) ; int ( * show_fdinfo ) ( struct seq_file * m , struct file * f ) ; } ;
typedef struct siginfo { int si_signo ; int si_errno ; int si_code ; union { int _pad [ ( ( 128 - ( 4 * sizeof ( int ) ) ) / sizeof ( int ) ) ] ; struct { __kernel_pid_t _pid ; __kernel_uid32_t _uid ; } _kill ; struct { __kernel_timer_t _tid ; int _overrun ; char _pad [ sizeof ( __kernel_uid32_t ) - sizeof ( int ) ] ; sigval_t _sigval ; int _sys_private ; } _timer ; struct { __kernel_pid_t _pid ; __kernel_uid32_t _uid ; sigval_t _sigval ; } _rt ; struct { __kernel_pid_t _pid ; __kernel_uid32_t _uid ; int _status ; __kernel_clock_t _utime ; __kernel_clock_t _stime ; } _sigchld ; struct { void * _addr ; short _addr_lsb ; } _sigfault ; struct { long _band ; int _fd ; } _sigpoll ; struct { void * _call_addr ; int _syscall ; unsigned int _arch ; } _sigsys ; } _sifields ; } siginfo_t ;
struct module ;
struct tick_sched { struct hrtimer sched_timer ; unsigned long check_clocks ; enum tick_nohz_mode nohz_mode ; ktime_t last_tick ; int inidle ; int tick_stopped ; unsigned long idle_jiffies ; unsigned long idle_calls ; unsigned long idle_sleeps ; int idle_active ; ktime_t idle_entrytime ; ktime_t idle_waketime ; ktime_t idle_exittime ; ktime_t idle_sleeptime ; ktime_t iowait_sleeptime ; ktime_t sleep_length ; unsigned long last_jiffies ; unsigned long next_jiffies ; ktime_t idle_expires ; int do_timer_last ; } ;
struct module ;
struct hrtimer_sleeper ;
struct module ;
struct module ;
struct tasklet_hrtimer { struct hrtimer timer ; struct tasklet_struct tasklet ; enum hrtimer_restart ( * function ) ( struct hrtimer * ) ; } ;
struct pm_qos_request { struct plist_node node ; int pm_qos_class ; struct delayed_work work ; } ;
struct ifreq { union { char ifrn_name [ 16 ] ; } ifr_ifrn ; union { struct sockaddr ifru_addr ; struct sockaddr ifru_dstaddr ; struct sockaddr ifru_broadaddr ; struct sockaddr ifru_netmask ; struct sockaddr ifru_hwaddr ; short ifru_flags ; int ifru_ivalue ; int ifru_mtu ; struct ifmap ifru_map ; char ifru_slave [ 16 ] ; char ifru_newname [ 16 ] ; void * ifru_data ; struct if_settings ifru_settings ; } ifr_ifru ; } ;
typedef struct compat_sigevent { compat_sigval_t sigev_value ; compat_int_t sigev_signo ; compat_int_t sigev_notify ; union { compat_int_t _pad [ ( ( 64 / sizeof ( int ) ) - 3 ) ] ; compat_int_t _tid ; struct { compat_uptr_t _function ; compat_uptr_t _attribute ; } _sigev_thread ; } _sigev_un ; } compat_sigevent_t ;
struct module ;
struct module ;
struct ethtool_rxnfc { __u32 cmd ; __u32 flow_type ; __u64 data ; struct ethtool_rx_flow_spec fs ; __u32 rule_cnt ; __u32 rule_locs [ 0 ] ; } ;
struct ethtool_rx_ntuple { __u32 cmd ; struct ethtool_rx_ntuple_flow_spec fs ; } ;
struct compat_ethtool_rxnfc { u32 cmd ; u32 flow_type ; compat_u64 data ; struct compat_ethtool_rx_flow_spec fs ; u32 rule_cnt ; u32 rule_locs [ 0 ] ; } ;
struct netns_mib { __typeof__ ( struct tcp_mib ) * tcp_statistics [ 1 ] ; __typeof__ ( struct ipstats_mib ) * ip_statistics [ 1 ] ; __typeof__ ( struct linux_mib ) * net_statistics [ 1 ] ; __typeof__ ( struct udp_mib ) * udp_statistics [ 1 ] ; __typeof__ ( struct udp_mib ) * udplite_statistics [ 1 ] ; __typeof__ ( struct icmp_mib ) * icmp_statistics [ 1 ] ; __typeof__ ( struct icmpmsg_mib ) * icmpmsg_statistics ; struct proc_dir_entry * proc_net_devsnmp6 ; __typeof__ ( struct udp_mib ) * udp_stats_in6 [ 1 ] ; __typeof__ ( struct udp_mib ) * udplite_stats_in6 [ 1 ] ; __typeof__ ( struct ipstats_mib ) * ipv6_statistics [ 1 ] ; __typeof__ ( struct icmpv6_mib ) * icmpv6_statistics [ 1 ] ; __typeof__ ( struct icmpv6msg_mib ) * icmpv6msg_statistics ; } ;
struct inet_frags { struct hlist_head hash [ 64 ] ; rwlock_t lock ; u32 rnd ; int qsize ; int secret_interval ; struct timer_list secret_timer ; unsigned int ( * hashfn ) ( struct inet_frag_queue * ) ; void ( * constructor ) ( struct inet_frag_queue * q , void * arg ) ; void ( * destructor ) ( struct inet_frag_queue * ) ; void ( * skb_free ) ( struct sk_buff * ) ; K_bool ( * match ) ( struct inet_frag_queue * q , void * arg ) ; void ( * frag_expire ) ( unsigned long data ) ; } ;
struct xfrm_user_tmpl { struct xfrm_id id ; __u16 family ; xfrm_address_t saddr ; __u32 reqid ; __u8 mode ; __u8 share ; __u8 optional ; __u32 aalgos ; __u32 ealgos ; __u32 calgos ; } ;
struct xfrm_usersa_info { struct xfrm_selector sel ; struct xfrm_id id ; xfrm_address_t saddr ; struct xfrm_lifetime_cfg lft ; struct xfrm_lifetime_cur curlft ; struct xfrm_stats stats ; __u32 seq ; __u32 reqid ; __u16 family ; __u8 mode ; __u8 replay_window ; __u8 flags ; } ;
struct xfrm_aevent_id { struct xfrm_usersa_id sa_id ; xfrm_address_t saddr ; __u32 flags ; __u32 reqid ; } ;
struct xfrm_userpolicy_info { struct xfrm_selector sel ; struct xfrm_lifetime_cfg lft ; struct xfrm_lifetime_cur curlft ; __u32 priority ; __u32 index ; __u8 dir ; __u8 action ; __u8 flags ; __u8 share ; } ;
struct xfrm_userpolicy_id { struct xfrm_selector sel ; __u32 index ; __u8 dir ; } ;
struct xfrm_user_report { __u8 proto ; struct xfrm_selector sel ; } ;
struct xfrm_user_mapping { struct xfrm_usersa_id id ; __u32 reqid ; xfrm_address_t old_saddr ; xfrm_address_t new_saddr ; __be16 old_sport ; __be16 new_sport ; } ;
struct fown_struct ;
struct file_operations ;
struct scm_cookie { struct pid * pid ; const struct cred * cred ; struct scm_fp_list * fp ; struct scm_creds creds ; } ;
struct netlink_skb_parms { struct scm_creds creds ; __u32 portid ; __u32 dst_group ; struct sock * ssk ; } ;
struct module ;
struct ip6_mtuinfo { struct sockaddr_in6 ip6m_addr ; __u32 ip6m_mtu ; } ;
struct poll_wqueues { poll_table pt ; struct poll_table_page * table ; struct task_struct * polling_task ; int triggered ; int error ; int inline_index ; struct poll_table_entry inline_entries [ ( ( 832 - 256 ) / sizeof ( struct poll_table_entry ) ) ] ; } ;
struct module ;
struct request_sock_queue { struct request_sock * rskq_accept_head ; struct request_sock * rskq_accept_tail ; rwlock_t syn_wait_lock ; u8 rskq_defer_accept ; struct listen_sock * listen_opt ; struct fastopen_queue * fastopenq ; } ;
struct ipv6_pinfo ;
struct inet_timewait_sock { struct sock_common __tw_common ; int tw_timeout ; volatile unsigned char tw_substate ; unsigned char tw_rcv_wscale ; __be16 tw_sport ; ; unsigned int tw_ipv6only : 1 , tw_transparent : 1 , tw_pad : 6 , tw_tos : 8 , tw_ipv6_offset : 16 ; ; unsigned long tw_ttd ; struct inet_bind_bucket * tw_tb ; struct hlist_node tw_death_node ; } ;
struct tcp6_request_sock { struct tcp_request_sock tcp6rsk_tcp ; struct inet6_request_sock tcp6rsk_inet6 ; } ;
struct ipv6_pinfo { struct in6_addr saddr ; struct in6_addr rcv_saddr ; struct in6_addr daddr ; struct in6_pktinfo sticky_pktinfo ; const struct in6_addr * daddr_cache ; const struct in6_addr * saddr_cache ; __be32 flow_label ; __u32 frag_size ; __u16 __unused_1 : 7 ; __s16 hop_limit : 9 ; __u16 mc_loop : 1 , __unused_2 : 6 ; __s16 mcast_hops : 9 ; int ucast_oif ; int mcast_oif ; union { struct { __u16 srcrt : 1 , osrcrt : 1 , rxinfo : 1 , rxoinfo : 1 , rxhlim : 1 , rxohlim : 1 , hopopts : 1 , ohopopts : 1 , dstopts : 1 , odstopts : 1 , rxflow : 1 , rxtclass : 1 , rxpmtu : 1 , rxorigdstaddr : 1 ; } bits ; __u16 all ; } rxopt ; __u16 recverr : 1 , sndflow : 1 , pmtudisc : 2 , ipv6only : 1 , srcprefs : 3 , dontfrag : 1 ; __u8 min_hopcount ; __u8 tclass ; __u8 rcv_tclass ; __u32 dst_cookie ; __u32 rx_dst_cookie ; struct ipv6_mc_socklist * ipv6_mc_list ; struct ipv6_ac_socklist * ipv6_ac_list ; struct ipv6_fl_socklist * ipv6_fl_list ; struct ipv6_txoptions * opt ; struct sk_buff * pktoptions ; struct sk_buff * rxpmtu ; struct { struct ipv6_txoptions * opt ; u8 hop_limit ; u8 tclass ; } cork ; } ;
struct module ;
struct qdisc_watchdog { struct hrtimer timer ; struct Qdisc * qdisc ; } ;
struct bio_pair { struct bio bio1 , bio2 ; struct bio_vec bv1 , bv2 ; struct bio_integrity_payload bip1 , bip2 ; struct bio_vec iv1 , iv2 ; atomic_t cnt ; int error ; } ;
struct module ;
struct crypto_ablkcipher ;
struct crypto_aead ;
struct crypto_blkcipher ;
struct crypto_hash ;
struct crypto_rng ;
struct crypto_ablkcipher { struct crypto_tfm base ; } ;
struct crypto_aead { struct crypto_tfm base ; } ;
struct crypto_blkcipher { struct crypto_tfm base ; } ;
struct crypto_cipher { struct crypto_tfm base ; } ;
struct crypto_comp { struct crypto_tfm base ; } ;
struct crypto_hash { struct crypto_tfm base ; } ;
struct crypto_rng { struct crypto_tfm base ; } ;
struct crypto_ahash ;
struct hash_alg_common { unsigned int digestsize ; unsigned int statesize ; struct crypto_alg base ; } ;
struct shash_alg { int ( * init ) ( struct shash_desc * desc ) ; int ( * update ) ( struct shash_desc * desc , const u8 * data , unsigned int len ) ; int ( * final ) ( struct shash_desc * desc , u8 * out ) ; int ( * finup ) ( struct shash_desc * desc , const u8 * data , unsigned int len , u8 * out ) ; int ( * digest ) ( struct shash_desc * desc , const u8 * data , unsigned int len , u8 * out ) ; int ( * export_ ) ( struct shash_desc * desc , void * out ) ; int ( * import ) ( struct shash_desc * desc , const void * in ) ; int ( * setkey ) ( struct crypto_shash * tfm , const u8 * key , unsigned int keylen ) ; unsigned int descsize ; unsigned int digestsize __attribute__ ( ( aligned ( __alignof__ ( struct hash_alg_common ) ) ) ) ; unsigned int statesize ; struct crypto_alg base ; } ;
struct crypto_ahash { int ( * init ) ( struct ahash_request * req ) ; int ( * update ) ( struct ahash_request * req ) ; int ( * final ) ( struct ahash_request * req ) ; int ( * finup ) ( struct ahash_request * req ) ; int ( * digest ) ( struct ahash_request * req ) ; int ( * export_ ) ( struct ahash_request * req , void * out ) ; int ( * import ) ( struct ahash_request * req , const void * in ) ; int ( * setkey ) ( struct crypto_ahash * tfm , const u8 * key , unsigned int keylen ) ; unsigned int reqsize ; struct crypto_tfm base ; } ;
struct crypto_shash { unsigned int descsize ; struct crypto_tfm base ; } ;
typedef struct jbd2_journal_revoke_header_s { journal_header_t r_header ; __be32 r_count ; } jbd2_journal_revoke_header_t ;
typedef struct journal_superblock_s { journal_header_t s_header ; __be32 s_blocksize ; __be32 s_maxlen ; __be32 s_first ; __be32 s_sequence ; __be32 s_start ; __be32 s_errno ; __be32 s_feature_compat ; __be32 s_feature_incompat ; __be32 s_feature_ro_compat ; __u8 s_uuid [ 16 ] ; __be32 s_nr_users ; __be32 s_dynsuper ; __be32 s_max_transaction ; __be32 s_max_trans_data ; __u8 s_checksum_type ; __u8 s_padding2 [ 3 ] ; __u32 s_padding [ 42 ] ; __be32 s_checksum ; __u8 s_users [ 16 * 48 ] ; } journal_superblock_t ;
struct cleancache_ops { int ( * init_fs ) ( size_t ) ; int ( * init_shared_fs ) ( char * uuid , size_t ) ; int ( * get_page ) ( int , struct cleancache_filekey , unsigned long , struct page * ) ; void ( * put_page ) ( int , struct cleancache_filekey , unsigned long , struct page * ) ; void ( * invalidate_page ) ( int , struct cleancache_filekey , unsigned long ) ; void ( * invalidate_inode ) ( int , struct cleancache_filekey ) ; void ( * invalidate_fs ) ( int ) ; } ;
struct module ;
struct acpi_resource { u32 type ; u32 length ; union acpi_resource_data data ; } ;
struct pnp_card_driver { struct list_head global_list ; char * name ; const struct pnp_card_device_id * id_table ; unsigned int flags ; int ( * probe ) ( struct pnp_card_link * card , const struct pnp_card_device_id * card_id ) ; void ( * remove ) ( struct pnp_card_link * card ) ; int ( * suspend ) ( struct pnp_card_link * card , pm_message_t state ) ; int ( * resume ) ( struct pnp_card_link * card ) ; struct pnp_driver link ; } ;
struct posix_acl_entry { short e_tag ; unsigned short e_perm ; union { kuid_t e_uid ; kgid_t e_gid ; unsigned int e_id ; } ; } ;
struct ctl_table_root ;
struct ctl_table_root { struct ctl_table_set default_set ; struct ctl_table_set * ( * lookup ) ( struct ctl_table_root * root , struct nsproxy * namespaces ) ; int ( * permissions ) ( struct ctl_table_header * head , struct ctl_table * table ) ; } ;
struct posix_acl ;
struct memcg_cache_params { K_bool is_root_cache ; union { struct kmem_cache * memcg_caches [ 0 ] ; struct { struct mem_cgroup * memcg ; struct list_head list ; struct kmem_cache * root_cache ; K_bool dead ; atomic_t nr_pages ; struct work_struct destroy ; } ; } ; } ;
typedef struct sigevent { sigval_t sigev_value ; int sigev_signo ; int sigev_notify ; union { int _pad [ ( ( 64 - ( sizeof ( int ) * 2 + sizeof ( sigval_t ) ) ) / sizeof ( int ) ) ] ; int _tid ; struct { void ( * _function ) ( sigval_t ) ; void * _attribute ; } _sigev_thread ; } _sigev_un ; } sigevent_t ;
struct sigqueue { struct list_head list ; int flags ; siginfo_t info ; struct user_struct * user ; } ;
union thread_union { struct thread_info thread_info ; unsigned long stack [ ( ( ( 1UL ) << 12 ) << 2 ) / sizeof ( long ) ] ; } ;
struct compat_siginfo ;
struct flowi ;
struct flowi { union { struct flowi_common __fl_common ; struct flowi4 ip4 ; struct flowi6 ip6 ; struct flowidn dn ; } u ; } __attribute__ ( ( __aligned__ ( 64 / 8 ) ) ) ;
struct xfrm_userspi_info { struct xfrm_usersa_info info ; __u32 min ; __u32 max ; } ;
struct xfrm_user_acquire { struct xfrm_id id ; xfrm_address_t saddr ; struct xfrm_selector sel ; struct xfrm_userpolicy_info policy ; __u32 aalgos ; __u32 ealgos ; __u32 calgos ; __u32 seq ; } ;
struct xfrm_user_expire { struct xfrm_usersa_info state ; __u8 hard ; } ;
struct xfrm_user_polexpire { struct xfrm_userpolicy_info pol ; __u8 hard ; } ;
struct flowi ;
struct flowi ;
struct tcp_timewait_sock { struct inet_timewait_sock tw_sk ; u32 tw_rcv_nxt ; u32 tw_snd_nxt ; u32 tw_rcv_wnd ; u32 tw_ts_recent ; long tw_ts_recent_stamp ; struct tcp_md5sig_key * tw_md5_key ; struct tcp_cookie_values * tw_cookie_values ; } ;
struct ahash_alg { int ( * init ) ( struct ahash_request * req ) ; int ( * update ) ( struct ahash_request * req ) ; int ( * final ) ( struct ahash_request * req ) ; int ( * finup ) ( struct ahash_request * req ) ; int ( * digest ) ( struct ahash_request * req ) ; int ( * export_ ) ( struct ahash_request * req , void * out ) ; int ( * import ) ( struct ahash_request * req , const void * in ) ; int ( * setkey ) ( struct crypto_ahash * tfm , const u8 * key , unsigned int keylen ) ; struct hash_alg_common halg ; } ;
struct posix_acl { union { atomic_t a_refcount ; struct callback_head a_rcu ; } ; unsigned int a_count ; struct posix_acl_entry a_entries [ 0 ] ; } ;
typedef struct raw_spinlock { arch_spinlock_t raw_lock ; } raw_spinlock_t ;
struct quotactl_ops { int ( * quota_on ) ( struct super_block * , int , int , struct path * ) ; int ( * quota_on_meta ) ( struct super_block * , int , int ) ; int ( * quota_off ) ( struct super_block * , int ) ; int ( * quota_sync ) ( struct super_block * , int ) ; int ( * get_info ) ( struct super_block * , int , struct if_dqinfo * ) ; int ( * set_info ) ( struct super_block * , int , struct if_dqinfo * ) ; int ( * get_dqblk ) ( struct super_block * , struct kqid , struct fs_disk_quota * ) ; int ( * set_dqblk ) ( struct super_block * , struct kqid , struct fs_disk_quota * ) ; int ( * get_xstate ) ( struct super_block * , struct fs_quota_stat * ) ; int ( * set_xstate ) ( struct super_block * , unsigned int , int ) ; } ;
typedef struct compat_siginfo { int si_signo ; int si_errno ; int si_code ; union { int _pad [ 128 / sizeof ( int ) - 3 ] ; struct { unsigned int _pid ; unsigned int _uid ; } _kill ; struct { compat_timer_t _tid ; int _overrun ; compat_sigval_t _sigval ; int _sys_private ; int _overrun_incr ; } _timer ; struct { unsigned int _pid ; unsigned int _uid ; compat_sigval_t _sigval ; } _rt ; struct { unsigned int _pid ; unsigned int _uid ; int _status ; compat_clock_t _utime ; compat_clock_t _stime ; } _sigchld ; struct { unsigned int _pid ; unsigned int _uid ; int _status ; compat_s64 _utime ; compat_s64 _stime ; } _sigchld_x32 ; struct { unsigned int _addr ; } _sigfault ; struct { int _band ; int _fd ; } _sigpoll ; struct { unsigned int _call_addr ; int _syscall ; unsigned int _arch ; } _sigsys ; } _sifields ; } compat_siginfo_t ;
struct inet_cork_full { struct inet_cork base ; struct flowi fl ; } ;
struct tcp6_timewait_sock { struct tcp_timewait_sock tcp6tw_tcp ; struct inet6_timewait_sock tcp6tw_inet6 ; } ;
struct rw_semaphore ;
struct rw_semaphore { long count ; raw_spinlock_t wait_lock ; struct list_head wait_list ; } ;
struct hrtimer_cpu_base ;
struct hrtimer_cpu_base { raw_spinlock_t lock ; unsigned int active_bases ; unsigned int clock_was_set ; ktime_t expires_next ; int hres_active ; int hang_detected ; unsigned long nr_events ; unsigned long nr_retries ; unsigned long nr_hangs ; ktime_t max_hang_time ; struct hrtimer_clock_base clock_base [ HRTIMER_MAX_CLOCK_BASES ] ; } ;
struct semaphore { raw_spinlock_t lock ; unsigned int count ; struct list_head wait_list ; } ;
struct percpu_counter { raw_spinlock_t lock ; s64 count ; struct list_head list ; s32 * counters ; } ;
struct ratelimit_state { raw_spinlock_t lock ; int interval ; int burst ; int printed ; int missed ; unsigned long begin ; } ;
struct prop_local_single { unsigned long events ; unsigned long period ; int shift ; raw_spinlock_t lock ; } ;
struct rt_mutex { raw_spinlock_t wait_lock ; struct plist_head wait_list ; struct task_struct * owner ; } ;
struct thread_group_cputimer { struct task_cputime cputime ; int running ; raw_spinlock_t lock ; } ;
struct irq_chip_generic { raw_spinlock_t lock ; void * reg_base ; unsigned int irq_base ; unsigned int irq_cnt ; u32 mask_cache ; u32 type_cache ; u32 polarity_cache ; u32 wake_enabled ; u32 wake_active ; unsigned int num_ct ; void * private_ ; struct list_head list ; struct irq_chip_type chip_types [ 0 ] ; } ;
struct fprop_local_single { unsigned long events ; unsigned int period ; raw_spinlock_t lock ; } ;
typedef struct spinlock { union { struct raw_spinlock rlock ; } ; } spinlock_t ;
struct blocking_notifier_head { struct rw_semaphore rwsem ; struct notifier_block * head ; } ;
struct dqstats { int stat [ _DQST_DQSTAT_LAST ] ; struct percpu_counter counter [ _DQST_DQSTAT_LAST ] ; } ;
struct prop_global { int shift ; struct percpu_counter events ; } ;
struct prop_local_percpu { struct percpu_counter events ; int shift ; unsigned long period ; raw_spinlock_t lock ; } ;
struct key ;
struct key { atomic_t usage ; key_serial_t serial ; union { struct list_head graveyard_link ; struct rb_node serial_node ; } ; struct key_type * type ; struct rw_semaphore sem ; struct key_user * user ; void * security ; union { time_t expiry ; time_t revoked_at ; } ; time_t last_used_at ; kuid_t uid ; kgid_t gid ; key_perm_t perm ; unsigned short quotalen ; unsigned short datalen ; unsigned long flags ; char * description ; union { struct list_head link ; unsigned long x [ 2 ] ; void * p [ 2 ] ; int reject_error ; } type_data ; union { unsigned long value ; void * rcudata ; void * data ; struct keyring_list * subscriptions ; } payload ; } ;
struct dst_ops { unsigned short family ; __be16 protocol ; unsigned int gc_thresh ; int ( * gc ) ( struct dst_ops * ops ) ; struct dst_entry * ( * check ) ( struct dst_entry * , __u32 cookie ) ; unsigned int ( * default_advmss ) ( const struct dst_entry * ) ; unsigned int ( * mtu ) ( const struct dst_entry * ) ; u32 * ( * cow_metrics ) ( struct dst_entry * , unsigned long ) ; void ( * destroy ) ( struct dst_entry * ) ; void ( * ifdown ) ( struct dst_entry * , struct net_device * dev , int how ) ; struct dst_entry * ( * negative_advice ) ( struct dst_entry * ) ; void ( * link_failure ) ( struct sk_buff * ) ; void ( * update_pmtu ) ( struct dst_entry * dst , struct sock * sk , struct sk_buff * skb , u32 mtu ) ; void ( * redirect ) ( struct dst_entry * dst , struct sock * sk , struct sk_buff * skb ) ; int ( * local_out ) ( struct sk_buff * skb ) ; struct neighbour * ( * neigh_lookup ) ( const struct dst_entry * dst , struct sk_buff * skb , const void * daddr ) ; struct kmem_cache * kmem_cachep ; struct percpu_counter pcpuc_entries __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; } ;
struct fprop_global { struct percpu_counter events ; unsigned int period ; seqcount_t sequence ; } ;
struct fprop_local_percpu { struct percpu_counter events ; unsigned int period ; raw_spinlock_t lock ; } ;
struct file ;
struct __wait_queue_head { spinlock_t lock ; struct list_head task_list ; } ;
struct mutex { atomic_t count ; spinlock_t wait_lock ; struct list_head wait_list ; struct task_struct * owner ; } ;
struct srcu_struct { unsigned completed ; struct srcu_struct_array * per_cpu_ref ; spinlock_t queue_lock ; K_bool running ; struct rcu_batch batch_queue ; struct rcu_batch batch_check0 ; struct rcu_batch batch_check1 ; struct rcu_batch batch_done ; struct delayed_work work ; } ;
struct atomic_notifier_head { spinlock_t lock ; struct notifier_block * head ; } ;
struct wakeup_source ;
struct pm_subsys_data { spinlock_t lock ; unsigned int refcount ; } ;
struct file ;
struct file ;
struct file ;
struct kset { struct list_head list ; spinlock_t list_lock ; struct kobject kobj ; const struct kset_uevent_ops * uevent_ops ; } ;
struct dentry { unsigned int d_flags ; seqcount_t d_seq ; struct hlist_bl_node d_hash ; struct dentry * d_parent ; struct qstr d_name ; struct inode * d_inode ; unsigned char d_iname [ 32 ] ; unsigned int d_count ; spinlock_t d_lock ; const struct dentry_operations * d_op ; struct super_block * d_sb ; unsigned long d_time ; void * d_fsdata ; struct list_head d_lru ; union { struct list_head d_child ; struct callback_head d_rcu ; } d_u ; struct list_head d_subdirs ; struct hlist_node d_alias ; } ;
struct dentry ;
struct dentry ;
struct io_context ;
struct file { union { struct list_head fu_list ; struct callback_head fu_rcuhead ; } f_u ; struct path f_path ; const struct file_operations * f_op ; spinlock_t f_lock ; int f_sb_list_cpu ; atomic_long_t f_count ; unsigned int f_flags ; fmode_t f_mode ; loff_t f_pos ; struct fown_struct f_owner ; const struct cred * f_cred ; struct file_ra_state f_ra ; u64 f_version ; void * private_data ; struct list_head f_ep_links ; struct list_head f_tfile_llink ; struct address_space * f_mapping ; } ;
struct fasync_struct { spinlock_t fa_lock ; int magic ; int fa_fd ; struct fasync_struct * fa_next ; struct file * fa_file ; struct callback_head fa_rcu ; } ;
struct kmem_cache_node { spinlock_t list_lock ; unsigned long nr_partial ; struct list_head partial ; atomic_long_t nr_slabs ; atomic_long_t total_objects ; struct list_head full ; } ;
struct proc_dir_entry { unsigned int low_ino ; umode_t mode ; nlink_t nlink ; kuid_t uid ; kgid_t gid ; loff_t size ; const struct inode_operations * proc_iops ; const struct file_operations * proc_fops ; struct proc_dir_entry * next , * parent , * subdir ; void * data ; read_proc_t * read_proc ; write_proc_t * write_proc ; atomic_t count ; int pde_users ; struct completion * pde_unload_completion ; struct list_head pde_openers ; spinlock_t pde_unload_lock ; u8 namelen ; char name [ ] ; } ;
struct klist { spinlock_t k_lock ; struct list_head k_list ; void ( * get ) ( struct klist_node * ) ; void ( * put ) ( struct klist_node * ) ; } __attribute__ ( ( aligned ( sizeof ( void * ) ) ) ) ;
struct wakeup_source { const char * name ; struct list_head entry ; spinlock_t lock ; struct timer_list timer ; unsigned long timer_expires ; ktime_t total_time ; ktime_t max_time ; ktime_t last_time ; ktime_t start_prevent_time ; ktime_t prevent_sleep_time ; unsigned long event_count ; unsigned long active_count ; unsigned long relax_count ; unsigned long expire_count ; unsigned long wakeup_count ; K_bool active : 1 ; K_bool autosleep_enabled : 1 ; } ;
struct pci_dynids { spinlock_t lock ; struct list_head list ; } ;
struct kern_ipc_perm { spinlock_t lock ; int deleted ; int id ; key_t key ; kuid_t uid ; kgid_t gid ; kuid_t cuid ; kgid_t cgid ; umode_t mode ; unsigned long seq ; void * security ; } ;
struct kern_ipc_perm ;
struct aio_ring_info { unsigned long mmap_base ; unsigned long mmap_size ; struct page * * ring_pages ; spinlock_t ring_lock ; long nr_pages ; unsigned nr , tail ; struct page * internal_pages [ 8 ] ; } ;
struct task_delay_info { spinlock_t lock ; unsigned int flags ; struct timespec blkio_start , blkio_end ; u64 blkio_delay ; u64 swapin_delay ; u32 blkio_count ; u32 swapin_count ; struct timespec freepages_start , freepages_end ; u64 freepages_delay ; u32 freepages_count ; } ;
struct io_context ;
struct proc_dir_entry ;
struct proc_dir_entry ;
struct file ;
struct sk_buff_head { struct sk_buff * next ; struct sk_buff * prev ; __u32 qlen ; spinlock_t lock ; } ;
struct inet_frag_queue { struct hlist_node list ; struct netns_frags * net ; struct list_head lru_list ; spinlock_t lock ; atomic_t refcnt ; struct timer_list timer ; struct sk_buff * fragments ; struct sk_buff * fragments_tail ; ktime_t stamp ; int len ; int meat ; __u8 last_in ; u16 max_size ; } ;
struct netns_ipv6 { struct netns_sysctl_ipv6 sysctl ; struct ipv6_devconf * devconf_all ; struct ipv6_devconf * devconf_dflt ; struct inet_peer_base * peers ; struct netns_frags frags ; struct xt_table * ip6table_filter ; struct xt_table * ip6table_mangle ; struct xt_table * ip6table_raw ; struct xt_table * ip6table_nat ; struct rt6_info * ip6_null_entry ; struct rt6_statistics * rt6_stats ; struct timer_list ip6_fib_timer ; struct hlist_head * fib_table_hash ; struct fib6_table * fib6_main_tbl ; struct dst_ops ip6_dst_ops ; unsigned int ip6_rt_gc_expire ; unsigned long ip6_rt_last_gc ; struct rt6_info * ip6_prohibit_entry ; struct rt6_info * ip6_blk_hole_entry ; struct fib6_table * fib6_local_tbl ; struct fib_rules_ops * fib6_rules_ops ; struct sock * * icmp_sk ; struct sock * ndisc_sk ; struct sock * tcp_sk ; struct sock * igmp_sk ; struct list_head mr6_tables ; struct fib_rules_ops * mr6_rules_ops ; } ;
struct proc_dir_entry ;
struct netns_sctp { __typeof__ ( struct sctp_mib ) * sctp_statistics [ 1 ] ; struct proc_dir_entry * proc_net_sctp ; struct ctl_table_header * sysctl_header ; struct sock * ctl_sock ; struct list_head local_addr_list ; struct list_head addr_waitq ; struct timer_list addr_wq_timer ; struct list_head auto_asconf_splist ; spinlock_t addr_wq_lock ; spinlock_t local_addr_lock ; unsigned int rto_initial ; unsigned int rto_min ; unsigned int rto_max ; int rto_alpha ; int rto_beta ; int max_burst ; int cookie_preserve_enable ; char * sctp_hmac_alg ; unsigned int valid_cookie_life ; unsigned int sack_timeout ; unsigned int hb_interval ; int max_retrans_association ; int max_retrans_path ; int max_retrans_init ; int pf_retrans ; int sndbuf_policy ; int rcvbuf_policy ; int default_auto_asconf ; int addip_enable ; int addip_noauth ; int prsctp_enable ; int auth_enable ; int scope_policy ; int rwnd_upd_shift ; unsigned long max_autoclose ; } ;
struct proc_dir_entry ;
struct file ;
struct dentry ;
struct idr { struct idr_layer * top ; struct idr_layer * id_free ; int layers ; int id_free_cnt ; spinlock_t lock ; } ;
struct dentry ;
struct simple_xattrs { struct list_head head ; spinlock_t lock ; } ;
struct kern_ipc_perm ;
struct dentry ;
struct file ;
struct napi_struct { struct list_head poll_list ; unsigned long state ; int weight ; unsigned int gro_count ; int ( * poll ) ( struct napi_struct * , int ) ; spinlock_t poll_lock ; int poll_owner ; struct net_device * dev ; struct sk_buff * gro_list ; struct sk_buff * skb ; struct list_head dev_list ; } ;
struct netdev_queue { struct net_device * dev ; struct Qdisc * qdisc ; struct Qdisc * qdisc_sleeping ; struct kobject kobj ; int numa_node ; spinlock_t _xmit_lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; int xmit_lock_owner ; unsigned long trans_start ; unsigned long trans_timeout ; unsigned long state ; struct dql dql ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct res_counter { unsigned long long usage ; unsigned long long max_usage ; unsigned long long limit ; unsigned long long soft_limit ; unsigned long long failcnt ; spinlock_t lock ; struct res_counter * parent ; } ;
struct fastopen_queue { struct request_sock * rskq_rst_head ; struct request_sock * rskq_rst_tail ; spinlock_t lock ; int qlen ; int max_qlen ; } ;
struct inet_timewait_death_row { int twcal_hand ; unsigned long twcal_jiffie ; struct timer_list twcal_timer ; struct hlist_head twcal_row [ ( 1 << 5 ) ] ; spinlock_t death_lock ; int tw_count ; int period ; u32 thread_slots ; struct work_struct twkill_work ; struct timer_list tw_timer ; int slot ; struct hlist_head cells [ 8 ] ; struct inet_hashinfo * hashinfo ; int sysctl_tw_recycle ; int sysctl_max_tw_buckets ; } ;
struct gnet_dump { spinlock_t * lock ; struct sk_buff * skb ; struct nlattr * tail ; int compat_tc_stats ; int compat_xstats ; void * xstats ; int xstats_len ; struct tc_stats tc_stats ; } ;
struct bdi_writeback ;
struct dentry ;
struct bdi_writeback { struct backing_dev_info * bdi ; unsigned int nr ; unsigned long last_old_flush ; unsigned long last_active ; struct task_struct * task ; struct timer_list wakeup_timer ; struct list_head b_dirty ; struct list_head b_io ; struct list_head b_more_io ; spinlock_t list_lock ; } ;
struct io_context { atomic_long_t refcount ; atomic_t active_ref ; atomic_t nr_tasks ; spinlock_t lock ; unsigned short ioprio ; int nr_batch_requests ; unsigned long last_waited ; struct radix_tree_root icq_tree ; struct io_cq * icq_hint ; struct hlist_head icq_list ; struct work_struct release_work ; } ;
struct transaction_s { journal_t * t_journal ; tid_t t_tid ; enum { T_RUNNING , T_LOCKED , T_FLUSH , T_COMMIT , T_COMMIT_DFLUSH , T_COMMIT_JFLUSH , T_FINISHED } t_state ; unsigned long t_log_start ; int t_nr_buffers ; struct journal_head * t_reserved_list ; struct journal_head * t_buffers ; struct journal_head * t_forget ; struct journal_head * t_checkpoint_list ; struct journal_head * t_checkpoint_io_list ; struct journal_head * t_iobuf_list ; struct journal_head * t_shadow_list ; struct journal_head * t_log_list ; struct list_head t_inode_list ; spinlock_t t_handle_lock ; unsigned long t_max_wait ; unsigned long t_start ; struct transaction_chp_stats_s t_chp_stats ; atomic_t t_updates ; atomic_t t_outstanding_credits ; transaction_t * t_cpnext , * t_cpprev ; unsigned long t_expires ; ktime_t t_start_time ; atomic_t t_handle_count ; unsigned int t_synchronous_commit : 1 ; int t_need_data_flush ; struct list_head t_private_list ; } ;
struct bgl_lock { spinlock_t lock ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct dentry ;
struct file ;
struct dentry ;
struct kthread_worker { spinlock_t lock ; struct list_head work_list ; struct task_struct * task ; struct kthread_work * current_work ; } ;
struct page ;
struct task_struct ;
struct task_struct ;
struct seq_file ;
struct page ;
struct task_struct ;
struct task_struct ;
struct task_struct ;
struct task_struct ;
typedef struct { unsigned sequence ; spinlock_t lock ; } seqlock_t ;
struct task_struct ;
struct page ;
struct srcu_notifier_head { struct mutex mutex ; struct srcu_struct srcu ; struct notifier_block * head ; } ;
struct page ;
struct task_struct ;
struct page ;
struct task_struct ;
struct task_struct ;
struct page ;
struct block_device ;
struct seq_file ;
struct quota_info { unsigned int flags ; struct mutex dqio_mutex ; struct mutex dqonoff_mutex ; struct rw_semaphore dqptr_sem ; struct inode * files [ 2 ] ; struct mem_dqinfo info [ 2 ] ; const struct quota_format_ops * ops [ 2 ] ; } ;
struct page ;
struct address_space ;
struct backing_dev_info ;
struct address_space { struct inode * host ; struct radix_tree_root page_tree ; spinlock_t tree_lock ; unsigned int i_mmap_writable ; struct rb_root i_mmap ; struct list_head i_mmap_nonlinear ; struct mutex i_mmap_mutex ; unsigned long nrpages ; unsigned long writeback_index ; const struct address_space_operations * a_ops ; unsigned long flags ; struct backing_dev_info * backing_dev_info ; spinlock_t private_lock ; struct list_head private_list ; void * private_data ; } __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ;
struct block_device { dev_t bd_dev ; int bd_openers ; struct inode * bd_inode ; struct super_block * bd_super ; struct mutex bd_mutex ; struct list_head bd_inodes ; void * bd_claiming ; void * bd_holder ; int bd_holders ; K_bool bd_write_holder ; struct list_head bd_holder_disks ; struct block_device * bd_contains ; unsigned bd_block_size ; struct hd_struct * bd_part ; unsigned bd_part_count ; int bd_invalidated ; struct gendisk * bd_disk ; struct request_queue * bd_queue ; struct list_head bd_list ; unsigned long bd_private ; int bd_fsfreeze_count ; struct mutex bd_fsfreeze_mutex ; } ;
struct seq_file ;
struct task_struct ;
struct pci_driver { struct list_head node ; const char * name ; const struct pci_device_id * id_table ; int ( * probe ) ( struct pci_dev * dev , const struct pci_device_id * id ) ; void ( * remove ) ( struct pci_dev * dev ) ; int ( * suspend ) ( struct pci_dev * dev , pm_message_t state ) ; int ( * suspend_late ) ( struct pci_dev * dev , pm_message_t state ) ; int ( * resume_early ) ( struct pci_dev * dev ) ; int ( * resume ) ( struct pci_dev * dev ) ; void ( * shutdown ) ( struct pci_dev * dev ) ; int ( * sriov_configure ) ( struct pci_dev * dev , int num_vfs ) ; const struct pci_error_handlers * err_handler ; struct device_driver driver ; struct pci_dynids dynids ; } ;
struct task_struct ;
struct task_struct ;
struct address_space ;
struct page { unsigned long flags ; struct address_space * mapping ; struct { union { unsigned long index ; void * freelist ; K_bool pfmemalloc ; } ; union { unsigned long counters ; struct { union { atomic_t _mapcount ; struct { unsigned inuse : 16 ; unsigned objects : 15 ; unsigned frozen : 1 ; } ; int units ; } ; atomic_t _count ; } ; } ; } ; union { struct list_head lru ; struct { struct page * next ; int pages ; int pobjects ; } ; struct list_head list ; struct slab * slab_page ; } ; union { unsigned long private_ ; spinlock_t ptl ; struct kmem_cache * slab_cache ; struct page * first_page ; } ; } __attribute__ ( ( aligned ( 2 * sizeof ( unsigned long ) ) ) ) ;
struct page ;
struct page ;
struct task_struct ;
struct sem_array { struct kern_ipc_perm __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) sem_perm ; time_t sem_otime ; time_t sem_ctime ; struct sem * sem_base ; struct list_head sem_pending ; struct list_head list_id ; int sem_nsems ; int complex_count ; } ;
struct prop_descriptor { int index ; struct prop_global pg [ 2 ] ; struct mutex mutex ; } ;
struct task_struct ;
struct task_struct ;
struct seq_file ;
struct seq_file ;
struct task_struct ;
struct backing_dev_info ;
struct task_struct { volatile long state ; void * stack ; atomic_t usage ; unsigned int flags ; unsigned int ptrace ; struct llist_node wake_entry ; int on_cpu ; int on_rq ; int prio , static_prio , normal_prio ; unsigned int rt_priority ; const struct sched_class * sched_class ; struct sched_entity se ; struct sched_rt_entity rt ; struct task_group * sched_task_group ; struct hlist_head preempt_notifiers ; unsigned char fpu_counter ; unsigned int btrace_seq ; unsigned int policy ; int nr_cpus_allowed ; cpumask_t cpus_allowed ; struct sched_info sched_info ; struct list_head tasks ; struct plist_node pushable_tasks ; struct mm_struct * mm , * active_mm ; struct task_rss_stat rss_stat ; int exit_state ; int exit_code , exit_signal ; int pdeath_signal ; unsigned int jobctl ; unsigned int personality ; unsigned did_exec : 1 ; unsigned in_execve : 1 ; unsigned in_iowait : 1 ; unsigned no_new_privs : 1 ; unsigned sched_reset_on_fork : 1 ; unsigned sched_contributes_to_load : 1 ; pid_t pid ; pid_t tgid ; unsigned long stack_canary ; struct task_struct * real_parent ; struct task_struct * parent ; struct list_head children ; struct list_head sibling ; struct task_struct * group_leader ; struct list_head ptraced ; struct list_head ptrace_entry ; struct pid_link pids [ PIDTYPE_MAX ] ; struct list_head thread_group ; struct completion * vfork_done ; int * set_child_tid ; int * clear_child_tid ; cputime_t utime , stime , utimescaled , stimescaled ; cputime_t gtime ; struct cputime prev_cputime ; unsigned long nvcsw , nivcsw ; struct timespec start_time ; struct timespec real_start_time ; unsigned long min_flt , maj_flt ; struct task_cputime cputime_expires ; struct list_head cpu_timers [ 3 ] ; const struct cred * real_cred ; const struct cred * cred ; char comm [ 16 ] ; int link_count , total_link_count ; struct sysv_sem sysvsem ; unsigned long last_switch_count ; struct thread_struct thread ; struct fs_struct * fs ; struct files_struct * files ; struct nsproxy * nsproxy ; struct signal_struct * signal ; struct sighand_struct * sighand ; sigset_t blocked , real_blocked ; sigset_t saved_sigmask ; struct sigpending pending ; unsigned long sas_ss_sp ; size_t sas_ss_size ; int ( * notifier ) ( void * priv ) ; void * notifier_data ; sigset_t * notifier_mask ; struct callback_head * task_works ; struct audit_context * audit_context ; kuid_t loginuid ; unsigned int sessionid ; struct seccomp seccomp ; u32 parent_exec_id ; u32 self_exec_id ; spinlock_t alloc_lock ; raw_spinlock_t pi_lock ; struct plist_head pi_waiters ; struct rt_mutex_waiter * pi_blocked_on ; void * journal_info ; struct bio_list * bio_list ; struct blk_plug * plug ; struct reclaim_state * reclaim_state ; struct backing_dev_info * backing_dev_info ; struct io_context * io_context ; unsigned long ptrace_message ; siginfo_t * last_siginfo ; struct task_io_accounting ioac ; u64 acct_rss_mem1 ; u64 acct_vm_mem1 ; cputime_t acct_timexpd ; nodemask_t mems_allowed ; seqcount_t mems_allowed_seq ; int cpuset_mem_spread_rotor ; int cpuset_slab_spread_rotor ; struct css_set * cgroups ; struct list_head cg_list ; struct robust_list_head * robust_list ; struct compat_robust_list_head * compat_robust_list ; struct list_head pi_state_list ; struct futex_pi_state * pi_state_cache ; struct perf_event_context * perf_event_ctxp [ perf_nr_task_contexts ] ; struct mutex perf_event_mutex ; struct list_head perf_event_list ; struct mempolicy * mempolicy ; short il_next ; short pref_node_fork ; struct callback_head rcu ; struct pipe_inode_info * splice_pipe ; struct page_frag task_frag ; struct task_delay_info * delays ; int nr_dirtied ; int nr_dirtied_pause ; unsigned long dirty_paused_when ; int latency_record_count ; struct latency_record latency_record [ 32 ] ; unsigned long timer_slack_ns ; unsigned long default_timer_slack_ns ; int curr_ret_stack ; struct ftrace_ret_stack * ret_stack ; unsigned long long ftrace_timestamp ; atomic_t trace_overrun ; atomic_t tracing_graph_pause ; unsigned long trace ; unsigned long trace_recursion ; atomic_t ptrace_bp_refcnt ; } ;
struct task_struct ;
struct seq_file ;
struct task_struct ;
struct seq_file ;
struct seq_file ;
struct page ;
struct netns_packet { struct mutex sklist_lock ; struct hlist_head sklist ; } ;
struct seq_file { char * buf ; size_t size ; size_t from ; size_t count ; loff_t index ; loff_t read_pos ; u64 version ; struct mutex lock ; const struct seq_operations * op ; int poll_event ; void * private_ ; } ;
struct ida { struct idr idr ; struct ida_bitmap * free_bitmap ; } ;
struct cgroup_subsys ;
struct cgroup ;
struct cgroup { unsigned long flags ; atomic_t count ; int id ; struct list_head sibling ; struct list_head children ; struct list_head files ; struct cgroup * parent ; struct dentry * dentry ; struct cgroup_subsys_state * subsys [ CGROUP_SUBSYS_COUNT ] ; struct cgroupfs_root * root ; struct cgroup * top_cgroup ; struct list_head css_sets ; struct list_head allcg_node ; struct list_head cft_q_node ; struct list_head release_list ; struct list_head pidlists ; struct mutex pidlist_mutex ; struct callback_head callback_head ; struct list_head event_list ; spinlock_t event_list_lock ; struct simple_xattrs xattrs ; } ;
struct cftype { char name [ 64 ] ; int private_ ; umode_t mode ; size_t max_write_len ; unsigned int flags ; struct simple_xattrs xattrs ; int ( * open ) ( struct inode * inode , struct file * file ) ; ssize_t ( * read ) ( struct cgroup * cgrp , struct cftype * cft , struct file * file , char * buf , size_t nbytes , loff_t * ppos ) ; u64 ( * read_u64 ) ( struct cgroup * cgrp , struct cftype * cft ) ; s64 ( * read_s64 ) ( struct cgroup * cgrp , struct cftype * cft ) ; int ( * read_map ) ( struct cgroup * cont , struct cftype * cft , struct cgroup_map_cb * cb ) ; int ( * read_seq_string ) ( struct cgroup * cont , struct cftype * cft , struct seq_file * m ) ; ssize_t ( * write ) ( struct cgroup * cgrp , struct cftype * cft , struct file * file , const char * buf , size_t nbytes , loff_t * ppos ) ; int ( * write_u64 ) ( struct cgroup * cgrp , struct cftype * cft , u64 val ) ; int ( * write_s64 ) ( struct cgroup * cgrp , struct cftype * cft , s64 val ) ; int ( * write_string ) ( struct cgroup * cgrp , struct cftype * cft , const char * buffer ) ; int ( * trigger ) ( struct cgroup * cgrp , unsigned int event ) ; int ( * release ) ( struct inode * inode , struct file * file ) ; int ( * register_event ) ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd , const char * args ) ; void ( * unregister_event ) ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) ; } ;
struct cgroup_subsys { struct cgroup_subsys_state * ( * css_alloc ) ( struct cgroup * cgrp ) ; int ( * css_online ) ( struct cgroup * cgrp ) ; void ( * css_offline ) ( struct cgroup * cgrp ) ; void ( * css_free ) ( struct cgroup * cgrp ) ; int ( * can_attach ) ( struct cgroup * cgrp , struct cgroup_taskset * tset ) ; void ( * cancel_attach ) ( struct cgroup * cgrp , struct cgroup_taskset * tset ) ; void ( * attach ) ( struct cgroup * cgrp , struct cgroup_taskset * tset ) ; void ( * fork ) ( struct task_struct * task ) ; void ( * exit ) ( struct cgroup * cgrp , struct cgroup * old_cgrp , struct task_struct * task ) ; void ( * bind ) ( struct cgroup * root ) ; int subsys_id ; int active ; int disabled ; int early_init ; K_bool use_id ; K_bool broken_hierarchy ; K_bool warned_broken_hierarchy ; const char * name ; struct cgroupfs_root * root ; struct list_head sibling ; struct idr idr ; spinlock_t id_lock ; struct list_head cftsets ; struct cftype * base_cftypes ; struct cftype_set base_cftset ; struct module * module ; } ;
struct sem_array ;
struct seq_file ;
struct softnet_data { struct Qdisc * output_queue ; struct Qdisc * * output_queue_tailp ; struct list_head poll_list ; struct sk_buff * completion_queue ; struct sk_buff_head process_queue ; unsigned int processed ; unsigned int time_squeeze ; unsigned int cpu_collision ; unsigned int received_rps ; struct softnet_data * rps_ipi_list ; struct call_single_data csd __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; struct softnet_data * rps_ipi_next ; unsigned int cpu ; unsigned int input_queue_head ; unsigned int input_queue_tail ; unsigned int dropped ; struct sk_buff_head input_pkt_queue ; struct napi_struct backlog ; } ;
struct page ;
struct neigh_table { struct neigh_table * next ; int family ; int entry_size ; int key_len ; __u32 ( * hash ) ( const void * pkey , const struct net_device * dev , __u32 * hash_rnd ) ; int ( * constructor ) ( struct neighbour * ) ; int ( * pconstructor ) ( struct pneigh_entry * ) ; void ( * pdestructor ) ( struct pneigh_entry * ) ; void ( * proxy_redo ) ( struct sk_buff * skb ) ; char * id ; struct neigh_parms parms ; int gc_interval ; int gc_thresh1 ; int gc_thresh2 ; int gc_thresh3 ; unsigned long last_flush ; struct delayed_work gc_work ; struct timer_list proxy_timer ; struct sk_buff_head proxy_queue ; atomic_t entries ; rwlock_t lock ; unsigned long last_rand ; struct neigh_statistics * stats ; struct neigh_hash_table * nht ; struct pneigh_entry * * phash_buckets ; } ;
struct cgroup ;
struct cgroup_subsys ;
struct Qdisc { int ( * enqueue ) ( struct sk_buff * skb , struct Qdisc * dev ) ; struct sk_buff * ( * dequeue ) ( struct Qdisc * dev ) ; unsigned int flags ; int padded ; const struct Qdisc_ops * ops ; struct qdisc_size_table * stab ; struct list_head list ; u32 handle ; u32 parent ; atomic_t refcnt ; struct gnet_stats_rate_est rate_est ; int ( * reshape_fail ) ( struct sk_buff * skb , struct Qdisc * q ) ; void * u32_node ; struct Qdisc * __parent ; struct netdev_queue * dev_queue ; struct Qdisc * next_sched ; struct sk_buff * gso_skb ; unsigned long state ; struct sk_buff_head q ; struct gnet_stats_basic_packed bstats ; unsigned int __state ; struct gnet_stats_queue qstats ; struct callback_head callback_head ; spinlock_t busylock ; u32 limit ; } ;
struct backing_dev_info ;
struct page ;
struct backing_dev_info { struct list_head bdi_list ; unsigned long ra_pages ; unsigned long state ; unsigned int capabilities ; congested_fn * congested_fn ; void * congested_data ; char * name ; struct percpu_counter bdi_stat [ NR_BDI_STAT_ITEMS ] ; unsigned long bw_time_stamp ; unsigned long dirtied_stamp ; unsigned long written_stamp ; unsigned long write_bandwidth ; unsigned long avg_write_bandwidth ; unsigned long dirty_ratelimit ; unsigned long balanced_dirty_ratelimit ; struct fprop_local_percpu completions ; int dirty_exceeded ; unsigned int min_ratio ; unsigned int max_ratio , max_prop_frac ; struct bdi_writeback wb ; spinlock_t wb_lock ; struct list_head work_list ; struct device * dev ; struct timer_list laptop_mode_wb_timer ; struct dentry * debug_dir ; struct dentry * debug_stats ; } ;
struct task_struct ;
struct elevator_queue ;
struct elevator_queue { struct elevator_type * type ; void * elevator_data ; struct kobject kobj ; struct mutex sysfs_lock ; struct hlist_head * hash ; unsigned int registered : 1 ; } ;
struct page ;
struct address_space ;
struct blockgroup_lock { struct bgl_lock locks [ 128 ] ; } ;
struct address_space ;
struct backing_dev_info ;
struct block_device ;
struct ata_host { spinlock_t lock ; struct device * dev ; void * const * iomap ; unsigned int n_ports ; void * private_data ; struct ata_port_operations * ops ; unsigned long flags ; struct mutex eh_mutex ; struct task_struct * eh_owner ; struct ata_port * simplex_claimed ; struct ata_port * ports [ 0 ] ; } ;
struct ff_device { int ( * upload ) ( struct input_dev * dev , struct ff_effect * effect , struct ff_effect * old ) ; int ( * erase ) ( struct input_dev * dev , int effect_id ) ; int ( * playback ) ( struct input_dev * dev , int effect_id , int value ) ; void ( * set_gain ) ( struct input_dev * dev , u16 gain ) ; void ( * set_autocenter ) ( struct input_dev * dev , u16 magnitude ) ; void ( * destroy ) ( struct ff_device * ) ; void * private_ ; unsigned long ffbit [ ( ( ( ( 0x7f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; struct mutex mutex ; int max_effects ; struct ff_effect * effects ; struct file * effect_owners [ ] ; } ;
struct completion ;
struct zone { unsigned long watermark [ NR_WMARK ] ; unsigned long percpu_drift_mark ; unsigned long lowmem_reserve [ 4 ] ; unsigned long dirty_balance_reserve ; int node ; unsigned long min_unmapped_pages ; unsigned long min_slab_pages ; struct per_cpu_pageset * pageset ; spinlock_t lock ; int all_unreclaimable ; K_bool compact_blockskip_flush ; unsigned long compact_cached_free_pfn ; unsigned long compact_cached_migrate_pfn ; seqlock_t span_seqlock ; struct free_area free_area [ 11 ] ; unsigned int compact_considered ; unsigned int compact_defer_shift ; int compact_order_failed ; struct zone_padding _pad1_ ; spinlock_t lru_lock ; struct lruvec lruvec ; unsigned long pages_scanned ; unsigned long flags ; atomic_long_t vm_stat [ NR_VM_ZONE_STAT_ITEMS ] ; unsigned int inactive_ratio ; struct zone_padding _pad2_ ; wait_queue_head_t * wait_table ; unsigned long wait_table_hash_nr_entries ; unsigned long wait_table_bits ; struct pglist_data * zone_pgdat ; unsigned long zone_start_pfn ; unsigned long spanned_pages ; unsigned long present_pages ; unsigned long managed_pages ; const char * name ; } __attribute__ ( ( __aligned__ ( 1 << ( 6 ) ) ) ) ;
struct completion { unsigned int done ; wait_queue_head_t wait ; } ;
struct zone ;
typedef struct { void * ldt ; int size ; unsigned short ia32_compat ; struct mutex lock ; void * vdso ; } mm_context_t ;
struct completion ;
struct ctl_table_poll { atomic_t event ; wait_queue_head_t wait ; } ;
struct inode ;
struct percpu_rw_semaphore { unsigned int * fast_read_ctr ; atomic_t write_ctr ; struct rw_semaphore rw_sem ; atomic_t slow_read_ctr ; wait_queue_head_t write_waitq ; } ;
struct dquot ;
struct dquot { struct hlist_node dq_hash ; struct list_head dq_inuse ; struct list_head dq_free ; struct list_head dq_dirty ; struct mutex dq_lock ; atomic_t dq_count ; wait_queue_head_t dq_wait_unused ; struct super_block * dq_sb ; struct kqid dq_id ; loff_t dq_off ; unsigned long dq_flags ; struct mem_dqblk dq_dqb ; } ;
struct inode { umode_t i_mode ; unsigned short i_opflags ; kuid_t i_uid ; kgid_t i_gid ; unsigned int i_flags ; struct posix_acl * i_acl ; struct posix_acl * i_default_acl ; const struct inode_operations * i_op ; struct super_block * i_sb ; struct address_space * i_mapping ; unsigned long i_ino ; union { const unsigned int i_nlink ; unsigned int __i_nlink ; } ; dev_t i_rdev ; loff_t i_size ; struct timespec i_atime ; struct timespec i_mtime ; struct timespec i_ctime ; spinlock_t i_lock ; unsigned short i_bytes ; unsigned int i_blkbits ; blkcnt_t i_blocks ; unsigned long i_state ; struct mutex i_mutex ; unsigned long dirtied_when ; struct hlist_node i_hash ; struct list_head i_wb_list ; struct list_head i_lru ; struct list_head i_sb_list ; union { struct hlist_head i_dentry ; struct callback_head i_rcu ; } ; u64 i_version ; atomic_t i_count ; atomic_t i_dio_count ; atomic_t i_writecount ; const struct file_operations * i_fop ; struct file_lock * i_flock ; struct address_space i_data ; struct dquot * i_dquot [ 2 ] ; struct list_head i_devices ; union { struct pipe_inode_info * i_pipe ; struct block_device * i_bdev ; struct cdev * i_cdev ; } ; __u32 i_generation ; __u32 i_fsnotify_mask ; struct hlist_head i_fsnotify_marks ; void * i_private ; } ;
struct file_lock { struct file_lock * fl_next ; struct list_head fl_link ; struct list_head fl_block ; fl_owner_t fl_owner ; unsigned int fl_flags ; unsigned char fl_type ; unsigned int fl_pid ; struct pid * fl_nspid ; wait_queue_head_t fl_wait ; struct file * fl_file ; loff_t fl_start ; loff_t fl_end ; struct fasync_struct * fl_fasync ; unsigned long fl_break_time ; unsigned long fl_downgrade_time ; const struct file_lock_operations * fl_ops ; const struct lock_manager_operations * fl_lmops ; union { struct nfs_lock_info nfs_fl ; struct nfs4_lock_info nfs4_fl ; struct { struct list_head link ; int state ; } afs ; } fl_u ; } ;
struct sb_writers { struct percpu_counter counter [ ( SB_FREEZE_COMPLETE - 1 ) ] ; wait_queue_head_t wait ; int frozen ; wait_queue_head_t wait_unfrozen ; } ;
struct completion ;
struct inode ;
struct inode ;
struct signal_struct ;
struct inode ;
struct kioctx ;
struct kioctx { atomic_t users ; int dead ; struct mm_struct * mm ; unsigned long user_id ; struct hlist_node list ; wait_queue_head_t wait ; spinlock_t ctx_lock ; int reqs_active ; struct list_head active_reqs ; struct list_head run_list ; unsigned max_reqs ; struct aio_ring_info ring_info ; struct delayed_work wq ; struct callback_head callback_head ; } ;
struct sighand_struct { atomic_t count ; struct k_sigaction action [ 64 ] ; spinlock_t siglock ; wait_queue_head_t signalfd_wqh ; } ;
struct signal_struct { atomic_t sigcnt ; atomic_t live ; int nr_threads ; wait_queue_head_t wait_chldexit ; struct task_struct * curr_target ; struct sigpending shared_pending ; int group_exit_code ; int notify_count ; struct task_struct * group_exit_task ; int group_stop_count ; unsigned int flags ; unsigned int is_child_subreaper : 1 ; unsigned int has_child_subreaper : 1 ; struct list_head posix_timers ; struct hrtimer real_timer ; struct pid * leader_pid ; ktime_t it_real_incr ; struct cpu_itimer it [ 2 ] ; struct thread_group_cputimer cputimer ; struct task_cputime cputime_expires ; struct list_head cpu_timers [ 3 ] ; struct pid * tty_old_pgrp ; int leader ; struct tty_struct * tty ; struct autogroup * autogroup ; cputime_t utime , stime , cutime , cstime ; cputime_t gtime ; cputime_t cgtime ; struct cputime prev_cputime ; unsigned long nvcsw , nivcsw , cnvcsw , cnivcsw ; unsigned long min_flt , maj_flt , cmin_flt , cmaj_flt ; unsigned long inblock , oublock , cinblock , coublock ; unsigned long maxrss , cmaxrss ; struct task_io_accounting ioac ; unsigned long long sum_sched_runtime ; struct rlimit rlim [ 16 ] ; struct pacct_struct pacct ; struct taskstats * stats ; unsigned audit_tty ; struct tty_audit_buf * tty_audit_buf ; struct rw_semaphore group_rwsem ; oom_flags_t oom_flags ; short oom_score_adj ; short oom_score_adj_min ; struct mutex cred_guard_mutex ; } ;
struct irq_desc ;
struct irq_desc ;
struct irq_desc { struct irq_data irq_data ; unsigned int * kstat_irqs ; irq_flow_handler_t handle_irq ; struct irqaction * action ; unsigned int status_use_accessors ; unsigned int core_internal_state__do_not_mess_with_it ; unsigned int depth ; unsigned int wake_depth ; unsigned int irq_count ; unsigned long last_unhandled ; unsigned int irqs_unhandled ; raw_spinlock_t lock ; struct cpumask * percpu_enabled ; const struct cpumask * affinity_hint ; struct irq_affinity_notify * affinity_notify ; cpumask_var_t pending_mask ; unsigned long threads_oneshot ; atomic_t threads_active ; wait_queue_head_t wait_for_threads ; struct proc_dir_entry * dir ; int parent_irq ; struct module * owner ; const char * name ; } __attribute__ ( ( __aligned__ ( 1 << ( 6 ) ) ) ) ;
struct inode ;
struct socket_wq { wait_queue_head_t wait ; struct fasync_struct * fasync_list ; struct callback_head rcu ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct netns_xfrm { struct list_head state_all ; struct hlist_head * state_bydst ; struct hlist_head * state_bysrc ; struct hlist_head * state_byspi ; unsigned int state_hmask ; unsigned int state_num ; struct work_struct state_hash_work ; struct hlist_head state_gc_list ; struct work_struct state_gc_work ; wait_queue_head_t km_waitq ; struct list_head policy_all ; struct hlist_head * policy_byidx ; unsigned int policy_idx_hmask ; struct hlist_head policy_inexact [ XFRM_POLICY_MAX * 2 ] ; struct xfrm_policy_hash policy_bydst [ XFRM_POLICY_MAX * 2 ] ; unsigned int policy_count [ XFRM_POLICY_MAX * 2 ] ; struct work_struct policy_hash_work ; struct sock * nlsk ; struct sock * nlsk_stash ; u32 sysctl_aevent_etime ; u32 sysctl_aevent_rseqth ; int sysctl_larval_drop ; u32 sysctl_acq_expires ; struct ctl_table_header * sysctl_hdr ; struct dst_ops xfrm4_dst_ops ; struct dst_ops xfrm6_dst_ops ; } ;
struct inode ;
struct inode ;
struct inode ;
struct inode ;
struct hh_cache { u16 hh_len ; u16 __pad ; seqlock_t hh_lock ; unsigned long hh_data [ ( ( ( 128 ) + ( 16 - 1 ) ) & ~ ( 16 - 1 ) ) / sizeof ( long ) ] ; } ;
struct journal_s { unsigned long j_flags ; int j_errno ; struct buffer_head * j_sb_buffer ; journal_superblock_t * j_superblock ; int j_format_version ; rwlock_t j_state_lock ; int j_barrier_count ; struct mutex j_barrier ; transaction_t * j_running_transaction ; transaction_t * j_committing_transaction ; transaction_t * j_checkpoint_transactions ; wait_queue_head_t j_wait_transaction_locked ; wait_queue_head_t j_wait_logspace ; wait_queue_head_t j_wait_done_commit ; wait_queue_head_t j_wait_checkpoint ; wait_queue_head_t j_wait_commit ; wait_queue_head_t j_wait_updates ; struct mutex j_checkpoint_mutex ; struct buffer_head * j_chkpt_bhs [ 64 ] ; unsigned long j_head ; unsigned long j_tail ; unsigned long j_free ; unsigned long j_first ; unsigned long j_last ; struct block_device * j_dev ; int j_blocksize ; unsigned long long j_blk_offset ; char j_devname [ 32 + 24 ] ; struct block_device * j_fs_dev ; unsigned int j_maxlen ; spinlock_t j_list_lock ; struct inode * j_inode ; tid_t j_tail_sequence ; tid_t j_transaction_sequence ; tid_t j_commit_sequence ; tid_t j_commit_request ; __u8 j_uuid [ 16 ] ; struct task_struct * j_task ; int j_max_transaction_buffers ; unsigned long j_commit_interval ; struct timer_list j_commit_timer ; spinlock_t j_revoke_lock ; struct jbd2_revoke_table_s * j_revoke ; struct jbd2_revoke_table_s * j_revoke_table [ 2 ] ; struct buffer_head * * j_wbuf ; int j_wbufsize ; pid_t j_last_sync_writer ; u64 j_average_commit_time ; u32 j_min_batch_time ; u32 j_max_batch_time ; void ( * j_commit_callback ) ( journal_t * , transaction_t * ) ; spinlock_t j_history_lock ; struct proc_dir_entry * j_proc_entry ; struct transaction_stats_s j_stats ; unsigned int j_failed_commit ; void * j_private ; struct crypto_shash * j_chksum_driver ; __u32 j_csum_seed ; } ;
struct zone ;
struct inode ;
struct kthread_work ;
struct kthread_work { struct list_head node ; kthread_work_func_t func ; wait_queue_head_t done ; struct kthread_worker * worker ; } ;
struct completion ;
struct mm_struct ;
struct mm_struct ;
struct pglist_data ;
struct pglist_data ;
struct dev_pm_info { pm_message_t power_state ; unsigned int can_wakeup : 1 ; unsigned int async_suspend : 1 ; K_bool is_prepared : 1 ; K_bool is_suspended : 1 ; K_bool ignore_children : 1 ; K_bool early_init : 1 ; spinlock_t lock ; struct list_head entry ; struct completion completion ; struct wakeup_source * wakeup ; K_bool wakeup_path : 1 ; K_bool syscore : 1 ; struct timer_list suspend_timer ; unsigned long timer_expires ; struct work_struct work ; wait_queue_head_t wait_queue ; atomic_t usage_count ; atomic_t child_count ; unsigned int disable_depth : 3 ; unsigned int idle_notification : 1 ; unsigned int request_pending : 1 ; unsigned int deferred_resume : 1 ; unsigned int run_wake : 1 ; unsigned int runtime_auto : 1 ; unsigned int no_callbacks : 1 ; unsigned int irq_safe : 1 ; unsigned int use_autosuspend : 1 ; unsigned int timer_autosuspends : 1 ; enum rpm_request request ; enum rpm_status runtime_status ; int runtime_error ; int autosuspend_delay ; unsigned long last_busy ; unsigned long active_jiffies ; unsigned long suspended_jiffies ; unsigned long accounting_timestamp ; struct pm_subsys_data * subsys_data ; struct dev_pm_qos * qos ; } ;
struct super_block ;
struct net ;
struct mm_struct ;
struct super_block { struct list_head s_list ; dev_t s_dev ; unsigned char s_blocksize_bits ; unsigned long s_blocksize ; loff_t s_maxbytes ; struct file_system_type * s_type ; const struct super_operations * s_op ; const struct dquot_operations * dq_op ; const struct quotactl_ops * s_qcop ; const struct export_operations * s_export_op ; unsigned long s_flags ; unsigned long s_magic ; struct dentry * s_root ; struct rw_semaphore s_umount ; int s_count ; atomic_t s_active ; const struct xattr_handler * * s_xattr ; struct list_head s_inodes ; struct hlist_bl_head s_anon ; struct list_head * s_files ; struct list_head s_mounts ; struct list_head s_dentry_lru ; int s_nr_dentry_unused ; spinlock_t s_inode_lru_lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; struct list_head s_inode_lru ; int s_nr_inodes_unused ; struct block_device * s_bdev ; struct backing_dev_info * s_bdi ; struct mtd_info * s_mtd ; struct hlist_node s_instances ; struct quota_info s_dquot ; struct sb_writers s_writers ; char s_id [ 32 ] ; u8 s_uuid [ 16 ] ; void * s_fs_info ; unsigned int s_max_links ; fmode_t s_mode ; u32 s_time_gran ; struct mutex s_vfs_rename_mutex ; char * s_subtype ; char * s_options ; const struct dentry_operations * s_d_op ; int cleancache_poolid ; struct shrinker s_shrink ; atomic_long_t s_remove_count ; int s_readonly_remount ; } ;
struct net ;
struct mm_struct ;
struct proc_inode { struct pid * pid ; int fd ; union proc_op op ; struct proc_dir_entry * pde ; struct ctl_table_header * sysctl ; struct ctl_table * sysctl_entry ; void * ns ; const struct proc_ns_operations * ns_ops ; struct inode vfs_inode ; } ;
struct mm_struct ;
struct core_state { atomic_t nr_threads ; struct core_thread dumper ; struct completion startup ; } ;
struct mm_struct { struct vm_area_struct * mmap ; struct rb_root mm_rb ; struct vm_area_struct * mmap_cache ; unsigned long ( * get_unmapped_area ) ( struct file * filp , unsigned long addr , unsigned long len , unsigned long pgoff , unsigned long flags ) ; void ( * unmap_area ) ( struct mm_struct * mm , unsigned long addr ) ; unsigned long mmap_base ; unsigned long task_size ; unsigned long cached_hole_size ; unsigned long free_area_cache ; unsigned long highest_vm_end ; pgd_t * pgd ; atomic_t mm_users ; atomic_t mm_count ; int map_count ; spinlock_t page_table_lock ; struct rw_semaphore mmap_sem ; struct list_head mmlist ; unsigned long hiwater_rss ; unsigned long hiwater_vm ; unsigned long total_vm ; unsigned long locked_vm ; unsigned long pinned_vm ; unsigned long shared_vm ; unsigned long exec_vm ; unsigned long stack_vm ; unsigned long def_flags ; unsigned long nr_ptes ; unsigned long start_code , end_code , start_data , end_data ; unsigned long start_brk , brk , start_stack ; unsigned long arg_start , arg_end , env_start , env_end ; unsigned long saved_auxv [ ( 2 * ( 0 + 19 + 1 ) ) ] ; struct mm_rss_stat rss_stat ; struct linux_binfmt * binfmt ; cpumask_var_t cpu_vm_mask_var ; mm_context_t context ; unsigned long flags ; struct core_state * core_state ; spinlock_t ioctx_lock ; struct hlist_head ioctx_list ; struct file * exe_file ; struct mmu_notifier_mm * mmu_notifier_mm ; pgtable_t pmd_huge_pte ; struct uprobes_state uprobes_state ; } ;
struct mm_struct ;
struct mm_struct ;
struct mm_struct ;
struct net ;
struct net ;
struct net { atomic_t passive ; atomic_t count ; spinlock_t rules_mod_lock ; struct list_head list ; struct list_head cleanup_list ; struct list_head exit_list ; struct user_namespace * user_ns ; unsigned int proc_inum ; struct proc_dir_entry * proc_net ; struct proc_dir_entry * proc_net_stat ; struct ctl_table_set sysctls ; struct sock * rtnl ; struct sock * genl_sock ; struct list_head dev_base_head ; struct hlist_head * dev_name_head ; struct hlist_head * dev_index_head ; unsigned int dev_base_seq ; int ifindex ; struct list_head rules_ops ; struct net_device * loopback_dev ; struct netns_core core ; struct netns_mib mib ; struct netns_packet packet ; struct netns_unix unx ; struct netns_ipv4 ipv4 ; struct netns_ipv6 ipv6 ; struct netns_sctp sctp ; struct netns_dccp dccp ; struct netns_xt xt ; struct netns_ct ct ; struct netns_nf_frag nf_frag ; struct sock * nfnl ; struct sock * nfnl_stash ; struct sk_buff_head wext_nlevents ; struct net_generic * gen ; struct netns_xfrm xfrm ; struct netns_ipvs * ipvs ; struct sock * diag_nlsk ; atomic_t rt_genid ; } ;
struct net ;
struct super_block ;
struct mm_struct ;
struct net ;
struct neighbour ;
struct mm_struct ;
struct neighbour ;
struct neighbour { struct neighbour * next ; struct neigh_table * tbl ; struct neigh_parms * parms ; unsigned long confirmed ; unsigned long updated ; rwlock_t lock ; atomic_t refcnt ; struct sk_buff_head arp_queue ; unsigned int arp_queue_len_bytes ; struct timer_list timer ; unsigned long used ; atomic_t probes ; __u8 flags ; __u8 nud_state ; __u8 type ; __u8 dead ; seqlock_t ha_lock ; unsigned char ha [ ( ( ( ( 32 ) ) + ( ( decltype ( ( 32 ) ) ) ( ( sizeof ( unsigned long ) ) ) - 1 ) ) & ~ ( ( decltype ( ( 32 ) ) ) ( ( sizeof ( unsigned long ) ) ) - 1 ) ) ] ; struct hh_cache hh ; int ( * output ) ( struct neighbour * , struct sk_buff * ) ; const struct neigh_ops * ops ; struct callback_head rcu ; struct net_device * dev ; u8 primary_key [ 0 ] ; } ;
typedef struct { spinlock_t slock ; int owned ; wait_queue_head_t wq ; } socket_lock_t ;
struct net ;
struct socket_alloc { struct socket socket ; struct inode vfs_inode ; } ;
struct net ;
typedef struct mempool_s { spinlock_t lock ; int min_nr ; int curr_nr ; void * * elements ; void * pool_data ; mempool_alloc_t * alloc ; mempool_free_t * free ; wait_queue_head_t wait ; } mempool_t ;
struct super_block ;
struct super_block ;
typedef struct pglist_data { struct zone node_zones [ 4 ] ; struct zonelist node_zonelists [ 2 ] ; int nr_zones ; spinlock_t node_size_lock ; unsigned long node_start_pfn ; unsigned long node_present_pages ; unsigned long node_spanned_pages ; int node_id ; nodemask_t reclaim_nodes ; wait_queue_head_t kswapd_wait ; wait_queue_head_t pfmemalloc_wait ; struct task_struct * kswapd ; int kswapd_max_order ; enum zone_type classzone_idx ; } pg_data_t ;
struct device ;
struct device ;
struct device ;
struct sock ;
struct sock ;
struct bio_set ;
struct device ;
struct device { struct device * parent ; struct device_private * p ; struct kobject kobj ; const char * init_name ; const struct device_type * type ; struct mutex mutex ; struct bus_type * bus ; struct device_driver * driver ; void * platform_data ; struct dev_pm_info power ; struct dev_pm_domain * pm_domain ; int numa_node ; u64 * dma_mask ; u64 coherent_dma_mask ; struct device_dma_parameters * dma_parms ; struct list_head dma_pools ; struct dma_coherent_mem * dma_mem ; struct dev_archdata archdata ; struct device_node * of_node ; struct acpi_dev_node acpi_node ; dev_t devt ; u32 id ; spinlock_t devres_lock ; struct list_head devres_head ; struct klist_node knode_class ; struct class_ * class_ ; const struct attribute_group * * groups ; void ( * release ) ( struct device * dev ) ; struct iommu_group * iommu_group ; } ;
struct device ;
struct device ;
struct device ;
struct device ;
struct device ;
struct device ;
struct sock ;
struct sock ;
struct sock ;
struct sock ;
struct sock ;
struct sock ;
struct sock ;
struct sock ;
struct device ;
struct device ;
struct sock ;
struct sock ;
struct sock ;
struct sock { struct sock_common __sk_common ; socket_lock_t sk_lock ; struct sk_buff_head sk_receive_queue ; struct { atomic_t rmem_alloc ; int len ; struct sk_buff * head ; struct sk_buff * tail ; } sk_backlog ; int sk_forward_alloc ; __u32 sk_rxhash ; atomic_t sk_drops ; int sk_rcvbuf ; struct sk_filter * sk_filter ; struct socket_wq * sk_wq ; struct sk_buff_head sk_async_wait_queue ; struct xfrm_policy * sk_policy [ 2 ] ; unsigned long sk_flags ; struct dst_entry * sk_rx_dst ; struct dst_entry * sk_dst_cache ; spinlock_t sk_dst_lock ; atomic_t sk_wmem_alloc ; atomic_t sk_omem_alloc ; int sk_sndbuf ; struct sk_buff_head sk_write_queue ; ; unsigned int sk_shutdown : 2 , sk_no_check : 2 , sk_userlocks : 4 , sk_protocol : 8 , sk_type : 16 ; ; int sk_wmem_queued ; gfp_t sk_allocation ; netdev_features_t sk_route_caps ; netdev_features_t sk_route_nocaps ; int sk_gso_type ; unsigned int sk_gso_max_size ; u16 sk_gso_max_segs ; int sk_rcvlowat ; unsigned long sk_lingertime ; struct sk_buff_head sk_error_queue ; struct proto * sk_prot_creator ; rwlock_t sk_callback_lock ; int sk_err , sk_err_soft ; unsigned short sk_ack_backlog ; unsigned short sk_max_ack_backlog ; __u32 sk_priority ; struct pid * sk_peer_pid ; const struct cred * sk_peer_cred ; long sk_rcvtimeo ; long sk_sndtimeo ; void * sk_protinfo ; struct timer_list sk_timer ; ktime_t sk_stamp ; struct socket * sk_socket ; void * sk_user_data ; struct page_frag sk_frag ; struct sk_buff * sk_send_head ; __s32 sk_peek_off ; int sk_write_pending ; __u32 sk_mark ; u32 sk_classid ; struct cg_proto * sk_cgrp ; void ( * sk_state_change ) ( struct sock * sk ) ; void ( * sk_data_ready ) ( struct sock * sk , int bytes ) ; void ( * sk_write_space ) ( struct sock * sk ) ; void ( * sk_error_report ) ( struct sock * sk ) ; int ( * sk_backlog_rcv ) ( struct sock * sk , struct sk_buff * skb ) ; void ( * sk_destruct ) ( struct sock * sk ) ; } ;
struct device ;
struct bio_set { struct kmem_cache * bio_slab ; unsigned int front_pad ; mempool_t * bio_pool ; mempool_t * bio_integrity_pool ; mempool_t * bvec_pool ; } ;
struct request_list { struct request_queue * q ; struct blkcg_gq * blkg ; int count [ 2 ] ; int starved [ 2 ] ; mempool_t * rq_pool ; wait_queue_head_t wait [ 2 ] ; unsigned int flags ; } ;
struct device ;
struct pci_dev ;
struct pci_bus ;
struct pci_dev ;
struct pci_dev ;
struct request_queue ;
struct pci_dev { struct list_head bus_list ; struct pci_bus * bus ; struct pci_bus * subordinate ; void * sysdata ; struct proc_dir_entry * procent ; struct pci_slot * slot ; unsigned int devfn ; unsigned short vendor ; unsigned short device ; unsigned short subsystem_vendor ; unsigned short subsystem_device ; unsigned int class_ ; u8 revision ; u8 hdr_type ; u8 pcie_cap ; u8 pcie_mpss : 3 ; u8 rom_base_reg ; u8 pin ; u16 pcie_flags_reg ; struct pci_driver * driver ; u64 dma_mask ; struct device_dma_parameters dma_parms ; pci_power_t current_state ; int pm_cap ; unsigned int pme_support : 5 ; unsigned int pme_interrupt : 1 ; unsigned int pme_poll : 1 ; unsigned int d1_support : 1 ; unsigned int d2_support : 1 ; unsigned int no_d1d2 : 1 ; unsigned int no_d3cold : 1 ; unsigned int d3cold_allowed : 1 ; unsigned int mmio_always_on : 1 ; unsigned int wakeup_prepared : 1 ; unsigned int runtime_d3cold : 1 ; unsigned int d3_delay ; unsigned int d3cold_delay ; struct pcie_link_state * link_state ; pci_channel_state_t error_state ; struct device dev ; int cfg_size ; unsigned int irq ; struct resource resource [ DEVICE_COUNT_RESOURCE ] ; unsigned int transparent : 1 ; unsigned int multifunction : 1 ; unsigned int is_added : 1 ; unsigned int is_busmaster : 1 ; unsigned int no_msi : 1 ; unsigned int block_cfg_access : 1 ; unsigned int broken_parity_status : 1 ; unsigned int irq_reroute_variant : 2 ; unsigned int msi_enabled : 1 ; unsigned int msix_enabled : 1 ; unsigned int ari_enabled : 1 ; unsigned int is_managed : 1 ; unsigned int is_pcie : 1 ; unsigned int needs_freset : 1 ; unsigned int state_saved : 1 ; unsigned int is_physfn : 1 ; unsigned int is_virtfn : 1 ; unsigned int reset_fn : 1 ; unsigned int is_hotplug_bridge : 1 ; unsigned int __aer_firmware_first_valid : 1 ; unsigned int __aer_firmware_first : 1 ; unsigned int broken_intx_masking : 1 ; unsigned int io_window_1k : 1 ; pci_dev_flags_t dev_flags ; atomic_t enable_cnt ; u32 saved_config_space [ 16 ] ; struct hlist_head saved_cap_space ; struct bin_attribute * rom_attr ; int rom_attr_enabled ; struct bin_attribute * res_attr [ DEVICE_COUNT_RESOURCE ] ; struct bin_attribute * res_attr_wc [ DEVICE_COUNT_RESOURCE ] ; struct list_head msi_list ; struct kset * msi_kset ; struct pci_vpd * vpd ; union { struct pci_sriov * sriov ; struct pci_dev * physfn ; } ; struct pci_ats * ats ; phys_addr_t rom ; size_t romlen ; } ;
struct pci_host_bridge { struct device dev ; struct pci_bus * bus ; struct list_head windows ; void ( * release_fn ) ( struct pci_host_bridge * ) ; void * release_data ; } ;
struct pci_bus { struct list_head node ; struct pci_bus * parent ; struct list_head children ; struct list_head devices ; struct pci_dev * self ; struct list_head slots ; struct resource * resource [ 4 ] ; struct list_head resources ; struct resource busn_res ; struct pci_ops * ops ; void * sysdata ; struct proc_dir_entry * procdir ; unsigned char number ; unsigned char primary ; unsigned char max_bus_speed ; unsigned char cur_bus_speed ; char name [ 48 ] ; unsigned short bridge_ctl ; pci_bus_flags_t bus_flags ; struct device * bridge ; struct device dev ; struct bin_attribute * legacy_io ; struct bin_attribute * legacy_mem ; unsigned int is_added : 1 ; } ;
struct dma_chan_dev { struct dma_chan * chan ; struct device device ; int dev_id ; atomic_t * idr_ref ; } ;
struct net_device ;
struct net_device ;
struct net_device ;
struct net_device ;
struct phy_device ;
struct net_device { char name [ 16 ] ; struct hlist_node name_hlist ; char * ifalias ; unsigned long mem_end ; unsigned long mem_start ; unsigned long base_addr ; unsigned int irq ; unsigned long state ; struct list_head dev_list ; struct list_head napi_list ; struct list_head unreg_list ; netdev_features_t features ; netdev_features_t hw_features ; netdev_features_t wanted_features ; netdev_features_t vlan_features ; netdev_features_t hw_enc_features ; int ifindex ; int iflink ; struct net_device_stats stats ; atomic_long_t rx_dropped ; const struct iw_handler_def * wireless_handlers ; struct iw_public_data * wireless_data ; const struct net_device_ops * netdev_ops ; const struct ethtool_ops * ethtool_ops ; const struct header_ops * header_ops ; unsigned int flags ; unsigned int priv_flags ; unsigned short gflags ; unsigned short padded ; unsigned char operstate ; unsigned char link_mode ; unsigned char if_port ; unsigned char dma ; unsigned int mtu ; unsigned short type ; unsigned short hard_header_len ; unsigned short needed_headroom ; unsigned short needed_tailroom ; unsigned char perm_addr [ 32 ] ; unsigned char addr_assign_type ; unsigned char addr_len ; unsigned char neigh_priv_len ; unsigned short dev_id ; spinlock_t addr_list_lock ; struct netdev_hw_addr_list uc ; struct netdev_hw_addr_list mc ; K_bool uc_promisc ; unsigned int promiscuity ; unsigned int allmulti ; struct vlan_info * vlan_info ; struct dsa_switch_tree * dsa_ptr ; void * atalk_ptr ; struct in_device * ip_ptr ; struct dn_dev * dn_ptr ; struct inet6_dev * ip6_ptr ; void * ax25_ptr ; struct wireless_dev * ieee80211_ptr ; unsigned long last_rx ; struct net_device * master ; unsigned char * dev_addr ; struct netdev_hw_addr_list dev_addrs ; unsigned char broadcast [ 32 ] ; struct kset * queues_kset ; struct netdev_rx_queue * _rx ; unsigned int num_rx_queues ; unsigned int real_num_rx_queues ; struct cpu_rmap * rx_cpu_rmap ; rx_handler_func_t * rx_handler ; void * rx_handler_data ; struct netdev_queue * ingress_queue ; struct netdev_queue * _tx __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; unsigned int num_tx_queues ; unsigned int real_num_tx_queues ; struct Qdisc * qdisc ; unsigned long tx_queue_len ; spinlock_t tx_global_lock ; struct xps_dev_maps * xps_maps ; unsigned long trans_start ; int watchdog_timeo ; struct timer_list watchdog_timer ; int * pcpu_refcnt ; struct list_head todo_list ; struct hlist_node index_hlist ; struct list_head link_watch_list ; enum { NETREG_UNINITIALIZED = 0 , NETREG_REGISTERED , NETREG_UNREGISTERING , NETREG_UNREGISTERED , NETREG_RELEASED , NETREG_DUMMY , } reg_state : 8 ; K_bool dismantle ; enum { RTNL_LINK_INITIALIZED , RTNL_LINK_INITIALIZING , } rtnl_link_state : 16 ; void ( * destructor ) ( struct net_device * dev ) ; struct netpoll_info * npinfo ; struct net * nd_net ; union { void * ml_priv ; struct pcpu_lstats * lstats ; struct pcpu_tstats * tstats ; struct pcpu_dstats * dstats ; } ; struct garp_port * garp_port ; struct device dev ; const struct attribute_group * sysfs_groups [ 4 ] ; const struct rtnl_link_ops * rtnl_link_ops ; unsigned int gso_max_size ; u16 gso_max_segs ; const struct dcbnl_rtnl_ops * dcbnl_ops ; u8 num_tc ; struct netdev_tc_txq tc_to_txq [ 16 ] ; u8 prio_tc_map [ 15 + 1 ] ; unsigned int fcoe_ddp_xid ; struct phy_device * phydev ; struct lock_class_key * qdisc_tx_busylock ; int group ; struct pm_qos_request pm_qos_req ; } ;
struct inet_sock { struct sock sk ; struct ipv6_pinfo * pinet6 ; __be32 inet_saddr ; __s16 uc_ttl ; __u16 cmsg_flags ; __be16 inet_sport ; __u16 inet_id ; struct ip_options_rcu * inet_opt ; int rx_dst_ifindex ; __u8 tos ; __u8 min_ttl ; __u8 mc_ttl ; __u8 pmtudisc ; __u8 recverr : 1 , is_icsk : 1 , freebind : 1 , hdrincl : 1 , mc_loop : 1 , transparent : 1 , mc_all : 1 , nodefrag : 1 ; __u8 rcv_tos ; int uc_index ; int mc_index ; __be32 mc_addr ; struct ip_mc_socklist * mc_list ; struct inet_cork_full cork ; } ;
struct hd_struct { sector_t start_sect ; sector_t nr_sects ; seqcount_t nr_sects_seq ; sector_t alignment_offset ; unsigned int discard_alignment ; struct device __dev ; struct kobject * holder_dir ; int policy , partno ; struct partition_meta_info * info ; unsigned long stamp ; atomic_t in_flight [ 2 ] ; struct disk_stats * dkstats ; atomic_t ref ; struct callback_head callback_head ; } ;
struct request_queue ;
struct request_queue ;
struct request_queue { struct list_head queue_head ; struct request * last_merge ; struct elevator_queue * elevator ; int nr_rqs [ 2 ] ; int nr_rqs_elvpriv ; struct request_list root_rl ; request_fn_proc * request_fn ; make_request_fn * make_request_fn ; prep_rq_fn * prep_rq_fn ; unprep_rq_fn * unprep_rq_fn ; merge_bvec_fn * merge_bvec_fn ; softirq_done_fn * softirq_done_fn ; rq_timed_out_fn * rq_timed_out_fn ; dma_drain_needed_fn * dma_drain_needed ; lld_busy_fn * lld_busy_fn ; sector_t end_sector ; struct request * boundary_rq ; struct delayed_work delay_work ; struct backing_dev_info backing_dev_info ; void * queuedata ; unsigned long queue_flags ; int id ; gfp_t bounce_gfp ; spinlock_t __queue_lock ; spinlock_t * queue_lock ; struct kobject kobj ; unsigned long nr_requests ; unsigned int nr_congestion_on ; unsigned int nr_congestion_off ; unsigned int nr_batching ; unsigned int dma_drain_size ; void * dma_drain_buffer ; unsigned int dma_pad_mask ; unsigned int dma_alignment ; struct blk_queue_tag * queue_tags ; struct list_head tag_busy_list ; unsigned int nr_sorted ; unsigned int in_flight [ 2 ] ; unsigned int request_fn_active ; unsigned int rq_timeout ; struct timer_list timeout ; struct list_head timeout_list ; struct list_head icq_list ; unsigned long blkcg_pols [ ( ( ( 2 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; struct blkcg_gq * root_blkg ; struct list_head blkg_list ; struct queue_limits limits ; unsigned int sg_timeout ; unsigned int sg_reserved_size ; int node ; struct blk_trace * blk_trace ; unsigned int flush_flags ; unsigned int flush_not_queueable : 1 ; unsigned int flush_queue_delayed : 1 ; unsigned int flush_pending_idx : 1 ; unsigned int flush_running_idx : 1 ; unsigned long flush_pending_since ; struct list_head flush_queue [ 2 ] ; struct list_head flush_data_in_flight ; struct request flush_rq ; struct mutex sysfs_lock ; int bypass_depth ; bsg_job_fn * bsg_job_fn ; int bsg_job_size ; struct bsg_class_device bsg_dev ; struct list_head all_q_node ; struct throtl_data * td ; } ;
struct node { struct device dev ; struct work_struct node_work ; } ;
struct request_queue ;
struct Scsi_Host ;
struct Scsi_Host { struct list_head __devices ; struct list_head __targets ; struct scsi_host_cmd_pool * cmd_pool ; spinlock_t free_list_lock ; struct list_head free_list ; struct list_head starved_list ; spinlock_t default_lock ; spinlock_t * host_lock ; struct mutex scan_mutex ; struct list_head eh_cmd_q ; struct task_struct * ehandler ; struct completion * eh_action ; wait_queue_head_t host_wait ; struct scsi_host_template * hostt ; struct scsi_transport_template * transportt ; struct blk_queue_tag * bqt ; unsigned int host_busy ; unsigned int host_failed ; unsigned int host_eh_scheduled ; unsigned int host_no ; int resetting ; unsigned long last_reset ; unsigned int max_id ; unsigned int max_lun ; unsigned int max_channel ; unsigned int unique_id ; unsigned short max_cmd_len ; int this_id ; int can_queue ; short cmd_per_lun ; short unsigned int sg_tablesize ; short unsigned int sg_prot_tablesize ; short unsigned int max_sectors ; unsigned long dma_boundary ; unsigned long cmd_serial_number ; unsigned active_mode : 2 ; unsigned unchecked_isa_dma : 1 ; unsigned use_clustering : 1 ; unsigned use_blk_tcq : 1 ; unsigned host_self_blocked : 1 ; unsigned reverse_ordering : 1 ; unsigned ordered_tag : 1 ; unsigned tmf_in_progress : 1 ; unsigned async_scan : 1 ; unsigned eh_noresume : 1 ; char work_q_name [ 20 ] ; struct workqueue_struct * work_q ; unsigned int host_blocked ; unsigned int max_host_blocked ; unsigned int prot_capabilities ; unsigned char prot_guard_type ; struct request_queue * uspace_req_q ; unsigned long base ; unsigned long io_port ; unsigned char n_io_port ; unsigned char dma_channel ; unsigned int irq ; enum scsi_host_state shost_state ; struct device shost_gendev , shost_dev ; struct list_head sht_legacy_list ; void * shost_data ; struct device * dma_dev ; unsigned long hostdata [ 0 ] __attribute__ ( ( aligned ( sizeof ( unsigned long ) ) ) ) ; } ;
struct acpi_device ;
struct acpi_device { int device_type ; acpi_handle handle ; struct acpi_device * parent ; struct list_head children ; struct list_head node ; struct list_head wakeup_list ; struct acpi_device_status status ; struct acpi_device_flags flags ; struct acpi_device_pnp pnp ; struct acpi_device_power power ; struct acpi_device_wakeup wakeup ; struct acpi_device_perf performance ; struct acpi_device_dir dir ; struct acpi_device_ops ops ; struct acpi_driver * driver ; void * driver_data ; struct device dev ; struct acpi_bus_ops bus_ops ; enum acpi_bus_removal_type removal_type ; u8 physical_node_count ; struct list_head physical_node_list ; struct mutex physical_node_lock ; unsigned long physical_node_id_bitmap [ ( ( ( 32 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;
struct pci_bus ;
struct pci_dev ;
struct ata_device { struct ata_link * link ; unsigned int devno ; unsigned int horkage ; unsigned long flags ; struct scsi_device * sdev ; void * private_data ; union acpi_object * gtf_cache ; unsigned int gtf_filter ; struct device tdev ; u64 n_sectors ; u64 n_native_sectors ; unsigned int class_ ; unsigned long unpark_deadline ; u8 pio_mode ; u8 dma_mode ; u8 xfer_mode ; unsigned int xfer_shift ; unsigned int multi_count ; unsigned int max_sectors ; unsigned int cdb_len ; unsigned long pio_mask ; unsigned long mwdma_mask ; unsigned long udma_mask ; u16 cylinders ; u16 heads ; u16 sectors ; union { u16 id [ ATA_ID_WORDS ] ; u32 gscr [ SATA_PMP_GSCR_DWORDS ] ; } ; u8 devslp_timing [ ATA_LOG_DEVSLP_SIZE ] ; int spdn_cnt ; struct ata_ering ering ; } ;
struct pci_dev ;
struct input_dev { const char * name ; const char * phys ; const char * uniq ; struct input_id id ; unsigned long propbit [ ( ( ( ( 0x1f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long evbit [ ( ( ( ( 0x1f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long keybit [ ( ( ( ( 0x2ff + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long relbit [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long absbit [ ( ( ( ( 0x3f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long mscbit [ ( ( ( ( 0x07 + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long ledbit [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long sndbit [ ( ( ( ( 0x07 + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long ffbit [ ( ( ( ( 0x7f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long swbit [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned int hint_events_per_packet ; unsigned int keycodemax ; unsigned int keycodesize ; void * keycode ; int ( * setkeycode ) ( struct input_dev * dev , const struct input_keymap_entry * ke , unsigned int * old_keycode ) ; int ( * getkeycode ) ( struct input_dev * dev , struct input_keymap_entry * ke ) ; struct ff_device * ff ; unsigned int repeat_key ; struct timer_list timer ; int rep [ ( 0x01 + 1 ) ] ; struct input_mt * mt ; struct input_absinfo * absinfo ; unsigned long key [ ( ( ( ( 0x2ff + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long led [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long snd [ ( ( ( ( 0x07 + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long sw [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; int ( * open ) ( struct input_dev * dev ) ; void ( * close ) ( struct input_dev * dev ) ; int ( * flush ) ( struct input_dev * dev , struct file * file ) ; int ( * event ) ( struct input_dev * dev , unsigned int type , unsigned int code , int value ) ; struct input_handle * grab ; spinlock_t event_lock ; struct mutex mutex ; unsigned int users ; K_bool going_away ; struct device dev ; struct list_head h_list ; struct list_head node ; unsigned int num_vals ; unsigned int max_vals ; struct input_value * vals ; K_bool devres_managed ; } ;
struct pnp_protocol ;
struct pnp_dev ;
struct pnp_card { struct device dev ; unsigned char number ; struct list_head global_list ; struct list_head protocol_list ; struct list_head devices ; struct pnp_protocol * protocol ; struct pnp_id * id ; char name [ 50 ] ; unsigned char pnpver ; unsigned char productver ; unsigned int serial ; unsigned char checksum ; struct proc_dir_entry * procdir ; } ;
struct pnp_dev { struct device dev ; u64 dma_mask ; unsigned int number ; int status ; struct list_head global_list ; struct list_head protocol_list ; struct list_head card_list ; struct list_head rdev_list ; struct pnp_protocol * protocol ; struct pnp_card * card ; struct pnp_driver * driver ; struct pnp_card_link * card_link ; struct pnp_id * id ; int active ; int capabilities ; unsigned int num_dependent_sets ; struct list_head resources ; struct list_head options ; char name [ 50 ] ; int flags ; struct proc_dir_entry * procent ; void * data ; } ;
struct pnp_protocol { struct list_head protocol_list ; char * name ; int ( * get ) ( struct pnp_dev * dev ) ; int ( * set ) ( struct pnp_dev * dev ) ; int ( * disable ) ( struct pnp_dev * dev ) ; K_bool ( * can_wakeup ) ( struct pnp_dev * dev ) ; int ( * suspend ) ( struct pnp_dev * dev , pm_message_t state ) ; int ( * resume ) ( struct pnp_dev * dev ) ; unsigned char number ; struct device dev ; struct list_head cards ; struct list_head devices ; } ;
struct mii_bus { const char * name ; char id [ ( 20 - 3 ) ] ; void * priv ; int ( * read ) ( struct mii_bus * bus , int phy_id , int regnum ) ; int ( * write ) ( struct mii_bus * bus , int phy_id , int regnum , u16 val ) ; int ( * reset ) ( struct mii_bus * bus ) ; struct mutex mdio_lock ; struct device * parent ; enum { MDIOBUS_ALLOCATED = 1 , MDIOBUS_REGISTERED , MDIOBUS_UNREGISTERED , MDIOBUS_RELEASED , } state ; struct device dev ; struct phy_device * phy_map [ 32 ] ; u32 phy_mask ; int * irq ; } ;
struct phy_device { struct phy_driver * drv ; struct mii_bus * bus ; struct device dev ; u32 phy_id ; struct phy_c45_device_ids c45_ids ; K_bool is_c45 ; enum phy_state state ; u32 dev_flags ; phy_interface_t interface ; int addr ; int speed ; int duplex ; int pause ; int asym_pause ; int link ; u32 interrupts ; u32 supported ; u32 advertising ; int autoneg ; int link_timeout ; int irq ; void * priv ; struct work_struct phy_queue ; struct delayed_work state_queue ; atomic_t irq_disable ; struct mutex lock ; struct net_device * attached_dev ; void ( * adjust_link ) ( struct net_device * dev ) ; void ( * adjust_state ) ( struct net_device * dev ) ; } ;
struct inet_connection_sock { struct inet_sock icsk_inet ; struct request_sock_queue icsk_accept_queue ; struct inet_bind_bucket * icsk_bind_hash ; unsigned long icsk_timeout ; struct timer_list icsk_retransmit_timer ; struct timer_list icsk_delack_timer ; __u32 icsk_rto ; __u32 icsk_pmtu_cookie ; const struct tcp_congestion_ops * icsk_ca_ops ; const struct inet_connection_sock_af_ops * icsk_af_ops ; unsigned int ( * icsk_sync_mss ) ( struct sock * sk , u32 pmtu ) ; __u8 icsk_ca_state ; __u8 icsk_retransmits ; __u8 icsk_pending ; __u8 icsk_backoff ; __u8 icsk_syn_retries ; __u8 icsk_probes_out ; __u16 icsk_ext_hdr_len ; struct { __u8 pending ; __u8 quick ; __u8 pingpong ; __u8 blocked ; __u32 ato ; unsigned long timeout ; __u32 lrcvtime ; __u16 last_seg_size ; __u16 rcv_mss ; } icsk_ack ; struct { int enabled ; int search_high ; int search_low ; int probe_size ; } icsk_mtup ; u32 icsk_ca_priv [ 16 ] ; u32 icsk_user_timeout ; } ;
struct udp_sock { struct inet_sock inet ; int pending ; unsigned int corkflag ; __u16 encap_type ; __u16 len ; __u16 pcslen ; __u16 pcrlen ; __u8 pcflag ; __u8 unused [ 3 ] ; int ( * encap_rcv ) ( struct sock * sk , struct sk_buff * skb ) ; } ;
struct raw6_sock { struct inet_sock inet ; __u32 checksum ; __u32 offset ; struct icmp6_filter filter ; __u32 ip6mr_table ; struct ipv6_pinfo inet6 ; } ;
struct gendisk { int major ; int first_minor ; int minors ; char disk_name [ 32 ] ; char * ( * devnode ) ( struct gendisk * gd , umode_t * mode ) ; unsigned int events ; unsigned int async_events ; struct disk_part_tbl * part_tbl ; struct hd_struct part0 ; const struct block_device_operations * fops ; struct request_queue * queue ; void * private_data ; int flags ; struct device * driverfs_dev ; struct kobject * slave_dir ; struct timer_rand_state * random ; atomic_t sync_io ; struct disk_events * ev ; struct blk_integrity * integrity ; int node_id ; } ;
struct ata_link ;
struct ata_link { struct ata_port * ap ; int pmp ; struct device tdev ; unsigned int active_tag ; u32 sactive ; unsigned int flags ; u32 saved_scontrol ; unsigned int hw_sata_spd_limit ; unsigned int sata_spd_limit ; unsigned int sata_spd ; enum ata_lpm_policy lpm_policy ; struct ata_eh_info eh_info ; struct ata_eh_context eh_context ; struct ata_device device [ ATA_MAX_DEVICES ] ; } ;
struct tcp_sock { struct inet_connection_sock inet_conn ; u16 tcp_header_len ; u16 xmit_size_goal_segs ; __be32 pred_flags ; u32 rcv_nxt ; u32 copied_seq ; u32 rcv_wup ; u32 snd_nxt ; u32 snd_una ; u32 snd_sml ; u32 rcv_tstamp ; u32 lsndtime ; struct list_head tsq_node ; unsigned long tsq_flags ; struct { struct sk_buff_head prequeue ; struct task_struct * task ; struct iovec * iov ; int memory ; int len ; struct dma_chan * dma_chan ; int wakeup ; struct dma_pinned_list * pinned_list ; dma_cookie_t dma_cookie ; } ucopy ; u32 snd_wl1 ; u32 snd_wnd ; u32 max_window ; u32 mss_cache ; u32 window_clamp ; u32 rcv_ssthresh ; u32 frto_highmark ; u16 advmss ; u8 frto_counter ; u8 nonagle : 4 , thin_lto : 1 , thin_dupack : 1 , repair : 1 , unused : 1 ; u8 repair_queue ; u8 do_early_retrans : 1 , early_retrans_delayed : 1 , syn_data : 1 , syn_fastopen : 1 , syn_data_acked : 1 ; u32 srtt ; u32 mdev ; u32 mdev_max ; u32 rttvar ; u32 rtt_seq ; u32 packets_out ; u32 retrans_out ; u16 urg_data ; u8 ecn_flags ; u8 reordering ; u32 snd_up ; u8 keepalive_probes ; struct tcp_options_received rx_opt ; u32 snd_ssthresh ; u32 snd_cwnd ; u32 snd_cwnd_cnt ; u32 snd_cwnd_clamp ; u32 snd_cwnd_used ; u32 snd_cwnd_stamp ; u32 prior_cwnd ; u32 prr_delivered ; u32 prr_out ; u32 rcv_wnd ; u32 write_seq ; u32 pushed_seq ; u32 lost_out ; u32 sacked_out ; u32 fackets_out ; u32 tso_deferred ; u32 bytes_acked ; struct sk_buff * lost_skb_hint ; struct sk_buff * scoreboard_skb_hint ; struct sk_buff * retransmit_skb_hint ; struct sk_buff_head out_of_order_queue ; struct tcp_sack_block duplicate_sack [ 1 ] ; struct tcp_sack_block selective_acks [ 4 ] ; struct tcp_sack_block recv_sack_cache [ 4 ] ; struct sk_buff * highest_sack ; int lost_cnt_hint ; u32 retransmit_high ; u32 lost_retrans_low ; u32 prior_ssthresh ; u32 high_seq ; u32 retrans_stamp ; u32 undo_marker ; int undo_retrans ; u32 total_retrans ; u32 urg_seq ; unsigned int keepalive_time ; unsigned int keepalive_intvl ; int linger2 ; struct { u32 rtt ; u32 seq ; u32 time ; } rcv_rtt_est ; struct { int space ; u32 seq ; u32 time ; } rcvq_space ; struct { u32 probe_seq_start ; u32 probe_seq_end ; } mtu_probe ; u32 mtu_info ; const struct tcp_sock_af_ops * af_specific ; struct tcp_md5sig_info * md5sig_info ; struct tcp_cookie_values * cookie_values ; struct tcp_fastopen_request * fastopen_req ; struct request_sock * fastopen_rsk ; } ;
struct udp6_sock { struct udp_sock udp ; struct ipv6_pinfo inet6 ; } ;
struct ata_port ;
struct ata_port { struct Scsi_Host * scsi_host ; struct ata_port_operations * ops ; spinlock_t * lock ; unsigned long flags ; unsigned int pflags ; unsigned int print_id ; unsigned int port_no ; struct ata_ioports ioaddr ; u8 ctl ; u8 last_ctl ; struct ata_link * sff_pio_task_link ; struct delayed_work sff_pio_task ; struct ata_bmdma_prd * bmdma_prd ; dma_addr_t bmdma_prd_dma ; unsigned int pio_mask ; unsigned int mwdma_mask ; unsigned int udma_mask ; unsigned int cbl ; struct ata_queued_cmd qcmd [ ATA_MAX_QUEUE ] ; unsigned long qc_allocated ; unsigned int qc_active ; int nr_active_links ; struct ata_link link ; struct ata_link * slave_link ; int nr_pmp_links ; struct ata_link * pmp_link ; struct ata_link * excl_link ; struct ata_port_stats stats ; struct ata_host * host ; struct device * dev ; struct device tdev ; struct mutex scsi_scan_mutex ; struct delayed_work hotplug_task ; struct work_struct scsi_rescan_task ; unsigned int hsm_task_state ; u32 msg_enable ; struct list_head eh_done_q ; wait_queue_head_t eh_wait_q ; int eh_tries ; struct completion park_req_pending ; pm_message_t pm_mesg ; int * pm_result ; enum ata_lpm_policy target_lpm_policy ; struct timer_list fastdrain_timer ; unsigned long fastdrain_cnt ; int em_message_type ; void * private_data ; struct ata_acpi_gtm __acpi_init_gtm ; u8 sector_buf [ ATA_SECT_SIZE ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; } ;
struct tcp6_sock { struct tcp_sock tcp ; struct ipv6_pinfo inet6 ; } ;
