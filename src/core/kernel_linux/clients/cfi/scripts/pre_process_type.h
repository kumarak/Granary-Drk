# 1 "type_decl_for_qemu.h"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "type_decl_for_qemu.h"

typedef unsigned char __u_char ;


typedef unsigned short int __u_short ;

typedef unsigned int __u_int ;

typedef unsigned long int __u_long ;

typedef signed char __int8_t ;

typedef unsigned char __uint8_t ;

typedef signed short int __int16_t ;

typedef unsigned short int __uint16_t ;

typedef signed int __int32_t ;

typedef unsigned int __uint32_t ;

typedef signed long int __int64_t ;

typedef unsigned long int __uint64_t ;

typedef long int __quad_t ;

typedef unsigned long int __u_quad_t ;

typedef unsigned long int __dev_t ;

typedef unsigned int __uid_t ;

typedef unsigned int __gid_t ;

typedef unsigned long int __ino_t ;

typedef unsigned long int __ino64_t ;

typedef unsigned int __mode_t ;

typedef unsigned long int __nlink_t ;

typedef long int __off_t ;

typedef long int __off64_t ;

typedef int __pid_t ;

typedef struct { int __val [ 2 ] ; } __fsid_t ;

typedef long int __clock_t ;

typedef unsigned long int __rlim_t ;

typedef unsigned long int __rlim64_t ;

typedef unsigned int __id_t ;

typedef long int __time_t ;

typedef unsigned int __useconds_t ;

typedef long int __suseconds_t ;

typedef int __daddr_t ;

typedef long int __swblk_t ;

typedef int __key_t ;

typedef int __clockid_t ;

typedef void * __timer_t ;

typedef long int __blksize_t ;

typedef long int __blkcnt_t ;

typedef long int __blkcnt64_t ;

typedef unsigned long int __fsblkcnt_t ;

typedef unsigned long int __fsblkcnt64_t ;

typedef unsigned long int __fsfilcnt_t ;

typedef unsigned long int __fsfilcnt64_t ;

typedef long int __ssize_t ;

typedef __off64_t __loff_t ;

typedef __quad_t * __qaddr_t ;

typedef char * __caddr_t ;

typedef long int __intptr_t ;

typedef unsigned int __socklen_t ;

typedef __u_char u_char ;

typedef __u_short u_short ;

typedef __u_int u_int ;

typedef __u_long u_long ;

typedef __quad_t quad_t ;

typedef __u_quad_t u_quad_t ;

typedef __fsid_t fsid_t ;

typedef __loff_t loff_t ;

typedef __ino_t ino_t ;

typedef __dev_t dev_t ;

typedef __gid_t gid_t ;

typedef __mode_t mode_t ;

typedef __nlink_t nlink_t ;

typedef __uid_t uid_t ;

typedef __off_t off_t ;

typedef __pid_t pid_t ;

typedef __id_t id_t ;

typedef __ssize_t ssize_t ;

typedef __daddr_t daddr_t ;

typedef __caddr_t caddr_t ;

typedef __key_t key_t ;

typedef __time_t time_t ;

typedef __clockid_t clockid_t ;

typedef __timer_t timer_t ;

typedef long unsigned int size_t ;

typedef unsigned long int ulong ;

typedef unsigned short int ushort ;

typedef unsigned int uint ;

typedef int int8_t __attribute__ ( ( __mode__ ( __QI__ ) ) ) ;

typedef int int16_t __attribute__ ( ( __mode__ ( __HI__ ) ) ) ;

typedef int int32_t __attribute__ ( ( __mode__ ( __SI__ ) ) ) ;

typedef int int64_t __attribute__ ( ( __mode__ ( __DI__ ) ) ) ;

typedef unsigned int u_int8_t __attribute__ ( ( __mode__ ( __QI__ ) ) ) ;

typedef unsigned int u_int16_t __attribute__ ( ( __mode__ ( __HI__ ) ) ) ;

typedef unsigned int u_int32_t __attribute__ ( ( __mode__ ( __SI__ ) ) ) ;

typedef unsigned int u_int64_t __attribute__ ( ( __mode__ ( __DI__ ) ) ) ;

typedef int register_t __attribute__ ( ( __mode__ ( __word__ ) ) ) ;

typedef int __sig_atomic_t ;

typedef struct { unsigned long int __val [ ( 1024 / ( 8 * sizeof ( unsigned long int ) ) ) ] ; } __sigset_t ;

typedef __sigset_t sigset_t ;


struct timespec { __time_t tv_sec ; long int tv_nsec ; } ;

struct timeval { __time_t tv_sec ; __suseconds_t tv_usec ; } ;

typedef __suseconds_t suseconds_t ;

typedef long int __fd_mask ;

typedef struct { __fd_mask __fds_bits [ 1024 / ( 8 * ( int ) sizeof ( __fd_mask ) ) ] ; } fd_set ;

typedef __fd_mask fd_mask ;

typedef __blkcnt_t blkcnt_t ;

typedef __fsblkcnt_t fsblkcnt_t ;

typedef __fsfilcnt_t fsfilcnt_t ;

typedef unsigned long int pthread_t ;

typedef union { char __size [ 56 ] ; long int __align ; } pthread_attr_t ;


typedef struct __pthread_internal_list { struct __pthread_internal_list * __prev ; struct __pthread_internal_list * __next ; } __pthread_list_t ;

typedef union { struct __pthread_mutex_s { int __lock ; unsigned int __count ; int __owner ; unsigned int __nusers ; int __kind ; int __spins ; __pthread_list_t __list ; } __data ; char __size [ 40 ] ; long int __align ; } pthread_mutex_t ;

typedef union { char __size [ 4 ] ; int __align ; } pthread_mutexattr_t ;

typedef union { struct { int __lock ; unsigned int __futex ; __extension__ unsigned long long int __total_seq ; __extension__ unsigned long long int __wakeup_seq ; __extension__ unsigned long long int __woken_seq ; void * __mutex ; unsigned int __nwaiters ; unsigned int __broadcast_seq ; } __data ; char __size [ 48 ] ; __extension__ long long int __align ; } pthread_cond_t ;

typedef union { char __size [ 4 ] ; int __align ; } pthread_condattr_t ;

typedef unsigned int pthread_key_t ;

typedef int pthread_once_t ;

typedef union { struct { int __lock ; unsigned int __nr_readers ; unsigned int __readers_wakeup ; unsigned int __writer_wakeup ; unsigned int __nr_readers_queued ; unsigned int __nr_writers_queued ; int __writer ; int __shared ; unsigned long int __pad1 ; unsigned long int __pad2 ; unsigned int __flags ; } __data ; char __size [ 56 ] ; long int __align ; } pthread_rwlock_t ;

typedef union { char __size [ 8 ] ; long int __align ; } pthread_rwlockattr_t ;

typedef volatile int pthread_spinlock_t ;

typedef union { char __size [ 32 ] ; long int __align ; } pthread_barrier_t ;

typedef union { char __size [ 4 ] ; int __align ; } pthread_barrierattr_t ;

struct stat { __dev_t st_dev ; __ino_t st_ino ; __nlink_t st_nlink ; __mode_t st_mode ; __uid_t st_uid ; __gid_t st_gid ; int __pad0 ; __dev_t st_rdev ; __off_t st_size ; __blksize_t st_blksize ; __blkcnt_t st_blocks ; struct timespec st_atim ; struct timespec st_mtim ; struct timespec st_ctim ; long int __unused [ 3 ] ; } ;

typedef __useconds_t useconds_t ;

typedef __intptr_t intptr_t ;

typedef __socklen_t socklen_t ;


enum { _PC_LINK_MAX , _PC_MAX_CANON , _PC_MAX_INPUT , _PC_NAME_MAX , _PC_PATH_MAX , _PC_PIPE_BUF , _PC_CHOWN_RESTRICTED , _PC_NO_TRUNC , _PC_VDISABLE , _PC_SYNC_IO , _PC_ASYNC_IO , _PC_PRIO_IO , _PC_SOCK_MAXBUF , _PC_FILESIZEBITS , _PC_REC_INCR_XFER_SIZE , _PC_REC_MAX_XFER_SIZE , _PC_REC_MIN_XFER_SIZE , _PC_REC_XFER_ALIGN , _PC_ALLOC_SIZE_MIN , _PC_SYMLINK_MAX , _PC_2_SYMLINKS } ;
enum { _SC_ARG_MAX , _SC_CHILD_MAX , _SC_CLK_TCK , _SC_NGROUPS_MAX , _SC_OPEN_MAX , _SC_STREAM_MAX , _SC_TZNAME_MAX , _SC_JOB_CONTROL , _SC_SAVED_IDS , _SC_REALTIME_SIGNALS , _SC_PRIORITY_SCHEDULING , _SC_TIMERS , _SC_ASYNCHRONOUS_IO , _SC_PRIORITIZED_IO , _SC_SYNCHRONIZED_IO , _SC_FSYNC , _SC_MAPPED_FILES , _SC_MEMLOCK , _SC_MEMLOCK_RANGE , _SC_MEMORY_PROTECTION , _SC_MESSAGE_PASSING , _SC_SEMAPHORES , _SC_SHARED_MEMORY_OBJECTS , _SC_AIO_LISTIO_MAX , _SC_AIO_MAX , _SC_AIO_PRIO_DELTA_MAX , _SC_DELAYTIMER_MAX , _SC_MQ_OPEN_MAX , _SC_MQ_PRIO_MAX , _SC_VERSION , _SC_PAGESIZE , _SC_RTSIG_MAX , _SC_SEM_NSEMS_MAX , _SC_SEM_VALUE_MAX , _SC_SIGQUEUE_MAX , _SC_TIMER_MAX , _SC_BC_BASE_MAX , _SC_BC_DIM_MAX , _SC_BC_SCALE_MAX , _SC_BC_STRING_MAX , _SC_COLL_WEIGHTS_MAX , _SC_EQUIV_CLASS_MAX , _SC_EXPR_NEST_MAX , _SC_LINE_MAX , _SC_RE_DUP_MAX , _SC_CHARCLASS_NAME_MAX , _SC_2_VERSION , _SC_2_C_BIND , _SC_2_C_DEV , _SC_2_FORT_DEV , _SC_2_FORT_RUN , _SC_2_SW_DEV , _SC_2_LOCALEDEF , _SC_PII , _SC_PII_XTI , _SC_PII_SOCKET , _SC_PII_INTERNET , _SC_PII_OSI , _SC_POLL , _SC_SELECT , _SC_UIO_MAXIOV , _SC_IOV_MAX = _SC_UIO_MAXIOV , _SC_PII_INTERNET_STREAM , _SC_PII_INTERNET_DGRAM , _SC_PII_OSI_COTS , _SC_PII_OSI_CLTS , _SC_PII_OSI_M , _SC_T_IOV_MAX , _SC_THREADS , _SC_THREAD_SAFE_FUNCTIONS , _SC_GETGR_R_SIZE_MAX , _SC_GETPW_R_SIZE_MAX , _SC_LOGIN_NAME_MAX , _SC_TTY_NAME_MAX , _SC_THREAD_DESTRUCTOR_ITERATIONS , _SC_THREAD_KEYS_MAX , _SC_THREAD_STACK_MIN , _SC_THREAD_THREADS_MAX , _SC_THREAD_ATTR_STACKADDR , _SC_THREAD_ATTR_STACKSIZE , _SC_THREAD_PRIORITY_SCHEDULING , _SC_THREAD_PRIO_INHERIT , _SC_THREAD_PRIO_PROTECT , _SC_THREAD_PROCESS_SHARED , _SC_NPROCESSORS_CONF , _SC_NPROCESSORS_ONLN , _SC_PHYS_PAGES , _SC_AVPHYS_PAGES , _SC_ATEXIT_MAX , _SC_PASS_MAX , _SC_XOPEN_VERSION , _SC_XOPEN_XCU_VERSION , _SC_XOPEN_UNIX , _SC_XOPEN_CRYPT , _SC_XOPEN_ENH_I18N , _SC_XOPEN_SHM , _SC_2_CHAR_TERM , _SC_2_C_VERSION , _SC_2_UPE , _SC_XOPEN_XPG2 , _SC_XOPEN_XPG3 , _SC_XOPEN_XPG4 , _SC_CHAR_BIT , _SC_CHAR_MAX , _SC_CHAR_MIN , _SC_INT_MAX , _SC_INT_MIN , _SC_LONG_BIT , _SC_WORD_BIT , _SC_MB_LEN_MAX , _SC_NZERO , _SC_SSIZE_MAX , _SC_SCHAR_MAX , _SC_SCHAR_MIN , _SC_SHRT_MAX , _SC_SHRT_MIN , _SC_UCHAR_MAX , _SC_UINT_MAX , _SC_ULONG_MAX , _SC_USHRT_MAX , _SC_NL_ARGMAX , _SC_NL_LANGMAX , _SC_NL_MSGMAX , _SC_NL_NMAX , _SC_NL_SETMAX , _SC_NL_TEXTMAX , _SC_XBS5_ILP32_OFF32 , _SC_XBS5_ILP32_OFFBIG , _SC_XBS5_LP64_OFF64 , _SC_XBS5_LPBIG_OFFBIG , _SC_XOPEN_LEGACY , _SC_XOPEN_REALTIME , _SC_XOPEN_REALTIME_THREADS , _SC_ADVISORY_INFO , _SC_BARRIERS , _SC_BASE , _SC_C_LANG_SUPPORT , _SC_C_LANG_SUPPORT_R , _SC_CLOCK_SELECTION , _SC_CPUTIME , _SC_THREAD_CPUTIME , _SC_DEVICE_IO , _SC_DEVICE_SPECIFIC , _SC_DEVICE_SPECIFIC_R , _SC_FD_MGMT , _SC_FIFO , _SC_PIPE , _SC_FILE_ATTRIBUTES , _SC_FILE_LOCKING , _SC_FILE_SYSTEM , _SC_MONOTONIC_CLOCK , _SC_MULTI_PROCESS , _SC_SINGLE_PROCESS , _SC_NETWORKING , _SC_READER_WRITER_LOCKS , _SC_SPIN_LOCKS , _SC_REGEXP , _SC_REGEX_VERSION , _SC_SHELL , _SC_SIGNALS , _SC_SPAWN , _SC_SPORADIC_SERVER , _SC_THREAD_SPORADIC_SERVER , _SC_SYSTEM_DATABASE , _SC_SYSTEM_DATABASE_R , _SC_TIMEOUTS , _SC_TYPED_MEMORY_OBJECTS , _SC_USER_GROUPS , _SC_USER_GROUPS_R , _SC_2_PBS , _SC_2_PBS_ACCOUNTING , _SC_2_PBS_LOCATE , _SC_2_PBS_MESSAGE , _SC_2_PBS_TRACK , _SC_SYMLOOP_MAX , _SC_STREAMS , _SC_2_PBS_CHECKPOINT , _SC_V6_ILP32_OFF32 , _SC_V6_ILP32_OFFBIG , _SC_V6_LP64_OFF64 , _SC_V6_LPBIG_OFFBIG , _SC_HOST_NAME_MAX , _SC_TRACE , _SC_TRACE_EVENT_FILTER , _SC_TRACE_INHERIT , _SC_TRACE_LOG , _SC_LEVEL1_ICACHE_SIZE , _SC_LEVEL1_ICACHE_ASSOC , _SC_LEVEL1_ICACHE_LINESIZE , _SC_LEVEL1_DCACHE_SIZE , _SC_LEVEL1_DCACHE_ASSOC , _SC_LEVEL1_DCACHE_LINESIZE , _SC_LEVEL2_CACHE_SIZE , _SC_LEVEL2_CACHE_ASSOC , _SC_LEVEL2_CACHE_LINESIZE , _SC_LEVEL3_CACHE_SIZE , _SC_LEVEL3_CACHE_ASSOC , _SC_LEVEL3_CACHE_LINESIZE , _SC_LEVEL4_CACHE_SIZE , _SC_LEVEL4_CACHE_ASSOC , _SC_LEVEL4_CACHE_LINESIZE , _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50 , _SC_RAW_SOCKETS , _SC_V7_ILP32_OFF32 , _SC_V7_ILP32_OFFBIG , _SC_V7_LP64_OFF64 , _SC_V7_LPBIG_OFFBIG , _SC_SS_REPL_MAX , _SC_TRACE_EVENT_NAME_MAX , _SC_TRACE_NAME_MAX , _SC_TRACE_SYS_MAX , _SC_TRACE_USER_EVENT_MAX , _SC_XOPEN_STREAMS , _SC_THREAD_ROBUST_PRIO_INHERIT , _SC_THREAD_ROBUST_PRIO_PROTECT } ;
enum { _CS_PATH , _CS_V6_WIDTH_RESTRICTED_ENVS , _CS_GNU_LIBC_VERSION , _CS_GNU_LIBPTHREAD_VERSION , _CS_V5_WIDTH_RESTRICTED_ENVS , _CS_V7_WIDTH_RESTRICTED_ENVS , _CS_LFS_CFLAGS = 1000 , _CS_LFS_LDFLAGS , _CS_LFS_LIBS , _CS_LFS_LINTFLAGS , _CS_LFS64_CFLAGS , _CS_LFS64_LDFLAGS , _CS_LFS64_LIBS , _CS_LFS64_LINTFLAGS , _CS_XBS5_ILP32_OFF32_CFLAGS = 1100 , _CS_XBS5_ILP32_OFF32_LDFLAGS , _CS_XBS5_ILP32_OFF32_LIBS , _CS_XBS5_ILP32_OFF32_LINTFLAGS , _CS_XBS5_ILP32_OFFBIG_CFLAGS , _CS_XBS5_ILP32_OFFBIG_LDFLAGS , _CS_XBS5_ILP32_OFFBIG_LIBS , _CS_XBS5_ILP32_OFFBIG_LINTFLAGS , _CS_XBS5_LP64_OFF64_CFLAGS , _CS_XBS5_LP64_OFF64_LDFLAGS , _CS_XBS5_LP64_OFF64_LIBS , _CS_XBS5_LP64_OFF64_LINTFLAGS , _CS_XBS5_LPBIG_OFFBIG_CFLAGS , _CS_XBS5_LPBIG_OFFBIG_LDFLAGS , _CS_XBS5_LPBIG_OFFBIG_LIBS , _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS , _CS_POSIX_V6_ILP32_OFF32_CFLAGS , _CS_POSIX_V6_ILP32_OFF32_LDFLAGS , _CS_POSIX_V6_ILP32_OFF32_LIBS , _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS , _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS , _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS , _CS_POSIX_V6_ILP32_OFFBIG_LIBS , _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS , _CS_POSIX_V6_LP64_OFF64_CFLAGS , _CS_POSIX_V6_LP64_OFF64_LDFLAGS , _CS_POSIX_V6_LP64_OFF64_LIBS , _CS_POSIX_V6_LP64_OFF64_LINTFLAGS , _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS , _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS , _CS_POSIX_V6_LPBIG_OFFBIG_LIBS , _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS , _CS_POSIX_V7_ILP32_OFF32_CFLAGS , _CS_POSIX_V7_ILP32_OFF32_LDFLAGS , _CS_POSIX_V7_ILP32_OFF32_LIBS , _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS , _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS , _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS , _CS_POSIX_V7_ILP32_OFFBIG_LIBS , _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS , _CS_POSIX_V7_LP64_OFF64_CFLAGS , _CS_POSIX_V7_LP64_OFF64_LDFLAGS , _CS_POSIX_V7_LP64_OFF64_LIBS , _CS_POSIX_V7_LP64_OFF64_LINTFLAGS , _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS , _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS , _CS_POSIX_V7_LPBIG_OFFBIG_LIBS , _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS } ;
struct flock { short int l_type ; short int l_whence ; __off_t l_start ; __off_t l_len ; __pid_t l_pid ; } ;


typedef struct __locale_struct { struct locale_data * __locales [ 13 ] ; const unsigned short int * __ctype_b ; const int * __ctype_tolower ; const int * __ctype_toupper ; const char * __names [ 13 ] ; } * __locale_t ;

typedef __locale_t locale_t ;

typedef int wchar_t ;

typedef struct { int quot ; int rem ; } div_t ;

typedef struct { long int quot ; long int rem ; } ldiv_t ;

typedef struct { long long int quot ; long long int rem ; } lldiv_t ;

struct random_data { int32_t * fptr ; int32_t * rptr ; int32_t * state ; int rand_type ; int rand_deg ; int rand_sep ; int32_t * end_ptr ; } ;

struct drand48_data { unsigned short int __x [ 3 ] ; unsigned short int __old_x [ 3 ] ; unsigned short int __c ; unsigned short int __init ; unsigned long long int __a ; } ;

typedef int ( * __compar_fn_t ) ( __const void * , __const void * ) ;

struct _IO_FILE ;

typedef struct _IO_FILE FILE ;

typedef struct _IO_FILE __FILE ;

typedef struct { int __count ; union { unsigned int __wch ; char __wchb [ 4 ] ; } __value ; } __mbstate_t ;

typedef struct { __off_t __pos ; __mbstate_t __state ; } _G_fpos_t ;

typedef struct { __off64_t __pos ; __mbstate_t __state ; } _G_fpos64_t ;

typedef int _G_int16_t __attribute__ ( ( __mode__ ( __HI__ ) ) ) ;

typedef int _G_int32_t __attribute__ ( ( __mode__ ( __SI__ ) ) ) ;

typedef unsigned int _G_uint16_t __attribute__ ( ( __mode__ ( __HI__ ) ) ) ;

typedef unsigned int _G_uint32_t __attribute__ ( ( __mode__ ( __SI__ ) ) ) ;

typedef __builtin_va_list __gnuc_va_list ;

struct _IO_jump_t ;

typedef void _IO_lock_t ;

struct _IO_marker { struct _IO_marker * _next ; struct _IO_FILE * _sbuf ; int _pos ; } ;

enum __codecvt_result { __codecvt_ok , __codecvt_partial , __codecvt_error , __codecvt_noconv } ;

struct _IO_FILE { int _flags ; char * _IO_read_ptr ; char * _IO_read_end ; char * _IO_read_base ; char * _IO_write_base ; char * _IO_write_ptr ; char * _IO_write_end ; char * _IO_buf_base ; char * _IO_buf_end ; char * _IO_save_base ; char * _IO_backup_base ; char * _IO_save_end ; struct _IO_marker * _markers ; struct _IO_FILE * _chain ; int _fileno ; int _flags2 ; __off_t _old_offset ; unsigned short _cur_column ; signed char _vtable_offset ; char _shortbuf [ 1 ] ; _IO_lock_t * _lock ; __off64_t _offset ; void * __pad1 ; void * __pad2 ; void * __pad3 ; void * __pad4 ; size_t __pad5 ; int _mode ; char _unused2 [ 15 * sizeof ( int ) - 4 * sizeof ( void * ) - sizeof ( size_t ) ] ; } ;
typedef struct _IO_FILE _IO_FILE ;

struct _IO_FILE_plus ;

typedef __ssize_t __io_read_fn ( void * __cookie , char * __buf , size_t __nbytes ) ;

typedef __ssize_t __io_write_fn ( void * __cookie , __const char * __buf , size_t __n ) ;

typedef int __io_seek_fn ( void * __cookie , __off64_t * __pos , int __w ) ;

typedef int __io_close_fn ( void * __cookie ) ;

typedef _G_fpos_t fpos_t ;

enum { _ISupper = ( ( 0 ) < 8 ? ( ( 1 << ( 0 ) ) << 8 ) : ( ( 1 << ( 0 ) ) >> 8 ) ) , _ISlower = ( ( 1 ) < 8 ? ( ( 1 << ( 1 ) ) << 8 ) : ( ( 1 << ( 1 ) ) >> 8 ) ) , _ISalpha = ( ( 2 ) < 8 ? ( ( 1 << ( 2 ) ) << 8 ) : ( ( 1 << ( 2 ) ) >> 8 ) ) , _ISdigit = ( ( 3 ) < 8 ? ( ( 1 << ( 3 ) ) << 8 ) : ( ( 1 << ( 3 ) ) >> 8 ) ) , _ISxdigit = ( ( 4 ) < 8 ? ( ( 1 << ( 4 ) ) << 8 ) : ( ( 1 << ( 4 ) ) >> 8 ) ) , _ISspace = ( ( 5 ) < 8 ? ( ( 1 << ( 5 ) ) << 8 ) : ( ( 1 << ( 5 ) ) >> 8 ) ) , _ISprint = ( ( 6 ) < 8 ? ( ( 1 << ( 6 ) ) << 8 ) : ( ( 1 << ( 6 ) ) >> 8 ) ) , _ISgraph = ( ( 7 ) < 8 ? ( ( 1 << ( 7 ) ) << 8 ) : ( ( 1 << ( 7 ) ) >> 8 ) ) , _ISblank = ( ( 8 ) < 8 ? ( ( 1 << ( 8 ) ) << 8 ) : ( ( 1 << ( 8 ) ) >> 8 ) ) , _IScntrl = ( ( 9 ) < 8 ? ( ( 1 << ( 9 ) ) << 8 ) : ( ( 1 << ( 9 ) ) >> 8 ) ) , _ISpunct = ( ( 10 ) < 8 ? ( ( 1 << ( 10 ) ) << 8 ) : ( ( 1 << ( 10 ) ) >> 8 ) ) , _ISalnum = ( ( 11 ) < 8 ? ( ( 1 << ( 11 ) ) << 8 ) : ( ( 1 << ( 11 ) ) >> 8 ) ) } ;
typedef unsigned char uint8_t ;

typedef unsigned short int uint16_t ;

typedef unsigned int uint32_t ;

typedef unsigned long int uint64_t ;

typedef signed char int_least8_t ;

typedef short int int_least16_t ;

typedef int int_least32_t ;

typedef long int int_least64_t ;

typedef unsigned char uint_least8_t ;

typedef unsigned short int uint_least16_t ;

typedef unsigned int uint_least32_t ;

typedef unsigned long int uint_least64_t ;

typedef signed char int_fast8_t ;

typedef long int int_fast16_t ;

typedef long int int_fast32_t ;

typedef long int int_fast64_t ;

typedef unsigned char uint_fast8_t ;

typedef unsigned long int uint_fast16_t ;

typedef unsigned long int uint_fast32_t ;

typedef unsigned long int uint_fast64_t ;

typedef unsigned long int uintptr_t ;

typedef long int intmax_t ;

typedef unsigned long int uintmax_t ;

struct iovec { void * iov_base ; size_t iov_len ; } ;

enum __socket_type { SOCK_STREAM = 1 , SOCK_DGRAM = 2 , SOCK_RAW = 3 , SOCK_RDM = 4 , SOCK_SEQPACKET = 5 , SOCK_DCCP = 6 , SOCK_PACKET = 10 , SOCK_CLOEXEC = 02000000 , SOCK_NONBLOCK = 04000 } ;

typedef unsigned short int sa_family_t ;

struct sockaddr { sa_family_t sa_family ; char sa_data [ 14 ] ; } ;

struct sockaddr_storage { sa_family_t ss_family ; unsigned long int __ss_align ; char __ss_padding [ ( 128 - ( 2 * sizeof ( unsigned long int ) ) ) ] ; } ;

enum { MSG_OOB = 0x01 , MSG_PEEK = 0x02 , MSG_DONTROUTE = 0x04 , MSG_CTRUNC = 0x08 , MSG_PROXY = 0x10 , MSG_TRUNC = 0x20 , MSG_DONTWAIT = 0x40 , MSG_EOR = 0x80 , MSG_WAITALL = 0x100 , MSG_FIN = 0x200 , MSG_SYN = 0x400 , MSG_CONFIRM = 0x800 , MSG_RST = 0x1000 , MSG_ERRQUEUE = 0x2000 , MSG_NOSIGNAL = 0x4000 , MSG_MORE = 0x8000 , MSG_CMSG_CLOEXEC = 0x40000000 } ;
struct msghdr { void * msg_name ; socklen_t msg_namelen ; struct iovec * msg_iov ; size_t msg_iovlen ; void * msg_control ; size_t msg_controllen ; int msg_flags ; } ;

struct cmsghdr { size_t cmsg_len ; int cmsg_level ; int cmsg_type ; __extension__ unsigned char __cmsg_data [ ] ; } ;

enum { SCM_RIGHTS = 0x01 } ;
struct linger { int l_onoff ; int l_linger ; } ;

struct osockaddr { unsigned short int sa_family ; unsigned char sa_data [ 14 ] ; } ;

enum { SHUT_RD = 0 , SHUT_WR , SHUT_RDWR } ;
enum { IPPROTO_IP = 0 , IPPROTO_HOPOPTS = 0 , IPPROTO_ICMP = 1 , IPPROTO_IGMP = 2 , IPPROTO_IPIP = 4 , IPPROTO_TCP = 6 , IPPROTO_EGP = 8 , IPPROTO_PUP = 12 , IPPROTO_UDP = 17 , IPPROTO_IDP = 22 , IPPROTO_TP = 29 , IPPROTO_DCCP = 33 , IPPROTO_IPV6 = 41 , IPPROTO_ROUTING = 43 , IPPROTO_FRAGMENT = 44 , IPPROTO_RSVP = 46 , IPPROTO_GRE = 47 , IPPROTO_ESP = 50 , IPPROTO_AH = 51 , IPPROTO_ICMPV6 = 58 , IPPROTO_NONE = 59 , IPPROTO_DSTOPTS = 60 , IPPROTO_MTP = 92 , IPPROTO_ENCAP = 98 , IPPROTO_PIM = 103 , IPPROTO_COMP = 108 , IPPROTO_SCTP = 132 , IPPROTO_UDPLITE = 136 , IPPROTO_RAW = 255 , IPPROTO_MAX } ;
typedef uint16_t in_port_t ;

enum { IPPORT_ECHO = 7 , IPPORT_DISCARD = 9 , IPPORT_SYSTAT = 11 , IPPORT_DAYTIME = 13 , IPPORT_NETSTAT = 15 , IPPORT_FTP = 21 , IPPORT_TELNET = 23 , IPPORT_SMTP = 25 , IPPORT_TIMESERVER = 37 , IPPORT_NAMESERVER = 42 , IPPORT_WHOIS = 43 , IPPORT_MTP = 57 , IPPORT_TFTP = 69 , IPPORT_RJE = 77 , IPPORT_FINGER = 79 , IPPORT_TTYLINK = 87 , IPPORT_SUPDUP = 95 , IPPORT_EXECSERVER = 512 , IPPORT_LOGINSERVER = 513 , IPPORT_CMDSERVER = 514 , IPPORT_EFSSERVER = 520 , IPPORT_BIFFUDP = 512 , IPPORT_WHOSERVER = 513 , IPPORT_ROUTESERVER = 520 , IPPORT_RESERVED = 1024 , IPPORT_USERRESERVED = 5000 } ;
typedef uint32_t in_addr_t ;

struct in_addr { in_addr_t s_addr ; } ;

struct in6_addr { union { uint8_t __u6_addr8 [ 16 ] ; uint16_t __u6_addr16 [ 8 ] ; uint32_t __u6_addr32 [ 4 ] ; } __in6_u ; } ;

struct sockaddr_in { sa_family_t sin_family ; in_port_t sin_port ; struct in_addr sin_addr ; unsigned char sin_zero [ sizeof ( struct sockaddr ) - ( sizeof ( unsigned short int ) ) - sizeof ( in_port_t ) - sizeof ( struct in_addr ) ] ; } ;

struct sockaddr_in6 { sa_family_t sin6_family ; in_port_t sin6_port ; uint32_t sin6_flowinfo ; struct in6_addr sin6_addr ; uint32_t sin6_scope_id ; } ;

struct ip_mreq { struct in_addr imr_multiaddr ; struct in_addr imr_interface ; } ;

struct ip_mreq_source { struct in_addr imr_multiaddr ; struct in_addr imr_interface ; struct in_addr imr_sourceaddr ; } ;

struct ipv6_mreq { struct in6_addr ipv6mr_multiaddr ; unsigned int ipv6mr_interface ; } ;

struct group_req { uint32_t gr_interface ; struct sockaddr_storage gr_group ; } ;

struct group_source_req { uint32_t gsr_interface ; struct sockaddr_storage gsr_group ; struct sockaddr_storage gsr_source ; } ;

struct ip_msfilter { struct in_addr imsf_multiaddr ; struct in_addr imsf_interface ; uint32_t imsf_fmode ; uint32_t imsf_numsrc ; struct in_addr imsf_slist [ 1 ] ; } ;

struct group_filter { uint32_t gf_interface ; struct sockaddr_storage gf_group ; uint32_t gf_fmode ; uint32_t gf_numsrc ; struct sockaddr_storage gf_slist [ 1 ] ; } ;

struct ip_opts { struct in_addr ip_dst ; char ip_opts [ 40 ] ; } ;

struct ip_mreqn { struct in_addr imr_multiaddr ; struct in_addr imr_address ; int imr_ifindex ; } ;

struct in_pktinfo { int ipi_ifindex ; struct in_addr ipi_spec_dst ; struct in_addr ipi_addr ; } ;

int main ( int argc , char * argv [ ] ) ;


typedef __sig_atomic_t sig_atomic_t ;


typedef union sigval { int sival_int ; void * sival_ptr ; } sigval_t ;


typedef struct siginfo { int si_signo ; int si_errno ; int si_code ; union { int _pad [ ( ( 128 / sizeof ( int ) ) - 4 ) ] ; struct { __pid_t si_pid ; __uid_t si_uid ; } _kill ; struct { int si_tid ; int si_overrun ; sigval_t si_sigval ; } _timer ; struct { __pid_t si_pid ; __uid_t si_uid ; sigval_t si_sigval ; } _rt ; struct { __pid_t si_pid ; __uid_t si_uid ; int si_status ; __clock_t si_utime ; __clock_t si_stime ; } _sigchld ; struct { void * si_addr ; } _sigfault ; struct { long int si_band ; int si_fd ; } _sigpoll ; } _sifields ; } siginfo_t ;

enum { SI_ASYNCNL = - 60 , SI_TKILL = - 6 , SI_SIGIO , SI_ASYNCIO , SI_MESGQ , SI_TIMER , SI_QUEUE , SI_USER , SI_KERNEL = 0x80 } ;
enum { ILL_ILLOPC = 1 , ILL_ILLOPN , ILL_ILLADR , ILL_ILLTRP , ILL_PRVOPC , ILL_PRVREG , ILL_COPROC , ILL_BADSTK } ;
enum { FPE_INTDIV = 1 , FPE_INTOVF , FPE_FLTDIV , FPE_FLTOVF , FPE_FLTUND , FPE_FLTRES , FPE_FLTINV , FPE_FLTSUB } ;
enum { SEGV_MAPERR = 1 , SEGV_ACCERR } ;
enum { BUS_ADRALN = 1 , BUS_ADRERR , BUS_OBJERR } ;
enum { TRAP_BRKPT = 1 , TRAP_TRACE } ;
enum { CLD_EXITED = 1 , CLD_KILLED , CLD_DUMPED , CLD_TRAPPED , CLD_STOPPED , CLD_CONTINUED } ;
enum { POLL_IN = 1 , POLL_OUT , POLL_MSG , POLL_ERR , POLL_PRI , POLL_HUP } ;

typedef struct sigevent { sigval_t sigev_value ; int sigev_signo ; int sigev_notify ; union { int _pad [ ( ( 64 / sizeof ( int ) ) - 4 ) ] ; __pid_t _tid ; struct { void ( * _function ) ( sigval_t ) ; void * _attribute ; } _sigev_thread ; } _sigev_un ; } sigevent_t ;

enum { SIGEV_SIGNAL = 0 , SIGEV_NONE , SIGEV_THREAD , SIGEV_THREAD_ID = 4 } ;
typedef void ( * __sighandler_t ) ( int ) ;

typedef __sighandler_t sig_t ;

struct sigaction { union { __sighandler_t sa_handler ; void ( * sa_sigaction ) ( int , siginfo_t * , void * ) ; } __sigaction_handler ; __sigset_t sa_mask ; int sa_flags ; void ( * sa_restorer ) ( void ) ; } ;

struct sigvec { __sighandler_t sv_handler ; int sv_mask ; int sv_flags ; } ;

struct _fpreg { unsigned short significand [ 4 ] ; unsigned short exponent ; } ;

struct _fpxreg { unsigned short significand [ 4 ] ; unsigned short exponent ; unsigned short padding [ 3 ] ; } ;

struct _xmmreg { __uint32_t element [ 4 ] ; } ;

struct _fpstate { __uint16_t cwd ; __uint16_t swd ; __uint16_t ftw ; __uint16_t fop ; __uint64_t rip ; __uint64_t rdp ; __uint32_t mxcsr ; __uint32_t mxcr_mask ; struct _fpxreg _st [ 8 ] ; struct _xmmreg _xmm [ 16 ] ; __uint32_t padding [ 24 ] ; } ;

struct sigcontext { unsigned long r8 ; unsigned long r9 ; unsigned long r10 ; unsigned long r11 ; unsigned long r12 ; unsigned long r13 ; unsigned long r14 ; unsigned long r15 ; unsigned long rdi ; unsigned long rsi ; unsigned long rbp ; unsigned long rbx ; unsigned long rdx ; unsigned long rax ; unsigned long rcx ; unsigned long rsp ; unsigned long rip ; unsigned long eflags ; unsigned short cs ; unsigned short gs ; unsigned short fs ; unsigned short __pad0 ; unsigned long err ; unsigned long trapno ; unsigned long oldmask ; unsigned long cr2 ; struct _fpstate * fpstate ; unsigned long __reserved1 [ 8 ] ; } ;

struct sigstack { void * ss_sp ; int ss_onstack ; } ;

enum { SS_ONSTACK = 1 , SS_DISABLE } ;

typedef struct sigaltstack { void * ss_sp ; int ss_flags ; size_t ss_size ; } stack_t ;

enum __rlimit_resource { RLIMIT_CPU = 0 , RLIMIT_FSIZE = 1 , RLIMIT_DATA = 2 , RLIMIT_STACK = 3 , RLIMIT_CORE = 4 , __RLIMIT_RSS = 5 , RLIMIT_NOFILE = 7 , __RLIMIT_OFILE = RLIMIT_NOFILE , RLIMIT_AS = 9 , __RLIMIT_NPROC = 6 , __RLIMIT_MEMLOCK = 8 , __RLIMIT_LOCKS = 10 , __RLIMIT_SIGPENDING = 11 , __RLIMIT_MSGQUEUE = 12 , __RLIMIT_NICE = 13 , __RLIMIT_RTPRIO = 14 , __RLIMIT_NLIMITS = 15 , __RLIM_NLIMITS = __RLIMIT_NLIMITS } ;

typedef __rlim_t rlim_t ;

struct rlimit { rlim_t rlim_cur ; rlim_t rlim_max ; } ;

enum __rusage_who { RUSAGE_SELF = 0 , RUSAGE_CHILDREN = - 1 } ;

struct rusage { struct timeval ru_utime ; struct timeval ru_stime ; long int ru_maxrss ; long int ru_ixrss ; long int ru_idrss ; long int ru_isrss ; long int ru_minflt ; long int ru_majflt ; long int ru_nswap ; long int ru_inblock ; long int ru_oublock ; long int ru_msgsnd ; long int ru_msgrcv ; long int ru_nsignals ; long int ru_nvcsw ; long int ru_nivcsw ; } ;

enum __priority_which { PRIO_PROCESS = 0 , PRIO_PGRP = 1 , PRIO_USER = 2 } ;

typedef int __rlimit_resource_t ;

typedef int __rusage_who_t ;

typedef int __priority_which_t ;

typedef union { union wait * __uptr ; int * __iptr ; } __WAIT_STATUS __attribute__ ( ( __transparent_union__ ) ) ;


union wait { int w_status ; struct { unsigned int __w_termsig : 7 ; unsigned int __w_coredump : 1 ; unsigned int __w_retcode : 8 ; unsigned int : 16 ; } __wait_terminated ; struct { unsigned int __w_stopval : 8 ; unsigned int __w_stopsig : 8 ; unsigned int : 16 ; } __wait_stopped ; } ;

typedef enum { P_ALL , P_PID , P_PGID } idtype_t ;

struct rusage ;
typedef void DFL ( char * ) ;

typedef void FILEONLY ( char * file ) ;

typedef void FILELINE ( char * file , char * line ) ;

struct symbols { char * name ; } ;

struct symfile { char * filename ; struct symbols * symbollist ; int symbolcnt ; } ;

enum { __LC_CTYPE = 0 , __LC_NUMERIC = 1 , __LC_TIME = 2 , __LC_COLLATE = 3 , __LC_MONETARY = 4 , __LC_MESSAGES = 5 , __LC_ALL = 6 , __LC_PAPER = 7 , __LC_NAME = 8 , __LC_ADDRESS = 9 , __LC_TELEPHONE = 10 , __LC_MEASUREMENT = 11 , __LC_IDENTIFICATION = 12 } ;
struct lconv { char * decimal_point ; char * thousands_sep ; char * grouping ; char * int_curr_symbol ; char * currency_symbol ; char * mon_decimal_point ; char * mon_thousands_sep ; char * mon_grouping ; char * positive_sign ; char * negative_sign ; char int_frac_digits ; char frac_digits ; char p_cs_precedes ; char p_sep_by_space ; char n_cs_precedes ; char n_sep_by_space ; char p_sign_posn ; char n_sign_posn ; char int_p_cs_precedes ; char int_p_sep_by_space ; char int_n_cs_precedes ; char int_n_sep_by_space ; char int_p_sign_posn ; char int_n_sign_posn ; } ;


typedef __clock_t clock_t ;

struct tm { int tm_sec ; int tm_min ; int tm_hour ; int tm_mday ; int tm_mon ; int tm_year ; int tm_wday ; int tm_yday ; int tm_isdst ; long int tm_gmtoff ; __const char * tm_zone ; } ;

struct itimerspec { struct timespec it_interval ; struct timespec it_value ; } ;

struct sigevent ;
struct timezone { int tz_minuteswest ; int tz_dsttime ; } ;

typedef struct timezone * __restrict __timezone_ptr_t ;

enum __itimer_which { ITIMER_REAL = 0 , ITIMER_VIRTUAL = 1 , ITIMER_PROF = 2 } ;

struct itimerval { struct timeval it_interval ; struct timeval it_value ; } ;

typedef int __itimer_which_t ;

struct file { struct file * next ; struct file * parent ; char * name ; int lineno ; int flags ; } ;


typedef enum tristate { no , mod , yes } tristate ;

enum expr_type { E_NONE , E_OR , E_AND , E_NOT , E_EQUAL , E_UNEQUAL , E_LIST , E_SYMBOL , E_RANGE } ;

union expr_data { struct expr * expr ; struct symbol * sym ; } ;

struct expr { enum expr_type type ; union expr_data left , right ; } ;

struct expr_value { struct expr * expr ; tristate tri ; } ;

struct symbol_value { void * val ; tristate tri ; } ;

enum symbol_type { S_UNKNOWN , S_BOOLEAN , S_TRISTATE , S_INT , S_HEX , S_STRING , S_OTHER } ;

enum { S_DEF_USER , S_DEF_AUTO , S_DEF_DEF3 , S_DEF_DEF4 , S_DEF_COUNT } ;
struct symbol { struct symbol * next ; char * name ; enum symbol_type type ; struct symbol_value curr ; struct symbol_value def [ S_DEF_COUNT ] ; tristate visible ; int flags ; struct property * prop ; struct expr_value rev_dep ; } ;

enum prop_type { P_UNKNOWN , P_PROMPT , P_COMMENT , P_MENU , P_DEFAULT , P_CHOICE , P_SELECT , P_RANGE , P_ENV , } ;

struct property { struct property * next ; struct symbol * sym ; enum prop_type type ; const char * text ; struct expr_value visible ; struct expr * expr ; struct menu * menu ; struct file * file ; int lineno ; } ;

struct menu { struct menu * next ; struct menu * parent ; struct menu * list ; struct symbol * sym ; struct property * prompt ; struct expr * dep ; unsigned int flags ; char * help ; struct file * file ; int lineno ; void * data ; } ;

struct gstr ;

enum conf_def_mode { def_default , def_yes , def_mod , def_no , def_random } ;

struct kconf_id { int name ; int token ; unsigned int flags ; enum symbol_type stype ; } ;

struct gstr { size_t len ; char * s ; } ;
int main ( int ac , char * * av ) ;
struct file_line { struct file_line * next ; char * file ; int lineno ; } ;

struct message { const char * msg ; const char * option ; struct message * next ; struct file_line * files ; } ;

typedef __gnuc_va_list va_list ;

enum yytokentype { T_MAINMENU = 258 , T_MENU = 259 , T_ENDMENU = 260 , T_SOURCE = 261 , T_CHOICE = 262 , T_ENDCHOICE = 263 , T_COMMENT = 264 , T_CONFIG = 265 , T_MENUCONFIG = 266 , T_HELP = 267 , T_HELPTEXT = 268 , T_IF = 269 , T_ENDIF = 270 , T_DEPENDS = 271 , T_OPTIONAL = 272 , T_PROMPT = 273 , T_TYPE = 274 , T_DEFAULT = 275 , T_SELECT = 276 , T_RANGE = 277 , T_OPTION = 278 , T_ON = 279 , T_WORD = 280 , T_WORD_QUOTE = 281 , T_UNEQUAL = 282 , T_CLOSE_PAREN = 283 , T_OPEN_PAREN = 284 , T_EOL = 285 , T_OR = 286 , T_AND = 287 , T_EQUAL = 288 , T_NOT = 289 } ;


typedef union YYSTYPE { char * string ; struct file * file ; struct symbol * symbol ; struct expr * expr ; struct menu * menu ; struct kconf_id * id ; } YYSTYPE ;

struct kconf_id ;
struct kconf_id_strings_t { char kconf_id_strings_str2 [ sizeof ( ) ] ; char kconf_id_strings_str3 [ sizeof ( ) ] ; char kconf_id_strings_str5 [ sizeof ( ) ] ; char kconf_id_strings_str6 [ sizeof ( ) ] ; char kconf_id_strings_str7 [ sizeof ( ) ] ; char kconf_id_strings_str8 [ sizeof ( ) ] ; char kconf_id_strings_str9 [ sizeof ( ) ] ; char kconf_id_strings_str10 [ sizeof ( ) ] ; char kconf_id_strings_str11 [ sizeof ( ) ] ; char kconf_id_strings_str12 [ sizeof ( ) ] ; char kconf_id_strings_str13 [ sizeof ( ) ] ; char kconf_id_strings_str14 [ sizeof ( ) ] ; char kconf_id_strings_str15 [ sizeof ( ) ] ; char kconf_id_strings_str16 [ sizeof ( ) ] ; char kconf_id_strings_str17 [ sizeof ( ) ] ; char kconf_id_strings_str18 [ sizeof ( ) ] ; char kconf_id_strings_str19 [ sizeof ( ) ] ; char kconf_id_strings_str21 [ sizeof ( ) ] ; char kconf_id_strings_str22 [ sizeof ( ) ] ; char kconf_id_strings_str23 [ sizeof ( ) ] ; char kconf_id_strings_str26 [ sizeof ( ) ] ; char kconf_id_strings_str27 [ sizeof ( ) ] ; char kconf_id_strings_str28 [ sizeof ( ) ] ; char kconf_id_strings_str29 [ sizeof ( ) ] ; char kconf_id_strings_str31 [ sizeof ( ) ] ; char kconf_id_strings_str32 [ sizeof ( ) ] ; char kconf_id_strings_str33 [ sizeof ( ) ] ; char kconf_id_strings_str35 [ sizeof ( ) ] ; char kconf_id_strings_str36 [ sizeof ( ) ] ; char kconf_id_strings_str37 [ sizeof ( ) ] ; char kconf_id_strings_str48 [ sizeof ( ) ] ; } ;

typedef unsigned char yytype_uint8 ;

typedef signed char yytype_int8 ;

typedef unsigned short int yytype_uint16 ;

typedef short int yytype_int16 ;

union yyalloc { yytype_int16 yyss_alloc ; YYSTYPE yyvs_alloc ; } ;

int zconfparse ( void ) ;

void conf_parse ( const char * name ) ;

void zconfdump ( FILE * out ) ;

typedef signed char flex_int8_t ;

typedef short int flex_int16_t ;

typedef int flex_int32_t ;

typedef unsigned char flex_uint8_t ;

typedef unsigned short int flex_uint16_t ;

typedef unsigned int flex_uint32_t ;

typedef struct yy_buffer_state * YY_BUFFER_STATE ;

typedef size_t yy_size_t ;

struct yy_buffer_state { FILE * yy_input_file ; char * yy_ch_buf ; char * yy_buf_pos ; yy_size_t yy_buf_size ; int yy_n_chars ; int yy_is_our_buffer ; int yy_is_interactive ; int yy_at_bol ; int yy_bs_lineno ; int yy_bs_column ; int yy_fill_buffer ; int yy_buffer_status ; } ;

typedef unsigned char YY_CHAR ;

typedef int yy_state_type ;

struct yy_trans_info { flex_int32_t yy_verify ; flex_int32_t yy_nxt ; } ;

struct buffer { struct buffer * parent ; YY_BUFFER_STATE state ; } ;

int zconflex ( void ) ;

void zconfrestart ( FILE * input_file ) ;

void zconf_switch_to_buffer ( YY_BUFFER_STATE new_buffer ) ;

YY_BUFFER_STATE zconf_create_buffer ( FILE * file , int size ) ;

void zconf_delete_buffer ( YY_BUFFER_STATE b ) ;

void zconf_flush_buffer ( YY_BUFFER_STATE b ) ;

void zconfpush_buffer_state ( YY_BUFFER_STATE new_buffer ) ;

void zconfpop_buffer_state ( void ) ;

YY_BUFFER_STATE zconf_scan_buffer ( char * base , yy_size_t size ) ;

YY_BUFFER_STATE zconf_scan_string ( const char * yystr ) ;

YY_BUFFER_STATE zconf_scan_bytes ( const char * yybytes , int _yybytes_len ) ;

int zconfget_lineno ( void ) ;

FILE * zconfget_in ( void ) ;

FILE * zconfget_out ( void ) ;

int zconfget_leng ( void ) ;

char * zconfget_text ( void ) ;

void zconfset_lineno ( int line_number ) ;

void zconfset_in ( FILE * in_str ) ;

void zconfset_out ( FILE * out_str ) ;

int zconfget_debug ( void ) ;

void zconfset_debug ( int bdebug ) ;

int zconflex_destroy ( void ) ;

void * zconfalloc ( yy_size_t size ) ;

void * zconfrealloc ( void * ptr , yy_size_t size ) ;

void zconffree ( void * ptr ) ;

void zconf_starthelp ( void ) ;

FILE * zconf_fopen ( const char * name ) ;

void zconf_initscan ( const char * name ) ;

void zconf_nextfile ( const char * name ) ;

int zconf_lineno ( void ) ;

char * zconf_curname ( void ) ;

struct file * file_lookup ( const char * name ) ;

int file_write_dep ( const char * name ) ;

struct gstr str_new ( void ) ;

struct gstr str_assign ( const char * s ) ;

void str_free ( struct gstr * gs ) ;

void str_append ( struct gstr * gs , const char * s ) ;

void str_printf ( struct gstr * gs , const char * fmt , ... ) ;

const char * str_get ( struct gstr * gs ) ;

const char * conf_get_configname ( void ) ;

const char * conf_get_autoconfig_name ( void ) ;

char * conf_get_default_confname ( void ) ;

int conf_read_simple ( const char * name , int def ) ;

int conf_read ( const char * name ) ;

int conf_write ( const char * name ) ;

int conf_write_autoconf ( void ) ;

void sym_set_change_count ( int count ) ;

void sym_add_change_count ( int count ) ;

_Bool conf_get_changed ( void ) ;

void conf_set_changed_callback ( void ( * fn ) ( void ) ) ;

void conf_set_all_new_symbols ( enum conf_def_mode mode ) ;

struct expr * expr_alloc_symbol ( struct symbol * sym ) ;

struct expr * expr_alloc_one ( enum expr_type type , struct expr * ce ) ;

struct expr * expr_alloc_two ( enum expr_type type , struct expr * e1 , struct expr * e2 ) ;

struct expr * expr_alloc_comp ( enum expr_type type , struct symbol * s1 , struct symbol * s2 ) ;

struct expr * expr_alloc_and ( struct expr * e1 , struct expr * e2 ) ;

struct expr * expr_alloc_or ( struct expr * e1 , struct expr * e2 ) ;

struct expr * expr_copy ( struct expr * org ) ;

void expr_free ( struct expr * e ) ;

void expr_eliminate_eq ( struct expr * * ep1 , struct expr * * ep2 ) ;

int expr_eq ( struct expr * e1 , struct expr * e2 ) ;

struct expr * expr_eliminate_yn ( struct expr * e ) ;

struct expr * expr_trans_bool ( struct expr * e ) ;

struct expr * expr_eliminate_dups ( struct expr * e ) ;

struct expr * expr_transform ( struct expr * e ) ;

int expr_contains_symbol ( struct expr * dep , struct symbol * sym ) ;

_Bool expr_depends_symbol ( struct expr * dep , struct symbol * sym ) ;

struct expr * expr_extract_eq_and ( struct expr * * ep1 , struct expr * * ep2 ) ;

struct expr * expr_extract_eq_or ( struct expr * * ep1 , struct expr * * ep2 ) ;

void expr_extract_eq ( enum expr_type type , struct expr * * ep , struct expr * * ep1 , struct expr * * ep2 ) ;

struct expr * expr_trans_compare ( struct expr * e , enum expr_type type , struct symbol * sym ) ;

tristate expr_calc_value ( struct expr * e ) ;

int expr_compare_type ( enum expr_type t1 , enum expr_type t2 ) ;

void expr_print ( struct expr * e , void ( * fn ) ( void * , struct symbol * , const char * ) , void * data , int prevtoken ) ;

void expr_fprint ( struct expr * e , FILE * out ) ;

void expr_gstr_print ( struct expr * e , struct gstr * gs ) ;

typedef long int s_reg_t ;

typedef unsigned long int active_reg_t ;

typedef unsigned long int reg_syntax_t ;

typedef enum { REG_ENOSYS = - 1 , REG_NOERROR = 0 , REG_NOMATCH , REG_BADPAT , REG_ECOLLATE , REG_ECTYPE , REG_EESCAPE , REG_ESUBREG , REG_EBRACK , REG_EPAREN , REG_EBRACE , REG_BADBR , REG_ERANGE , REG_ESPACE , REG_BADRPT , REG_EEND , REG_ESIZE , REG_ERPAREN } reg_errcode_t ;

struct re_pattern_buffer { unsigned char * __buffer ; unsigned long int __allocated ; unsigned long int __used ; reg_syntax_t __syntax ; char * __fastmap ; unsigned char * __translate ; size_t re_nsub ; unsigned __can_be_null : 1 ; unsigned __regs_allocated : 2 ; unsigned __fastmap_accurate : 1 ; unsigned __no_sub : 1 ; unsigned __not_bol : 1 ; unsigned __not_eol : 1 ; unsigned __newline_anchor : 1 ; } ;

typedef struct re_pattern_buffer regex_t ;

typedef int regoff_t ;

typedef struct { regoff_t rm_so ; regoff_t rm_eo ; } regmatch_t ;

struct utsname { char sysname [ 65 ] ; char nodename [ 65 ] ; char release [ 65 ] ; char version [ 65 ] ; char machine [ 65 ] ; char __domainname [ 65 ] ; } ;

void sym_init ( void ) ;

enum symbol_type sym_get_type ( struct symbol * sym ) ;

const char * sym_type_name ( enum symbol_type type ) ;

struct property * sym_get_choice_prop ( struct symbol * sym ) ;

struct property * sym_get_env_prop ( struct symbol * sym ) ;

struct property * sym_get_default_prop ( struct symbol * sym ) ;

void sym_calc_value ( struct symbol * sym ) ;

void sym_clear_all_valid ( void ) ;

void sym_set_changed ( struct symbol * sym ) ;

void sym_set_all_changed ( void ) ;

_Bool sym_tristate_within_range ( struct symbol * sym , tristate val ) ;

_Bool sym_set_tristate_value ( struct symbol * sym , tristate val ) ;

tristate sym_toggle_tristate_value ( struct symbol * sym ) ;

_Bool sym_string_valid ( struct symbol * sym , const char * str ) ;

_Bool sym_string_within_range ( struct symbol * sym , const char * str ) ;

_Bool sym_set_string_value ( struct symbol * sym , const char * newval ) ;

const char * sym_get_string_value ( struct symbol * sym ) ;

_Bool sym_is_changable ( struct symbol * sym ) ;

struct symbol * sym_lookup ( const char * name , int flags ) ;

struct symbol * sym_find ( const char * name ) ;

struct symbol * * sym_re_search ( const char * pattern ) ;

struct symbol * sym_check_deps ( struct symbol * sym ) ;

struct property * prop_alloc ( enum prop_type type , struct symbol * sym ) ;

struct symbol * prop_get_symbol ( struct property * prop ) ;

const char * prop_get_type_name ( enum prop_type type ) ;

void menu_warn ( struct menu * menu , const char * fmt , ... ) ;

void menu_init ( void ) ;

void menu_add_entry ( struct symbol * sym ) ;

void menu_end_entry ( void ) ;

struct menu * menu_add_menu ( void ) ;

void menu_end_menu ( void ) ;

void menu_add_dep ( struct expr * dep ) ;

void menu_set_type ( int type ) ;

struct property * menu_add_prop ( enum prop_type type , char * prompt , struct expr * expr , struct expr * dep ) ;

struct property * menu_add_prompt ( enum prop_type type , char * prompt , struct expr * dep ) ;

void menu_add_expr ( enum prop_type type , struct expr * expr , struct expr * dep ) ;

void menu_add_symbol ( enum prop_type type , struct symbol * sym , struct expr * dep ) ;

void menu_add_option ( int token , char * arg ) ;

void menu_finalize ( struct menu * parent ) ;

_Bool menu_is_visible ( struct menu * menu ) ;

const char * menu_get_prompt ( struct menu * menu ) ;

struct menu * menu_get_root_menu ( struct menu * menu ) ;

struct menu * menu_get_parent_menu ( struct menu * menu ) ;

_Bool menu_has_help ( struct menu * menu ) ;

const char * menu_get_help ( struct menu * menu ) ;

void get_symbol_str ( struct gstr * r , struct symbol * sym ) ;

void menu_get_ext_help ( struct menu * menu , struct gstr * help ) ;

typedef __signed__ char __s8 ;

typedef unsigned char __u8 ;

typedef __signed__ short __s16 ;

typedef unsigned short __u16 ;

typedef __signed__ int __s32 ;

typedef unsigned int __u32 ;

typedef __signed__ long long __s64 ;

typedef unsigned long long __u64 ;

typedef signed char s8 ;

typedef unsigned char u8 ;

typedef signed short s16 ;

typedef unsigned short u16 ;

typedef signed int s32 ;

typedef unsigned int u32 ;

typedef signed long long s64 ;

typedef unsigned long long u64 ;

typedef unsigned short umode_t ;

typedef u64 dma64_addr_t ;

typedef u64 dma_addr_t ;

struct ftrace_branch_data { const char * func ; const char * file ; unsigned line ; union { struct { unsigned long correct ; unsigned long incorrect ; } ; struct { unsigned long miss ; unsigned long hit ; } ; unsigned long miss_hit [ 2 ] ; } ; } ;

enum { false = 0 , true = 1 } ;
typedef struct { unsigned long fds_bits [ ( 1024 / ( 8 * sizeof ( unsigned long ) ) ) ] ; } __kernel_fd_set ;

typedef void ( * __kernel_sighandler_t ) ( int ) ;
typedef int __kernel_key_t ;

typedef int __kernel_mqd_t ;

typedef unsigned long __kernel_ino_t ;

typedef unsigned int __kernel_mode_t ;

typedef unsigned long __kernel_nlink_t ;

typedef long __kernel_off_t ;

typedef int __kernel_pid_t ;

typedef int __kernel_ipc_pid_t ;

typedef unsigned int __kernel_uid_t ;

typedef unsigned int __kernel_gid_t ;

typedef unsigned long __kernel_size_t ;

typedef long __kernel_ssize_t ;

typedef long __kernel_ptrdiff_t ;

typedef long __kernel_time_t ;

typedef long __kernel_suseconds_t ;

typedef long __kernel_clock_t ;

typedef int __kernel_timer_t ;

typedef int __kernel_clockid_t ;

typedef int __kernel_daddr_t ;

typedef char * __kernel_caddr_t ;

typedef unsigned short __kernel_uid16_t ;

typedef unsigned short __kernel_gid16_t ;

typedef long long __kernel_loff_t ;

typedef struct { int val [ 2 ] ; } __kernel_fsid_t ;

typedef unsigned short __kernel_old_uid_t ;

typedef unsigned short __kernel_old_gid_t ;

typedef __kernel_uid_t __kernel_uid32_t ;

typedef __kernel_gid_t __kernel_gid32_t ;

typedef unsigned long __kernel_old_dev_t ;

typedef __u32 __kernel_dev_t ;

typedef __kernel_fd_set fd_set ;
typedef __kernel_dev_t dev_t ;
typedef __kernel_ino_t ino_t ;
typedef __kernel_mode_t mode_t ;
typedef __kernel_nlink_t nlink_t ;
typedef __kernel_off_t off_t ;
typedef __kernel_pid_t pid_t ;
typedef __kernel_daddr_t daddr_t ;
typedef __kernel_key_t key_t ;
typedef __kernel_suseconds_t suseconds_t ;
typedef __kernel_timer_t timer_t ;
typedef __kernel_clockid_t clockid_t ;
typedef __kernel_mqd_t mqd_t ;

typedef _Bool bool ;

typedef __kernel_uid32_t uid_t ;
typedef __kernel_gid32_t gid_t ;
typedef __kernel_uid16_t uid16_t ;

typedef __kernel_gid16_t gid16_t ;

typedef unsigned long uintptr_t ;
typedef __kernel_old_uid_t old_uid_t ;

typedef __kernel_old_gid_t old_gid_t ;

typedef __kernel_loff_t loff_t ;
typedef __kernel_size_t size_t ;
typedef __kernel_ssize_t ssize_t ;
typedef __kernel_ptrdiff_t ptrdiff_t ;

typedef __kernel_time_t time_t ;
typedef __kernel_clock_t clock_t ;
typedef __kernel_caddr_t caddr_t ;
typedef unsigned char u_char ;
typedef unsigned short u_short ;
typedef unsigned int u_int ;
typedef unsigned long u_long ;
typedef unsigned char unchar ;

typedef unsigned short ushort ;
typedef unsigned long ulong ;
typedef __u8 u_int8_t ;

typedef __s8 int8_t ;

typedef __u16 u_int16_t ;

typedef __s16 int16_t ;

typedef __u32 u_int32_t ;

typedef __s32 int32_t ;

typedef __u8 uint8_t ;
typedef __u16 uint16_t ;
typedef __u32 uint32_t ;
typedef __u64 uint64_t ;
typedef __u64 u_int64_t ;

typedef __s64 int64_t ;

typedef unsigned long sector_t ;

typedef unsigned long blkcnt_t ;
typedef __u16 __le16 ;

typedef __u16 __be16 ;

typedef __u32 __le32 ;

typedef __u32 __be32 ;

typedef __u64 __le64 ;

typedef __u64 __be64 ;

typedef __u16 __sum16 ;

typedef __u32 __wsum ;

typedef unsigned gfp_t ;

typedef unsigned fmode_t ;

typedef u64 phys_addr_t ;

typedef phys_addr_t resource_size_t ;

typedef struct { volatile int counter ; } atomic_t ;

typedef struct { volatile long counter ; } atomic64_t ;

struct ustat { __kernel_daddr_t f_tfree ; __kernel_ino_t f_tinode ; char f_fname [ 6 ] ; char f_fpack [ 6 ] ; } ;

enum pageflags { PG_locked , PG_error , PG_referenced , PG_uptodate , PG_dirty , PG_lru , PG_active , PG_slab , PG_owner_priv_1 , PG_arch_1 , PG_reserved , PG_private , PG_private_2 , PG_writeback , PG_head , PG_tail , PG_swapcache , PG_mappedtodisk , PG_reclaim , PG_buddy , PG_swapbacked , PG_unevictable , PG_mlocked , PG_uncached , PG_hwpoison , __NR_PAGEFLAGS , PG_checked = PG_owner_priv_1 , PG_fscache = PG_private_2 , PG_pinned = PG_owner_priv_1 , PG_savepinned = PG_dirty , PG_slob_free = PG_private , PG_slub_frozen = PG_active , PG_slub_debug = PG_error , } ;

enum zone_type { ZONE_DMA , ZONE_DMA32 , ZONE_NORMAL , ZONE_MOVABLE , __MAX_NR_ZONES } ;

void foo ( void ) ;

struct alt_instr { u8 * instr ; u8 * replacement ; u8 cpuid ; u8 instrlen ; u8 replacementlen ; u8 pad1 ; u32 pad2 ; } ;

struct module ;

struct paravirt_patch_site ;

typedef atomic64_t atomic_long_t ;

struct task_struct ;

struct mm_struct ;

struct vm86_regs { long ebx ; long ecx ; long edx ; long esi ; long edi ; long ebp ; long eax ; long __null_ds ; long __null_es ; long __null_fs ; long __null_gs ; long orig_eax ; long eip ; unsigned short cs , __csh ; long eflags ; long esp ; unsigned short ss , __ssh ; unsigned short es , __esh ; unsigned short ds , __dsh ; unsigned short fs , __fsh ; unsigned short gs , __gsh ; } ;

struct revectored_struct { unsigned long __map [ 8 ] ; } ;

struct vm86_struct { struct vm86_regs regs ; unsigned long flags ; unsigned long screen_bitmap ; unsigned long cpu_type ; struct revectored_struct int_revectored ; struct revectored_struct int21_revectored ; } ;

struct vm86plus_info_struct { unsigned long force_return_for_pic : 1 ; unsigned long vm86dbg_active : 1 ; unsigned long vm86dbg_TFpendig : 1 ; unsigned long unused : 28 ; unsigned long is_vm86pus : 1 ; unsigned char vm86dbg_intxxtab [ 32 ] ; } ;

struct vm86plus_struct { struct vm86_regs regs ; unsigned long flags ; unsigned long screen_bitmap ; unsigned long cpu_type ; struct revectored_struct int_revectored ; struct revectored_struct int21_revectored ; struct vm86plus_info_struct vm86plus ; } ;

struct ptrace_bts_config { __u32 size ; __u32 flags ; __u32 signal ; __u32 bts_size ; } ;

struct pt_regs { unsigned long r15 ; unsigned long r14 ; unsigned long r13 ; unsigned long r12 ; unsigned long bp ; unsigned long bx ; unsigned long r11 ; unsigned long r10 ; unsigned long r9 ; unsigned long r8 ; unsigned long ax ; unsigned long cx ; unsigned long dx ; unsigned long si ; unsigned long di ; unsigned long orig_ax ; unsigned long ip ; unsigned long cs ; unsigned long flags ; unsigned long sp ; unsigned long ss ; } ;

typedef int ( * initcall_t ) ( void ) ;
typedef void ( * exitcall_t ) ( void ) ;
typedef void ( * ctor_fn_t ) ( void ) ;

struct obs_kernel_param { const char * str ; int ( * setup_func ) ( char * ) ; int early ; } ;

struct cpuinfo_x86 ;

struct user_desc ;

struct kernel_vm86_regs { struct pt_regs pt ; unsigned short es , __esh ; unsigned short ds , __dsh ; unsigned short fs , __fsh ; unsigned short gs , __gsh ; } ;

struct kernel_vm86_struct { struct kernel_vm86_regs regs ; unsigned long flags ; unsigned long screen_bitmap ; unsigned long cpu_type ; struct revectored_struct int_revectored ; struct revectored_struct int21_revectored ; struct vm86plus_info_struct vm86plus ; struct pt_regs * regs32 ; } ;

struct math_emu_info { long ___orig_eip ; union { struct pt_regs * regs ; struct kernel_vm86_regs * vm86 ; } ; } ;

struct _fpx_sw_bytes { __u32 magic1 ; __u32 extended_size ; __u64 xstate_bv ; __u32 xstate_size ; __u32 padding [ 7 ] ; } ;

struct _fpstate { __u16 cwd ; __u16 swd ; __u16 twd ; __u16 fop ; __u64 rip ; __u64 rdp ; __u32 mxcsr ; __u32 mxcsr_mask ; __u32 st_space [ 32 ] ; __u32 xmm_space [ 64 ] ; __u32 reserved2 [ 12 ] ; union { __u32 reserved3 [ 12 ] ; struct _fpx_sw_bytes sw_reserved ; } ; } ;
struct sigcontext { unsigned long r8 ; unsigned long r9 ; unsigned long r10 ; unsigned long r11 ; unsigned long r12 ; unsigned long r13 ; unsigned long r14 ; unsigned long r15 ; unsigned long di ; unsigned long si ; unsigned long bp ; unsigned long bx ; unsigned long dx ; unsigned long ax ; unsigned long cx ; unsigned long sp ; unsigned long ip ; unsigned long flags ; unsigned short cs ; unsigned short gs ; unsigned short fs ; unsigned short __pad0 ; unsigned long err ; unsigned long trapno ; unsigned long oldmask ; unsigned long cr2 ; void * fpstate ; unsigned long reserved1 [ 8 ] ; } ;
struct _xsave_hdr { __u64 xstate_bv ; __u64 reserved1 [ 2 ] ; __u64 reserved2 [ 5 ] ; } ;

struct _ymmh_state { __u32 ymmh_space [ 64 ] ; } ;

struct _xstate { struct _fpstate fpstate ; struct _xsave_hdr xstate_hdr ; struct _ymmh_state ymmh ; } ;

struct ratelimit_state { int interval ; int burst ; int printed ; int missed ; unsigned long begin ; } ;

struct _ddebug { const char * modname ; const char * function ; const char * filename ; const char * format ; char primary_hash ; char secondary_hash ; unsigned int lineno : 24 ; unsigned int flags : 8 ; } __attribute__ ( ( aligned ( 8 ) ) ) ;
struct bug_entry { signed int bug_addr_disp ; signed int file_disp ; unsigned short line ; unsigned short flags ; } ;

struct completion ;

struct pt_regs ;
struct user ;

struct pid ;


enum { DUMP_PREFIX_NONE , DUMP_PREFIX_ADDRESS , DUMP_PREFIX_OFFSET } ;
struct sysinfo ;

struct sysinfo { long uptime ; unsigned long loads [ 3 ] ; unsigned long totalram ; unsigned long freeram ; unsigned long sharedram ; unsigned long bufferram ; unsigned long totalswap ; unsigned long freeswap ; unsigned short procs ; unsigned short pad ; unsigned long totalhigh ; unsigned long freehigh ; unsigned int mem_unit ; char _f [ 20 - 2 * sizeof ( long ) - sizeof ( int ) ] ; } ;
typedef unsigned long pteval_t ;

typedef unsigned long pmdval_t ;

typedef unsigned long pudval_t ;

typedef unsigned long pgdval_t ;

typedef unsigned long pgprotval_t ;

typedef struct { pteval_t pte ; } pte_t ;


typedef struct pgprot { pgprotval_t pgprot ; } pgprot_t ;

typedef struct { pgdval_t pgd ; } pgd_t ;

typedef struct { pudval_t pud ; } pud_t ;

typedef struct { pmdval_t pmd ; } pmd_t ;

typedef struct page * pgtable_t ;

struct file ;
struct seq_file ;

enum { PG_LEVEL_NONE , PG_LEVEL_4K , PG_LEVEL_2M , PG_LEVEL_1G , PG_LEVEL_NUM } ;
struct desc_struct { union { struct { unsigned int a ; unsigned int b ; } ; struct { u16 limit0 ; u16 base0 ; unsigned base1 : 8 , type : 4 , s : 1 , dpl : 2 , p : 1 ; unsigned limit : 4 , avl : 1 , l : 1 , d : 1 , g : 1 , base2 : 8 ; } ; } ; } __attribute__ ( ( packed ) ) ;
enum { GATE_INTERRUPT = 0xE , GATE_TRAP = 0xF , GATE_CALL = 0xC , GATE_TASK = 0x5 , } ;
struct gate_struct64 { u16 offset_low ; u16 segment ; unsigned ist : 3 , zero0 : 5 , type : 5 , dpl : 2 , p : 1 ; u16 offset_middle ; u32 offset_high ; u32 zero1 ; } __attribute__ ( ( packed ) ) ;
enum { DESC_TSS = 0x9 , DESC_LDT = 0x2 , DESCTYPE_S = 0x10 , } ;
struct ldttss_desc64 { u16 limit0 ; u16 base0 ; unsigned base1 : 8 , type : 5 , dpl : 2 , p : 1 ; unsigned limit1 : 4 , zero0 : 3 , g : 1 , base2 : 8 ; u32 base3 ; u32 zero1 ; } __attribute__ ( ( packed ) ) ;
typedef struct gate_struct64 gate_desc ;

typedef struct ldttss_desc64 ldt_desc ;

typedef struct ldttss_desc64 tss_desc ;

struct desc_ptr { unsigned short size ; unsigned long address ; } __attribute__ ( ( packed ) ) ;
enum km_type { KM_BOUNCE_READ , KM_SKB_SUNRPC_DATA , KM_SKB_DATA_SOFTIRQ , KM_USER0 , KM_USER1 , KM_BIO_SRC_IRQ , KM_BIO_DST_IRQ , KM_PTE0 , KM_PTE1 , KM_IRQ0 , KM_IRQ1 , KM_SOFTIRQ0 , KM_SOFTIRQ1 , KM_SYNC_ICACHE , KM_SYNC_DCACHE , KM_UML_USERCOPY , KM_IRQ_PTE , KM_NMI , KM_NMI_PTE , KM_TYPE_NR } ;

struct page ;

struct thread_struct ;

struct desc_ptr ;

struct tss_struct ;

struct desc_struct ;

struct cpumask ;

struct paravirt_callee_save { void * func ; } ;

struct pv_info { unsigned int kernel_rpl ; int shared_kernel_pmd ; int paravirt_enabled ; const char * name ; } ;

struct pv_init_ops { unsigned ( * patch ) ( u8 type , u16 clobber , void * insnbuf , unsigned long addr , unsigned len ) ; } ;

struct pv_lazy_ops { void ( * enter ) ( void ) ; void ( * leave ) ( void ) ; } ;

struct pv_time_ops { unsigned long long ( * sched_clock ) ( void ) ; unsigned long ( * get_tsc_khz ) ( void ) ; } ;

struct pv_cpu_ops { unsigned long ( * get_debugreg ) ( int regno ) ; void ( * set_debugreg ) ( int regno , unsigned long value ) ; void ( * clts ) ( void ) ; unsigned long ( * read_cr0 ) ( void ) ; void ( * write_cr0 ) ( unsigned long ) ; unsigned long ( * read_cr4_safe ) ( void ) ; unsigned long ( * read_cr4 ) ( void ) ; void ( * write_cr4 ) ( unsigned long ) ; unsigned long ( * read_cr8 ) ( void ) ; void ( * write_cr8 ) ( unsigned long ) ; void ( * load_tr_desc ) ( void ) ; void ( * load_gdt ) ( const struct desc_ptr * ) ; void ( * load_idt ) ( const struct desc_ptr * ) ; void ( * store_gdt ) ( struct desc_ptr * ) ; void ( * store_idt ) ( struct desc_ptr * ) ; void ( * set_ldt ) ( const void * desc , unsigned entries ) ; unsigned long ( * store_tr ) ( void ) ; void ( * load_tls ) ( struct thread_struct * t , unsigned int cpu ) ; void ( * load_gs_index ) ( unsigned int idx ) ; void ( * write_ldt_entry ) ( struct desc_struct * ldt , int entrynum , const void * desc ) ; void ( * write_gdt_entry ) ( struct desc_struct * , int entrynum , const void * desc , int size ) ; void ( * write_idt_entry ) ( gate_desc * , int entrynum , const gate_desc * gate ) ; void ( * alloc_ldt ) ( struct desc_struct * ldt , unsigned entries ) ; void ( * free_ldt ) ( struct desc_struct * ldt , unsigned entries ) ; void ( * load_sp0 ) ( struct tss_struct * tss , struct thread_struct * t ) ; void ( * set_iopl_mask ) ( unsigned mask ) ; void ( * wbinvd ) ( void ) ; void ( * io_delay ) ( void ) ; void ( * cpuid ) ( unsigned int * eax , unsigned int * ebx , unsigned int * ecx , unsigned int * edx ) ; u64 ( * read_msr ) ( unsigned int msr , int * err ) ; int ( * rdmsr_regs ) ( u32 * regs ) ; int ( * write_msr ) ( unsigned int msr , unsigned low , unsigned high ) ; int ( * wrmsr_regs ) ( u32 * regs ) ; u64 ( * read_tsc ) ( void ) ; u64 ( * read_pmc ) ( int counter ) ; unsigned long long ( * read_tscp ) ( unsigned int * aux ) ; void ( * irq_enable_sysexit ) ( void ) ; void ( * usergs_sysret64 ) ( void ) ; void ( * usergs_sysret32 ) ( void ) ; void ( * iret ) ( void ) ; void ( * swapgs ) ( void ) ; void ( * start_context_switch ) ( struct task_struct * prev ) ; void ( * end_context_switch ) ( struct task_struct * next ) ; } ;

struct pv_irq_ops { struct paravirt_callee_save save_fl ; struct paravirt_callee_save restore_fl ; struct paravirt_callee_save irq_disable ; struct paravirt_callee_save irq_enable ; void ( * safe_halt ) ( void ) ; void ( * halt ) ( void ) ; void ( * adjust_exception_frame ) ( void ) ; } ;

struct pv_apic_ops { void ( * startup_ipi_hook ) ( int phys_apicid , unsigned long start_eip , unsigned long start_esp ) ; } ;

struct pv_mmu_ops { unsigned long ( * read_cr2 ) ( void ) ; void ( * write_cr2 ) ( unsigned long ) ; unsigned long ( * read_cr3 ) ( void ) ; void ( * write_cr3 ) ( unsigned long ) ; void ( * activate_mm ) ( struct mm_struct * prev , struct mm_struct * next ) ; void ( * dup_mmap ) ( struct mm_struct * oldmm , struct mm_struct * mm ) ; void ( * exit_mmap ) ( struct mm_struct * mm ) ; void ( * flush_tlb_user ) ( void ) ; void ( * flush_tlb_kernel ) ( void ) ; void ( * flush_tlb_single ) ( unsigned long addr ) ; void ( * flush_tlb_others ) ( const struct cpumask * cpus , struct mm_struct * mm , unsigned long va ) ; int ( * pgd_alloc ) ( struct mm_struct * mm ) ; void ( * pgd_free ) ( struct mm_struct * mm , pgd_t * pgd ) ; void ( * alloc_pte ) ( struct mm_struct * mm , unsigned long pfn ) ; void ( * alloc_pmd ) ( struct mm_struct * mm , unsigned long pfn ) ; void ( * alloc_pmd_clone ) ( unsigned long pfn , unsigned long clonepfn , unsigned long start , unsigned long count ) ; void ( * alloc_pud ) ( struct mm_struct * mm , unsigned long pfn ) ; void ( * release_pte ) ( unsigned long pfn ) ; void ( * release_pmd ) ( unsigned long pfn ) ; void ( * release_pud ) ( unsigned long pfn ) ; void ( * set_pte ) ( pte_t * ptep , pte_t pteval ) ; void ( * set_pte_at ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep , pte_t pteval ) ; void ( * set_pmd ) ( pmd_t * pmdp , pmd_t pmdval ) ; void ( * pte_update ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep ) ; void ( * pte_update_defer ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep ) ; pte_t ( * ptep_modify_prot_start ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep ) ; void ( * ptep_modify_prot_commit ) ( struct mm_struct * mm , unsigned long addr , pte_t * ptep , pte_t pte ) ; struct paravirt_callee_save pte_val ; struct paravirt_callee_save make_pte ; struct paravirt_callee_save pgd_val ; struct paravirt_callee_save make_pgd ; void ( * set_pud ) ( pud_t * pudp , pud_t pudval ) ; struct paravirt_callee_save pmd_val ; struct paravirt_callee_save make_pmd ; struct paravirt_callee_save pud_val ; struct paravirt_callee_save make_pud ; void ( * set_pgd ) ( pgd_t * pudp , pgd_t pgdval ) ; struct pv_lazy_ops lazy_mode ; void ( * set_fixmap ) ( unsigned idx , phys_addr_t phys , pgprot_t flags ) ; } ;

struct raw_spinlock ;

struct pv_lock_ops { int ( * spin_is_locked ) ( struct raw_spinlock * lock ) ; int ( * spin_is_contended ) ( struct raw_spinlock * lock ) ; void ( * spin_lock ) ( struct raw_spinlock * lock ) ; void ( * spin_lock_flags ) ( struct raw_spinlock * lock , unsigned long flags ) ; int ( * spin_trylock ) ( struct raw_spinlock * lock ) ; void ( * spin_unlock ) ( struct raw_spinlock * lock ) ; } ;

struct paravirt_patch_template { struct pv_init_ops pv_init_ops ; struct pv_time_ops pv_time_ops ; struct pv_cpu_ops pv_cpu_ops ; struct pv_irq_ops pv_irq_ops ; struct pv_apic_ops pv_apic_ops ; struct pv_mmu_ops pv_mmu_ops ; struct pv_lock_ops pv_lock_ops ; } ;

enum paravirt_lazy_mode { PARAVIRT_LAZY_NONE , PARAVIRT_LAZY_MMU , PARAVIRT_LAZY_CPU , } ;

struct paravirt_patch_site { u8 * instr ; u8 instrtype ; u8 len ; u16 clobbers ; } ;
typedef struct cpumask { unsigned long bits [ ( ( ( 64 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } cpumask_t ;

typedef struct cpumask cpumask_var_t [ 1 ] ;

struct msr { union { struct { u32 l ; u32 h ; } ; u64 q ; } ; } ;

struct msr_info { u32 msr_no ; struct msr reg ; struct msr * msrs ; int err ; } ;

struct msr_regs_info { u32 * regs ; int err ; } ;

struct exec_domain ;

enum { ADDR_NO_RANDOMIZE = 0x0040000 , FDPIC_FUNCPTRS = 0x0080000 , MMAP_PAGE_ZERO = 0x0100000 , ADDR_COMPAT_LAYOUT = 0x0200000 , READ_IMPLIES_EXEC = 0x0400000 , ADDR_LIMIT_32BIT = 0x0800000 , SHORT_INODE = 0x1000000 , WHOLE_SECONDS = 0x2000000 , STICKY_TIMEOUTS = 0x4000000 , ADDR_LIMIT_3GB = 0x8000000 , } ;
enum { PER_LINUX = 0x0000 , PER_LINUX_32BIT = 0x0000 | ADDR_LIMIT_32BIT , PER_LINUX_FDPIC = 0x0000 | FDPIC_FUNCPTRS , PER_SVR4 = 0x0001 | STICKY_TIMEOUTS | MMAP_PAGE_ZERO , PER_SVR3 = 0x0002 | STICKY_TIMEOUTS | SHORT_INODE , PER_SCOSVR3 = 0x0003 | STICKY_TIMEOUTS | WHOLE_SECONDS | SHORT_INODE , PER_OSR5 = 0x0003 | STICKY_TIMEOUTS | WHOLE_SECONDS , PER_WYSEV386 = 0x0004 | STICKY_TIMEOUTS | SHORT_INODE , PER_ISCR4 = 0x0005 | STICKY_TIMEOUTS , PER_BSD = 0x0006 , PER_SUNOS = 0x0006 | STICKY_TIMEOUTS , PER_XENIX = 0x0007 | STICKY_TIMEOUTS | SHORT_INODE , PER_LINUX32 = 0x0008 , PER_LINUX32_3GB = 0x0008 | ADDR_LIMIT_3GB , PER_IRIX32 = 0x0009 | STICKY_TIMEOUTS , PER_IRIXN32 = 0x000a | STICKY_TIMEOUTS , PER_IRIX64 = 0x000b | STICKY_TIMEOUTS , PER_RISCOS = 0x000c , PER_SOLARIS = 0x000d | STICKY_TIMEOUTS , PER_UW7 = 0x000e | STICKY_TIMEOUTS | MMAP_PAGE_ZERO , PER_OSF4 = 0x000f , PER_HPUX = 0x0010 , PER_MASK = 0x00ff , } ;
typedef void ( * handler_t ) ( int , struct pt_regs * ) ;
struct exec_domain { const char * name ; handler_t handler ; unsigned char pers_low ; unsigned char pers_high ; unsigned long * signal_map ; unsigned long * signal_invmap ; struct map_segment * err_map ; struct map_segment * socktype_map ; struct map_segment * sockopt_map ; struct map_segment * af_map ; struct module * module ; struct exec_domain * next ; } ;
struct cpuinfo_x86 { __u8 x86 ; __u8 x86_vendor ; __u8 x86_model ; __u8 x86_mask ; int x86_tlbsize ; __u8 x86_virt_bits ; __u8 x86_phys_bits ; __u8 x86_coreid_bits ; __u32 extended_cpuid_level ; int cpuid_level ; __u32 x86_capability [ 9 ] ; char x86_vendor_id [ 16 ] ; char x86_model_id [ 64 ] ; int x86_cache_size ; int x86_cache_alignment ; int x86_power ; unsigned long loops_per_jiffy ; cpumask_var_t llc_shared_map ; u16 x86_max_cores ; u16 apicid ; u16 initial_apicid ; u16 x86_clflush_size ; u16 booted_cores ; u16 phys_proc_id ; u16 cpu_core_id ; u16 cpu_index ; unsigned int x86_hyper_vendor ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct x86_hw_tss { u32 reserved1 ; u64 sp0 ; u64 sp1 ; u64 sp2 ; u64 reserved2 ; u64 ist [ 7 ] ; u32 reserved3 ; u32 reserved4 ; u16 reserved5 ; u16 io_bitmap_base ; } __attribute__ ( ( packed ) ) __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct tss_struct { struct x86_hw_tss x86_tss ; unsigned long io_bitmap [ ( ( 65536 / 8 ) / sizeof ( long ) ) + 1 ] ; unsigned long stack [ 64 ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct orig_ist { unsigned long ist [ 7 ] ; } ;

struct i387_fsave_struct { u32 cwd ; u32 swd ; u32 twd ; u32 fip ; u32 fcs ; u32 foo ; u32 fos ; u32 st_space [ 20 ] ; u32 status ; } ;

struct i387_fxsave_struct { u16 cwd ; u16 swd ; u16 twd ; u16 fop ; union { struct { u64 rip ; u64 rdp ; } ; struct { u32 fip ; u32 fcs ; u32 foo ; u32 fos ; } ; } ; u32 mxcsr ; u32 mxcsr_mask ; u32 st_space [ 32 ] ; u32 xmm_space [ 64 ] ; u32 padding [ 12 ] ; union { u32 padding1 [ 12 ] ; u32 sw_reserved [ 12 ] ; } ; } __attribute__ ( ( aligned ( 16 ) ) ) ;
struct i387_soft_struct { u32 cwd ; u32 swd ; u32 twd ; u32 fip ; u32 fcs ; u32 foo ; u32 fos ; u32 st_space [ 20 ] ; u8 ftop ; u8 changed ; u8 lookahead ; u8 no_update ; u8 rm ; u8 alimit ; struct math_emu_info * info ; u32 entry_eip ; } ;

struct ymmh_struct { u32 ymmh_space [ 64 ] ; } ;

struct xsave_hdr_struct { u64 xstate_bv ; u64 reserved1 [ 2 ] ; u64 reserved2 [ 5 ] ; } __attribute__ ( ( packed ) ) ;
struct xsave_struct { struct i387_fxsave_struct i387 ; struct xsave_hdr_struct xsave_hdr ; struct ymmh_struct ymmh ; } __attribute__ ( ( packed , aligned ( 64 ) ) ) ;
union thread_xstate { struct i387_fsave_struct fsave ; struct i387_fxsave_struct fxsave ; struct i387_soft_struct soft ; struct xsave_struct xsave ; } ;

union irq_stack_union { char irq_stack [ ( ( ( 1UL ) << 12 ) << 2 ) ] ; struct { char gs_base [ 40 ] ; unsigned long stack_canary ; } ; } ;

struct thread_struct { struct desc_struct tls_array [ 3 ] ; unsigned long sp0 ; unsigned long sp ; unsigned long usersp ; unsigned short es ; unsigned short ds ; unsigned short fsindex ; unsigned short gsindex ; unsigned long fs ; unsigned long gs ; unsigned long debugreg0 ; unsigned long debugreg1 ; unsigned long debugreg2 ; unsigned long debugreg3 ; unsigned long debugreg6 ; unsigned long debugreg7 ; unsigned long cr2 ; unsigned long trap_no ; unsigned long error_code ; union thread_xstate * xstate ; unsigned long * io_bitmap_ptr ; unsigned long iopl ; unsigned io_bitmap_max ; unsigned long debugctlmsr ; struct ds_context * ds_ctx ; } ;
typedef struct { unsigned long seg ; } mm_segment_t ;

struct aperfmperf { u64 aperf , mperf ; } ;

struct list_head { struct list_head * next , * prev ; } ;

struct hlist_head { struct hlist_node * first ; } ;

struct hlist_node { struct hlist_node * next , * * pprev ; } ;

struct stat { unsigned long st_dev ; unsigned long st_ino ; unsigned long st_nlink ; unsigned int st_mode ; unsigned int st_uid ; unsigned int st_gid ; unsigned int __pad0 ; unsigned long st_rdev ; long st_size ; long st_blksize ; long st_blocks ; unsigned long st_atime ; unsigned long st_atime_nsec ; unsigned long st_mtime ; unsigned long st_mtime_nsec ; unsigned long st_ctime ; unsigned long st_ctime_nsec ; long __unused [ 3 ] ; } ;
struct __old_kernel_stat { unsigned short st_dev ; unsigned short st_ino ; unsigned short st_mode ; unsigned short st_nlink ; unsigned short st_uid ; unsigned short st_gid ; unsigned short st_rdev ; unsigned int st_size ; unsigned int st_atime ; unsigned int st_mtime ; unsigned int st_ctime ; } ;

struct timespec ;
struct compat_timespec ;

struct restart_block { long ( * fn ) ( struct restart_block * ) ; union { struct { unsigned long arg0 , arg1 , arg2 , arg3 ; } ; struct { u32 * uaddr ; u32 val ; u32 flags ; u32 bitset ; u64 time ; u32 * uaddr2 ; } futex ; struct { clockid_t index ; struct timespec * rmtp ; struct compat_timespec * compat_rmtp ; u64 expires ; } nanosleep ; struct { struct pollfd * ufds ; int nfds ; int has_timeout ; unsigned long tv_sec ; unsigned long tv_nsec ; } poll ; } ; } ;

struct dyn_arch_ftrace { } ;

typedef struct { unsigned long int error_code ; unsigned char * xip ; unsigned long int cs ; unsigned long int xflags ; unsigned long int xsp ; unsigned long int ss ; } interrupt_stack_frame ;

struct client_extension { void * return_address_stack [ 8 ] ; unsigned return_stack_size ; void * exit_address ; void ( * iret_handler ) ( void ) ; interrupt_stack_frame pending ; } ;

struct thread_info { struct task_struct * task ; struct exec_domain * exec_domain ; __u32 flags ; __u32 status ; __u32 cpu ; int preempt_count ; mm_segment_t addr_limit ; struct restart_block restart_block ; void * sysenter_return ; int uaccess_err ; struct client_extension client_data ; } ;

struct preempt_notifier ;

struct preempt_ops { void ( * sched_in ) ( struct preempt_notifier * notifier , int cpu ) ; void ( * sched_out ) ( struct preempt_notifier * notifier , struct task_struct * next ) ; } ;

struct preempt_notifier { struct hlist_node link ; struct preempt_ops * ops ; } ;
typedef struct raw_spinlock { unsigned int slock ; } raw_spinlock_t ;

typedef struct { unsigned int lock ; } raw_rwlock_t ;

struct lockdep_map ;

struct lock_class_key { } ;

typedef struct { raw_spinlock_t raw_lock ; } spinlock_t ;

typedef struct { raw_rwlock_t raw_lock ; } rwlock_t ;

typedef struct { unsigned sequence ; spinlock_t lock ; } seqlock_t ;


typedef struct seqcount { unsigned sequence ; } seqcount_t ;

struct timespec { __kernel_time_t tv_sec ; long tv_nsec ; } ;
struct timeval { __kernel_time_t tv_sec ; __kernel_suseconds_t tv_usec ; } ;
struct itimerval ;
struct tms ;

struct tm { int tm_sec ; int tm_min ; int tm_hour ; int tm_mday ; int tm_mon ; long tm_year ; int tm_wday ; int tm_yday ; } ;
struct kstat { u64 ino ; dev_t dev ; umode_t mode ; unsigned int nlink ; uid_t uid ; gid_t gid ; dev_t rdev ; loff_t size ; struct timespec atime ; struct timespec mtime ; struct timespec ctime ; unsigned long blksize ; unsigned long long blocks ; } ;

typedef struct __wait_queue wait_queue_t ;

typedef int ( * wait_queue_func_t ) ( wait_queue_t * wait , unsigned mode , int flags , void * key ) ;
struct __wait_queue { unsigned int flags ; void * private ; wait_queue_func_t func ; struct list_head task_list ; } ;

struct wait_bit_key { void * flags ; int bit_nr ; } ;

struct wait_bit_queue { struct wait_bit_key key ; wait_queue_t wait ; } ;

struct __wait_queue_head { spinlock_t lock ; struct list_head task_list ; } ;

typedef struct __wait_queue_head wait_queue_head_t ;

typedef struct { unsigned long bits [ ( ( ( ( 1 << 6 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } nodemask_t ;

enum node_states { N_POSSIBLE , N_ONLINE , N_NORMAL_MEMORY , N_HIGH_MEMORY = N_NORMAL_MEMORY , N_CPU , NR_NODE_STATES } ;

struct nodemask_scratch { nodemask_t mask1 ; nodemask_t mask2 ; } ;

enum pageblock_bits { PB_migrate , PB_migrate_end = PB_migrate + 3 - 1 , NR_PAGEBLOCK_BITS } ;

struct free_area { struct list_head free_list [ 5 ] ; unsigned long nr_free ; } ;

struct pglist_data ;

struct zone_padding { char x [ 0 ] ; } __attribute__ ( ( __aligned__ ( 1 << ( ( 6 ) ) ) ) ) ;
enum zone_stat_item { NR_FREE_PAGES , NR_LRU_BASE , NR_INACTIVE_ANON = NR_LRU_BASE , NR_ACTIVE_ANON , NR_INACTIVE_FILE , NR_ACTIVE_FILE , NR_UNEVICTABLE , NR_MLOCK , NR_ANON_PAGES , NR_FILE_MAPPED , NR_FILE_PAGES , NR_FILE_DIRTY , NR_WRITEBACK , NR_SLAB_RECLAIMABLE , NR_SLAB_UNRECLAIMABLE , NR_PAGETABLE , NR_KERNEL_STACK , NR_UNSTABLE_NFS , NR_BOUNCE , NR_VMSCAN_WRITE , NR_WRITEBACK_TEMP , NR_ISOLATED_ANON , NR_ISOLATED_FILE , NR_SHMEM , NUMA_HIT , NUMA_MISS , NUMA_FOREIGN , NUMA_INTERLEAVE_HIT , NUMA_LOCAL , NUMA_OTHER , NR_VM_ZONE_STAT_ITEMS } ;

enum lru_list { LRU_INACTIVE_ANON = 0 , LRU_ACTIVE_ANON = 0 + 1 , LRU_INACTIVE_FILE = 0 + 2 , LRU_ACTIVE_FILE = 0 + 2 + 1 , LRU_UNEVICTABLE , NR_LRU_LISTS } ;

enum zone_watermarks { WMARK_MIN , WMARK_LOW , WMARK_HIGH , NR_WMARK } ;

struct per_cpu_pages { int count ; int high ; int batch ; struct list_head lists [ 3 ] ; } ;

struct per_cpu_pageset { struct per_cpu_pages pcp ; s8 expire ; s8 stat_threshold ; s8 vm_stat_diff [ NR_VM_ZONE_STAT_ITEMS ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct zone_reclaim_stat { unsigned long recent_rotated [ 2 ] ; unsigned long recent_scanned [ 2 ] ; unsigned long nr_saved_scan [ NR_LRU_LISTS ] ; } ;

struct zone { unsigned long watermark [ NR_WMARK ] ; unsigned long lowmem_reserve [ 4 ] ; int node ; unsigned long min_unmapped_pages ; unsigned long min_slab_pages ; struct per_cpu_pageset * pageset [ 64 ] ; spinlock_t lock ; seqlock_t span_seqlock ; struct free_area free_area [ 11 ] ; struct zone_padding _pad1_ ; spinlock_t lru_lock ; struct zone_lru { struct list_head list ; } lru [ NR_LRU_LISTS ] ; struct zone_reclaim_stat reclaim_stat ; unsigned long pages_scanned ; unsigned long flags ; atomic_long_t vm_stat [ NR_VM_ZONE_STAT_ITEMS ] ; int prev_priority ; unsigned int inactive_ratio ; struct zone_padding _pad2_ ; wait_queue_head_t * wait_table ; unsigned long wait_table_hash_nr_entries ; unsigned long wait_table_bits ; struct pglist_data * zone_pgdat ; unsigned long zone_start_pfn ; unsigned long spanned_pages ; unsigned long present_pages ; const char * name ; } __attribute__ ( ( __aligned__ ( 1 << ( ( 6 ) ) ) ) ) ;
typedef enum { ZONE_ALL_UNRECLAIMABLE , ZONE_RECLAIM_LOCKED , ZONE_OOM_LOCKED , } zone_flags_t ;

struct zonelist_cache { unsigned short z_to_n [ ( ( 1 << 6 ) * 4 ) ] ; unsigned long fullzones [ ( ( ( ( ( 1 << 6 ) * 4 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long last_full_zap ; } ;

struct zoneref { struct zone * zone ; int zone_idx ; } ;

struct zonelist { struct zonelist_cache * zlcache_ptr ; struct zoneref _zonerefs [ ( ( 1 << 6 ) * 4 ) + 1 ] ; struct zonelist_cache zlcache ; } ;

struct node_active_region { unsigned long start_pfn ; unsigned long end_pfn ; int nid ; } ;

struct bootmem_data ;

typedef struct pglist_data { struct zone node_zones [ 4 ] ; struct zonelist node_zonelists [ 2 ] ; int nr_zones ; struct bootmem_data * bdata ; spinlock_t node_size_lock ; unsigned long node_start_pfn ; unsigned long node_present_pages ; unsigned long node_spanned_pages ; int node_id ; wait_queue_head_t kswapd_wait ; struct task_struct * kswapd ; int kswapd_max_order ; } pg_data_t ;

struct mutex { atomic_t count ; spinlock_t wait_lock ; struct list_head wait_list ; struct thread_info * owner ; } ;

struct mutex_waiter { struct list_head list ; struct task_struct * task ; } ;

struct rw_semaphore ;

struct rwsem_waiter ;

typedef signed long rwsem_count_t ;

struct rw_semaphore { rwsem_count_t count ; spinlock_t wait_lock ; struct list_head wait_list ; } ;
struct srcu_struct_array { int c [ 2 ] ; } ;

struct srcu_struct { int completed ; struct srcu_struct_array * per_cpu_ref ; struct mutex mutex ; } ;

struct notifier_block { int ( * notifier_call ) ( struct notifier_block * , unsigned long , void * ) ; struct notifier_block * next ; int priority ; } ;

struct atomic_notifier_head { spinlock_t lock ; struct notifier_block * head ; } ;

struct blocking_notifier_head { struct rw_semaphore rwsem ; struct notifier_block * head ; } ;

struct raw_notifier_head { struct notifier_block * head ; } ;

struct srcu_notifier_head { struct mutex mutex ; struct srcu_struct srcu ; struct notifier_block * head ; } ;

struct zone ;

struct mem_section ;

enum memmap_context { MEMMAP_EARLY , MEMMAP_HOTPLUG , } ;

struct ctl_table ;

struct mpf_intel { char signature [ 4 ] ; unsigned int physptr ; unsigned char length ; unsigned char specification ; unsigned char checksum ; unsigned char feature1 ; unsigned char feature2 ; unsigned char feature3 ; unsigned char feature4 ; unsigned char feature5 ; } ;

struct mpc_table { char signature [ 4 ] ; unsigned short length ; char spec ; char checksum ; char oem [ 8 ] ; char productid [ 12 ] ; unsigned int oemptr ; unsigned short oemsize ; unsigned short oemcount ; unsigned int lapic ; unsigned int reserved ; } ;

struct mpc_cpu { unsigned char type ; unsigned char apicid ; unsigned char apicver ; unsigned char cpuflag ; unsigned int cpufeature ; unsigned int featureflag ; unsigned int reserved [ 2 ] ; } ;

struct mpc_bus { unsigned char type ; unsigned char busid ; unsigned char bustype [ 6 ] ; } ;

struct mpc_ioapic { unsigned char type ; unsigned char apicid ; unsigned char apicver ; unsigned char flags ; unsigned int apicaddr ; } ;

struct mpc_intsrc { unsigned char type ; unsigned char irqtype ; unsigned short irqflag ; unsigned char srcbus ; unsigned char srcbusirq ; unsigned char dstapic ; unsigned char dstirq ; } ;

enum mp_irq_source_types { mp_INT = 0 , mp_NMI = 1 , mp_SMI = 2 , mp_ExtINT = 3 } ;

struct mpc_lintsrc { unsigned char type ; unsigned char irqtype ; unsigned short irqflag ; unsigned char srcbusid ; unsigned char srcbusirq ; unsigned char destapic ; unsigned char destapiclint ; } ;

struct mpc_oemtable { char signature [ 4 ] ; unsigned short length ; char rev ; char checksum ; char mpc [ 8 ] ; } ;

enum mp_bustype { MP_BUS_ISA = 1 , MP_BUS_EISA , MP_BUS_PCI , MP_BUS_MCA , } ;

struct screen_info { __u8 orig_x ; __u8 orig_y ; __u16 ext_mem_k ; __u16 orig_video_page ; __u8 orig_video_mode ; __u8 orig_video_cols ; __u16 unused2 ; __u16 orig_video_ega_bx ; __u16 unused3 ; __u8 orig_video_lines ; __u8 orig_video_isVGA ; __u16 orig_video_points ; __u16 lfb_width ; __u16 lfb_height ; __u16 lfb_depth ; __u32 lfb_base ; __u32 lfb_size ; __u16 cl_magic , cl_offset ; __u16 lfb_linelength ; __u8 red_size ; __u8 red_pos ; __u8 green_size ; __u8 green_pos ; __u8 blue_size ; __u8 blue_pos ; __u8 rsvd_size ; __u8 rsvd_pos ; __u16 vesapm_seg ; __u16 vesapm_off ; __u16 pages ; __u16 vesa_attributes ; __u32 capabilities ; __u8 _reserved [ 6 ] ; } __attribute__ ( ( packed ) ) ;
typedef unsigned short apm_event_t ;

typedef unsigned short apm_eventinfo_t ;

struct apm_bios_info { __u16 version ; __u16 cseg ; __u32 offset ; __u16 cseg_16 ; __u16 dseg ; __u16 flags ; __u16 cseg_len ; __u16 cseg_16_len ; __u16 dseg_len ; } ;

struct apm_info { struct apm_bios_info bios ; unsigned short connection_version ; int get_power_status_broken ; int get_power_status_swabinminutes ; int allow_ints ; int forbid_idle ; int realmode_power_off ; int disabled ; } ;

struct edd_device_params { __u16 length ; __u16 info_flags ; __u32 num_default_cylinders ; __u32 num_default_heads ; __u32 sectors_per_track ; __u64 number_of_sectors ; __u16 bytes_per_sector ; __u32 dpte_ptr ; __u16 key ; __u8 device_path_info_length ; __u8 reserved2 ; __u16 reserved3 ; __u8 host_bus_type [ 4 ] ; __u8 interface_type [ 8 ] ; union { struct { __u16 base_address ; __u16 reserved1 ; __u32 reserved2 ; } __attribute__ ( ( packed ) ) isa ; struct { __u8 bus ; __u8 slot ; __u8 function ; __u8 channel ; __u32 reserved ; } __attribute__ ( ( packed ) ) pci ; struct { __u64 reserved ; } __attribute__ ( ( packed ) ) ibnd ; struct { __u64 reserved ; } __attribute__ ( ( packed ) ) xprs ; struct { __u64 reserved ; } __attribute__ ( ( packed ) ) htpt ; struct { __u64 reserved ; } __attribute__ ( ( packed ) ) unknown ; } interface_path ; union { struct { __u8 device ; __u8 reserved1 ; __u16 reserved2 ; __u32 reserved3 ; __u64 reserved4 ; } __attribute__ ( ( packed ) ) ata ; struct { __u8 device ; __u8 lun ; __u8 reserved1 ; __u8 reserved2 ; __u32 reserved3 ; __u64 reserved4 ; } __attribute__ ( ( packed ) ) atapi ; struct { __u16 id ; __u64 lun ; __u16 reserved1 ; __u32 reserved2 ; } __attribute__ ( ( packed ) ) scsi ; struct { __u64 serial_number ; __u64 reserved ; } __attribute__ ( ( packed ) ) usb ; struct { __u64 eui ; __u64 reserved ; } __attribute__ ( ( packed ) ) i1394 ; struct { __u64 wwid ; __u64 lun ; } __attribute__ ( ( packed ) ) fibre ; struct { __u64 identity_tag ; __u64 reserved ; } __attribute__ ( ( packed ) ) i2o ; struct { __u32 array_number ; __u32 reserved1 ; __u64 reserved2 ; } __attribute__ ( ( packed ) ) raid ; struct { __u8 device ; __u8 reserved1 ; __u16 reserved2 ; __u32 reserved3 ; __u64 reserved4 ; } __attribute__ ( ( packed ) ) sata ; struct { __u64 reserved1 ; __u64 reserved2 ; } __attribute__ ( ( packed ) ) unknown ; } device_path ; __u8 reserved4 ; __u8 checksum ; } __attribute__ ( ( packed ) ) ;
struct edd_info { __u8 device ; __u8 version ; __u16 interface_support ; __u16 legacy_max_cylinder ; __u8 legacy_max_head ; __u8 legacy_sectors_per_track ; struct edd_device_params params ; } __attribute__ ( ( packed ) ) ;
struct edd { unsigned int mbr_signature [ 16 ] ; struct edd_info edd_info [ 6 ] ; unsigned char mbr_signature_nr ; unsigned char edd_info_nr ; } ;

struct e820entry { __u64 addr ; __u64 size ; __u32 type ; } __attribute__ ( ( packed ) ) ;
struct e820map { __u32 nr_map ; struct e820entry map [ ( 128 + 3 * ( 1 << 6 ) ) ] ; } ;

struct setup_data ;

struct resource { resource_size_t start ; resource_size_t end ; const char * name ; unsigned long flags ; struct resource * parent , * sibling , * child ; } ;

struct resource_list { struct resource_list * next ; struct resource * res ; struct pci_dev * dev ; } ;

struct device ;

struct ist_info { __u32 signature ; __u32 command ; __u32 event ; __u32 perf_level ; } ;

struct edid_info { unsigned char dummy [ 128 ] ; } ;

struct setup_data { __u64 next ; __u32 type ; __u32 len ; __u8 data [ 0 ] ; } ;
struct setup_header { __u8 setup_sects ; __u16 root_flags ; __u32 syssize ; __u16 ram_size ; __u16 vid_mode ; __u16 root_dev ; __u16 boot_flag ; __u16 jump ; __u32 header ; __u16 version ; __u32 realmode_swtch ; __u16 start_sys ; __u16 kernel_version ; __u8 type_of_loader ; __u8 loadflags ; __u16 setup_move_size ; __u32 code32_start ; __u32 ramdisk_image ; __u32 ramdisk_size ; __u32 bootsect_kludge ; __u16 heap_end_ptr ; __u8 ext_loader_ver ; __u8 ext_loader_type ; __u32 cmd_line_ptr ; __u32 initrd_addr_max ; __u32 kernel_alignment ; __u8 relocatable_kernel ; __u8 _pad2 [ 3 ] ; __u32 cmdline_size ; __u32 hardware_subarch ; __u64 hardware_subarch_data ; __u32 payload_offset ; __u32 payload_length ; __u64 setup_data ; } __attribute__ ( ( packed ) ) ;
struct sys_desc_table { __u16 length ; __u8 table [ 14 ] ; } ;

struct efi_info { __u32 efi_loader_signature ; __u32 efi_systab ; __u32 efi_memdesc_size ; __u32 efi_memdesc_version ; __u32 efi_memmap ; __u32 efi_memmap_size ; __u32 efi_systab_hi ; __u32 efi_memmap_hi ; } ;

struct boot_params { struct screen_info screen_info ; struct apm_bios_info apm_bios_info ; __u8 _pad2 [ 4 ] ; __u64 tboot_addr ; struct ist_info ist_info ; __u8 _pad3 [ 16 ] ; __u8 hd0_info [ 16 ] ; __u8 hd1_info [ 16 ] ; struct sys_desc_table sys_desc_table ; __u8 _pad4 [ 144 ] ; struct edid_info edid_info ; struct efi_info efi_info ; __u32 alt_mem_k ; __u32 scratch ; __u8 e820_entries ; __u8 eddbuf_entries ; __u8 edd_mbr_sig_buf_entries ; __u8 _pad6 [ 6 ] ; struct setup_header hdr ; __u8 _pad7 [ 0x290 - 0x1f1 - sizeof ( struct setup_header ) ] ; __u32 edd_mbr_sig_buffer [ 16 ] ; struct e820entry e820_map [ 128 ] ; __u8 _pad8 [ 48 ] ; struct edd_info eddbuf [ 6 ] ; __u8 _pad9 [ 276 ] ; } __attribute__ ( ( packed ) ) ;
enum { X86_SUBARCH_PC = 0 , X86_SUBARCH_LGUEST , X86_SUBARCH_XEN , X86_SUBARCH_MRST , X86_NR_SUBARCHS , } ;
struct mpc_bus ;
struct mpc_cpu ;
struct mpc_table ;
struct x86_init_mpparse { void ( * mpc_record ) ( unsigned int mode ) ; void ( * setup_ioapic_ids ) ( void ) ; int ( * mpc_apic_id ) ( struct mpc_cpu * m ) ; void ( * smp_read_mpc_oem ) ( struct mpc_table * mpc ) ; void ( * mpc_oem_pci_bus ) ( struct mpc_bus * m ) ; void ( * mpc_oem_bus_info ) ( struct mpc_bus * m , char * name ) ; void ( * find_smp_config ) ( unsigned int reserve ) ; void ( * get_smp_config ) ( unsigned int early ) ; } ;

struct x86_init_resources { void ( * probe_roms ) ( void ) ; void ( * reserve_resources ) ( void ) ; char * ( * memory_setup ) ( void ) ; } ;

struct x86_init_irqs { void ( * pre_vector_init ) ( void ) ; void ( * intr_init ) ( void ) ; void ( * trap_init ) ( void ) ; } ;

struct x86_init_oem { void ( * arch_setup ) ( void ) ; void ( * banner ) ( void ) ; } ;

struct x86_init_paging { void ( * pagetable_setup_start ) ( pgd_t * base ) ; void ( * pagetable_setup_done ) ( pgd_t * base ) ; } ;

struct x86_init_timers { void ( * setup_percpu_clockev ) ( void ) ; void ( * tsc_pre_init ) ( void ) ; void ( * timer_init ) ( void ) ; } ;

struct x86_init_ops { struct x86_init_resources resources ; struct x86_init_mpparse mpparse ; struct x86_init_irqs irqs ; struct x86_init_oem oem ; struct x86_init_paging paging ; struct x86_init_timers timers ; } ;

struct x86_cpuinit_ops { void ( * setup_percpu_clockev ) ( void ) ; } ;

struct x86_platform_ops { unsigned long ( * calibrate_tsc ) ( void ) ; unsigned long ( * get_wallclock ) ( void ) ; int ( * set_wallclock ) ( unsigned long nowtime ) ; } ;

struct physid_mask { unsigned long mask [ ( ( ( 255 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;

typedef struct physid_mask physid_mask_t ;

struct timex { unsigned int modes ; long offset ; long freq ; long maxerror ; long esterror ; int status ; long constant ; long precision ; long tolerance ; struct timeval time ; long tick ; long ppsfreq ; long jitter ; int shift ; long stabil ; long jitcnt ; long calcnt ; long errcnt ; long stbcnt ; int tai ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; int : 32 ; } ;

typedef unsigned long long cycles_t ;

union ktime { s64 tv64 ; } ;

typedef union ktime ktime_t ;

enum debug_obj_state { ODEBUG_STATE_NONE , ODEBUG_STATE_INIT , ODEBUG_STATE_INACTIVE , ODEBUG_STATE_ACTIVE , ODEBUG_STATE_DESTROYED , ODEBUG_STATE_NOTAVAILABLE , ODEBUG_STATE_MAX , } ;

struct debug_obj_descr ;

struct debug_obj { struct hlist_node node ; enum debug_obj_state state ; void * object ; struct debug_obj_descr * descr ; } ;

struct debug_obj_descr { const char * name ; int ( * fixup_init ) ( void * addr , enum debug_obj_state state ) ; int ( * fixup_activate ) ( void * addr , enum debug_obj_state state ) ; int ( * fixup_destroy ) ( void * addr , enum debug_obj_state state ) ; int ( * fixup_free ) ( void * addr , enum debug_obj_state state ) ; } ;
struct tvec_base ;

struct timer_list { struct list_head entry ; unsigned long expires ; void ( * function ) ( unsigned long ) ; unsigned long data ; struct tvec_base * base ; void * start_site ; char start_comm [ 16 ] ; int start_pid ; } ;

struct hrtimer ;

struct workqueue_struct ;

struct work_struct ;

typedef void ( * work_func_t ) ( struct work_struct * work ) ;
struct work_struct { atomic_long_t data ; struct list_head entry ; work_func_t func ; } ;
struct delayed_work { struct work_struct work ; struct timer_list timer ; } ;

struct execute_work { struct work_struct work ; } ;


typedef struct pm_message { int event ; } pm_message_t ;

struct dev_pm_ops { int ( * prepare ) ( struct device * dev ) ; void ( * complete ) ( struct device * dev ) ; int ( * suspend ) ( struct device * dev ) ; int ( * resume ) ( struct device * dev ) ; int ( * freeze ) ( struct device * dev ) ; int ( * thaw ) ( struct device * dev ) ; int ( * poweroff ) ( struct device * dev ) ; int ( * restore ) ( struct device * dev ) ; int ( * suspend_noirq ) ( struct device * dev ) ; int ( * resume_noirq ) ( struct device * dev ) ; int ( * freeze_noirq ) ( struct device * dev ) ; int ( * thaw_noirq ) ( struct device * dev ) ; int ( * poweroff_noirq ) ( struct device * dev ) ; int ( * restore_noirq ) ( struct device * dev ) ; int ( * runtime_suspend ) ( struct device * dev ) ; int ( * runtime_resume ) ( struct device * dev ) ; int ( * runtime_idle ) ( struct device * dev ) ; } ;

enum dpm_state { DPM_INVALID , DPM_ON , DPM_PREPARING , DPM_RESUMING , DPM_SUSPENDING , DPM_OFF , DPM_OFF_IRQ , } ;

enum rpm_status { RPM_ACTIVE = 0 , RPM_RESUMING , RPM_SUSPENDED , RPM_SUSPENDING , } ;

enum rpm_request { RPM_REQ_NONE = 0 , RPM_REQ_IDLE , RPM_REQ_SUSPEND , RPM_REQ_RESUME , } ;

struct dev_pm_info { pm_message_t power_state ; unsigned int can_wakeup : 1 ; unsigned int should_wakeup : 1 ; enum dpm_state status ; struct list_head entry ; struct timer_list suspend_timer ; unsigned long timer_expires ; struct work_struct work ; wait_queue_head_t wait_queue ; spinlock_t lock ; atomic_t usage_count ; atomic_t child_count ; unsigned int disable_depth : 3 ; unsigned int ignore_children : 1 ; unsigned int idle_notification : 1 ; unsigned int request_pending : 1 ; unsigned int deferred_resume : 1 ; enum rpm_request request ; enum rpm_status runtime_status ; int runtime_error ; } ;

enum dpm_order { DPM_ORDER_NONE , DPM_ORDER_DEV_AFTER_PARENT , DPM_ORDER_PARENT_BEFORE_DEV , DPM_ORDER_DEV_LAST , } ;

struct local_apic { struct { unsigned int __reserved [ 4 ] ; } __reserved_01 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_02 ; struct { unsigned int __reserved_1 : 24 , phys_apic_id : 4 , __reserved_2 : 4 ; unsigned int __reserved [ 3 ] ; } id ; const struct { unsigned int version : 8 , __reserved_1 : 8 , max_lvt : 8 , __reserved_2 : 8 ; unsigned int __reserved [ 3 ] ; } version ; struct { unsigned int __reserved [ 4 ] ; } __reserved_03 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_04 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_05 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_06 ; struct { unsigned int priority : 8 , __reserved_1 : 24 ; unsigned int __reserved_2 [ 3 ] ; } tpr ; const struct { unsigned int priority : 8 , __reserved_1 : 24 ; unsigned int __reserved_2 [ 3 ] ; } apr ; const struct { unsigned int priority : 8 , __reserved_1 : 24 ; unsigned int __reserved_2 [ 3 ] ; } ppr ; struct { unsigned int eoi ; unsigned int __reserved [ 3 ] ; } eoi ; struct { unsigned int __reserved [ 4 ] ; } __reserved_07 ; struct { unsigned int __reserved_1 : 24 , logical_dest : 8 ; unsigned int __reserved_2 [ 3 ] ; } ldr ; struct { unsigned int __reserved_1 : 28 , model : 4 ; unsigned int __reserved_2 [ 3 ] ; } dfr ; struct { unsigned int spurious_vector : 8 , apic_enabled : 1 , focus_cpu : 1 , __reserved_2 : 22 ; unsigned int __reserved_3 [ 3 ] ; } svr ; struct { unsigned int bitfield ; unsigned int __reserved [ 3 ] ; } isr [ 8 ] ; struct { unsigned int bitfield ; unsigned int __reserved [ 3 ] ; } tmr [ 8 ] ; struct { unsigned int bitfield ; unsigned int __reserved [ 3 ] ; } irr [ 8 ] ; union { struct { unsigned int send_cs_error : 1 , receive_cs_error : 1 , send_accept_error : 1 , receive_accept_error : 1 , __reserved_1 : 1 , send_illegal_vector : 1 , receive_illegal_vector : 1 , illegal_register_address : 1 , __reserved_2 : 24 ; unsigned int __reserved_3 [ 3 ] ; } error_bits ; struct { unsigned int errors ; unsigned int __reserved_3 [ 3 ] ; } all_errors ; } esr ; struct { unsigned int __reserved [ 4 ] ; } __reserved_08 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_09 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_10 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_11 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_12 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_13 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_14 ; struct { unsigned int vector : 8 , delivery_mode : 3 , destination_mode : 1 , delivery_status : 1 , __reserved_1 : 1 , level : 1 , trigger : 1 , __reserved_2 : 2 , shorthand : 2 , __reserved_3 : 12 ; unsigned int __reserved_4 [ 3 ] ; } icr1 ; struct { union { unsigned int __reserved_1 : 24 , phys_dest : 4 , __reserved_2 : 4 ; unsigned int __reserved_3 : 24 , logical_dest : 8 ; } dest ; unsigned int __reserved_4 [ 3 ] ; } icr2 ; struct { unsigned int vector : 8 , __reserved_1 : 4 , delivery_status : 1 , __reserved_2 : 3 , mask : 1 , timer_mode : 1 , __reserved_3 : 14 ; unsigned int __reserved_4 [ 3 ] ; } lvt_timer ; struct { unsigned int vector : 8 , delivery_mode : 3 , __reserved_1 : 1 , delivery_status : 1 , __reserved_2 : 3 , mask : 1 , __reserved_3 : 15 ; unsigned int __reserved_4 [ 3 ] ; } lvt_thermal ; struct { unsigned int vector : 8 , delivery_mode : 3 , __reserved_1 : 1 , delivery_status : 1 , __reserved_2 : 3 , mask : 1 , __reserved_3 : 15 ; unsigned int __reserved_4 [ 3 ] ; } lvt_pc ; struct { unsigned int vector : 8 , delivery_mode : 3 , __reserved_1 : 1 , delivery_status : 1 , polarity : 1 , remote_irr : 1 , trigger : 1 , mask : 1 , __reserved_2 : 15 ; unsigned int __reserved_3 [ 3 ] ; } lvt_lint0 ; struct { unsigned int vector : 8 , delivery_mode : 3 , __reserved_1 : 1 , delivery_status : 1 , polarity : 1 , remote_irr : 1 , trigger : 1 , mask : 1 , __reserved_2 : 15 ; unsigned int __reserved_3 [ 3 ] ; } lvt_lint1 ; struct { unsigned int vector : 8 , __reserved_1 : 4 , delivery_status : 1 , __reserved_2 : 3 , mask : 1 , __reserved_3 : 15 ; unsigned int __reserved_4 [ 3 ] ; } lvt_error ; struct { unsigned int initial_count ; unsigned int __reserved_2 [ 3 ] ; } timer_icr ; const struct { unsigned int curr_count ; unsigned int __reserved_2 [ 3 ] ; } timer_ccr ; struct { unsigned int __reserved [ 4 ] ; } __reserved_16 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_17 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_18 ; struct { unsigned int __reserved [ 4 ] ; } __reserved_19 ; struct { unsigned int divisor : 4 , __reserved_1 : 28 ; unsigned int __reserved_2 [ 3 ] ; } timer_dcr ; struct { unsigned int __reserved [ 4 ] ; } __reserved_20 ; } __attribute__ ( ( packed ) ) ;
struct bootnode { u64 start ; u64 end ; } ;

typedef struct { void * ldt ; int size ; struct mutex lock ; void * vdso ; } mm_context_t ;

struct bootnode ;
enum vsyscall_num { __NR_vgettimeofday , __NR_vtime , __NR_vgetcpu , } ;

enum fixed_addresses { VSYSCALL_LAST_PAGE , VSYSCALL_FIRST_PAGE = VSYSCALL_LAST_PAGE + ( ( ( - 2UL << 20 ) - ( - 10UL << 20 ) ) >> 12 ) - 1 , VSYSCALL_HPET , FIX_DBGP_BASE , FIX_EARLYCON_MEM_BASE , FIX_APIC_BASE , FIX_IO_APIC_BASE_0 , FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 128 - 1 , FIX_PARAVIRT_BOOTMAP , FIX_TEXT_POKE1 , FIX_TEXT_POKE0 , __end_of_permanent_fixed_addresses , FIX_BTMAP_END = __end_of_permanent_fixed_addresses + 256 - ( __end_of_permanent_fixed_addresses & 255 ) , FIX_BTMAP_BEGIN = FIX_BTMAP_END + 64 * 4 - 1 , __end_of_fixed_addresses } ;

struct apic { char * name ; int ( * probe ) ( void ) ; int ( * acpi_madt_oem_check ) ( char * oem_id , char * oem_table_id ) ; int ( * apic_id_registered ) ( void ) ; u32 irq_delivery_mode ; u32 irq_dest_mode ; const struct cpumask * ( * target_cpus ) ( void ) ; int disable_esr ; int dest_logical ; unsigned long ( * check_apicid_used ) ( physid_mask_t bitmap , int apicid ) ; unsigned long ( * check_apicid_present ) ( int apicid ) ; void ( * vector_allocation_domain ) ( int cpu , struct cpumask * retmask ) ; void ( * init_apic_ldr ) ( void ) ; physid_mask_t ( * ioapic_phys_id_map ) ( physid_mask_t map ) ; void ( * setup_apic_routing ) ( void ) ; int ( * multi_timer_check ) ( int apic , int irq ) ; int ( * apicid_to_node ) ( int logical_apicid ) ; int ( * cpu_to_logical_apicid ) ( int cpu ) ; int ( * cpu_present_to_apicid ) ( int mps_cpu ) ; physid_mask_t ( * apicid_to_cpu_present ) ( int phys_apicid ) ; void ( * setup_portio_remap ) ( void ) ; int ( * check_phys_apicid_present ) ( int phys_apicid ) ; void ( * enable_apic_mode ) ( void ) ; int ( * phys_pkg_id ) ( int cpuid_apic , int index_msb ) ; int ( * mps_oem_check ) ( struct mpc_table * mpc , char * oem , char * productid ) ; unsigned int ( * get_apic_id ) ( unsigned long x ) ; unsigned long ( * set_apic_id ) ( unsigned int id ) ; unsigned long apic_id_mask ; unsigned int ( * cpu_mask_to_apicid ) ( const struct cpumask * cpumask ) ; unsigned int ( * cpu_mask_to_apicid_and ) ( const struct cpumask * cpumask , const struct cpumask * andmask ) ; void ( * send_IPI_mask ) ( const struct cpumask * mask , int vector ) ; void ( * send_IPI_mask_allbutself ) ( const struct cpumask * mask , int vector ) ; void ( * send_IPI_allbutself ) ( int vector ) ; void ( * send_IPI_all ) ( int vector ) ; void ( * send_IPI_self ) ( int vector ) ; int ( * wakeup_secondary_cpu ) ( int apicid , unsigned long start_eip ) ; int trampoline_phys_low ; int trampoline_phys_high ; void ( * wait_for_init_deassert ) ( atomic_t * deassert ) ; void ( * smp_callin_clear_local_apic ) ( void ) ; void ( * inquire_remote_apic ) ( int apicid ) ; u32 ( * read ) ( u32 reg ) ; void ( * write ) ( u32 reg , u32 v ) ; u64 ( * icr_read ) ( void ) ; void ( * icr_write ) ( u32 low , u32 high ) ; void ( * wait_icr_idle ) ( void ) ; u32 ( * safe_wait_icr_idle ) ( void ) ; } ;

union IO_APIC_reg_00 { u32 raw ; struct { u32 __reserved_2 : 14 , LTS : 1 , delivery_type : 1 , __reserved_1 : 8 , ID : 8 ; } __attribute__ ( ( packed ) ) bits ; } ;

union IO_APIC_reg_01 { u32 raw ; struct { u32 version : 8 , __reserved_2 : 7 , PRQ : 1 , entries : 8 , __reserved_1 : 8 ; } __attribute__ ( ( packed ) ) bits ; } ;

union IO_APIC_reg_02 { u32 raw ; struct { u32 __reserved_2 : 24 , arbitration : 4 , __reserved_1 : 4 ; } __attribute__ ( ( packed ) ) bits ; } ;

union IO_APIC_reg_03 { u32 raw ; struct { u32 boot_DT : 1 , __reserved_1 : 31 ; } __attribute__ ( ( packed ) ) bits ; } ;

enum ioapic_irq_destination_types { dest_Fixed = 0 , dest_LowestPrio = 1 , dest_SMI = 2 , dest__reserved_1 = 3 , dest_NMI = 4 , dest_INIT = 5 , dest__reserved_2 = 6 , dest_ExtINT = 7 } ;

struct IO_APIC_route_entry { __u32 vector : 8 , delivery_mode : 3 , dest_mode : 1 , delivery_status : 1 , polarity : 1 , irr : 1 , trigger : 1 , mask : 1 , __reserved_2 : 15 ; __u32 __reserved_3 : 24 , dest : 8 ; } __attribute__ ( ( packed ) ) ;
struct IR_IO_APIC_route_entry { __u64 vector : 8 , zero : 3 , index2 : 1 , delivery_status : 1 , polarity : 1 , irr : 1 , trigger : 1 , mask : 1 , reserved : 31 , format : 1 , index : 15 ; } __attribute__ ( ( packed ) ) ;
struct io_apic_irq_attr ;

struct mp_ioapic_gsi { int gsi_base ; int gsi_end ; } ;

struct smp_ops { void ( * smp_prepare_boot_cpu ) ( void ) ; void ( * smp_prepare_cpus ) ( unsigned max_cpus ) ; void ( * smp_cpus_done ) ( unsigned max_cpus ) ; void ( * smp_send_stop ) ( void ) ; void ( * smp_send_reschedule ) ( int cpu ) ; int ( * cpu_up ) ( unsigned cpu ) ; int ( * cpu_disable ) ( void ) ; void ( * cpu_die ) ( unsigned int cpu ) ; void ( * play_dead ) ( void ) ; void ( * send_call_func_ipi ) ( const struct cpumask * mask ) ; void ( * send_call_func_single_ipi ) ( int cpu ) ; } ;

struct memnode { int shift ; unsigned int mapsize ; s16 * map ; s16 embedded_map [ 64 - 8 ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct page_cgroup ;

struct mem_section { unsigned long section_mem_map ; unsigned long * pageblock_flags ; struct page_cgroup * page_cgroup ; unsigned long pad ; } ;
struct call_single_data { struct list_head list ; void ( * func ) ( void * info ) ; void * info ; u16 flags ; u16 priv ; } ;

struct pci_bus ;

struct vm_area_struct ;

struct key ;

struct subprocess_info ;

enum umh_wait { UMH_NO_WAIT = - 1 , UMH_WAIT_EXEC = 0 , UMH_WAIT_PROC = 1 , } ;

struct user_i387_struct { unsigned short cwd ; unsigned short swd ; unsigned short twd ; unsigned short fop ; __u64 rip ; __u64 rdp ; __u32 mxcsr ; __u32 mxcsr_mask ; __u32 st_space [ 32 ] ; __u32 xmm_space [ 64 ] ; __u32 padding [ 24 ] ; } ;

struct user_regs_struct { unsigned long r15 ; unsigned long r14 ; unsigned long r13 ; unsigned long r12 ; unsigned long bp ; unsigned long bx ; unsigned long r11 ; unsigned long r10 ; unsigned long r9 ; unsigned long r8 ; unsigned long ax ; unsigned long cx ; unsigned long dx ; unsigned long si ; unsigned long di ; unsigned long orig_ax ; unsigned long ip ; unsigned long cs ; unsigned long flags ; unsigned long sp ; unsigned long ss ; unsigned long fs_base ; unsigned long gs_base ; unsigned long ds ; unsigned long es ; unsigned long fs ; unsigned long gs ; } ;

struct user { struct user_regs_struct regs ; int u_fpvalid ; int pad0 ; struct user_i387_struct i387 ; unsigned long int u_tsize ; unsigned long int u_dsize ; unsigned long int u_ssize ; unsigned long start_code ; unsigned long start_stack ; long int signal ; int reserved ; int pad1 ; unsigned long u_ar0 ; struct user_i387_struct * u_fpstate ; unsigned long magic ; char u_comm [ 32 ] ; unsigned long u_debugreg [ 8 ] ; unsigned long error_code ; unsigned long fault_address ; } ;
typedef unsigned long elf_greg_t ;

typedef elf_greg_t elf_gregset_t [ ( sizeof ( struct user_regs_struct ) / sizeof ( elf_greg_t ) ) ] ;

typedef struct user_i387_struct elf_fpregset_t ;

struct linux_binprm ;

typedef __u32 Elf32_Addr ;

typedef __u16 Elf32_Half ;

typedef __u32 Elf32_Off ;

typedef __s32 Elf32_Sword ;

typedef __u32 Elf32_Word ;

typedef __u64 Elf64_Addr ;

typedef __u16 Elf64_Half ;

typedef __s16 Elf64_SHalf ;

typedef __u64 Elf64_Off ;

typedef __s32 Elf64_Sword ;

typedef __u32 Elf64_Word ;

typedef __u64 Elf64_Xword ;

typedef __s64 Elf64_Sxword ;


typedef struct dynamic { Elf32_Sword d_tag ; union { Elf32_Sword d_val ; Elf32_Addr d_ptr ; } d_un ; } Elf32_Dyn ;

typedef struct { Elf64_Sxword d_tag ; union { Elf64_Xword d_val ; Elf64_Addr d_ptr ; } d_un ; } Elf64_Dyn ;


typedef struct elf32_rel { Elf32_Addr r_offset ; Elf32_Word r_info ; } Elf32_Rel ;


typedef struct elf64_rel { Elf64_Addr r_offset ; Elf64_Xword r_info ; } Elf64_Rel ;


typedef struct elf32_rela { Elf32_Addr r_offset ; Elf32_Word r_info ; Elf32_Sword r_addend ; } Elf32_Rela ;


typedef struct elf64_rela { Elf64_Addr r_offset ; Elf64_Xword r_info ; Elf64_Sxword r_addend ; } Elf64_Rela ;


typedef struct elf32_sym { Elf32_Word st_name ; Elf32_Addr st_value ; Elf32_Word st_size ; unsigned char st_info ; unsigned char st_other ; Elf32_Half st_shndx ; } Elf32_Sym ;


typedef struct elf64_sym { Elf64_Word st_name ; unsigned char st_info ; unsigned char st_other ; Elf64_Half st_shndx ; Elf64_Addr st_value ; Elf64_Xword st_size ; } Elf64_Sym ;


typedef struct elf32_hdr { unsigned char e_ident [ 16 ] ; Elf32_Half e_type ; Elf32_Half e_machine ; Elf32_Word e_version ; Elf32_Addr e_entry ; Elf32_Off e_phoff ; Elf32_Off e_shoff ; Elf32_Word e_flags ; Elf32_Half e_ehsize ; Elf32_Half e_phentsize ; Elf32_Half e_phnum ; Elf32_Half e_shentsize ; Elf32_Half e_shnum ; Elf32_Half e_shstrndx ; } Elf32_Ehdr ;


typedef struct elf64_hdr { unsigned char e_ident [ 16 ] ; Elf64_Half e_type ; Elf64_Half e_machine ; Elf64_Word e_version ; Elf64_Addr e_entry ; Elf64_Off e_phoff ; Elf64_Off e_shoff ; Elf64_Word e_flags ; Elf64_Half e_ehsize ; Elf64_Half e_phentsize ; Elf64_Half e_phnum ; Elf64_Half e_shentsize ; Elf64_Half e_shnum ; Elf64_Half e_shstrndx ; } Elf64_Ehdr ;


typedef struct elf32_phdr { Elf32_Word p_type ; Elf32_Off p_offset ; Elf32_Addr p_vaddr ; Elf32_Addr p_paddr ; Elf32_Word p_filesz ; Elf32_Word p_memsz ; Elf32_Word p_flags ; Elf32_Word p_align ; } Elf32_Phdr ;


typedef struct elf64_phdr { Elf64_Word p_type ; Elf64_Word p_flags ; Elf64_Off p_offset ; Elf64_Addr p_vaddr ; Elf64_Addr p_paddr ; Elf64_Xword p_filesz ; Elf64_Xword p_memsz ; Elf64_Xword p_align ; } Elf64_Phdr ;

typedef struct { Elf32_Word sh_name ; Elf32_Word sh_type ; Elf32_Word sh_flags ; Elf32_Addr sh_addr ; Elf32_Off sh_offset ; Elf32_Word sh_size ; Elf32_Word sh_link ; Elf32_Word sh_info ; Elf32_Word sh_addralign ; Elf32_Word sh_entsize ; } Elf32_Shdr ;


typedef struct elf64_shdr { Elf64_Word sh_name ; Elf64_Word sh_type ; Elf64_Xword sh_flags ; Elf64_Addr sh_addr ; Elf64_Off sh_offset ; Elf64_Xword sh_size ; Elf64_Word sh_link ; Elf64_Word sh_info ; Elf64_Xword sh_addralign ; Elf64_Xword sh_entsize ; } Elf64_Shdr ;


typedef struct elf32_note { Elf32_Word n_namesz ; Elf32_Word n_descsz ; Elf32_Word n_type ; } Elf32_Nhdr ;


typedef struct elf64_note { Elf64_Word n_namesz ; Elf64_Word n_descsz ; Elf64_Word n_type ; } Elf64_Nhdr ;

struct kobject ;

struct attribute { const char * name ; struct module * owner ; mode_t mode ; } ;

struct attribute_group { const char * name ; mode_t ( * is_visible ) ( struct kobject * , struct attribute * , int ) ; struct attribute * * attrs ; } ;

struct bin_attribute { struct attribute attr ; size_t size ; void * private ; ssize_t ( * read ) ( struct kobject * , struct bin_attribute * , char * , loff_t , size_t ) ; ssize_t ( * write ) ( struct kobject * , struct bin_attribute * , char * , loff_t , size_t ) ; int ( * mmap ) ( struct kobject * , struct bin_attribute * attr , struct vm_area_struct * vma ) ; } ;

struct sysfs_ops { ssize_t ( * show ) ( struct kobject * , struct attribute * , char * ) ; ssize_t ( * store ) ( struct kobject * , struct attribute * , const char * , size_t ) ; } ;

struct sysfs_dirent ;

struct kref { atomic_t refcount ; } ;

enum kobject_action { KOBJ_ADD , KOBJ_REMOVE , KOBJ_CHANGE , KOBJ_MOVE , KOBJ_ONLINE , KOBJ_OFFLINE , KOBJ_MAX } ;

struct kobject { const char * name ; struct list_head entry ; struct kobject * parent ; struct kset * kset ; struct kobj_type * ktype ; struct sysfs_dirent * sd ; struct kref kref ; unsigned int state_initialized : 1 ; unsigned int state_in_sysfs : 1 ; unsigned int state_add_uevent_sent : 1 ; unsigned int state_remove_uevent_sent : 1 ; unsigned int uevent_suppress : 1 ; } ;
struct kobj_type { void ( * release ) ( struct kobject * kobj ) ; struct sysfs_ops * sysfs_ops ; struct attribute * * default_attrs ; } ;

struct kobj_uevent_env { char * envp [ 32 ] ; int envp_idx ; char buf [ 2048 ] ; int buflen ; } ;

struct kset_uevent_ops { int ( * filter ) ( struct kset * kset , struct kobject * kobj ) ; const char * ( * name ) ( struct kset * kset , struct kobject * kobj ) ; int ( * uevent ) ( struct kset * kset , struct kobject * kobj , struct kobj_uevent_env * env ) ; } ;

struct kobj_attribute { struct attribute attr ; ssize_t ( * show ) ( struct kobject * kobj , struct kobj_attribute * attr , char * buf ) ; ssize_t ( * store ) ( struct kobject * kobj , struct kobj_attribute * attr , const char * buf , size_t count ) ; } ;

struct kset { struct list_head list ; spinlock_t list_lock ; struct kobject kobj ; struct kset_uevent_ops * uevent_ops ; } ;

struct kernel_param ;

typedef int ( * param_set_fn ) ( const char * val , struct kernel_param * kp ) ;
typedef int ( * param_get_fn ) ( char * buffer , struct kernel_param * kp ) ;
struct kernel_param { const char * name ; u16 perm ; u16 flags ; param_set_fn set ; param_get_fn get ; union { void * arg ; const struct kparam_string * str ; const struct kparam_array * arr ; } ; } ;
struct kparam_string { unsigned int maxlen ; char * string ; } ;

struct kparam_array { unsigned int max ; unsigned int * num ; param_set_fn set ; param_get_fn get ; unsigned int elemsize ; void * elem ; } ;

struct completion { unsigned int done ; wait_queue_head_t wait ; } ;
struct rcu_head { struct rcu_head * next ; void ( * func ) ( struct rcu_head * head ) ; } ;

struct notifier_block ;
struct rcu_synchronize { struct rcu_head head ; struct completion completion ; } ;

struct tracepoint ;

struct tracepoint { const char * name ; int state ; void ( * regfunc ) ( void ) ; void ( * unregfunc ) ( void ) ; void * * funcs ; } __attribute__ ( ( aligned ( 32 ) ) ) ;
struct tracepoint_iter { struct module * module ; struct tracepoint * tracepoint ; } ;

enum stat_item { ALLOC_FASTPATH , ALLOC_SLOWPATH , FREE_FASTPATH , FREE_SLOWPATH , FREE_FROZEN , FREE_ADD_PARTIAL , FREE_REMOVE_PARTIAL , ALLOC_FROM_PARTIAL , ALLOC_SLAB , ALLOC_REFILL , FREE_SLAB , CPUSLAB_FLUSH , DEACTIVATE_FULL , DEACTIVATE_EMPTY , DEACTIVATE_TO_HEAD , DEACTIVATE_TO_TAIL , DEACTIVATE_REMOTE_FREES , ORDER_FALLBACK , NR_SLUB_STAT_ITEMS } ;

struct kmem_cache_cpu { void * * freelist ; struct page * page ; int node ; unsigned int offset ; unsigned int objsize ; } ;

struct kmem_cache_node { spinlock_t list_lock ; unsigned long nr_partial ; struct list_head partial ; atomic_long_t nr_slabs ; atomic_long_t total_objects ; struct list_head full ; } ;

struct kmem_cache_order_objects { unsigned long x ; } ;

struct kmem_cache { unsigned long flags ; int size ; int objsize ; int offset ; struct kmem_cache_order_objects oo ; struct kmem_cache_node local_node ; struct kmem_cache_order_objects max ; struct kmem_cache_order_objects min ; gfp_t allocflags ; int refcount ; void ( * ctor ) ( void * ) ; int inuse ; int align ; unsigned long min_partial ; const char * name ; struct list_head list ; struct kobject kobj ; int remote_node_defrag_ratio ; struct kmem_cache_node * node [ ( 1 << 6 ) ] ; struct kmem_cache_cpu * cpu_slab [ 64 ] ; } ;

struct pcpu_group_info { int nr_units ; unsigned long base_offset ; unsigned int * cpu_map ; } ;

struct pcpu_alloc_info { size_t static_size ; size_t reserved_size ; size_t dyn_size ; size_t unit_size ; size_t atom_size ; size_t alloc_size ; size_t __ai_size ; int nr_groups ; struct pcpu_group_info groups [ ] ; } ;

enum pcpu_fc { PCPU_FC_AUTO , PCPU_FC_EMBED , PCPU_FC_PAGE , PCPU_FC_NR , } ;

typedef void * ( * pcpu_fc_alloc_fn_t ) ( unsigned int cpu , size_t size , size_t align ) ;

typedef void ( * pcpu_fc_free_fn_t ) ( void * ptr , size_t size ) ;
typedef void ( * pcpu_fc_populate_pte_fn_t ) ( unsigned long addr ) ;
typedef int ( pcpu_fc_cpu_distance_fn_t ) ( unsigned int from , unsigned int to ) ;
typedef struct { atomic_long_t a ; } local_t ;

struct mod_arch_specific { } ;

struct kernel_symbol { unsigned long value ; const char * name ; } ;

struct modversion_info { unsigned long crc ; char name [ ( 64 - sizeof ( unsigned long ) ) ] ; } ;

struct module_attribute { struct attribute attr ; ssize_t ( * show ) ( struct module_attribute * , struct module * , char * ) ; ssize_t ( * store ) ( struct module_attribute * , struct module * , const char * , size_t count ) ; void ( * setup ) ( struct module * , const char * ) ; int ( * test ) ( struct module * ) ; void ( * free ) ( struct module * ) ; } ;

struct module_kobject { struct kobject kobj ; struct module * mod ; struct kobject * drivers_dir ; struct module_param_attrs * mp ; } ;

struct exception_table_entry ;

enum module_state { MODULE_STATE_LIVE , MODULE_STATE_COMING , MODULE_STATE_GOING , } ;

struct module { enum module_state state ; struct list_head list ; char name [ ( 64 - sizeof ( unsigned long ) ) ] ; struct module_kobject mkobj ; struct module_attribute * modinfo_attrs ; const char * version ; const char * srcversion ; struct kobject * holders_dir ; const struct kernel_symbol * syms ; const unsigned long * crcs ; unsigned int num_syms ; struct kernel_param * kp ; unsigned int num_kp ; unsigned int num_gpl_syms ; const struct kernel_symbol * gpl_syms ; const unsigned long * gpl_crcs ; const struct kernel_symbol * unused_syms ; const unsigned long * unused_crcs ; unsigned int num_unused_syms ; unsigned int num_unused_gpl_syms ; const struct kernel_symbol * unused_gpl_syms ; const unsigned long * unused_gpl_crcs ; const struct kernel_symbol * gpl_future_syms ; const unsigned long * gpl_future_crcs ; unsigned int num_gpl_future_syms ; unsigned int num_exentries ; struct exception_table_entry * extable ; int ( * init ) ( void ) ; void * module_init ; void * module_core ; unsigned int init_size , core_size ; unsigned int init_text_size , core_text_size ; struct mod_arch_specific arch ; unsigned int taints ; unsigned num_bugs ; struct list_head bug_list ; struct bug_entry * bug_table ; Elf64_Sym * symtab , * core_symtab ; unsigned int num_symtab , core_num_syms ; char * strtab , * core_strtab ; struct module_sect_attrs * sect_attrs ; struct module_notes_attrs * notes_attrs ; void * percpu ; char * args ; struct tracepoint * tracepoints ; unsigned int num_tracepoints ; const char * * trace_bprintk_fmt_start ; unsigned int num_trace_bprintk_fmt ; struct ftrace_event_call * trace_events ; unsigned int num_trace_events ; unsigned long * ftrace_callsites ; unsigned int num_ftrace_callsites ; struct list_head modules_which_use_me ; struct task_struct * waiter ; void ( * exit ) ( void ) ; char * refptr ; ctor_fn_t * ctors ; unsigned int num_ctors ; } ;
struct symsearch { const struct kernel_symbol * start , * stop ; const unsigned long * crcs ; enum { NOT_GPL_ONLY , GPL_ONLY , WILL_BE_GPL_ONLY , } licence ; bool unused ; } ;

struct device_driver ;

struct exception_table_entry { unsigned long insn , fixup ; } ;
struct __large_struct { unsigned long buf [ 100 ] ; } ;

struct scatterlist ;

struct crypto_ablkcipher ;

struct crypto_async_request ;

struct crypto_aead ;

struct crypto_blkcipher ;

struct crypto_hash ;

struct crypto_rng ;

struct crypto_tfm ;

struct crypto_type ;

struct aead_givcrypt_request ;

struct skcipher_givcrypt_request ;

typedef void ( * crypto_completion_t ) ( struct crypto_async_request * req , int err ) ;
struct crypto_async_request { struct list_head list ; crypto_completion_t complete ; void * data ; struct crypto_tfm * tfm ; u32 flags ; } ;
struct ablkcipher_request { struct crypto_async_request base ; unsigned int nbytes ; void * info ; struct scatterlist * src ; struct scatterlist * dst ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;

struct aead_request { struct crypto_async_request base ; unsigned int assoclen ; unsigned int cryptlen ; u8 * iv ; struct scatterlist * assoc ; struct scatterlist * src ; struct scatterlist * dst ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;

struct blkcipher_desc { struct crypto_blkcipher * tfm ; void * info ; u32 flags ; } ;

struct cipher_desc { struct crypto_tfm * tfm ; void ( * crfn ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; unsigned int ( * prfn ) ( const struct cipher_desc * desc , u8 * dst , const u8 * src , unsigned int nbytes ) ; void * info ; } ;

struct hash_desc { struct crypto_hash * tfm ; u32 flags ; } ;

struct ablkcipher_alg { int ( * setkey ) ( struct crypto_ablkcipher * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct ablkcipher_request * req ) ; int ( * decrypt ) ( struct ablkcipher_request * req ) ; int ( * givencrypt ) ( struct skcipher_givcrypt_request * req ) ; int ( * givdecrypt ) ( struct skcipher_givcrypt_request * req ) ; const char * geniv ; unsigned int min_keysize ; unsigned int max_keysize ; unsigned int ivsize ; } ;

struct aead_alg { int ( * setkey ) ( struct crypto_aead * tfm , const u8 * key , unsigned int keylen ) ; int ( * setauthsize ) ( struct crypto_aead * tfm , unsigned int authsize ) ; int ( * encrypt ) ( struct aead_request * req ) ; int ( * decrypt ) ( struct aead_request * req ) ; int ( * givencrypt ) ( struct aead_givcrypt_request * req ) ; int ( * givdecrypt ) ( struct aead_givcrypt_request * req ) ; const char * geniv ; unsigned int ivsize ; unsigned int maxauthsize ; } ;

struct blkcipher_alg { int ( * setkey ) ( struct crypto_tfm * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) ; int ( * decrypt ) ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) ; const char * geniv ; unsigned int min_keysize ; unsigned int max_keysize ; unsigned int ivsize ; } ;

struct cipher_alg { unsigned int cia_min_keysize ; unsigned int cia_max_keysize ; int ( * cia_setkey ) ( struct crypto_tfm * tfm , const u8 * key , unsigned int keylen ) ; void ( * cia_encrypt ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; void ( * cia_decrypt ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; } ;

struct digest_alg { unsigned int dia_digestsize ; void ( * dia_init ) ( struct crypto_tfm * tfm ) ; void ( * dia_update ) ( struct crypto_tfm * tfm , const u8 * data , unsigned int len ) ; void ( * dia_final ) ( struct crypto_tfm * tfm , u8 * out ) ; int ( * dia_setkey ) ( struct crypto_tfm * tfm , const u8 * key , unsigned int keylen ) ; } ;

struct hash_alg { int ( * init ) ( struct hash_desc * desc ) ; int ( * update ) ( struct hash_desc * desc , struct scatterlist * sg , unsigned int nbytes ) ; int ( * final ) ( struct hash_desc * desc , u8 * out ) ; int ( * digest ) ( struct hash_desc * desc , struct scatterlist * sg , unsigned int nbytes , u8 * out ) ; int ( * setkey ) ( struct crypto_hash * tfm , const u8 * key , unsigned int keylen ) ; unsigned int digestsize ; } ;

struct compress_alg { int ( * coa_compress ) ( struct crypto_tfm * tfm , const u8 * src , unsigned int slen , u8 * dst , unsigned int * dlen ) ; int ( * coa_decompress ) ( struct crypto_tfm * tfm , const u8 * src , unsigned int slen , u8 * dst , unsigned int * dlen ) ; } ;

struct rng_alg { int ( * rng_make_random ) ( struct crypto_rng * tfm , u8 * rdata , unsigned int dlen ) ; int ( * rng_reset ) ( struct crypto_rng * tfm , u8 * seed , unsigned int slen ) ; unsigned int seedsize ; } ;

struct crypto_alg { struct list_head cra_list ; struct list_head cra_users ; u32 cra_flags ; unsigned int cra_blocksize ; unsigned int cra_ctxsize ; unsigned int cra_alignmask ; int cra_priority ; atomic_t cra_refcnt ; char cra_name [ 64 ] ; char cra_driver_name [ 64 ] ; const struct crypto_type * cra_type ; union { struct ablkcipher_alg ablkcipher ; struct aead_alg aead ; struct blkcipher_alg blkcipher ; struct cipher_alg cipher ; struct digest_alg digest ; struct hash_alg hash ; struct compress_alg compress ; struct rng_alg rng ; } cra_u ; int ( * cra_init ) ( struct crypto_tfm * tfm ) ; void ( * cra_exit ) ( struct crypto_tfm * tfm ) ; void ( * cra_destroy ) ( struct crypto_alg * alg ) ; struct module * cra_module ; } ;

struct ablkcipher_tfm { int ( * setkey ) ( struct crypto_ablkcipher * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct ablkcipher_request * req ) ; int ( * decrypt ) ( struct ablkcipher_request * req ) ; int ( * givencrypt ) ( struct skcipher_givcrypt_request * req ) ; int ( * givdecrypt ) ( struct skcipher_givcrypt_request * req ) ; struct crypto_ablkcipher * base ; unsigned int ivsize ; unsigned int reqsize ; } ;

struct aead_tfm { int ( * setkey ) ( struct crypto_aead * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct aead_request * req ) ; int ( * decrypt ) ( struct aead_request * req ) ; int ( * givencrypt ) ( struct aead_givcrypt_request * req ) ; int ( * givdecrypt ) ( struct aead_givcrypt_request * req ) ; struct crypto_aead * base ; unsigned int ivsize ; unsigned int authsize ; unsigned int reqsize ; } ;

struct blkcipher_tfm { void * iv ; int ( * setkey ) ( struct crypto_tfm * tfm , const u8 * key , unsigned int keylen ) ; int ( * encrypt ) ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) ; int ( * decrypt ) ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) ; } ;

struct cipher_tfm { int ( * cit_setkey ) ( struct crypto_tfm * tfm , const u8 * key , unsigned int keylen ) ; void ( * cit_encrypt_one ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; void ( * cit_decrypt_one ) ( struct crypto_tfm * tfm , u8 * dst , const u8 * src ) ; } ;

struct hash_tfm { int ( * init ) ( struct hash_desc * desc ) ; int ( * update ) ( struct hash_desc * desc , struct scatterlist * sg , unsigned int nsg ) ; int ( * final ) ( struct hash_desc * desc , u8 * out ) ; int ( * digest ) ( struct hash_desc * desc , struct scatterlist * sg , unsigned int nsg , u8 * out ) ; int ( * setkey ) ( struct crypto_hash * tfm , const u8 * key , unsigned int keylen ) ; unsigned int digestsize ; } ;

struct compress_tfm { int ( * cot_compress ) ( struct crypto_tfm * tfm , const u8 * src , unsigned int slen , u8 * dst , unsigned int * dlen ) ; int ( * cot_decompress ) ( struct crypto_tfm * tfm , const u8 * src , unsigned int slen , u8 * dst , unsigned int * dlen ) ; } ;

struct rng_tfm { int ( * rng_gen_random ) ( struct crypto_rng * tfm , u8 * rdata , unsigned int dlen ) ; int ( * rng_reset ) ( struct crypto_rng * tfm , u8 * seed , unsigned int slen ) ; } ;

struct crypto_tfm { u32 crt_flags ; union { struct ablkcipher_tfm ablkcipher ; struct aead_tfm aead ; struct blkcipher_tfm blkcipher ; struct cipher_tfm cipher ; struct hash_tfm hash ; struct compress_tfm compress ; struct rng_tfm rng ; } crt_u ; void ( * exit ) ( struct crypto_tfm * tfm ) ; struct crypto_alg * __crt_alg ; void * __crt_ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;
struct crypto_ablkcipher { struct crypto_tfm base ; } ;
struct crypto_aead { struct crypto_tfm base ; } ;
struct crypto_blkcipher { struct crypto_tfm base ; } ;
struct crypto_cipher { struct crypto_tfm base ; } ;

struct crypto_comp { struct crypto_tfm base ; } ;

struct crypto_hash { struct crypto_tfm base ; } ;
struct crypto_rng { struct crypto_tfm base ; } ;
enum { CRYPTOA_UNSPEC , CRYPTOA_ALG , CRYPTOA_TYPE , CRYPTOA_U32 , __CRYPTOA_MAX , } ;
struct crypto_attr_alg { char name [ 64 ] ; } ;

struct crypto_attr_type { u32 type ; u32 mask ; } ;

struct crypto_attr_u32 { u32 num ; } ;

struct sched_param { int sched_priority ; } ;


typedef struct __user_cap_header_struct { __u32 version ; int pid ; } * cap_user_header_t ;


typedef struct __user_cap_data_struct { __u32 effective ; __u32 permitted ; __u32 inheritable ; } * cap_user_data_t ;

struct vfs_cap_data { __le32 magic_etc ; struct { __le32 permitted ; __le32 inheritable ; } data [ 2 ] ; } ;


typedef struct kernel_cap_struct { __u32 cap [ 2 ] ; } kernel_cap_t ;

struct cpu_vfs_cap_data { __u32 magic_etc ; kernel_cap_t permitted ; kernel_cap_t inheritable ; } ;

struct dentry ;

struct rb_node { unsigned long rb_parent_color ; struct rb_node * rb_right ; struct rb_node * rb_left ; } __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ;
struct rb_root { struct rb_node * rb_node ; } ;

struct raw_prio_tree_node { struct prio_tree_node * left ; struct prio_tree_node * right ; struct prio_tree_node * parent ; } ;

struct prio_tree_node { struct prio_tree_node * left ; struct prio_tree_node * right ; struct prio_tree_node * parent ; unsigned long start ; unsigned long last ; } ;

struct prio_tree_root { struct prio_tree_node * prio_tree_node ; unsigned short index_bits ; unsigned short raw ; } ;

struct prio_tree_iter { struct prio_tree_node * cur ; unsigned long mask ; unsigned long value ; int size_level ; struct prio_tree_root * root ; unsigned long r_index ; unsigned long h_index ; } ;

enum page_debug_flags { PAGE_DEBUG_FLAG_POISON , } ;

struct address_space ;

typedef atomic_long_t mm_counter_t ;

struct page { unsigned long flags ; atomic_t _count ; union { atomic_t _mapcount ; struct { u16 inuse ; u16 objects ; } ; } ; union { struct { unsigned long private ; struct address_space * mapping ; } ; spinlock_t ptl ; struct kmem_cache * slab ; struct page * first_page ; } ; union { unsigned long index ; void * freelist ; } ; struct list_head lru ; } ;
struct vm_region { struct rb_node vm_rb ; unsigned long vm_flags ; unsigned long vm_start ; unsigned long vm_end ; unsigned long vm_top ; unsigned long vm_pgoff ; struct file * vm_file ; atomic_t vm_usage ; } ;

struct vm_area_struct { struct mm_struct * vm_mm ; unsigned long vm_start ; unsigned long vm_end ; struct vm_area_struct * vm_next , * vm_prev ; pgprot_t vm_page_prot ; unsigned long vm_flags ; struct rb_node vm_rb ; union { struct { struct list_head list ; void * parent ; struct vm_area_struct * head ; } vm_set ; struct raw_prio_tree_node prio_tree_node ; } shared ; struct list_head anon_vma_node ; struct anon_vma * anon_vma ; const struct vm_operations_struct * vm_ops ; unsigned long vm_pgoff ; struct file * vm_file ; void * vm_private_data ; unsigned long vm_truncate_count ; struct mempolicy * vm_policy ; } ;
struct core_thread { struct task_struct * task ; struct core_thread * next ; } ;

struct core_state { atomic_t nr_threads ; struct core_thread dumper ; struct completion startup ; } ;

struct mm_struct { struct vm_area_struct * mmap ; struct rb_root mm_rb ; struct vm_area_struct * mmap_cache ; unsigned long ( * get_unmapped_area ) ( struct file * filp , unsigned long addr , unsigned long len , unsigned long pgoff , unsigned long flags ) ; unsigned long ( * get_unmapped_exec_area ) ( struct file * filp , unsigned long addr , unsigned long len , unsigned long pgoff , unsigned long flags ) ; void ( * unmap_area ) ( struct mm_struct * mm , unsigned long addr ) ; unsigned long mmap_base ; unsigned long task_size ; unsigned long cached_hole_size ; unsigned long free_area_cache ; pgd_t * pgd ; atomic_t mm_users ; atomic_t mm_count ; int map_count ; struct rw_semaphore mmap_sem ; spinlock_t page_table_lock ; struct list_head mmlist ; mm_counter_t _file_rss ; mm_counter_t _anon_rss ; unsigned long hiwater_rss ; unsigned long hiwater_vm ; unsigned long total_vm , locked_vm , shared_vm , exec_vm ; unsigned long stack_vm , reserved_vm , def_flags , nr_ptes ; unsigned long start_code , end_code , start_data , end_data ; unsigned long start_brk , brk , start_stack ; unsigned long arg_start , arg_end , env_start , env_end ; unsigned long saved_auxv [ ( 2 * ( 2 + 19 + 1 ) ) ] ; struct linux_binfmt * binfmt ; cpumask_t cpu_vm_mask ; mm_context_t context ; unsigned int faultstamp ; unsigned int token_priority ; unsigned int last_interval ; unsigned long flags ; struct core_state * core_state ; spinlock_t ioctx_lock ; struct hlist_head ioctx_list ; struct task_struct * owner ; struct file * exe_file ; unsigned long num_exe_file_vmas ; struct mmu_notifier_mm * mmu_notifier_mm ; } ;
typedef unsigned long cputime_t ;

typedef u64 cputime64_t ;

struct ipc_perm { __kernel_key_t key ; __kernel_uid_t uid ; __kernel_gid_t gid ; __kernel_uid_t cuid ; __kernel_gid_t cgid ; __kernel_mode_t mode ; unsigned short seq ; } ;

struct ipc64_perm { __kernel_key_t key ; __kernel_uid32_t uid ; __kernel_gid32_t gid ; __kernel_uid32_t cuid ; __kernel_gid32_t cgid ; __kernel_mode_t mode ; unsigned char __pad1 [ 4 - sizeof ( __kernel_mode_t ) ] ; unsigned short seq ; unsigned short __pad2 ; unsigned long __unused1 ; unsigned long __unused2 ; } ;

struct ipc_kludge { struct msgbuf * msgp ; long msgtyp ; } ;

struct kern_ipc_perm { spinlock_t lock ; int deleted ; int id ; key_t key ; uid_t uid ; gid_t gid ; uid_t cuid ; gid_t cgid ; mode_t mode ; unsigned long seq ; void * security ; } ;

struct semid_ds { struct ipc_perm sem_perm ; __kernel_time_t sem_otime ; __kernel_time_t sem_ctime ; struct sem * sem_base ; struct sem_queue * sem_pending ; struct sem_queue * * sem_pending_last ; struct sem_undo * undo ; unsigned short sem_nsems ; } ;

struct semid64_ds { struct ipc64_perm sem_perm ; __kernel_time_t sem_otime ; unsigned long __unused1 ; __kernel_time_t sem_ctime ; unsigned long __unused2 ; unsigned long sem_nsems ; unsigned long __unused3 ; unsigned long __unused4 ; } ;

struct sembuf { unsigned short sem_num ; short sem_op ; short sem_flg ; } ;

union semun { int val ; struct semid_ds * buf ; unsigned short * array ; struct seminfo * __buf ; void * __pad ; } ;

struct seminfo { int semmap ; int semmni ; int semmns ; int semmnu ; int semmsl ; int semopm ; int semume ; int semusz ; int semvmx ; int semaem ; } ;

struct sem { int semval ; int sempid ; } ;

struct sem_array { struct kern_ipc_perm sem_perm ; time_t sem_otime ; time_t sem_ctime ; struct sem * sem_base ; struct list_head sem_pending ; struct list_head list_id ; unsigned long sem_nsems ; } ;

struct sem_queue { struct list_head list ; struct task_struct * sleeper ; struct sem_undo * undo ; int pid ; int status ; struct sembuf * sops ; int nsops ; int alter ; } ;

struct sem_undo { struct list_head list_proc ; struct rcu_head rcu ; struct sem_undo_list * ulp ; struct list_head list_id ; int semid ; short * semadj ; } ;

struct sem_undo_list { atomic_t refcnt ; spinlock_t lock ; struct list_head list_proc ; } ;

struct sysv_sem { struct sem_undo_list * undo_list ; } ;

struct siginfo ;
typedef unsigned long old_sigset_t ;

typedef struct { unsigned long sig [ ( 64 / 64 ) ] ; } sigset_t ;
typedef void __signalfn_t ( int ) ;

typedef __signalfn_t * __sighandler_t ;

typedef void __restorefn_t ( void ) ;

typedef __restorefn_t * __sigrestore_t ;

struct sigaction { __sighandler_t sa_handler ; unsigned long sa_flags ; __sigrestore_t sa_restorer ; sigset_t sa_mask ; } ;
struct k_sigaction { struct sigaction sa ; } ;

typedef struct siginfo { int si_signo ; int si_errno ; int si_code ; union { int _pad [ ( ( 128 - ( 4 * sizeof ( int ) ) ) / sizeof ( int ) ) ] ; struct { __kernel_pid_t _pid ; __kernel_uid32_t _uid ; } _kill ; struct { __kernel_timer_t _tid ; int _overrun ; char _pad [ sizeof ( __kernel_uid32_t ) - sizeof ( int ) ] ; sigval_t _sigval ; int _sys_private ; } _timer ; struct { __kernel_pid_t _pid ; __kernel_uid32_t _uid ; sigval_t _sigval ; } _rt ; struct { __kernel_pid_t _pid ; __kernel_uid32_t _uid ; int _status ; __kernel_clock_t _utime ; __kernel_clock_t _stime ; } _sigchld ; struct { void * _addr ; short _addr_lsb ; } _sigfault ; struct { long _band ; int _fd ; } _sigpoll ; } _sifields ; } siginfo_t ;
typedef struct sigevent { sigval_t sigev_value ; int sigev_signo ; int sigev_notify ; union { int _pad [ ( ( 64 - ( sizeof ( int ) * 2 + sizeof ( sigval_t ) ) ) / sizeof ( int ) ) ] ; int _tid ; struct { void ( * _function ) ( sigval_t ) ; void * _attribute ; } _sigev_thread ; } _sigev_un ; } sigevent_t ;
struct sigqueue { struct list_head list ; int flags ; siginfo_t info ; struct user_struct * user ; } ;

struct sigpending { struct list_head list ; sigset_t signal ; } ;

struct vfsmount ;

struct path { struct vfsmount * mnt ; struct dentry * dentry ; } ;

enum pid_type { PIDTYPE_PID , PIDTYPE_PGID , PIDTYPE_SID , PIDTYPE_MAX } ;

struct upid { int nr ; struct pid_namespace * ns ; struct hlist_node pid_chain ; } ;

struct pid { atomic_t count ; unsigned int level ; struct hlist_head tasks [ PIDTYPE_MAX ] ; struct rcu_head rcu ; struct upid numbers [ 1 ] ; } ;
struct pid_link { struct hlist_node node ; struct pid * pid ; } ;

struct pid_namespace ;

struct percpu_counter { spinlock_t lock ; s64 count ; struct list_head list ; s32 * counters ; } ;

struct prop_global { int shift ; struct percpu_counter events ; } ;

struct prop_descriptor { int index ; struct prop_global pg [ 2 ] ; struct mutex mutex ; } ;

struct prop_local_percpu { struct percpu_counter events ; int shift ; unsigned long period ; spinlock_t lock ; } ;

struct prop_local_single { unsigned long events ; unsigned long period ; int shift ; spinlock_t lock ; } ;

typedef struct { int mode ; } seccomp_t ;

struct plist_head { struct list_head prio_list ; struct list_head node_list ; } ;

struct plist_node { int prio ; struct plist_head plist ; } ;

struct rt_mutex { spinlock_t wait_lock ; struct plist_head wait_list ; struct task_struct * owner ; } ;

struct rt_mutex_waiter ;

struct hrtimer_sleeper ;

struct rusage { struct timeval ru_utime ; struct timeval ru_stime ; long ru_maxrss ; long ru_ixrss ; long ru_idrss ; long ru_isrss ; long ru_minflt ; long ru_majflt ; long ru_nswap ; long ru_inblock ; long ru_oublock ; long ru_msgsnd ; long ru_msgrcv ; long ru_nsignals ; long ru_nvcsw ; long ru_nivcsw ; } ;
struct rlimit { unsigned long rlim_cur ; unsigned long rlim_max ; } ;
struct hrtimer_clock_base ;

struct hrtimer_cpu_base ;

enum hrtimer_mode { HRTIMER_MODE_ABS = 0x0 , HRTIMER_MODE_REL = 0x1 , HRTIMER_MODE_PINNED = 0x02 , HRTIMER_MODE_ABS_PINNED = 0x02 , HRTIMER_MODE_REL_PINNED = 0x03 , } ;

enum hrtimer_restart { HRTIMER_NORESTART , HRTIMER_RESTART , } ;

struct hrtimer { struct rb_node node ; ktime_t _expires ; ktime_t _softexpires ; enum hrtimer_restart ( * function ) ( struct hrtimer * ) ; struct hrtimer_clock_base * base ; unsigned long state ; int start_pid ; void * start_site ; char start_comm [ 16 ] ; } ;
struct hrtimer_sleeper { struct hrtimer timer ; struct task_struct * task ; } ;
struct hrtimer_clock_base { struct hrtimer_cpu_base * cpu_base ; clockid_t index ; struct rb_root active ; struct rb_node * first ; ktime_t resolution ; ktime_t ( * get_time ) ( void ) ; ktime_t softirq_time ; ktime_t offset ; } ;
struct hrtimer_cpu_base { spinlock_t lock ; struct hrtimer_clock_base clock_base [ 2 ] ; ktime_t expires_next ; int hres_active ; int hang_detected ; unsigned long nr_events ; unsigned long nr_retries ; unsigned long nr_hangs ; ktime_t max_hang_time ; } ;
struct clock_event_device ;

struct task_io_accounting { u64 rchar ; u64 wchar ; u64 syscr ; u64 syscw ; u64 read_bytes ; u64 write_bytes ; u64 cancelled_write_bytes ; } ;

struct latency_record { unsigned long backtrace [ 12 ] ; unsigned int count ; unsigned long time ; unsigned long max ; } ;

struct __sysctl_args { int * name ; int nlen ; void * oldval ; size_t * oldlenp ; void * newval ; size_t newlen ; unsigned long __unused [ 4 ] ; } ;

enum { CTL_KERN = 1 , CTL_VM = 2 , CTL_NET = 3 , CTL_PROC = 4 , CTL_FS = 5 , CTL_DEBUG = 6 , CTL_DEV = 7 , CTL_BUS = 8 , CTL_ABI = 9 , CTL_CPU = 10 , CTL_ARLAN = 254 , CTL_S390DBF = 5677 , CTL_SUNRPC = 7249 , CTL_PM = 9899 , CTL_FRV = 9898 , } ;
enum { CTL_BUS_ISA = 1 } ;
enum { INOTIFY_MAX_USER_INSTANCES = 1 , INOTIFY_MAX_USER_WATCHES = 2 , INOTIFY_MAX_QUEUED_EVENTS = 3 } ;
enum { KERN_OSTYPE = 1 , KERN_OSRELEASE = 2 , KERN_OSREV = 3 , KERN_VERSION = 4 , KERN_SECUREMASK = 5 , KERN_PROF = 6 , KERN_NODENAME = 7 , KERN_DOMAINNAME = 8 , KERN_PANIC = 15 , KERN_REALROOTDEV = 16 , KERN_SPARC_REBOOT = 21 , KERN_CTLALTDEL = 22 , KERN_PRINTK = 23 , KERN_NAMETRANS = 24 , KERN_PPC_HTABRECLAIM = 25 , KERN_PPC_ZEROPAGED = 26 , KERN_PPC_POWERSAVE_NAP = 27 , KERN_MODPROBE = 28 , KERN_SG_BIG_BUFF = 29 , KERN_ACCT = 30 , KERN_PPC_L2CR = 31 , KERN_RTSIGNR = 32 , KERN_RTSIGMAX = 33 , KERN_SHMMAX = 34 , KERN_MSGMAX = 35 , KERN_MSGMNB = 36 , KERN_MSGPOOL = 37 , KERN_SYSRQ = 38 , KERN_MAX_THREADS = 39 , KERN_RANDOM = 40 , KERN_SHMALL = 41 , KERN_MSGMNI = 42 , KERN_SEM = 43 , KERN_SPARC_STOP_A = 44 , KERN_SHMMNI = 45 , KERN_OVERFLOWUID = 46 , KERN_OVERFLOWGID = 47 , KERN_SHMPATH = 48 , KERN_HOTPLUG = 49 , KERN_IEEE_EMULATION_WARNINGS = 50 , KERN_S390_USER_DEBUG_LOGGING = 51 , KERN_CORE_USES_PID = 52 , KERN_TAINTED = 53 , KERN_CADPID = 54 , KERN_PIDMAX = 55 , KERN_CORE_PATTERN = 56 , KERN_PANIC_ON_OOPS = 57 , KERN_HPPA_PWRSW = 58 , KERN_HPPA_UNALIGNED = 59 , KERN_PRINTK_RATELIMIT = 60 , KERN_PRINTK_RATELIMIT_BURST = 61 , KERN_PTY = 62 , KERN_NGROUPS_MAX = 63 , KERN_SPARC_SCONS_PWROFF = 64 , KERN_HZ_TIMER = 65 , KERN_UNKNOWN_NMI_PANIC = 66 , KERN_BOOTLOADER_TYPE = 67 , KERN_RANDOMIZE = 68 , KERN_SETUID_DUMPABLE = 69 , KERN_SPIN_RETRY = 70 , KERN_ACPI_VIDEO_FLAGS = 71 , KERN_IA64_UNALIGNED = 72 , KERN_COMPAT_LOG = 73 , KERN_MAX_LOCK_DEPTH = 74 , KERN_NMI_WATCHDOG = 75 , KERN_PANIC_ON_NMI = 76 , } ;
enum { VM_UNUSED1 = 1 , VM_UNUSED2 = 2 , VM_UNUSED3 = 3 , VM_UNUSED4 = 4 , VM_OVERCOMMIT_MEMORY = 5 , VM_UNUSED5 = 6 , VM_UNUSED7 = 7 , VM_UNUSED8 = 8 , VM_UNUSED9 = 9 , VM_PAGE_CLUSTER = 10 , VM_DIRTY_BACKGROUND = 11 , VM_DIRTY_RATIO = 12 , VM_DIRTY_WB_CS = 13 , VM_DIRTY_EXPIRE_CS = 14 , VM_NR_PDFLUSH_THREADS = 15 , VM_OVERCOMMIT_RATIO = 16 , VM_PAGEBUF = 17 , VM_HUGETLB_PAGES = 18 , VM_SWAPPINESS = 19 , VM_LOWMEM_RESERVE_RATIO = 20 , VM_MIN_FREE_KBYTES = 21 , VM_MAX_MAP_COUNT = 22 , VM_LAPTOP_MODE = 23 , VM_BLOCK_DUMP = 24 , VM_HUGETLB_GROUP = 25 , VM_VFS_CACHE_PRESSURE = 26 , VM_LEGACY_VA_LAYOUT = 27 , VM_SWAP_TOKEN_TIMEOUT = 28 , VM_DROP_PAGECACHE = 29 , VM_PERCPU_PAGELIST_FRACTION = 30 , VM_ZONE_RECLAIM_MODE = 31 , VM_MIN_UNMAPPED = 32 , VM_PANIC_ON_OOM = 33 , VM_VDSO_ENABLED = 34 , VM_MIN_SLAB = 35 , } ;
enum { NET_CORE = 1 , NET_ETHER = 2 , NET_802 = 3 , NET_UNIX = 4 , NET_IPV4 = 5 , NET_IPX = 6 , NET_ATALK = 7 , NET_NETROM = 8 , NET_AX25 = 9 , NET_BRIDGE = 10 , NET_ROSE = 11 , NET_IPV6 = 12 , NET_X25 = 13 , NET_TR = 14 , NET_DECNET = 15 , NET_ECONET = 16 , NET_SCTP = 17 , NET_LLC = 18 , NET_NETFILTER = 19 , NET_DCCP = 20 , NET_IRDA = 412 , } ;
enum { RANDOM_POOLSIZE = 1 , RANDOM_ENTROPY_COUNT = 2 , RANDOM_READ_THRESH = 3 , RANDOM_WRITE_THRESH = 4 , RANDOM_BOOT_ID = 5 , RANDOM_UUID = 6 } ;
enum { PTY_MAX = 1 , PTY_NR = 2 } ;
enum { BUS_ISA_MEM_BASE = 1 , BUS_ISA_PORT_BASE = 2 , BUS_ISA_PORT_SHIFT = 3 } ;
enum { NET_CORE_WMEM_MAX = 1 , NET_CORE_RMEM_MAX = 2 , NET_CORE_WMEM_DEFAULT = 3 , NET_CORE_RMEM_DEFAULT = 4 , NET_CORE_MAX_BACKLOG = 6 , NET_CORE_FASTROUTE = 7 , NET_CORE_MSG_COST = 8 , NET_CORE_MSG_BURST = 9 , NET_CORE_OPTMEM_MAX = 10 , NET_CORE_HOT_LIST_LENGTH = 11 , NET_CORE_DIVERT_VERSION = 12 , NET_CORE_NO_CONG_THRESH = 13 , NET_CORE_NO_CONG = 14 , NET_CORE_LO_CONG = 15 , NET_CORE_MOD_CONG = 16 , NET_CORE_DEV_WEIGHT = 17 , NET_CORE_SOMAXCONN = 18 , NET_CORE_BUDGET = 19 , NET_CORE_AEVENT_ETIME = 20 , NET_CORE_AEVENT_RSEQTH = 21 , NET_CORE_WARNINGS = 22 , } ;
enum { NET_UNIX_DESTROY_DELAY = 1 , NET_UNIX_DELETE_DELAY = 2 , NET_UNIX_MAX_DGRAM_QLEN = 3 , } ;
enum { NET_NF_CONNTRACK_MAX = 1 , NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2 , NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3 , NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4 , NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5 , NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6 , NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7 , NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8 , NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9 , NET_NF_CONNTRACK_UDP_TIMEOUT = 10 , NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11 , NET_NF_CONNTRACK_ICMP_TIMEOUT = 12 , NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13 , NET_NF_CONNTRACK_BUCKETS = 14 , NET_NF_CONNTRACK_LOG_INVALID = 15 , NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16 , NET_NF_CONNTRACK_TCP_LOOSE = 17 , NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18 , NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19 , NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20 , NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21 , NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22 , NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23 , NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24 , NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25 , NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26 , NET_NF_CONNTRACK_COUNT = 27 , NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28 , NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29 , NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30 , NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31 , NET_NF_CONNTRACK_CHECKSUM = 32 , } ;
enum { NET_IPV4_FORWARD = 8 , NET_IPV4_DYNADDR = 9 , NET_IPV4_CONF = 16 , NET_IPV4_NEIGH = 17 , NET_IPV4_ROUTE = 18 , NET_IPV4_FIB_HASH = 19 , NET_IPV4_NETFILTER = 20 , NET_IPV4_TCP_TIMESTAMPS = 33 , NET_IPV4_TCP_WINDOW_SCALING = 34 , NET_IPV4_TCP_SACK = 35 , NET_IPV4_TCP_RETRANS_COLLAPSE = 36 , NET_IPV4_DEFAULT_TTL = 37 , NET_IPV4_AUTOCONFIG = 38 , NET_IPV4_NO_PMTU_DISC = 39 , NET_IPV4_TCP_SYN_RETRIES = 40 , NET_IPV4_IPFRAG_HIGH_THRESH = 41 , NET_IPV4_IPFRAG_LOW_THRESH = 42 , NET_IPV4_IPFRAG_TIME = 43 , NET_IPV4_TCP_MAX_KA_PROBES = 44 , NET_IPV4_TCP_KEEPALIVE_TIME = 45 , NET_IPV4_TCP_KEEPALIVE_PROBES = 46 , NET_IPV4_TCP_RETRIES1 = 47 , NET_IPV4_TCP_RETRIES2 = 48 , NET_IPV4_TCP_FIN_TIMEOUT = 49 , NET_IPV4_IP_MASQ_DEBUG = 50 , NET_TCP_SYNCOOKIES = 51 , NET_TCP_STDURG = 52 , NET_TCP_RFC1337 = 53 , NET_TCP_SYN_TAILDROP = 54 , NET_TCP_MAX_SYN_BACKLOG = 55 , NET_IPV4_LOCAL_PORT_RANGE = 56 , NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57 , NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58 , NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59 , NET_IPV4_ICMP_DESTUNREACH_RATE = 60 , NET_IPV4_ICMP_TIMEEXCEED_RATE = 61 , NET_IPV4_ICMP_PARAMPROB_RATE = 62 , NET_IPV4_ICMP_ECHOREPLY_RATE = 63 , NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64 , NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65 , NET_TCP_TW_RECYCLE = 66 , NET_IPV4_ALWAYS_DEFRAG = 67 , NET_IPV4_TCP_KEEPALIVE_INTVL = 68 , NET_IPV4_INET_PEER_THRESHOLD = 69 , NET_IPV4_INET_PEER_MINTTL = 70 , NET_IPV4_INET_PEER_MAXTTL = 71 , NET_IPV4_INET_PEER_GC_MINTIME = 72 , NET_IPV4_INET_PEER_GC_MAXTIME = 73 , NET_TCP_ORPHAN_RETRIES = 74 , NET_TCP_ABORT_ON_OVERFLOW = 75 , NET_TCP_SYNACK_RETRIES = 76 , NET_TCP_MAX_ORPHANS = 77 , NET_TCP_MAX_TW_BUCKETS = 78 , NET_TCP_FACK = 79 , NET_TCP_REORDERING = 80 , NET_TCP_ECN = 81 , NET_TCP_DSACK = 82 , NET_TCP_MEM = 83 , NET_TCP_WMEM = 84 , NET_TCP_RMEM = 85 , NET_TCP_APP_WIN = 86 , NET_TCP_ADV_WIN_SCALE = 87 , NET_IPV4_NONLOCAL_BIND = 88 , NET_IPV4_ICMP_RATELIMIT = 89 , NET_IPV4_ICMP_RATEMASK = 90 , NET_TCP_TW_REUSE = 91 , NET_TCP_FRTO = 92 , NET_TCP_LOW_LATENCY = 93 , NET_IPV4_IPFRAG_SECRET_INTERVAL = 94 , NET_IPV4_IGMP_MAX_MSF = 96 , NET_TCP_NO_METRICS_SAVE = 97 , NET_TCP_DEFAULT_WIN_SCALE = 105 , NET_TCP_MODERATE_RCVBUF = 106 , NET_TCP_TSO_WIN_DIVISOR = 107 , NET_TCP_BIC_BETA = 108 , NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109 , NET_TCP_CONG_CONTROL = 110 , NET_TCP_ABC = 111 , NET_IPV4_IPFRAG_MAX_DIST = 112 , NET_TCP_MTU_PROBING = 113 , NET_TCP_BASE_MSS = 114 , NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115 , NET_TCP_DMA_COPYBREAK = 116 , NET_TCP_SLOW_START_AFTER_IDLE = 117 , NET_CIPSOV4_CACHE_ENABLE = 118 , NET_CIPSOV4_CACHE_BUCKET_SIZE = 119 , NET_CIPSOV4_RBM_OPTFMT = 120 , NET_CIPSOV4_RBM_STRICTVALID = 121 , NET_TCP_AVAIL_CONG_CONTROL = 122 , NET_TCP_ALLOWED_CONG_CONTROL = 123 , NET_TCP_MAX_SSTHRESH = 124 , NET_TCP_FRTO_RESPONSE = 125 , } ;
enum { NET_IPV4_ROUTE_FLUSH = 1 , NET_IPV4_ROUTE_MIN_DELAY = 2 , NET_IPV4_ROUTE_MAX_DELAY = 3 , NET_IPV4_ROUTE_GC_THRESH = 4 , NET_IPV4_ROUTE_MAX_SIZE = 5 , NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6 , NET_IPV4_ROUTE_GC_TIMEOUT = 7 , NET_IPV4_ROUTE_GC_INTERVAL = 8 , NET_IPV4_ROUTE_REDIRECT_LOAD = 9 , NET_IPV4_ROUTE_REDIRECT_NUMBER = 10 , NET_IPV4_ROUTE_REDIRECT_SILENCE = 11 , NET_IPV4_ROUTE_ERROR_COST = 12 , NET_IPV4_ROUTE_ERROR_BURST = 13 , NET_IPV4_ROUTE_GC_ELASTICITY = 14 , NET_IPV4_ROUTE_MTU_EXPIRES = 15 , NET_IPV4_ROUTE_MIN_PMTU = 16 , NET_IPV4_ROUTE_MIN_ADVMSS = 17 , NET_IPV4_ROUTE_SECRET_INTERVAL = 18 , NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19 , } ;
enum { NET_PROTO_CONF_ALL = - 2 , NET_PROTO_CONF_DEFAULT = - 3 } ;
enum { NET_IPV4_CONF_FORWARDING = 1 , NET_IPV4_CONF_MC_FORWARDING = 2 , NET_IPV4_CONF_PROXY_ARP = 3 , NET_IPV4_CONF_ACCEPT_REDIRECTS = 4 , NET_IPV4_CONF_SECURE_REDIRECTS = 5 , NET_IPV4_CONF_SEND_REDIRECTS = 6 , NET_IPV4_CONF_SHARED_MEDIA = 7 , NET_IPV4_CONF_RP_FILTER = 8 , NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9 , NET_IPV4_CONF_BOOTP_RELAY = 10 , NET_IPV4_CONF_LOG_MARTIANS = 11 , NET_IPV4_CONF_TAG = 12 , NET_IPV4_CONF_ARPFILTER = 13 , NET_IPV4_CONF_MEDIUM_ID = 14 , NET_IPV4_CONF_NOXFRM = 15 , NET_IPV4_CONF_NOPOLICY = 16 , NET_IPV4_CONF_FORCE_IGMP_VERSION = 17 , NET_IPV4_CONF_ARP_ANNOUNCE = 18 , NET_IPV4_CONF_ARP_IGNORE = 19 , NET_IPV4_CONF_PROMOTE_SECONDARIES = 20 , NET_IPV4_CONF_ARP_ACCEPT = 21 , NET_IPV4_CONF_ARP_NOTIFY = 22 , NET_IPV4_CONF_SRC_VMARK = 24 , __NET_IPV4_CONF_MAX } ;
enum { NET_IPV4_NF_CONNTRACK_MAX = 1 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9 , NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10 , NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11 , NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12 , NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13 , NET_IPV4_NF_CONNTRACK_BUCKETS = 14 , NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15 , NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16 , NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17 , NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18 , NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25 , NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26 , NET_IPV4_NF_CONNTRACK_COUNT = 27 , NET_IPV4_NF_CONNTRACK_CHECKSUM = 28 , } ;
enum { NET_IPV6_CONF = 16 , NET_IPV6_NEIGH = 17 , NET_IPV6_ROUTE = 18 , NET_IPV6_ICMP = 19 , NET_IPV6_BINDV6ONLY = 20 , NET_IPV6_IP6FRAG_HIGH_THRESH = 21 , NET_IPV6_IP6FRAG_LOW_THRESH = 22 , NET_IPV6_IP6FRAG_TIME = 23 , NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24 , NET_IPV6_MLD_MAX_MSF = 25 , } ;
enum { NET_IPV6_ROUTE_FLUSH = 1 , NET_IPV6_ROUTE_GC_THRESH = 2 , NET_IPV6_ROUTE_MAX_SIZE = 3 , NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4 , NET_IPV6_ROUTE_GC_TIMEOUT = 5 , NET_IPV6_ROUTE_GC_INTERVAL = 6 , NET_IPV6_ROUTE_GC_ELASTICITY = 7 , NET_IPV6_ROUTE_MTU_EXPIRES = 8 , NET_IPV6_ROUTE_MIN_ADVMSS = 9 , NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10 } ;
enum { NET_IPV6_FORWARDING = 1 , NET_IPV6_HOP_LIMIT = 2 , NET_IPV6_MTU = 3 , NET_IPV6_ACCEPT_RA = 4 , NET_IPV6_ACCEPT_REDIRECTS = 5 , NET_IPV6_AUTOCONF = 6 , NET_IPV6_DAD_TRANSMITS = 7 , NET_IPV6_RTR_SOLICITS = 8 , NET_IPV6_RTR_SOLICIT_INTERVAL = 9 , NET_IPV6_RTR_SOLICIT_DELAY = 10 , NET_IPV6_USE_TEMPADDR = 11 , NET_IPV6_TEMP_VALID_LFT = 12 , NET_IPV6_TEMP_PREFERED_LFT = 13 , NET_IPV6_REGEN_MAX_RETRY = 14 , NET_IPV6_MAX_DESYNC_FACTOR = 15 , NET_IPV6_MAX_ADDRESSES = 16 , NET_IPV6_FORCE_MLD_VERSION = 17 , NET_IPV6_ACCEPT_RA_DEFRTR = 18 , NET_IPV6_ACCEPT_RA_PINFO = 19 , NET_IPV6_ACCEPT_RA_RTR_PREF = 20 , NET_IPV6_RTR_PROBE_INTERVAL = 21 , NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22 , NET_IPV6_PROXY_NDP = 23 , NET_IPV6_ACCEPT_SOURCE_ROUTE = 25 , __NET_IPV6_MAX } ;
enum { NET_IPV6_ICMP_RATELIMIT = 1 } ;
enum { NET_NEIGH_MCAST_SOLICIT = 1 , NET_NEIGH_UCAST_SOLICIT = 2 , NET_NEIGH_APP_SOLICIT = 3 , NET_NEIGH_RETRANS_TIME = 4 , NET_NEIGH_REACHABLE_TIME = 5 , NET_NEIGH_DELAY_PROBE_TIME = 6 , NET_NEIGH_GC_STALE_TIME = 7 , NET_NEIGH_UNRES_QLEN = 8 , NET_NEIGH_PROXY_QLEN = 9 , NET_NEIGH_ANYCAST_DELAY = 10 , NET_NEIGH_PROXY_DELAY = 11 , NET_NEIGH_LOCKTIME = 12 , NET_NEIGH_GC_INTERVAL = 13 , NET_NEIGH_GC_THRESH1 = 14 , NET_NEIGH_GC_THRESH2 = 15 , NET_NEIGH_GC_THRESH3 = 16 , NET_NEIGH_RETRANS_TIME_MS = 17 , NET_NEIGH_REACHABLE_TIME_MS = 18 , __NET_NEIGH_MAX } ;
enum { NET_DCCP_DEFAULT = 1 , } ;
enum { NET_IPX_PPROP_BROADCASTING = 1 , NET_IPX_FORWARDING = 2 } ;
enum { NET_LLC2 = 1 , NET_LLC_STATION = 2 , } ;
enum { NET_LLC2_TIMEOUT = 1 , } ;
enum { NET_LLC_STATION_ACK_TIMEOUT = 1 , } ;
enum { NET_LLC2_ACK_TIMEOUT = 1 , NET_LLC2_P_TIMEOUT = 2 , NET_LLC2_REJ_TIMEOUT = 3 , NET_LLC2_BUSY_TIMEOUT = 4 , } ;
enum { NET_ATALK_AARP_EXPIRY_TIME = 1 , NET_ATALK_AARP_TICK_TIME = 2 , NET_ATALK_AARP_RETRANSMIT_LIMIT = 3 , NET_ATALK_AARP_RESOLVE_TIME = 4 } ;
enum { NET_NETROM_DEFAULT_PATH_QUALITY = 1 , NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2 , NET_NETROM_NETWORK_TTL_INITIALISER = 3 , NET_NETROM_TRANSPORT_TIMEOUT = 4 , NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5 , NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6 , NET_NETROM_TRANSPORT_BUSY_DELAY = 7 , NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8 , NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9 , NET_NETROM_ROUTING_CONTROL = 10 , NET_NETROM_LINK_FAILS_COUNT = 11 , NET_NETROM_RESET = 12 } ;
enum { NET_AX25_IP_DEFAULT_MODE = 1 , NET_AX25_DEFAULT_MODE = 2 , NET_AX25_BACKOFF_TYPE = 3 , NET_AX25_CONNECT_MODE = 4 , NET_AX25_STANDARD_WINDOW = 5 , NET_AX25_EXTENDED_WINDOW = 6 , NET_AX25_T1_TIMEOUT = 7 , NET_AX25_T2_TIMEOUT = 8 , NET_AX25_T3_TIMEOUT = 9 , NET_AX25_IDLE_TIMEOUT = 10 , NET_AX25_N2 = 11 , NET_AX25_PACLEN = 12 , NET_AX25_PROTOCOL = 13 , NET_AX25_DAMA_SLAVE_TIMEOUT = 14 } ;
enum { NET_ROSE_RESTART_REQUEST_TIMEOUT = 1 , NET_ROSE_CALL_REQUEST_TIMEOUT = 2 , NET_ROSE_RESET_REQUEST_TIMEOUT = 3 , NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4 , NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5 , NET_ROSE_ROUTING_CONTROL = 6 , NET_ROSE_LINK_FAIL_TIMEOUT = 7 , NET_ROSE_MAX_VCS = 8 , NET_ROSE_WINDOW_SIZE = 9 , NET_ROSE_NO_ACTIVITY_TIMEOUT = 10 } ;
enum { NET_X25_RESTART_REQUEST_TIMEOUT = 1 , NET_X25_CALL_REQUEST_TIMEOUT = 2 , NET_X25_RESET_REQUEST_TIMEOUT = 3 , NET_X25_CLEAR_REQUEST_TIMEOUT = 4 , NET_X25_ACK_HOLD_BACK_TIMEOUT = 5 , NET_X25_FORWARD = 6 } ;
enum { NET_TR_RIF_TIMEOUT = 1 } ;
enum { NET_DECNET_NODE_TYPE = 1 , NET_DECNET_NODE_ADDRESS = 2 , NET_DECNET_NODE_NAME = 3 , NET_DECNET_DEFAULT_DEVICE = 4 , NET_DECNET_TIME_WAIT = 5 , NET_DECNET_DN_COUNT = 6 , NET_DECNET_DI_COUNT = 7 , NET_DECNET_DR_COUNT = 8 , NET_DECNET_DST_GC_INTERVAL = 9 , NET_DECNET_CONF = 10 , NET_DECNET_NO_FC_MAX_CWND = 11 , NET_DECNET_MEM = 12 , NET_DECNET_RMEM = 13 , NET_DECNET_WMEM = 14 , NET_DECNET_DEBUG_LEVEL = 255 } ;
enum { NET_DECNET_CONF_LOOPBACK = - 2 , NET_DECNET_CONF_DDCMP = - 3 , NET_DECNET_CONF_PPP = - 4 , NET_DECNET_CONF_X25 = - 5 , NET_DECNET_CONF_GRE = - 6 , NET_DECNET_CONF_ETHER = - 7 } ;
enum { NET_DECNET_CONF_DEV_PRIORITY = 1 , NET_DECNET_CONF_DEV_T1 = 2 , NET_DECNET_CONF_DEV_T2 = 3 , NET_DECNET_CONF_DEV_T3 = 4 , NET_DECNET_CONF_DEV_FORWARDING = 5 , NET_DECNET_CONF_DEV_BLKSIZE = 6 , NET_DECNET_CONF_DEV_STATE = 7 } ;
enum { NET_SCTP_RTO_INITIAL = 1 , NET_SCTP_RTO_MIN = 2 , NET_SCTP_RTO_MAX = 3 , NET_SCTP_RTO_ALPHA = 4 , NET_SCTP_RTO_BETA = 5 , NET_SCTP_VALID_COOKIE_LIFE = 6 , NET_SCTP_ASSOCIATION_MAX_RETRANS = 7 , NET_SCTP_PATH_MAX_RETRANS = 8 , NET_SCTP_MAX_INIT_RETRANSMITS = 9 , NET_SCTP_HB_INTERVAL = 10 , NET_SCTP_PRESERVE_ENABLE = 11 , NET_SCTP_MAX_BURST = 12 , NET_SCTP_ADDIP_ENABLE = 13 , NET_SCTP_PRSCTP_ENABLE = 14 , NET_SCTP_SNDBUF_POLICY = 15 , NET_SCTP_SACK_TIMEOUT = 16 , NET_SCTP_RCVBUF_POLICY = 17 , } ;
enum { NET_BRIDGE_NF_CALL_ARPTABLES = 1 , NET_BRIDGE_NF_CALL_IPTABLES = 2 , NET_BRIDGE_NF_CALL_IP6TABLES = 3 , NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4 , NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5 , } ;
enum { NET_IRDA_DISCOVERY = 1 , NET_IRDA_DEVNAME = 2 , NET_IRDA_DEBUG = 3 , NET_IRDA_FAST_POLL = 4 , NET_IRDA_DISCOVERY_SLOTS = 5 , NET_IRDA_DISCOVERY_TIMEOUT = 6 , NET_IRDA_SLOT_TIMEOUT = 7 , NET_IRDA_MAX_BAUD_RATE = 8 , NET_IRDA_MIN_TX_TURN_TIME = 9 , NET_IRDA_MAX_TX_DATA_SIZE = 10 , NET_IRDA_MAX_TX_WINDOW = 11 , NET_IRDA_MAX_NOREPLY_TIME = 12 , NET_IRDA_WARN_NOREPLY_TIME = 13 , NET_IRDA_LAP_KEEPALIVE_TIME = 14 , } ;
enum { FS_NRINODE = 1 , FS_STATINODE = 2 , FS_MAXINODE = 3 , FS_NRDQUOT = 4 , FS_MAXDQUOT = 5 , FS_NRFILE = 6 , FS_MAXFILE = 7 , FS_DENTRY = 8 , FS_NRSUPER = 9 , FS_MAXSUPER = 10 , FS_OVERFLOWUID = 11 , FS_OVERFLOWGID = 12 , FS_LEASES = 13 , FS_DIR_NOTIFY = 14 , FS_LEASE_TIME = 15 , FS_DQSTATS = 16 , FS_XFS = 17 , FS_AIO_NR = 18 , FS_AIO_MAX_NR = 19 , FS_INOTIFY = 20 , FS_OCFS2 = 988 , } ;
enum { FS_DQ_LOOKUPS = 1 , FS_DQ_DROPS = 2 , FS_DQ_READS = 3 , FS_DQ_WRITES = 4 , FS_DQ_CACHE_HITS = 5 , FS_DQ_ALLOCATED = 6 , FS_DQ_FREE = 7 , FS_DQ_SYNCS = 8 , FS_DQ_WARNINGS = 9 , } ;
enum { DEV_CDROM = 1 , DEV_HWMON = 2 , DEV_PARPORT = 3 , DEV_RAID = 4 , DEV_MAC_HID = 5 , DEV_SCSI = 6 , DEV_IPMI = 7 , } ;
enum { DEV_CDROM_INFO = 1 , DEV_CDROM_AUTOCLOSE = 2 , DEV_CDROM_AUTOEJECT = 3 , DEV_CDROM_DEBUG = 4 , DEV_CDROM_LOCK = 5 , DEV_CDROM_CHECK_MEDIA = 6 } ;
enum { DEV_PARPORT_DEFAULT = - 3 } ;
enum { DEV_RAID_SPEED_LIMIT_MIN = 1 , DEV_RAID_SPEED_LIMIT_MAX = 2 } ;
enum { DEV_PARPORT_DEFAULT_TIMESLICE = 1 , DEV_PARPORT_DEFAULT_SPINTIME = 2 } ;
enum { DEV_PARPORT_SPINTIME = 1 , DEV_PARPORT_BASE_ADDR = 2 , DEV_PARPORT_IRQ = 3 , DEV_PARPORT_DMA = 4 , DEV_PARPORT_MODES = 5 , DEV_PARPORT_DEVICES = 6 , DEV_PARPORT_AUTOPROBE = 16 } ;
enum { DEV_PARPORT_DEVICES_ACTIVE = - 3 , } ;
enum { DEV_PARPORT_DEVICE_TIMESLICE = 1 , } ;
enum { DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1 , DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2 , DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3 , DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4 , DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5 , DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6 } ;
enum { DEV_SCSI_LOGGING_LEVEL = 1 , } ;
enum { DEV_IPMI_POWEROFF_POWERCYCLE = 1 , } ;
enum { ABI_DEFHANDLER_COFF = 1 , ABI_DEFHANDLER_ELF = 2 , ABI_DEFHANDLER_LCALL7 = 3 , ABI_DEFHANDLER_LIBCSO = 4 , ABI_TRACE = 5 , ABI_FAKE_UTSNAME = 6 , } ;
struct nsproxy ;

struct ctl_table_root ;

struct ctl_table_set { struct list_head list ; struct ctl_table_set * parent ; int ( * is_seen ) ( struct ctl_table_set * ) ; } ;

struct ctl_table_header ;

typedef struct ctl_table ctl_table ;

typedef int ctl_handler ( struct ctl_table * table , void * oldval , size_t * oldlenp , void * newval , size_t newlen ) ;

typedef int proc_handler ( struct ctl_table * ctl , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

struct ctl_table { int ctl_name ; const char * procname ; void * data ; int maxlen ; mode_t mode ; struct ctl_table * child ; struct ctl_table * parent ; proc_handler * proc_handler ; ctl_handler * strategy ; void * extra1 ; void * extra2 ; } ;
struct ctl_table_root { struct list_head root_list ; struct ctl_table_set default_set ; struct ctl_table_set * ( * lookup ) ( struct ctl_table_root * root , struct nsproxy * namespaces ) ; int ( * permissions ) ( struct ctl_table_root * root , struct nsproxy * namespaces , struct ctl_table * table ) ; } ;
struct ctl_table_header { struct ctl_table * ctl_table ; struct list_head ctl_entry ; int used ; int count ; struct completion * unregistering ; struct ctl_table * ctl_table_arg ; struct ctl_table_root * root ; struct ctl_table_set * set ; struct ctl_table * attached_by ; struct ctl_table * attached_to ; struct ctl_table_header * parent ; } ;
struct ctl_path { const char * procname ; int ctl_name ; } ;

typedef int32_t key_serial_t ;

typedef uint32_t key_perm_t ;

struct user_struct ;

struct signal_struct ;

struct cred ;

struct key_type ;

struct key_owner ;

struct keyring_list ;

struct keyring_name ;

typedef struct __key_reference_with_attributes * key_ref_t ;

struct key { atomic_t usage ; key_serial_t serial ; struct rb_node serial_node ; struct key_type * type ; struct rw_semaphore sem ; struct key_user * user ; void * security ; union { time_t expiry ; time_t revoked_at ; } ; uid_t uid ; gid_t gid ; key_perm_t perm ; unsigned short quotalen ; unsigned short datalen ; unsigned long flags ; char * description ; union { struct list_head link ; unsigned long x [ 2 ] ; void * p [ 2 ] ; } type_data ; union { unsigned long value ; void * data ; struct keyring_list * subscriptions ; } payload ; } ;
struct selinux_audit_rule ;

struct audit_context ;

struct kern_ipc_perm ;
struct inode ;

struct group_info { atomic_t usage ; int ngroups ; int nblocks ; gid_t small_block [ 32 ] ; gid_t * blocks [ 0 ] ; } ;

struct thread_group_cred { atomic_t usage ; pid_t tgid ; spinlock_t lock ; struct key * session_keyring ; struct key * process_keyring ; struct rcu_head rcu ; } ;

struct cred { atomic_t usage ; uid_t uid ; gid_t gid ; uid_t suid ; gid_t sgid ; uid_t euid ; gid_t egid ; uid_t fsuid ; gid_t fsgid ; unsigned securebits ; kernel_cap_t cap_inheritable ; kernel_cap_t cap_permitted ; kernel_cap_t cap_effective ; kernel_cap_t cap_bset ; unsigned char jit_keyring ; struct key * thread_keyring ; struct key * request_key_auth ; struct thread_group_cred * tgcred ; void * security ; struct user_struct * user ; struct group_info * group_info ; struct rcu_head rcu ; } ;
struct futex_pi_state ;

struct robust_list_head ;

struct bio ;

struct fs_struct ;

struct bts_context ;

struct perf_event_context ;

struct cfs_rq ;

struct task_group ;

struct user_namespace ;

typedef unsigned long aio_context_t ;

enum { IOCB_CMD_PREAD = 0 , IOCB_CMD_PWRITE = 1 , IOCB_CMD_FSYNC = 2 , IOCB_CMD_FDSYNC = 3 , IOCB_CMD_NOOP = 6 , IOCB_CMD_PREADV = 7 , IOCB_CMD_PWRITEV = 8 , } ;
struct io_event { __u64 data ; __u64 obj ; __s64 res ; __s64 res2 ; } ;

struct iocb { __u64 aio_data ; __u32 aio_key , aio_reserved1 ; __u16 aio_lio_opcode ; __s16 aio_reqprio ; __u32 aio_fildes ; __u64 aio_buf ; __u64 aio_nbytes ; __s64 aio_offset ; __u64 aio_reserved2 ; __u32 aio_flags ; __u32 aio_resfd ; } ;

struct iovec { void * iov_base ; __kernel_size_t iov_len ; } ;
struct kvec { void * iov_base ; size_t iov_len ; } ;

struct kioctx ;

struct kiocb { struct list_head ki_run_list ; unsigned long ki_flags ; int ki_users ; unsigned ki_key ; struct file * ki_filp ; struct kioctx * ki_ctx ; int ( * ki_cancel ) ( struct kiocb * , struct io_event * ) ; ssize_t ( * ki_retry ) ( struct kiocb * ) ; void ( * ki_dtor ) ( struct kiocb * ) ; union { void * user ; struct task_struct * tsk ; } ki_obj ; __u64 ki_user_data ; wait_queue_t ki_wait ; loff_t ki_pos ; void * private ; unsigned short ki_opcode ; size_t ki_nbytes ; char * ki_buf ; size_t ki_left ; struct iovec ki_inline_vec ; struct iovec * ki_iovec ; unsigned long ki_nr_segs ; unsigned long ki_cur_seg ; struct list_head ki_list ; struct eventfd_ctx * ki_eventfd ; } ;

struct aio_ring { unsigned id ; unsigned nr ; unsigned head ; unsigned tail ; unsigned magic ; unsigned compat_features ; unsigned incompat_features ; unsigned header_length ; struct io_event io_events [ 0 ] ; } ;

struct aio_ring_info { unsigned long mmap_base ; unsigned long mmap_size ; struct page * * ring_pages ; spinlock_t ring_lock ; long nr_pages ; unsigned nr , tail ; struct page * internal_pages [ 8 ] ; } ;

struct kioctx { atomic_t users ; int dead ; struct mm_struct * mm ; unsigned long user_id ; struct hlist_node list ; wait_queue_head_t wait ; spinlock_t ctx_lock ; int reqs_active ; struct list_head active_reqs ; struct list_head run_list ; unsigned max_reqs ; struct aio_ring_info ring_info ; struct delayed_work wq ; struct rcu_head rcu_head ; } ;
struct sighand_struct { atomic_t count ; struct k_sigaction action [ 64 ] ; spinlock_t siglock ; wait_queue_head_t signalfd_wqh ; } ;

struct pacct_struct { int ac_flag ; long ac_exitcode ; unsigned long ac_mem ; cputime_t ac_utime , ac_stime ; unsigned long ac_minflt , ac_majflt ; } ;

struct cpu_itimer { cputime_t expires ; cputime_t incr ; u32 error ; u32 incr_error ; } ;

struct task_cputime { cputime_t utime ; cputime_t stime ; unsigned long long sum_exec_runtime ; } ;

struct thread_group_cputimer { struct task_cputime cputime ; int running ; spinlock_t lock ; } ;

struct signal_struct { atomic_t count ; atomic_t live ; wait_queue_head_t wait_chldexit ; struct task_struct * curr_target ; struct sigpending shared_pending ; int group_exit_code ; int notify_count ; struct task_struct * group_exit_task ; int group_stop_count ; unsigned int flags ; struct list_head posix_timers ; struct hrtimer real_timer ; struct pid * leader_pid ; ktime_t it_real_incr ; struct cpu_itimer it [ 2 ] ; struct thread_group_cputimer cputimer ; struct task_cputime cputime_expires ; struct list_head cpu_timers [ 3 ] ; struct pid * tty_old_pgrp ; int leader ; struct tty_struct * tty ; cputime_t utime , stime , cutime , cstime ; cputime_t gtime ; cputime_t cgtime ; cputime_t prev_utime , prev_stime ; unsigned long nvcsw , nivcsw , cnvcsw , cnivcsw ; unsigned long min_flt , maj_flt , cmin_flt , cmaj_flt ; unsigned long inblock , oublock , cinblock , coublock ; unsigned long maxrss , cmaxrss ; struct task_io_accounting ioac ; unsigned long long sum_sched_runtime ; struct rlimit rlim [ 16 ] ; struct pacct_struct pacct ; struct taskstats * stats ; unsigned audit_tty ; struct tty_audit_buf * tty_audit_buf ; int oom_adj ; } ;
struct user_struct { atomic_t __count ; atomic_t processes ; atomic_t files ; atomic_t sigpending ; atomic_t inotify_watches ; atomic_t inotify_devs ; atomic_t epoll_watches ; unsigned long mq_bytes ; unsigned long locked_shm ; struct key * uid_keyring ; struct key * session_keyring ; struct hlist_node uidhash_node ; uid_t uid ; struct user_namespace * user_ns ; atomic_long_t locked_vm ; } ;
struct backing_dev_info ;

struct reclaim_state ;

struct sched_info { unsigned long pcount ; unsigned long long run_delay ; unsigned long long last_arrival , last_queued ; unsigned int bkl_count ; } ;

enum cpu_idle_type { CPU_IDLE , CPU_NOT_IDLE , CPU_NEWLY_IDLE , CPU_MAX_IDLE_TYPES } ;

enum powersavings_balance_level { POWERSAVINGS_BALANCE_NONE = 0 , POWERSAVINGS_BALANCE_BASIC , POWERSAVINGS_BALANCE_WAKEUP , MAX_POWERSAVINGS_BALANCE_LEVELS } ;

struct sched_group { struct sched_group * next ; unsigned int cpu_power ; unsigned long cpumask [ 0 ] ; } ;

enum sched_domain_level { SD_LV_NONE = 0 , SD_LV_SIBLING , SD_LV_MC , SD_LV_CPU , SD_LV_NODE , SD_LV_ALLNODES , SD_LV_MAX } ;

struct sched_domain_attr { int relax_domain_level ; } ;

struct sched_domain { struct sched_domain * parent ; struct sched_domain * child ; struct sched_group * groups ; unsigned long min_interval ; unsigned long max_interval ; unsigned int busy_factor ; unsigned int imbalance_pct ; unsigned int cache_nice_tries ; unsigned int busy_idx ; unsigned int idle_idx ; unsigned int newidle_idx ; unsigned int wake_idx ; unsigned int forkexec_idx ; unsigned int smt_gain ; int flags ; enum sched_domain_level level ; unsigned long last_balance ; unsigned int balance_interval ; unsigned int nr_balance_failed ; u64 last_update ; unsigned int lb_count [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_failed [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_balanced [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_imbalance [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_gained [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_hot_gained [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_nobusyg [ CPU_MAX_IDLE_TYPES ] ; unsigned int lb_nobusyq [ CPU_MAX_IDLE_TYPES ] ; unsigned int alb_count ; unsigned int alb_failed ; unsigned int alb_pushed ; unsigned int sbe_count ; unsigned int sbe_balanced ; unsigned int sbe_pushed ; unsigned int sbf_count ; unsigned int sbf_balanced ; unsigned int sbf_pushed ; unsigned int ttwu_wake_remote ; unsigned int ttwu_move_affine ; unsigned int ttwu_move_balance ; char * name ; unsigned long span [ 0 ] ; } ;

struct io_context ;

struct mempolicy ;

struct pipe_inode_info ;

struct uts_namespace ;

struct rq ;

struct sched_domain ;
struct sched_class { const struct sched_class * next ; void ( * enqueue_task ) ( struct rq * rq , struct task_struct * p , int wakeup ) ; void ( * dequeue_task ) ( struct rq * rq , struct task_struct * p , int sleep ) ; void ( * yield_task ) ( struct rq * rq ) ; void ( * check_preempt_curr ) ( struct rq * rq , struct task_struct * p , int flags ) ; struct task_struct * ( * pick_next_task ) ( struct rq * rq ) ; void ( * put_prev_task ) ( struct rq * rq , struct task_struct * p ) ; int ( * select_task_rq ) ( struct task_struct * p , int sd_flag , int flags ) ; unsigned long ( * load_balance ) ( struct rq * this_rq , int this_cpu , struct rq * busiest , unsigned long max_load_move , struct sched_domain * sd , enum cpu_idle_type idle , int * all_pinned , int * this_best_prio ) ; int ( * move_one_task ) ( struct rq * this_rq , int this_cpu , struct rq * busiest , struct sched_domain * sd , enum cpu_idle_type idle ) ; void ( * pre_schedule ) ( struct rq * this_rq , struct task_struct * task ) ; void ( * post_schedule ) ( struct rq * this_rq ) ; void ( * task_wake_up ) ( struct rq * this_rq , struct task_struct * task ) ; void ( * set_cpus_allowed ) ( struct task_struct * p , const struct cpumask * newmask ) ; void ( * rq_online ) ( struct rq * rq ) ; void ( * rq_offline ) ( struct rq * rq ) ; void ( * set_curr_task ) ( struct rq * rq ) ; void ( * task_tick ) ( struct rq * rq , struct task_struct * p , int queued ) ; void ( * task_new ) ( struct rq * rq , struct task_struct * p ) ; void ( * switched_from ) ( struct rq * this_rq , struct task_struct * task , int running ) ; void ( * switched_to ) ( struct rq * this_rq , struct task_struct * task , int running ) ; void ( * prio_changed ) ( struct rq * this_rq , struct task_struct * task , int oldprio , int running ) ; unsigned int ( * get_rr_interval ) ( struct task_struct * task ) ; void ( * moved_group ) ( struct task_struct * p ) ; } ;

struct load_weight { unsigned long weight , inv_weight ; } ;

struct sched_entity { struct load_weight load ; struct rb_node run_node ; struct list_head group_node ; unsigned int on_rq ; u64 exec_start ; u64 sum_exec_runtime ; u64 vruntime ; u64 prev_sum_exec_runtime ; u64 last_wakeup ; u64 avg_overlap ; u64 nr_migrations ; u64 start_runtime ; u64 avg_wakeup ; u64 avg_running ; u64 wait_start ; u64 wait_max ; u64 wait_count ; u64 wait_sum ; u64 iowait_count ; u64 iowait_sum ; u64 sleep_start ; u64 sleep_max ; s64 sum_sleep_runtime ; u64 block_start ; u64 block_max ; u64 exec_max ; u64 slice_max ; u64 nr_migrations_cold ; u64 nr_failed_migrations_affine ; u64 nr_failed_migrations_running ; u64 nr_failed_migrations_hot ; u64 nr_forced_migrations ; u64 nr_forced2_migrations ; u64 nr_wakeups ; u64 nr_wakeups_sync ; u64 nr_wakeups_migrate ; u64 nr_wakeups_local ; u64 nr_wakeups_remote ; u64 nr_wakeups_affine ; u64 nr_wakeups_affine_attempts ; u64 nr_wakeups_passive ; u64 nr_wakeups_idle ; struct sched_entity * parent ; struct cfs_rq * cfs_rq ; struct cfs_rq * my_q ; } ;

struct sched_rt_entity { struct list_head run_list ; unsigned long timeout ; unsigned int time_slice ; int nr_cpus_allowed ; struct sched_rt_entity * back ; struct sched_rt_entity * parent ; struct rt_rq * rt_rq ; struct rt_rq * my_q ; } ;

struct rcu_node ;

struct task_struct { volatile long state ; void * stack ; atomic_t usage ; unsigned int flags ; unsigned int ptrace ; int lock_depth ; int prio , static_prio , normal_prio ; unsigned int rt_priority ; const struct sched_class * sched_class ; struct sched_entity se ; struct sched_rt_entity rt ; struct hlist_head preempt_notifiers ; unsigned char fpu_counter ; unsigned int btrace_seq ; unsigned int policy ; cpumask_t cpus_allowed ; struct sched_info sched_info ; struct list_head tasks ; struct plist_node pushable_tasks ; struct mm_struct * mm , * active_mm ; int exit_state ; int exit_code , exit_signal ; int pdeath_signal ; unsigned int personality ; unsigned did_exec : 1 ; unsigned in_execve : 1 ; unsigned in_iowait : 1 ; unsigned sched_reset_on_fork : 1 ; pid_t pid ; pid_t tgid ; unsigned long stack_canary ; struct task_struct * real_parent ; struct task_struct * parent ; struct list_head children ; struct list_head sibling ; struct task_struct * group_leader ; struct list_head ptraced ; struct list_head ptrace_entry ; struct bts_context * bts ; struct pid_link pids [ PIDTYPE_MAX ] ; struct list_head thread_group ; struct completion * vfork_done ; int * set_child_tid ; int * clear_child_tid ; cputime_t utime , stime , utimescaled , stimescaled ; cputime_t gtime ; cputime_t prev_utime , prev_stime ; unsigned long nvcsw , nivcsw ; struct timespec start_time ; struct timespec real_start_time ; unsigned long min_flt , maj_flt ; struct task_cputime cputime_expires ; struct list_head cpu_timers [ 3 ] ; const struct cred * real_cred ; const struct cred * cred ; struct mutex cred_guard_mutex ; struct cred * replacement_session_keyring ; char comm [ 16 ] ; int link_count , total_link_count ; struct sysv_sem sysvsem ; unsigned long last_switch_count ; struct thread_struct thread ; struct fs_struct * fs ; struct files_struct * files ; struct nsproxy * nsproxy ; struct signal_struct * signal ; struct sighand_struct * sighand ; sigset_t blocked , real_blocked ; sigset_t saved_sigmask ; struct sigpending pending ; unsigned long sas_ss_sp ; size_t sas_ss_size ; int ( * notifier ) ( void * priv ) ; void * notifier_data ; sigset_t * notifier_mask ; struct audit_context * audit_context ; uid_t loginuid ; unsigned int sessionid ; seccomp_t seccomp ; u32 parent_exec_id ; u32 self_exec_id ; spinlock_t alloc_lock ; struct irqaction * irqaction ; spinlock_t pi_lock ; struct plist_head pi_waiters ; struct rt_mutex_waiter * pi_blocked_on ; void * journal_info ; struct bio * bio_list , * * bio_tail ; struct reclaim_state * reclaim_state ; struct backing_dev_info * backing_dev_info ; struct io_context * io_context ; unsigned long ptrace_message ; siginfo_t * last_siginfo ; struct task_io_accounting ioac ; u64 acct_rss_mem1 ; u64 acct_vm_mem1 ; cputime_t acct_timexpd ; nodemask_t mems_allowed ; int cpuset_mem_spread_rotor ; struct css_set * cgroups ; struct list_head cg_list ; struct robust_list_head * robust_list ; struct compat_robust_list_head * compat_robust_list ; struct list_head pi_state_list ; struct futex_pi_state * pi_state_cache ; struct perf_event_context * perf_event_ctxp ; struct mutex perf_event_mutex ; struct list_head perf_event_list ; struct mempolicy * mempolicy ; short il_next ; atomic_t fs_excl ; struct rcu_head rcu ; struct pipe_inode_info * splice_pipe ; struct prop_local_single dirties ; int latency_record_count ; struct latency_record latency_record [ 32 ] ; unsigned long timer_slack_ns ; unsigned long default_timer_slack_ns ; struct list_head * scm_work_list ; int curr_ret_stack ; struct ftrace_ret_stack * ret_stack ; unsigned long long ftrace_timestamp ; atomic_t trace_overrun ; atomic_t tracing_graph_pause ; unsigned long trace ; unsigned long trace_recursion ; } ;
union thread_union { struct thread_info thread_info ; unsigned long stack [ ( ( ( 1UL ) << 12 ) << 1 ) / sizeof ( long ) ] ; } ;

enum irqreturn { IRQ_NONE , IRQ_HANDLED , IRQ_WAKE_THREAD , } ;

typedef enum irqreturn irqreturn_t ;


struct irq_desc ;

typedef void ( * irq_flow_handler_t ) ( unsigned int irq , struct irq_desc * desc ) ;
struct proc_dir_entry ;

struct msi_desc ;

struct irq_chip { const char * name ; unsigned int ( * startup ) ( unsigned int irq ) ; void ( * shutdown ) ( unsigned int irq ) ; void ( * enable ) ( unsigned int irq ) ; void ( * disable ) ( unsigned int irq ) ; void ( * ack ) ( unsigned int irq ) ; void ( * mask ) ( unsigned int irq ) ; void ( * mask_ack ) ( unsigned int irq ) ; void ( * unmask ) ( unsigned int irq ) ; void ( * eoi ) ( unsigned int irq ) ; void ( * end ) ( unsigned int irq ) ; int ( * set_affinity ) ( unsigned int irq , const struct cpumask * dest ) ; int ( * retrigger ) ( unsigned int irq ) ; int ( * set_type ) ( unsigned int irq , unsigned int flow_type ) ; int ( * set_wake ) ( unsigned int irq , unsigned int on ) ; void ( * bus_lock ) ( unsigned int irq ) ; void ( * bus_sync_unlock ) ( unsigned int irq ) ; const char * typename ; } ;

struct timer_rand_state ;

struct irq_2_iommu ;

struct irq_desc { unsigned int irq ; struct timer_rand_state * timer_rand_state ; unsigned int * kstat_irqs ; irq_flow_handler_t handle_irq ; struct irq_chip * chip ; struct msi_desc * msi_desc ; void * handler_data ; void * chip_data ; struct irqaction * action ; unsigned int status ; unsigned int depth ; unsigned int wake_depth ; unsigned int irq_count ; unsigned long last_unhandled ; unsigned int irqs_unhandled ; spinlock_t lock ; cpumask_var_t affinity ; unsigned int node ; cpumask_var_t pending_mask ; atomic_t threads_active ; wait_queue_head_t wait_for_threads ; struct proc_dir_entry * dir ; const char * name ; } __attribute__ ( ( __aligned__ ( 1 << ( ( 6 ) ) ) ) ) ;
enum profile_type { PROFILE_TASK_EXIT , PROFILE_MUNMAP } ;

struct io_apic_irq_attr { int ioapic ; int ioapic_pin ; int trigger ; int polarity ; } ;
typedef int vector_irq_t [ 256 ] ;
typedef struct { unsigned int __softirq_pending ; unsigned int __nmi_count ; unsigned int irq0_irqs ; unsigned int apic_timer_irqs ; unsigned int irq_spurious_count ; unsigned int generic_irqs ; unsigned int apic_perf_irqs ; unsigned int apic_pending_irqs ; unsigned int irq_resched_count ; unsigned int irq_call_count ; unsigned int irq_tlb_count ; unsigned int irq_thermal_count ; unsigned int irq_threshold_count ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) irq_cpustat_t ;

struct taskstats { __u16 version ; __u32 ac_exitcode ; __u8 ac_flag ; __u8 ac_nice ; __u64 cpu_count __attribute__ ( ( aligned ( 8 ) ) ) ; __u64 cpu_delay_total ; __u64 blkio_count ; __u64 blkio_delay_total ; __u64 swapin_count ; __u64 swapin_delay_total ; __u64 cpu_run_real_total ; __u64 cpu_run_virtual_total ; char ac_comm [ 32 ] ; __u8 ac_sched __attribute__ ( ( aligned ( 8 ) ) ) ; __u8 ac_pad [ 3 ] ; __u32 ac_uid __attribute__ ( ( aligned ( 8 ) ) ) ; __u32 ac_gid ; __u32 ac_pid ; __u32 ac_ppid ; __u32 ac_btime ; __u64 ac_etime __attribute__ ( ( aligned ( 8 ) ) ) ; __u64 ac_utime ; __u64 ac_stime ; __u64 ac_minflt ; __u64 ac_majflt ; __u64 coremem ; __u64 virtmem ; __u64 hiwater_rss ; __u64 hiwater_vm ; __u64 read_char ; __u64 write_char ; __u64 read_syscalls ; __u64 write_syscalls ; __u64 read_bytes ; __u64 write_bytes ; __u64 cancelled_write_bytes ; __u64 nvcsw ; __u64 nivcsw ; __u64 ac_utimescaled ; __u64 ac_stimescaled ; __u64 cpu_scaled_run_real_total ; __u64 freepages_count ; __u64 freepages_delay_total ; } ;

enum { TASKSTATS_CMD_UNSPEC = 0 , TASKSTATS_CMD_GET , TASKSTATS_CMD_NEW , __TASKSTATS_CMD_MAX , } ;
enum { TASKSTATS_TYPE_UNSPEC = 0 , TASKSTATS_TYPE_PID , TASKSTATS_TYPE_TGID , TASKSTATS_TYPE_STATS , TASKSTATS_TYPE_AGGR_PID , TASKSTATS_TYPE_AGGR_TGID , __TASKSTATS_TYPE_MAX , } ;
enum { TASKSTATS_CMD_ATTR_UNSPEC = 0 , TASKSTATS_CMD_ATTR_PID , TASKSTATS_CMD_ATTR_TGID , TASKSTATS_CMD_ATTR_REGISTER_CPUMASK , TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK , __TASKSTATS_CMD_ATTR_MAX , } ;
struct cgroupstats { __u64 nr_sleeping ; __u64 nr_running ; __u64 nr_stopped ; __u64 nr_uninterruptible ; __u64 nr_io_wait ; } ;

enum { CGROUPSTATS_CMD_UNSPEC = __TASKSTATS_CMD_MAX , CGROUPSTATS_CMD_GET , CGROUPSTATS_CMD_NEW , __CGROUPSTATS_CMD_MAX , } ;
enum { CGROUPSTATS_TYPE_UNSPEC = 0 , CGROUPSTATS_TYPE_CGROUP_STATS , __CGROUPSTATS_TYPE_MAX , } ;
enum { CGROUPSTATS_CMD_ATTR_UNSPEC = 0 , CGROUPSTATS_CMD_ATTR_FD , __CGROUPSTATS_CMD_ATTR_MAX , } ;
struct ptr_heap { void * * ptrs ; int max ; int size ; int ( * gt ) ( void * , void * ) ; } ;

struct idr_layer { unsigned long bitmap ; struct idr_layer * ary [ 1 << 6 ] ; int count ; int layer ; struct rcu_head rcu_head ; } ;

struct idr { struct idr_layer * top ; struct idr_layer * id_free ; int layers ; int id_free_cnt ; spinlock_t lock ; } ;

struct ida_bitmap { long nr_busy ; unsigned long bitmap [ ( 128 / sizeof ( long ) - 1 ) ] ; } ;

struct ida { struct idr idr ; struct ida_bitmap * free_bitmap ; } ;

struct cgroupfs_root ;

struct cgroup_subsys ;

struct cgroup ;

struct css_id ;

enum cgroup_subsys_id { cpuset_subsys_id , ns_subsys_id , cpu_cgroup_subsys_id , cpuacct_subsys_id , mem_cgroup_subsys_id , devices_subsys_id , freezer_subsys_id , net_cls_subsys_id , CGROUP_SUBSYS_COUNT } ;

struct cgroup_subsys_state { struct cgroup * cgroup ; atomic_t refcnt ; unsigned long flags ; struct css_id * id ; } ;

enum { CSS_ROOT , CSS_REMOVED , } ;
enum { CGRP_REMOVED , CGRP_RELEASABLE , CGRP_NOTIFY_ON_RELEASE , CGRP_WAIT_ON_RMDIR , } ;
enum cgroup_filetype { CGROUP_FILE_PROCS , CGROUP_FILE_TASKS , } ;

struct cgroup_pidlist { struct { enum cgroup_filetype type ; struct pid_namespace * ns ; } key ; pid_t * list ; int length ; int use_count ; struct list_head links ; struct cgroup * owner ; struct rw_semaphore mutex ; } ;

struct cgroup { unsigned long flags ; atomic_t count ; struct list_head sibling ; struct list_head children ; struct cgroup * parent ; struct dentry * dentry ; struct cgroup_subsys_state * subsys [ CGROUP_SUBSYS_COUNT ] ; struct cgroupfs_root * root ; struct cgroup * top_cgroup ; struct list_head css_sets ; struct list_head release_list ; struct list_head pidlists ; struct mutex pidlist_mutex ; struct rcu_head rcu_head ; } ;
struct css_set { atomic_t refcount ; struct hlist_node hlist ; struct list_head tasks ; struct list_head cg_links ; struct cgroup_subsys_state * subsys [ CGROUP_SUBSYS_COUNT ] ; struct rcu_head rcu_head ; } ;

struct cgroup_map_cb { int ( * fill ) ( struct cgroup_map_cb * cb , const char * key , u64 value ) ; void * state ; } ;

struct cftype { char name [ 64 ] ; int private ; mode_t mode ; size_t max_write_len ; int ( * open ) ( struct inode * inode , struct file * file ) ; ssize_t ( * read ) ( struct cgroup * cgrp , struct cftype * cft , struct file * file , char * buf , size_t nbytes , loff_t * ppos ) ; u64 ( * read_u64 ) ( struct cgroup * cgrp , struct cftype * cft ) ; s64 ( * read_s64 ) ( struct cgroup * cgrp , struct cftype * cft ) ; int ( * read_map ) ( struct cgroup * cont , struct cftype * cft , struct cgroup_map_cb * cb ) ; int ( * read_seq_string ) ( struct cgroup * cont , struct cftype * cft , struct seq_file * m ) ; ssize_t ( * write ) ( struct cgroup * cgrp , struct cftype * cft , struct file * file , const char * buf , size_t nbytes , loff_t * ppos ) ; int ( * write_u64 ) ( struct cgroup * cgrp , struct cftype * cft , u64 val ) ; int ( * write_s64 ) ( struct cgroup * cgrp , struct cftype * cft , s64 val ) ; int ( * write_string ) ( struct cgroup * cgrp , struct cftype * cft , const char * buffer ) ; int ( * trigger ) ( struct cgroup * cgrp , unsigned int event ) ; int ( * release ) ( struct inode * inode , struct file * file ) ; } ;

struct cgroup_scanner { struct cgroup * cg ; int ( * test_task ) ( struct task_struct * p , struct cgroup_scanner * scan ) ; void ( * process_task ) ( struct task_struct * p , struct cgroup_scanner * scan ) ; struct ptr_heap * heap ; void * data ; } ;

struct cgroup_subsys { struct cgroup_subsys_state * ( * create ) ( struct cgroup_subsys * ss , struct cgroup * cgrp ) ; int ( * pre_destroy ) ( struct cgroup_subsys * ss , struct cgroup * cgrp ) ; void ( * destroy ) ( struct cgroup_subsys * ss , struct cgroup * cgrp ) ; int ( * can_attach ) ( struct cgroup_subsys * ss , struct cgroup * cgrp , struct task_struct * tsk , bool threadgroup ) ; void ( * attach ) ( struct cgroup_subsys * ss , struct cgroup * cgrp , struct cgroup * old_cgrp , struct task_struct * tsk , bool threadgroup ) ; void ( * fork ) ( struct cgroup_subsys * ss , struct task_struct * task ) ; void ( * exit ) ( struct cgroup_subsys * ss , struct task_struct * task ) ; int ( * populate ) ( struct cgroup_subsys * ss , struct cgroup * cgrp ) ; void ( * post_clone ) ( struct cgroup_subsys * ss , struct cgroup * cgrp ) ; void ( * bind ) ( struct cgroup_subsys * ss , struct cgroup * root ) ; int subsys_id ; int active ; int disabled ; int early_init ; bool use_id ; const char * name ; struct mutex hierarchy_mutex ; struct lock_class_key subsys_key ; struct cgroupfs_root * root ; struct list_head sibling ; struct idr idr ; spinlock_t id_lock ; } ;
struct cgroup_iter { struct list_head * cg_link ; struct list_head * task ; } ;

struct mem_cgroup ;

struct sys_device ;

struct sysdev_class { const char * name ; struct list_head drivers ; int ( * shutdown ) ( struct sys_device * ) ; int ( * suspend ) ( struct sys_device * , pm_message_t state ) ; int ( * resume ) ( struct sys_device * ) ; struct kset kset ; } ;

struct sysdev_class_attribute { struct attribute attr ; ssize_t ( * show ) ( struct sysdev_class * , char * ) ; ssize_t ( * store ) ( struct sysdev_class * , const char * , size_t ) ; } ;

struct sysdev_driver { struct list_head entry ; int ( * add ) ( struct sys_device * ) ; int ( * remove ) ( struct sys_device * ) ; int ( * shutdown ) ( struct sys_device * ) ; int ( * suspend ) ( struct sys_device * , pm_message_t state ) ; int ( * resume ) ( struct sys_device * ) ; } ;

struct sys_device { u32 id ; struct sysdev_class * cls ; struct kobject kobj ; } ;
struct sysdev_attribute { struct attribute attr ; ssize_t ( * show ) ( struct sys_device * , struct sysdev_attribute * , char * ) ; ssize_t ( * store ) ( struct sys_device * , struct sysdev_attribute * , const char * , size_t ) ; } ;

struct sysdev_ext_attribute { struct sysdev_attribute attr ; void * var ; } ;

struct node { struct sys_device sysdev ; } ;

struct memory_block ;

union swap_header { struct { char reserved [ ( ( 1UL ) << 12 ) - 10 ] ; char magic [ 10 ] ; } magic ; struct { char bootbits [ 1024 ] ; __u32 version ; __u32 last_page ; __u32 nr_badpages ; unsigned char sws_uuid [ 16 ] ; unsigned char sws_volume [ 16 ] ; __u32 padding [ 117 ] ; __u32 badpages [ 1 ] ; } info ; } ;

typedef struct { unsigned long val ; } swp_entry_t ;

struct reclaim_state { unsigned long reclaimed_slab ; } ;
struct writeback_control ;

struct swap_extent { struct list_head list ; unsigned long start_page ; unsigned long nr_pages ; sector_t start_block ; } ;

enum { SWP_USED = ( 1 << 0 ) , SWP_WRITEOK = ( 1 << 1 ) , SWP_DISCARDABLE = ( 1 << 2 ) , SWP_DISCARDING = ( 1 << 3 ) , SWP_SOLIDSTATE = ( 1 << 4 ) , SWP_SCANNING = ( 1 << 8 ) , } ;
struct swap_info_struct { unsigned long flags ; int prio ; int next ; struct file * swap_file ; struct block_device * bdev ; struct list_head extent_list ; struct swap_extent * curr_swap_extent ; unsigned short * swap_map ; unsigned int lowest_bit ; unsigned int highest_bit ; unsigned int lowest_alloc ; unsigned int highest_alloc ; unsigned int cluster_next ; unsigned int cluster_nr ; unsigned int pages ; unsigned int max ; unsigned int inuse_pages ; unsigned int old_block_size ; void ( * notify_swap_entry_free_fn ) ( unsigned long ) ; } ;

struct swap_list_t { int head ; int next ; } ;

struct anon_vma ;

struct file_ra_state ;

struct rlimit ;
struct vm_fault { unsigned int flags ; unsigned long pgoff ; void * virtual_address ; struct page * page ; } ;

struct vm_operations_struct { void ( * open ) ( struct vm_area_struct * area ) ; void ( * close ) ( struct vm_area_struct * area ) ; int ( * fault ) ( struct vm_area_struct * vma , struct vm_fault * vmf ) ; int ( * page_mkwrite ) ( struct vm_area_struct * vma , struct vm_fault * vmf ) ; int ( * access ) ( struct vm_area_struct * vma , unsigned long addr , void * buf , int len , int write ) ; int ( * set_policy ) ( struct vm_area_struct * vma , struct mempolicy * new ) ; struct mempolicy * ( * get_policy ) ( struct vm_area_struct * vma , unsigned long addr ) ; int ( * migrate ) ( struct vm_area_struct * vma , const nodemask_t * from , const nodemask_t * to , unsigned long flags ) ; } ;

struct mmu_gather ;

typedef void compound_page_dtor ( struct page * ) ;

enum vm_event_item { PGPGIN , PGPGOUT , PSWPIN , PSWPOUT , PGALLOC_DMA , PGALLOC_DMA32 , PGALLOC_NORMAL , PGALLOC_MOVABLE , PGFREE , PGACTIVATE , PGDEACTIVATE , PGFAULT , PGMAJFAULT , PGREFILL_DMA , PGREFILL_DMA32 , PGREFILL_NORMAL , PGREFILL_MOVABLE , PGSTEAL_DMA , PGSTEAL_DMA32 , PGSTEAL_NORMAL , PGSTEAL_MOVABLE , PGSCAN_KSWAPD_DMA , PGSCAN_KSWAPD_DMA32 , PGSCAN_KSWAPD_NORMAL , PGSCAN_KSWAPD_MOVABLE , PGSCAN_DIRECT_DMA , PGSCAN_DIRECT_DMA32 , PGSCAN_DIRECT_NORMAL , PGSCAN_DIRECT_MOVABLE , PGSCAN_ZONE_RECLAIM_FAILED , PGINODESTEAL , SLABS_SCANNED , KSWAPD_STEAL , KSWAPD_INODESTEAL , PAGEOUTRUN , ALLOCSTALL , PGROTATED , HTLB_BUDDY_PGALLOC , HTLB_BUDDY_PGALLOC_FAIL , UNEVICTABLE_PGCULLED , UNEVICTABLE_PGSCANNED , UNEVICTABLE_PGRESCUED , UNEVICTABLE_PGMLOCKED , UNEVICTABLE_PGMUNLOCKED , UNEVICTABLE_PGCLEARED , UNEVICTABLE_PGSTRANDED , UNEVICTABLE_MLOCKFREED , NR_VM_EVENT_ITEMS } ;

struct vm_event_state { unsigned long event [ NR_VM_EVENT_ITEMS ] ; } ;

struct zap_details { struct vm_area_struct * nonlinear_vma ; struct address_space * check_mapping ; unsigned long first_index ; unsigned long last_index ; spinlock_t * i_mmap_lock ; unsigned long truncate_count ; } ;

struct mm_walk { int ( * pgd_entry ) ( pgd_t * , unsigned long , unsigned long , struct mm_walk * ) ; int ( * pud_entry ) ( pud_t * , unsigned long , unsigned long , struct mm_walk * ) ; int ( * pmd_entry ) ( pmd_t * , unsigned long , unsigned long , struct mm_walk * ) ; int ( * pte_entry ) ( pte_t * , unsigned long , unsigned long , struct mm_walk * ) ; int ( * pte_hole ) ( unsigned long , unsigned long , struct mm_walk * ) ; struct mm_struct * mm ; void * private ; } ;

struct shrinker { int ( * shrink ) ( int nr_to_scan , gfp_t gfp_mask ) ; int seeks ; struct list_head list ; long nr ; } ;

typedef int ( * work_fn_t ) ( unsigned long , unsigned long , void * ) ;
typedef int ( * pte_fn_t ) ( pte_t * pte , pgtable_t token , unsigned long addr , void * data ) ;
typedef int suspend_state_t ;

struct platform_suspend_ops { int ( * valid ) ( suspend_state_t state ) ; int ( * begin ) ( suspend_state_t state ) ; int ( * prepare ) ( void ) ; int ( * prepare_late ) ( void ) ; int ( * enter ) ( suspend_state_t state ) ; void ( * wake ) ( void ) ; void ( * finish ) ( void ) ; void ( * end ) ( void ) ; void ( * recover ) ( void ) ; } ;

struct pbe { void * address ; void * orig_address ; struct pbe * next ; } ;

struct platform_hibernation_ops { int ( * begin ) ( void ) ; void ( * end ) ( void ) ; int ( * pre_snapshot ) ( void ) ; void ( * finish ) ( void ) ; int ( * prepare ) ( void ) ; int ( * enter ) ( void ) ; void ( * leave ) ( void ) ; int ( * pre_restore ) ( void ) ; void ( * restore_cleanup ) ( void ) ; void ( * recover ) ( void ) ; } ;

struct user_i387_ia32_struct { u32 cwd ; u32 swd ; u32 twd ; u32 fip ; u32 fcs ; u32 foo ; u32 fos ; u32 st_space [ 20 ] ; } ;

struct user32_fxsr_struct { unsigned short cwd ; unsigned short swd ; unsigned short twd ; unsigned short fop ; int fip ; int fcs ; int foo ; int fos ; int mxcsr ; int reserved ; int st_space [ 32 ] ; int xmm_space [ 32 ] ; int padding [ 56 ] ; } ;

struct user_regs_struct32 { __u32 ebx , ecx , edx , esi , edi , ebp , eax ; unsigned short ds , __ds , es , __es ; unsigned short fs , __fs , gs , __gs ; __u32 orig_eax , eip ; unsigned short cs , __cs ; __u32 eflags , esp ; unsigned short ss , __ss ; } ;

struct user32 { struct user_regs_struct32 regs ; int u_fpvalid ; struct user_i387_ia32_struct i387 ; __u32 u_tsize ; __u32 u_dsize ; __u32 u_ssize ; __u32 start_code ; __u32 start_stack ; __u32 signal ; int reserved ; __u32 u_ar0 ; __u32 u_fpstate ; __u32 magic ; char u_comm [ 32 ] ; int u_debugreg [ 8 ] ; } ;

typedef u32 compat_size_t ;

typedef s32 compat_ssize_t ;

typedef s32 compat_time_t ;

typedef s32 compat_clock_t ;

typedef s32 compat_pid_t ;

typedef u16 __compat_uid_t ;

typedef u16 __compat_gid_t ;

typedef u32 __compat_uid32_t ;

typedef u32 __compat_gid32_t ;

typedef u16 compat_mode_t ;

typedef u32 compat_ino_t ;

typedef u16 compat_dev_t ;

typedef s32 compat_off_t ;

typedef s64 compat_loff_t ;

typedef u16 compat_nlink_t ;

typedef u16 compat_ipc_pid_t ;

typedef s32 compat_daddr_t ;

typedef u32 compat_caddr_t ;

typedef __kernel_fsid_t compat_fsid_t ;

typedef s32 compat_timer_t ;

typedef s32 compat_key_t ;

typedef s32 compat_int_t ;

typedef s32 compat_long_t ;

typedef s64 __attribute__ ( ( aligned ( 4 ) ) ) compat_s64 ;

typedef u32 compat_uint_t ;

typedef u32 compat_ulong_t ;

typedef u64 __attribute__ ( ( aligned ( 4 ) ) ) compat_u64 ;

struct compat_timespec { compat_time_t tv_sec ; s32 tv_nsec ; } ;
struct compat_timeval { compat_time_t tv_sec ; s32 tv_usec ; } ;

struct compat_stat { compat_dev_t st_dev ; u16 __pad1 ; compat_ino_t st_ino ; compat_mode_t st_mode ; compat_nlink_t st_nlink ; __compat_uid_t st_uid ; __compat_gid_t st_gid ; compat_dev_t st_rdev ; u16 __pad2 ; u32 st_size ; u32 st_blksize ; u32 st_blocks ; u32 st_atime ; u32 st_atime_nsec ; u32 st_mtime ; u32 st_mtime_nsec ; u32 st_ctime ; u32 st_ctime_nsec ; u32 __unused4 ; u32 __unused5 ; } ;

struct compat_flock { short l_type ; short l_whence ; compat_off_t l_start ; compat_off_t l_len ; compat_pid_t l_pid ; } ;

struct compat_flock64 { short l_type ; short l_whence ; compat_loff_t l_start ; compat_loff_t l_len ; compat_pid_t l_pid ; } __attribute__ ( ( packed ) ) ;
struct compat_statfs { int f_type ; int f_bsize ; int f_blocks ; int f_bfree ; int f_bavail ; int f_files ; int f_ffree ; compat_fsid_t f_fsid ; int f_namelen ; int f_frsize ; int f_spare [ 5 ] ; } ;

typedef u32 compat_old_sigset_t ;

typedef u32 compat_sigset_word ;

struct compat_ipc64_perm { compat_key_t key ; __compat_uid32_t uid ; __compat_gid32_t gid ; __compat_uid32_t cuid ; __compat_gid32_t cgid ; unsigned short mode ; unsigned short __pad1 ; unsigned short seq ; unsigned short __pad2 ; compat_ulong_t unused1 ; compat_ulong_t unused2 ; } ;

struct compat_semid64_ds { struct compat_ipc64_perm sem_perm ; compat_time_t sem_otime ; compat_ulong_t __unused1 ; compat_time_t sem_ctime ; compat_ulong_t __unused2 ; compat_ulong_t sem_nsems ; compat_ulong_t __unused3 ; compat_ulong_t __unused4 ; } ;

struct compat_msqid64_ds { struct compat_ipc64_perm msg_perm ; compat_time_t msg_stime ; compat_ulong_t __unused1 ; compat_time_t msg_rtime ; compat_ulong_t __unused2 ; compat_time_t msg_ctime ; compat_ulong_t __unused3 ; compat_ulong_t msg_cbytes ; compat_ulong_t msg_qnum ; compat_ulong_t msg_qbytes ; compat_pid_t msg_lspid ; compat_pid_t msg_lrpid ; compat_ulong_t __unused4 ; compat_ulong_t __unused5 ; } ;

struct compat_shmid64_ds { struct compat_ipc64_perm shm_perm ; compat_size_t shm_segsz ; compat_time_t shm_atime ; compat_ulong_t __unused1 ; compat_time_t shm_dtime ; compat_ulong_t __unused2 ; compat_time_t shm_ctime ; compat_ulong_t __unused3 ; compat_pid_t shm_cpid ; compat_pid_t shm_lpid ; compat_ulong_t shm_nattch ; compat_ulong_t __unused4 ; compat_ulong_t __unused5 ; } ;

typedef struct user_regs_struct32 compat_elf_gregset_t ;

typedef u32 compat_uptr_t ;

typedef __compat_uid32_t compat_uid_t ;

typedef __compat_gid32_t compat_gid_t ;

struct compat_itimerspec { struct compat_timespec it_interval ; struct compat_timespec it_value ; } ;

struct compat_utimbuf { compat_time_t actime ; compat_time_t modtime ; } ;

struct compat_itimerval { struct compat_timeval it_interval ; struct compat_timeval it_value ; } ;

struct compat_tms { compat_clock_t tms_utime ; compat_clock_t tms_stime ; compat_clock_t tms_cutime ; compat_clock_t tms_cstime ; } ;

struct compat_timex { compat_uint_t modes ; compat_long_t offset ; compat_long_t freq ; compat_long_t maxerror ; compat_long_t esterror ; compat_int_t status ; compat_long_t constant ; compat_long_t precision ; compat_long_t tolerance ; struct compat_timeval time ; compat_long_t tick ; compat_long_t ppsfreq ; compat_long_t jitter ; compat_int_t shift ; compat_long_t stabil ; compat_long_t jitcnt ; compat_long_t calcnt ; compat_long_t errcnt ; compat_long_t stbcnt ; compat_int_t tai ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; compat_int_t : 32 ; } ;

typedef struct { compat_sigset_word sig [ ( 64 / 32 ) ] ; } compat_sigset_t ;

struct compat_iovec { compat_uptr_t iov_base ; compat_size_t iov_len ; } ;

struct compat_rlimit { compat_ulong_t rlim_cur ; compat_ulong_t rlim_max ; } ;

struct compat_rusage { struct compat_timeval ru_utime ; struct compat_timeval ru_stime ; compat_long_t ru_maxrss ; compat_long_t ru_ixrss ; compat_long_t ru_idrss ; compat_long_t ru_isrss ; compat_long_t ru_minflt ; compat_long_t ru_majflt ; compat_long_t ru_nswap ; compat_long_t ru_inblock ; compat_long_t ru_oublock ; compat_long_t ru_msgsnd ; compat_long_t ru_msgrcv ; compat_long_t ru_nsignals ; compat_long_t ru_nvcsw ; compat_long_t ru_nivcsw ; } ;

struct compat_siginfo ;

struct compat_dirent { u32 d_ino ; compat_off_t d_off ; u16 d_reclen ; char d_name [ 256 ] ; } ;

struct compat_ustat { compat_daddr_t f_tfree ; compat_ino_t f_tinode ; char f_fname [ 6 ] ; char f_fpack [ 6 ] ; } ;


typedef union compat_sigval { compat_int_t sival_int ; compat_uptr_t sival_ptr ; } compat_sigval_t ;


typedef struct compat_sigevent { compat_sigval_t sigev_value ; compat_int_t sigev_signo ; compat_int_t sigev_notify ; union { compat_int_t _pad [ ( ( 64 / sizeof ( int ) ) - 3 ) ] ; compat_int_t _tid ; struct { compat_uptr_t _function ; compat_uptr_t _attribute ; } _sigev_thread ; } _sigev_un ; } compat_sigevent_t ;

struct compat_robust_list { compat_uptr_t next ; } ;

struct compat_robust_list_head { struct compat_robust_list list ; compat_long_t futex_offset ; compat_uptr_t list_op_pending ; } ;

struct epoll_event ;

struct _xmmreg { __u32 element [ 4 ] ; } ;
struct _fpstate_ia32 { __u32 cw ; __u32 sw ; __u32 tag ; __u32 ipoff ; __u32 cssel ; __u32 dataoff ; __u32 datasel ; struct _fpreg _st [ 8 ] ; unsigned short status ; unsigned short magic ; __u32 _fxsr_env [ 6 ] ; __u32 mxcsr ; __u32 reserved ; struct _fpxreg _fxsr_st [ 8 ] ; struct _xmmreg _xmm [ 8 ] ; __u32 padding [ 44 ] ; union { __u32 padding2 [ 12 ] ; struct _fpx_sw_bytes sw_reserved ; } ; } ;

struct sigcontext_ia32 { unsigned short gs , __gsh ; unsigned short fs , __fsh ; unsigned short es , __esh ; unsigned short ds , __dsh ; unsigned int di ; unsigned int si ; unsigned int bp ; unsigned int sp ; unsigned int bx ; unsigned int dx ; unsigned int cx ; unsigned int ax ; unsigned int trapno ; unsigned int err ; unsigned int ip ; unsigned short cs , __csh ; unsigned int flags ; unsigned int sp_at_signal ; unsigned short ss , __ssh ; unsigned int fpstate ; unsigned int oldmask ; unsigned int cr2 ; } ;

struct sigaction32 { unsigned int sa_handler ; unsigned int sa_flags ; unsigned int sa_restorer ; compat_sigset_t sa_mask ; } ;

struct old_sigaction32 { unsigned int sa_handler ; compat_old_sigset_t sa_mask ; unsigned int sa_flags ; unsigned int sa_restorer ; } ;


typedef struct sigaltstack_ia32 { unsigned int ss_sp ; int ss_flags ; unsigned int ss_size ; } stack_ia32_t ;

struct ucontext_ia32 { unsigned int uc_flags ; unsigned int uc_link ; stack_ia32_t uc_stack ; struct sigcontext_ia32 uc_mcontext ; compat_sigset_t uc_sigmask ; } ;

struct stat64 { unsigned long long st_dev ; unsigned char __pad0 [ 4 ] ; unsigned int __st_ino ; unsigned int st_mode ; unsigned int st_nlink ; unsigned int st_uid ; unsigned int st_gid ; unsigned long long st_rdev ; unsigned char __pad3 [ 4 ] ; long long st_size ; unsigned int st_blksize ; long long st_blocks ; unsigned st_atime ; unsigned st_atime_nsec ; unsigned st_mtime ; unsigned st_mtime_nsec ; unsigned st_ctime ; unsigned st_ctime_nsec ; unsigned long long st_ino ; } __attribute__ ( ( packed ) ) ;
typedef struct compat_siginfo { int si_signo ; int si_errno ; int si_code ; union { int _pad [ ( ( 128 / sizeof ( int ) ) - 3 ) ] ; struct { unsigned int _pid ; unsigned int _uid ; } _kill ; struct { compat_timer_t _tid ; int _overrun ; compat_sigval_t _sigval ; int _sys_private ; int _overrun_incr ; } _timer ; struct { unsigned int _pid ; unsigned int _uid ; compat_sigval_t _sigval ; } _rt ; struct { unsigned int _pid ; unsigned int _uid ; int _status ; compat_clock_t _utime ; compat_clock_t _stime ; } _sigchld ; struct { unsigned int _addr ; } _sigfault ; struct { int _band ; int _fd ; } _sigpoll ; } _sifields ; } compat_siginfo_t ;

struct user_desc { unsigned int entry_number ; unsigned int base_addr ; unsigned int limit ; unsigned int seg_32bit : 1 ; unsigned int contents : 2 ; unsigned int read_exec_only : 1 ; unsigned int limit_in_pages : 1 ; unsigned int seg_not_present : 1 ; unsigned int useable : 1 ; unsigned int lm : 1 ; } ;
struct gdt_page { struct desc_struct gdt [ 16 ] ; } __attribute__ ( ( aligned ( ( ( 1UL ) << 12 ) ) ) ) ;
enum { IRQTF_RUNTHREAD , IRQTF_DIED , IRQTF_WARNED , IRQTF_AFFINITY , } ;
typedef irqreturn_t ( * irq_handler_t ) ( int , void * ) ;

struct irqaction { irq_handler_t handler ; unsigned long flags ; const char * name ; void * dev_id ; struct irqaction * next ; int irq ; struct proc_dir_entry * dir ; irq_handler_t thread_fn ; struct task_struct * thread ; unsigned long thread_flags ; } ;

enum { HI_SOFTIRQ = 0 , TIMER_SOFTIRQ , NET_TX_SOFTIRQ , NET_RX_SOFTIRQ , BLOCK_SOFTIRQ , BLOCK_IOPOLL_SOFTIRQ , TASKLET_SOFTIRQ , SCHED_SOFTIRQ , HRTIMER_SOFTIRQ , RCU_SOFTIRQ , NR_SOFTIRQS } ;
struct softirq_action { void ( * action ) ( struct softirq_action * ) ; } ;

struct tasklet_struct { struct tasklet_struct * next ; unsigned long state ; atomic_t count ; void ( * func ) ( unsigned long ) ; unsigned long data ; } ;

enum { TASKLET_STATE_SCHED , TASKLET_STATE_RUN } ;
struct tasklet_hrtimer { struct hrtimer timer ; struct tasklet_struct tasklet ; enum hrtimer_restart ( * function ) ( struct hrtimer * ) ; } ;

struct cpu_usage_stat { cputime64_t user ; cputime64_t nice ; cputime64_t system ; cputime64_t softirq ; cputime64_t irq ; cputime64_t idle ; cputime64_t iowait ; cputime64_t steal ; cputime64_t guest ; } ;

struct kernel_stat { struct cpu_usage_stat cpustat ; unsigned int softirqs [ NR_SOFTIRQS ] ; } ;

struct user_regset ;

typedef int user_regset_active_fn ( struct task_struct * target , const struct user_regset * regset ) ;

typedef int user_regset_get_fn ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , void * kbuf , void * ubuf ) ;

typedef int user_regset_set_fn ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void * ubuf ) ;

typedef int user_regset_writeback_fn ( struct task_struct * target , const struct user_regset * regset , int immediate ) ;

struct user_regset { user_regset_get_fn * get ; user_regset_set_fn * set ; user_regset_active_fn * active ; user_regset_writeback_fn * writeback ; unsigned int n ; unsigned int size ; unsigned int align ; unsigned int bias ; unsigned int core_note_type ; } ;
struct user_regset_view { const char * name ; const struct user_regset * regsets ; unsigned int n ; u32 e_flags ; u16 e_machine ; u8 ei_osabi ; } ;

struct _fpstate_ia32 ;
struct _xstate_ia32 ;

struct saved_context { struct pt_regs regs ; u16 ds , es , fs , gs , ss ; unsigned long gs_base , gs_kernel_base , fs_base ; unsigned long cr0 , cr2 , cr3 , cr4 , cr8 ; u64 misc_enable ; bool misc_enable_saved ; unsigned long efer ; u16 gdt_pad ; u16 gdt_limit ; unsigned long gdt_base ; u16 idt_pad ; u16 idt_limit ; unsigned long idt_base ; u16 ldt ; u16 tss ; unsigned long tr ; unsigned long safety ; unsigned long return_address ; } __attribute__ ( ( packed ) ) ;
typedef unsigned char * __guest_handle_uchar ;

typedef unsigned int * __guest_handle_uint ;

typedef unsigned long * __guest_handle_ulong ;

typedef char * __guest_handle_char ;

typedef int * __guest_handle_int ;

typedef long * __guest_handle_long ;

typedef void * __guest_handle_void ;

struct trap_info { uint8_t vector ; uint8_t flags ; uint16_t cs ; unsigned long address ; } ;

typedef struct trap_info * __guest_handle_trap_info ;

struct arch_shared_info { unsigned long max_pfn ; unsigned long pfn_to_mfn_frame_list_list ; unsigned long nmi_reason ; } ;

struct iret_context { uint64_t rax , r11 , rcx , flags , rip , cs , rflags , rsp , ss ; } ;

struct cpu_user_regs { uint64_t r15 ; uint64_t r14 ; uint64_t r13 ; uint64_t r12 ; union { uint64_t rbp , ebp ; uint32_t _ebp ; } ; union { uint64_t rbx , ebx ; uint32_t _ebx ; } ; uint64_t r11 ; uint64_t r10 ; uint64_t r9 ; uint64_t r8 ; union { uint64_t rax , eax ; uint32_t _eax ; } ; union { uint64_t rcx , ecx ; uint32_t _ecx ; } ; union { uint64_t rdx , edx ; uint32_t _edx ; } ; union { uint64_t rsi , esi ; uint32_t _esi ; } ; union { uint64_t rdi , edi ; uint32_t _edi ; } ; uint32_t error_code ; uint32_t entry_vector ; union { uint64_t rip , eip ; uint32_t _eip ; } ; uint16_t cs , _pad0 [ 1 ] ; uint8_t saved_upcall_mask ; uint8_t _pad1 [ 3 ] ; union { uint64_t rflags , eflags ; uint32_t _eflags ; } ; union { uint64_t rsp , esp ; uint32_t _esp ; } ; uint16_t ss , _pad2 [ 3 ] ; uint16_t es , _pad3 [ 3 ] ; uint16_t ds , _pad4 [ 3 ] ; uint16_t fs , _pad5 [ 3 ] ; uint16_t gs , _pad6 [ 3 ] ; } ;

typedef struct cpu_user_regs * __guest_handle_cpu_user_regs ;

struct arch_vcpu_info { unsigned long cr2 ; unsigned long pad ; } ;

typedef unsigned long xen_callback_t ;

struct vcpu_guest_context { struct { char x [ 512 ] ; } fpu_ctxt ; unsigned long flags ; struct cpu_user_regs user_regs ; struct trap_info trap_ctxt [ 256 ] ; unsigned long ldt_base , ldt_ents ; unsigned long gdt_frames [ 16 ] , gdt_ents ; unsigned long kernel_ss , kernel_sp ; unsigned long ctrlreg [ 8 ] ; unsigned long debugreg [ 8 ] ; unsigned long event_callback_eip ; unsigned long failsafe_callback_eip ; unsigned long syscall_callback_eip ; unsigned long vm_assist ; uint64_t fs_base ; uint64_t gs_base_kernel ; uint64_t gs_base_user ; } ;

typedef struct vcpu_guest_context * __guest_handle_vcpu_guest_context ;

struct pvclock_vcpu_time_info { u32 version ; u32 pad0 ; u64 tsc_timestamp ; u64 system_time ; u32 tsc_to_system_mul ; s8 tsc_shift ; u8 pad [ 3 ] ; } __attribute__ ( ( __packed__ ) ) ;
struct pvclock_wall_clock { u32 version ; u32 sec ; u32 nsec ; } __attribute__ ( ( __packed__ ) ) ;
struct mmuext_op { unsigned int cmd ; union { unsigned long mfn ; unsigned long linear_addr ; } arg1 ; union { unsigned int nr_ents ; void * vcpumask ; } arg2 ; } ;

typedef struct mmuext_op * __guest_handle_mmuext_op ;

typedef uint16_t domid_t ;

struct mmu_update { uint64_t ptr ; uint64_t val ; } ;

typedef struct mmu_update * __guest_handle_mmu_update ;

struct multicall_entry { unsigned long op ; long result ; unsigned long args [ 6 ] ; } ;

typedef struct multicall_entry * __guest_handle_multicall_entry ;

struct vcpu_time_info { uint32_t version ; uint32_t pad0 ; uint64_t tsc_timestamp ; uint64_t system_time ; uint32_t tsc_to_system_mul ; int8_t tsc_shift ; int8_t pad1 [ 3 ] ; } ;

struct vcpu_info { uint8_t evtchn_upcall_pending ; uint8_t evtchn_upcall_mask ; unsigned long evtchn_pending_sel ; struct arch_vcpu_info arch ; struct pvclock_vcpu_time_info time ; } ;

struct shared_info { struct vcpu_info vcpu_info [ 32 ] ; unsigned long evtchn_pending [ sizeof ( unsigned long ) * 8 ] ; unsigned long evtchn_mask [ sizeof ( unsigned long ) * 8 ] ; struct pvclock_wall_clock wc ; struct arch_shared_info arch ; } ;

struct start_info { char magic [ 32 ] ; unsigned long nr_pages ; unsigned long shared_info ; uint32_t flags ; unsigned long store_mfn ; uint32_t store_evtchn ; union { struct { unsigned long mfn ; uint32_t evtchn ; } domU ; struct { uint32_t info_off ; uint32_t info_size ; } dom0 ; } console ; unsigned long pt_base ; unsigned long nr_pt_frames ; unsigned long mfn_list ; unsigned long mod_start ; unsigned long mod_len ; int8_t cmd_line [ 1024 ] ; } ;

typedef uint64_t cpumap_t ;

typedef uint8_t xen_domain_handle_t [ 16 ] ;
struct ucontext { unsigned long uc_flags ; struct ucontext * uc_link ; stack_t uc_stack ; struct sigcontext uc_mcontext ; sigset_t uc_sigmask ; } ;

struct sigframe_ia32 { u32 pretcode ; int sig ; struct sigcontext_ia32 sc ; struct _fpstate_ia32 fpstate_unused ; unsigned int extramask [ ( 64 / 32 ) - 1 ] ; char retcode [ 8 ] ; } ;

struct rt_sigframe_ia32 { u32 pretcode ; int sig ; u32 pinfo ; u32 puc ; compat_siginfo_t info ; struct ucontext_ia32 uc ; char retcode [ 8 ] ; } ;

struct rt_sigframe { char * pretcode ; struct ucontext uc ; struct siginfo info ; } ;

int main ( void ) ;
struct option { const char * name ; int has_arg ; int * flag ; int val ; } ;

enum symbol_type { SYM_NORMAL , SYM_TYPEDEF , SYM_ENUM , SYM_STRUCT , SYM_UNION } ;
enum symbol_status { STATUS_UNCHANGED , STATUS_DEFINED , STATUS_MODIFIED } ;

struct string_list { struct string_list * next ; enum symbol_type tag ; char * string ; } ;

struct symbol { struct symbol * hash_next ; const char * name ; enum symbol_type type ; struct string_list * defn ; struct symbol * expansion_trail ; struct symbol * visited ; int is_extern ; int is_declared ; enum symbol_status status ; int is_override ; } ;
typedef struct string_list * * yystype ;

struct symbol * find_symbol ( const char * name , enum symbol_type ns ) ;

struct symbol * add_symbol ( const char * name , enum symbol_type type , struct string_list * defn , int is_extern ) ;

void free_node ( struct string_list * node ) ;

void free_list ( struct string_list * s , struct string_list * e ) ;

struct string_list * copy_node ( struct string_list * node ) ;

void export_symbol ( const char * name ) ;

void error_with_pos ( const char * fmt , ... ) ;

int main ( int argc , char * * argv ) ;
enum yytokentype { ASM_KEYW = 258 , ATTRIBUTE_KEYW = 259 , AUTO_KEYW = 260 , BOOL_KEYW = 261 , CHAR_KEYW = 262 , CONST_KEYW = 263 , DOUBLE_KEYW = 264 , ENUM_KEYW = 265 , EXTERN_KEYW = 266 , EXTENSION_KEYW = 267 , FLOAT_KEYW = 268 , INLINE_KEYW = 269 , INT_KEYW = 270 , LONG_KEYW = 271 , REGISTER_KEYW = 272 , RESTRICT_KEYW = 273 , SHORT_KEYW = 274 , SIGNED_KEYW = 275 , STATIC_KEYW = 276 , STRUCT_KEYW = 277 , TYPEDEF_KEYW = 278 , UNION_KEYW = 279 , UNSIGNED_KEYW = 280 , VOID_KEYW = 281 , VOLATILE_KEYW = 282 , TYPEOF_KEYW = 283 , EXPORT_SYMBOL_KEYW = 284 , ASM_PHRASE = 285 , ATTRIBUTE_PHRASE = 286 , BRACE_PHRASE = 287 , BRACKET_PHRASE = 288 , EXPRESSION_PHRASE = 289 , CHAR = 290 , DOTS = 291 , IDENT = 292 , INT = 293 , REAL = 294 , STRING = 295 , TYPE = 296 , OTHER = 297 , FILENAME = 298 } ;
void yyrestart ( FILE * input_file ) ;

void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer ) ;

YY_BUFFER_STATE yy_create_buffer ( FILE * file , int size ) ;

void yy_delete_buffer ( YY_BUFFER_STATE b ) ;

void yy_flush_buffer ( YY_BUFFER_STATE b ) ;

void yypush_buffer_state ( YY_BUFFER_STATE new_buffer ) ;

void yypop_buffer_state ( void ) ;

YY_BUFFER_STATE yy_scan_buffer ( char * base , yy_size_t size ) ;

YY_BUFFER_STATE yy_scan_string ( const char * yystr ) ;

YY_BUFFER_STATE yy_scan_bytes ( const char * yybytes , int _yybytes_len ) ;

int yyget_lineno ( void ) ;

FILE * yyget_in ( void ) ;

FILE * yyget_out ( void ) ;

int yyget_leng ( void ) ;

char * yyget_text ( void ) ;

void yyset_lineno ( int line_number ) ;

void yyset_in ( FILE * in_str ) ;

void yyset_out ( FILE * out_str ) ;

int yyget_debug ( void ) ;

void yyset_debug ( int bdebug ) ;

int yylex_destroy ( void ) ;

void * yyalloc ( yy_size_t size ) ;
void * yyrealloc ( void * ptr , yy_size_t size ) ;

void yyfree ( void * ptr ) ;

struct resword ;

struct resword { const char * name ; int token ; } ;
int yylex ( void ) ;

typedef long int ptrdiff_t ;
struct mallinfo { int arena ; int ordblks ; int smblks ; int hblks ; int hblkhd ; int usmblks ; int fsmblks ; int uordblks ; int fordblks ; int keepcost ; } ;

union yyalloc { yytype_int16 yyss ; yystype yyvs ; } ;
int yyparse ( void ) ;

typedef long int intptr_t ;
typedef uint16_t Elf32_Half ;
typedef uint16_t Elf64_Half ;
typedef uint32_t Elf32_Word ;
typedef int32_t Elf32_Sword ;
typedef uint32_t Elf64_Word ;
typedef int32_t Elf64_Sword ;
typedef uint64_t Elf32_Xword ;

typedef int64_t Elf32_Sxword ;

typedef uint64_t Elf64_Xword ;
typedef int64_t Elf64_Sxword ;
typedef uint32_t Elf32_Addr ;
typedef uint64_t Elf64_Addr ;
typedef uint32_t Elf32_Off ;
typedef uint64_t Elf64_Off ;
typedef uint16_t Elf32_Section ;

typedef uint16_t Elf64_Section ;

typedef Elf32_Half Elf32_Versym ;

typedef Elf64_Half Elf64_Versym ;

typedef struct { unsigned char e_ident [ ( 16 ) ] ; Elf32_Half e_type ; Elf32_Half e_machine ; Elf32_Word e_version ; Elf32_Addr e_entry ; Elf32_Off e_phoff ; Elf32_Off e_shoff ; Elf32_Word e_flags ; Elf32_Half e_ehsize ; Elf32_Half e_phentsize ; Elf32_Half e_phnum ; Elf32_Half e_shentsize ; Elf32_Half e_shnum ; Elf32_Half e_shstrndx ; } Elf32_Ehdr ;
typedef struct { unsigned char e_ident [ ( 16 ) ] ; Elf64_Half e_type ; Elf64_Half e_machine ; Elf64_Word e_version ; Elf64_Addr e_entry ; Elf64_Off e_phoff ; Elf64_Off e_shoff ; Elf64_Word e_flags ; Elf64_Half e_ehsize ; Elf64_Half e_phentsize ; Elf64_Half e_phnum ; Elf64_Half e_shentsize ; Elf64_Half e_shnum ; Elf64_Half e_shstrndx ; } Elf64_Ehdr ;
typedef struct { Elf64_Word sh_name ; Elf64_Word sh_type ; Elf64_Xword sh_flags ; Elf64_Addr sh_addr ; Elf64_Off sh_offset ; Elf64_Xword sh_size ; Elf64_Word sh_link ; Elf64_Word sh_info ; Elf64_Xword sh_addralign ; Elf64_Xword sh_entsize ; } Elf64_Shdr ;
typedef struct { Elf32_Word st_name ; Elf32_Addr st_value ; Elf32_Word st_size ; unsigned char st_info ; unsigned char st_other ; Elf32_Section st_shndx ; } Elf32_Sym ;
typedef struct { Elf64_Word st_name ; unsigned char st_info ; unsigned char st_other ; Elf64_Section st_shndx ; Elf64_Addr st_value ; Elf64_Xword st_size ; } Elf64_Sym ;
typedef struct { Elf32_Half si_boundto ; Elf32_Half si_flags ; } Elf32_Syminfo ;

typedef struct { Elf64_Half si_boundto ; Elf64_Half si_flags ; } Elf64_Syminfo ;

typedef struct { Elf32_Addr r_offset ; Elf32_Word r_info ; } Elf32_Rel ;
typedef struct { Elf64_Addr r_offset ; Elf64_Xword r_info ; } Elf64_Rel ;
typedef struct { Elf32_Addr r_offset ; Elf32_Word r_info ; Elf32_Sword r_addend ; } Elf32_Rela ;
typedef struct { Elf64_Addr r_offset ; Elf64_Xword r_info ; Elf64_Sxword r_addend ; } Elf64_Rela ;
typedef struct { Elf32_Word p_type ; Elf32_Off p_offset ; Elf32_Addr p_vaddr ; Elf32_Addr p_paddr ; Elf32_Word p_filesz ; Elf32_Word p_memsz ; Elf32_Word p_flags ; Elf32_Word p_align ; } Elf32_Phdr ;
typedef struct { Elf64_Word p_type ; Elf64_Word p_flags ; Elf64_Off p_offset ; Elf64_Addr p_vaddr ; Elf64_Addr p_paddr ; Elf64_Xword p_filesz ; Elf64_Xword p_memsz ; Elf64_Xword p_align ; } Elf64_Phdr ;
typedef struct { Elf32_Sword d_tag ; union { Elf32_Word d_val ; Elf32_Addr d_ptr ; } d_un ; } Elf32_Dyn ;
typedef struct { Elf32_Half vd_version ; Elf32_Half vd_flags ; Elf32_Half vd_ndx ; Elf32_Half vd_cnt ; Elf32_Word vd_hash ; Elf32_Word vd_aux ; Elf32_Word vd_next ; } Elf32_Verdef ;

typedef struct { Elf64_Half vd_version ; Elf64_Half vd_flags ; Elf64_Half vd_ndx ; Elf64_Half vd_cnt ; Elf64_Word vd_hash ; Elf64_Word vd_aux ; Elf64_Word vd_next ; } Elf64_Verdef ;

typedef struct { Elf32_Word vda_name ; Elf32_Word vda_next ; } Elf32_Verdaux ;

typedef struct { Elf64_Word vda_name ; Elf64_Word vda_next ; } Elf64_Verdaux ;

typedef struct { Elf32_Half vn_version ; Elf32_Half vn_cnt ; Elf32_Word vn_file ; Elf32_Word vn_aux ; Elf32_Word vn_next ; } Elf32_Verneed ;

typedef struct { Elf64_Half vn_version ; Elf64_Half vn_cnt ; Elf64_Word vn_file ; Elf64_Word vn_aux ; Elf64_Word vn_next ; } Elf64_Verneed ;

typedef struct { Elf32_Word vna_hash ; Elf32_Half vna_flags ; Elf32_Half vna_other ; Elf32_Word vna_name ; Elf32_Word vna_next ; } Elf32_Vernaux ;

typedef struct { Elf64_Word vna_hash ; Elf64_Half vna_flags ; Elf64_Half vna_other ; Elf64_Word vna_name ; Elf64_Word vna_next ; } Elf64_Vernaux ;

typedef struct { uint32_t a_type ; union { uint32_t a_val ; } a_un ; } Elf32_auxv_t ;

typedef struct { uint64_t a_type ; union { uint64_t a_val ; } a_un ; } Elf64_auxv_t ;

typedef struct { Elf32_Word n_namesz ; Elf32_Word n_descsz ; Elf32_Word n_type ; } Elf32_Nhdr ;
typedef struct { Elf64_Word n_namesz ; Elf64_Word n_descsz ; Elf64_Word n_type ; } Elf64_Nhdr ;
typedef struct { Elf32_Xword m_value ; Elf32_Word m_info ; Elf32_Word m_poffset ; Elf32_Half m_repeat ; Elf32_Half m_stride ; } Elf32_Move ;

typedef struct { Elf64_Xword m_value ; Elf64_Xword m_info ; Elf64_Xword m_poffset ; Elf64_Half m_repeat ; Elf64_Half m_stride ; } Elf64_Move ;

typedef union { struct { Elf32_Word gt_current_g_value ; Elf32_Word gt_unused ; } gt_header ; struct { Elf32_Word gt_g_value ; Elf32_Word gt_bytes ; } gt_entry ; } Elf32_gptab ;

typedef struct { Elf32_Word ri_gprmask ; Elf32_Word ri_cprmask [ 4 ] ; Elf32_Sword ri_gp_value ; } Elf32_RegInfo ;

typedef struct { unsigned char kind ; unsigned char size ; Elf32_Section section ; Elf32_Word info ; } Elf_Options ;

typedef struct { Elf32_Word hwp_flags1 ; Elf32_Word hwp_flags2 ; } Elf_Options_Hw ;

typedef struct { Elf32_Word l_name ; Elf32_Word l_time_stamp ; Elf32_Word l_checksum ; Elf32_Word l_version ; Elf32_Word l_flags ; } Elf32_Lib ;

typedef struct { Elf64_Word l_name ; Elf64_Word l_time_stamp ; Elf64_Word l_checksum ; Elf64_Word l_version ; Elf64_Word l_flags ; } Elf64_Lib ;

typedef Elf32_Addr Elf32_Conflict ;

typedef struct { Elf32_Word r_sym ; unsigned char r_ssym ; unsigned char r_type3 ; unsigned char r_type2 ; unsigned char r_type1 ; } _Elf64_Mips_R_Info ;

typedef union { Elf64_Xword r_info_number ; _Elf64_Mips_R_Info r_info_fields ; } _Elf64_Mips_R_Info_union ;

struct buffer { char * p ; int pos ; int size ; } ;
struct module { struct module * next ; const char * name ; int gpl_compatible ; struct symbol * unres ; int seen ; int skip ; int has_init ; int has_cleanup ; struct buffer dev_table_buf ; char * * markers ; size_t nmarkers ; char srcversion [ 25 ] ; } ;
struct elf_info { unsigned long size ; Elf64_Ehdr * hdr ; Elf64_Shdr * sechdrs ; Elf64_Sym * symtab_start ; Elf64_Sym * symtab_stop ; Elf64_Half export_sec ; Elf64_Half export_unused_sec ; Elf64_Half export_gpl_sec ; Elf64_Half export_unused_gpl_sec ; Elf64_Half export_gpl_future_sec ; Elf64_Half markers_strings_sec ; const char * strtab ; char * modinfo ; unsigned int modinfo_len ; } ;

typedef Elf64_Addr kernel_ulong_t ;

typedef uint32_t __u32 ;
typedef uint16_t __u16 ;
struct pci_device_id { __u32 vendor , device ; __u32 subvendor , subdevice ; __u32 class , class_mask ; kernel_ulong_t driver_data ; } ;

struct ieee1394_device_id { __u32 match_flags ; __u32 vendor_id ; __u32 model_id ; __u32 specifier_id ; __u32 version ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;

struct usb_device_id { __u16 match_flags ; __u16 idVendor ; __u16 idProduct ; __u16 bcdDevice_lo ; __u16 bcdDevice_hi ; __u8 bDeviceClass ; __u8 bDeviceSubClass ; __u8 bDeviceProtocol ; __u8 bInterfaceClass ; __u8 bInterfaceSubClass ; __u8 bInterfaceProtocol ; kernel_ulong_t driver_info ; } ;

struct hid_device_id { __u16 bus ; __u16 pad1 ; __u32 vendor ; __u32 product ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;

struct ccw_device_id { __u16 match_flags ; __u16 cu_type ; __u16 dev_type ; __u8 cu_model ; __u8 dev_model ; kernel_ulong_t driver_info ; } ;

struct ap_device_id { __u16 match_flags ; __u8 dev_type ; __u8 pad1 ; __u32 pad2 ; kernel_ulong_t driver_info ; } ;

struct css_device_id { __u8 match_flags ; __u8 type ; __u16 pad2 ; __u32 pad3 ; kernel_ulong_t driver_data ; } ;

struct acpi_device_id { __u8 id [ 16 ] ; kernel_ulong_t driver_data ; } ;

struct pnp_device_id { __u8 id [ 8 ] ; kernel_ulong_t driver_data ; } ;

struct pnp_card_device_id { __u8 id [ 8 ] ; kernel_ulong_t driver_data ; struct { __u8 id [ 8 ] ; } devs [ 8 ] ; } ;

struct serio_device_id { __u8 type ; __u8 extra ; __u8 id ; __u8 proto ; } ;

struct of_device_id { char name [ 32 ] ; char type [ 32 ] ; char compatible [ 128 ] ; kernel_ulong_t data ; } ;

struct vio_device_id { char type [ 32 ] ; char compat [ 32 ] ; } ;

struct pcmcia_device_id { __u16 match_flags ; __u16 manf_id ; __u16 card_id ; __u8 func_id ; __u8 function ; __u8 device_no ; __u32 prod_id_hash [ 4 ] __attribute__ ( ( aligned ( sizeof ( __u32 ) ) ) ) ; kernel_ulong_t prod_id [ 4 ] __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; kernel_ulong_t driver_info ; kernel_ulong_t cisfile ; } ;

struct input_device_id { kernel_ulong_t flags ; __u16 bustype ; __u16 vendor ; __u16 product ; __u16 version ; kernel_ulong_t evbit [ 0x1f / 64 + 1 ] ; kernel_ulong_t keybit [ 0x2ff / 64 + 1 ] ; kernel_ulong_t relbit [ 0x0f / 64 + 1 ] ; kernel_ulong_t absbit [ 0x3f / 64 + 1 ] ; kernel_ulong_t mscbit [ 0x07 / 64 + 1 ] ; kernel_ulong_t ledbit [ 0x0f / 64 + 1 ] ; kernel_ulong_t sndbit [ 0x07 / 64 + 1 ] ; kernel_ulong_t ffbit [ 0x7f / 64 + 1 ] ; kernel_ulong_t swbit [ 0x0f / 64 + 1 ] ; kernel_ulong_t driver_info ; } ;

struct eisa_device_id { char sig [ 8 ] ; kernel_ulong_t driver_data ; } ;

struct parisc_device_id { __u8 hw_type ; __u8 hversion_rev ; __u16 hversion ; __u32 sversion ; } ;

struct sdio_device_id { __u8 class ; __u16 vendor ; __u16 device ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;

struct ssb_device_id { __u16 vendor ; __u16 coreid ; __u8 revision ; } ;

struct virtio_device_id { __u32 device ; __u32 vendor ; } ;

struct i2c_device_id { char name [ 20 ] ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;

struct spi_device_id { char name [ 32 ] ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;

enum dmi_field { DMI_NONE , DMI_BIOS_VENDOR , DMI_BIOS_VERSION , DMI_BIOS_DATE , DMI_SYS_VENDOR , DMI_PRODUCT_NAME , DMI_PRODUCT_VERSION , DMI_PRODUCT_SERIAL , DMI_PRODUCT_UUID , DMI_BOARD_VENDOR , DMI_BOARD_NAME , DMI_BOARD_VERSION , DMI_BOARD_SERIAL , DMI_BOARD_ASSET_TAG , DMI_CHASSIS_VENDOR , DMI_CHASSIS_TYPE , DMI_CHASSIS_VERSION , DMI_CHASSIS_SERIAL , DMI_CHASSIS_ASSET_TAG , DMI_STRING_MAX , } ;

struct dmi_strmatch { unsigned char slot ; char substr [ 79 ] ; } ;

struct dmi_system_id { kernel_ulong_t callback ; kernel_ulong_t ident ; struct dmi_strmatch matches [ 4 ] ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;

struct platform_device_id { char name [ 20 ] ; kernel_ulong_t driver_data __attribute__ ( ( aligned ( sizeof ( kernel_ulong_t ) ) ) ) ; } ;


void handle_moddevtable ( struct module * mod , struct elf_info * info , Elf64_Sym * sym , const char * symname ) ;

void add_moddevtable ( struct buffer * buf , struct module * mod ) ;

typedef __io_read_fn cookie_read_function_t ;

typedef __io_write_fn cookie_write_function_t ;

typedef __io_seek_fn cookie_seek_function_t ;

typedef __io_close_fn cookie_close_function_t ;

typedef struct { __io_read_fn * read ; __io_write_fn * write ; __io_seek_fn * seek ; __io_close_fn * close ; } _IO_cookie_io_functions_t ;

typedef _IO_cookie_io_functions_t cookie_io_functions_t ;

struct _IO_cookie_file ;

typedef _G_fpos64_t fpos64_t ;

struct obstack ;

typedef __ino64_t ino64_t ;

typedef __off64_t off64_t ;

typedef struct { __fd_mask fds_bits [ 1024 / ( 8 * ( int ) sizeof ( __fd_mask ) ) ] ; } fd_set ;
typedef __blksize_t blksize_t ;

typedef __blkcnt64_t blkcnt64_t ;

typedef __fsblkcnt64_t fsblkcnt64_t ;

typedef __fsfilcnt64_t fsfilcnt64_t ;

typedef __compar_fn_t comparison_fn_t ;

typedef int ( * __compar_d_fn_t ) ( __const void * , __const void * , void * ) ;
struct stat64 { __dev_t st_dev ; __ino64_t st_ino ; __nlink_t st_nlink ; __mode_t st_mode ; __uid_t st_uid ; __gid_t st_gid ; int __pad0 ; __dev_t st_rdev ; __off_t st_size ; __blksize_t st_blksize ; __blkcnt64_t st_blocks ; struct timespec st_atim ; struct timespec st_mtim ; struct timespec st_ctim ; long int __unused [ 3 ] ; } ;

struct flock64 { short int l_type ; short int l_whence ; __off64_t l_start ; __off64_t l_len ; __pid_t l_pid ; } ;

enum __pid_type { F_OWNER_TID = 0 , F_OWNER_PID , F_OWNER_GID } ;

struct f_owner_ex { enum __pid_type type ; __pid_t pid ; } ;

enum export { export_plain , export_unused , export_gpl , export_unused_gpl , export_gpl_future , export_unknown } ;

__attribute__ ( ( format ( printf , 1 , 2 ) ) ) void fatal ( const char * fmt , ... ) ;

__attribute__ ( ( format ( printf , 1 , 2 ) ) ) void warn ( const char * fmt , ... ) ;

__attribute__ ( ( format ( printf , 1 , 2 ) ) ) void merror ( const char * fmt , ... ) ;

void * do_nofail ( void * ptr , const char * expr ) ;

struct symbol { struct symbol * next ; struct module * module ; unsigned int crc ; int crc_valid ; unsigned int weak : 1 ; unsigned int vmlinux : 1 ; unsigned int kernel : 1 ; unsigned int preloaded : 1 ; enum export export ; char name [ 0 ] ; } ;
void * grab_file ( const char * filename , unsigned long * size ) ;

char * get_next_line ( unsigned long * pos , void * file , unsigned long size ) ;

void release_file ( void * file , unsigned long size ) ;

enum mismatch { NO_MISMATCH , TEXT_TO_INIT , DATA_TO_INIT , TEXT_TO_EXIT , DATA_TO_EXIT , XXXINIT_TO_INIT , XXXEXIT_TO_EXIT , INIT_TO_EXIT , EXIT_TO_INIT , EXPORT_TO_INIT_EXIT , } ;

struct sectioncheck { const char * fromsec [ 20 ] ; const char * tosec [ 20 ] ; enum mismatch mismatch ; } ;

void __attribute__ ( ( format ( printf , 2 , 3 ) ) ) buf_printf ( struct buffer * buf , const char * fmt , ... ) ;

void buf_write ( struct buffer * buf , const char * s , int len ) ;

struct ext_sym_list { struct ext_sym_list * next ; const char * file ; } ;

typedef signed char int8_t ;
typedef short int int16_t ;
typedef int int32_t ;
typedef long int int64_t ;
struct md4_ctx { uint32_t hash [ 4 ] ; uint32_t block [ 16 ] ; uint64_t byte_count ; } ;

void get_src_version ( const char * modname , char sum [ ] , unsigned sumlen ) ;

void maybe_frob_rcs_version ( const char * modfilename , char * version , void * modinfo , unsigned long version_offset ) ;

struct common { char * cname ; char * * perms ; } ;

struct av_inherit { int class ; char * common ; } ;

struct av_perms { int class ; int perm_i ; char * perm_s ; } ;

struct sym_entry { unsigned long long addr ; unsigned int len ; unsigned int start_pos ; unsigned char * sym ; } ;

struct text_range { const char * stext , * etext ; unsigned long long start , end ; } ;

typedef unsigned short unicode ;

struct files_stat_struct { int nr_files ; int nr_free_files ; int max_files ; } ;

struct inodes_stat_t { int nr_inodes ; int nr_unused ; int dummy [ 5 ] ; } ;

struct nameidata ;

struct path ;
struct qstr { unsigned int hash ; unsigned int len ; const unsigned char * name ; } ;

struct dentry_stat_t { int nr_dentry ; int nr_unused ; int age_limit ; int want_pages ; int dummy [ 2 ] ; } ;

struct dentry { atomic_t d_count ; unsigned int d_flags ; spinlock_t d_lock ; int d_mounted ; struct inode * d_inode ; struct hlist_node d_hash ; struct dentry * d_parent ; struct qstr d_name ; struct list_head d_lru ; union { struct list_head d_child ; struct rcu_head d_rcu ; } d_u ; struct list_head d_subdirs ; struct list_head d_alias ; unsigned long d_time ; const struct dentry_operations * d_op ; struct super_block * d_sb ; void * d_fsdata ; unsigned char d_iname [ 32 ] ; } ;
enum dentry_d_lock_class { DENTRY_D_LOCK_NORMAL , DENTRY_D_LOCK_NESTED } ;

struct dentry_operations { int ( * d_revalidate ) ( struct dentry * , struct nameidata * ) ; int ( * d_hash ) ( struct dentry * , struct qstr * ) ; int ( * d_compare ) ( struct dentry * , struct qstr * , struct qstr * ) ; int ( * d_delete ) ( struct dentry * ) ; void ( * d_release ) ( struct dentry * ) ; void ( * d_iput ) ( struct dentry * , struct inode * ) ; char * ( * d_dname ) ( struct dentry * , char * , int ) ; } ;

struct radix_tree_root { unsigned int height ; gfp_t gfp_mask ; struct radix_tree_node * rnode ; } ;

struct semaphore { spinlock_t lock ; unsigned int count ; struct list_head wait_list ; } ;

struct fiemap_extent { __u64 fe_logical ; __u64 fe_physical ; __u64 fe_length ; __u64 fe_reserved64 [ 2 ] ; __u32 fe_flags ; __u32 fe_reserved [ 3 ] ; } ;

struct fiemap { __u64 fm_start ; __u64 fm_length ; __u32 fm_flags ; __u32 fm_mapped_extents ; __u32 fm_extent_count ; __u32 fm_reserved ; struct fiemap_extent fm_extents [ 0 ] ; } ;

struct export_operations ;

struct hd_geometry ;

struct iovec ;
struct kiocb ;
struct poll_table_struct ;

struct kstatfs ;

struct buffer_head ;

typedef int ( get_block_t ) ( struct inode * inode , sector_t iblock , struct buffer_head * bh_result , int create ) ;
typedef void ( dio_iodone_t ) ( struct kiocb * iocb , loff_t offset , ssize_t bytes , void * private ) ;
struct iattr { unsigned int ia_valid ; umode_t ia_mode ; uid_t ia_uid ; gid_t ia_gid ; loff_t ia_size ; struct timespec ia_atime ; struct timespec ia_mtime ; struct timespec ia_ctime ; struct file * ia_file ; } ;

enum { QIF_BLIMITS_B = 0 , QIF_SPACE_B , QIF_ILIMITS_B , QIF_INODES_B , QIF_BTIME_B , QIF_ITIME_B , } ;
struct if_dqblk { __u64 dqb_bhardlimit ; __u64 dqb_bsoftlimit ; __u64 dqb_curspace ; __u64 dqb_ihardlimit ; __u64 dqb_isoftlimit ; __u64 dqb_curinodes ; __u64 dqb_btime ; __u64 dqb_itime ; __u32 dqb_valid ; } ;

struct if_dqinfo { __u64 dqi_bgrace ; __u64 dqi_igrace ; __u32 dqi_flags ; __u32 dqi_valid ; } ;

enum { QUOTA_NL_C_UNSPEC , QUOTA_NL_C_WARNING , __QUOTA_NL_C_MAX , } ;
enum { QUOTA_NL_A_UNSPEC , QUOTA_NL_A_QTYPE , QUOTA_NL_A_EXCESS_ID , QUOTA_NL_A_WARNING , QUOTA_NL_A_DEV_MAJOR , QUOTA_NL_A_DEV_MINOR , QUOTA_NL_A_CAUSED_ID , __QUOTA_NL_A_MAX , } ;

typedef struct fs_disk_quota { __s8 d_version ; __s8 d_flags ; __u16 d_fieldmask ; __u32 d_id ; __u64 d_blk_hardlimit ; __u64 d_blk_softlimit ; __u64 d_ino_hardlimit ; __u64 d_ino_softlimit ; __u64 d_bcount ; __u64 d_icount ; __s32 d_itimer ; __s32 d_btimer ; __u16 d_iwarns ; __u16 d_bwarns ; __s32 d_padding2 ; __u64 d_rtb_hardlimit ; __u64 d_rtb_softlimit ; __u64 d_rtbcount ; __s32 d_rtbtimer ; __u16 d_rtbwarns ; __s16 d_padding3 ; char d_padding4 [ 8 ] ; } fs_disk_quota_t ;


typedef struct fs_qfilestat { __u64 qfs_ino ; __u64 qfs_nblks ; __u32 qfs_nextents ; } fs_qfilestat_t ;


typedef struct fs_quota_stat { __s8 qs_version ; __u16 qs_flags ; __s8 qs_pad ; fs_qfilestat_t qs_uquota ; fs_qfilestat_t qs_gquota ; __u32 qs_incoredqs ; __s32 qs_btimelimit ; __s32 qs_itimelimit ; __s32 qs_rtbtimelimit ; __u16 qs_bwarnlimit ; __u16 qs_iwarnlimit ; } fs_quota_stat_t ;

struct dquot ;

struct qtree_fmt_operations { void ( * mem2disk_dqblk ) ( void * disk , struct dquot * dquot ) ; void ( * disk2mem_dqblk ) ( struct dquot * dquot , void * disk ) ; int ( * is_id ) ( void * disk , struct dquot * dquot ) ; } ;

struct qtree_mem_dqinfo { struct super_block * dqi_sb ; int dqi_type ; unsigned int dqi_blocks ; unsigned int dqi_free_blk ; unsigned int dqi_free_entry ; unsigned int dqi_blocksize_bits ; unsigned int dqi_entry_size ; unsigned int dqi_usable_bs ; unsigned int dqi_qtree_depth ; struct qtree_fmt_operations * dqi_ops ; } ;

typedef __kernel_uid32_t qid_t ;

typedef long long qsize_t ;

struct mem_dqblk { qsize_t dqb_bhardlimit ; qsize_t dqb_bsoftlimit ; qsize_t dqb_curspace ; qsize_t dqb_rsvspace ; qsize_t dqb_ihardlimit ; qsize_t dqb_isoftlimit ; qsize_t dqb_curinodes ; time_t dqb_btime ; time_t dqb_itime ; } ;

struct quota_format_type ;

struct mem_dqinfo { struct quota_format_type * dqi_format ; int dqi_fmt_id ; struct list_head dqi_dirty_list ; unsigned long dqi_flags ; unsigned int dqi_bgrace ; unsigned int dqi_igrace ; qsize_t dqi_maxblimit ; qsize_t dqi_maxilimit ; void * dqi_priv ; } ;

struct super_block ;

struct dqstats { int lookups ; int drops ; int reads ; int writes ; int cache_hits ; int allocated_dquots ; int free_dquots ; int syncs ; } ;

struct dquot { struct hlist_node dq_hash ; struct list_head dq_inuse ; struct list_head dq_free ; struct list_head dq_dirty ; struct mutex dq_lock ; atomic_t dq_count ; wait_queue_head_t dq_wait_unused ; struct super_block * dq_sb ; unsigned int dq_id ; loff_t dq_off ; unsigned long dq_flags ; short dq_type ; struct mem_dqblk dq_dqb ; } ;
struct quota_format_ops { int ( * check_quota_file ) ( struct super_block * sb , int type ) ; int ( * read_file_info ) ( struct super_block * sb , int type ) ; int ( * write_file_info ) ( struct super_block * sb , int type ) ; int ( * free_file_info ) ( struct super_block * sb , int type ) ; int ( * read_dqblk ) ( struct dquot * dquot ) ; int ( * commit_dqblk ) ( struct dquot * dquot ) ; int ( * release_dqblk ) ( struct dquot * dquot ) ; } ;

struct dquot_operations { int ( * initialize ) ( struct inode * , int ) ; int ( * drop ) ( struct inode * ) ; int ( * alloc_space ) ( struct inode * , qsize_t , int ) ; int ( * alloc_inode ) ( const struct inode * , qsize_t ) ; int ( * free_space ) ( struct inode * , qsize_t ) ; int ( * free_inode ) ( const struct inode * , qsize_t ) ; int ( * transfer ) ( struct inode * , struct iattr * ) ; int ( * write_dquot ) ( struct dquot * ) ; struct dquot * ( * alloc_dquot ) ( struct super_block * , int ) ; void ( * destroy_dquot ) ( struct dquot * ) ; int ( * acquire_dquot ) ( struct dquot * ) ; int ( * release_dquot ) ( struct dquot * ) ; int ( * mark_dirty ) ( struct dquot * ) ; int ( * write_info ) ( struct super_block * , int ) ; int ( * reserve_space ) ( struct inode * , qsize_t , int ) ; int ( * claim_space ) ( struct inode * , qsize_t ) ; void ( * release_rsv ) ( struct inode * , qsize_t ) ; qsize_t * ( * get_reserved_space ) ( struct inode * ) ; } ;

struct quotactl_ops { int ( * quota_on ) ( struct super_block * , int , int , char * , int ) ; int ( * quota_off ) ( struct super_block * , int , int ) ; int ( * quota_sync ) ( struct super_block * , int ) ; int ( * get_info ) ( struct super_block * , int , struct if_dqinfo * ) ; int ( * set_info ) ( struct super_block * , int , struct if_dqinfo * ) ; int ( * get_dqblk ) ( struct super_block * , int , qid_t , struct if_dqblk * ) ; int ( * set_dqblk ) ( struct super_block * , int , qid_t , struct if_dqblk * ) ; int ( * get_xstate ) ( struct super_block * , struct fs_quota_stat * ) ; int ( * set_xstate ) ( struct super_block * , unsigned int , int ) ; int ( * get_xquota ) ( struct super_block * , int , qid_t , struct fs_disk_quota * ) ; int ( * set_xquota ) ( struct super_block * , int , qid_t , struct fs_disk_quota * ) ; } ;

struct quota_format_type { int qf_fmt_id ; struct quota_format_ops * qf_ops ; struct module * qf_owner ; struct quota_format_type * qf_next ; } ;
enum { _DQUOT_USAGE_ENABLED = 0 , _DQUOT_LIMITS_ENABLED , _DQUOT_SUSPENDED , _DQUOT_STATE_FLAGS } ;
struct quota_info { unsigned int flags ; struct mutex dqio_mutex ; struct mutex dqonoff_mutex ; struct rw_semaphore dqptr_sem ; struct inode * files [ 2 ] ; struct mem_dqinfo info [ 2 ] ; struct quota_format_ops * ops [ 2 ] ; } ;

struct quota_module_name { int qm_fmt_id ; char * qm_mod_name ; } ;

enum positive_aop_returns { AOP_WRITEPAGE_ACTIVATE = 0x80000 , AOP_TRUNCATED_PAGE = 0x80001 , } ;

struct iov_iter { const struct iovec * iov ; unsigned long nr_segs ; size_t iov_offset ; size_t count ; } ;

typedef struct { size_t written ; size_t count ; union { char * buf ; void * data ; } arg ; int error ; } read_descriptor_t ;

typedef int ( * read_actor_t ) ( read_descriptor_t * , struct page * , unsigned long , unsigned long ) ;
struct address_space_operations { int ( * writepage ) ( struct page * page , struct writeback_control * wbc ) ; int ( * readpage ) ( struct file * , struct page * ) ; void ( * sync_page ) ( struct page * ) ; int ( * writepages ) ( struct address_space * , struct writeback_control * ) ; int ( * set_page_dirty ) ( struct page * page ) ; int ( * readpages ) ( struct file * filp , struct address_space * mapping , struct list_head * pages , unsigned nr_pages ) ; int ( * write_begin ) ( struct file * , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata ) ; int ( * write_end ) ( struct file * , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) ; sector_t ( * bmap ) ( struct address_space * , sector_t ) ; void ( * invalidatepage ) ( struct page * , unsigned long ) ; int ( * releasepage ) ( struct page * , gfp_t ) ; ssize_t ( * direct_IO ) ( int , struct kiocb * , const struct iovec * iov , loff_t offset , unsigned long nr_segs ) ; int ( * get_xip_mem ) ( struct address_space * , unsigned long , int , void * * , unsigned long * ) ; int ( * migratepage ) ( struct address_space * , struct page * , struct page * ) ; int ( * launder_page ) ( struct page * ) ; int ( * is_partially_uptodate ) ( struct page * , read_descriptor_t * , unsigned long ) ; int ( * error_remove_page ) ( struct address_space * , struct page * ) ; } ;

struct address_space { struct inode * host ; struct radix_tree_root page_tree ; spinlock_t tree_lock ; unsigned int i_mmap_writable ; struct prio_tree_root i_mmap ; struct list_head i_mmap_nonlinear ; spinlock_t i_mmap_lock ; unsigned int truncate_count ; unsigned long nrpages ; unsigned long writeback_index ; const struct address_space_operations * a_ops ; unsigned long flags ; struct backing_dev_info * backing_dev_info ; spinlock_t private_lock ; struct list_head private_list ; struct address_space * assoc_mapping ; } __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ;
struct block_device { dev_t bd_dev ; struct inode * bd_inode ; struct super_block * bd_super ; int bd_openers ; struct mutex bd_mutex ; struct list_head bd_inodes ; void * bd_holder ; int bd_holders ; struct list_head bd_holder_list ; struct block_device * bd_contains ; unsigned bd_block_size ; struct hd_struct * bd_part ; unsigned bd_part_count ; int bd_invalidated ; struct gendisk * bd_disk ; struct list_head bd_list ; unsigned long bd_private ; int bd_fsfreeze_count ; struct mutex bd_fsfreeze_mutex ; } ;

struct posix_acl ;

struct inode { struct hlist_node i_hash ; struct list_head i_list ; struct list_head i_sb_list ; struct list_head i_dentry ; unsigned long i_ino ; atomic_t i_count ; unsigned int i_nlink ; uid_t i_uid ; gid_t i_gid ; dev_t i_rdev ; u64 i_version ; loff_t i_size ; struct timespec i_atime ; struct timespec i_mtime ; struct timespec i_ctime ; blkcnt_t i_blocks ; unsigned int i_blkbits ; unsigned short i_bytes ; umode_t i_mode ; spinlock_t i_lock ; struct mutex i_mutex ; struct rw_semaphore i_alloc_sem ; const struct inode_operations * i_op ; const struct file_operations * i_fop ; struct super_block * i_sb ; struct file_lock * i_flock ; struct address_space * i_mapping ; struct address_space i_data ; struct dquot * i_dquot [ 2 ] ; struct list_head i_devices ; union { struct pipe_inode_info * i_pipe ; struct block_device * i_bdev ; struct cdev * i_cdev ; } ; __u32 i_generation ; __u32 i_fsnotify_mask ; struct hlist_head i_fsnotify_mark_entries ; struct list_head inotify_watches ; struct mutex inotify_mutex ; unsigned long i_state ; unsigned long dirtied_when ; unsigned int i_flags ; atomic_t i_writecount ; void * i_security ; struct posix_acl * i_acl ; struct posix_acl * i_default_acl ; void * i_private ; } ;
enum inode_i_mutex_lock_class { I_MUTEX_NORMAL , I_MUTEX_PARENT , I_MUTEX_CHILD , I_MUTEX_XATTR , I_MUTEX_QUOTA } ;

struct fown_struct { rwlock_t lock ; struct pid * pid ; enum pid_type pid_type ; uid_t uid , euid ; int signum ; } ;

struct file_ra_state { unsigned long start ; unsigned int size ; unsigned int async_size ; unsigned int ra_pages ; unsigned int mmap_miss ; loff_t prev_pos ; } ;
struct file { union { struct list_head fu_list ; struct rcu_head fu_rcuhead ; } f_u ; struct path f_path ; const struct file_operations * f_op ; spinlock_t f_lock ; atomic_long_t f_count ; unsigned int f_flags ; fmode_t f_mode ; loff_t f_pos ; struct fown_struct f_owner ; const struct cred * f_cred ; struct file_ra_state f_ra ; u64 f_version ; void * f_security ; void * private_data ; struct list_head f_ep_links ; struct address_space * f_mapping ; } ;
typedef struct files_struct * fl_owner_t ;

struct file_lock_operations { void ( * fl_copy_lock ) ( struct file_lock * , struct file_lock * ) ; void ( * fl_release_private ) ( struct file_lock * ) ; } ;

struct lock_manager_operations { int ( * fl_compare_owner ) ( struct file_lock * , struct file_lock * ) ; void ( * fl_notify ) ( struct file_lock * ) ; int ( * fl_grant ) ( struct file_lock * , struct file_lock * , int ) ; void ( * fl_copy_lock ) ( struct file_lock * , struct file_lock * ) ; void ( * fl_release_private ) ( struct file_lock * ) ; void ( * fl_break ) ( struct file_lock * ) ; int ( * fl_mylease ) ( struct file_lock * , struct file_lock * ) ; int ( * fl_change ) ( struct file_lock * * , int ) ; } ;

struct lock_manager { struct list_head list ; } ;

enum nfs_stat { NFS_OK = 0 , NFSERR_PERM = 1 , NFSERR_NOENT = 2 , NFSERR_IO = 5 , NFSERR_NXIO = 6 , NFSERR_EAGAIN = 11 , NFSERR_ACCES = 13 , NFSERR_EXIST = 17 , NFSERR_XDEV = 18 , NFSERR_NODEV = 19 , NFSERR_NOTDIR = 20 , NFSERR_ISDIR = 21 , NFSERR_INVAL = 22 , NFSERR_FBIG = 27 , NFSERR_NOSPC = 28 , NFSERR_ROFS = 30 , NFSERR_MLINK = 31 , NFSERR_OPNOTSUPP = 45 , NFSERR_NAMETOOLONG = 63 , NFSERR_NOTEMPTY = 66 , NFSERR_DQUOT = 69 , NFSERR_STALE = 70 , NFSERR_REMOTE = 71 , NFSERR_WFLUSH = 99 , NFSERR_BADHANDLE = 10001 , NFSERR_NOT_SYNC = 10002 , NFSERR_BAD_COOKIE = 10003 , NFSERR_NOTSUPP = 10004 , NFSERR_TOOSMALL = 10005 , NFSERR_SERVERFAULT = 10006 , NFSERR_BADTYPE = 10007 , NFSERR_JUKEBOX = 10008 , NFSERR_SAME = 10009 , NFSERR_DENIED = 10010 , NFSERR_EXPIRED = 10011 , NFSERR_LOCKED = 10012 , NFSERR_GRACE = 10013 , NFSERR_FHEXPIRED = 10014 , NFSERR_SHARE_DENIED = 10015 , NFSERR_WRONGSEC = 10016 , NFSERR_CLID_INUSE = 10017 , NFSERR_RESOURCE = 10018 , NFSERR_MOVED = 10019 , NFSERR_NOFILEHANDLE = 10020 , NFSERR_MINOR_VERS_MISMATCH = 10021 , NFSERR_STALE_CLIENTID = 10022 , NFSERR_STALE_STATEID = 10023 , NFSERR_OLD_STATEID = 10024 , NFSERR_BAD_STATEID = 10025 , NFSERR_BAD_SEQID = 10026 , NFSERR_NOT_SAME = 10027 , NFSERR_LOCK_RANGE = 10028 , NFSERR_SYMLINK = 10029 , NFSERR_RESTOREFH = 10030 , NFSERR_LEASE_MOVED = 10031 , NFSERR_ATTRNOTSUPP = 10032 , NFSERR_NO_GRACE = 10033 , NFSERR_RECLAIM_BAD = 10034 , NFSERR_RECLAIM_CONFLICT = 10035 , NFSERR_BAD_XDR = 10036 , NFSERR_LOCKS_HELD = 10037 , NFSERR_OPENMODE = 10038 , NFSERR_BADOWNER = 10039 , NFSERR_BADCHAR = 10040 , NFSERR_BADNAME = 10041 , NFSERR_BAD_RANGE = 10042 , NFSERR_LOCK_NOTSUPP = 10043 , NFSERR_OP_ILLEGAL = 10044 , NFSERR_DEADLOCK = 10045 , NFSERR_FILE_OPEN = 10046 , NFSERR_ADMIN_REVOKED = 10047 , NFSERR_CB_PATH_DOWN = 10048 , } ;

enum nfs_ftype { NFNON = 0 , NFREG = 1 , NFDIR = 2 , NFBLK = 3 , NFCHR = 4 , NFLNK = 5 , NFSOCK = 6 , NFBAD = 7 , NFFIFO = 8 } ;

typedef u32 rpc_authflavor_t ;

enum rpc_auth_flavors { RPC_AUTH_NULL = 0 , RPC_AUTH_UNIX = 1 , RPC_AUTH_SHORT = 2 , RPC_AUTH_DES = 3 , RPC_AUTH_KRB = 4 , RPC_AUTH_GSS = 6 , RPC_AUTH_MAXFLAVOR = 8 , RPC_AUTH_GSS_KRB5 = 390003 , RPC_AUTH_GSS_KRB5I = 390004 , RPC_AUTH_GSS_KRB5P = 390005 , RPC_AUTH_GSS_LKEY = 390006 , RPC_AUTH_GSS_LKEYI = 390007 , RPC_AUTH_GSS_LKEYP = 390008 , RPC_AUTH_GSS_SPKM = 390009 , RPC_AUTH_GSS_SPKMI = 390010 , RPC_AUTH_GSS_SPKMP = 390011 , } ;

enum rpc_msg_type { RPC_CALL = 0 , RPC_REPLY = 1 } ;

enum rpc_reply_stat { RPC_MSG_ACCEPTED = 0 , RPC_MSG_DENIED = 1 } ;

enum rpc_accept_stat { RPC_SUCCESS = 0 , RPC_PROG_UNAVAIL = 1 , RPC_PROG_MISMATCH = 2 , RPC_PROC_UNAVAIL = 3 , RPC_GARBAGE_ARGS = 4 , RPC_SYSTEM_ERR = 5 , RPC_DROP_REPLY = 60000 , } ;

enum rpc_reject_stat { RPC_MISMATCH = 0 , RPC_AUTH_ERROR = 1 } ;

enum rpc_auth_stat { RPC_AUTH_OK = 0 , RPC_AUTH_BADCRED = 1 , RPC_AUTH_REJECTEDCRED = 2 , RPC_AUTH_BADVERF = 3 , RPC_AUTH_REJECTEDVERF = 4 , RPC_AUTH_TOOWEAK = 5 , RPCSEC_GSS_CREDPROBLEM = 13 , RPCSEC_GSS_CTXPROBLEM = 14 } ;

typedef __be32 rpc_fraghdr ;

struct nfs_fh { unsigned short size ; unsigned char data [ 128 ] ; } ;

enum nfs3_stable_how { NFS_UNSTABLE = 0 , NFS_DATA_SYNC = 1 , NFS_FILE_SYNC = 2 } ;

struct nlm_lockowner ;

struct nfs_lock_info { u32 state ; struct nlm_lockowner * owner ; struct list_head list ; } ;

struct nfs4_lock_state ;

struct nfs4_lock_info { struct nfs4_lock_state * owner ; } ;

struct file_lock { struct file_lock * fl_next ; struct list_head fl_link ; struct list_head fl_block ; fl_owner_t fl_owner ; unsigned char fl_flags ; unsigned char fl_type ; unsigned int fl_pid ; struct pid * fl_nspid ; wait_queue_head_t fl_wait ; struct file * fl_file ; loff_t fl_start ; loff_t fl_end ; struct fasync_struct * fl_fasync ; unsigned long fl_break_time ; const struct file_lock_operations * fl_ops ; const struct lock_manager_operations * fl_lmops ; union { struct nfs_lock_info nfs_fl ; struct nfs4_lock_info nfs4_fl ; struct { struct list_head link ; int state ; } afs ; } fl_u ; } ;

struct f_owner_ex { int type ; pid_t pid ; } ;
struct flock { short l_type ; short l_whence ; __kernel_off_t l_start ; __kernel_off_t l_len ; __kernel_pid_t l_pid ; } ;
struct fasync_struct { int magic ; int fa_fd ; struct fasync_struct * fa_next ; struct file * fa_file ; } ;

struct super_block { struct list_head s_list ; dev_t s_dev ; unsigned long s_blocksize ; unsigned char s_blocksize_bits ; unsigned char s_dirt ; loff_t s_maxbytes ; struct file_system_type * s_type ; const struct super_operations * s_op ; const struct dquot_operations * dq_op ; const struct quotactl_ops * s_qcop ; const struct export_operations * s_export_op ; unsigned long s_flags ; unsigned long s_magic ; struct dentry * s_root ; struct rw_semaphore s_umount ; struct mutex s_lock ; int s_count ; int s_need_sync ; atomic_t s_active ; void * s_security ; struct xattr_handler * * s_xattr ; struct list_head s_inodes ; struct hlist_head s_anon ; struct list_head s_files ; struct list_head s_dentry_lru ; int s_nr_dentry_unused ; struct block_device * s_bdev ; struct backing_dev_info * s_bdi ; struct mtd_info * s_mtd ; struct list_head s_instances ; struct quota_info s_dquot ; int s_frozen ; wait_queue_head_t s_wait_unfrozen ; char s_id [ 32 ] ; void * s_fs_info ; fmode_t s_mode ; struct mutex s_vfs_rename_mutex ; u32 s_time_gran ; char * s_subtype ; char * s_options ; } ;
enum { SB_UNFROZEN = 0 , SB_FREEZE_WRITE = 1 , SB_FREEZE_TRANS = 2 , } ;
struct fiemap_extent_info { unsigned int fi_flags ; unsigned int fi_extents_mapped ; unsigned int fi_extents_max ; struct fiemap_extent * fi_extents_start ; } ;

typedef int ( * filldir_t ) ( void * , const char * , int , loff_t , u64 , unsigned ) ;
struct block_device_operations ;

struct file_operations { struct module * owner ; loff_t ( * llseek ) ( struct file * , loff_t , int ) ; ssize_t ( * read ) ( struct file * , char * , size_t , loff_t * ) ; ssize_t ( * write ) ( struct file * , const char * , size_t , loff_t * ) ; ssize_t ( * aio_read ) ( struct kiocb * , const struct iovec * , unsigned long , loff_t ) ; ssize_t ( * aio_write ) ( struct kiocb * , const struct iovec * , unsigned long , loff_t ) ; int ( * readdir ) ( struct file * , void * , filldir_t ) ; unsigned int ( * poll ) ( struct file * , struct poll_table_struct * ) ; int ( * ioctl ) ( struct inode * , struct file * , unsigned int , unsigned long ) ; long ( * unlocked_ioctl ) ( struct file * , unsigned int , unsigned long ) ; long ( * compat_ioctl ) ( struct file * , unsigned int , unsigned long ) ; int ( * mmap ) ( struct file * , struct vm_area_struct * ) ; int ( * open ) ( struct inode * , struct file * ) ; int ( * flush ) ( struct file * , fl_owner_t id ) ; int ( * release ) ( struct inode * , struct file * ) ; int ( * fsync ) ( struct file * , struct dentry * , int datasync ) ; int ( * aio_fsync ) ( struct kiocb * , int datasync ) ; int ( * fasync ) ( int , struct file * , int ) ; int ( * lock ) ( struct file * , int , struct file_lock * ) ; ssize_t ( * sendpage ) ( struct file * , struct page * , int , size_t , loff_t * , int ) ; unsigned long ( * get_unmapped_area ) ( struct file * , unsigned long , unsigned long , unsigned long , unsigned long ) ; int ( * check_flags ) ( int ) ; int ( * flock ) ( struct file * , int , struct file_lock * ) ; ssize_t ( * splice_write ) ( struct pipe_inode_info * , struct file * , loff_t * , size_t , unsigned int ) ; ssize_t ( * splice_read ) ( struct file * , loff_t * , struct pipe_inode_info * , size_t , unsigned int ) ; int ( * setlease ) ( struct file * , long , struct file_lock * * ) ; } ;

struct inode_operations { int ( * create ) ( struct inode * , struct dentry * , int , struct nameidata * ) ; struct dentry * ( * lookup ) ( struct inode * , struct dentry * , struct nameidata * ) ; int ( * link ) ( struct dentry * , struct inode * , struct dentry * ) ; int ( * unlink ) ( struct inode * , struct dentry * ) ; int ( * symlink ) ( struct inode * , struct dentry * , const char * ) ; int ( * mkdir ) ( struct inode * , struct dentry * , int ) ; int ( * rmdir ) ( struct inode * , struct dentry * ) ; int ( * mknod ) ( struct inode * , struct dentry * , int , dev_t ) ; int ( * rename ) ( struct inode * , struct dentry * , struct inode * , struct dentry * ) ; int ( * readlink ) ( struct dentry * , char * , int ) ; void * ( * follow_link ) ( struct dentry * , struct nameidata * ) ; void ( * put_link ) ( struct dentry * , struct nameidata * , void * ) ; void ( * truncate ) ( struct inode * ) ; int ( * permission ) ( struct inode * , int ) ; int ( * check_acl ) ( struct inode * , int ) ; int ( * setattr ) ( struct dentry * , struct iattr * ) ; int ( * getattr ) ( struct vfsmount * mnt , struct dentry * , struct kstat * ) ; int ( * setxattr ) ( struct dentry * , const char * , const void * , size_t , int ) ; ssize_t ( * getxattr ) ( struct dentry * , const char * , void * , size_t ) ; ssize_t ( * listxattr ) ( struct dentry * , char * , size_t ) ; int ( * removexattr ) ( struct dentry * , const char * ) ; void ( * truncate_range ) ( struct inode * , loff_t , loff_t ) ; long ( * fallocate ) ( struct inode * inode , int mode , loff_t offset , loff_t len ) ; int ( * fiemap ) ( struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ; } ;

struct super_operations { struct inode * ( * alloc_inode ) ( struct super_block * sb ) ; void ( * destroy_inode ) ( struct inode * ) ; void ( * dirty_inode ) ( struct inode * ) ; int ( * write_inode ) ( struct inode * , int ) ; void ( * drop_inode ) ( struct inode * ) ; void ( * delete_inode ) ( struct inode * ) ; void ( * put_super ) ( struct super_block * ) ; void ( * write_super ) ( struct super_block * ) ; int ( * sync_fs ) ( struct super_block * sb , int wait ) ; int ( * freeze_fs ) ( struct super_block * ) ; int ( * unfreeze_fs ) ( struct super_block * ) ; int ( * statfs ) ( struct dentry * , struct kstatfs * ) ; int ( * remount_fs ) ( struct super_block * , int * , char * ) ; void ( * clear_inode ) ( struct inode * ) ; void ( * umount_begin ) ( struct super_block * ) ; int ( * show_options ) ( struct seq_file * , struct vfsmount * ) ; int ( * show_stats ) ( struct seq_file * , struct vfsmount * ) ; ssize_t ( * quota_read ) ( struct super_block * , int , char * , size_t , loff_t ) ; ssize_t ( * quota_write ) ( struct super_block * , int , const char * , size_t , loff_t ) ; int ( * bdev_try_to_free_page ) ( struct super_block * , struct page * , gfp_t ) ; } ;

struct file_system_type { const char * name ; int fs_flags ; int ( * get_sb ) ( struct file_system_type * , int , const char * , void * , struct vfsmount * ) ; void ( * kill_sb ) ( struct super_block * ) ; struct module * owner ; struct file_system_type * next ; struct list_head fs_supers ; struct lock_class_key s_lock_key ; struct lock_class_key s_umount_key ; struct lock_class_key i_lock_key ; struct lock_class_key i_mutex_key ; struct lock_class_key i_mutex_dir_key ; struct lock_class_key i_alloc_sem_key ; } ;

enum { DIO_LOCKING = 1 , DIO_NO_LOCKING , DIO_OWN_LOCKING , } ;
struct tree_descr { char * name ; const struct file_operations * ops ; int mode ; } ;

struct simple_transaction_argresp { ssize_t size ; char data [ 0 ] ; } ;

struct net ;

enum { PROC_ROOT_INO = 1 , } ;
typedef int ( read_proc_t ) ( char * page , char * * start , off_t off , int count , int * eof , void * data ) ;
typedef int ( write_proc_t ) ( struct file * file , const char * buffer , unsigned long count , void * data ) ;
struct proc_dir_entry { unsigned int low_ino ; unsigned short namelen ; const char * name ; mode_t mode ; nlink_t nlink ; uid_t uid ; gid_t gid ; loff_t size ; const struct inode_operations * proc_iops ; const struct file_operations * proc_fops ; struct proc_dir_entry * next , * parent , * subdir ; void * data ; read_proc_t * read_proc ; write_proc_t * write_proc ; atomic_t count ; int pde_users ; spinlock_t pde_unload_lock ; struct completion * pde_unload_completion ; struct list_head pde_openers ; } ;
enum kcore_type { KCORE_TEXT , KCORE_VMALLOC , KCORE_RAM , KCORE_VMEMMAP , KCORE_OTHER , } ;

struct kcore_list { struct list_head list ; unsigned long addr ; size_t size ; int type ; } ;

struct vmcore { struct list_head list ; unsigned long long paddr ; unsigned long long size ; loff_t offset ; } ;

struct tty_driver ;

union proc_op { int ( * proc_get_link ) ( struct inode * , struct path * ) ; int ( * proc_read ) ( struct task_struct * task , char * page ) ; int ( * proc_show ) ( struct seq_file * m , struct pid_namespace * ns , struct pid * pid , struct task_struct * task ) ; } ;

struct proc_inode { struct pid * pid ; int fd ; union proc_op op ; struct proc_dir_entry * pde ; struct ctl_table_header * sysctl ; struct ctl_table * sysctl_entry ; struct inode vfs_inode ; } ;

struct proc_maps_private { struct pid * pid ; struct task_struct * task ; struct vm_area_struct * tail_vma ; } ;

struct iattr ;
struct iocb ;
struct io_event ;
struct itimerspec ;
struct kexec_segment ;

struct linux_dirent ;

struct linux_dirent64 ;

struct list_head ;
struct msgbuf ;

struct msghdr ;
struct msqid_ds ;

struct new_utsname ;

struct nfsctl_arg ;

struct __old_kernel_stat ;
struct pollfd ;

struct sched_param ;
struct semaphore ;
struct sembuf ;
struct shmid_ds ;

struct sockaddr ;
struct stat ;
struct stat64 ;
struct statfs ;

struct statfs64 ;

struct __sysctl_args ;
struct timeval ;
struct timex ;
struct timezone ;
struct utimbuf ;

struct mq_attr ;

struct compat_stat ;
struct compat_timeval ;
struct getcpu_cache ;

struct old_linux_dirent ;

struct perf_event_attr ;

struct seq_operations ;

struct seq_file { char * buf ; size_t size ; size_t from ; size_t count ; loff_t index ; loff_t read_pos ; u64 version ; struct mutex lock ; const struct seq_operations * op ; void * private ; } ;
struct seq_operations { void * ( * start ) ( struct seq_file * m , loff_t * pos ) ; void ( * stop ) ( struct seq_file * m , void * v ) ; void * ( * next ) ( struct seq_file * m , void * v , loff_t * pos ) ; int ( * show ) ( struct seq_file * m , void * v ) ; } ;
struct ring_buffer ;

struct ring_buffer_iter ;

struct ring_buffer_event { int bitfield_begin [ 0 ] ; ; u32 type_len : 5 , time_delta : 27 ; int bitfield_end [ 0 ] ; ; u32 array [ ] ; } ;

enum ring_buffer_type { RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28 , RINGBUF_TYPE_PADDING , RINGBUF_TYPE_TIME_EXTEND , RINGBUF_TYPE_TIME_STAMP , } ;

struct trace_seq ;

enum ring_buffer_flags { RB_FL_OVERWRITE = 1 << 0 , } ;

struct trace_seq { unsigned char buffer [ ( ( 1UL ) << 12 ) ] ; unsigned int len ; unsigned int readpos ; } ;
struct trace_array ;

struct tracer ;

struct trace_print_flags { unsigned long mask ; const char * name ; } ;

struct trace_entry { unsigned short type ; unsigned char flags ; unsigned char preempt_count ; int pid ; int lock_depth ; } ;

struct trace_iterator { struct trace_array * tr ; struct tracer * trace ; void * private ; int cpu_file ; struct mutex mutex ; struct ring_buffer_iter * buffer_iter [ 64 ] ; unsigned long iter_flags ; struct trace_seq seq ; struct trace_entry * ent ; int cpu ; u64 ts ; loff_t pos ; long idx ; cpumask_var_t started ; } ;

typedef enum print_line_t ( * trace_print_func ) ( struct trace_iterator * iter , int flags ) ;

struct trace_event { struct hlist_node node ; struct list_head list ; int type ; trace_print_func trace ; trace_print_func raw ; trace_print_func hex ; trace_print_func binary ; } ;

enum print_line_t { TRACE_TYPE_PARTIAL_LINE = 0 , TRACE_TYPE_HANDLED = 1 , TRACE_TYPE_UNHANDLED = 2 , TRACE_TYPE_NO_CONSUME = 3 } ;

struct event_filter ;

struct ftrace_event_call { struct list_head list ; char * name ; char * system ; struct dentry * dir ; struct trace_event * event ; int enabled ; int ( * regfunc ) ( void * ) ; void ( * unregfunc ) ( void * ) ; int id ; int ( * raw_init ) ( void ) ; int ( * show_format ) ( struct ftrace_event_call * call , struct trace_seq * s ) ; int ( * define_fields ) ( struct ftrace_event_call * ) ; struct list_head fields ; int filter_active ; struct event_filter * filter ; void * mod ; void * data ; atomic_t profile_count ; int ( * profile_enable ) ( void ) ; void ( * profile_disable ) ( void ) ; } ;

enum { FILTER_OTHER = 0 , FILTER_STATIC_STRING , FILTER_DYN_STRING , FILTER_PTR_STRING , } ;
struct syscall_metadata { const char * name ; int nb_args ; const char * * types ; const char * * args ; int enter_id ; int exit_id ; struct ftrace_event_call * enter_event ; struct ftrace_event_call * exit_event ; } ;

struct rand_pool_info { int entropy_count ; int buf_size ; __u32 buf [ 0 ] ; } ;

struct vm_struct { struct vm_struct * next ; void * addr ; unsigned long size ; unsigned long flags ; struct page * * pages ; unsigned int nr_pages ; unsigned long phys_addr ; void * caller ; } ;

struct pci_dev ;

typedef struct bootmem_data { unsigned long node_min_pfn ; unsigned long node_low_pfn ; void * node_bootmem_map ; unsigned long last_end_off ; unsigned long hint_idx ; struct list_head list ; } bootmem_data_t ;

typedef unsigned long kernel_ulong_t ;
struct of_device_id { char name [ 32 ] ; char type [ 32 ] ; char compatible [ 128 ] ; void * data ; } ;
struct pcmcia_device_id { __u16 match_flags ; __u16 manf_id ; __u16 card_id ; __u8 func_id ; __u8 function ; __u8 device_no ; __u32 prod_id_hash [ 4 ] __attribute__ ( ( aligned ( sizeof ( __u32 ) ) ) ) ; const char * prod_id [ 4 ] ; kernel_ulong_t driver_info ; char * cisfile ; } ;
struct dmi_system_id { int ( * callback ) ( const struct dmi_system_id * ) ; const char * ident ; struct dmi_strmatch matches [ 4 ] ; void * driver_data ; } ;
typedef unsigned char BOOLEAN ;

typedef unsigned char UINT8 ;

typedef unsigned short UINT16 ;

typedef unsigned long long UINT64 ;

typedef long long INT64 ;

typedef unsigned int UINT32 ;

typedef int INT32 ;

typedef s64 acpi_native_int ;

typedef u64 acpi_size ;

typedef u64 acpi_io_address ;

typedef u64 acpi_physical_address ;

typedef u32 acpi_status ;

typedef u32 acpi_name ;

typedef char * acpi_string ;

typedef void * acpi_handle ;

typedef u8 acpi_owner_id ;

struct uint64_struct { u32 lo ; u32 hi ; } ;

union uint64_overlay { u64 full ; struct uint64_struct part ; } ;

struct uint32_struct { u32 lo ; u32 hi ; } ;

typedef unsigned long long acpi_integer ;

typedef u32 acpi_object_type ;

typedef u32 acpi_event_type ;

typedef u32 acpi_event_status ;

typedef u8 acpi_adr_space_type ;

union acpi_object { acpi_object_type type ; struct { acpi_object_type type ; acpi_integer value ; } integer ; struct { acpi_object_type type ; u32 length ; char * pointer ; } string ; struct { acpi_object_type type ; u32 length ; u8 * pointer ; } buffer ; struct { acpi_object_type type ; u32 count ; union acpi_object * elements ; } package ; struct { acpi_object_type type ; acpi_object_type actual_type ; acpi_handle handle ; } reference ; struct { acpi_object_type type ; u32 proc_id ; acpi_io_address pblk_address ; u32 pblk_length ; } processor ; struct { acpi_object_type type ; u32 system_level ; u32 resource_order ; } power_resource ; } ;

struct acpi_object_list { u32 count ; union acpi_object * pointer ; } ;

struct acpi_buffer { acpi_size length ; void * pointer ; } ;

struct acpi_predefined_names { char * name ; u8 type ; char * val ; } ;

struct acpi_system_info { u32 acpi_ca_version ; u32 flags ; u32 timer_resolution ; u32 reserved1 ; u32 reserved2 ; u32 debug_level ; u32 debug_layer ; } ;

typedef u32 ( * acpi_osd_handler ) ( void * context ) ;

typedef void ( * acpi_osd_exec_callback ) ( void * context ) ;
typedef u32 ( * acpi_event_handler ) ( void * context ) ;
typedef void ( * acpi_notify_handler ) ( acpi_handle device , u32 value , void * context ) ;
typedef void ( * acpi_object_handler ) ( acpi_handle object , void * data ) ;
typedef acpi_status ( * acpi_init_handler ) ( acpi_handle object , u32 function ) ;

typedef acpi_status ( * acpi_exception_handler ) ( acpi_status aml_status , acpi_name name , u16 opcode , u32 aml_offset , void * context ) ;
typedef acpi_status ( * acpi_tbl_handler ) ( u32 event , void * table , void * context ) ;
typedef acpi_status ( * acpi_adr_space_handler ) ( u32 function , acpi_physical_address address , u32 bit_width , acpi_integer * value , void * handler_context , void * region_context ) ;
typedef acpi_status ( * acpi_adr_space_setup ) ( acpi_handle region_handle , u32 function , void * handler_context , void * * region_context ) ;
typedef acpi_status ( * acpi_walk_callback ) ( acpi_handle obj_handle , u32 nesting_level , void * context , void * * return_value ) ;
struct acpica_device_id { u32 length ; char * string ; } ;

struct acpica_device_id_list { u32 count ; u32 list_size ; struct acpica_device_id ids [ 1 ] ; } ;

struct acpi_device_info { u32 info_size ; u32 name ; acpi_object_type type ; u8 param_count ; u8 valid ; u8 flags ; u8 highest_dstates [ 4 ] ; u8 lowest_dstates [ 5 ] ; u32 current_status ; acpi_integer address ; struct acpica_device_id hardware_id ; struct acpica_device_id unique_id ; struct acpica_device_id_list compatible_id_list ; } ;

struct acpi_pci_id { u16 segment ; u16 bus ; u16 device ; u16 function ; } ;

struct acpi_mem_space_context { u32 length ; acpi_physical_address address ; acpi_physical_address mapped_physical_address ; u8 * mapped_logical_address ; acpi_size mapped_length ; } ;

struct acpi_memory_list { char * list_name ; void * list_head ; u16 object_size ; u16 max_depth ; u16 current_depth ; u16 link_offset ; } ;

struct acpi_table_header { char signature [ 4 ] ; u32 length ; u8 revision ; u8 checksum ; char oem_id [ 6 ] ; char oem_table_id [ 8 ] ; u32 oem_revision ; char asl_compiler_id [ 4 ] ; u32 asl_compiler_revision ; } ;

struct acpi_generic_address { u8 space_id ; u8 bit_width ; u8 bit_offset ; u8 access_width ; u64 address ; } ;

struct acpi_table_rsdp { char signature [ 8 ] ; u8 checksum ; char oem_id [ 6 ] ; u8 revision ; u32 rsdt_physical_address ; u32 length ; u64 xsdt_physical_address ; u8 extended_checksum ; u8 reserved [ 3 ] ; } ;

struct acpi_table_rsdt { struct acpi_table_header header ; u32 table_offset_entry [ 1 ] ; } ;

struct acpi_table_xsdt { struct acpi_table_header header ; u64 table_offset_entry [ 1 ] ; } ;

struct acpi_table_facs { char signature [ 4 ] ; u32 length ; u32 hardware_signature ; u32 firmware_waking_vector ; u32 global_lock ; u32 flags ; u64 xfirmware_waking_vector ; u8 version ; u8 reserved [ 3 ] ; u32 ospm_flags ; u8 reserved1 [ 24 ] ; } ;

struct acpi_table_fadt { struct acpi_table_header header ; u32 facs ; u32 dsdt ; u8 model ; u8 preferred_profile ; u16 sci_interrupt ; u32 smi_command ; u8 acpi_enable ; u8 acpi_disable ; u8 S4bios_request ; u8 pstate_control ; u32 pm1a_event_block ; u32 pm1b_event_block ; u32 pm1a_control_block ; u32 pm1b_control_block ; u32 pm2_control_block ; u32 pm_timer_block ; u32 gpe0_block ; u32 gpe1_block ; u8 pm1_event_length ; u8 pm1_control_length ; u8 pm2_control_length ; u8 pm_timer_length ; u8 gpe0_block_length ; u8 gpe1_block_length ; u8 gpe1_base ; u8 cst_control ; u16 C2latency ; u16 C3latency ; u16 flush_size ; u16 flush_stride ; u8 duty_offset ; u8 duty_width ; u8 day_alarm ; u8 month_alarm ; u8 century ; u16 boot_flags ; u8 reserved ; u32 flags ; struct acpi_generic_address reset_register ; u8 reset_value ; u8 reserved4 [ 3 ] ; u64 Xfacs ; u64 Xdsdt ; struct acpi_generic_address xpm1a_event_block ; struct acpi_generic_address xpm1b_event_block ; struct acpi_generic_address xpm1a_control_block ; struct acpi_generic_address xpm1b_control_block ; struct acpi_generic_address xpm2_control_block ; struct acpi_generic_address xpm_timer_block ; struct acpi_generic_address xgpe0_block ; struct acpi_generic_address xgpe1_block ; } ;

enum acpi_prefered_pm_profiles { PM_UNSPECIFIED = 0 , PM_DESKTOP = 1 , PM_MOBILE = 2 , PM_WORKSTATION = 3 , PM_ENTERPRISE_SERVER = 4 , PM_SOHO_SERVER = 5 , PM_APPLIANCE_PC = 6 } ;

union acpi_name_union { u32 integer ; char ascii [ 4 ] ; } ;

struct acpi_table_desc { acpi_physical_address address ; struct acpi_table_header * pointer ; u32 length ; union acpi_name_union signature ; acpi_owner_id owner_id ; u8 flags ; } ;

struct acpi_subtable_header { u8 type ; u8 length ; } ;

struct acpi_whea_header { u8 action ; u8 instruction ; u8 flags ; u8 reserved ; struct acpi_generic_address register_region ; u64 value ; u64 mask ; } ;

struct acpi_table_bert { struct acpi_table_header header ; u32 region_length ; u64 address ; } ;

struct acpi_bert_region { u32 block_status ; u32 raw_data_offset ; u32 raw_data_length ; u32 data_length ; u32 error_severity ; } ;

enum acpi_bert_error_severity { ACPI_BERT_ERROR_CORRECTABLE = 0 , ACPI_BERT_ERROR_FATAL = 1 , ACPI_BERT_ERROR_CORRECTED = 2 , ACPI_BERT_ERROR_NONE = 3 , ACPI_BERT_ERROR_RESERVED = 4 } ;

struct acpi_table_cpep { struct acpi_table_header header ; u64 reserved ; } ;

struct acpi_cpep_polling { struct acpi_subtable_header header ; u8 id ; u8 eid ; u32 interval ; } ;

struct acpi_table_ecdt { struct acpi_table_header header ; struct acpi_generic_address control ; struct acpi_generic_address data ; u32 uid ; u8 gpe ; u8 id [ 1 ] ; } ;

struct acpi_table_einj { struct acpi_table_header header ; u32 header_length ; u8 flags ; u8 reserved [ 3 ] ; u32 entries ; } ;

struct acpi_einj_entry { struct acpi_whea_header whea_header ; } ;

enum acpi_einj_actions { ACPI_EINJ_BEGIN_OPERATION = 0 , ACPI_EINJ_GET_TRIGGER_TABLE = 1 , ACPI_EINJ_SET_ERROR_TYPE = 2 , ACPI_EINJ_GET_ERROR_TYPE = 3 , ACPI_EINJ_END_OPERATION = 4 , ACPI_EINJ_EXECUTE_OPERATION = 5 , ACPI_EINJ_CHECK_BUSY_STATUS = 6 , ACPI_EINJ_GET_COMMAND_STATUS = 7 , ACPI_EINJ_ACTION_RESERVED = 8 , ACPI_EINJ_TRIGGER_ERROR = 0xFF } ;

enum acpi_einj_instructions { ACPI_EINJ_READ_REGISTER = 0 , ACPI_EINJ_READ_REGISTER_VALUE = 1 , ACPI_EINJ_WRITE_REGISTER = 2 , ACPI_EINJ_WRITE_REGISTER_VALUE = 3 , ACPI_EINJ_NOOP = 4 , ACPI_EINJ_INSTRUCTION_RESERVED = 5 } ;

struct acpi_einj_trigger { u32 header_size ; u32 revision ; u32 table_size ; u32 entry_count ; } ;

enum acpi_einj_command_status { ACPI_EINJ_SUCCESS = 0 , ACPI_EINJ_FAILURE = 1 , ACPI_EINJ_INVALID_ACCESS = 2 , ACPI_EINJ_STATUS_RESERVED = 3 } ;

struct acpi_table_erst { struct acpi_table_header header ; u32 header_length ; u32 reserved ; u32 entries ; } ;

struct acpi_erst_entry { struct acpi_whea_header whea_header ; } ;

enum acpi_erst_actions { ACPI_ERST_BEGIN_WRITE = 0 , ACPI_ERST_BEGIN_READ = 1 , ACPI_ERST_BEGIN_CLEAR = 2 , ACPI_ERST_END = 3 , ACPI_ERST_SET_RECORD_OFFSET = 4 , ACPI_ERST_EXECUTE_OPERATION = 5 , ACPI_ERST_CHECK_BUSY_STATUS = 6 , ACPI_ERST_GET_COMMAND_STATUS = 7 , ACPI_ERST_GET_RECORD_ID = 8 , ACPI_ERST_SET_RECORD_ID = 9 , ACPI_ERST_GET_RECORD_COUNT = 10 , ACPI_ERST_BEGIN_DUMMY_WRIITE = 11 , ACPI_ERST_NOT_USED = 12 , ACPI_ERST_GET_ERROR_RANGE = 13 , ACPI_ERST_GET_ERROR_LENGTH = 14 , ACPI_ERST_GET_ERROR_ATTRIBUTES = 15 , ACPI_ERST_ACTION_RESERVED = 16 } ;

enum acpi_erst_instructions { ACPI_ERST_READ_REGISTER = 0 , ACPI_ERST_READ_REGISTER_VALUE = 1 , ACPI_ERST_WRITE_REGISTER = 2 , ACPI_ERST_WRITE_REGISTER_VALUE = 3 , ACPI_ERST_NOOP = 4 , ACPI_ERST_LOAD_VAR1 = 5 , ACPI_ERST_LOAD_VAR2 = 6 , ACPI_ERST_STORE_VAR1 = 7 , ACPI_ERST_ADD = 8 , ACPI_ERST_SUBTRACT = 9 , ACPI_ERST_ADD_VALUE = 10 , ACPI_ERST_SUBTRACT_VALUE = 11 , ACPI_ERST_STALL = 12 , ACPI_ERST_STALL_WHILE_TRUE = 13 , ACPI_ERST_SKIP_NEXT_IF_TRUE = 14 , ACPI_ERST_GOTO = 15 , ACPI_ERST_SET_SRC_ADDRESS_BASE = 16 , ACPI_ERST_SET_DST_ADDRESS_BASE = 17 , ACPI_ERST_MOVE_DATA = 18 , ACPI_ERST_INSTRUCTION_RESERVED = 19 } ;

enum acpi_erst_command_status { ACPI_ERST_SUCESS = 0 , ACPI_ERST_NO_SPACE = 1 , ACPI_ERST_NOT_AVAILABLE = 2 , ACPI_ERST_FAILURE = 3 , ACPI_ERST_RECORD_EMPTY = 4 , ACPI_ERST_NOT_FOUND = 5 , ACPI_ERST_STATUS_RESERVED = 6 } ;

struct acpi_erst_info { u16 signature ; u8 data [ 48 ] ; } ;

struct acpi_table_hest { struct acpi_table_header header ; u32 error_source_count ; } ;

struct acpi_hest_header { u16 type ; u16 source_id ; } ;

enum acpi_hest_types { ACPI_HEST_TYPE_IA32_CHECK = 0 , ACPI_HEST_TYPE_IA32_CORRECTED_CHECK = 1 , ACPI_HEST_TYPE_IA32_NMI = 2 , ACPI_HEST_TYPE_NOT_USED3 = 3 , ACPI_HEST_TYPE_NOT_USED4 = 4 , ACPI_HEST_TYPE_NOT_USED5 = 5 , ACPI_HEST_TYPE_AER_ROOT_PORT = 6 , ACPI_HEST_TYPE_AER_ENDPOINT = 7 , ACPI_HEST_TYPE_AER_BRIDGE = 8 , ACPI_HEST_TYPE_GENERIC_ERROR = 9 , ACPI_HEST_TYPE_RESERVED = 10 } ;

struct acpi_hest_ia_error_bank { u8 bank_number ; u8 clear_status_on_init ; u8 status_format ; u8 reserved ; u32 control_register ; u64 control_data ; u32 status_register ; u32 address_register ; u32 misc_register ; } ;

struct acpi_hest_aer_common { u16 reserved1 ; u8 flags ; u8 enabled ; u32 records_to_preallocate ; u32 max_sections_per_record ; u32 bus ; u16 device ; u16 function ; u16 device_control ; u16 reserved2 ; u32 uncorrectable_mask ; u32 uncorrectable_severity ; u32 correctable_mask ; u32 advanced_capabilities ; } ;

struct acpi_hest_notify { u8 type ; u8 length ; u16 config_write_enable ; u32 poll_interval ; u32 vector ; u32 polling_threshold_value ; u32 polling_threshold_window ; u32 error_threshold_value ; u32 error_threshold_window ; } ;

enum acpi_hest_notify_types { ACPI_HEST_NOTIFY_POLLED = 0 , ACPI_HEST_NOTIFY_EXTERNAL = 1 , ACPI_HEST_NOTIFY_LOCAL = 2 , ACPI_HEST_NOTIFY_SCI = 3 , ACPI_HEST_NOTIFY_NMI = 4 , ACPI_HEST_NOTIFY_RESERVED = 5 } ;

struct acpi_hest_ia_machine_check { struct acpi_hest_header header ; u16 reserved1 ; u8 flags ; u8 enabled ; u32 records_to_preallocate ; u32 max_sections_per_record ; u64 global_capability_data ; u64 global_control_data ; u8 num_hardware_banks ; u8 reserved3 [ 7 ] ; } ;

struct acpi_hest_ia_corrected { struct acpi_hest_header header ; u16 reserved1 ; u8 flags ; u8 enabled ; u32 records_to_preallocate ; u32 max_sections_per_record ; struct acpi_hest_notify notify ; u8 num_hardware_banks ; u8 reserved2 [ 3 ] ; } ;

struct acpi_hest_ia_nmi { struct acpi_hest_header header ; u32 reserved ; u32 records_to_preallocate ; u32 max_sections_per_record ; u32 max_raw_data_length ; } ;

struct acpi_hest_aer_root { struct acpi_hest_header header ; struct acpi_hest_aer_common aer ; u32 root_error_command ; } ;

struct acpi_hest_aer { struct acpi_hest_header header ; struct acpi_hest_aer_common aer ; } ;

struct acpi_hest_aer_bridge { struct acpi_hest_header header ; struct acpi_hest_aer_common aer ; u32 uncorrectable_mask2 ; u32 uncorrectable_severity2 ; u32 advanced_capabilities2 ; } ;

struct acpi_hest_generic { struct acpi_hest_header header ; u16 related_source_id ; u8 reserved ; u8 enabled ; u32 records_to_preallocate ; u32 max_sections_per_record ; u32 max_raw_data_length ; struct acpi_generic_address error_status_address ; struct acpi_hest_notify notify ; u32 error_block_length ; } ;

struct acpi_hest_generic_status { u32 block_status ; u32 raw_data_offset ; u32 raw_data_length ; u32 data_length ; u32 error_severity ; } ;

struct acpi_hest_generic_data { u8 section_type [ 16 ] ; u32 error_severity ; u16 revision ; u8 validation_bits ; u8 flags ; u32 error_data_length ; u8 fru_id [ 16 ] ; u8 fru_text [ 20 ] ; } ;

struct acpi_table_madt { struct acpi_table_header header ; u32 address ; u32 flags ; } ;

enum acpi_madt_type { ACPI_MADT_TYPE_LOCAL_APIC = 0 , ACPI_MADT_TYPE_IO_APIC = 1 , ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 2 , ACPI_MADT_TYPE_NMI_SOURCE = 3 , ACPI_MADT_TYPE_LOCAL_APIC_NMI = 4 , ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 5 , ACPI_MADT_TYPE_IO_SAPIC = 6 , ACPI_MADT_TYPE_LOCAL_SAPIC = 7 , ACPI_MADT_TYPE_INTERRUPT_SOURCE = 8 , ACPI_MADT_TYPE_LOCAL_X2APIC = 9 , ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 10 , ACPI_MADT_TYPE_RESERVED = 11 } ;

struct acpi_madt_local_apic { struct acpi_subtable_header header ; u8 processor_id ; u8 id ; u32 lapic_flags ; } ;

struct acpi_madt_io_apic { struct acpi_subtable_header header ; u8 id ; u8 reserved ; u32 address ; u32 global_irq_base ; } ;

struct acpi_madt_interrupt_override { struct acpi_subtable_header header ; u8 bus ; u8 source_irq ; u32 global_irq ; u16 inti_flags ; } ;

struct acpi_madt_nmi_source { struct acpi_subtable_header header ; u16 inti_flags ; u32 global_irq ; } ;

struct acpi_madt_local_apic_nmi { struct acpi_subtable_header header ; u8 processor_id ; u16 inti_flags ; u8 lint ; } ;

struct acpi_madt_local_apic_override { struct acpi_subtable_header header ; u16 reserved ; u64 address ; } ;

struct acpi_madt_io_sapic { struct acpi_subtable_header header ; u8 id ; u8 reserved ; u32 global_irq_base ; u64 address ; } ;

struct acpi_madt_local_sapic { struct acpi_subtable_header header ; u8 processor_id ; u8 id ; u8 eid ; u8 reserved [ 3 ] ; u32 lapic_flags ; u32 uid ; char uid_string [ 1 ] ; } ;

struct acpi_madt_interrupt_source { struct acpi_subtable_header header ; u16 inti_flags ; u8 type ; u8 id ; u8 eid ; u8 io_sapic_vector ; u32 global_irq ; u32 flags ; } ;

struct acpi_madt_local_x2apic { struct acpi_subtable_header header ; u16 reserved ; u32 local_apic_id ; u32 lapic_flags ; u32 uid ; } ;

struct acpi_madt_local_x2apic_nmi { struct acpi_subtable_header header ; u16 inti_flags ; u32 uid ; u8 lint ; u8 reserved [ 3 ] ; } ;

struct acpi_table_msct { struct acpi_table_header header ; u32 proximity_offset ; u32 max_proximity_domains ; u32 max_clock_domains ; u64 max_address ; } ;

struct acpi_msct_proximity { u8 revision ; u8 length ; u32 range_start ; u32 range_end ; u32 processor_capacity ; u64 memory_capacity ; } ;

struct acpi_table_sbst { struct acpi_table_header header ; u32 warning_level ; u32 low_level ; u32 critical_level ; } ;

struct acpi_table_slit { struct acpi_table_header header ; u64 locality_count ; u8 entry [ 1 ] ; } ;

struct acpi_table_srat { struct acpi_table_header header ; u32 table_revision ; u64 reserved ; } ;

enum acpi_srat_type { ACPI_SRAT_TYPE_CPU_AFFINITY = 0 , ACPI_SRAT_TYPE_MEMORY_AFFINITY = 1 , ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 2 , ACPI_SRAT_TYPE_RESERVED = 3 } ;

struct acpi_srat_cpu_affinity { struct acpi_subtable_header header ; u8 proximity_domain_lo ; u8 apic_id ; u32 flags ; u8 local_sapic_eid ; u8 proximity_domain_hi [ 3 ] ; u32 reserved ; } ;

struct acpi_srat_mem_affinity { struct acpi_subtable_header header ; u32 proximity_domain ; u16 reserved ; u64 base_address ; u64 length ; u32 reserved1 ; u32 flags ; u64 reserved2 ; } ;

struct acpi_srat_x2apic_cpu_affinity { struct acpi_subtable_header header ; u16 reserved ; u32 proximity_domain ; u32 apic_id ; u32 flags ; u32 clock_domain ; u32 reserved2 ; } ;

struct acpi_table_asf { struct acpi_table_header header ; } ;

struct acpi_asf_header { u8 type ; u8 reserved ; u16 length ; } ;

enum acpi_asf_type { ACPI_ASF_TYPE_INFO = 0 , ACPI_ASF_TYPE_ALERT = 1 , ACPI_ASF_TYPE_CONTROL = 2 , ACPI_ASF_TYPE_BOOT = 3 , ACPI_ASF_TYPE_ADDRESS = 4 , ACPI_ASF_TYPE_RESERVED = 5 } ;

struct acpi_asf_info { struct acpi_asf_header header ; u8 min_reset_value ; u8 min_poll_interval ; u16 system_id ; u32 mfg_id ; u8 flags ; u8 reserved2 [ 3 ] ; } ;

struct acpi_asf_alert { struct acpi_asf_header header ; u8 assert_mask ; u8 deassert_mask ; u8 alerts ; u8 data_length ; } ;

struct acpi_asf_alert_data { u8 address ; u8 command ; u8 mask ; u8 value ; u8 sensor_type ; u8 type ; u8 offset ; u8 source_type ; u8 severity ; u8 sensor_number ; u8 entity ; u8 instance ; } ;

struct acpi_asf_remote { struct acpi_asf_header header ; u8 controls ; u8 data_length ; u16 reserved2 ; } ;

struct acpi_asf_control_data { u8 function ; u8 address ; u8 command ; u8 value ; } ;

struct acpi_asf_rmcp { struct acpi_asf_header header ; u8 capabilities [ 7 ] ; u8 completion_code ; u32 enterprise_id ; u8 command ; u16 parameter ; u16 boot_options ; u16 oem_parameters ; } ;

struct acpi_asf_address { struct acpi_asf_header header ; u8 eprom_address ; u8 devices ; } ;

struct acpi_table_boot { struct acpi_table_header header ; u8 cmos_index ; u8 reserved [ 3 ] ; } ;

struct acpi_table_dbgp { struct acpi_table_header header ; u8 type ; u8 reserved [ 3 ] ; struct acpi_generic_address debug_port ; } ;

struct acpi_table_dmar { struct acpi_table_header header ; u8 width ; u8 flags ; u8 reserved [ 10 ] ; } ;

struct acpi_dmar_header { u16 type ; u16 length ; } ;

enum acpi_dmar_type { ACPI_DMAR_TYPE_HARDWARE_UNIT = 0 , ACPI_DMAR_TYPE_RESERVED_MEMORY = 1 , ACPI_DMAR_TYPE_ATSR = 2 , ACPI_DMAR_HARDWARE_AFFINITY = 3 , ACPI_DMAR_TYPE_RESERVED = 4 } ;

struct acpi_dmar_device_scope { u8 entry_type ; u8 length ; u16 reserved ; u8 enumeration_id ; u8 bus ; } ;

enum acpi_dmar_scope_type { ACPI_DMAR_SCOPE_TYPE_NOT_USED = 0 , ACPI_DMAR_SCOPE_TYPE_ENDPOINT = 1 , ACPI_DMAR_SCOPE_TYPE_BRIDGE = 2 , ACPI_DMAR_SCOPE_TYPE_IOAPIC = 3 , ACPI_DMAR_SCOPE_TYPE_HPET = 4 , ACPI_DMAR_SCOPE_TYPE_RESERVED = 5 } ;

struct acpi_dmar_pci_path { u8 dev ; u8 fn ; } ;

struct acpi_dmar_hardware_unit { struct acpi_dmar_header header ; u8 flags ; u8 reserved ; u16 segment ; u64 address ; } ;

struct acpi_dmar_reserved_memory { struct acpi_dmar_header header ; u16 reserved ; u16 segment ; u64 base_address ; u64 end_address ; } ;

struct acpi_dmar_atsr { struct acpi_dmar_header header ; u8 flags ; u8 reserved ; u16 segment ; } ;

struct acpi_dmar_rhsa { struct acpi_dmar_header header ; u32 reserved ; u64 base_address ; u32 proximity_domain ; } ;

struct acpi_table_hpet { struct acpi_table_header header ; u32 id ; struct acpi_generic_address address ; u8 sequence ; u16 minimum_tick ; u8 flags ; } ;

enum acpi_hpet_page_protect { ACPI_HPET_NO_PAGE_PROTECT = 0 , ACPI_HPET_PAGE_PROTECT4 = 1 , ACPI_HPET_PAGE_PROTECT64 = 2 } ;

struct acpi_table_ibft { struct acpi_table_header header ; u8 reserved [ 12 ] ; } ;

struct acpi_ibft_header { u8 type ; u8 version ; u16 length ; u8 index ; u8 flags ; } ;

enum acpi_ibft_type { ACPI_IBFT_TYPE_NOT_USED = 0 , ACPI_IBFT_TYPE_CONTROL = 1 , ACPI_IBFT_TYPE_INITIATOR = 2 , ACPI_IBFT_TYPE_NIC = 3 , ACPI_IBFT_TYPE_TARGET = 4 , ACPI_IBFT_TYPE_EXTENSIONS = 5 , ACPI_IBFT_TYPE_RESERVED = 6 } ;

struct acpi_ibft_control { struct acpi_ibft_header header ; u16 extensions ; u16 initiator_offset ; u16 nic0_offset ; u16 target0_offset ; u16 nic1_offset ; u16 target1_offset ; } ;

struct acpi_ibft_initiator { struct acpi_ibft_header header ; u8 sns_server [ 16 ] ; u8 slp_server [ 16 ] ; u8 primary_server [ 16 ] ; u8 secondary_server [ 16 ] ; u16 name_length ; u16 name_offset ; } ;

struct acpi_ibft_nic { struct acpi_ibft_header header ; u8 ip_address [ 16 ] ; u8 subnet_mask_prefix ; u8 origin ; u8 gateway [ 16 ] ; u8 primary_dns [ 16 ] ; u8 secondary_dns [ 16 ] ; u8 dhcp [ 16 ] ; u16 vlan ; u8 mac_address [ 6 ] ; u16 pci_address ; u16 name_length ; u16 name_offset ; } ;

struct acpi_ibft_target { struct acpi_ibft_header header ; u8 target_ip_address [ 16 ] ; u16 target_ip_socket ; u8 target_boot_lun [ 8 ] ; u8 chap_type ; u8 nic_association ; u16 target_name_length ; u16 target_name_offset ; u16 chap_name_length ; u16 chap_name_offset ; u16 chap_secret_length ; u16 chap_secret_offset ; u16 reverse_chap_name_length ; u16 reverse_chap_name_offset ; u16 reverse_chap_secret_length ; u16 reverse_chap_secret_offset ; } ;

struct acpi_table_ivrs { struct acpi_table_header header ; u32 info ; u64 reserved ; } ;

struct acpi_ivrs_header { u8 type ; u8 flags ; u16 length ; u16 device_id ; } ;

enum acpi_ivrs_type { ACPI_IVRS_TYPE_HARDWARE = 0x10 , ACPI_IVRS_TYPE_MEMORY1 = 0x20 , ACPI_IVRS_TYPE_MEMORY2 = 0x21 , ACPI_IVRS_TYPE_MEMORY3 = 0x22 } ;

struct acpi_ivrs_hardware { struct acpi_ivrs_header header ; u16 capability_offset ; u64 base_address ; u16 pci_segment_group ; u16 info ; u32 reserved ; } ;

struct acpi_ivrs_de_header { u8 type ; u16 id ; u8 data_setting ; } ;

enum acpi_ivrs_device_entry_type { ACPI_IVRS_TYPE_PAD4 = 0 , ACPI_IVRS_TYPE_ALL = 1 , ACPI_IVRS_TYPE_SELECT = 2 , ACPI_IVRS_TYPE_START = 3 , ACPI_IVRS_TYPE_END = 4 , ACPI_IVRS_TYPE_PAD8 = 64 , ACPI_IVRS_TYPE_NOT_USED = 65 , ACPI_IVRS_TYPE_ALIAS_SELECT = 66 , ACPI_IVRS_TYPE_ALIAS_START = 67 , ACPI_IVRS_TYPE_EXT_SELECT = 70 , ACPI_IVRS_TYPE_EXT_START = 71 , ACPI_IVRS_TYPE_SPECIAL = 72 } ;

struct acpi_ivrs_device4 { struct acpi_ivrs_de_header header ; } ;

struct acpi_ivrs_device8a { struct acpi_ivrs_de_header header ; u8 reserved1 ; u16 used_id ; u8 reserved2 ; } ;

struct acpi_ivrs_device8b { struct acpi_ivrs_de_header header ; u32 extended_data ; } ;

struct acpi_ivrs_device8c { struct acpi_ivrs_de_header header ; u8 handle ; u16 used_id ; u8 variety ; } ;

struct acpi_ivrs_memory { struct acpi_ivrs_header header ; u16 aux_data ; u64 reserved ; u64 start_address ; u64 memory_length ; } ;

struct acpi_table_mcfg { struct acpi_table_header header ; u8 reserved [ 8 ] ; } ;

struct acpi_mcfg_allocation { u64 address ; u16 pci_segment ; u8 start_bus_number ; u8 end_bus_number ; u32 reserved ; } ;

struct acpi_table_spcr { struct acpi_table_header header ; u8 interface_type ; u8 reserved [ 3 ] ; struct acpi_generic_address serial_port ; u8 interrupt_type ; u8 pc_interrupt ; u32 interrupt ; u8 baud_rate ; u8 parity ; u8 stop_bits ; u8 flow_control ; u8 terminal_type ; u8 reserved1 ; u16 pci_device_id ; u16 pci_vendor_id ; u8 pci_bus ; u8 pci_device ; u8 pci_function ; u32 pci_flags ; u8 pci_segment ; u32 reserved2 ; } ;

struct acpi_table_spmi { struct acpi_table_header header ; u8 interface_type ; u8 reserved ; u16 spec_revision ; u8 interrupt_type ; u8 gpe_number ; u8 reserved1 ; u8 pci_device_flag ; u32 interrupt ; struct acpi_generic_address ipmi_register ; u8 pci_segment ; u8 pci_bus ; u8 pci_device ; u8 pci_function ; u8 reserved2 ; } ;

enum acpi_spmi_interface_types { ACPI_SPMI_NOT_USED = 0 , ACPI_SPMI_KEYBOARD = 1 , ACPI_SPMI_SMI = 2 , ACPI_SPMI_BLOCK_TRANSFER = 3 , ACPI_SPMI_SMBUS = 4 , ACPI_SPMI_RESERVED = 5 } ;

struct acpi_table_tcpa { struct acpi_table_header header ; u16 reserved ; u32 max_log_length ; u64 log_address ; } ;

struct acpi_table_uefi { struct acpi_table_header header ; u8 identifier [ 16 ] ; u16 data_offset ; } ;

struct acpi_table_waet { struct acpi_table_header header ; u32 flags ; } ;

struct acpi_table_wdat { struct acpi_table_header header ; u32 header_length ; u16 pci_segment ; u8 pci_bus ; u8 pci_device ; u8 pci_function ; u8 reserved [ 3 ] ; u32 timer_period ; u32 max_count ; u32 min_count ; u8 flags ; u8 reserved2 [ 3 ] ; u32 entries ; } ;

struct acpi_wdat_entry { u8 action ; u8 instruction ; u16 reserved ; struct acpi_generic_address register_region ; u32 value ; u32 mask ; } ;

enum acpi_wdat_actions { ACPI_WDAT_RESET = 1 , ACPI_WDAT_GET_CURRENT_COUNTDOWN = 4 , ACPI_WDAT_GET_COUNTDOWN = 5 , ACPI_WDAT_SET_COUNTDOWN = 6 , ACPI_WDAT_GET_RUNNING_STATE = 8 , ACPI_WDAT_SET_RUNNING_STATE = 9 , ACPI_WDAT_GET_STOPPED_STATE = 10 , ACPI_WDAT_SET_STOPPED_STATE = 11 , ACPI_WDAT_GET_REBOOT = 16 , ACPI_WDAT_SET_REBOOT = 17 , ACPI_WDAT_GET_SHUTDOWN = 18 , ACPI_WDAT_SET_SHUTDOWN = 19 , ACPI_WDAT_GET_STATUS = 32 , ACPI_WDAT_SET_STATUS = 33 , ACPI_WDAT_ACTION_RESERVED = 34 } ;

enum acpi_wdat_instructions { ACPI_WDAT_READ_VALUE = 0 , ACPI_WDAT_READ_COUNTDOWN = 1 , ACPI_WDAT_WRITE_VALUE = 2 , ACPI_WDAT_WRITE_COUNTDOWN = 3 , ACPI_WDAT_INSTRUCTION_RESERVED = 4 , ACPI_WDAT_PRESERVE_REGISTER = 0x80 } ;

struct acpi_table_wdrt { struct acpi_table_header header ; struct acpi_generic_address control_register ; struct acpi_generic_address count_register ; u16 pci_device_id ; u16 pci_vendor_id ; u8 pci_bus ; u8 pci_device ; u8 pci_function ; u8 pci_segment ; u16 max_count ; u8 units ; } ;

typedef u16 acpi_rs_length ;

typedef u32 acpi_rsdesc_size ;

struct acpi_uuid { u8 data [ 16 ] ; } ;

struct acpi_vendor_uuid { u8 subtype ; u8 data [ 16 ] ; } ;

struct acpi_resource_irq { u8 descriptor_length ; u8 triggering ; u8 polarity ; u8 sharable ; u8 interrupt_count ; u8 interrupts [ 1 ] ; } ;

struct acpi_resource_dma { u8 type ; u8 bus_master ; u8 transfer ; u8 channel_count ; u8 channels [ 1 ] ; } ;

struct acpi_resource_start_dependent { u8 descriptor_length ; u8 compatibility_priority ; u8 performance_robustness ; } ;

struct acpi_resource_io { u8 io_decode ; u8 alignment ; u8 address_length ; u16 minimum ; u16 maximum ; } ;

struct acpi_resource_fixed_io { u16 address ; u8 address_length ; } ;

struct acpi_resource_vendor { u16 byte_length ; u8 byte_data [ 1 ] ; } ;

struct acpi_resource_vendor_typed { u16 byte_length ; u8 uuid_subtype ; u8 uuid [ 16 ] ; u8 byte_data [ 1 ] ; } ;

struct acpi_resource_end_tag { u8 checksum ; } ;

struct acpi_resource_memory24 { u8 write_protect ; u16 minimum ; u16 maximum ; u16 alignment ; u16 address_length ; } ;

struct acpi_resource_memory32 { u8 write_protect ; u32 minimum ; u32 maximum ; u32 alignment ; u32 address_length ; } ;

struct acpi_resource_fixed_memory32 { u8 write_protect ; u32 address ; u32 address_length ; } ;

struct acpi_memory_attribute { u8 write_protect ; u8 caching ; u8 range_type ; u8 translation ; } ;

struct acpi_io_attribute { u8 range_type ; u8 translation ; u8 translation_type ; u8 reserved1 ; } ;

union acpi_resource_attribute { struct acpi_memory_attribute mem ; struct acpi_io_attribute io ; u8 type_specific ; } ;

struct acpi_resource_source { u8 index ; u16 string_length ; char * string_ptr ; } ;

struct acpi_resource_address { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; } ;

struct acpi_resource_address16 { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; u16 granularity ; u16 minimum ; u16 maximum ; u16 translation_offset ; u16 address_length ; struct acpi_resource_source resource_source ; } ;

struct acpi_resource_address32 { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; u32 granularity ; u32 minimum ; u32 maximum ; u32 translation_offset ; u32 address_length ; struct acpi_resource_source resource_source ; } ;

struct acpi_resource_address64 { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; u64 granularity ; u64 minimum ; u64 maximum ; u64 translation_offset ; u64 address_length ; struct acpi_resource_source resource_source ; } ;

struct acpi_resource_extended_address64 { u8 resource_type ; u8 producer_consumer ; u8 decode ; u8 min_address_fixed ; u8 max_address_fixed ; union acpi_resource_attribute info ; u8 revision_iD ; u64 granularity ; u64 minimum ; u64 maximum ; u64 translation_offset ; u64 address_length ; u64 type_specific ; } ;

struct acpi_resource_extended_irq { u8 producer_consumer ; u8 triggering ; u8 polarity ; u8 sharable ; u8 interrupt_count ; struct acpi_resource_source resource_source ; u32 interrupts [ 1 ] ; } ;

struct acpi_resource_generic_register { u8 space_id ; u8 bit_width ; u8 bit_offset ; u8 access_size ; u64 address ; } ;

union acpi_resource_data { struct acpi_resource_irq irq ; struct acpi_resource_dma dma ; struct acpi_resource_start_dependent start_dpf ; struct acpi_resource_io io ; struct acpi_resource_fixed_io fixed_io ; struct acpi_resource_vendor vendor ; struct acpi_resource_vendor_typed vendor_typed ; struct acpi_resource_end_tag end_tag ; struct acpi_resource_memory24 memory24 ; struct acpi_resource_memory32 memory32 ; struct acpi_resource_fixed_memory32 fixed_memory32 ; struct acpi_resource_address16 address16 ; struct acpi_resource_address32 address32 ; struct acpi_resource_address64 address64 ; struct acpi_resource_extended_address64 ext_address64 ; struct acpi_resource_extended_irq extended_irq ; struct acpi_resource_generic_register generic_reg ; struct acpi_resource_address address ; } ;

struct acpi_resource { u32 type ; u32 length ; union acpi_resource_data data ; } ;

struct acpi_pci_routing_table { u32 length ; u32 pin ; acpi_integer address ; u32 source_index ; char source [ 4 ] ; } ;

typedef enum { OSL_GLOBAL_LOCK_HANDLER , OSL_NOTIFY_HANDLER , OSL_GPE_HANDLER , OSL_DEBUGGER_THREAD , OSL_EC_POLL_HANDLER , OSL_EC_BURST_HANDLER } acpi_execute_type ;

struct acpi_signal_fatal_info { u32 type ; u32 code ; u32 argument ; } ;

typedef acpi_status ( * acpi_walk_resource_callback ) ( struct acpi_resource * resource , void * context ) ;
struct klist_node ;

struct klist { spinlock_t k_lock ; struct list_head k_list ; void ( * get ) ( struct klist_node * ) ; void ( * put ) ( struct klist_node * ) ; } __attribute__ ( ( aligned ( 4 ) ) ) ;
struct klist_node { void * n_klist ; struct list_head n_node ; struct kref n_ref ; } ;
struct klist_iter { struct klist * i_klist ; struct klist_node * i_cur ; } ;

struct dev_archdata { void * acpi_handle ; struct dma_map_ops * dma_ops ; } ;

struct pdev_archdata { } ;

struct device_private ;

struct driver_private ;

struct class ;

struct class_private ;

struct bus_type ;

struct bus_type_private ;

struct bus_attribute { struct attribute attr ; ssize_t ( * show ) ( struct bus_type * bus , char * buf ) ; ssize_t ( * store ) ( struct bus_type * bus , const char * buf , size_t count ) ; } ;

struct bus_type { const char * name ; struct bus_attribute * bus_attrs ; struct device_attribute * dev_attrs ; struct driver_attribute * drv_attrs ; int ( * match ) ( struct device * dev , struct device_driver * drv ) ; int ( * uevent ) ( struct device * dev , struct kobj_uevent_env * env ) ; int ( * probe ) ( struct device * dev ) ; int ( * remove ) ( struct device * dev ) ; void ( * shutdown ) ( struct device * dev ) ; int ( * suspend ) ( struct device * dev , pm_message_t state ) ; int ( * resume ) ( struct device * dev ) ; const struct dev_pm_ops * pm ; struct bus_type_private * p ; } ;
struct device_driver { const char * name ; struct bus_type * bus ; struct module * owner ; const char * mod_name ; bool suppress_bind_attrs ; int ( * probe ) ( struct device * dev ) ; int ( * remove ) ( struct device * dev ) ; void ( * shutdown ) ( struct device * dev ) ; int ( * suspend ) ( struct device * dev , pm_message_t state ) ; int ( * resume ) ( struct device * dev ) ; const struct attribute_group * * groups ; const struct dev_pm_ops * pm ; struct driver_private * p ; } ;
struct driver_attribute { struct attribute attr ; ssize_t ( * show ) ( struct device_driver * driver , char * buf ) ; ssize_t ( * store ) ( struct device_driver * driver , const char * buf , size_t count ) ; } ;

struct class { const char * name ; struct module * owner ; struct class_attribute * class_attrs ; struct device_attribute * dev_attrs ; struct kobject * dev_kobj ; int ( * dev_uevent ) ( struct device * dev , struct kobj_uevent_env * env ) ; char * ( * devnode ) ( struct device * dev , mode_t * mode ) ; void ( * class_release ) ( struct class * class ) ; void ( * dev_release ) ( struct device * dev ) ; int ( * suspend ) ( struct device * dev , pm_message_t state ) ; int ( * resume ) ( struct device * dev ) ; const struct dev_pm_ops * pm ; struct class_private * p ; } ;
struct class_dev_iter { struct klist_iter ki ; const struct device_type * type ; } ;

struct class_compat ;

struct class_attribute { struct attribute attr ; ssize_t ( * show ) ( struct class * class , char * buf ) ; ssize_t ( * store ) ( struct class * class , const char * buf , size_t count ) ; } ;

struct class_interface { struct list_head node ; struct class * class ; int ( * add_dev ) ( struct device * , struct class_interface * ) ; void ( * remove_dev ) ( struct device * , struct class_interface * ) ; } ;

struct device_type { const char * name ; const struct attribute_group * * groups ; int ( * uevent ) ( struct device * dev , struct kobj_uevent_env * env ) ; char * ( * devnode ) ( struct device * dev , mode_t * mode ) ; void ( * release ) ( struct device * dev ) ; const struct dev_pm_ops * pm ; } ;

struct device_attribute { struct attribute attr ; ssize_t ( * show ) ( struct device * dev , struct device_attribute * attr , char * buf ) ; ssize_t ( * store ) ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) ; } ;

typedef void ( * dr_release_t ) ( struct device * dev , void * res ) ;
typedef int ( * dr_match_t ) ( struct device * dev , void * res , void * match_data ) ;
struct device_dma_parameters { unsigned int max_segment_size ; unsigned long segment_boundary_mask ; } ;

struct device { struct device * parent ; struct device_private * p ; struct kobject kobj ; const char * init_name ; struct device_type * type ; struct semaphore sem ; struct bus_type * bus ; struct device_driver * driver ; void * platform_data ; struct dev_pm_info power ; int numa_node ; u64 * dma_mask ; u64 coherent_dma_mask ; struct device_dma_parameters * dma_parms ; struct list_head dma_pools ; struct dma_coherent_mem * dma_mem ; struct dev_archdata archdata ; dev_t devt ; spinlock_t devres_lock ; struct list_head devres_head ; struct klist_node knode_class ; struct class * class ; const struct attribute_group * * groups ; void ( * release ) ( struct device * dev ) ; } ;
struct acpi_handle_list { u32 count ; acpi_handle handles [ 10 ] ; } ;

enum acpi_bus_removal_type { ACPI_BUS_REMOVAL_NORMAL = 0 , ACPI_BUS_REMOVAL_EJECT , ACPI_BUS_REMOVAL_SUPRISE , ACPI_BUS_REMOVAL_TYPE_COUNT } ;

enum acpi_bus_device_type { ACPI_BUS_TYPE_DEVICE = 0 , ACPI_BUS_TYPE_POWER , ACPI_BUS_TYPE_PROCESSOR , ACPI_BUS_TYPE_THERMAL , ACPI_BUS_TYPE_POWER_BUTTON , ACPI_BUS_TYPE_SLEEP_BUTTON , ACPI_BUS_DEVICE_TYPE_COUNT } ;

struct acpi_driver ;

struct acpi_device ;

typedef int ( * acpi_op_add ) ( struct acpi_device * device ) ;
typedef int ( * acpi_op_remove ) ( struct acpi_device * device , int type ) ;
typedef int ( * acpi_op_start ) ( struct acpi_device * device ) ;
typedef int ( * acpi_op_suspend ) ( struct acpi_device * device , pm_message_t state ) ;
typedef int ( * acpi_op_resume ) ( struct acpi_device * device ) ;
typedef int ( * acpi_op_bind ) ( struct acpi_device * device ) ;
typedef int ( * acpi_op_unbind ) ( struct acpi_device * device ) ;
typedef void ( * acpi_op_notify ) ( struct acpi_device * device , u32 event ) ;
struct acpi_bus_ops { u32 acpi_op_add : 1 ; u32 acpi_op_start : 1 ; } ;

struct acpi_device_ops { acpi_op_add add ; acpi_op_remove remove ; acpi_op_start start ; acpi_op_suspend suspend ; acpi_op_resume resume ; acpi_op_bind bind ; acpi_op_unbind unbind ; acpi_op_notify notify ; } ;

struct acpi_driver { char name [ 80 ] ; char class [ 80 ] ; const struct acpi_device_id * ids ; unsigned int flags ; struct acpi_device_ops ops ; struct device_driver drv ; struct module * owner ; } ;
struct acpi_device_status { u32 present : 1 ; u32 enabled : 1 ; u32 show_in_ui : 1 ; u32 functional : 1 ; u32 battery_present : 1 ; u32 reserved : 27 ; } ;

struct acpi_device_flags { u32 dynamic_status : 1 ; u32 bus_address : 1 ; u32 removable : 1 ; u32 ejectable : 1 ; u32 lockable : 1 ; u32 suprise_removal_ok : 1 ; u32 power_manageable : 1 ; u32 performance_manageable : 1 ; u32 wake_capable : 1 ; u32 force_power_state : 1 ; u32 reserved : 22 ; } ;

struct acpi_device_dir { struct proc_dir_entry * entry ; } ;

typedef char acpi_bus_id [ 8 ] ;
typedef unsigned long acpi_bus_address ;

typedef char acpi_device_name [ 40 ] ;
typedef char acpi_device_class [ 20 ] ;
struct acpi_hardware_id { struct list_head list ; char * id ; } ;

struct acpi_device_pnp { acpi_bus_id bus_id ; acpi_bus_address bus_address ; char * unique_id ; struct list_head ids ; acpi_device_name device_name ; acpi_device_class device_class ; } ;

struct acpi_device_power_flags { u32 explicit_get : 1 ; u32 power_resources : 1 ; u32 inrush_current : 1 ; u32 power_removed : 1 ; u32 reserved : 28 ; } ;

struct acpi_device_power_state { struct { u8 valid : 1 ; u8 explicit_set : 1 ; u8 reserved : 6 ; } flags ; int power ; int latency ; struct acpi_handle_list resources ; } ;

struct acpi_device_power { int state ; struct acpi_device_power_flags flags ; struct acpi_device_power_state states [ 4 ] ; } ;

struct acpi_device_perf_flags { u8 reserved : 8 ; } ;

struct acpi_device_perf_state { struct { u8 valid : 1 ; u8 reserved : 7 ; } flags ; u8 power ; u8 performance ; int latency ; } ;

struct acpi_device_perf { int state ; struct acpi_device_perf_flags flags ; int state_count ; struct acpi_device_perf_state * states ; } ;

struct acpi_device_wakeup_flags { u8 valid : 1 ; u8 run_wake : 1 ; } ;

struct acpi_device_wakeup_state { u8 enabled : 1 ; } ;

struct acpi_device_wakeup { acpi_handle gpe_device ; acpi_integer gpe_number ; acpi_integer sleep_state ; struct acpi_handle_list resources ; struct acpi_device_wakeup_state state ; struct acpi_device_wakeup_flags flags ; int prepare_count ; } ;

struct acpi_device { int device_type ; acpi_handle handle ; struct acpi_device * parent ; struct list_head children ; struct list_head node ; struct list_head wakeup_list ; struct acpi_device_status status ; struct acpi_device_flags flags ; struct acpi_device_pnp pnp ; struct acpi_device_power power ; struct acpi_device_wakeup wakeup ; struct acpi_device_perf performance ; struct acpi_device_dir dir ; struct acpi_device_ops ops ; struct acpi_driver * driver ; void * driver_data ; struct device dev ; struct acpi_bus_ops bus_ops ; enum acpi_bus_removal_type removal_type ; } ;
struct acpi_bus_event { struct list_head node ; acpi_device_class device_class ; acpi_bus_id bus_id ; u32 type ; u32 data ; } ;

struct acpi_bus_type { struct list_head list ; struct bus_type * bus ; int ( * find_device ) ( struct device * , acpi_handle * ) ; int ( * find_bridge ) ( struct device * , acpi_handle * ) ; } ;

struct acpi_pci_root { struct list_head node ; struct acpi_device * device ; struct acpi_pci_id id ; struct pci_bus * bus ; u16 segment ; u8 bus_nr ; u32 osc_support_set ; u32 osc_control_set ; u32 osc_control_qry ; u32 osc_queried : 1 ; } ;

struct acpi_dock_ops { acpi_notify_handler handler ; acpi_notify_handler uevent ; } ;

enum acpi_irq_model_id { ACPI_IRQ_MODEL_PIC = 0 , ACPI_IRQ_MODEL_IOAPIC , ACPI_IRQ_MODEL_IOSAPIC , ACPI_IRQ_MODEL_PLATFORM , ACPI_IRQ_MODEL_COUNT } ;

enum acpi_interrupt_id { ACPI_INTERRUPT_PMI = 1 , ACPI_INTERRUPT_INIT , ACPI_INTERRUPT_CPEI , ACPI_INTERRUPT_COUNT } ;

enum acpi_address_range_id { ACPI_ADDRESS_RANGE_MEMORY = 1 , ACPI_ADDRESS_RANGE_RESERVED = 2 , ACPI_ADDRESS_RANGE_ACPI = 3 , ACPI_ADDRESS_RANGE_NVS = 4 , ACPI_ADDRESS_RANGE_COUNT } ;

typedef int ( * acpi_table_handler ) ( struct acpi_table_header * table ) ;
typedef int ( * acpi_table_entry_handler ) ( struct acpi_subtable_header * header , const unsigned long end ) ;
struct acpi_pci_driver { struct acpi_pci_driver * next ; int ( * add ) ( acpi_handle handle ) ; void ( * remove ) ( acpi_handle handle ) ; } ;

typedef void ( * wmi_notify_handler ) ( u32 value , void * context ) ;
struct acpi_osc_context { char * uuid_str ; int rev ; struct acpi_buffer cap ; struct acpi_buffer ret ; } ;

typedef unsigned char cc_t ;

typedef unsigned int speed_t ;

typedef unsigned int tcflag_t ;

struct termios { tcflag_t c_iflag ; tcflag_t c_oflag ; tcflag_t c_cflag ; tcflag_t c_lflag ; cc_t c_line ; cc_t c_cc [ 19 ] ; } ;

struct termios2 { tcflag_t c_iflag ; tcflag_t c_oflag ; tcflag_t c_cflag ; tcflag_t c_lflag ; cc_t c_line ; cc_t c_cc [ 19 ] ; speed_t c_ispeed ; speed_t c_ospeed ; } ;

struct ktermios { tcflag_t c_iflag ; tcflag_t c_oflag ; tcflag_t c_cflag ; tcflag_t c_lflag ; cc_t c_line ; cc_t c_cc [ 19 ] ; speed_t c_ispeed ; speed_t c_ospeed ; } ;

struct winsize { unsigned short ws_row ; unsigned short ws_col ; unsigned short ws_xpixel ; unsigned short ws_ypixel ; } ;

struct termio { unsigned short c_iflag ; unsigned short c_oflag ; unsigned short c_cflag ; unsigned short c_lflag ; unsigned char c_line ; unsigned char c_cc [ 8 ] ; } ;

struct termiox { __u16 x_hflag ; __u16 x_cflag ; __u16 x_rflag [ 5 ] ; __u16 x_sflag ; } ;

struct file_operations ;
struct cdev { struct kobject kobj ; struct module * owner ; const struct file_operations * ops ; struct list_head list ; dev_t dev ; unsigned int count ; } ;

struct tty_struct ;

struct tty_operations { struct tty_struct * ( * lookup ) ( struct tty_driver * driver , struct inode * inode , int idx ) ; int ( * install ) ( struct tty_driver * driver , struct tty_struct * tty ) ; void ( * remove ) ( struct tty_driver * driver , struct tty_struct * tty ) ; int ( * open ) ( struct tty_struct * tty , struct file * filp ) ; void ( * close ) ( struct tty_struct * tty , struct file * filp ) ; void ( * shutdown ) ( struct tty_struct * tty ) ; void ( * cleanup ) ( struct tty_struct * tty ) ; int ( * write ) ( struct tty_struct * tty , const unsigned char * buf , int count ) ; int ( * put_char ) ( struct tty_struct * tty , unsigned char ch ) ; void ( * flush_chars ) ( struct tty_struct * tty ) ; int ( * write_room ) ( struct tty_struct * tty ) ; int ( * chars_in_buffer ) ( struct tty_struct * tty ) ; int ( * ioctl ) ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) ; long ( * compat_ioctl ) ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) ; void ( * set_termios ) ( struct tty_struct * tty , struct ktermios * old ) ; void ( * throttle ) ( struct tty_struct * tty ) ; void ( * unthrottle ) ( struct tty_struct * tty ) ; void ( * stop ) ( struct tty_struct * tty ) ; void ( * start ) ( struct tty_struct * tty ) ; void ( * hangup ) ( struct tty_struct * tty ) ; int ( * break_ctl ) ( struct tty_struct * tty , int state ) ; void ( * flush_buffer ) ( struct tty_struct * tty ) ; void ( * set_ldisc ) ( struct tty_struct * tty ) ; void ( * wait_until_sent ) ( struct tty_struct * tty , int timeout ) ; void ( * send_xchar ) ( struct tty_struct * tty , char ch ) ; int ( * tiocmget ) ( struct tty_struct * tty , struct file * file ) ; int ( * tiocmset ) ( struct tty_struct * tty , struct file * file , unsigned int set , unsigned int clear ) ; int ( * resize ) ( struct tty_struct * tty , struct winsize * ws ) ; int ( * set_termiox ) ( struct tty_struct * tty , struct termiox * tnew ) ; int ( * poll_init ) ( struct tty_driver * driver , int line , char * options ) ; int ( * poll_get_char ) ( struct tty_driver * driver , int line ) ; void ( * poll_put_char ) ( struct tty_driver * driver , int line , char ch ) ; const struct file_operations * proc_fops ; } ;

struct tty_driver { int magic ; struct kref kref ; struct cdev cdev ; struct module * owner ; const char * driver_name ; const char * name ; int name_base ; int major ; int minor_start ; int minor_num ; int num ; short type ; short subtype ; struct ktermios init_termios ; int flags ; struct proc_dir_entry * proc_entry ; struct tty_driver * other ; struct tty_struct * * ttys ; struct ktermios * * termios ; struct ktermios * * termios_locked ; void * driver_state ; const struct tty_operations * ops ; struct list_head tty_drivers ; } ;
struct tty_ldisc_ops { int magic ; char * name ; int num ; int flags ; int ( * open ) ( struct tty_struct * ) ; void ( * close ) ( struct tty_struct * ) ; void ( * flush_buffer ) ( struct tty_struct * tty ) ; ssize_t ( * chars_in_buffer ) ( struct tty_struct * tty ) ; ssize_t ( * read ) ( struct tty_struct * tty , struct file * file , unsigned char * buf , size_t nr ) ; ssize_t ( * write ) ( struct tty_struct * tty , struct file * file , const unsigned char * buf , size_t nr ) ; int ( * ioctl ) ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) ; long ( * compat_ioctl ) ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) ; void ( * set_termios ) ( struct tty_struct * tty , struct ktermios * old ) ; unsigned int ( * poll ) ( struct tty_struct * , struct file * , struct poll_table_struct * ) ; int ( * hangup ) ( struct tty_struct * tty ) ; void ( * receive_buf ) ( struct tty_struct * , const unsigned char * cp , char * fp , int count ) ; void ( * write_wakeup ) ( struct tty_struct * ) ; struct module * owner ; int refcount ; } ;

struct tty_ldisc { struct tty_ldisc_ops * ops ; atomic_t users ; } ;

struct tty_buffer { struct tty_buffer * next ; char * char_buf_ptr ; unsigned char * flag_buf_ptr ; int used ; int size ; int commit ; int read ; unsigned long data [ 0 ] ; } ;

struct tty_bufhead { struct delayed_work work ; spinlock_t lock ; struct tty_buffer * head ; struct tty_buffer * tail ; struct tty_buffer * free ; int memory_used ; } ;

struct tty_port ;

struct tty_port_operations { int ( * carrier_raised ) ( struct tty_port * port ) ; void ( * dtr_rts ) ( struct tty_port * port , int raise ) ; void ( * shutdown ) ( struct tty_port * port ) ; void ( * drop ) ( struct tty_port * port ) ; } ;

struct tty_port { struct tty_struct * tty ; const struct tty_port_operations * ops ; spinlock_t lock ; int blocked_open ; int count ; wait_queue_head_t open_wait ; wait_queue_head_t close_wait ; wait_queue_head_t delta_msr_wait ; unsigned long flags ; struct mutex mutex ; unsigned char * xmit_buf ; unsigned int close_delay ; unsigned int closing_wait ; int drain_delay ; } ;
struct tty_operations ;
struct tty_struct { int magic ; struct kref kref ; struct tty_driver * driver ; const struct tty_operations * ops ; int index ; struct mutex ldisc_mutex ; struct tty_ldisc * ldisc ; struct mutex termios_mutex ; spinlock_t ctrl_lock ; struct ktermios * termios , * termios_locked ; struct termiox * termiox ; char name [ 64 ] ; struct pid * pgrp ; struct pid * session ; unsigned long flags ; int count ; struct winsize winsize ; unsigned char stopped : 1 , hw_stopped : 1 , flow_stopped : 1 , packet : 1 ; unsigned char low_latency : 1 , warned : 1 ; unsigned char ctrl_status ; unsigned int receive_room ; struct tty_struct * link ; struct fasync_struct * fasync ; struct tty_bufhead buf ; int alt_speed ; wait_queue_head_t write_wait ; wait_queue_head_t read_wait ; struct work_struct hangup_work ; void * disc_data ; void * driver_data ; struct list_head tty_files ; unsigned int column ; unsigned char lnext : 1 , erasing : 1 , raw : 1 , real_raw : 1 , icanon : 1 ; unsigned char closing : 1 ; unsigned char echo_overrun : 1 ; unsigned short minimum_to_wake ; unsigned long overrun_time ; int num_overrun ; unsigned long process_char_map [ 256 / ( 8 * sizeof ( unsigned long ) ) ] ; char * read_buf ; int read_head ; int read_tail ; int read_cnt ; unsigned long read_flags [ 4096 / ( 8 * sizeof ( unsigned long ) ) ] ; unsigned char * echo_buf ; unsigned int echo_pos ; unsigned int echo_cnt ; int canon_data ; unsigned long canon_head ; unsigned int canon_column ; struct mutex atomic_read_lock ; struct mutex atomic_write_lock ; struct mutex output_lock ; struct mutex echo_lock ; unsigned char * write_buf ; int write_cnt ; spinlock_t read_lock ; struct work_struct SAK_work ; struct tty_port * port ; } ;
struct linux_binprm { char buf [ 128 ] ; struct vm_area_struct * vma ; struct mm_struct * mm ; unsigned long p ; unsigned int cred_prepared : 1 , cap_effective : 1 ; unsigned int recursion_depth ; struct file * file ; struct cred * cred ; int unsafe ; unsigned int per_clear ; int argc , envc ; char * filename ; char * interp ; unsigned interp_flags ; unsigned interp_data ; unsigned long loader , exec ; } ;
struct linux_binfmt { struct list_head lh ; struct module * module ; int ( * load_binary ) ( struct linux_binprm * , struct pt_regs * regs ) ; int ( * load_shlib ) ( struct file * ) ; int ( * core_dump ) ( long signr , struct pt_regs * regs , struct file * file , unsigned long limit ) ; unsigned long min_coredump ; int hasvdso ; } ;

struct shmid_ds { struct ipc_perm shm_perm ; int shm_segsz ; __kernel_time_t shm_atime ; __kernel_time_t shm_dtime ; __kernel_time_t shm_ctime ; __kernel_ipc_pid_t shm_cpid ; __kernel_ipc_pid_t shm_lpid ; unsigned short shm_nattch ; unsigned short shm_unused ; void * shm_unused2 ; void * shm_unused3 ; } ;
struct shmid64_ds { struct ipc64_perm shm_perm ; size_t shm_segsz ; __kernel_time_t shm_atime ; __kernel_time_t shm_dtime ; __kernel_time_t shm_ctime ; __kernel_pid_t shm_cpid ; __kernel_pid_t shm_lpid ; unsigned long shm_nattch ; unsigned long __unused4 ; unsigned long __unused5 ; } ;

struct shminfo64 { unsigned long shmmax ; unsigned long shmmin ; unsigned long shmmni ; unsigned long shmseg ; unsigned long shmall ; unsigned long __unused1 ; unsigned long __unused2 ; unsigned long __unused3 ; unsigned long __unused4 ; } ;

struct shminfo { int shmmax ; int shmmin ; int shmmni ; int shmseg ; int shmall ; } ;

struct shm_info { int used_ids ; unsigned long shm_tot ; unsigned long shm_rss ; unsigned long shm_swp ; unsigned long swap_attempts ; unsigned long swap_successes ; } ;

struct shmid_kernel { struct kern_ipc_perm shm_perm ; struct file * shm_file ; unsigned long shm_nattch ; unsigned long shm_segsz ; time_t shm_atim ; time_t shm_dtim ; time_t shm_ctim ; pid_t shm_cprid ; pid_t shm_lprid ; struct user_struct * mlock_user ; } ;

struct msqid_ds { struct ipc_perm msg_perm ; struct msg * msg_first ; struct msg * msg_last ; __kernel_time_t msg_stime ; __kernel_time_t msg_rtime ; __kernel_time_t msg_ctime ; unsigned long msg_lcbytes ; unsigned long msg_lqbytes ; unsigned short msg_cbytes ; unsigned short msg_qnum ; unsigned short msg_qbytes ; __kernel_ipc_pid_t msg_lspid ; __kernel_ipc_pid_t msg_lrpid ; } ;
struct msqid64_ds { struct ipc64_perm msg_perm ; __kernel_time_t msg_stime ; __kernel_time_t msg_rtime ; __kernel_time_t msg_ctime ; unsigned long msg_cbytes ; unsigned long msg_qnum ; unsigned long msg_qbytes ; __kernel_pid_t msg_lspid ; __kernel_pid_t msg_lrpid ; unsigned long __unused4 ; unsigned long __unused5 ; } ;

struct msgbuf { long mtype ; char mtext [ 1 ] ; } ;
struct msginfo { int msgpool ; int msgmap ; int msgmax ; int msgmnb ; int msgmni ; int msgssz ; int msgtql ; unsigned short msgseg ; } ;

struct msg_msg { struct list_head m_list ; long m_type ; int m_ts ; struct msg_msgseg * next ; void * security ; } ;

struct msg_queue { struct kern_ipc_perm q_perm ; time_t q_stime ; time_t q_rtime ; time_t q_ctime ; unsigned long q_cbytes ; unsigned long q_qnum ; unsigned long q_qbytes ; pid_t q_lspid ; pid_t q_lrpid ; struct list_head q_messages ; struct list_head q_receivers ; struct list_head q_senders ; } ;

typedef union { __be32 a4 ; __be32 a6 [ 4 ] ; } xfrm_address_t ;

struct xfrm_id { xfrm_address_t daddr ; __be32 spi ; __u8 proto ; } ;

struct xfrm_sec_ctx { __u8 ctx_doi ; __u8 ctx_alg ; __u16 ctx_len ; __u32 ctx_sid ; char ctx_str [ 0 ] ; } ;

struct xfrm_selector { xfrm_address_t daddr ; xfrm_address_t saddr ; __be16 dport ; __be16 dport_mask ; __be16 sport ; __be16 sport_mask ; __u16 family ; __u8 prefixlen_d ; __u8 prefixlen_s ; __u8 proto ; int ifindex ; __kernel_uid32_t user ; } ;

struct xfrm_lifetime_cfg { __u64 soft_byte_limit ; __u64 hard_byte_limit ; __u64 soft_packet_limit ; __u64 hard_packet_limit ; __u64 soft_add_expires_seconds ; __u64 hard_add_expires_seconds ; __u64 soft_use_expires_seconds ; __u64 hard_use_expires_seconds ; } ;

struct xfrm_lifetime_cur { __u64 bytes ; __u64 packets ; __u64 add_time ; __u64 use_time ; } ;

struct xfrm_replay_state { __u32 oseq ; __u32 seq ; __u32 bitmap ; } ;

struct xfrm_algo { char alg_name [ 64 ] ; unsigned int alg_key_len ; char alg_key [ 0 ] ; } ;

struct xfrm_algo_aead { char alg_name [ 64 ] ; unsigned int alg_key_len ; unsigned int alg_icv_len ; char alg_key [ 0 ] ; } ;

struct xfrm_stats { __u32 replay_window ; __u32 replay ; __u32 integrity_failed ; } ;

enum { XFRM_POLICY_TYPE_MAIN = 0 , XFRM_POLICY_TYPE_SUB = 1 , XFRM_POLICY_TYPE_MAX = 2 , XFRM_POLICY_TYPE_ANY = 255 } ;
enum { XFRM_POLICY_IN = 0 , XFRM_POLICY_OUT = 1 , XFRM_POLICY_FWD = 2 , XFRM_POLICY_MASK = 3 , XFRM_POLICY_MAX = 3 } ;
enum { XFRM_SHARE_ANY , XFRM_SHARE_SESSION , XFRM_SHARE_USER , XFRM_SHARE_UNIQUE } ;
enum { XFRM_MSG_BASE = 0x10 , XFRM_MSG_NEWSA = 0x10 , XFRM_MSG_DELSA , XFRM_MSG_GETSA , XFRM_MSG_NEWPOLICY , XFRM_MSG_DELPOLICY , XFRM_MSG_GETPOLICY , XFRM_MSG_ALLOCSPI , XFRM_MSG_ACQUIRE , XFRM_MSG_EXPIRE , XFRM_MSG_UPDPOLICY , XFRM_MSG_UPDSA , XFRM_MSG_POLEXPIRE , XFRM_MSG_FLUSHSA , XFRM_MSG_FLUSHPOLICY , XFRM_MSG_NEWAE , XFRM_MSG_GETAE , XFRM_MSG_REPORT , XFRM_MSG_MIGRATE , XFRM_MSG_NEWSADINFO , XFRM_MSG_GETSADINFO , XFRM_MSG_NEWSPDINFO , XFRM_MSG_GETSPDINFO , XFRM_MSG_MAPPING , __XFRM_MSG_MAX } ;
struct xfrm_user_sec_ctx { __u16 len ; __u16 exttype ; __u8 ctx_alg ; __u8 ctx_doi ; __u16 ctx_len ; } ;

struct xfrm_user_tmpl { struct xfrm_id id ; __u16 family ; xfrm_address_t saddr ; __u32 reqid ; __u8 mode ; __u8 share ; __u8 optional ; __u32 aalgos ; __u32 ealgos ; __u32 calgos ; } ;

struct xfrm_encap_tmpl { __u16 encap_type ; __be16 encap_sport ; __be16 encap_dport ; xfrm_address_t encap_oa ; } ;

enum xfrm_ae_ftype_t { XFRM_AE_UNSPEC , XFRM_AE_RTHR = 1 , XFRM_AE_RVAL = 2 , XFRM_AE_LVAL = 4 , XFRM_AE_ETHR = 8 , XFRM_AE_CR = 16 , XFRM_AE_CE = 32 , XFRM_AE_CU = 64 , __XFRM_AE_MAX } ;

struct xfrm_userpolicy_type { __u8 type ; __u16 reserved1 ; __u8 reserved2 ; } ;

enum xfrm_attr_type_t { XFRMA_UNSPEC , XFRMA_ALG_AUTH , XFRMA_ALG_CRYPT , XFRMA_ALG_COMP , XFRMA_ENCAP , XFRMA_TMPL , XFRMA_SA , XFRMA_POLICY , XFRMA_SEC_CTX , XFRMA_LTIME_VAL , XFRMA_REPLAY_VAL , XFRMA_REPLAY_THRESH , XFRMA_ETIMER_THRESH , XFRMA_SRCADDR , XFRMA_COADDR , XFRMA_LASTUSED , XFRMA_POLICY_TYPE , XFRMA_MIGRATE , XFRMA_ALG_AEAD , XFRMA_KMADDRESS , __XFRMA_MAX } ;

enum xfrm_sadattr_type_t { XFRMA_SAD_UNSPEC , XFRMA_SAD_CNT , XFRMA_SAD_HINFO , __XFRMA_SAD_MAX } ;

struct xfrmu_sadhinfo { __u32 sadhcnt ; __u32 sadhmcnt ; } ;

enum xfrm_spdattr_type_t { XFRMA_SPD_UNSPEC , XFRMA_SPD_INFO , XFRMA_SPD_HINFO , __XFRMA_SPD_MAX } ;

struct xfrmu_spdinfo { __u32 incnt ; __u32 outcnt ; __u32 fwdcnt ; __u32 inscnt ; __u32 outscnt ; __u32 fwdscnt ; } ;

struct xfrmu_spdhinfo { __u32 spdhcnt ; __u32 spdhmcnt ; } ;

struct xfrm_usersa_info { struct xfrm_selector sel ; struct xfrm_id id ; xfrm_address_t saddr ; struct xfrm_lifetime_cfg lft ; struct xfrm_lifetime_cur curlft ; struct xfrm_stats stats ; __u32 seq ; __u32 reqid ; __u16 family ; __u8 mode ; __u8 replay_window ; __u8 flags ; } ;

struct xfrm_usersa_id { xfrm_address_t daddr ; __be32 spi ; __u16 family ; __u8 proto ; } ;

struct xfrm_aevent_id { struct xfrm_usersa_id sa_id ; xfrm_address_t saddr ; __u32 flags ; __u32 reqid ; } ;

struct xfrm_userspi_info { struct xfrm_usersa_info info ; __u32 min ; __u32 max ; } ;

struct xfrm_userpolicy_info { struct xfrm_selector sel ; struct xfrm_lifetime_cfg lft ; struct xfrm_lifetime_cur curlft ; __u32 priority ; __u32 index ; __u8 dir ; __u8 action ; __u8 flags ; __u8 share ; } ;

struct xfrm_userpolicy_id { struct xfrm_selector sel ; __u32 index ; __u8 dir ; } ;

struct xfrm_user_acquire { struct xfrm_id id ; xfrm_address_t saddr ; struct xfrm_selector sel ; struct xfrm_userpolicy_info policy ; __u32 aalgos ; __u32 ealgos ; __u32 calgos ; __u32 seq ; } ;

struct xfrm_user_expire { struct xfrm_usersa_info state ; __u8 hard ; } ;

struct xfrm_user_polexpire { struct xfrm_userpolicy_info pol ; __u8 hard ; } ;

struct xfrm_usersa_flush { __u8 proto ; } ;

struct xfrm_user_report { __u8 proto ; struct xfrm_selector sel ; } ;

struct xfrm_user_kmaddress { xfrm_address_t local ; xfrm_address_t remote ; __u32 reserved ; __u16 family ; } ;

struct xfrm_user_migrate { xfrm_address_t old_daddr ; xfrm_address_t old_saddr ; xfrm_address_t new_daddr ; xfrm_address_t new_saddr ; __u8 proto ; __u8 mode ; __u16 reserved ; __u32 reqid ; __u16 old_family ; __u16 new_family ; } ;

struct xfrm_user_mapping { struct xfrm_usersa_id id ; __u32 reqid ; xfrm_address_t old_saddr ; xfrm_address_t new_saddr ; __be16 old_sport ; __be16 new_sport ; } ;

enum xfrm_nlgroups { XFRMNLGRP_NONE , XFRMNLGRP_ACQUIRE , XFRMNLGRP_EXPIRE , XFRMNLGRP_SA , XFRMNLGRP_POLICY , XFRMNLGRP_AEVENTS , XFRMNLGRP_REPORT , XFRMNLGRP_MIGRATE , XFRMNLGRP_MAPPING , __XFRMNLGRP_MAX } ;

struct in6_addr { union { __u8 u6_addr8 [ 16 ] ; __be16 u6_addr16 [ 8 ] ; __be32 u6_addr32 [ 4 ] ; } in6_u ; } ;
struct sockaddr_in6 { unsigned short int sin6_family ; __be16 sin6_port ; __be32 sin6_flowinfo ; struct in6_addr sin6_addr ; __u32 sin6_scope_id ; } ;
struct ipv6_mreq { struct in6_addr ipv6mr_multiaddr ; int ipv6mr_ifindex ; } ;
struct in6_flowlabel_req { struct in6_addr flr_dst ; __be32 flr_label ; __u8 flr_action ; __u8 flr_share ; __u16 flr_flags ; __u16 flr_expires ; __u16 flr_linger ; __u32 __flr_pad ; } ;

struct flowi { int oif ; int iif ; __u32 mark ; union { struct { __be32 daddr ; __be32 saddr ; __u8 tos ; __u8 scope ; } ip4_u ; struct { struct in6_addr daddr ; struct in6_addr saddr ; __be32 flowlabel ; } ip6_u ; struct { __le16 daddr ; __le16 saddr ; __u8 scope ; } dn_u ; } nl_u ; __u8 proto ; __u8 flags ; union { struct { __be16 sport ; __be16 dport ; } ports ; struct { __u8 type ; __u8 code ; } icmpt ; struct { __le16 sport ; __le16 dport ; } dnports ; __be32 spi ; struct { __u8 type ; } mht ; } uli_u ; __u32 secid ; } __attribute__ ( ( __aligned__ ( 64 / 8 ) ) ) ;
struct sock ;

typedef int ( * flow_resolve_t ) ( struct net * net , struct flowi * key , u16 family , u8 dir , void * * objp , atomic_t * * obj_refp ) ;
struct audit_krule ;

struct sk_buff ;

struct socket ;

struct flowi ;

struct dst_entry ;

struct xfrm_selector ;
struct xfrm_policy ;

struct xfrm_state ;

struct xfrm_user_sec_ctx ;
struct request_sock ;

struct security_mnt_opts { char * * mnt_opts ; int * mnt_opts_flags ; int num_mnt_opts ; } ;

struct security_operations { char name [ 10 + 1 ] ; int ( * ptrace_access_check ) ( struct task_struct * child , unsigned int mode ) ; int ( * ptrace_traceme ) ( struct task_struct * parent ) ; int ( * capget ) ( struct task_struct * target , kernel_cap_t * effective , kernel_cap_t * inheritable , kernel_cap_t * permitted ) ; int ( * capset ) ( struct cred * new , const struct cred * old , const kernel_cap_t * effective , const kernel_cap_t * inheritable , const kernel_cap_t * permitted ) ; int ( * capable ) ( struct task_struct * tsk , const struct cred * cred , int cap , int audit ) ; int ( * acct ) ( struct file * file ) ; int ( * sysctl ) ( struct ctl_table * table , int op ) ; int ( * quotactl ) ( int cmds , int type , int id , struct super_block * sb ) ; int ( * quota_on ) ( struct dentry * dentry ) ; int ( * syslog ) ( int type , bool from_file ) ; int ( * settime ) ( struct timespec * ts , struct timezone * tz ) ; int ( * vm_enough_memory ) ( struct mm_struct * mm , long pages ) ; int ( * bprm_set_creds ) ( struct linux_binprm * bprm ) ; int ( * bprm_check_security ) ( struct linux_binprm * bprm ) ; int ( * bprm_secureexec ) ( struct linux_binprm * bprm ) ; void ( * bprm_committing_creds ) ( struct linux_binprm * bprm ) ; void ( * bprm_committed_creds ) ( struct linux_binprm * bprm ) ; int ( * sb_alloc_security ) ( struct super_block * sb ) ; void ( * sb_free_security ) ( struct super_block * sb ) ; int ( * sb_copy_data ) ( char * orig , char * copy ) ; int ( * sb_kern_mount ) ( struct super_block * sb , int flags , void * data ) ; int ( * sb_show_options ) ( struct seq_file * m , struct super_block * sb ) ; int ( * sb_statfs ) ( struct dentry * dentry ) ; int ( * sb_mount ) ( char * dev_name , struct path * path , char * type , unsigned long flags , void * data ) ; int ( * sb_check_sb ) ( struct vfsmount * mnt , struct path * path ) ; int ( * sb_umount ) ( struct vfsmount * mnt , int flags ) ; void ( * sb_umount_close ) ( struct vfsmount * mnt ) ; void ( * sb_umount_busy ) ( struct vfsmount * mnt ) ; void ( * sb_post_remount ) ( struct vfsmount * mnt , unsigned long flags , void * data ) ; void ( * sb_post_addmount ) ( struct vfsmount * mnt , struct path * mountpoint ) ; int ( * sb_pivotroot ) ( struct path * old_path , struct path * new_path ) ; void ( * sb_post_pivotroot ) ( struct path * old_path , struct path * new_path ) ; int ( * sb_set_mnt_opts ) ( struct super_block * sb , struct security_mnt_opts * opts ) ; void ( * sb_clone_mnt_opts ) ( const struct super_block * oldsb , struct super_block * newsb ) ; int ( * sb_parse_opts_str ) ( char * options , struct security_mnt_opts * opts ) ; int ( * path_unlink ) ( struct path * dir , struct dentry * dentry ) ; int ( * path_mkdir ) ( struct path * dir , struct dentry * dentry , int mode ) ; int ( * path_rmdir ) ( struct path * dir , struct dentry * dentry ) ; int ( * path_mknod ) ( struct path * dir , struct dentry * dentry , int mode , unsigned int dev ) ; int ( * path_truncate ) ( struct path * path , loff_t length , unsigned int time_attrs ) ; int ( * path_symlink ) ( struct path * dir , struct dentry * dentry , const char * old_name ) ; int ( * path_link ) ( struct dentry * old_dentry , struct path * new_dir , struct dentry * new_dentry ) ; int ( * path_rename ) ( struct path * old_dir , struct dentry * old_dentry , struct path * new_dir , struct dentry * new_dentry ) ; int ( * path_chmod ) ( struct dentry * dentry , struct vfsmount * mnt , mode_t mode ) ; int ( * path_chown ) ( struct path * path , uid_t uid , gid_t gid ) ; int ( * path_chroot ) ( struct path * path ) ; int ( * inode_alloc_security ) ( struct inode * inode ) ; void ( * inode_free_security ) ( struct inode * inode ) ; int ( * inode_init_security ) ( struct inode * inode , struct inode * dir , char * * name , void * * value , size_t * len ) ; int ( * inode_create ) ( struct inode * dir , struct dentry * dentry , int mode ) ; int ( * inode_link ) ( struct dentry * old_dentry , struct inode * dir , struct dentry * new_dentry ) ; int ( * inode_unlink ) ( struct inode * dir , struct dentry * dentry ) ; int ( * inode_symlink ) ( struct inode * dir , struct dentry * dentry , const char * old_name ) ; int ( * inode_mkdir ) ( struct inode * dir , struct dentry * dentry , int mode ) ; int ( * inode_rmdir ) ( struct inode * dir , struct dentry * dentry ) ; int ( * inode_mknod ) ( struct inode * dir , struct dentry * dentry , int mode , dev_t dev ) ; int ( * inode_rename ) ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) ; int ( * inode_readlink ) ( struct dentry * dentry ) ; int ( * inode_follow_link ) ( struct dentry * dentry , struct nameidata * nd ) ; int ( * inode_permission ) ( struct inode * inode , int mask ) ; int ( * inode_setattr ) ( struct dentry * dentry , struct iattr * attr ) ; int ( * inode_getattr ) ( struct vfsmount * mnt , struct dentry * dentry ) ; void ( * inode_delete ) ( struct inode * inode ) ; int ( * inode_setxattr ) ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ; void ( * inode_post_setxattr ) ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ; int ( * inode_getxattr ) ( struct dentry * dentry , const char * name ) ; int ( * inode_listxattr ) ( struct dentry * dentry ) ; int ( * inode_removexattr ) ( struct dentry * dentry , const char * name ) ; int ( * inode_need_killpriv ) ( struct dentry * dentry ) ; int ( * inode_killpriv ) ( struct dentry * dentry ) ; int ( * inode_getsecurity ) ( const struct inode * inode , const char * name , void * * buffer , bool alloc ) ; int ( * inode_setsecurity ) ( struct inode * inode , const char * name , const void * value , size_t size , int flags ) ; int ( * inode_listsecurity ) ( struct inode * inode , char * buffer , size_t buffer_size ) ; void ( * inode_getsecid ) ( const struct inode * inode , u32 * secid ) ; int ( * file_permission ) ( struct file * file , int mask ) ; int ( * file_alloc_security ) ( struct file * file ) ; void ( * file_free_security ) ( struct file * file ) ; int ( * file_ioctl ) ( struct file * file , unsigned int cmd , unsigned long arg ) ; int ( * file_mmap ) ( struct file * file , unsigned long reqprot , unsigned long prot , unsigned long flags , unsigned long addr , unsigned long addr_only ) ; int ( * file_mprotect ) ( struct vm_area_struct * vma , unsigned long reqprot , unsigned long prot ) ; int ( * file_lock ) ( struct file * file , unsigned int cmd ) ; int ( * file_fcntl ) ( struct file * file , unsigned int cmd , unsigned long arg ) ; int ( * file_set_fowner ) ( struct file * file ) ; int ( * file_send_sigiotask ) ( struct task_struct * tsk , struct fown_struct * fown , int sig ) ; int ( * file_receive ) ( struct file * file ) ; int ( * dentry_open ) ( struct file * file , const struct cred * cred ) ; int ( * task_create ) ( unsigned long clone_flags ) ; int ( * cred_alloc_blank ) ( struct cred * cred , gfp_t gfp ) ; void ( * cred_free ) ( struct cred * cred ) ; int ( * cred_prepare ) ( struct cred * new , const struct cred * old , gfp_t gfp ) ; void ( * cred_commit ) ( struct cred * new , const struct cred * old ) ; void ( * cred_transfer ) ( struct cred * new , const struct cred * old ) ; int ( * kernel_act_as ) ( struct cred * new , u32 secid ) ; int ( * kernel_create_files_as ) ( struct cred * new , struct inode * inode ) ; int ( * kernel_module_request ) ( void ) ; int ( * task_setuid ) ( uid_t id0 , uid_t id1 , uid_t id2 , int flags ) ; int ( * task_fix_setuid ) ( struct cred * new , const struct cred * old , int flags ) ; int ( * task_setgid ) ( gid_t id0 , gid_t id1 , gid_t id2 , int flags ) ; int ( * task_setpgid ) ( struct task_struct * p , pid_t pgid ) ; int ( * task_getpgid ) ( struct task_struct * p ) ; int ( * task_getsid ) ( struct task_struct * p ) ; void ( * task_getsecid ) ( struct task_struct * p , u32 * secid ) ; int ( * task_setgroups ) ( struct group_info * group_info ) ; int ( * task_setnice ) ( struct task_struct * p , int nice ) ; int ( * task_setioprio ) ( struct task_struct * p , int ioprio ) ; int ( * task_getioprio ) ( struct task_struct * p ) ; int ( * task_setrlimit ) ( unsigned int resource , struct rlimit * new_rlim ) ; int ( * task_setscheduler ) ( struct task_struct * p , int policy , struct sched_param * lp ) ; int ( * task_getscheduler ) ( struct task_struct * p ) ; int ( * task_movememory ) ( struct task_struct * p ) ; int ( * task_kill ) ( struct task_struct * p , struct siginfo * info , int sig , u32 secid ) ; int ( * task_wait ) ( struct task_struct * p ) ; int ( * task_prctl ) ( int option , unsigned long arg2 , unsigned long arg3 , unsigned long arg4 , unsigned long arg5 ) ; void ( * task_to_inode ) ( struct task_struct * p , struct inode * inode ) ; int ( * ipc_permission ) ( struct kern_ipc_perm * ipcp , short flag ) ; void ( * ipc_getsecid ) ( struct kern_ipc_perm * ipcp , u32 * secid ) ; int ( * msg_msg_alloc_security ) ( struct msg_msg * msg ) ; void ( * msg_msg_free_security ) ( struct msg_msg * msg ) ; int ( * msg_queue_alloc_security ) ( struct msg_queue * msq ) ; void ( * msg_queue_free_security ) ( struct msg_queue * msq ) ; int ( * msg_queue_associate ) ( struct msg_queue * msq , int msqflg ) ; int ( * msg_queue_msgctl ) ( struct msg_queue * msq , int cmd ) ; int ( * msg_queue_msgsnd ) ( struct msg_queue * msq , struct msg_msg * msg , int msqflg ) ; int ( * msg_queue_msgrcv ) ( struct msg_queue * msq , struct msg_msg * msg , struct task_struct * target , long type , int mode ) ; int ( * shm_alloc_security ) ( struct shmid_kernel * shp ) ; void ( * shm_free_security ) ( struct shmid_kernel * shp ) ; int ( * shm_associate ) ( struct shmid_kernel * shp , int shmflg ) ; int ( * shm_shmctl ) ( struct shmid_kernel * shp , int cmd ) ; int ( * shm_shmat ) ( struct shmid_kernel * shp , char * shmaddr , int shmflg ) ; int ( * sem_alloc_security ) ( struct sem_array * sma ) ; void ( * sem_free_security ) ( struct sem_array * sma ) ; int ( * sem_associate ) ( struct sem_array * sma , int semflg ) ; int ( * sem_semctl ) ( struct sem_array * sma , int cmd ) ; int ( * sem_semop ) ( struct sem_array * sma , struct sembuf * sops , unsigned nsops , int alter ) ; int ( * netlink_send ) ( struct sock * sk , struct sk_buff * skb ) ; int ( * netlink_recv ) ( struct sk_buff * skb , int cap ) ; void ( * d_instantiate ) ( struct dentry * dentry , struct inode * inode ) ; int ( * getprocattr ) ( struct task_struct * p , char * name , char * * value ) ; int ( * setprocattr ) ( struct task_struct * p , char * name , void * value , size_t size ) ; int ( * secid_to_secctx ) ( u32 secid , char * * secdata , u32 * seclen ) ; int ( * secctx_to_secid ) ( const char * secdata , u32 seclen , u32 * secid ) ; void ( * release_secctx ) ( char * secdata , u32 seclen ) ; int ( * inode_notifysecctx ) ( struct inode * inode , void * ctx , u32 ctxlen ) ; int ( * inode_setsecctx ) ( struct dentry * dentry , void * ctx , u32 ctxlen ) ; int ( * inode_getsecctx ) ( struct inode * inode , void * * ctx , u32 * ctxlen ) ; int ( * unix_stream_connect ) ( struct socket * sock , struct socket * other , struct sock * newsk ) ; int ( * unix_may_send ) ( struct socket * sock , struct socket * other ) ; int ( * socket_create ) ( int family , int type , int protocol , int kern ) ; int ( * socket_post_create ) ( struct socket * sock , int family , int type , int protocol , int kern ) ; int ( * socket_bind ) ( struct socket * sock , struct sockaddr * address , int addrlen ) ; int ( * socket_connect ) ( struct socket * sock , struct sockaddr * address , int addrlen ) ; int ( * socket_listen ) ( struct socket * sock , int backlog ) ; int ( * socket_accept ) ( struct socket * sock , struct socket * newsock ) ; int ( * socket_sendmsg ) ( struct socket * sock , struct msghdr * msg , int size ) ; int ( * socket_recvmsg ) ( struct socket * sock , struct msghdr * msg , int size , int flags ) ; int ( * socket_getsockname ) ( struct socket * sock ) ; int ( * socket_getpeername ) ( struct socket * sock ) ; int ( * socket_getsockopt ) ( struct socket * sock , int level , int optname ) ; int ( * socket_setsockopt ) ( struct socket * sock , int level , int optname ) ; int ( * socket_shutdown ) ( struct socket * sock , int how ) ; int ( * socket_sock_rcv_skb ) ( struct sock * sk , struct sk_buff * skb ) ; int ( * socket_getpeersec_stream ) ( struct socket * sock , char * optval , int * optlen , unsigned len ) ; int ( * socket_getpeersec_dgram ) ( struct socket * sock , struct sk_buff * skb , u32 * secid ) ; int ( * sk_alloc_security ) ( struct sock * sk , int family , gfp_t priority ) ; void ( * sk_free_security ) ( struct sock * sk ) ; void ( * sk_clone_security ) ( const struct sock * sk , struct sock * newsk ) ; void ( * sk_getsecid ) ( struct sock * sk , u32 * secid ) ; void ( * sock_graft ) ( struct sock * sk , struct socket * parent ) ; int ( * inet_conn_request ) ( struct sock * sk , struct sk_buff * skb , struct request_sock * req ) ; void ( * inet_csk_clone ) ( struct sock * newsk , const struct request_sock * req ) ; void ( * inet_conn_established ) ( struct sock * sk , struct sk_buff * skb ) ; void ( * req_classify_flow ) ( const struct request_sock * req , struct flowi * fl ) ; int ( * tun_dev_create ) ( void ) ; void ( * tun_dev_post_create ) ( struct sock * sk ) ; int ( * tun_dev_attach ) ( struct sock * sk ) ; int ( * key_alloc ) ( struct key * key , const struct cred * cred , unsigned long flags ) ; void ( * key_free ) ( struct key * key ) ; int ( * key_permission ) ( key_ref_t key_ref , const struct cred * cred , key_perm_t perm ) ; int ( * key_getsecurity ) ( struct key * key , char * * _buffer ) ; int ( * key_session_to_parent ) ( const struct cred * cred , const struct cred * parent_cred , struct key * key ) ; int ( * audit_rule_init ) ( u32 field , u32 op , char * rulestr , void * * lsmrule ) ; int ( * audit_rule_known ) ( struct audit_krule * krule ) ; int ( * audit_rule_match ) ( u32 secid , u32 field , u32 op , void * lsmrule , struct audit_context * actx ) ; void ( * audit_rule_free ) ( void * lsmrule ) ; } ;

enum writeback_sync_modes { WB_SYNC_NONE , WB_SYNC_ALL , } ;

struct writeback_control { enum writeback_sync_modes sync_mode ; unsigned long * older_than_this ; unsigned long wb_start ; long nr_to_write ; long pages_skipped ; loff_t range_start ; loff_t range_end ; unsigned nonblocking : 1 ; unsigned encountered_congestion : 1 ; unsigned for_kupdate : 1 ; unsigned for_reclaim : 1 ; unsigned range_cyclic : 1 ; unsigned more_io : 1 ; unsigned no_nrwrite_index_update : 1 ; } ;
struct bdi_writeback ;

typedef int ( * writepage_t ) ( struct page * page , struct writeback_control * wbc , void * data ) ;
struct cpu { int node_id ; int hotpluggable ; struct sys_device sysdev ; } ;

struct rtc_time { int tm_sec ; int tm_min ; int tm_hour ; int tm_mday ; int tm_mon ; int tm_year ; int tm_wday ; int tm_yday ; int tm_isdst ; } ;

struct rtc_wkalrm { unsigned char enabled ; unsigned char pending ; struct rtc_time time ; } ;

struct rtc_pll_info { int pll_ctrl ; int pll_value ; int pll_max ; int pll_min ; int pll_posmult ; int pll_negmult ; long pll_clock ; } ;

struct pollfd { int fd ; short events ; short revents ; } ;
typedef void ( * poll_queue_proc ) ( struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;

typedef struct poll_table_struct { poll_queue_proc qproc ; unsigned long key ; } poll_table ;

struct poll_table_entry { struct file * filp ; unsigned long key ; wait_queue_t wait ; wait_queue_head_t * wait_address ; } ;

struct poll_wqueues { poll_table pt ; struct poll_table_page * table ; struct task_struct * polling_task ; int triggered ; int error ; int inline_index ; struct poll_table_entry inline_entries [ ( ( 832 - 256 ) / sizeof ( struct poll_table_entry ) ) ] ; } ;

typedef struct { unsigned long * in , * out , * ex ; unsigned long * res_in , * res_out , * res_ex ; } fd_set_bits ;

struct rtc_class_ops { int ( * open ) ( struct device * ) ; void ( * release ) ( struct device * ) ; int ( * ioctl ) ( struct device * , unsigned int , unsigned long ) ; int ( * read_time ) ( struct device * , struct rtc_time * ) ; int ( * set_time ) ( struct device * , struct rtc_time * ) ; int ( * read_alarm ) ( struct device * , struct rtc_wkalrm * ) ; int ( * set_alarm ) ( struct device * , struct rtc_wkalrm * ) ; int ( * proc ) ( struct device * , struct seq_file * ) ; int ( * set_mmss ) ( struct device * , unsigned long secs ) ; int ( * irq_set_state ) ( struct device * , int enabled ) ; int ( * irq_set_freq ) ( struct device * , int freq ) ; int ( * read_callback ) ( struct device * , int data ) ; int ( * alarm_irq_enable ) ( struct device * , unsigned int enabled ) ; int ( * update_irq_enable ) ( struct device * , unsigned int enabled ) ; } ;

struct rtc_task ;

struct rtc_device { struct device dev ; struct module * owner ; int id ; char name [ 20 ] ; const struct rtc_class_ops * ops ; struct mutex ops_lock ; struct cdev char_dev ; unsigned long flags ; unsigned long irq_data ; spinlock_t irq_lock ; wait_queue_head_t irq_queue ; struct fasync_struct * async_queue ; struct rtc_task * irq_task ; spinlock_t irq_task_lock ; int irq_freq ; int max_user_freq ; struct work_struct uie_task ; struct timer_list uie_timer ; unsigned int oldsecs ; unsigned int uie_irq_active : 1 ; unsigned int stop_uie_polling : 1 ; unsigned int uie_task_active : 1 ; unsigned int uie_timer_active : 1 ; } ;

typedef struct rtc_task { void ( * func ) ( void * private_data ) ; void * private_data ; } rtc_task_t ;

typedef unsigned long efi_status_t ;

typedef u8 efi_bool_t ;

typedef u16 efi_char16_t ;

typedef struct { u8 b [ 16 ] ; } efi_guid_t ;

typedef struct { u64 signature ; u32 revision ; u32 headersize ; u32 crc32 ; u32 reserved ; } efi_table_hdr_t ;

typedef struct { u32 type ; u32 pad ; u64 phys_addr ; u64 virt_addr ; u64 num_pages ; u64 attribute ; } efi_memory_desc_t ;

typedef int ( * efi_freemem_callback_t ) ( u64 start , u64 end , void * arg ) ;
typedef struct { u16 year ; u8 month ; u8 day ; u8 hour ; u8 minute ; u8 second ; u8 pad1 ; u32 nanosecond ; s16 timezone ; u8 daylight ; u8 pad2 ; } efi_time_t ;

typedef struct { u32 resolution ; u32 accuracy ; u8 sets_to_zero ; } efi_time_cap_t ;

typedef struct { efi_table_hdr_t hdr ; unsigned long get_time ; unsigned long set_time ; unsigned long get_wakeup_time ; unsigned long set_wakeup_time ; unsigned long set_virtual_address_map ; unsigned long convert_pointer ; unsigned long get_variable ; unsigned long get_next_variable ; unsigned long set_variable ; unsigned long get_next_high_mono_count ; unsigned long reset_system ; } efi_runtime_services_t ;

typedef efi_status_t efi_get_time_t ( efi_time_t * tm , efi_time_cap_t * tc ) ;

typedef efi_status_t efi_set_time_t ( efi_time_t * tm ) ;

typedef efi_status_t efi_get_wakeup_time_t ( efi_bool_t * enabled , efi_bool_t * pending , efi_time_t * tm ) ;

typedef efi_status_t efi_set_wakeup_time_t ( efi_bool_t enabled , efi_time_t * tm ) ;

typedef efi_status_t efi_get_variable_t ( efi_char16_t * name , efi_guid_t * vendor , u32 * attr , unsigned long * data_size , void * data ) ;

typedef efi_status_t efi_get_next_variable_t ( unsigned long * name_size , efi_char16_t * name , efi_guid_t * vendor ) ;

typedef efi_status_t efi_set_variable_t ( efi_char16_t * name , efi_guid_t * vendor , unsigned long attr , unsigned long data_size , void * data ) ;

typedef efi_status_t efi_get_next_high_mono_count_t ( u32 * count ) ;

typedef void efi_reset_system_t ( int reset_type , efi_status_t status , unsigned long data_size , efi_char16_t * data ) ;

typedef efi_status_t efi_set_virtual_address_map_t ( unsigned long memory_map_size , unsigned long descriptor_size , u32 descriptor_version , efi_memory_desc_t * virtual_map ) ;

typedef struct { efi_guid_t guid ; unsigned long table ; } efi_config_table_t ;

typedef struct { efi_table_hdr_t hdr ; unsigned long fw_vendor ; u32 fw_revision ; unsigned long con_in_handle ; unsigned long con_in ; unsigned long con_out_handle ; unsigned long con_out ; unsigned long stderr_handle ; unsigned long stderr ; efi_runtime_services_t * runtime ; unsigned long boottime ; unsigned long nr_tables ; unsigned long tables ; } efi_system_table_t ;

struct efi_memory_map { void * phys_map ; void * map ; void * map_end ; int nr_map ; unsigned long desc_version ; unsigned long desc_size ; } ;


struct efi_generic_dev_path { u8 type ; u8 sub_type ; u16 length ; } __attribute ( ( packed ) ) ;
typedef u64 cycle_t ;

struct clocksource ;

struct cyclecounter { cycle_t ( * read ) ( const struct cyclecounter * cc ) ; cycle_t mask ; u32 mult ; u32 shift ; } ;

struct timecounter { const struct cyclecounter * cc ; cycle_t cycle_last ; u64 nsec ; } ;

struct clocksource { char * name ; struct list_head list ; int rating ; cycle_t ( * read ) ( struct clocksource * cs ) ; int ( * enable ) ( struct clocksource * cs ) ; void ( * disable ) ( struct clocksource * cs ) ; cycle_t mask ; u32 mult ; u32 shift ; u64 max_idle_ns ; unsigned long flags ; cycle_t ( * vread ) ( void ) ; void ( * resume ) ( void ) ; cycle_t cycle_last __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; struct list_head wd_list ; cycle_t wd_last ; } ;
enum clock_event_mode { CLOCK_EVT_MODE_UNUSED = 0 , CLOCK_EVT_MODE_SHUTDOWN , CLOCK_EVT_MODE_PERIODIC , CLOCK_EVT_MODE_ONESHOT , CLOCK_EVT_MODE_RESUME , } ;

enum clock_event_nofitiers { CLOCK_EVT_NOTIFY_ADD , CLOCK_EVT_NOTIFY_BROADCAST_ON , CLOCK_EVT_NOTIFY_BROADCAST_OFF , CLOCK_EVT_NOTIFY_BROADCAST_FORCE , CLOCK_EVT_NOTIFY_BROADCAST_ENTER , CLOCK_EVT_NOTIFY_BROADCAST_EXIT , CLOCK_EVT_NOTIFY_SUSPEND , CLOCK_EVT_NOTIFY_RESUME , CLOCK_EVT_NOTIFY_CPU_DYING , CLOCK_EVT_NOTIFY_CPU_DEAD , } ;

struct clock_event_device { const char * name ; unsigned int features ; unsigned long max_delta_ns ; unsigned long min_delta_ns ; unsigned long mult ; int shift ; int rating ; int irq ; const struct cpumask * cpumask ; int ( * set_next_event ) ( unsigned long evt , struct clock_event_device * ) ; void ( * set_mode ) ( enum clock_event_mode mode , struct clock_event_device * ) ; void ( * event_handler ) ( struct clock_event_device * ) ; void ( * broadcast ) ( const struct cpumask * mask ) ; struct list_head list ; enum clock_event_mode mode ; ktime_t next_event ; } ;
enum tick_device_mode { TICKDEV_MODE_PERIODIC , TICKDEV_MODE_ONESHOT , } ;

struct tick_device { struct clock_event_device * evtdev ; enum tick_device_mode mode ; } ;

enum tick_nohz_mode { NOHZ_MODE_INACTIVE , NOHZ_MODE_LOWRES , NOHZ_MODE_HIGHRES , } ;

struct tick_sched { struct hrtimer sched_timer ; unsigned long check_clocks ; enum tick_nohz_mode nohz_mode ; ktime_t idle_tick ; int inidle ; int tick_stopped ; unsigned long idle_jiffies ; unsigned long idle_calls ; unsigned long idle_sleeps ; int idle_active ; ktime_t idle_entrytime ; ktime_t idle_waketime ; ktime_t idle_exittime ; ktime_t idle_sleeptime ; ktime_t idle_lastupdate ; ktime_t sleep_length ; unsigned long last_jiffies ; unsigned long next_jiffies ; ktime_t idle_expires ; } ;

struct anon_vma { spinlock_t lock ; struct list_head head ; } ;
enum ttu_flags { TTU_UNMAP = 0 , TTU_MIGRATION = 1 , TTU_MUNLOCK = 2 , TTU_ACTION_MASK = 0xff , TTU_IGNORE_MLOCK = ( 1 << 8 ) , TTU_IGNORE_ACCESS = ( 1 << 9 ) , TTU_IGNORE_HWPOISON = ( 1 << 10 ) , } ;

enum { MPOL_DEFAULT , MPOL_PREFERRED , MPOL_BIND , MPOL_INTERLEAVE , MPOL_MAX , } ;
enum mapping_flags { AS_EIO = 22 + 0 , AS_ENOSPC = 22 + 1 , AS_MM_ALL_LOCKS = 22 + 2 , AS_UNEVICTABLE = 22 + 3 , } ;

typedef int filler_t ( void * , struct page * ) ;

struct mempolicy { atomic_t refcnt ; unsigned short mode ; unsigned short flags ; union { short preferred_node ; nodemask_t nodes ; } v ; union { nodemask_t cpuset_mems_allowed ; nodemask_t user_nodemask ; } w ; } ;
struct sp_node { struct rb_node nd ; unsigned long start , end ; struct mempolicy * policy ; } ;

struct shared_policy { struct rb_root root ; spinlock_t lock ; } ;

enum bh_state_bits { BH_Uptodate , BH_Dirty , BH_Lock , BH_Req , BH_Uptodate_Lock , BH_Mapped , BH_New , BH_Async_Read , BH_Async_Write , BH_Delay , BH_Boundary , BH_Write_EIO , BH_Ordered , BH_Eopnotsupp , BH_Unwritten , BH_Quiet , BH_PrivateStart , } ;

typedef void ( bh_end_io_t ) ( struct buffer_head * bh , int uptodate ) ;
struct buffer_head { unsigned long b_state ; struct buffer_head * b_this_page ; struct page * b_page ; sector_t b_blocknr ; size_t b_size ; char * b_data ; struct block_device * b_bdev ; bh_end_io_t * b_end_io ; void * b_private ; struct list_head b_assoc_buffers ; struct address_space * b_assoc_map ; atomic_t b_count ; } ;
struct page_cgroup { unsigned long flags ; struct mem_cgroup * mem_cgroup ; struct page * page ; struct list_head lru ; } ;
enum { PCG_LOCK , PCG_CACHE , PCG_USED , PCG_ACCT_LRU , } ;
struct mnt_namespace ;

struct ipc_namespace ;

struct nsproxy { atomic_t count ; struct uts_namespace * uts_ns ; struct ipc_namespace * ipc_ns ; struct mnt_namespace * mnt_ns ; struct pid_namespace * pid_ns ; struct net * net_ns ; } ;
struct pidmap { atomic_t nr_free ; void * page ; } ;

struct bsd_acct_struct ;

struct pid_namespace { struct kref kref ; struct pidmap pidmap [ ( ( ( 0 ? ( ( 1UL ) << 12 ) * 8 : ( sizeof ( long ) > 4 ? 4 * 1024 * 1024 : ( 0 ? 0x1000 : 0x8000 ) ) ) + 8 * ( ( 1UL ) << 12 ) - 1 ) / ( ( 1UL ) << 12 ) / 8 ) ] ; int last_pid ; struct task_struct * child_reaper ; struct kmem_cache * pid_cachep ; unsigned int level ; struct pid_namespace * parent ; struct vfsmount * proc_mnt ; struct bsd_acct_struct * bacct ; } ;
typedef void ( * ftrace_func_t ) ( unsigned long ip , unsigned long parent_ip ) ;
struct ftrace_ops { ftrace_func_t func ; struct ftrace_ops * next ; } ;

enum ftrace_tracing_type_t { FTRACE_TYPE_ENTER = 0 , FTRACE_TYPE_RETURN , } ;

struct ftrace_func_command { struct list_head list ; char * name ; int ( * func ) ( char * func , char * cmd , char * params , int enable ) ; } ;

struct ftrace_probe_ops { void ( * func ) ( unsigned long ip , unsigned long parent_ip , void * * data ) ; int ( * callback ) ( unsigned long ip , void * * data ) ; void ( * free ) ( void * * data ) ; int ( * print ) ( struct seq_file * m , unsigned long ip , struct ftrace_probe_ops * ops , void * data ) ; } ;

enum { FTRACE_FL_FREE = ( 1 << 0 ) , FTRACE_FL_FAILED = ( 1 << 1 ) , FTRACE_FL_FILTER = ( 1 << 2 ) , FTRACE_FL_ENABLED = ( 1 << 3 ) , FTRACE_FL_NOTRACE = ( 1 << 4 ) , FTRACE_FL_CONVERTED = ( 1 << 5 ) , FTRACE_FL_FROZEN = ( 1 << 6 ) , } ;
struct dyn_ftrace { union { unsigned long ip ; struct dyn_ftrace * freelist ; } ; union { unsigned long flags ; struct dyn_ftrace * newlist ; } ; struct dyn_arch_ftrace arch ; } ;

struct ftrace_graph_ent { unsigned long func ; int depth ; } ;

struct ftrace_graph_ret { unsigned long func ; unsigned long long calltime ; unsigned long long rettime ; unsigned long overrun ; int depth ; } ;

struct ftrace_ret_stack { unsigned long ret ; unsigned long func ; unsigned long long calltime ; unsigned long long subtime ; unsigned long fp ; } ;

typedef void ( * trace_func_graph_ret_t ) ( struct ftrace_graph_ret * ) ;
typedef int ( * trace_func_graph_ent_t ) ( struct ftrace_graph_ent * ) ;

enum { TSK_TRACE_FL_TRACE_BIT = 0 , TSK_TRACE_FL_GRAPH_BIT = 1 , } ;
enum { TSK_TRACE_FL_TRACE = 1 << TSK_TRACE_FL_TRACE_BIT , TSK_TRACE_FL_GRAPH = 1 << TSK_TRACE_FL_GRAPH_BIT , } ;
typedef u64 async_cookie_t ;

typedef void ( async_func_ptr ) ( void * data , async_cookie_t cookie ) ;
struct sfi_table_header { char sig [ 4 ] ; u32 len ; u8 rev ; u8 csum ; char oem_id [ 6 ] ; char oem_table_id [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct sfi_table_simple { struct sfi_table_header header ; u64 pentry [ 1 ] ; } __attribute__ ( ( packed ) ) ;
struct sfi_mem_entry { u32 type ; u64 phys_start ; u64 virt_start ; u64 pages ; u64 attrib ; } __attribute__ ( ( packed ) ) ;
struct sfi_cpu_table_entry { u32 apic_id ; } __attribute__ ( ( packed ) ) ;
struct sfi_cstate_table_entry { u32 hint ; u32 latency ; } __attribute__ ( ( packed ) ) ;
struct sfi_apic_table_entry { u64 phys_addr ; } __attribute__ ( ( packed ) ) ;
struct sfi_freq_table_entry { u32 freq_mhz ; u32 latency ; u32 ctrl_val ; } __attribute__ ( ( packed ) ) ;
struct sfi_wake_table_entry { u64 phys_addr ; } __attribute__ ( ( packed ) ) ;
struct sfi_timer_table_entry { u64 phys_addr ; u32 freq_hz ; u32 irq ; } __attribute__ ( ( packed ) ) ;
struct sfi_rtc_table_entry { u64 phys_addr ; u32 irq ; } __attribute__ ( ( packed ) ) ;
struct sfi_spi_table_entry { u16 host_num ; u16 cs ; u16 irq_info ; char name [ 16 ] ; u8 dev_info [ 10 ] ; } __attribute__ ( ( packed ) ) ;
struct sfi_i2c_table_entry { u16 host_num ; u16 addr ; u16 irq_info ; char name [ 16 ] ; u8 dev_info [ 10 ] ; } __attribute__ ( ( packed ) ) ;
struct sfi_gpe_table_entry { u16 logical_id ; u16 phys_id ; } __attribute__ ( ( packed ) ) ;
typedef int ( * sfi_table_handler ) ( struct sfi_table_header * table ) ;
struct shmem_inode_info { spinlock_t lock ; unsigned long flags ; unsigned long alloced ; unsigned long swapped ; unsigned long next_index ; struct shared_policy policy ; struct page * i_indirect ; swp_entry_t i_direct [ 16 ] ; struct list_head swaplist ; struct inode vfs_inode ; } ;

struct shmem_sb_info { unsigned long max_blocks ; unsigned long free_blocks ; unsigned long max_inodes ; unsigned long free_inodes ; spinlock_t stat_lock ; uid_t uid ; gid_t gid ; mode_t mode ; struct mempolicy * mpol ; } ;

struct boot_trace_call { pid_t caller ; char func [ ( sizeof ( ) + ( 128 - 1 ) + 2 * ( 64 * 3 / 10 ) + ( ( 64 - sizeof ( unsigned long ) ) - 1 ) + 1 ) ] ; } ;

struct boot_trace_ret { char func [ ( sizeof ( ) + ( 128 - 1 ) + 2 * ( 64 * 3 / 10 ) + ( ( 64 - sizeof ( unsigned long ) ) - 1 ) + 1 ) ] ; int result ; unsigned long long duration ; } ;

void __attribute__ ( ( weak ) ) arch_disable_smp_support ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) parse_early_options ( char * cmdline ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) parse_early_param ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( weak ) ) smp_setup_processor_id ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( weak ) ) thread_info_cache_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) start_kernel ( void ) ;

int do_one_initcall ( initcall_t fn ) ;

struct oldold_utsname { char sysname [ 9 ] ; char nodename [ 9 ] ; char release [ 9 ] ; char version [ 9 ] ; char machine [ 9 ] ; } ;

struct old_utsname { char sysname [ 65 ] ; char nodename [ 65 ] ; char release [ 65 ] ; char version [ 65 ] ; char machine [ 65 ] ; } ;

struct new_utsname { char sysname [ 64 + 1 ] ; char nodename [ 64 + 1 ] ; char release [ 64 + 1 ] ; char version [ 64 + 1 ] ; char machine [ 64 + 1 ] ; char domainname [ 64 + 1 ] ; } ;
struct uts_namespace { struct kref kref ; struct new_utsname name ; } ;
struct floppy_struct { unsigned int size , sect , head , track , stretch ; unsigned char gap , rate , spec1 , fmt_gap ; const char * name ; } ;

struct format_descr { unsigned int device , head , track ; } ;

struct floppy_max_errors { unsigned int abort , read_track , reset , recal , reporting ; } ;

typedef char floppy_drive_name [ 16 ] ;
struct floppy_drive_params { signed char cmos ; unsigned long max_dtr ; unsigned long hlt ; unsigned long hut ; unsigned long srt ; unsigned long spinup ; unsigned long spindown ; unsigned char spindown_offset ; unsigned char select_delay ; unsigned char rps ; unsigned char tracks ; unsigned long timeout ; unsigned char interleave_sect ; struct floppy_max_errors max_errors ; char flags ; char read_track ; short autodetect [ 8 ] ; int checkfreq ; int native_format ; } ;

enum { FD_NEED_TWADDLE_BIT , FD_VERIFY_BIT , FD_DISK_NEWCHANGE_BIT , FD_UNUSED_BIT , FD_DISK_CHANGED_BIT , FD_DISK_WRITABLE_BIT } ;
struct floppy_drive_struct { unsigned long flags ; unsigned long spinup_date ; unsigned long select_date ; unsigned long first_read_date ; short probed_format ; short track ; short maxblock ; short maxtrack ; int generation ; int keep_data ; int fd_ref ; int fd_device ; unsigned long last_checked ; char * dmabuf ; int bufblocks ; } ;

enum reset_mode { FD_RESET_IF_NEEDED , FD_RESET_IF_RAWCMD , FD_RESET_ALWAYS } ;

struct floppy_fdc_state { int spec1 ; int spec2 ; int dtr ; unsigned char version ; unsigned char dor ; unsigned long address ; unsigned int rawcmd : 2 ; unsigned int reset : 1 ; unsigned int need_configure : 1 ; unsigned int perp_mode : 2 ; unsigned int has_fifo : 1 ; unsigned int driver_version ; unsigned char track [ 4 ] ; } ;

struct floppy_write_errors { unsigned int write_errors ; unsigned long first_error_sector ; int first_error_generation ; unsigned long last_error_sector ; int last_error_generation ; unsigned int badness ; } ;

struct floppy_raw_cmd { unsigned int flags ; void * data ; char * kernel_data ; struct floppy_raw_cmd * next ; long length ; long phys_length ; int buffer_length ; unsigned char rate ; unsigned char cmd_count ; unsigned char cmd [ 16 ] ; unsigned char reply_count ; unsigned char reply [ 16 ] ; int track ; int resultcode ; int reserved1 ; int reserved2 ; } ;

enum { Root_NFS = ( ( ( 0 ) << 20 ) | ( 255 ) ) , Root_RAM0 = ( ( ( 1 ) << 20 ) | ( 0 ) ) , Root_RAM1 = ( ( ( 1 ) << 20 ) | ( 1 ) ) , Root_FD0 = ( ( ( 2 ) << 20 ) | ( 0 ) ) , Root_HDA1 = ( ( ( 3 ) << 20 ) | ( 1 ) ) , Root_HDA2 = ( ( ( 3 ) << 20 ) | ( 2 ) ) , Root_SDA1 = ( ( ( 8 ) << 20 ) | ( 1 ) ) , Root_SDA2 = ( ( ( 8 ) << 20 ) | ( 2 ) ) , Root_HDC1 = ( ( ( 22 ) << 20 ) | ( 1 ) ) , Root_SR0 = ( ( ( 11 ) << 20 ) | ( 0 ) ) , } ;
enum { DOS_EXTENDED_PARTITION = 5 , LINUX_EXTENDED_PARTITION = 0x85 , WIN98_EXTENDED_PARTITION = 0x0f , SUN_WHOLE_DISK = DOS_EXTENDED_PARTITION , LINUX_SWAP_PARTITION = 0x82 , LINUX_DATA_PARTITION = 0x83 , LINUX_LVM_PARTITION = 0x8e , LINUX_RAID_PARTITION = 0xfd , SOLARIS_X86_PARTITION = LINUX_SWAP_PARTITION , NEW_SOLARIS_X86_PARTITION = 0xbf , DM6_AUX1PARTITION = 0x51 , DM6_AUX3PARTITION = 0x53 , DM6_PARTITION = 0x54 , EZD_PARTITION = 0x55 , FREEBSD_PARTITION = 0xa5 , OPENBSD_PARTITION = 0xa6 , NETBSD_PARTITION = 0xa9 , BSDI_PARTITION = 0xb7 , MINIX_PARTITION = 0x81 , UNIXWARE_PARTITION = 0x63 , } ;
struct partition { unsigned char boot_ind ; unsigned char head ; unsigned char sector ; unsigned char cyl ; unsigned char sys_ind ; unsigned char end_head ; unsigned char end_sector ; unsigned char end_cyl ; __le32 start_sect ; __le32 nr_sects ; } __attribute__ ( ( packed ) ) ;
struct disk_stats { unsigned long sectors [ 2 ] ; unsigned long ios [ 2 ] ; unsigned long merges [ 2 ] ; unsigned long ticks [ 2 ] ; unsigned long io_ticks ; unsigned long time_in_queue ; } ;

struct hd_struct { sector_t start_sect ; sector_t nr_sects ; sector_t alignment_offset ; struct device __dev ; struct kobject * holder_dir ; int policy , partno ; unsigned long stamp ; int in_flight [ 2 ] ; struct disk_stats * dkstats ; struct rcu_head rcu_head ; } ;

struct blk_scsi_cmd_filter { unsigned long read_ok [ ( ( 256 ) / ( sizeof ( long ) * 8 ) ) ] ; unsigned long write_ok [ ( ( 256 ) / ( sizeof ( long ) * 8 ) ) ] ; struct kobject kobj ; } ;

struct disk_part_tbl { struct rcu_head rcu_head ; int len ; struct hd_struct * last_lookup ; struct hd_struct * part [ ] ; } ;

struct gendisk { int major ; int first_minor ; int minors ; char disk_name [ 32 ] ; char * ( * devnode ) ( struct gendisk * gd , mode_t * mode ) ; struct disk_part_tbl * part_tbl ; struct hd_struct part0 ; const struct block_device_operations * fops ; struct request_queue * queue ; void * private_data ; int flags ; struct device * driverfs_dev ; struct kobject * slave_dir ; struct timer_rand_state * random ; atomic_t sync_io ; struct work_struct async_notify ; struct blk_integrity * integrity ; int node_id ; } ;

struct disk_part_iter { struct gendisk * disk ; struct hd_struct * part ; int idx ; unsigned int flags ; } ;

struct solaris_x86_slice { __le16 s_tag ; __le16 s_flag ; __le32 s_start ; __le32 s_size ; } ;

struct solaris_x86_vtoc { unsigned int v_bootinfo [ 3 ] ; __le32 v_sanity ; __le32 v_version ; char v_volume [ 8 ] ; __le16 v_sectorsz ; __le16 v_nparts ; unsigned int v_reserved [ 10 ] ; struct solaris_x86_slice v_slice [ 16 ] ; unsigned int timestamp [ 16 ] ; char v_asciilabel [ 128 ] ; } ;

struct bsd_disklabel { __le32 d_magic ; __s16 d_type ; __s16 d_subtype ; char d_typename [ 16 ] ; char d_packname [ 16 ] ; __u32 d_secsize ; __u32 d_nsectors ; __u32 d_ntracks ; __u32 d_ncylinders ; __u32 d_secpercyl ; __u32 d_secperunit ; __u16 d_sparespertrack ; __u16 d_sparespercyl ; __u32 d_acylinders ; __u16 d_rpm ; __u16 d_interleave ; __u16 d_trackskew ; __u16 d_cylskew ; __u32 d_headswitch ; __u32 d_trkseek ; __u32 d_flags ; __u32 d_drivedata [ 5 ] ; __u32 d_spare [ 5 ] ; __le32 d_magic2 ; __le16 d_checksum ; __le16 d_npartitions ; __le32 d_bbsize ; __le32 d_sbsize ; struct bsd_partition { __le32 p_size ; __le32 p_offset ; __le32 p_fsize ; __u8 p_fstype ; __u8 p_frag ; __le16 p_cpg ; } d_partitions [ 16 ] ; } ;

struct unixware_slice { __le16 s_label ; __le16 s_flags ; __le32 start_sect ; __le32 nr_sects ; } ;

struct unixware_disklabel { __le32 d_type ; __le32 d_magic ; __le32 d_version ; char d_serial [ 12 ] ; __le32 d_ncylinders ; __le32 d_ntracks ; __le32 d_nsectors ; __le32 d_secsize ; __le32 d_part_start ; __le32 d_unknown1 [ 12 ] ; __le32 d_alt_tbl ; __le32 d_alt_len ; __le32 d_phys_cyl ; __le32 d_phys_trk ; __le32 d_phys_sec ; __le32 d_phys_bytes ; __le32 d_unknown2 ; __le32 d_unknown3 ; __le32 d_pad [ 8 ] ; struct unixware_vtoc { __le32 v_magic ; __le32 v_version ; char v_name [ 8 ] ; __le16 v_nslices ; __le16 v_unknown1 ; __le32 v_reserved [ 10 ] ; struct unixware_slice v_slice [ 16 ] ; } vtoc ; } ;

struct vfsmount { struct list_head mnt_hash ; struct vfsmount * mnt_parent ; struct dentry * mnt_mountpoint ; struct dentry * mnt_root ; struct super_block * mnt_sb ; struct list_head mnt_mounts ; struct list_head mnt_child ; int mnt_flags ; const char * mnt_devname ; struct list_head mnt_list ; struct list_head mnt_expire ; struct list_head mnt_share ; struct list_head mnt_slave_list ; struct list_head mnt_slave ; struct vfsmount * mnt_master ; struct mnt_namespace * mnt_ns ; int mnt_id ; int mnt_group_id ; atomic_t mnt_count ; int mnt_expiry_mark ; int mnt_pinned ; int mnt_ghosts ; int * mnt_writers ; } ;
struct file_system_type ;
struct fs_struct { int users ; rwlock_t lock ; int umask ; int in_exec ; struct path root , pwd ; } ;
struct __kernel_sockaddr_storage { unsigned short ss_family ; char __data [ 128 - sizeof ( unsigned short ) ] ; } __attribute__ ( ( aligned ( ( __alignof__ ( struct sockaddr * ) ) ) ) ) ;
typedef unsigned short sa_family_t ;
struct msghdr { void * msg_name ; int msg_namelen ; struct iovec * msg_iov ; __kernel_size_t msg_iovlen ; void * msg_control ; __kernel_size_t msg_controllen ; unsigned msg_flags ; } ;
struct cmsghdr { __kernel_size_t cmsg_len ; int cmsg_level ; int cmsg_type ; } ;
struct ucred { __u32 pid ; __u32 uid ; __u32 gid ; } ;

enum { IPPROTO_IP = 0 , IPPROTO_ICMP = 1 , IPPROTO_IGMP = 2 , IPPROTO_IPIP = 4 , IPPROTO_TCP = 6 , IPPROTO_EGP = 8 , IPPROTO_PUP = 12 , IPPROTO_UDP = 17 , IPPROTO_IDP = 22 , IPPROTO_DCCP = 33 , IPPROTO_RSVP = 46 , IPPROTO_GRE = 47 , IPPROTO_IPV6 = 41 , IPPROTO_ESP = 50 , IPPROTO_AH = 51 , IPPROTO_BEETPH = 94 , IPPROTO_PIM = 103 , IPPROTO_COMP = 108 , IPPROTO_SCTP = 132 , IPPROTO_UDPLITE = 136 , IPPROTO_RAW = 255 , IPPROTO_MAX } ;
struct in_addr { __be32 s_addr ; } ;
struct ip_mreq_source { __be32 imr_multiaddr ; __be32 imr_interface ; __be32 imr_sourceaddr ; } ;
struct ip_msfilter { __be32 imsf_multiaddr ; __be32 imsf_interface ; __u32 imsf_fmode ; __u32 imsf_numsrc ; __be32 imsf_slist [ 1 ] ; } ;
struct group_req { __u32 gr_interface ; struct __kernel_sockaddr_storage gr_group ; } ;
struct group_source_req { __u32 gsr_interface ; struct __kernel_sockaddr_storage gsr_group ; struct __kernel_sockaddr_storage gsr_source ; } ;
struct group_filter { __u32 gf_interface ; struct __kernel_sockaddr_storage gf_group ; __u32 gf_fmode ; __u32 gf_numsrc ; struct __kernel_sockaddr_storage gf_slist [ 1 ] ; } ;
struct sockaddr_in { sa_family_t sin_family ; __be16 sin_port ; struct in_addr sin_addr ; unsigned char __pad [ 16 - sizeof ( short int ) - sizeof ( unsigned short int ) - sizeof ( struct in_addr ) ] ; } ;
enum { CTL_RPCDEBUG = 1 , CTL_NFSDEBUG , CTL_NFSDDEBUG , CTL_NLMDEBUG , CTL_SLOTTABLE_UDP , CTL_SLOTTABLE_TCP , CTL_MIN_RESVPORT , CTL_MAX_RESVPORT , } ;
struct scatterlist { unsigned long page_link ; unsigned int offset ; unsigned int length ; dma_addr_t dma_address ; unsigned int dma_length ; } ;
struct sg_table { struct scatterlist * sgl ; unsigned int nents ; unsigned int orig_nents ; } ;

typedef struct scatterlist * ( sg_alloc_fn ) ( unsigned int , gfp_t ) ;
typedef void ( sg_free_fn ) ( struct scatterlist * , unsigned int ) ;
struct sg_mapping_iter { struct page * page ; void * addr ; size_t length ; size_t consumed ; struct scatterlist * __sg ; unsigned int __nents ; unsigned int __offset ; unsigned int __flags ; } ;

struct xdr_netobj { unsigned int len ; u8 * data ; } ;

typedef int ( * kxdrproc_t ) ( void * rqstp , __be32 * data , void * obj ) ;
struct xdr_buf { struct kvec head [ 1 ] , tail [ 1 ] ; struct page * * pages ; unsigned int page_base , page_len , flags ; unsigned int buflen , len ; } ;

struct xdr_skb_reader { struct sk_buff * skb ; unsigned int offset ; size_t count ; __wsum csum ; } ;

typedef size_t ( * xdr_skb_read_actor ) ( struct xdr_skb_reader * desc , void * to , size_t len ) ;

struct xdr_array2_desc ;

typedef int ( * xdr_xcode_elem_t ) ( struct xdr_array2_desc * desc , void * elem ) ;
struct xdr_array2_desc { unsigned int elem_size ; unsigned int array_len ; unsigned int array_maxlen ; xdr_xcode_elem_t xcode ; } ;
struct xdr_stream { __be32 * p ; struct xdr_buf * buf ; __be32 * end ; struct kvec * iov ; } ;

struct rpc_procinfo ;

struct rpc_message { struct rpc_procinfo * rpc_proc ; void * rpc_argp ; void * rpc_resp ; struct rpc_cred * rpc_cred ; } ;

struct rpc_call_ops ;

struct rpc_wait_queue ;

struct rpc_wait { struct list_head list ; struct list_head links ; struct list_head timer_list ; unsigned long expires ; } ;

struct rpc_task { unsigned long tk_magic ; atomic_t tk_count ; struct list_head tk_task ; struct rpc_clnt * tk_client ; struct rpc_rqst * tk_rqstp ; int tk_status ; struct rpc_message tk_msg ; __u8 tk_garb_retry ; __u8 tk_cred_retry ; void ( * tk_callback ) ( struct rpc_task * ) ; void ( * tk_action ) ( struct rpc_task * ) ; const struct rpc_call_ops * tk_ops ; void * tk_calldata ; unsigned long tk_timeout ; unsigned short tk_flags ; unsigned long tk_runstate ; struct workqueue_struct * tk_workqueue ; struct rpc_wait_queue * tk_waitqueue ; union { struct work_struct tk_work ; struct rpc_wait tk_wait ; } u ; unsigned short tk_timeouts ; size_t tk_bytes_sent ; unsigned long tk_start ; long tk_rtt ; pid_t tk_owner ; unsigned char tk_priority : 2 ; unsigned short tk_pid ; } ;

typedef void ( * rpc_action ) ( struct rpc_task * ) ;
struct rpc_call_ops { void ( * rpc_call_prepare ) ( struct rpc_task * , void * ) ; void ( * rpc_call_done ) ( struct rpc_task * , void * ) ; void ( * rpc_release ) ( void * ) ; } ;
struct rpc_task_setup { struct rpc_task * task ; struct rpc_clnt * rpc_client ; const struct rpc_message * rpc_message ; const struct rpc_call_ops * callback_ops ; void * callback_data ; struct workqueue_struct * workqueue ; unsigned short flags ; signed char priority ; } ;

struct rpc_timer { struct timer_list timer ; struct list_head list ; unsigned long expires ; } ;

struct rpc_wait_queue { spinlock_t lock ; struct list_head tasks [ ( 1 + ( 1 ) - ( - 1 ) ) ] ; pid_t owner ; unsigned char maxpriority ; unsigned char priority ; unsigned char count ; unsigned char nr ; unsigned short qlen ; struct rpc_timer timer_list ; const char * name ; } ;
struct auth_cred { uid_t uid ; gid_t gid ; struct group_info * group_info ; unsigned char machine_cred : 1 ; } ;

struct rpc_auth ;

struct rpc_credops ;

struct rpc_cred { struct hlist_node cr_hash ; struct list_head cr_lru ; struct rcu_head cr_rcu ; struct rpc_auth * cr_auth ; const struct rpc_credops * cr_ops ; unsigned long cr_magic ; unsigned long cr_expire ; unsigned long cr_flags ; atomic_t cr_count ; uid_t cr_uid ; } ;

struct rpc_cred_cache { struct hlist_head hashtable [ ( 1 << 4 ) ] ; spinlock_t lock ; } ;

struct rpc_authops ;

struct rpc_auth { unsigned int au_cslack ; unsigned int au_rslack ; unsigned int au_verfsize ; unsigned int au_flags ; const struct rpc_authops * au_ops ; rpc_authflavor_t au_flavor ; atomic_t au_count ; struct rpc_cred_cache * au_credcache ; } ;
struct rpc_authops { struct module * owner ; rpc_authflavor_t au_flavor ; char * au_name ; struct rpc_auth * ( * create ) ( struct rpc_clnt * , rpc_authflavor_t ) ; void ( * destroy ) ( struct rpc_auth * ) ; struct rpc_cred * ( * lookup_cred ) ( struct rpc_auth * , struct auth_cred * , int ) ; struct rpc_cred * ( * crcreate ) ( struct rpc_auth * , struct auth_cred * , int ) ; } ;
struct rpc_credops { const char * cr_name ; int ( * cr_init ) ( struct rpc_auth * , struct rpc_cred * ) ; void ( * crdestroy ) ( struct rpc_cred * ) ; int ( * crmatch ) ( struct auth_cred * , struct rpc_cred * , int ) ; void ( * crbind ) ( struct rpc_task * , struct rpc_cred * , int ) ; __be32 * ( * crmarshal ) ( struct rpc_task * , __be32 * ) ; int ( * crrefresh ) ( struct rpc_task * ) ; __be32 * ( * crvalidate ) ( struct rpc_task * , __be32 * ) ; int ( * crwrap_req ) ( struct rpc_task * , kxdrproc_t , void * , __be32 * , void * ) ; int ( * crunwrap_resp ) ( struct rpc_task * , kxdrproc_t , void * , __be32 * , void * ) ; } ;
struct rpc_timeout { unsigned long to_initval , to_maxval , to_increment ; unsigned int to_retries ; unsigned char to_exponential ; } ;

enum rpc_display_format_t { RPC_DISPLAY_ADDR = 0 , RPC_DISPLAY_PORT , RPC_DISPLAY_PROTO , RPC_DISPLAY_HEX_ADDR , RPC_DISPLAY_HEX_PORT , RPC_DISPLAY_NETID , RPC_DISPLAY_MAX , } ;

struct rpc_task ;
struct rpc_xprt ;

struct rpc_rqst { struct rpc_xprt * rq_xprt ; struct xdr_buf rq_snd_buf ; struct xdr_buf rq_rcv_buf ; struct rpc_task * rq_task ; __be32 rq_xid ; int rq_cong ; int rq_reply_bytes_recvd ; u32 rq_seqno ; int rq_enc_pages_num ; struct page * * rq_enc_pages ; void ( * rq_release_snd_buf ) ( struct rpc_rqst * ) ; struct list_head rq_list ; __u32 * rq_buffer ; size_t rq_callsize , rq_rcvsize ; struct xdr_buf rq_private_buf ; unsigned long rq_majortimeo ; unsigned long rq_timeout ; unsigned int rq_retries ; unsigned int rq_connect_cookie ; u32 rq_bytes_sent ; unsigned long rq_xtime ; int rq_ntrans ; } ;

struct rpc_xprt_ops { void ( * set_buffer_size ) ( struct rpc_xprt * xprt , size_t sndsize , size_t rcvsize ) ; int ( * reserve_xprt ) ( struct rpc_task * task ) ; void ( * release_xprt ) ( struct rpc_xprt * xprt , struct rpc_task * task ) ; void ( * rpcbind ) ( struct rpc_task * task ) ; void ( * set_port ) ( struct rpc_xprt * xprt , unsigned short port ) ; void ( * connect ) ( struct rpc_task * task ) ; void * ( * buf_alloc ) ( struct rpc_task * task , size_t size ) ; void ( * buf_free ) ( void * buffer ) ; int ( * send_request ) ( struct rpc_task * task ) ; void ( * set_retrans_timeout ) ( struct rpc_task * task ) ; void ( * timer ) ( struct rpc_task * task ) ; void ( * release_request ) ( struct rpc_task * task ) ; void ( * close ) ( struct rpc_xprt * xprt ) ; void ( * destroy ) ( struct rpc_xprt * xprt ) ; void ( * print_stats ) ( struct rpc_xprt * xprt , struct seq_file * seq ) ; } ;

enum xprt_transports { XPRT_TRANSPORT_UDP = IPPROTO_UDP , XPRT_TRANSPORT_TCP = IPPROTO_TCP , XPRT_TRANSPORT_BC_TCP = IPPROTO_TCP | ( 1 << 31 ) , XPRT_TRANSPORT_RDMA = 256 } ;

struct rpc_xprt { struct kref kref ; struct rpc_xprt_ops * ops ; const struct rpc_timeout * timeout ; struct __kernel_sockaddr_storage addr ; size_t addrlen ; int prot ; unsigned long cong ; unsigned long cwnd ; size_t max_payload ; unsigned int tsh_size ; struct rpc_wait_queue binding ; struct rpc_wait_queue sending ; struct rpc_wait_queue resend ; struct rpc_wait_queue pending ; struct rpc_wait_queue backlog ; struct list_head free ; struct rpc_rqst * slot ; unsigned int max_reqs ; unsigned long state ; unsigned char shutdown : 1 , resvport : 1 ; unsigned int bind_index ; unsigned long connect_timeout , bind_timeout , reestablish_timeout ; unsigned int connect_cookie ; struct work_struct task_cleanup ; struct timer_list timer ; unsigned long last_used , idle_timeout ; spinlock_t transport_lock ; spinlock_t reserve_lock ; u32 xid ; struct rpc_task * snd_task ; struct svc_xprt * bc_xprt ; struct list_head recv ; struct { unsigned long bind_count , connect_count , connect_start , connect_time , sends , recvs , bad_xids ; unsigned long long req_u , bklog_u ; } stat ; const char * address_strings [ RPC_DISPLAY_MAX ] ; } ;
struct xprt_create { int ident ; struct sockaddr * srcaddr ; struct sockaddr * dstaddr ; size_t addrlen ; struct svc_xprt * bc_xprt ; } ;

struct xprt_class { struct list_head list ; int ident ; struct rpc_xprt * ( * setup ) ( struct xprt_create * ) ; struct module * owner ; char name [ 32 ] ; } ;

struct rpc_stat { struct rpc_program * program ; unsigned int netcnt , netudpcnt , nettcpcnt , nettcpconn , netreconn ; unsigned int rpccnt , rpcretrans , rpcauthrefresh , rpcgarbage ; } ;

struct svc_stat { struct svc_program * program ; unsigned int netcnt , netudpcnt , nettcpcnt , nettcpconn ; unsigned int rpccnt , rpcbadfmt , rpcbadauth , rpcbadclnt ; } ;

struct rpc_rtt { unsigned long timeo ; unsigned long srtt [ 5 ] ; unsigned long sdrtt [ 5 ] ; int ntimeouts [ 5 ] ; } ;

struct in6_pktinfo { struct in6_addr ipi6_addr ; int ipi6_ifindex ; } ;

struct in6_ifreq { struct in6_addr ifr6_addr ; __u32 ifr6_prefixlen ; int ifr6_ifindex ; } ;

struct ipv6_rt_hdr { __u8 nexthdr ; __u8 hdrlen ; __u8 type ; __u8 segments_left ; } ;

struct ipv6_opt_hdr { __u8 nexthdr ; __u8 hdrlen ; } __attribute__ ( ( packed ) ) ;
struct rt0_hdr { struct ipv6_rt_hdr rt_hdr ; __u32 reserved ; struct in6_addr addr [ 0 ] ; } ;

struct rt2_hdr { struct ipv6_rt_hdr rt_hdr ; __u32 reserved ; struct in6_addr addr ; } ;

struct ipv6_destopt_hao { __u8 type ; __u8 length ; struct in6_addr addr ; } __attribute__ ( ( __packed__ ) ) ;
struct ipv6hdr { __u8 priority : 4 , version : 4 ; __u8 flow_lbl [ 3 ] ; __be16 payload_len ; __u8 nexthdr ; __u8 hop_limit ; struct in6_addr saddr ; struct in6_addr daddr ; } ;

struct ipv6_devconf { __s32 forwarding ; __s32 hop_limit ; __s32 mtu6 ; __s32 accept_ra ; __s32 accept_redirects ; __s32 autoconf ; __s32 dad_transmits ; __s32 rtr_solicits ; __s32 rtr_solicit_interval ; __s32 rtr_solicit_delay ; __s32 force_mld_version ; __s32 use_tempaddr ; __s32 temp_valid_lft ; __s32 temp_prefered_lft ; __s32 regen_max_retry ; __s32 max_desync_factor ; __s32 max_addresses ; __s32 accept_ra_defrtr ; __s32 accept_ra_pinfo ; __s32 proxy_ndp ; __s32 accept_source_route ; __s32 disable_ipv6 ; __s32 accept_dad ; void * sysctl ; } ;

struct ipv6_params { __s32 disable_ipv6 ; __s32 autoconf ; } ;

enum { DEVCONF_FORWARDING = 0 , DEVCONF_HOPLIMIT , DEVCONF_MTU6 , DEVCONF_ACCEPT_RA , DEVCONF_ACCEPT_REDIRECTS , DEVCONF_AUTOCONF , DEVCONF_DAD_TRANSMITS , DEVCONF_RTR_SOLICITS , DEVCONF_RTR_SOLICIT_INTERVAL , DEVCONF_RTR_SOLICIT_DELAY , DEVCONF_USE_TEMPADDR , DEVCONF_TEMP_VALID_LFT , DEVCONF_TEMP_PREFERED_LFT , DEVCONF_REGEN_MAX_RETRY , DEVCONF_MAX_DESYNC_FACTOR , DEVCONF_MAX_ADDRESSES , DEVCONF_FORCE_MLD_VERSION , DEVCONF_ACCEPT_RA_DEFRTR , DEVCONF_ACCEPT_RA_PINFO , DEVCONF_ACCEPT_RA_RTR_PREF , DEVCONF_RTR_PROBE_INTERVAL , DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN , DEVCONF_PROXY_NDP , DEVCONF_OPTIMISTIC_DAD , DEVCONF_ACCEPT_SOURCE_ROUTE , DEVCONF_MC_FORWARDING , DEVCONF_DISABLE_IPV6 , DEVCONF_ACCEPT_DAD , DEVCONF_MAX } ;
struct icmp6hdr { __u8 icmp6_type ; __u8 icmp6_code ; __sum16 icmp6_cksum ; union { __be32 un_data32 [ 1 ] ; __be16 un_data16 [ 2 ] ; __u8 un_data8 [ 4 ] ; struct icmpv6_echo { __be16 identifier ; __be16 sequence ; } u_echo ; struct icmpv6_nd_advt { __u32 reserved : 5 , override : 1 , solicited : 1 , router : 1 , reserved2 : 24 ; } u_nd_advt ; struct icmpv6_nd_ra { __u8 hop_limit ; __u8 reserved : 3 , router_pref : 2 , home_agent : 1 , other : 1 , managed : 1 ; __be16 rt_lifetime ; } u_nd_ra ; } icmp6_dataun ; } ;

typedef enum { SS_FREE = 0 , SS_UNCONNECTED , SS_CONNECTING , SS_CONNECTED , SS_DISCONNECTING } socket_state ;

enum sock_type { SOCK_STREAM = 1 , SOCK_DGRAM = 2 , SOCK_RAW = 3 , SOCK_RDM = 4 , SOCK_SEQPACKET = 5 , SOCK_DCCP = 6 , SOCK_PACKET = 10 , } ;

enum sock_shutdown_cmd { SHUT_RD = 0 , SHUT_WR = 1 , SHUT_RDWR = 2 , } ;

struct socket { socket_state state ; int type_begin [ 0 ] ; ; short type ; int type_end [ 0 ] ; ; unsigned long flags ; struct fasync_struct * fasync_list ; wait_queue_head_t wait ; struct file * file ; struct sock * sk ; const struct proto_ops * ops ; } ;
struct proto_ops { int family ; struct module * owner ; int ( * release ) ( struct socket * sock ) ; int ( * bind ) ( struct socket * sock , struct sockaddr * myaddr , int sockaddr_len ) ; int ( * connect ) ( struct socket * sock , struct sockaddr * vaddr , int sockaddr_len , int flags ) ; int ( * socketpair ) ( struct socket * sock1 , struct socket * sock2 ) ; int ( * accept ) ( struct socket * sock , struct socket * newsock , int flags ) ; int ( * getname ) ( struct socket * sock , struct sockaddr * addr , int * sockaddr_len , int peer ) ; unsigned int ( * poll ) ( struct file * file , struct socket * sock , struct poll_table_struct * wait ) ; int ( * ioctl ) ( struct socket * sock , unsigned int cmd , unsigned long arg ) ; int ( * compat_ioctl ) ( struct socket * sock , unsigned int cmd , unsigned long arg ) ; int ( * listen ) ( struct socket * sock , int len ) ; int ( * shutdown ) ( struct socket * sock , int flags ) ; int ( * setsockopt ) ( struct socket * sock , int level , int optname , char * optval , unsigned int optlen ) ; int ( * getsockopt ) ( struct socket * sock , int level , int optname , char * optval , int * optlen ) ; int ( * compat_setsockopt ) ( struct socket * sock , int level , int optname , char * optval , unsigned int optlen ) ; int ( * compat_getsockopt ) ( struct socket * sock , int level , int optname , char * optval , int * optlen ) ; int ( * sendmsg ) ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t total_len ) ; int ( * recvmsg ) ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t total_len , int flags ) ; int ( * mmap ) ( struct file * file , struct socket * sock , struct vm_area_struct * vma ) ; ssize_t ( * sendpage ) ( struct socket * sock , struct page * page , int offset , size_t size , int flags ) ; ssize_t ( * splice_read ) ( struct socket * sock , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) ; } ;

struct net_proto_family { int family ; int ( * create ) ( struct net * net , struct socket * sock , int protocol ) ; struct module * owner ; } ;

struct kvec ;
enum { SOCK_WAKE_IO , SOCK_WAKE_WAITD , SOCK_WAKE_SPACE , SOCK_WAKE_URG , } ;
struct ts_config ;

struct ts_state { unsigned int offset ; char cb [ 40 ] ; } ;

struct ts_ops { const char * name ; struct ts_config * ( * init ) ( const void * , unsigned int , gfp_t , int ) ; unsigned int ( * find ) ( struct ts_config * , struct ts_state * ) ; void ( * destroy ) ( struct ts_config * ) ; void * ( * get_pattern ) ( struct ts_config * ) ; unsigned int ( * get_pattern_len ) ( struct ts_config * ) ; struct module * owner ; struct list_head list ; } ;

struct ts_config { struct ts_ops * ops ; int flags ; unsigned int ( * get_next_block ) ( unsigned int consumed , const u8 * * dst , struct ts_config * conf , struct ts_state * state ) ; void ( * finish ) ( struct ts_config * conf , struct ts_state * state ) ; } ;
struct in6_addr ;
enum bug_trap_type { BUG_TRAP_TYPE_NONE = 0 , BUG_TRAP_TYPE_WARN = 1 , BUG_TRAP_TYPE_BUG = 2 , } ;

enum dma_attr { DMA_ATTR_WRITE_BARRIER , DMA_ATTR_WEAK_ORDERING , DMA_ATTR_MAX , } ;

struct dma_attrs { unsigned long flags [ ( ( ( DMA_ATTR_MAX ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;

enum dma_data_direction { DMA_BIDIRECTIONAL = 0 , DMA_TO_DEVICE = 1 , DMA_FROM_DEVICE = 2 , DMA_NONE = 3 , } ;

struct dma_map_ops { void * ( * alloc_coherent ) ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t gfp ) ; void ( * free_coherent ) ( struct device * dev , size_t size , void * vaddr , dma_addr_t dma_handle ) ; dma_addr_t ( * map_page ) ( struct device * dev , struct page * page , unsigned long offset , size_t size , enum dma_data_direction dir , struct dma_attrs * attrs ) ; void ( * unmap_page ) ( struct device * dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir , struct dma_attrs * attrs ) ; int ( * map_sg ) ( struct device * dev , struct scatterlist * sg , int nents , enum dma_data_direction dir , struct dma_attrs * attrs ) ; void ( * unmap_sg ) ( struct device * dev , struct scatterlist * sg , int nents , enum dma_data_direction dir , struct dma_attrs * attrs ) ; void ( * sync_single_for_cpu ) ( struct device * dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ) ; void ( * sync_single_for_device ) ( struct device * dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ) ; void ( * sync_single_range_for_cpu ) ( struct device * dev , dma_addr_t dma_handle , unsigned long offset , size_t size , enum dma_data_direction dir ) ; void ( * sync_single_range_for_device ) ( struct device * dev , dma_addr_t dma_handle , unsigned long offset , size_t size , enum dma_data_direction dir ) ; void ( * sync_sg_for_cpu ) ( struct device * dev , struct scatterlist * sg , int nents , enum dma_data_direction dir ) ; void ( * sync_sg_for_device ) ( struct device * dev , struct scatterlist * sg , int nents , enum dma_data_direction dir ) ; int ( * mapping_error ) ( struct device * dev , dma_addr_t dma_addr ) ; int ( * dma_supported ) ( struct device * dev , u64 mask ) ; int ( * set_dma_mask ) ( struct device * dev , u64 mask ) ; int is_phys ; } ;

typedef u64 DMA_nnBIT_MASK ;

struct dma_attrs ;
typedef s32 dma_cookie_t ;

enum dma_status { DMA_SUCCESS , DMA_IN_PROGRESS , DMA_ERROR , } ;

enum dma_transaction_type { DMA_MEMCPY , DMA_XOR , DMA_PQ , DMA_XOR_VAL , DMA_PQ_VAL , DMA_MEMSET , DMA_INTERRUPT , DMA_PRIVATE , DMA_ASYNC_TX , DMA_SLAVE , } ;

enum dma_ctrl_flags { DMA_PREP_INTERRUPT = ( 1 << 0 ) , DMA_CTRL_ACK = ( 1 << 1 ) , DMA_COMPL_SKIP_SRC_UNMAP = ( 1 << 2 ) , DMA_COMPL_SKIP_DEST_UNMAP = ( 1 << 3 ) , DMA_COMPL_SRC_UNMAP_SINGLE = ( 1 << 4 ) , DMA_COMPL_DEST_UNMAP_SINGLE = ( 1 << 5 ) , DMA_PREP_PQ_DISABLE_P = ( 1 << 6 ) , DMA_PREP_PQ_DISABLE_Q = ( 1 << 7 ) , DMA_PREP_CONTINUE = ( 1 << 8 ) , DMA_PREP_FENCE = ( 1 << 9 ) , } ;

enum sum_check_bits { SUM_CHECK_P = 0 , SUM_CHECK_Q = 1 , } ;

enum sum_check_flags { SUM_CHECK_P_RESULT = ( 1 << SUM_CHECK_P ) , SUM_CHECK_Q_RESULT = ( 1 << SUM_CHECK_Q ) , } ;

typedef struct { unsigned long bits [ ( ( ( ( DMA_SLAVE + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } dma_cap_mask_t ;

struct dma_chan_percpu { unsigned long memcpy_count ; unsigned long bytes_transferred ; } ;

struct dma_chan { struct dma_device * device ; dma_cookie_t cookie ; int chan_id ; struct dma_chan_dev * dev ; struct list_head device_node ; struct dma_chan_percpu * local ; int client_count ; int table_count ; void * private ; } ;

struct dma_chan_dev { struct dma_chan * chan ; struct device device ; int dev_id ; atomic_t * idr_ref ; } ;

typedef bool ( * dma_filter_fn ) ( struct dma_chan * chan , void * filter_param ) ;

typedef void ( * dma_async_tx_callback ) ( void * dma_async_param ) ;
struct dma_async_tx_descriptor { dma_cookie_t cookie ; enum dma_ctrl_flags flags ; dma_addr_t phys ; struct dma_chan * chan ; dma_cookie_t ( * tx_submit ) ( struct dma_async_tx_descriptor * tx ) ; dma_async_tx_callback callback ; void * callback_param ; struct dma_async_tx_descriptor * next ; struct dma_async_tx_descriptor * parent ; spinlock_t lock ; } ;

struct dma_device { unsigned int chancnt ; unsigned int privatecnt ; struct list_head channels ; struct list_head global_node ; dma_cap_mask_t cap_mask ; unsigned short max_xor ; unsigned short max_pq ; u8 copy_align ; u8 xor_align ; u8 pq_align ; u8 fill_align ; int dev_id ; struct device * dev ; int ( * device_alloc_chan_resources ) ( struct dma_chan * chan ) ; void ( * device_free_chan_resources ) ( struct dma_chan * chan ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_memcpy ) ( struct dma_chan * chan , dma_addr_t dest , dma_addr_t src , size_t len , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_xor ) ( struct dma_chan * chan , dma_addr_t dest , dma_addr_t * src , unsigned int src_cnt , size_t len , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_xor_val ) ( struct dma_chan * chan , dma_addr_t * src , unsigned int src_cnt , size_t len , enum sum_check_flags * result , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_pq ) ( struct dma_chan * chan , dma_addr_t * dst , dma_addr_t * src , unsigned int src_cnt , const unsigned char * scf , size_t len , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_pq_val ) ( struct dma_chan * chan , dma_addr_t * pq , dma_addr_t * src , unsigned int src_cnt , const unsigned char * scf , size_t len , enum sum_check_flags * pqres , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_memset ) ( struct dma_chan * chan , dma_addr_t dest , int value , size_t len , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_dma_interrupt ) ( struct dma_chan * chan , unsigned long flags ) ; struct dma_async_tx_descriptor * ( * device_prep_slave_sg ) ( struct dma_chan * chan , struct scatterlist * sgl , unsigned int sg_len , enum dma_data_direction direction , unsigned long flags ) ; void ( * device_terminate_all ) ( struct dma_chan * chan ) ; enum dma_status ( * device_is_tx_complete ) ( struct dma_chan * chan , dma_cookie_t cookie , dma_cookie_t * last , dma_cookie_t * used ) ; void ( * device_issue_pending ) ( struct dma_chan * chan ) ; } ;

struct dma_page_list { char * base_address ; int nr_pages ; struct page * * pages ; } ;

struct dma_pinned_list { int nr_iovecs ; struct dma_page_list page_list [ 0 ] ; } ;

struct net_device ;

struct sk_buff_head { struct sk_buff * next ; struct sk_buff * prev ; __u32 qlen ; spinlock_t lock ; } ;

typedef struct skb_frag_struct skb_frag_t ;

struct skb_frag_struct { struct page * page ; __u32 page_offset ; __u32 size ; } ;

struct skb_shared_hwtstamps { ktime_t hwtstamp ; ktime_t syststamp ; } ;

union skb_shared_tx { struct { __u8 hardware : 1 , software : 1 , in_progress : 1 ; } ; __u8 flags ; } ;

struct skb_shared_info { atomic_t dataref ; unsigned short nr_frags ; unsigned short gso_size ; dma_addr_t dma_head ; unsigned short gso_segs ; unsigned short gso_type ; __be32 ip6_frag_id ; union skb_shared_tx tx_flags ; struct sk_buff * frag_list ; struct skb_shared_hwtstamps hwtstamps ; skb_frag_t frags [ ( 65536 / ( ( 1UL ) << 12 ) + 2 ) ] ; dma_addr_t dma_maps [ ( 65536 / ( ( 1UL ) << 12 ) + 2 ) ] ; void * destructor_arg ; } ;

enum { SKB_FCLONE_UNAVAILABLE , SKB_FCLONE_ORIG , SKB_FCLONE_CLONE , } ;
enum { SKB_GSO_TCPV4 = 1 << 0 , SKB_GSO_UDP = 1 << 1 , SKB_GSO_DODGY = 1 << 2 , SKB_GSO_TCP_ECN = 1 << 3 , SKB_GSO_TCPV6 = 1 << 4 , SKB_GSO_FCOE = 1 << 5 , } ;
typedef unsigned int sk_buff_data_t ;

struct sk_buff { struct sk_buff * next ; struct sk_buff * prev ; struct sock * sk ; ktime_t tstamp ; struct net_device * dev ; unsigned long _skb_dst ; char cb [ 48 ] ; unsigned int len , data_len ; __u16 mac_len , hdr_len ; union { __wsum csum ; struct { __u16 csum_start ; __u16 csum_offset ; } ; } ; __u32 priority ; int flags1_begin [ 0 ] ; ; __u8 local_df : 1 , cloned : 1 , ip_summed : 2 , nohdr : 1 , nfctinfo : 3 ; __u8 pkt_type : 3 , fclone : 2 , ipvs_property : 1 , peeked : 1 , nf_trace : 1 ; __be16 protocol : 16 ; int flags1_end [ 0 ] ; ; void ( * destructor ) ( struct sk_buff * skb ) ; int iif ; __u16 tc_index ; __u16 tc_verd ; int flags2_begin [ 0 ] ; ; __u16 queue_mapping : 16 ; int flags2_end [ 0 ] ; ; __u32 secmark ; __u32 mark ; __u16 vlan_tci ; sk_buff_data_t transport_header ; sk_buff_data_t network_header ; sk_buff_data_t mac_header ; sk_buff_data_t tail ; sk_buff_data_t end ; unsigned char * head , * data ; unsigned int truesize ; atomic_t users ; } ;
struct skb_seq_state { __u32 lower_offset ; __u32 upper_offset ; __u32 frag_idx ; __u32 stepped_offset ; struct sk_buff * root_skb ; struct sk_buff * cur_skb ; __u8 * frag_data ; } ;

struct icmp6_filter { __u32 data [ 8 ] ; } ;

typedef struct { unsigned int clock_rate ; unsigned int clock_type ; unsigned short loopback ; } sync_serial_settings ;

typedef struct { unsigned int clock_rate ; unsigned int clock_type ; unsigned short loopback ; unsigned int slot_map ; } te1_settings ;

typedef struct { unsigned short encoding ; unsigned short parity ; } raw_hdlc_proto ;

typedef struct { unsigned int t391 ; unsigned int t392 ; unsigned int n391 ; unsigned int n392 ; unsigned int n393 ; unsigned short lmi ; unsigned short dce ; } fr_proto ;

typedef struct { unsigned int dlci ; } fr_proto_pvc ;

typedef struct { unsigned int dlci ; char master [ 16 ] ; } fr_proto_pvc_info ;

typedef struct { unsigned int interval ; unsigned int timeout ; } cisco_proto ;

enum { IF_OPER_UNKNOWN , IF_OPER_NOTPRESENT , IF_OPER_DOWN , IF_OPER_LOWERLAYERDOWN , IF_OPER_TESTING , IF_OPER_DORMANT , IF_OPER_UP , } ;
enum { IF_LINK_MODE_DEFAULT , IF_LINK_MODE_DORMANT , } ;
struct ifmap { unsigned long mem_start ; unsigned long mem_end ; unsigned short base_addr ; unsigned char irq ; unsigned char dma ; unsigned char port ; } ;

struct if_settings { unsigned int type ; unsigned int size ; union { raw_hdlc_proto * raw_hdlc ; cisco_proto * cisco ; fr_proto * fr ; fr_proto_pvc * fr_pvc ; fr_proto_pvc_info * fr_pvc_info ; sync_serial_settings * sync ; te1_settings * te1 ; } ifs_ifsu ; } ;

struct ifreq { union { char ifrn_name [ 16 ] ; } ifr_ifrn ; union { struct sockaddr ifru_addr ; struct sockaddr ifru_dstaddr ; struct sockaddr ifru_broadaddr ; struct sockaddr ifru_netmask ; struct sockaddr ifru_hwaddr ; short ifru_flags ; int ifru_ivalue ; int ifru_mtu ; struct ifmap ifru_map ; char ifru_slave [ 16 ] ; char ifru_newname [ 16 ] ; void * ifru_data ; struct if_settings ifru_settings ; } ifr_ifru ; } ;

struct ifconf { int ifc_len ; union { char * ifcu_buf ; struct ifreq * ifcu_req ; } ifc_ifcu ; } ;

struct ethhdr { unsigned char h_dest [ 6 ] ; unsigned char h_source [ 6 ] ; __be16 h_proto ; } __attribute__ ( ( packed ) ) ;
struct sockaddr_pkt { unsigned short spkt_family ; unsigned char spkt_device [ 14 ] ; __be16 spkt_protocol ; } ;

struct sockaddr_ll { unsigned short sll_family ; __be16 sll_protocol ; int sll_ifindex ; unsigned short sll_hatype ; unsigned char sll_pkttype ; unsigned char sll_halen ; unsigned char sll_addr [ 8 ] ; } ;

struct tpacket_stats { unsigned int tp_packets ; unsigned int tp_drops ; } ;

struct tpacket_auxdata { __u32 tp_status ; __u32 tp_len ; __u32 tp_snaplen ; __u16 tp_mac ; __u16 tp_net ; __u16 tp_vlan_tci ; } ;

struct tpacket_hdr { unsigned long tp_status ; unsigned int tp_len ; unsigned int tp_snaplen ; unsigned short tp_mac ; unsigned short tp_net ; unsigned int tp_sec ; unsigned int tp_usec ; } ;

struct tpacket2_hdr { __u32 tp_status ; __u32 tp_len ; __u32 tp_snaplen ; __u16 tp_mac ; __u16 tp_net ; __u32 tp_sec ; __u32 tp_nsec ; __u16 tp_vlan_tci ; } ;

enum tpacket_versions { TPACKET_V1 , TPACKET_V2 , } ;

struct tpacket_req { unsigned int tp_block_size ; unsigned int tp_block_nr ; unsigned int tp_frame_size ; unsigned int tp_frame_nr ; } ;

struct packet_mreq { int mr_ifindex ; unsigned short mr_type ; unsigned short mr_alen ; unsigned char mr_address [ 8 ] ; } ;

struct ethtool_cmd { __u32 cmd ; __u32 supported ; __u32 advertising ; __u16 speed ; __u8 duplex ; __u8 port ; __u8 phy_address ; __u8 transceiver ; __u8 autoneg ; __u8 mdio_support ; __u32 maxtxpkt ; __u32 maxrxpkt ; __u16 speed_hi ; __u8 eth_tp_mdix ; __u8 reserved2 ; __u32 lp_advertising ; __u32 reserved [ 2 ] ; } ;

struct ethtool_drvinfo { __u32 cmd ; char driver [ 32 ] ; char version [ 32 ] ; char fw_version [ 32 ] ; char bus_info [ 32 ] ; char reserved1 [ 32 ] ; char reserved2 [ 12 ] ; __u32 n_priv_flags ; __u32 n_stats ; __u32 testinfo_len ; __u32 eedump_len ; __u32 regdump_len ; } ;

struct ethtool_wolinfo { __u32 cmd ; __u32 supported ; __u32 wolopts ; __u8 sopass [ 6 ] ; } ;

struct ethtool_value { __u32 cmd ; __u32 data ; } ;

struct ethtool_regs { __u32 cmd ; __u32 version ; __u32 len ; __u8 data [ 0 ] ; } ;

struct ethtool_eeprom { __u32 cmd ; __u32 magic ; __u32 offset ; __u32 len ; __u8 data [ 0 ] ; } ;

struct ethtool_coalesce { __u32 cmd ; __u32 rx_coalesce_usecs ; __u32 rx_max_coalesced_frames ; __u32 rx_coalesce_usecs_irq ; __u32 rx_max_coalesced_frames_irq ; __u32 tx_coalesce_usecs ; __u32 tx_max_coalesced_frames ; __u32 tx_coalesce_usecs_irq ; __u32 tx_max_coalesced_frames_irq ; __u32 stats_block_coalesce_usecs ; __u32 use_adaptive_rx_coalesce ; __u32 use_adaptive_tx_coalesce ; __u32 pkt_rate_low ; __u32 rx_coalesce_usecs_low ; __u32 rx_max_coalesced_frames_low ; __u32 tx_coalesce_usecs_low ; __u32 tx_max_coalesced_frames_low ; __u32 pkt_rate_high ; __u32 rx_coalesce_usecs_high ; __u32 rx_max_coalesced_frames_high ; __u32 tx_coalesce_usecs_high ; __u32 tx_max_coalesced_frames_high ; __u32 rate_sample_interval ; } ;

struct ethtool_ringparam { __u32 cmd ; __u32 rx_max_pending ; __u32 rx_mini_max_pending ; __u32 rx_jumbo_max_pending ; __u32 tx_max_pending ; __u32 rx_pending ; __u32 rx_mini_pending ; __u32 rx_jumbo_pending ; __u32 tx_pending ; } ;

struct ethtool_pauseparam { __u32 cmd ; __u32 autoneg ; __u32 rx_pause ; __u32 tx_pause ; } ;

enum ethtool_stringset { ETH_SS_TEST = 0 , ETH_SS_STATS , ETH_SS_PRIV_FLAGS , } ;

struct ethtool_gstrings { __u32 cmd ; __u32 string_set ; __u32 len ; __u8 data [ 0 ] ; } ;

enum ethtool_test_flags { ETH_TEST_FL_OFFLINE = ( 1 << 0 ) , ETH_TEST_FL_FAILED = ( 1 << 1 ) , } ;

struct ethtool_test { __u32 cmd ; __u32 flags ; __u32 reserved ; __u32 len ; __u64 data [ 0 ] ; } ;

struct ethtool_stats { __u32 cmd ; __u32 n_stats ; __u64 data [ 0 ] ; } ;

struct ethtool_perm_addr { __u32 cmd ; __u32 size ; __u8 data [ 0 ] ; } ;

enum ethtool_flags { ETH_FLAG_LRO = ( 1 << 15 ) , } ;

struct ethtool_tcpip4_spec { __be32 ip4src ; __be32 ip4dst ; __be16 psrc ; __be16 pdst ; __u8 tos ; } ;

struct ethtool_ah_espip4_spec { __be32 ip4src ; __be32 ip4dst ; __be32 spi ; __u8 tos ; } ;

struct ethtool_rawip4_spec { __be32 ip4src ; __be32 ip4dst ; __u8 hdata [ 64 ] ; } ;

struct ethtool_ether_spec { __be16 ether_type ; __u8 frame_size ; __u8 eframe [ 16 ] ; } ;

struct ethtool_usrip4_spec { __be32 ip4src ; __be32 ip4dst ; __be32 l4_4_bytes ; __u8 tos ; __u8 ip_ver ; __u8 proto ; } ;

struct ethtool_rx_flow_spec { __u32 flow_type ; union { struct ethtool_tcpip4_spec tcp_ip4_spec ; struct ethtool_tcpip4_spec udp_ip4_spec ; struct ethtool_tcpip4_spec sctp_ip4_spec ; struct ethtool_ah_espip4_spec ah_ip4_spec ; struct ethtool_ah_espip4_spec esp_ip4_spec ; struct ethtool_rawip4_spec raw_ip4_spec ; struct ethtool_ether_spec ether_spec ; struct ethtool_usrip4_spec usr_ip4_spec ; __u8 hdata [ 64 ] ; } h_u , m_u ; __u64 ring_cookie ; __u32 location ; } ;

struct ethtool_rxnfc { __u32 cmd ; __u32 flow_type ; __u64 data ; struct ethtool_rx_flow_spec fs ; __u32 rule_cnt ; __u32 rule_locs [ 0 ] ; } ;

enum ethtool_flash_op_type { ETHTOOL_FLASH_ALL_REGIONS = 0 , } ;

struct ethtool_flash { __u32 cmd ; __u32 region ; char data [ 128 ] ; } ;

struct ethtool_ops { int ( * get_settings ) ( struct net_device * , struct ethtool_cmd * ) ; int ( * set_settings ) ( struct net_device * , struct ethtool_cmd * ) ; void ( * get_drvinfo ) ( struct net_device * , struct ethtool_drvinfo * ) ; int ( * get_regs_len ) ( struct net_device * ) ; void ( * get_regs ) ( struct net_device * , struct ethtool_regs * , void * ) ; void ( * get_wol ) ( struct net_device * , struct ethtool_wolinfo * ) ; int ( * set_wol ) ( struct net_device * , struct ethtool_wolinfo * ) ; u32 ( * get_msglevel ) ( struct net_device * ) ; void ( * set_msglevel ) ( struct net_device * , u32 ) ; int ( * nway_reset ) ( struct net_device * ) ; u32 ( * get_link ) ( struct net_device * ) ; int ( * get_eeprom_len ) ( struct net_device * ) ; int ( * get_eeprom ) ( struct net_device * , struct ethtool_eeprom * , u8 * ) ; int ( * set_eeprom ) ( struct net_device * , struct ethtool_eeprom * , u8 * ) ; int ( * get_coalesce ) ( struct net_device * , struct ethtool_coalesce * ) ; int ( * set_coalesce ) ( struct net_device * , struct ethtool_coalesce * ) ; void ( * get_ringparam ) ( struct net_device * , struct ethtool_ringparam * ) ; int ( * set_ringparam ) ( struct net_device * , struct ethtool_ringparam * ) ; void ( * get_pauseparam ) ( struct net_device * , struct ethtool_pauseparam * ) ; int ( * set_pauseparam ) ( struct net_device * , struct ethtool_pauseparam * ) ; u32 ( * get_rx_csum ) ( struct net_device * ) ; int ( * set_rx_csum ) ( struct net_device * , u32 ) ; u32 ( * get_tx_csum ) ( struct net_device * ) ; int ( * set_tx_csum ) ( struct net_device * , u32 ) ; u32 ( * get_sg ) ( struct net_device * ) ; int ( * set_sg ) ( struct net_device * , u32 ) ; u32 ( * get_tso ) ( struct net_device * ) ; int ( * set_tso ) ( struct net_device * , u32 ) ; void ( * self_test ) ( struct net_device * , struct ethtool_test * , u64 * ) ; void ( * get_strings ) ( struct net_device * , u32 stringset , u8 * ) ; int ( * phys_id ) ( struct net_device * , u32 ) ; void ( * get_ethtool_stats ) ( struct net_device * , struct ethtool_stats * , u64 * ) ; int ( * begin ) ( struct net_device * ) ; void ( * complete ) ( struct net_device * ) ; u32 ( * get_ufo ) ( struct net_device * ) ; int ( * set_ufo ) ( struct net_device * , u32 ) ; u32 ( * get_flags ) ( struct net_device * ) ; int ( * set_flags ) ( struct net_device * , u32 ) ; u32 ( * get_priv_flags ) ( struct net_device * ) ; int ( * set_priv_flags ) ( struct net_device * , u32 ) ; int ( * get_sset_count ) ( struct net_device * , int ) ; int ( * self_test_count ) ( struct net_device * ) ; int ( * get_stats_count ) ( struct net_device * ) ; int ( * get_rxnfc ) ( struct net_device * , struct ethtool_rxnfc * , void * ) ; int ( * set_rxnfc ) ( struct net_device * , struct ethtool_rxnfc * ) ; int ( * flash_device ) ( struct net_device * , struct ethtool_flash * ) ; int ( * reset ) ( struct net_device * , u32 * ) ; } ;

enum ethtool_reset_flags { ETH_RESET_MGMT = 1 << 0 , ETH_RESET_IRQ = 1 << 1 , ETH_RESET_DMA = 1 << 2 , ETH_RESET_FILTER = 1 << 3 , ETH_RESET_OFFLOAD = 1 << 4 , ETH_RESET_MAC = 1 << 5 , ETH_RESET_PHY = 1 << 6 , ETH_RESET_RAM = 1 << 7 , ETH_RESET_DEDICATED = 0x0000ffff , ETH_RESET_ALL = 0xffffffff , } ;

struct prot_inuse ;

struct netns_core { struct ctl_table_header * sysctl_hdr ; int sysctl_somaxconn ; struct prot_inuse * inuse ; } ;

enum { IPSTATS_MIB_NUM = 0 , IPSTATS_MIB_INPKTS , IPSTATS_MIB_INHDRERRORS , IPSTATS_MIB_INTOOBIGERRORS , IPSTATS_MIB_INNOROUTES , IPSTATS_MIB_INADDRERRORS , IPSTATS_MIB_INUNKNOWNPROTOS , IPSTATS_MIB_INTRUNCATEDPKTS , IPSTATS_MIB_INDISCARDS , IPSTATS_MIB_INDELIVERS , IPSTATS_MIB_OUTFORWDATAGRAMS , IPSTATS_MIB_OUTPKTS , IPSTATS_MIB_OUTDISCARDS , IPSTATS_MIB_OUTNOROUTES , IPSTATS_MIB_REASMTIMEOUT , IPSTATS_MIB_REASMREQDS , IPSTATS_MIB_REASMOKS , IPSTATS_MIB_REASMFAILS , IPSTATS_MIB_FRAGOKS , IPSTATS_MIB_FRAGFAILS , IPSTATS_MIB_FRAGCREATES , IPSTATS_MIB_INMCASTPKTS , IPSTATS_MIB_OUTMCASTPKTS , IPSTATS_MIB_INBCASTPKTS , IPSTATS_MIB_OUTBCASTPKTS , IPSTATS_MIB_INOCTETS , IPSTATS_MIB_OUTOCTETS , IPSTATS_MIB_INMCASTOCTETS , IPSTATS_MIB_OUTMCASTOCTETS , IPSTATS_MIB_INBCASTOCTETS , IPSTATS_MIB_OUTBCASTOCTETS , __IPSTATS_MIB_MAX } ;
enum { ICMP_MIB_NUM = 0 , ICMP_MIB_INMSGS , ICMP_MIB_INERRORS , ICMP_MIB_INDESTUNREACHS , ICMP_MIB_INTIMEEXCDS , ICMP_MIB_INPARMPROBS , ICMP_MIB_INSRCQUENCHS , ICMP_MIB_INREDIRECTS , ICMP_MIB_INECHOS , ICMP_MIB_INECHOREPS , ICMP_MIB_INTIMESTAMPS , ICMP_MIB_INTIMESTAMPREPS , ICMP_MIB_INADDRMASKS , ICMP_MIB_INADDRMASKREPS , ICMP_MIB_OUTMSGS , ICMP_MIB_OUTERRORS , ICMP_MIB_OUTDESTUNREACHS , ICMP_MIB_OUTTIMEEXCDS , ICMP_MIB_OUTPARMPROBS , ICMP_MIB_OUTSRCQUENCHS , ICMP_MIB_OUTREDIRECTS , ICMP_MIB_OUTECHOS , ICMP_MIB_OUTECHOREPS , ICMP_MIB_OUTTIMESTAMPS , ICMP_MIB_OUTTIMESTAMPREPS , ICMP_MIB_OUTADDRMASKS , ICMP_MIB_OUTADDRMASKREPS , __ICMP_MIB_MAX } ;
enum { ICMP6_MIB_NUM = 0 , ICMP6_MIB_INMSGS , ICMP6_MIB_INERRORS , ICMP6_MIB_OUTMSGS , __ICMP6_MIB_MAX } ;
enum { TCP_MIB_NUM = 0 , TCP_MIB_RTOALGORITHM , TCP_MIB_RTOMIN , TCP_MIB_RTOMAX , TCP_MIB_MAXCONN , TCP_MIB_ACTIVEOPENS , TCP_MIB_PASSIVEOPENS , TCP_MIB_ATTEMPTFAILS , TCP_MIB_ESTABRESETS , TCP_MIB_CURRESTAB , TCP_MIB_INSEGS , TCP_MIB_OUTSEGS , TCP_MIB_RETRANSSEGS , TCP_MIB_INERRS , TCP_MIB_OUTRSTS , __TCP_MIB_MAX } ;
enum { UDP_MIB_NUM = 0 , UDP_MIB_INDATAGRAMS , UDP_MIB_NOPORTS , UDP_MIB_INERRORS , UDP_MIB_OUTDATAGRAMS , UDP_MIB_RCVBUFERRORS , UDP_MIB_SNDBUFERRORS , __UDP_MIB_MAX } ;
enum { LINUX_MIB_NUM = 0 , LINUX_MIB_SYNCOOKIESSENT , LINUX_MIB_SYNCOOKIESRECV , LINUX_MIB_SYNCOOKIESFAILED , LINUX_MIB_EMBRYONICRSTS , LINUX_MIB_PRUNECALLED , LINUX_MIB_RCVPRUNED , LINUX_MIB_OFOPRUNED , LINUX_MIB_OUTOFWINDOWICMPS , LINUX_MIB_LOCKDROPPEDICMPS , LINUX_MIB_ARPFILTER , LINUX_MIB_TIMEWAITED , LINUX_MIB_TIMEWAITRECYCLED , LINUX_MIB_TIMEWAITKILLED , LINUX_MIB_PAWSPASSIVEREJECTED , LINUX_MIB_PAWSACTIVEREJECTED , LINUX_MIB_PAWSESTABREJECTED , LINUX_MIB_DELAYEDACKS , LINUX_MIB_DELAYEDACKLOCKED , LINUX_MIB_DELAYEDACKLOST , LINUX_MIB_LISTENOVERFLOWS , LINUX_MIB_LISTENDROPS , LINUX_MIB_TCPPREQUEUED , LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG , LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE , LINUX_MIB_TCPPREQUEUEDROPPED , LINUX_MIB_TCPHPHITS , LINUX_MIB_TCPHPHITSTOUSER , LINUX_MIB_TCPPUREACKS , LINUX_MIB_TCPHPACKS , LINUX_MIB_TCPRENORECOVERY , LINUX_MIB_TCPSACKRECOVERY , LINUX_MIB_TCPSACKRENEGING , LINUX_MIB_TCPFACKREORDER , LINUX_MIB_TCPSACKREORDER , LINUX_MIB_TCPRENOREORDER , LINUX_MIB_TCPTSREORDER , LINUX_MIB_TCPFULLUNDO , LINUX_MIB_TCPPARTIALUNDO , LINUX_MIB_TCPDSACKUNDO , LINUX_MIB_TCPLOSSUNDO , LINUX_MIB_TCPLOSS , LINUX_MIB_TCPLOSTRETRANSMIT , LINUX_MIB_TCPRENOFAILURES , LINUX_MIB_TCPSACKFAILURES , LINUX_MIB_TCPLOSSFAILURES , LINUX_MIB_TCPFASTRETRANS , LINUX_MIB_TCPFORWARDRETRANS , LINUX_MIB_TCPSLOWSTARTRETRANS , LINUX_MIB_TCPTIMEOUTS , LINUX_MIB_TCPRENORECOVERYFAIL , LINUX_MIB_TCPSACKRECOVERYFAIL , LINUX_MIB_TCPSCHEDULERFAILED , LINUX_MIB_TCPRCVCOLLAPSED , LINUX_MIB_TCPDSACKOLDSENT , LINUX_MIB_TCPDSACKOFOSENT , LINUX_MIB_TCPDSACKRECV , LINUX_MIB_TCPDSACKOFORECV , LINUX_MIB_TCPABORTONSYN , LINUX_MIB_TCPABORTONDATA , LINUX_MIB_TCPABORTONCLOSE , LINUX_MIB_TCPABORTONMEMORY , LINUX_MIB_TCPABORTONTIMEOUT , LINUX_MIB_TCPABORTONLINGER , LINUX_MIB_TCPABORTFAILED , LINUX_MIB_TCPMEMORYPRESSURES , LINUX_MIB_TCPSACKDISCARD , LINUX_MIB_TCPDSACKIGNOREDOLD , LINUX_MIB_TCPDSACKIGNOREDNOUNDO , LINUX_MIB_TCPSPURIOUSRTOS , LINUX_MIB_TCPMD5NOTFOUND , LINUX_MIB_TCPMD5UNEXPECTED , LINUX_MIB_SACKSHIFTED , LINUX_MIB_SACKMERGED , LINUX_MIB_SACKSHIFTFALLBACK , __LINUX_MIB_MAX } ;
enum { LINUX_MIB_XFRMNUM = 0 , LINUX_MIB_XFRMINERROR , LINUX_MIB_XFRMINBUFFERERROR , LINUX_MIB_XFRMINHDRERROR , LINUX_MIB_XFRMINNOSTATES , LINUX_MIB_XFRMINSTATEPROTOERROR , LINUX_MIB_XFRMINSTATEMODEERROR , LINUX_MIB_XFRMINSTATESEQERROR , LINUX_MIB_XFRMINSTATEEXPIRED , LINUX_MIB_XFRMINSTATEMISMATCH , LINUX_MIB_XFRMINSTATEINVALID , LINUX_MIB_XFRMINTMPLMISMATCH , LINUX_MIB_XFRMINNOPOLS , LINUX_MIB_XFRMINPOLBLOCK , LINUX_MIB_XFRMINPOLERROR , LINUX_MIB_XFRMOUTERROR , LINUX_MIB_XFRMOUTBUNDLEGENERROR , LINUX_MIB_XFRMOUTBUNDLECHECKERROR , LINUX_MIB_XFRMOUTNOSTATES , LINUX_MIB_XFRMOUTSTATEPROTOERROR , LINUX_MIB_XFRMOUTSTATEMODEERROR , LINUX_MIB_XFRMOUTSTATESEQERROR , LINUX_MIB_XFRMOUTSTATEEXPIRED , LINUX_MIB_XFRMOUTPOLBLOCK , LINUX_MIB_XFRMOUTPOLDEAD , LINUX_MIB_XFRMOUTPOLERROR , __LINUX_MIB_XFRMMAX } ;
struct snmp_mib { char * name ; int entry ; } ;

struct ipstats_mib { unsigned long mibs [ __IPSTATS_MIB_MAX ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct icmp_mib { unsigned long mibs [ ( __ICMP_MIB_MAX + 1 ) ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct icmpmsg_mib { unsigned long mibs [ 512 ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct icmpv6_mib { unsigned long mibs [ __ICMP6_MIB_MAX ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct icmpv6msg_mib { unsigned long mibs [ 512 ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct tcp_mib { unsigned long mibs [ __TCP_MIB_MAX ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct udp_mib { unsigned long mibs [ __UDP_MIB_MAX ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct linux_mib { unsigned long mibs [ __LINUX_MIB_MAX ] ; } ;

struct linux_xfrm_mib { unsigned long mibs [ __LINUX_MIB_XFRMMAX ] ; } ;

struct netns_mib { __typeof__ ( struct tcp_mib ) * tcp_statistics [ 2 ] ; __typeof__ ( struct ipstats_mib ) * ip_statistics [ 2 ] ; __typeof__ ( struct linux_mib ) * net_statistics [ 2 ] ; __typeof__ ( struct udp_mib ) * udp_statistics [ 2 ] ; __typeof__ ( struct udp_mib ) * udplite_statistics [ 2 ] ; __typeof__ ( struct icmp_mib ) * icmp_statistics [ 2 ] ; __typeof__ ( struct icmpmsg_mib ) * icmpmsg_statistics [ 2 ] ; struct proc_dir_entry * proc_net_devsnmp6 ; __typeof__ ( struct udp_mib ) * udp_stats_in6 [ 2 ] ; __typeof__ ( struct udp_mib ) * udplite_stats_in6 [ 2 ] ; __typeof__ ( struct ipstats_mib ) * ipv6_statistics [ 2 ] ; __typeof__ ( struct icmpv6_mib ) * icmpv6_statistics [ 2 ] ; __typeof__ ( struct icmpv6msg_mib ) * icmpv6msg_statistics [ 2 ] ; } ;

struct netns_unix { int sysctl_max_dgram_qlen ; struct ctl_table_header * ctl ; } ;

struct netns_packet { rwlock_t sklist_lock ; struct hlist_head sklist ; } ;

struct netns_frags { int nqueues ; atomic_t mem ; struct list_head lru_list ; int timeout ; int high_thresh ; int low_thresh ; } ;

struct inet_frag_queue { struct hlist_node list ; struct netns_frags * net ; struct list_head lru_list ; spinlock_t lock ; atomic_t refcnt ; struct timer_list timer ; struct sk_buff * fragments ; ktime_t stamp ; int len ; int meat ; __u8 last_in ; } ;

struct inet_frags { struct hlist_head hash [ 64 ] ; rwlock_t lock ; u32 rnd ; int qsize ; int secret_interval ; struct timer_list secret_timer ; unsigned int ( * hashfn ) ( struct inet_frag_queue * ) ; void ( * constructor ) ( struct inet_frag_queue * q , void * arg ) ; void ( * destructor ) ( struct inet_frag_queue * ) ; void ( * skb_free ) ( struct sk_buff * ) ; int ( * match ) ( struct inet_frag_queue * q , void * arg ) ; void ( * frag_expire ) ( unsigned long data ) ; } ;

struct ipv4_devconf ;

struct fib_rules_ops ;

struct hlist_head ;
struct netns_ipv4 { struct ctl_table_header * forw_hdr ; struct ctl_table_header * frags_hdr ; struct ctl_table_header * ipv4_hdr ; struct ctl_table_header * route_hdr ; struct ipv4_devconf * devconf_all ; struct ipv4_devconf * devconf_dflt ; struct fib_rules_ops * rules_ops ; struct hlist_head * fib_table_hash ; struct sock * fibnl ; struct sock * * icmp_sk ; struct sock * tcp_sock ; struct netns_frags frags ; struct xt_table * iptable_filter ; struct xt_table * iptable_mangle ; struct xt_table * iptable_raw ; struct xt_table * arptable_filter ; struct xt_table * iptable_security ; struct xt_table * nat_table ; struct hlist_head * nat_bysource ; unsigned int nat_htable_size ; int nat_vmalloced ; int sysctl_icmp_echo_ignore_all ; int sysctl_icmp_echo_ignore_broadcasts ; int sysctl_icmp_ignore_bogus_error_responses ; int sysctl_icmp_ratelimit ; int sysctl_icmp_ratemask ; int sysctl_icmp_errors_use_inbound_ifaddr ; int sysctl_rt_cache_rebuild_count ; int current_rt_cache_rebuild_count ; struct timer_list rt_secret_timer ; atomic_t rt_genid ; struct sock * mroute_sk ; struct mfc_cache * * mfc_cache_array ; struct vif_device * vif_table ; int maxvif ; atomic_t cache_resolve_queue_len ; int mroute_do_assert ; int mroute_do_pim ; int mroute_reg_vif_num ; } ;

struct kmem_cachep ;

struct dst_ops { unsigned short family ; __be16 protocol ; unsigned gc_thresh ; int ( * gc ) ( struct dst_ops * ops ) ; struct dst_entry * ( * check ) ( struct dst_entry * , __u32 cookie ) ; void ( * destroy ) ( struct dst_entry * ) ; void ( * ifdown ) ( struct dst_entry * , struct net_device * dev , int how ) ; struct dst_entry * ( * negative_advice ) ( struct dst_entry * ) ; void ( * link_failure ) ( struct sk_buff * ) ; void ( * update_pmtu ) ( struct dst_entry * dst , u32 mtu ) ; int ( * local_out ) ( struct sk_buff * skb ) ; atomic_t entries ; struct kmem_cache * kmem_cachep ; } ;

struct netns_sysctl_ipv6 { struct ctl_table_header * table ; struct ctl_table_header * frags_hdr ; int bindv6only ; int flush_delay ; int ip6_rt_max_size ; int ip6_rt_gc_min_interval ; int ip6_rt_gc_timeout ; int ip6_rt_gc_interval ; int ip6_rt_gc_elasticity ; int ip6_rt_mtu_expires ; int ip6_rt_min_advmss ; int icmpv6_time ; } ;

struct netns_ipv6 { struct netns_sysctl_ipv6 sysctl ; struct ipv6_devconf * devconf_all ; struct ipv6_devconf * devconf_dflt ; struct netns_frags frags ; struct xt_table * ip6table_filter ; struct xt_table * ip6table_mangle ; struct xt_table * ip6table_raw ; struct xt_table * ip6table_security ; struct rt6_info * ip6_null_entry ; struct rt6_statistics * rt6_stats ; struct timer_list ip6_fib_timer ; struct hlist_head * fib_table_hash ; struct fib6_table * fib6_main_tbl ; struct dst_ops ip6_dst_ops ; unsigned int ip6_rt_gc_expire ; unsigned long ip6_rt_last_gc ; struct rt6_info * ip6_prohibit_entry ; struct rt6_info * ip6_blk_hole_entry ; struct fib6_table * fib6_local_tbl ; struct fib_rules_ops * fib6_rules_ops ; struct sock * * icmp_sk ; struct sock * ndisc_sk ; struct sock * tcp_sk ; struct sock * igmp_sk ; } ;

struct netns_dccp { struct sock * v4_ctl_sk ; struct sock * v6_ctl_sk ; } ;

enum nf_inet_hooks { NF_INET_PRE_ROUTING , NF_INET_LOCAL_IN , NF_INET_FORWARD , NF_INET_LOCAL_OUT , NF_INET_POST_ROUTING , NF_INET_NUMHOOKS } ;

enum { NFPROTO_UNSPEC = 0 , NFPROTO_IPV4 = 2 , NFPROTO_ARP = 3 , NFPROTO_BRIDGE = 7 , NFPROTO_IPV6 = 10 , NFPROTO_DECNET = 12 , NFPROTO_NUMPROTO , } ;
union nf_inet_addr { __u32 all [ 4 ] ; __be32 ip ; __be32 ip6 [ 4 ] ; struct in_addr in ; struct in6_addr in6 ; } ;

typedef unsigned int nf_hookfn ( unsigned int hooknum , struct sk_buff * skb , const struct net_device * in , const struct net_device * out , int ( * okfn ) ( struct sk_buff * ) ) ;

struct nf_hook_ops { struct list_head list ; nf_hookfn * hook ; struct module * owner ; u_int8_t pf ; unsigned int hooknum ; int priority ; } ;

struct nf_sockopt_ops { struct list_head list ; u_int8_t pf ; int set_optmin ; int set_optmax ; int ( * set ) ( struct sock * sk , int optval , void * user , unsigned int len ) ; int ( * compat_set ) ( struct sock * sk , int optval , void * user , unsigned int len ) ; int get_optmin ; int get_optmax ; int ( * get ) ( struct sock * sk , int optval , void * user , int * len ) ; int ( * compat_get ) ( struct sock * sk , int optval , void * user , int * len ) ; struct module * owner ; } ;

struct nf_queue_entry ;

struct nf_afinfo { unsigned short family ; __sum16 ( * checksum ) ( struct sk_buff * skb , unsigned int hook , unsigned int dataoff , u_int8_t protocol ) ; __sum16 ( * checksum_partial ) ( struct sk_buff * skb , unsigned int hook , unsigned int dataoff , unsigned int len , u_int8_t protocol ) ; int ( * route ) ( struct dst_entry * * dst , struct flowi * fl ) ; void ( * saveroute ) ( const struct sk_buff * skb , struct nf_queue_entry * entry ) ; int ( * reroute ) ( struct sk_buff * skb , const struct nf_queue_entry * entry ) ; int route_key_size ; } ;

struct ebt_table ;

struct netns_xt { struct list_head tables [ NFPROTO_NUMPROTO ] ; } ;

struct xfrm_policy_hash { struct hlist_head * table ; unsigned int hmask ; } ;

struct netns_xfrm { struct list_head state_all ; struct hlist_head * state_bydst ; struct hlist_head * state_bysrc ; struct hlist_head * state_byspi ; unsigned int state_hmask ; unsigned int state_num ; struct work_struct state_hash_work ; struct hlist_head state_gc_list ; struct work_struct state_gc_work ; wait_queue_head_t km_waitq ; struct list_head policy_all ; struct hlist_head * policy_byidx ; unsigned int policy_idx_hmask ; struct hlist_head policy_inexact [ XFRM_POLICY_MAX * 2 ] ; struct xfrm_policy_hash policy_bydst [ XFRM_POLICY_MAX * 2 ] ; unsigned int policy_count [ XFRM_POLICY_MAX * 2 ] ; struct work_struct policy_hash_work ; struct sock * nlsk ; u32 sysctl_aevent_etime ; u32 sysctl_aevent_rseqth ; int sysctl_larval_drop ; u32 sysctl_acq_expires ; struct ctl_table_header * sysctl_hdr ; } ;

struct net_generic ;

struct net { atomic_t count ; struct list_head list ; struct work_struct work ; struct proc_dir_entry * proc_net ; struct proc_dir_entry * proc_net_stat ; struct ctl_table_set sysctls ; struct net_device * loopback_dev ; struct list_head dev_base_head ; struct hlist_head * dev_name_head ; struct hlist_head * dev_index_head ; struct list_head rules_ops ; spinlock_t rules_mod_lock ; struct sock * rtnl ; struct sock * genl_sock ; struct netns_core core ; struct netns_mib mib ; struct netns_packet packet ; struct netns_unix unx ; struct netns_ipv4 ipv4 ; struct netns_ipv6 ipv6 ; struct netns_xt xt ; struct sk_buff_head wext_nlevents ; struct net_generic * gen ; } ;
struct seq_net_private { struct net * net ; } ;

struct pernet_operations { struct list_head list ; int ( * init ) ( struct net * net ) ; void ( * exit ) ( struct net * net ) ; } ;

struct ctl_path ;
struct dsa_chip_data { struct device * mii_bus ; int sw_addr ; char * port_names [ 12 ] ; s8 * rtable ; } ;

struct dsa_platform_data { struct device * netdev ; int nr_chips ; struct dsa_chip_data * chip ; } ;

struct dcbnl_rtnl_ops { u8 ( * getstate ) ( struct net_device * ) ; u8 ( * setstate ) ( struct net_device * , u8 ) ; void ( * getpermhwaddr ) ( struct net_device * , u8 * ) ; void ( * setpgtccfgtx ) ( struct net_device * , int , u8 , u8 , u8 , u8 ) ; void ( * setpgbwgcfgtx ) ( struct net_device * , int , u8 ) ; void ( * setpgtccfgrx ) ( struct net_device * , int , u8 , u8 , u8 , u8 ) ; void ( * setpgbwgcfgrx ) ( struct net_device * , int , u8 ) ; void ( * getpgtccfgtx ) ( struct net_device * , int , u8 * , u8 * , u8 * , u8 * ) ; void ( * getpgbwgcfgtx ) ( struct net_device * , int , u8 * ) ; void ( * getpgtccfgrx ) ( struct net_device * , int , u8 * , u8 * , u8 * , u8 * ) ; void ( * getpgbwgcfgrx ) ( struct net_device * , int , u8 * ) ; void ( * setpfccfg ) ( struct net_device * , int , u8 ) ; void ( * getpfccfg ) ( struct net_device * , int , u8 * ) ; u8 ( * setall ) ( struct net_device * ) ; u8 ( * getcap ) ( struct net_device * , int , u8 * ) ; u8 ( * getnumtcs ) ( struct net_device * , int , u8 * ) ; u8 ( * setnumtcs ) ( struct net_device * , int , u8 ) ; u8 ( * getpfcstate ) ( struct net_device * ) ; void ( * setpfcstate ) ( struct net_device * , u8 ) ; void ( * getbcncfg ) ( struct net_device * , int , u32 * ) ; void ( * setbcncfg ) ( struct net_device * , int , u32 ) ; void ( * getbcnrp ) ( struct net_device * , int , u8 * ) ; void ( * setbcnrp ) ( struct net_device * , int , u8 ) ; u8 ( * setapp ) ( struct net_device * , u8 , u16 , u8 ) ; u8 ( * getapp ) ( struct net_device * , u8 , u16 ) ; } ;

struct vlan_group ;

struct netpoll_info ;

struct wireless_dev ;

enum netdev_tx { NETDEV_TX_OK = 0 , NETDEV_TX_BUSY , NETDEV_TX_LOCKED = - 1 , } ;

typedef enum netdev_tx netdev_tx_t ;

struct net_device_stats { unsigned long rx_packets ; unsigned long tx_packets ; unsigned long rx_bytes ; unsigned long tx_bytes ; unsigned long rx_errors ; unsigned long tx_errors ; unsigned long rx_dropped ; unsigned long tx_dropped ; unsigned long multicast ; unsigned long collisions ; unsigned long rx_length_errors ; unsigned long rx_over_errors ; unsigned long rx_crc_errors ; unsigned long rx_frame_errors ; unsigned long rx_fifo_errors ; unsigned long rx_missed_errors ; unsigned long tx_aborted_errors ; unsigned long tx_carrier_errors ; unsigned long tx_fifo_errors ; unsigned long tx_heartbeat_errors ; unsigned long tx_window_errors ; unsigned long rx_compressed ; unsigned long tx_compressed ; } ;

enum { IF_PORT_UNKNOWN = 0 , IF_PORT_10BASE2 , IF_PORT_10BASET , IF_PORT_AUI , IF_PORT_100BASET , IF_PORT_100BASETX , IF_PORT_100BASEFX } ;
struct neighbour ;

struct neigh_parms ;

struct netif_rx_stats { unsigned total ; unsigned dropped ; unsigned time_squeeze ; unsigned cpu_collision ; } ;

struct dev_addr_list { struct dev_addr_list * next ; u8 da_addr [ 32 ] ; u8 da_addrlen ; u8 da_synced ; int da_users ; int da_gusers ; } ;

struct netdev_hw_addr { struct list_head list ; unsigned char addr [ 32 ] ; unsigned char type ; int refcount ; bool synced ; struct rcu_head rcu_head ; } ;

struct netdev_hw_addr_list { struct list_head list ; int count ; } ;

struct hh_cache { struct hh_cache * hh_next ; atomic_t hh_refcnt ; __be16 hh_type __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; u16 hh_len ; int ( * hh_output ) ( struct sk_buff * skb ) ; seqlock_t hh_lock ; unsigned long hh_data [ ( ( ( 96 ) + ( 16 - 1 ) ) & ~ ( 16 - 1 ) ) / sizeof ( long ) ] ; } ;

struct header_ops { int ( * create ) ( struct sk_buff * skb , struct net_device * dev , unsigned short type , const void * daddr , const void * saddr , unsigned len ) ; int ( * parse ) ( const struct sk_buff * skb , unsigned char * haddr ) ; int ( * rebuild ) ( struct sk_buff * skb ) ; int ( * cache ) ( const struct neighbour * neigh , struct hh_cache * hh ) ; void ( * cache_update ) ( struct hh_cache * hh , const struct net_device * dev , const unsigned char * haddr ) ; } ;

enum netdev_state_t { __LINK_STATE_START , __LINK_STATE_PRESENT , __LINK_STATE_NOCARRIER , __LINK_STATE_LINKWATCH_PENDING , __LINK_STATE_DORMANT , } ;

struct netdev_boot_setup { char name [ 16 ] ; struct ifmap map ; } ;

struct napi_struct { struct list_head poll_list ; unsigned long state ; int weight ; int ( * poll ) ( struct napi_struct * , int ) ; unsigned int gro_count ; struct net_device * dev ; struct list_head dev_list ; struct sk_buff * gro_list ; struct sk_buff * skb ; } ;

enum { NAPI_STATE_SCHED , NAPI_STATE_DISABLE , NAPI_STATE_NPSVC , } ;
enum gro_result { GRO_MERGED , GRO_MERGED_FREE , GRO_HELD , GRO_NORMAL , GRO_DROP , } ;

typedef enum gro_result gro_result_t ;

enum netdev_queue_state_t { __QUEUE_STATE_XOFF , __QUEUE_STATE_FROZEN , } ;

struct netdev_queue { struct net_device * dev ; struct Qdisc * qdisc ; unsigned long state ; struct Qdisc * qdisc_sleeping ; spinlock_t _xmit_lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; int xmit_lock_owner ; unsigned long trans_start ; unsigned long tx_bytes ; unsigned long tx_packets ; unsigned long tx_dropped ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct net_device_ops { int ( * ndo_init ) ( struct net_device * dev ) ; void ( * ndo_uninit ) ( struct net_device * dev ) ; int ( * ndo_open ) ( struct net_device * dev ) ; int ( * ndo_stop ) ( struct net_device * dev ) ; netdev_tx_t ( * ndo_start_xmit ) ( struct sk_buff * skb , struct net_device * dev ) ; u16 ( * ndo_select_queue ) ( struct net_device * dev , struct sk_buff * skb ) ; void ( * ndo_change_rx_flags ) ( struct net_device * dev , int flags ) ; void ( * ndo_set_rx_mode ) ( struct net_device * dev ) ; void ( * ndo_set_multicast_list ) ( struct net_device * dev ) ; int ( * ndo_set_mac_address ) ( struct net_device * dev , void * addr ) ; int ( * ndo_validate_addr ) ( struct net_device * dev ) ; int ( * ndo_do_ioctl ) ( struct net_device * dev , struct ifreq * ifr , int cmd ) ; int ( * ndo_set_config ) ( struct net_device * dev , struct ifmap * map ) ; int ( * ndo_change_mtu ) ( struct net_device * dev , int new_mtu ) ; int ( * ndo_neigh_setup ) ( struct net_device * dev , struct neigh_parms * ) ; void ( * ndo_tx_timeout ) ( struct net_device * dev ) ; struct net_device_stats * ( * ndo_get_stats ) ( struct net_device * dev ) ; void ( * ndo_vlan_rx_register ) ( struct net_device * dev , struct vlan_group * grp ) ; void ( * ndo_vlan_rx_add_vid ) ( struct net_device * dev , unsigned short vid ) ; void ( * ndo_vlan_rx_kill_vid ) ( struct net_device * dev , unsigned short vid ) ; } ;

struct net_device { char name [ 16 ] ; struct hlist_node name_hlist ; char * ifalias ; unsigned long mem_end ; unsigned long mem_start ; unsigned long base_addr ; unsigned int irq ; unsigned char if_port ; unsigned char dma ; unsigned long state ; struct list_head dev_list ; struct list_head napi_list ; unsigned long features ; int ifindex ; int iflink ; struct net_device_stats stats ; const struct iw_handler_def * wireless_handlers ; struct iw_public_data * wireless_data ; const struct net_device_ops * netdev_ops ; const struct ethtool_ops * ethtool_ops ; const struct header_ops * header_ops ; unsigned int flags ; unsigned short gflags ; unsigned short priv_flags ; unsigned short padded ; unsigned char operstate ; unsigned char link_mode ; unsigned mtu ; unsigned short type ; unsigned short hard_header_len ; unsigned short needed_headroom ; unsigned short needed_tailroom ; struct net_device * master ; unsigned char perm_addr [ 32 ] ; unsigned char addr_len ; unsigned short dev_id ; struct netdev_hw_addr_list uc ; int uc_promisc ; spinlock_t addr_list_lock ; struct dev_addr_list * mc_list ; int mc_count ; unsigned int promiscuity ; unsigned int allmulti ; void * dsa_ptr ; void * atalk_ptr ; void * ip_ptr ; void * dn_ptr ; void * ip6_ptr ; void * ec_ptr ; void * ax25_ptr ; struct wireless_dev * ieee80211_ptr ; unsigned long last_rx ; unsigned char * dev_addr ; struct netdev_hw_addr_list dev_addrs ; unsigned char broadcast [ 32 ] ; struct netdev_queue rx_queue ; struct netdev_queue * _tx __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; unsigned int num_tx_queues ; unsigned int real_num_tx_queues ; struct Qdisc * qdisc ; unsigned long tx_queue_len ; spinlock_t tx_global_lock ; unsigned long trans_start ; int watchdog_timeo ; struct timer_list watchdog_timer ; atomic_t refcnt __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; struct list_head todo_list ; struct hlist_node index_hlist ; struct net_device * link_watch_next ; enum { NETREG_UNINITIALIZED = 0 , NETREG_REGISTERED , NETREG_UNREGISTERING , NETREG_UNREGISTERED , NETREG_RELEASED , NETREG_DUMMY , } reg_state ; void ( * destructor ) ( struct net_device * dev ) ; struct net * nd_net ; void * ml_priv ; struct net_bridge_port * br_port ; struct macvlan_port * macvlan_port ; struct garp_port * garp_port ; struct device dev ; const struct attribute_group * sysfs_groups [ 3 ] ; const struct rtnl_link_ops * rtnl_link_ops ; unsigned long vlan_features ; unsigned int gso_max_size ; struct dcbnl_rtnl_ops * dcbnl_ops ; } ;
struct napi_gro_cb { void * frag0 ; unsigned int frag0_len ; int data_offset ; int same_flow ; int flush ; int count ; int free ; } ;

struct packet_type { __be16 type ; struct net_device * dev ; int ( * func ) ( struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ; struct sk_buff * ( * gso_segment ) ( struct sk_buff * skb , int features ) ; int ( * gso_send_check ) ( struct sk_buff * skb ) ; struct sk_buff * * ( * gro_receive ) ( struct sk_buff * * head , struct sk_buff * skb ) ; int ( * gro_complete ) ( struct sk_buff * skb ) ; void * af_packet_priv ; struct list_head list ; } ;

typedef int gifconf_func_t ( struct net_device * dev , char * bufptr , int len ) ;

struct softnet_data { struct Qdisc * output_queue ; struct sk_buff_head input_pkt_queue ; struct list_head poll_list ; struct sk_buff * completion_queue ; struct napi_struct backlog ; } ;

enum { NETIF_MSG_DRV = 0x0001 , NETIF_MSG_PROBE = 0x0002 , NETIF_MSG_LINK = 0x0004 , NETIF_MSG_TIMER = 0x0008 , NETIF_MSG_IFDOWN = 0x0010 , NETIF_MSG_IFUP = 0x0020 , NETIF_MSG_RX_ERR = 0x0040 , NETIF_MSG_TX_ERR = 0x0080 , NETIF_MSG_TX_QUEUED = 0x0100 , NETIF_MSG_INTR = 0x0200 , NETIF_MSG_TX_DONE = 0x0400 , NETIF_MSG_RX_STATUS = 0x0800 , NETIF_MSG_PKTDATA = 0x1000 , NETIF_MSG_HW = 0x2000 , NETIF_MSG_WOL = 0x4000 , } ;
struct tcphdr { __be16 source ; __be16 dest ; __be32 seq ; __be32 ack_seq ; __u16 res1 : 4 , doff : 4 , fin : 1 , syn : 1 , rst : 1 , psh : 1 , ack : 1 , urg : 1 , ece : 1 , cwr : 1 ; __be16 window ; __sum16 check ; __be16 urg_ptr ; } ;

union tcp_word_hdr { struct tcphdr hdr ; __be32 words [ 5 ] ; } ;

enum { TCP_FLAG_CWR = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0x00800000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00800000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00800000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00800000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00800000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0x00800000 ) ) ) ) , TCP_FLAG_ECE = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0x00400000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00400000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00400000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00400000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00400000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0x00400000 ) ) ) ) , TCP_FLAG_URG = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0x00200000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00200000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00200000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00200000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00200000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0x00200000 ) ) ) ) , TCP_FLAG_ACK = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0x00100000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00100000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00100000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00100000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00100000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0x00100000 ) ) ) ) , TCP_FLAG_PSH = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0x00080000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00080000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00080000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00080000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00080000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0x00080000 ) ) ) ) , TCP_FLAG_RST = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0x00040000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00040000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00040000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00040000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00040000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0x00040000 ) ) ) ) , TCP_FLAG_SYN = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0x00020000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00020000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00020000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00020000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00020000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0x00020000 ) ) ) ) , TCP_FLAG_FIN = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0x00010000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x00010000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x00010000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x00010000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x00010000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0x00010000 ) ) ) ) , TCP_RESERVED_BITS = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0x0F000000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0x0F000000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0x0F000000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0x0F000000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0x0F000000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0x0F000000 ) ) ) ) , TCP_DATA_OFFSET = ( ( __be32 ) ( __builtin_constant_p ( ( __u32 ) ( ( 0xF0000000 ) ) ) ? ( ( __u32 ) ( ( ( ( __u32 ) ( ( 0xF0000000 ) ) & ( __u32 ) 0x000000ffUL ) << 24 ) | ( ( ( __u32 ) ( ( 0xF0000000 ) ) & ( __u32 ) 0x0000ff00UL ) << 8 ) | ( ( ( __u32 ) ( ( 0xF0000000 ) ) & ( __u32 ) 0x00ff0000UL ) >> 8 ) | ( ( ( __u32 ) ( ( 0xF0000000 ) ) & ( __u32 ) 0xff000000UL ) >> 24 ) ) ) : __fswab32 ( ( 0xF0000000 ) ) ) ) } ;
enum tcp_ca_state { TCP_CA_Open = 0 , TCP_CA_Disorder = 1 , TCP_CA_CWR = 2 , TCP_CA_Recovery = 3 , TCP_CA_Loss = 4 } ;

struct tcp_info { __u8 tcpi_state ; __u8 tcpi_ca_state ; __u8 tcpi_retransmits ; __u8 tcpi_probes ; __u8 tcpi_backoff ; __u8 tcpi_options ; __u8 tcpi_snd_wscale : 4 , tcpi_rcv_wscale : 4 ; __u32 tcpi_rto ; __u32 tcpi_ato ; __u32 tcpi_snd_mss ; __u32 tcpi_rcv_mss ; __u32 tcpi_unacked ; __u32 tcpi_sacked ; __u32 tcpi_lost ; __u32 tcpi_retrans ; __u32 tcpi_fackets ; __u32 tcpi_last_data_sent ; __u32 tcpi_last_ack_sent ; __u32 tcpi_last_data_recv ; __u32 tcpi_last_ack_recv ; __u32 tcpi_pmtu ; __u32 tcpi_rcv_ssthresh ; __u32 tcpi_rtt ; __u32 tcpi_rttvar ; __u32 tcpi_snd_ssthresh ; __u32 tcpi_snd_cwnd ; __u32 tcpi_advmss ; __u32 tcpi_reordering ; __u32 tcpi_rcv_rtt ; __u32 tcpi_rcv_space ; __u32 tcpi_total_retrans ; } ;

struct tcp_md5sig { struct __kernel_sockaddr_storage tcpm_addr ; __u16 __tcpm_pad1 ; __u16 tcpm_keylen ; __u32 __tcpm_pad2 ; __u8 tcpm_key [ 80 ] ; } ;

struct hlist_nulls_head { struct hlist_nulls_node * first ; } ;

struct hlist_nulls_node { struct hlist_nulls_node * next , * * pprev ; } ;

struct sock_filter { __u16 code ; __u8 jt ; __u8 jf ; __u32 k ; } ;

struct sock_fprog { unsigned short len ; struct sock_filter * filter ; } ;

struct sk_filter { atomic_t refcnt ; unsigned int len ; struct rcu_head rcu ; struct sock_filter insns [ 0 ] ; } ;

struct sockaddr_nl { sa_family_t nl_family ; unsigned short nl_pad ; __u32 nl_pid ; __u32 nl_groups ; } ;

struct nlmsghdr { __u32 nlmsg_len ; __u16 nlmsg_type ; __u16 nlmsg_flags ; __u32 nlmsg_seq ; __u32 nlmsg_pid ; } ;

struct nlmsgerr { int error ; struct nlmsghdr msg ; } ;

struct nl_pktinfo { __u32 group ; } ;

enum { NETLINK_UNCONNECTED = 0 , NETLINK_CONNECTED , } ;
struct nlattr { __u16 nla_len ; __u16 nla_type ; } ;

struct netlink_skb_parms { struct ucred creds ; __u32 pid ; __u32 dst_group ; kernel_cap_t eff_cap ; __u32 loginuid ; __u32 sessionid ; __u32 sid ; } ;

struct netlink_callback { struct sk_buff * skb ; const struct nlmsghdr * nlh ; int ( * dump ) ( struct sk_buff * skb , struct netlink_callback * cb ) ; int ( * done ) ( struct netlink_callback * cb ) ; int family ; long args [ 6 ] ; } ;

struct netlink_notify { struct net * net ; int pid ; int protocol ; } ;

struct rtnl_link_stats { __u32 rx_packets ; __u32 tx_packets ; __u32 rx_bytes ; __u32 tx_bytes ; __u32 rx_errors ; __u32 tx_errors ; __u32 rx_dropped ; __u32 tx_dropped ; __u32 multicast ; __u32 collisions ; __u32 rx_length_errors ; __u32 rx_over_errors ; __u32 rx_crc_errors ; __u32 rx_frame_errors ; __u32 rx_fifo_errors ; __u32 rx_missed_errors ; __u32 tx_aborted_errors ; __u32 tx_carrier_errors ; __u32 tx_fifo_errors ; __u32 tx_heartbeat_errors ; __u32 tx_window_errors ; __u32 rx_compressed ; __u32 tx_compressed ; } ;

struct rtnl_link_ifmap { __u64 mem_start ; __u64 mem_end ; __u64 base_addr ; __u16 irq ; __u8 dma ; __u8 port ; } ;

enum { IFLA_UNSPEC , IFLA_ADDRESS , IFLA_BROADCAST , IFLA_IFNAME , IFLA_MTU , IFLA_LINK , IFLA_QDISC , IFLA_STATS , IFLA_COST , IFLA_PRIORITY , IFLA_MASTER , IFLA_WIRELESS , IFLA_PROTINFO , IFLA_TXQLEN , IFLA_MAP , IFLA_WEIGHT , IFLA_OPERSTATE , IFLA_LINKMODE , IFLA_LINKINFO , IFLA_NET_NS_PID , IFLA_IFALIAS , __IFLA_MAX } ;
enum { IFLA_INET6_UNSPEC , IFLA_INET6_FLAGS , IFLA_INET6_CONF , IFLA_INET6_STATS , IFLA_INET6_MCAST , IFLA_INET6_CACHEINFO , IFLA_INET6_ICMP6STATS , __IFLA_INET6_MAX } ;
struct ifla_cacheinfo { __u32 max_reasm_len ; __u32 tstamp ; __u32 reachable_time ; __u32 retrans_time ; } ;

enum { IFLA_INFO_UNSPEC , IFLA_INFO_KIND , IFLA_INFO_DATA , IFLA_INFO_XSTATS , __IFLA_INFO_MAX , } ;
enum { IFLA_VLAN_UNSPEC , IFLA_VLAN_ID , IFLA_VLAN_FLAGS , IFLA_VLAN_EGRESS_QOS , IFLA_VLAN_INGRESS_QOS , __IFLA_VLAN_MAX , } ;
struct ifla_vlan_flags { __u32 flags ; __u32 mask ; } ;

enum { IFLA_VLAN_QOS_UNSPEC , IFLA_VLAN_QOS_MAPPING , __IFLA_VLAN_QOS_MAX } ;
struct ifla_vlan_qos_mapping { __u32 from ; __u32 to ; } ;

struct ifaddrmsg { __u8 ifa_family ; __u8 ifa_prefixlen ; __u8 ifa_flags ; __u8 ifa_scope ; __u32 ifa_index ; } ;

enum { IFA_UNSPEC , IFA_ADDRESS , IFA_LOCAL , IFA_LABEL , IFA_BROADCAST , IFA_ANYCAST , IFA_CACHEINFO , IFA_MULTICAST , __IFA_MAX , } ;
struct ifa_cacheinfo { __u32 ifa_prefered ; __u32 ifa_valid ; __u32 cstamp ; __u32 tstamp ; } ;

struct ndmsg { __u8 ndm_family ; __u8 ndm_pad1 ; __u16 ndm_pad2 ; __s32 ndm_ifindex ; __u16 ndm_state ; __u8 ndm_flags ; __u8 ndm_type ; } ;

enum { NDA_UNSPEC , NDA_DST , NDA_LLADDR , NDA_CACHEINFO , NDA_PROBES , __NDA_MAX } ;
struct nda_cacheinfo { __u32 ndm_confirmed ; __u32 ndm_used ; __u32 ndm_updated ; __u32 ndm_refcnt ; } ;

struct ndt_stats { __u64 ndts_allocs ; __u64 ndts_destroys ; __u64 ndts_hash_grows ; __u64 ndts_res_failed ; __u64 ndts_lookups ; __u64 ndts_hits ; __u64 ndts_rcv_probes_mcast ; __u64 ndts_rcv_probes_ucast ; __u64 ndts_periodic_gc_runs ; __u64 ndts_forced_gc_runs ; } ;

enum { NDTPA_UNSPEC , NDTPA_IFINDEX , NDTPA_REFCNT , NDTPA_REACHABLE_TIME , NDTPA_BASE_REACHABLE_TIME , NDTPA_RETRANS_TIME , NDTPA_GC_STALETIME , NDTPA_DELAY_PROBE_TIME , NDTPA_QUEUE_LEN , NDTPA_APP_PROBES , NDTPA_UCAST_PROBES , NDTPA_MCAST_PROBES , NDTPA_ANYCAST_DELAY , NDTPA_PROXY_DELAY , NDTPA_PROXY_QLEN , NDTPA_LOCKTIME , __NDTPA_MAX } ;
struct ndtmsg { __u8 ndtm_family ; __u8 ndtm_pad1 ; __u16 ndtm_pad2 ; } ;

struct ndt_config { __u16 ndtc_key_len ; __u16 ndtc_entry_size ; __u32 ndtc_entries ; __u32 ndtc_last_flush ; __u32 ndtc_last_rand ; __u32 ndtc_hash_rnd ; __u32 ndtc_hash_mask ; __u32 ndtc_hash_chain_gc ; __u32 ndtc_proxy_qlen ; } ;

enum { NDTA_UNSPEC , NDTA_NAME , NDTA_THRESH1 , NDTA_THRESH2 , NDTA_THRESH3 , NDTA_CONFIG , NDTA_PARMS , NDTA_STATS , NDTA_GC_INTERVAL , __NDTA_MAX } ;
enum { RTM_BASE = 16 , RTM_NEWLINK = 16 , RTM_DELLINK , RTM_GETLINK , RTM_SETLINK , RTM_NEWADDR = 20 , RTM_DELADDR , RTM_GETADDR , RTM_NEWROUTE = 24 , RTM_DELROUTE , RTM_GETROUTE , RTM_NEWNEIGH = 28 , RTM_DELNEIGH , RTM_GETNEIGH , RTM_NEWRULE = 32 , RTM_DELRULE , RTM_GETRULE , RTM_NEWQDISC = 36 , RTM_DELQDISC , RTM_GETQDISC , RTM_NEWTCLASS = 40 , RTM_DELTCLASS , RTM_GETTCLASS , RTM_NEWTFILTER = 44 , RTM_DELTFILTER , RTM_GETTFILTER , RTM_NEWACTION = 48 , RTM_DELACTION , RTM_GETACTION , RTM_NEWPREFIX = 52 , RTM_GETMULTICAST = 58 , RTM_GETANYCAST = 62 , RTM_NEWNEIGHTBL = 64 , RTM_GETNEIGHTBL = 66 , RTM_SETNEIGHTBL , RTM_NEWNDUSEROPT = 68 , RTM_NEWADDRLABEL = 72 , RTM_DELADDRLABEL , RTM_GETADDRLABEL , RTM_GETDCB = 78 , RTM_SETDCB , __RTM_MAX , } ;
struct rtattr { unsigned short rta_len ; unsigned short rta_type ; } ;

struct rtmsg { unsigned char rtm_family ; unsigned char rtm_dst_len ; unsigned char rtm_src_len ; unsigned char rtm_tos ; unsigned char rtm_table ; unsigned char rtm_protocol ; unsigned char rtm_scope ; unsigned char rtm_type ; unsigned rtm_flags ; } ;

enum { RTN_UNSPEC , RTN_UNICAST , RTN_LOCAL , RTN_BROADCAST , RTN_ANYCAST , RTN_MULTICAST , RTN_BLACKHOLE , RTN_UNREACHABLE , RTN_PROHIBIT , RTN_THROW , RTN_NAT , RTN_XRESOLVE , __RTN_MAX } ;
enum rt_scope_t { RT_SCOPE_UNIVERSE = 0 , RT_SCOPE_SITE = 200 , RT_SCOPE_LINK = 253 , RT_SCOPE_HOST = 254 , RT_SCOPE_NOWHERE = 255 } ;

enum rt_class_t { RT_TABLE_UNSPEC = 0 , RT_TABLE_COMPAT = 252 , RT_TABLE_DEFAULT = 253 , RT_TABLE_MAIN = 254 , RT_TABLE_LOCAL = 255 , RT_TABLE_MAX = 0xFFFFFFFF } ;

enum rtattr_type_t { RTA_UNSPEC , RTA_DST , RTA_SRC , RTA_IIF , RTA_OIF , RTA_GATEWAY , RTA_PRIORITY , RTA_PREFSRC , RTA_METRICS , RTA_MULTIPATH , RTA_PROTOINFO , RTA_FLOW , RTA_CACHEINFO , RTA_SESSION , RTA_MP_ALGO , RTA_TABLE , __RTA_MAX } ;

struct rtnexthop { unsigned short rtnh_len ; unsigned char rtnh_flags ; unsigned char rtnh_hops ; int rtnh_ifindex ; } ;

struct rta_cacheinfo { __u32 rta_clntref ; __u32 rta_lastuse ; __s32 rta_expires ; __u32 rta_error ; __u32 rta_used ; __u32 rta_id ; __u32 rta_ts ; __u32 rta_tsage ; } ;

enum { RTAX_UNSPEC , RTAX_LOCK , RTAX_MTU , RTAX_WINDOW , RTAX_RTT , RTAX_RTTVAR , RTAX_SSTHRESH , RTAX_CWND , RTAX_ADVMSS , RTAX_REORDERING , RTAX_HOPLIMIT , RTAX_INITCWND , RTAX_FEATURES , RTAX_RTO_MIN , __RTAX_MAX } ;
struct rta_session { __u8 proto ; __u8 pad1 ; __u16 pad2 ; union { struct { __u16 sport ; __u16 dport ; } ports ; struct { __u8 type ; __u8 code ; __u16 ident ; } icmpt ; __u32 spi ; } u ; } ;

struct rtgenmsg { unsigned char rtgen_family ; } ;

struct ifinfomsg { unsigned char ifi_family ; unsigned char __ifi_pad ; unsigned short ifi_type ; int ifi_index ; unsigned ifi_flags ; unsigned ifi_change ; } ;

struct prefixmsg { unsigned char prefix_family ; unsigned char prefix_pad1 ; unsigned short prefix_pad2 ; int prefix_ifindex ; unsigned char prefix_type ; unsigned char prefix_len ; unsigned char prefix_flags ; unsigned char prefix_pad3 ; } ;

enum { PREFIX_UNSPEC , PREFIX_ADDRESS , PREFIX_CACHEINFO , __PREFIX_MAX } ;
struct prefix_cacheinfo { __u32 preferred_time ; __u32 valid_time ; } ;

struct tcmsg { unsigned char tcm_family ; unsigned char tcm__pad1 ; unsigned short tcm__pad2 ; int tcm_ifindex ; __u32 tcm_handle ; __u32 tcm_parent ; __u32 tcm_info ; } ;

enum { TCA_UNSPEC , TCA_KIND , TCA_OPTIONS , TCA_STATS , TCA_XSTATS , TCA_RATE , TCA_FCNT , TCA_STATS2 , TCA_STAB , __TCA_MAX } ;
struct nduseroptmsg { unsigned char nduseropt_family ; unsigned char nduseropt_pad1 ; unsigned short nduseropt_opts_len ; int nduseropt_ifindex ; __u8 nduseropt_icmp_type ; __u8 nduseropt_icmp_code ; unsigned short nduseropt_pad2 ; unsigned int nduseropt_pad3 ; } ;

enum { NDUSEROPT_UNSPEC , NDUSEROPT_SRCADDR , __NDUSEROPT_MAX } ;
enum rtnetlink_groups { RTNLGRP_NONE , RTNLGRP_LINK , RTNLGRP_NOTIFY , RTNLGRP_NEIGH , RTNLGRP_TC , RTNLGRP_IPV4_IFADDR , RTNLGRP_IPV4_MROUTE , RTNLGRP_IPV4_ROUTE , RTNLGRP_IPV4_RULE , RTNLGRP_IPV6_IFADDR , RTNLGRP_IPV6_MROUTE , RTNLGRP_IPV6_ROUTE , RTNLGRP_IPV6_IFINFO , RTNLGRP_DECnet_IFADDR , RTNLGRP_NOP2 , RTNLGRP_DECnet_ROUTE , RTNLGRP_DECnet_RULE , RTNLGRP_NOP4 , RTNLGRP_IPV6_PREFIX , RTNLGRP_IPV6_RULE , RTNLGRP_ND_USEROPT , RTNLGRP_PHONET_IFADDR , RTNLGRP_PHONET_ROUTE , __RTNLGRP_MAX } ;

struct tcamsg { unsigned char tca_family ; unsigned char tca__pad1 ; unsigned short tca__pad2 ; } ;

enum { NLA_UNSPEC , NLA_U8 , NLA_U16 , NLA_U32 , NLA_U64 , NLA_STRING , NLA_FLAG , NLA_MSECS , NLA_NESTED , NLA_NESTED_COMPAT , NLA_NUL_STRING , NLA_BINARY , __NLA_TYPE_MAX , } ;
struct nla_policy { u16 type ; u16 len ; } ;

struct nl_info { struct nlmsghdr * nlh ; struct net * nl_net ; u32 pid ; } ;

typedef int ( * rtnl_doit_func ) ( struct sk_buff * , struct nlmsghdr * , void * ) ;
typedef int ( * rtnl_dumpit_func ) ( struct sk_buff * , struct netlink_callback * ) ;
struct rtnl_link_ops { struct list_head list ; const char * kind ; size_t priv_size ; void ( * setup ) ( struct net_device * dev ) ; int maxtype ; const struct nla_policy * policy ; int ( * validate ) ( struct nlattr * tb [ ] , struct nlattr * data [ ] ) ; int ( * newlink ) ( struct net_device * dev , struct nlattr * tb [ ] , struct nlattr * data [ ] ) ; int ( * changelink ) ( struct net_device * dev , struct nlattr * tb [ ] , struct nlattr * data [ ] ) ; void ( * dellink ) ( struct net_device * dev ) ; size_t ( * get_size ) ( const struct net_device * dev ) ; int ( * fill_info ) ( struct sk_buff * skb , const struct net_device * dev ) ; size_t ( * get_xstats_size ) ( const struct net_device * dev ) ; int ( * fill_xstats ) ( struct sk_buff * skb , const struct net_device * dev ) ; int ( * get_tx_queues ) ( struct net * net , struct nlattr * tb [ ] , unsigned int * tx_queues , unsigned int * real_tx_queues ) ; } ;

struct neigh_parms { struct net * net ; struct net_device * dev ; struct neigh_parms * next ; int ( * neigh_setup ) ( struct neighbour * ) ; void ( * neigh_cleanup ) ( struct neighbour * ) ; struct neigh_table * tbl ; void * sysctl_table ; int dead ; atomic_t refcnt ; struct rcu_head rcu_head ; int base_reachable_time ; int retrans_time ; int gc_staletime ; int reachable_time ; int delay_probe_time ; int queue_len ; int ucast_probes ; int app_probes ; int mcast_probes ; int anycast_delay ; int proxy_delay ; int proxy_qlen ; int locktime ; } ;
struct neigh_statistics { unsigned long allocs ; unsigned long destroys ; unsigned long hash_grows ; unsigned long res_failed ; unsigned long lookups ; unsigned long hits ; unsigned long rcv_probes_mcast ; unsigned long rcv_probes_ucast ; unsigned long periodic_gc_runs ; unsigned long forced_gc_runs ; unsigned long unres_discards ; } ;

struct neighbour { struct neighbour * next ; struct neigh_table * tbl ; struct neigh_parms * parms ; struct net_device * dev ; unsigned long used ; unsigned long confirmed ; unsigned long updated ; __u8 flags ; __u8 nud_state ; __u8 type ; __u8 dead ; atomic_t probes ; rwlock_t lock ; unsigned char ha [ ( ( ( 32 ) + ( ( typeof ( 32 ) ) ( sizeof ( unsigned long ) ) - 1 ) ) & ~ ( ( typeof ( 32 ) ) ( sizeof ( unsigned long ) ) - 1 ) ) ] ; struct hh_cache * hh ; atomic_t refcnt ; int ( * output ) ( struct sk_buff * skb ) ; struct sk_buff_head arp_queue ; struct timer_list timer ; const struct neigh_ops * ops ; u8 primary_key [ 0 ] ; } ;
struct neigh_ops { int family ; void ( * solicit ) ( struct neighbour * , struct sk_buff * ) ; void ( * error_report ) ( struct neighbour * , struct sk_buff * ) ; int ( * output ) ( struct sk_buff * ) ; int ( * connected_output ) ( struct sk_buff * ) ; int ( * hh_output ) ( struct sk_buff * ) ; int ( * queue_xmit ) ( struct sk_buff * ) ; } ;

struct pneigh_entry { struct pneigh_entry * next ; struct net * net ; struct net_device * dev ; u8 flags ; u8 key [ 0 ] ; } ;

struct neigh_table { struct neigh_table * next ; int family ; int entry_size ; int key_len ; __u32 ( * hash ) ( const void * pkey , const struct net_device * ) ; int ( * constructor ) ( struct neighbour * ) ; int ( * pconstructor ) ( struct pneigh_entry * ) ; void ( * pdestructor ) ( struct pneigh_entry * ) ; void ( * proxy_redo ) ( struct sk_buff * skb ) ; char * id ; struct neigh_parms parms ; int gc_interval ; int gc_thresh1 ; int gc_thresh2 ; int gc_thresh3 ; unsigned long last_flush ; struct delayed_work gc_work ; struct timer_list proxy_timer ; struct sk_buff_head proxy_queue ; atomic_t entries ; rwlock_t lock ; unsigned long last_rand ; struct kmem_cache * kmem_cachep ; struct neigh_statistics * stats ; struct neighbour * * hash_buckets ; unsigned int hash_mask ; __u32 hash_rnd ; struct pneigh_entry * * phash_buckets ; } ;

struct neigh_seq_state { struct seq_net_private p ; struct neigh_table * tbl ; void * ( * neigh_sub_iter ) ( struct neigh_seq_state * state , struct neighbour * n , loff_t * pos ) ; unsigned int bucket ; unsigned int flags ; } ;

struct neighbour_cb { unsigned long sched_next ; unsigned int flags ; } ;

struct dst_entry { struct rcu_head rcu_head ; struct dst_entry * child ; struct net_device * dev ; short error ; short obsolete ; int flags ; unsigned long expires ; unsigned short header_len ; unsigned short trailer_len ; unsigned int rate_tokens ; unsigned long rate_last ; struct dst_entry * path ; struct neighbour * neighbour ; struct hh_cache * hh ; void * __pad1 ; int ( * input ) ( struct sk_buff * ) ; int ( * output ) ( struct sk_buff * ) ; struct dst_ops * ops ; u32 metrics [ ( __RTAX_MAX - 1 ) ] ; __u32 __pad2 ; long __pad_to_align_refcnt [ 2 ] ; atomic_t __refcnt ; int __use ; unsigned long lastuse ; union { struct dst_entry * next ; struct rtable * rt_next ; struct rt6_info * rt6_next ; struct dn_route * dn_next ; } ; } ;
enum { XFRM_LOOKUP_WAIT = 1 << 0 , XFRM_LOOKUP_ICMP = 1 << 1 , } ;
typedef struct { spinlock_t slock ; int owned ; wait_queue_head_t wq ; } socket_lock_t ;

struct proto ;

struct sock_common { union { struct hlist_node skc_node ; struct hlist_nulls_node skc_nulls_node ; } ; atomic_t skc_refcnt ; unsigned int skc_hash ; unsigned short skc_family ; volatile unsigned char skc_state ; unsigned char skc_reuse ; int skc_bound_dev_if ; struct hlist_node skc_bind_node ; struct proto * skc_prot ; struct net * skc_net ; } ;

struct sock { struct sock_common __sk_common ; int flags_begin [ 0 ] ; ; unsigned int sk_shutdown : 2 , sk_no_check : 2 , sk_userlocks : 4 , sk_protocol : 8 , sk_type : 16 ; int flags_end [ 0 ] ; ; int sk_rcvbuf ; socket_lock_t sk_lock ; struct { struct sk_buff * head ; struct sk_buff * tail ; } sk_backlog ; wait_queue_head_t * sk_sleep ; struct dst_entry * sk_dst_cache ; rwlock_t sk_dst_lock ; atomic_t sk_rmem_alloc ; atomic_t sk_wmem_alloc ; atomic_t sk_omem_alloc ; int sk_sndbuf ; struct sk_buff_head sk_receive_queue ; struct sk_buff_head sk_write_queue ; int sk_wmem_queued ; int sk_forward_alloc ; gfp_t sk_allocation ; int sk_route_caps ; int sk_gso_type ; unsigned int sk_gso_max_size ; int sk_rcvlowat ; unsigned long sk_flags ; unsigned long sk_lingertime ; struct sk_buff_head sk_error_queue ; struct proto * sk_prot_creator ; rwlock_t sk_callback_lock ; int sk_err , sk_err_soft ; atomic_t sk_drops ; unsigned short sk_ack_backlog ; unsigned short sk_max_ack_backlog ; __u32 sk_priority ; struct ucred sk_peercred ; long sk_rcvtimeo ; long sk_sndtimeo ; struct sk_filter * sk_filter ; void * sk_protinfo ; struct timer_list sk_timer ; ktime_t sk_stamp ; struct socket * sk_socket ; void * sk_user_data ; struct page * sk_sndmsg_page ; struct sk_buff * sk_send_head ; __u32 sk_sndmsg_off ; int sk_write_pending ; void * sk_security ; __u32 sk_mark ; void ( * sk_state_change ) ( struct sock * sk ) ; void ( * sk_data_ready ) ( struct sock * sk , int bytes ) ; void ( * sk_write_space ) ( struct sock * sk ) ; void ( * sk_error_report ) ( struct sock * sk ) ; int ( * sk_backlog_rcv ) ( struct sock * sk , struct sk_buff * skb ) ; void ( * sk_destruct ) ( struct sock * sk ) ; } ;
enum sock_flags { SOCK_DEAD , SOCK_DONE , SOCK_URGINLINE , SOCK_KEEPOPEN , SOCK_LINGER , SOCK_DESTROY , SOCK_BROADCAST , SOCK_TIMESTAMP , SOCK_ZAPPED , SOCK_USE_WRITE_QUEUE , SOCK_DBG , SOCK_RCVTSTAMP , SOCK_RCVTSTAMPNS , SOCK_LOCALROUTE , SOCK_QUEUE_SHRUNK , SOCK_TIMESTAMPING_TX_HARDWARE , SOCK_TIMESTAMPING_TX_SOFTWARE , SOCK_TIMESTAMPING_RX_HARDWARE , SOCK_TIMESTAMPING_RX_SOFTWARE , SOCK_TIMESTAMPING_SOFTWARE , SOCK_TIMESTAMPING_RAW_HARDWARE , SOCK_TIMESTAMPING_SYS_HARDWARE , } ;

struct request_sock_ops ;

struct timewait_sock_ops ;

struct inet_hashinfo ;

struct raw_hashinfo ;

struct proto { void ( * close ) ( struct sock * sk , long timeout ) ; int ( * connect ) ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) ; int ( * disconnect ) ( struct sock * sk , int flags ) ; struct sock * ( * accept ) ( struct sock * sk , int flags , int * err ) ; int ( * ioctl ) ( struct sock * sk , int cmd , unsigned long arg ) ; int ( * init ) ( struct sock * sk ) ; void ( * destroy ) ( struct sock * sk ) ; void ( * shutdown ) ( struct sock * sk , int how ) ; int ( * setsockopt ) ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ; int ( * getsockopt ) ( struct sock * sk , int level , int optname , char * optval , int * option ) ; int ( * compat_setsockopt ) ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ; int ( * compat_getsockopt ) ( struct sock * sk , int level , int optname , char * optval , int * option ) ; int ( * sendmsg ) ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) ; int ( * recvmsg ) ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) ; int ( * sendpage ) ( struct sock * sk , struct page * page , int offset , size_t size , int flags ) ; int ( * bind ) ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) ; int ( * backlog_rcv ) ( struct sock * sk , struct sk_buff * skb ) ; void ( * hash ) ( struct sock * sk ) ; void ( * unhash ) ( struct sock * sk ) ; int ( * get_port ) ( struct sock * sk , unsigned short snum ) ; unsigned int inuse_idx ; void ( * enter_memory_pressure ) ( struct sock * sk ) ; atomic_t * memory_allocated ; struct percpu_counter * sockets_allocated ; int * memory_pressure ; int * sysctl_mem ; int * sysctl_wmem ; int * sysctl_rmem ; int max_header ; struct kmem_cache * slab ; unsigned int obj_size ; int slab_flags ; struct percpu_counter * orphan_count ; struct request_sock_ops * rsk_prot ; struct timewait_sock_ops * twsk_prot ; union { struct inet_hashinfo * hashinfo ; struct udp_table * udp_table ; struct raw_hashinfo * raw_hash ; } h ; struct module * owner ; char name [ 32 ] ; struct list_head node ; } ;
struct sock_iocb { struct list_head list ; int flags ; int size ; struct socket * sock ; struct sock * sk ; struct scm_cookie * scm ; struct msghdr * msg , async_msg ; struct kiocb * kiocb ; } ;

struct socket_alloc { struct socket socket ; struct inode vfs_inode ; } ;

struct request_sock_ops { int family ; int obj_size ; struct kmem_cache * slab ; char * slab_name ; int ( * rtx_syn_ack ) ( struct sock * sk , struct request_sock * req ) ; void ( * send_ack ) ( struct sock * sk , struct sk_buff * skb , struct request_sock * req ) ; void ( * send_reset ) ( struct sock * sk , struct sk_buff * skb ) ; void ( * destructor ) ( struct request_sock * req ) ; } ;
struct request_sock { struct request_sock * dl_next ; u16 mss ; u8 retrans ; u8 cookie_ts ; u32 window_clamp ; u32 rcv_wnd ; u32 ts_recent ; unsigned long expires ; const struct request_sock_ops * rsk_ops ; struct sock * sk ; u32 secid ; u32 peer_secid ; } ;
struct listen_sock { u8 max_qlen_log ; int qlen ; int qlen_young ; int clock_hand ; u32 hash_rnd ; u32 nr_table_entries ; struct request_sock * syn_table [ 0 ] ; } ;

struct request_sock_queue { struct request_sock * rskq_accept_head ; struct request_sock * rskq_accept_tail ; rwlock_t syn_wait_lock ; u8 rskq_defer_accept ; struct listen_sock * listen_opt ; } ;

struct ip_options { __be32 faddr ; unsigned char optlen ; unsigned char srr ; unsigned char rr ; unsigned char ts ; unsigned char is_strictroute : 1 , srr_is_hit : 1 , is_changed : 1 , rr_needaddr : 1 , ts_needtime : 1 , ts_needaddr : 1 ; unsigned char router_alert ; unsigned char cipso ; unsigned char __pad2 ; unsigned char __data [ 0 ] ; } ;

struct inet_request_sock { struct request_sock req ; u16 inet6_rsk_offset ; __be16 loc_port ; __be32 loc_addr ; __be32 rmt_addr ; __be16 rmt_port ; int flags_begin [ 0 ] ; ; u16 snd_wscale : 4 , rcv_wscale : 4 , tstamp_ok : 1 , sack_ok : 1 , wscale_ok : 1 , ecn_ok : 1 , acked : 1 , no_srccheck : 1 ; int flags_end [ 0 ] ; ; struct ip_options * opt ; } ;

struct ip_mc_socklist ;

struct ipv6_pinfo ;

struct rtable ;

struct inet_sock { struct sock sk ; struct ipv6_pinfo * pinet6 ; __be32 daddr ; __be32 rcv_saddr ; __be16 dport ; __u16 num ; __be32 saddr ; __s16 uc_ttl ; __u16 cmsg_flags ; struct ip_options * opt ; __be16 sport ; __u16 id ; __u8 tos ; __u8 mc_ttl ; __u8 pmtudisc ; __u8 recverr : 1 , is_icsk : 1 , freebind : 1 , hdrincl : 1 , mc_loop : 1 , transparent : 1 , mc_all : 1 ; int mc_index ; __be32 mc_addr ; struct ip_mc_socklist * mc_list ; struct { unsigned int flags ; unsigned int fragsize ; struct ip_options * opt ; struct dst_entry * dst ; int length ; __be32 addr ; struct flowi fl ; } cork ; } ;

struct inet_bind_bucket ;

struct tcp_congestion_ops ;

struct inet_connection_sock_af_ops { int ( * queue_xmit ) ( struct sk_buff * skb , int ipfragok ) ; void ( * send_check ) ( struct sock * sk , int len , struct sk_buff * skb ) ; int ( * rebuild_header ) ( struct sock * sk ) ; int ( * conn_request ) ( struct sock * sk , struct sk_buff * skb ) ; struct sock * ( * syn_recv_sock ) ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) ; int ( * remember_stamp ) ( struct sock * sk ) ; u16 net_header_len ; u16 sockaddr_len ; int ( * setsockopt ) ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ; int ( * getsockopt ) ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ; int ( * compat_setsockopt ) ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ; int ( * compat_getsockopt ) ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ; void ( * addr2sockaddr ) ( struct sock * sk , struct sockaddr * ) ; int ( * bind_conflict ) ( const struct sock * sk , const struct inet_bind_bucket * tb ) ; } ;

struct inet_connection_sock { struct inet_sock icsk_inet ; struct request_sock_queue icsk_accept_queue ; struct inet_bind_bucket * icsk_bind_hash ; unsigned long icsk_timeout ; struct timer_list icsk_retransmit_timer ; struct timer_list icsk_delack_timer ; __u32 icsk_rto ; __u32 icsk_pmtu_cookie ; const struct tcp_congestion_ops * icsk_ca_ops ; const struct inet_connection_sock_af_ops * icsk_af_ops ; unsigned int ( * icsk_sync_mss ) ( struct sock * sk , u32 pmtu ) ; __u8 icsk_ca_state ; __u8 icsk_retransmits ; __u8 icsk_pending ; __u8 icsk_backoff ; __u8 icsk_syn_retries ; __u8 icsk_probes_out ; __u16 icsk_ext_hdr_len ; struct { __u8 pending ; __u8 quick ; __u8 pingpong ; __u8 blocked ; __u32 ato ; unsigned long timeout ; __u32 lrcvtime ; __u16 last_seg_size ; __u16 rcv_mss ; } icsk_ack ; struct { int enabled ; int search_high ; int search_low ; int probe_size ; } icsk_mtup ; u32 icsk_ca_priv [ 16 ] ; } ;

enum inet_csk_ack_state_t { ICSK_ACK_SCHED = 1 , ICSK_ACK_TIMER = 2 , ICSK_ACK_PUSHED = 4 , ICSK_ACK_PUSHED2 = 8 } ;

enum { TCP_ESTABLISHED = 1 , TCP_SYN_SENT , TCP_SYN_RECV , TCP_FIN_WAIT1 , TCP_FIN_WAIT2 , TCP_TIME_WAIT , TCP_CLOSE , TCP_CLOSE_WAIT , TCP_LAST_ACK , TCP_LISTEN , TCP_CLOSING , TCP_MAX_STATES } ;
enum { TCPF_ESTABLISHED = ( 1 << 1 ) , TCPF_SYN_SENT = ( 1 << 2 ) , TCPF_SYN_RECV = ( 1 << 3 ) , TCPF_FIN_WAIT1 = ( 1 << 4 ) , TCPF_FIN_WAIT2 = ( 1 << 5 ) , TCPF_TIME_WAIT = ( 1 << 6 ) , TCPF_CLOSE = ( 1 << 7 ) , TCPF_CLOSE_WAIT = ( 1 << 8 ) , TCPF_LAST_ACK = ( 1 << 9 ) , TCPF_LISTEN = ( 1 << 10 ) , TCPF_CLOSING = ( 1 << 11 ) } ;
struct timewait_sock_ops { struct kmem_cache * twsk_slab ; char * twsk_slab_name ; unsigned int twsk_obj_size ; int ( * twsk_unique ) ( struct sock * sk , struct sock * sktw , void * twp ) ; void ( * twsk_destructor ) ( struct sock * sk ) ; } ;
struct inet_timewait_death_row { int twcal_hand ; unsigned long twcal_jiffie ; struct timer_list twcal_timer ; struct hlist_head twcal_row [ ( 1 << 5 ) ] ; spinlock_t death_lock ; int tw_count ; int period ; u32 thread_slots ; struct work_struct twkill_work ; struct timer_list tw_timer ; int slot ; struct hlist_head cells [ 8 ] ; struct inet_hashinfo * hashinfo ; int sysctl_tw_recycle ; int sysctl_max_tw_buckets ; } ;

struct inet_timewait_sock { struct sock_common __tw_common ; int tw_timeout ; volatile unsigned char tw_substate ; unsigned char tw_rcv_wscale ; __be16 tw_sport ; __be32 tw_daddr __attribute__ ( ( aligned ( 8 ) ) ) ; __be32 tw_rcv_saddr ; __be16 tw_dport ; __u16 tw_num ; int flags_begin [ 0 ] ; ; unsigned int tw_ipv6only : 1 , tw_transparent : 1 , tw_pad : 14 , tw_ipv6_offset : 16 ; int flags_end [ 0 ] ; ; unsigned long tw_ttd ; struct inet_bind_bucket * tw_tb ; struct hlist_node tw_death_node ; } ;

struct tcp_sack_block_wire { __be32 start_seq ; __be32 end_seq ; } ;

struct tcp_sack_block { u32 start_seq ; u32 end_seq ; } ;

struct tcp_options_received { long ts_recent_stamp ; u32 ts_recent ; u32 rcv_tsval ; u32 rcv_tsecr ; u16 saw_tstamp : 1 , tstamp_ok : 1 , dsack : 1 , wscale_ok : 1 , sack_ok : 4 , snd_wscale : 4 , rcv_wscale : 4 ; u8 num_sacks ; u16 user_mss ; u16 mss_clamp ; } ;

struct tcp_request_sock { struct inet_request_sock req ; const struct tcp_request_sock_ops * af_specific ; u32 rcv_isn ; u32 snt_isn ; } ;

struct tcp_sock { struct inet_connection_sock inet_conn ; u16 tcp_header_len ; u16 xmit_size_goal_segs ; __be32 pred_flags ; u32 rcv_nxt ; u32 copied_seq ; u32 rcv_wup ; u32 snd_nxt ; u32 snd_una ; u32 snd_sml ; u32 rcv_tstamp ; u32 lsndtime ; struct { struct sk_buff_head prequeue ; struct task_struct * task ; struct iovec * iov ; int memory ; int len ; } ucopy ; u32 snd_wl1 ; u32 snd_wnd ; u32 max_window ; u32 mss_cache ; u32 window_clamp ; u32 rcv_ssthresh ; u32 frto_highmark ; u16 advmss ; u8 frto_counter ; u8 nonagle ; u32 srtt ; u32 mdev ; u32 mdev_max ; u32 rttvar ; u32 rtt_seq ; u32 packets_out ; u32 retrans_out ; u16 urg_data ; u8 ecn_flags ; u8 reordering ; u32 snd_up ; u8 keepalive_probes ; struct tcp_options_received rx_opt ; u32 snd_ssthresh ; u32 snd_cwnd ; u32 snd_cwnd_cnt ; u32 snd_cwnd_clamp ; u32 snd_cwnd_used ; u32 snd_cwnd_stamp ; u32 rcv_wnd ; u32 write_seq ; u32 pushed_seq ; u32 lost_out ; u32 sacked_out ; u32 fackets_out ; u32 tso_deferred ; u32 bytes_acked ; struct sk_buff * lost_skb_hint ; struct sk_buff * scoreboard_skb_hint ; struct sk_buff * retransmit_skb_hint ; struct sk_buff_head out_of_order_queue ; struct tcp_sack_block duplicate_sack [ 1 ] ; struct tcp_sack_block selective_acks [ 4 ] ; struct tcp_sack_block recv_sack_cache [ 4 ] ; struct sk_buff * highest_sack ; int lost_cnt_hint ; u32 retransmit_high ; u32 lost_retrans_low ; u32 prior_ssthresh ; u32 high_seq ; u32 retrans_stamp ; u32 undo_marker ; int undo_retrans ; u32 total_retrans ; u32 urg_seq ; unsigned int keepalive_time ; unsigned int keepalive_intvl ; int linger2 ; struct { u32 rtt ; u32 seq ; u32 time ; } rcv_rtt_est ; struct { int space ; u32 seq ; u32 time ; } rcvq_space ; struct { u32 probe_seq_start ; u32 probe_seq_end ; } mtu_probe ; const struct tcp_sock_af_ops * af_specific ; struct tcp_md5sig_info * md5sig_info ; } ;

struct tcp_timewait_sock { struct inet_timewait_sock tw_sk ; u32 tw_rcv_nxt ; u32 tw_snd_nxt ; u32 tw_rcv_wnd ; u32 tw_ts_recent ; long tw_ts_recent_stamp ; u16 tw_md5_keylen ; u8 tw_md5_key [ 80 ] ; } ;

struct udphdr { __be16 source ; __be16 dest ; __be16 len ; __sum16 check ; } ;

struct udp_sock { struct inet_sock inet ; int pending ; unsigned int corkflag ; __u16 encap_type ; __u16 len ; __u16 pcslen ; __u16 pcrlen ; __u8 pcflag ; __u8 unused [ 3 ] ; int ( * encap_rcv ) ( struct sock * sk , struct sk_buff * skb ) ; } ;

struct inet6_skb_parm { int iif ; __u16 ra ; __u16 hop ; __u16 dst0 ; __u16 srcrt ; __u16 dst1 ; __u16 lastopt ; __u32 nhoff ; __u16 flags ; } ;

struct inet6_request_sock { struct in6_addr loc_addr ; struct in6_addr rmt_addr ; struct sk_buff * pktopts ; int iif ; } ;

struct tcp6_request_sock { struct tcp_request_sock tcp6rsk_tcp ; struct inet6_request_sock tcp6rsk_inet6 ; } ;

struct ipv6_mc_socklist ;

struct ipv6_ac_socklist ;

struct ipv6_fl_socklist ;

struct ipv6_pinfo { struct in6_addr saddr ; struct in6_addr rcv_saddr ; struct in6_addr daddr ; struct in6_pktinfo sticky_pktinfo ; struct in6_addr * daddr_cache ; __be32 flow_label ; __u32 frag_size ; __u16 __unused_1 : 7 ; __s16 hop_limit : 9 ; __u16 mc_loop : 1 , __unused_2 : 6 ; __s16 mcast_hops : 9 ; int mcast_oif ; union { struct { __u16 srcrt : 1 , osrcrt : 1 , rxinfo : 1 , rxoinfo : 1 , rxhlim : 1 , rxohlim : 1 , hopopts : 1 , ohopopts : 1 , dstopts : 1 , odstopts : 1 , rxflow : 1 , rxtclass : 1 ; } bits ; __u16 all ; } rxopt ; __u8 recverr : 1 , sndflow : 1 , pmtudisc : 2 , ipv6only : 1 , srcprefs : 3 ; __u8 tclass ; __u32 dst_cookie ; struct ipv6_mc_socklist * ipv6_mc_list ; struct ipv6_ac_socklist * ipv6_ac_list ; struct ipv6_fl_socklist * ipv6_fl_list ; struct ipv6_txoptions * opt ; struct sk_buff * pktoptions ; struct { struct ipv6_txoptions * opt ; u8 hop_limit ; u8 tclass ; } cork ; } ;
struct raw6_sock { struct inet_sock inet ; __u32 checksum ; __u32 offset ; struct icmp6_filter filter ; struct ipv6_pinfo inet6 ; } ;

struct udp6_sock { struct udp_sock udp ; struct ipv6_pinfo inet6 ; } ;

struct tcp6_sock { struct tcp_sock tcp ; struct ipv6_pinfo inet6 ; } ;

struct inet6_timewait_sock { struct in6_addr tw_v6_daddr ; struct in6_addr tw_v6_rcv_saddr ; } ;

struct tcp6_timewait_sock { struct tcp_timewait_sock tcp6tw_tcp ; struct inet6_timewait_sock tcp6tw_inet6 ; } ;

struct inet6_ifaddr { struct in6_addr addr ; __u32 prefix_len ; __u32 valid_lft ; __u32 prefered_lft ; atomic_t refcnt ; spinlock_t lock ; __u8 probes ; __u8 flags ; __u16 scope ; unsigned long cstamp ; unsigned long tstamp ; struct timer_list timer ; struct inet6_dev * idev ; struct rt6_info * rt ; struct inet6_ifaddr * lst_next ; struct inet6_ifaddr * if_next ; struct inet6_ifaddr * tmp_next ; struct inet6_ifaddr * ifpub ; int regen_count ; int dead ; } ;

struct ip6_sf_socklist { unsigned int sl_max ; unsigned int sl_count ; struct in6_addr sl_addr [ 0 ] ; } ;

struct ipv6_mc_socklist { struct in6_addr addr ; int ifindex ; struct ipv6_mc_socklist * next ; rwlock_t sflock ; unsigned int sfmode ; struct ip6_sf_socklist * sflist ; } ;
struct ip6_sf_list { struct ip6_sf_list * sf_next ; struct in6_addr sf_addr ; unsigned long sf_count [ 2 ] ; unsigned char sf_gsresp ; unsigned char sf_oldin ; unsigned char sf_crcount ; } ;

struct ifmcaddr6 { struct in6_addr mca_addr ; struct inet6_dev * idev ; struct ifmcaddr6 * next ; struct ip6_sf_list * mca_sources ; struct ip6_sf_list * mca_tomb ; unsigned int mca_sfmode ; unsigned char mca_crcount ; unsigned long mca_sfcount [ 2 ] ; struct timer_list mca_timer ; unsigned mca_flags ; int mca_users ; atomic_t mca_refcnt ; spinlock_t mca_lock ; unsigned long mca_cstamp ; unsigned long mca_tstamp ; } ;

struct ipv6_ac_socklist { struct in6_addr acl_addr ; int acl_ifindex ; struct ipv6_ac_socklist * acl_next ; } ;
struct ifacaddr6 { struct in6_addr aca_addr ; struct inet6_dev * aca_idev ; struct rt6_info * aca_rt ; struct ifacaddr6 * aca_next ; int aca_users ; atomic_t aca_refcnt ; spinlock_t aca_lock ; unsigned long aca_cstamp ; unsigned long aca_tstamp ; } ;

struct ipv6_devstat { struct proc_dir_entry * proc_dir_entry ; __typeof__ ( struct ipstats_mib ) * ipv6 [ 2 ] ; __typeof__ ( struct icmpv6_mib ) * icmpv6 [ 2 ] ; __typeof__ ( struct icmpv6msg_mib ) * icmpv6msg [ 2 ] ; } ;

struct inet6_dev { struct net_device * dev ; struct inet6_ifaddr * addr_list ; struct ifmcaddr6 * mc_list ; struct ifmcaddr6 * mc_tomb ; rwlock_t mc_lock ; unsigned char mc_qrv ; unsigned char mc_gq_running ; unsigned char mc_ifc_count ; unsigned long mc_v1_seen ; unsigned long mc_maxdelay ; struct timer_list mc_gq_timer ; struct timer_list mc_ifc_timer ; struct ifacaddr6 * ac_list ; rwlock_t lock ; atomic_t refcnt ; __u32 if_flags ; int dead ; u8 rndid [ 8 ] ; struct timer_list regen_timer ; struct inet6_ifaddr * tempaddr_list ; struct neigh_parms * nd_parms ; struct inet6_dev * next ; struct ipv6_devconf cnf ; struct ipv6_devstat stats ; unsigned long tstamp ; struct rcu_head rcu ; } ;

enum { __ND_OPT_PREFIX_INFO_END = 0 , ND_OPT_SOURCE_LL_ADDR = 1 , ND_OPT_TARGET_LL_ADDR = 2 , ND_OPT_PREFIX_INFO = 3 , ND_OPT_REDIRECT_HDR = 4 , ND_OPT_MTU = 5 , __ND_OPT_ARRAY_MAX , ND_OPT_ROUTE_INFO = 24 , ND_OPT_RDNSS = 25 , __ND_OPT_MAX } ;
struct inet6_dev ;
struct net_proto_family ;
struct nd_msg { struct icmp6hdr icmph ; struct in6_addr target ; __u8 opt [ 0 ] ; } ;

struct rs_msg { struct icmp6hdr icmph ; __u8 opt [ 0 ] ; } ;

struct ra_msg { struct icmp6hdr icmph ; __be32 reachable_time ; __be32 retrans_timer ; } ;

struct nd_opt_hdr { __u8 nd_opt_type ; __u8 nd_opt_len ; } __attribute__ ( ( __packed__ ) ) ;
struct frag_hdr { __u8 nexthdr ; __u8 reserved ; __be16 frag_off ; __be32 identification ; } ;

struct ip6_ra_chain { struct ip6_ra_chain * next ; struct sock * sk ; int sel ; void ( * destructor ) ( struct sock * ) ; } ;

struct ipv6_txoptions { int tot_len ; __u16 opt_flen ; __u16 opt_nflen ; struct ipv6_opt_hdr * hopopt ; struct ipv6_opt_hdr * dst0opt ; struct ipv6_rt_hdr * srcrt ; struct ipv6_opt_hdr * dst1opt ; } ;

struct ip6_flowlabel { struct ip6_flowlabel * next ; __be32 label ; atomic_t users ; struct in6_addr dst ; struct ipv6_txoptions * opt ; unsigned long linger ; u8 share ; u32 owner ; unsigned long lastuse ; unsigned long expires ; struct net * fl_net ; } ;

struct ipv6_fl_socklist { struct ipv6_fl_socklist * next ; struct ip6_flowlabel * fl ; } ;
struct inet_frag_queue ;
enum ip6_defrag_users { IP6_DEFRAG_LOCAL_DELIVER , IP6_DEFRAG_CONNTRACK_IN , IP6_DEFRAG_CONNTRACK_OUT , IP6_DEFRAG_CONNTRACK_BRIDGE_IN , } ;

struct ip6_create_arg { __be32 id ; u32 user ; struct in6_addr * src ; struct in6_addr * dst ; } ;

struct group_source_req ;
struct group_filter ;
struct rpc_inode ;

struct rpc_clnt { struct kref cl_kref ; struct list_head cl_clients ; struct list_head cl_tasks ; spinlock_t cl_lock ; struct rpc_xprt * cl_xprt ; struct rpc_procinfo * cl_procinfo ; u32 cl_prog , cl_vers , cl_maxproc ; char * cl_server ; char * cl_protname ; struct rpc_auth * cl_auth ; struct rpc_stat * cl_stats ; struct rpc_iostats * cl_metrics ; unsigned int cl_softrtry : 1 , cl_discrtry : 1 , cl_autobind : 1 , cl_chatty : 1 ; struct rpc_rtt * cl_rtt ; const struct rpc_timeout * cl_timeout ; int cl_nodelen ; char cl_nodename [ 32 ] ; struct path cl_path ; struct rpc_clnt * cl_parent ; struct rpc_rtt cl_rtt_default ; struct rpc_timeout cl_timeout_default ; struct rpc_program * cl_program ; char cl_inline_name [ 32 ] ; char * cl_principal ; } ;

struct rpc_program { char * name ; u32 number ; unsigned int nrvers ; struct rpc_version * * version ; struct rpc_stat * stats ; char * pipe_dir_name ; } ;

struct rpc_version { u32 number ; unsigned int nrprocs ; struct rpc_procinfo * procs ; } ;

struct rpc_procinfo { u32 p_proc ; kxdrproc_t p_encode ; kxdrproc_t p_decode ; unsigned int p_arglen ; unsigned int p_replen ; unsigned int p_count ; unsigned int p_timer ; u32 p_statidx ; char * p_name ; } ;
struct rpc_create_args { int protocol ; struct sockaddr * address ; size_t addrsize ; struct sockaddr * saddress ; const struct rpc_timeout * timeout ; char * servername ; struct rpc_program * program ; u32 prognumber ; u32 version ; rpc_authflavor_t authflavor ; unsigned long flags ; char * client_name ; struct svc_xprt * bc_xprt ; } ;

enum nfs2_ftype { NF2NON = 0 , NF2REG = 1 , NF2DIR = 2 , NF2BLK = 3 , NF2CHR = 4 , NF2LNK = 5 , NF2SOCK = 6 , NF2BAD = 7 , NF2FIFO = 8 } ;

struct nfs2_fh { char data [ 32 ] ; } ;

enum nfs3_createmode { NFS3_CREATE_UNCHECKED = 0 , NFS3_CREATE_GUARDED = 1 , NFS3_CREATE_EXCLUSIVE = 2 } ;

enum nfs3_ftype { NF3NON = 0 , NF3REG = 1 , NF3DIR = 2 , NF3BLK = 3 , NF3CHR = 4 , NF3LNK = 5 , NF3SOCK = 6 , NF3FIFO = 7 , NF3BAD = 8 } ;

struct nfs3_fh { unsigned short size ; unsigned char data [ 64 ] ; } ;

enum nfs4_acl_whotype { NFS4_ACL_WHO_NAMED = 0 , NFS4_ACL_WHO_OWNER , NFS4_ACL_WHO_GROUP , NFS4_ACL_WHO_EVERYONE , } ;

struct nfs4_ace { uint32_t type ; uint32_t flag ; uint32_t access_mask ; int whotype ; uid_t who ; } ;

struct nfs4_acl { uint32_t naces ; struct nfs4_ace aces [ 0 ] ; } ;

typedef struct { char data [ 8 ] ; } nfs4_verifier ;

typedef struct { char data [ 16 ] ; } nfs4_stateid ;

enum nfs_opnum4 { OP_ACCESS = 3 , OP_CLOSE = 4 , OP_COMMIT = 5 , OP_CREATE = 6 , OP_DELEGPURGE = 7 , OP_DELEGRETURN = 8 , OP_GETATTR = 9 , OP_GETFH = 10 , OP_LINK = 11 , OP_LOCK = 12 , OP_LOCKT = 13 , OP_LOCKU = 14 , OP_LOOKUP = 15 , OP_LOOKUPP = 16 , OP_NVERIFY = 17 , OP_OPEN = 18 , OP_OPENATTR = 19 , OP_OPEN_CONFIRM = 20 , OP_OPEN_DOWNGRADE = 21 , OP_PUTFH = 22 , OP_PUTPUBFH = 23 , OP_PUTROOTFH = 24 , OP_READ = 25 , OP_READDIR = 26 , OP_READLINK = 27 , OP_REMOVE = 28 , OP_RENAME = 29 , OP_RENEW = 30 , OP_RESTOREFH = 31 , OP_SAVEFH = 32 , OP_SECINFO = 33 , OP_SETATTR = 34 , OP_SETCLIENTID = 35 , OP_SETCLIENTID_CONFIRM = 36 , OP_VERIFY = 37 , OP_WRITE = 38 , OP_RELEASE_LOCKOWNER = 39 , OP_BACKCHANNEL_CTL = 40 , OP_BIND_CONN_TO_SESSION = 41 , OP_EXCHANGE_ID = 42 , OP_CREATE_SESSION = 43 , OP_DESTROY_SESSION = 44 , OP_FREE_STATEID = 45 , OP_GET_DIR_DELEGATION = 46 , OP_GETDEVICEINFO = 47 , OP_GETDEVICELIST = 48 , OP_LAYOUTCOMMIT = 49 , OP_LAYOUTGET = 50 , OP_LAYOUTRETURN = 51 , OP_SECINFO_NO_NAME = 52 , OP_SEQUENCE = 53 , OP_SET_SSV = 54 , OP_TEST_STATEID = 55 , OP_WANT_DELEGATION = 56 , OP_DESTROY_CLIENTID = 57 , OP_RECLAIM_COMPLETE = 58 , OP_ILLEGAL = 10044 , } ;

enum nfsstat4 { NFS4_OK = 0 , NFS4ERR_PERM = 1 , NFS4ERR_NOENT = 2 , NFS4ERR_IO = 5 , NFS4ERR_NXIO = 6 , NFS4ERR_ACCESS = 13 , NFS4ERR_EXIST = 17 , NFS4ERR_XDEV = 18 , NFS4ERR_NOTDIR = 20 , NFS4ERR_ISDIR = 21 , NFS4ERR_INVAL = 22 , NFS4ERR_FBIG = 27 , NFS4ERR_NOSPC = 28 , NFS4ERR_ROFS = 30 , NFS4ERR_MLINK = 31 , NFS4ERR_NAMETOOLONG = 63 , NFS4ERR_NOTEMPTY = 66 , NFS4ERR_DQUOT = 69 , NFS4ERR_STALE = 70 , NFS4ERR_BADHANDLE = 10001 , NFS4ERR_BAD_COOKIE = 10003 , NFS4ERR_NOTSUPP = 10004 , NFS4ERR_TOOSMALL = 10005 , NFS4ERR_SERVERFAULT = 10006 , NFS4ERR_BADTYPE = 10007 , NFS4ERR_DELAY = 10008 , NFS4ERR_SAME = 10009 , NFS4ERR_DENIED = 10010 , NFS4ERR_EXPIRED = 10011 , NFS4ERR_LOCKED = 10012 , NFS4ERR_GRACE = 10013 , NFS4ERR_FHEXPIRED = 10014 , NFS4ERR_SHARE_DENIED = 10015 , NFS4ERR_WRONGSEC = 10016 , NFS4ERR_CLID_INUSE = 10017 , NFS4ERR_RESOURCE = 10018 , NFS4ERR_MOVED = 10019 , NFS4ERR_NOFILEHANDLE = 10020 , NFS4ERR_MINOR_VERS_MISMATCH = 10021 , NFS4ERR_STALE_CLIENTID = 10022 , NFS4ERR_STALE_STATEID = 10023 , NFS4ERR_OLD_STATEID = 10024 , NFS4ERR_BAD_STATEID = 10025 , NFS4ERR_BAD_SEQID = 10026 , NFS4ERR_NOT_SAME = 10027 , NFS4ERR_LOCK_RANGE = 10028 , NFS4ERR_SYMLINK = 10029 , NFS4ERR_RESTOREFH = 10030 , NFS4ERR_LEASE_MOVED = 10031 , NFS4ERR_ATTRNOTSUPP = 10032 , NFS4ERR_NO_GRACE = 10033 , NFS4ERR_RECLAIM_BAD = 10034 , NFS4ERR_RECLAIM_CONFLICT = 10035 , NFS4ERR_BADXDR = 10036 , NFS4ERR_LOCKS_HELD = 10037 , NFS4ERR_OPENMODE = 10038 , NFS4ERR_BADOWNER = 10039 , NFS4ERR_BADCHAR = 10040 , NFS4ERR_BADNAME = 10041 , NFS4ERR_BAD_RANGE = 10042 , NFS4ERR_LOCK_NOTSUPP = 10043 , NFS4ERR_OP_ILLEGAL = 10044 , NFS4ERR_DEADLOCK = 10045 , NFS4ERR_FILE_OPEN = 10046 , NFS4ERR_ADMIN_REVOKED = 10047 , NFS4ERR_CB_PATH_DOWN = 10048 , NFS4ERR_BADIOMODE = 10049 , NFS4ERR_BADLAYOUT = 10050 , NFS4ERR_BAD_SESSION_DIGEST = 10051 , NFS4ERR_BADSESSION = 10052 , NFS4ERR_BADSLOT = 10053 , NFS4ERR_COMPLETE_ALREADY = 10054 , NFS4ERR_CONN_NOT_BOUND_TO_SESSION = 10055 , NFS4ERR_DELEG_ALREADY_WANTED = 10056 , NFS4ERR_BACK_CHAN_BUSY = 10057 , NFS4ERR_LAYOUTTRYLATER = 10058 , NFS4ERR_LAYOUTUNAVAILABLE = 10059 , NFS4ERR_NOMATCHING_LAYOUT = 10060 , NFS4ERR_RECALLCONFLICT = 10061 , NFS4ERR_UNKNOWN_LAYOUTTYPE = 10062 , NFS4ERR_SEQ_MISORDERED = 10063 , NFS4ERR_SEQUENCE_POS = 10064 , NFS4ERR_REQ_TOO_BIG = 10065 , NFS4ERR_REP_TOO_BIG = 10066 , NFS4ERR_REP_TOO_BIG_TO_CACHE = 10067 , NFS4ERR_RETRY_UNCACHED_REP = 10068 , NFS4ERR_UNSAFE_COMPOUND = 10069 , NFS4ERR_TOO_MANY_OPS = 10070 , NFS4ERR_OP_NOT_IN_SESSION = 10071 , NFS4ERR_HASH_ALG_UNSUPP = 10072 , NFS4ERR_CLIENTID_BUSY = 10074 , NFS4ERR_PNFS_IO_HOLE = 10075 , NFS4ERR_SEQ_FALSE_RETRY = 10076 , NFS4ERR_BAD_HIGH_SLOT = 10077 , NFS4ERR_DEADSESSION = 10078 , NFS4ERR_ENCR_ALG_UNSUPP = 10079 , NFS4ERR_PNFS_NO_LAYOUT = 10080 , NFS4ERR_NOT_ONLY_OP = 10081 , NFS4ERR_WRONG_CRED = 10082 , NFS4ERR_WRONG_TYPE = 10083 , NFS4ERR_DIRDELEG_UNAVAIL = 10084 , NFS4ERR_REJECT_DELEG = 10085 , NFS4ERR_RETURNCONFLICT = 10086 , NFS4ERR_DELEG_REVOKED = 10087 , } ;

enum nfs_ftype4 { NF4BAD = 0 , NF4REG = 1 , NF4DIR = 2 , NF4BLK = 3 , NF4CHR = 4 , NF4LNK = 5 , NF4SOCK = 6 , NF4FIFO = 7 , NF4ATTRDIR = 8 , NF4NAMEDATTR = 9 } ;

enum open_claim_type4 { NFS4_OPEN_CLAIM_NULL = 0 , NFS4_OPEN_CLAIM_PREVIOUS = 1 , NFS4_OPEN_CLAIM_DELEGATE_CUR = 2 , NFS4_OPEN_CLAIM_DELEGATE_PREV = 3 } ;

enum opentype4 { NFS4_OPEN_NOCREATE = 0 , NFS4_OPEN_CREATE = 1 } ;

enum createmode4 { NFS4_CREATE_UNCHECKED = 0 , NFS4_CREATE_GUARDED = 1 , NFS4_CREATE_EXCLUSIVE = 2 , NFS4_CREATE_EXCLUSIVE4_1 = 3 } ;

enum limit_by4 { NFS4_LIMIT_SIZE = 1 , NFS4_LIMIT_BLOCKS = 2 } ;

enum open_delegation_type4 { NFS4_OPEN_DELEGATE_NONE = 0 , NFS4_OPEN_DELEGATE_READ = 1 , NFS4_OPEN_DELEGATE_WRITE = 2 } ;

enum lock_type4 { NFS4_UNLOCK_LT = 0 , NFS4_READ_LT = 1 , NFS4_WRITE_LT = 2 , NFS4_READW_LT = 3 , NFS4_WRITEW_LT = 4 } ;

enum { NFSPROC4_CLNT_NULL = 0 , NFSPROC4_CLNT_READ , NFSPROC4_CLNT_WRITE , NFSPROC4_CLNT_COMMIT , NFSPROC4_CLNT_OPEN , NFSPROC4_CLNT_OPEN_CONFIRM , NFSPROC4_CLNT_OPEN_NOATTR , NFSPROC4_CLNT_OPEN_DOWNGRADE , NFSPROC4_CLNT_CLOSE , NFSPROC4_CLNT_SETATTR , NFSPROC4_CLNT_FSINFO , NFSPROC4_CLNT_RENEW , NFSPROC4_CLNT_SETCLIENTID , NFSPROC4_CLNT_SETCLIENTID_CONFIRM , NFSPROC4_CLNT_LOCK , NFSPROC4_CLNT_LOCKT , NFSPROC4_CLNT_LOCKU , NFSPROC4_CLNT_ACCESS , NFSPROC4_CLNT_GETATTR , NFSPROC4_CLNT_LOOKUP , NFSPROC4_CLNT_LOOKUP_ROOT , NFSPROC4_CLNT_REMOVE , NFSPROC4_CLNT_RENAME , NFSPROC4_CLNT_LINK , NFSPROC4_CLNT_SYMLINK , NFSPROC4_CLNT_CREATE , NFSPROC4_CLNT_PATHCONF , NFSPROC4_CLNT_STATFS , NFSPROC4_CLNT_READLINK , NFSPROC4_CLNT_READDIR , NFSPROC4_CLNT_SERVER_CAPS , NFSPROC4_CLNT_DELEGRETURN , NFSPROC4_CLNT_GETACL , NFSPROC4_CLNT_SETACL , NFSPROC4_CLNT_FS_LOCATIONS , NFSPROC4_CLNT_EXCHANGE_ID , NFSPROC4_CLNT_CREATE_SESSION , NFSPROC4_CLNT_DESTROY_SESSION , NFSPROC4_CLNT_SEQUENCE , NFSPROC4_CLNT_GET_LEASE_TIME , } ;
struct nfs4_sessionid { unsigned char data [ 16 ] ; } ;

enum state_protect_how4 { SP4_NONE = 0 , SP4_MACH_CRED = 1 , SP4_SSV = 2 } ;

struct posix_acl_entry { short e_tag ; unsigned short e_perm ; unsigned int e_id ; } ;

struct posix_acl { atomic_t a_refcount ; unsigned int a_count ; struct posix_acl_entry a_entries [ 0 ] ; } ;
struct nfs_fsid { uint64_t major ; uint64_t minor ; } ;

struct nfs_fattr { unsigned int valid ; umode_t mode ; __u32 nlink ; __u32 uid ; __u32 gid ; dev_t rdev ; __u64 size ; union { struct { __u32 blocksize ; __u32 blocks ; } nfs2 ; struct { __u64 used ; } nfs3 ; } du ; struct nfs_fsid fsid ; __u64 fileid ; struct timespec atime ; struct timespec mtime ; struct timespec ctime ; __u64 change_attr ; __u64 pre_change_attr ; __u64 pre_size ; struct timespec pre_mtime ; struct timespec pre_ctime ; unsigned long time_start ; unsigned long gencount ; } ;

struct nfs_fsinfo { struct nfs_fattr * fattr ; __u32 rtmax ; __u32 rtpref ; __u32 rtmult ; __u32 wtmax ; __u32 wtpref ; __u32 wtmult ; __u32 dtpref ; __u64 maxfilesize ; __u32 lease_time ; } ;

struct nfs_fsstat { struct nfs_fattr * fattr ; __u64 tbytes ; __u64 fbytes ; __u64 abytes ; __u64 tfiles ; __u64 ffiles ; __u64 afiles ; } ;

struct nfs2_fsstat { __u32 tsize ; __u32 bsize ; __u32 blocks ; __u32 bfree ; __u32 bavail ; } ;

struct nfs_pathconf { struct nfs_fattr * fattr ; __u32 max_link ; __u32 max_namelen ; } ;

struct nfs4_change_info { u32 atomic ; u64 before ; u64 after ; } ;

struct nfs_seqid ;

struct nfs4_channel_attrs { u32 headerpadsz ; u32 max_rqst_sz ; u32 max_resp_sz ; u32 max_resp_sz_cached ; u32 max_ops ; u32 max_reqs ; } ;

struct nfs4_slot { u32 seq_nr ; } ;

struct nfs4_sequence_args { struct nfs4_session * sa_session ; u8 sa_slotid ; u8 sa_cache_this ; } ;

struct nfs4_sequence_res { struct nfs4_session * sr_session ; u8 sr_slotid ; unsigned long sr_renewal_time ; int sr_status ; } ;

struct nfs4_get_lease_time_args { struct nfs4_sequence_args la_seq_args ; } ;

struct nfs4_get_lease_time_res { struct nfs_fsinfo * lr_fsinfo ; struct nfs4_sequence_res lr_seq_res ; } ;

struct nfs_openargs { const struct nfs_fh * fh ; struct nfs_seqid * seqid ; int open_flags ; fmode_t fmode ; __u64 clientid ; __u64 id ; union { struct iattr * attrs ; nfs4_verifier verifier ; nfs4_stateid delegation ; fmode_t delegation_type ; } u ; const struct qstr * name ; const struct nfs_server * server ; const u32 * bitmask ; __u32 claim ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_openres { nfs4_stateid stateid ; struct nfs_fh fh ; struct nfs4_change_info cinfo ; __u32 rflags ; struct nfs_fattr * f_attr ; struct nfs_fattr * dir_attr ; struct nfs_seqid * seqid ; const struct nfs_server * server ; fmode_t delegation_type ; nfs4_stateid delegation ; __u32 do_recall ; __u64 maxsize ; __u32 attrset [ 2 ] ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_open_confirmargs { const struct nfs_fh * fh ; nfs4_stateid * stateid ; struct nfs_seqid * seqid ; } ;

struct nfs_open_confirmres { nfs4_stateid stateid ; struct nfs_seqid * seqid ; } ;

struct nfs_closeargs { struct nfs_fh * fh ; nfs4_stateid * stateid ; struct nfs_seqid * seqid ; fmode_t fmode ; const u32 * bitmask ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_closeres { nfs4_stateid stateid ; struct nfs_fattr * fattr ; struct nfs_seqid * seqid ; const struct nfs_server * server ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_lowner { __u64 clientid ; __u64 id ; } ;

struct nfs_lock_args { struct nfs_fh * fh ; struct file_lock * fl ; struct nfs_seqid * lock_seqid ; nfs4_stateid * lock_stateid ; struct nfs_seqid * open_seqid ; nfs4_stateid * open_stateid ; struct nfs_lowner lock_owner ; unsigned char block : 1 ; unsigned char reclaim : 1 ; unsigned char new_lock_owner : 1 ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_lock_res { nfs4_stateid stateid ; struct nfs_seqid * lock_seqid ; struct nfs_seqid * open_seqid ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_locku_args { struct nfs_fh * fh ; struct file_lock * fl ; struct nfs_seqid * seqid ; nfs4_stateid * stateid ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_locku_res { nfs4_stateid stateid ; struct nfs_seqid * seqid ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_lockt_args { struct nfs_fh * fh ; struct file_lock * fl ; struct nfs_lowner lock_owner ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_lockt_res { struct file_lock * denied ; struct nfs4_sequence_res seq_res ; } ;

struct nfs4_delegreturnargs { const struct nfs_fh * fhandle ; const nfs4_stateid * stateid ; const u32 * bitmask ; struct nfs4_sequence_args seq_args ; } ;

struct nfs4_delegreturnres { struct nfs_fattr * fattr ; const struct nfs_server * server ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_readargs { struct nfs_fh * fh ; struct nfs_open_context * context ; __u64 offset ; __u32 count ; unsigned int pgbase ; struct page * * pages ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_readres { struct nfs_fattr * fattr ; __u32 count ; int eof ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_writeargs { struct nfs_fh * fh ; struct nfs_open_context * context ; __u64 offset ; __u32 count ; enum nfs3_stable_how stable ; unsigned int pgbase ; struct page * * pages ; const u32 * bitmask ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_writeverf { enum nfs3_stable_how committed ; __be32 verifier [ 2 ] ; } ;

struct nfs_writeres { struct nfs_fattr * fattr ; struct nfs_writeverf * verf ; __u32 count ; const struct nfs_server * server ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_removeargs { const struct nfs_fh * fh ; struct qstr name ; const u32 * bitmask ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_removeres { const struct nfs_server * server ; struct nfs4_change_info cinfo ; struct nfs_fattr dir_attr ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_entry { __u64 ino ; __u64 cookie , prev_cookie ; const char * name ; unsigned int len ; int eof ; struct nfs_fh * fh ; struct nfs_fattr * fattr ; } ;

struct nfs_sattrargs { struct nfs_fh * fh ; struct iattr * sattr ; } ;

struct nfs_diropargs { struct nfs_fh * fh ; const char * name ; unsigned int len ; } ;

struct nfs_createargs { struct nfs_fh * fh ; const char * name ; unsigned int len ; struct iattr * sattr ; } ;

struct nfs_renameargs { struct nfs_fh * fromfh ; const char * fromname ; unsigned int fromlen ; struct nfs_fh * tofh ; const char * toname ; unsigned int tolen ; } ;

struct nfs_setattrargs { struct nfs_fh * fh ; nfs4_stateid stateid ; struct iattr * iap ; const struct nfs_server * server ; const u32 * bitmask ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_setaclargs { struct nfs_fh * fh ; size_t acl_len ; unsigned int acl_pgbase ; struct page * * acl_pages ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_setaclres { struct nfs4_sequence_res seq_res ; } ;

struct nfs_getaclargs { struct nfs_fh * fh ; size_t acl_len ; unsigned int acl_pgbase ; struct page * * acl_pages ; struct nfs4_sequence_args seq_args ; } ;

struct nfs_getaclres { size_t acl_len ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_setattrres { struct nfs_fattr * fattr ; const struct nfs_server * server ; struct nfs4_sequence_res seq_res ; } ;

struct nfs_linkargs { struct nfs_fh * fromfh ; struct nfs_fh * tofh ; const char * toname ; unsigned int tolen ; } ;

struct nfs_symlinkargs { struct nfs_fh * fromfh ; const char * fromname ; unsigned int fromlen ; struct page * * pages ; unsigned int pathlen ; struct iattr * sattr ; } ;

struct nfs_readdirargs { struct nfs_fh * fh ; __u32 cookie ; unsigned int count ; struct page * * pages ; } ;

struct nfs3_getaclargs { struct nfs_fh * fh ; int mask ; struct page * * pages ; } ;

struct nfs3_setaclargs { struct inode * inode ; int mask ; struct posix_acl * acl_access ; struct posix_acl * acl_default ; size_t len ; unsigned int npages ; struct page * * pages ; } ;

struct nfs_diropok { struct nfs_fh * fh ; struct nfs_fattr * fattr ; } ;

struct nfs_readlinkargs { struct nfs_fh * fh ; unsigned int pgbase ; unsigned int pglen ; struct page * * pages ; } ;

struct nfs3_sattrargs { struct nfs_fh * fh ; struct iattr * sattr ; unsigned int guard ; struct timespec guardtime ; } ;

struct nfs3_diropargs { struct nfs_fh * fh ; const char * name ; unsigned int len ; } ;

struct nfs3_accessargs { struct nfs_fh * fh ; __u32 access ; } ;

struct nfs3_createargs { struct nfs_fh * fh ; const char * name ; unsigned int len ; struct iattr * sattr ; enum nfs3_createmode createmode ; __be32 verifier [ 2 ] ; } ;

struct nfs3_mkdirargs { struct nfs_fh * fh ; const char * name ; unsigned int len ; struct iattr * sattr ; } ;

struct nfs3_symlinkargs { struct nfs_fh * fromfh ; const char * fromname ; unsigned int fromlen ; struct page * * pages ; unsigned int pathlen ; struct iattr * sattr ; } ;

struct nfs3_mknodargs { struct nfs_fh * fh ; const char * name ; unsigned int len ; enum nfs3_ftype type ; struct iattr * sattr ; dev_t rdev ; } ;

struct nfs3_renameargs { struct nfs_fh * fromfh ; const char * fromname ; unsigned int fromlen ; struct nfs_fh * tofh ; const char * toname ; unsigned int tolen ; } ;

struct nfs3_linkargs { struct nfs_fh * fromfh ; struct nfs_fh * tofh ; const char * toname ; unsigned int tolen ; } ;

struct nfs3_readdirargs { struct nfs_fh * fh ; __u64 cookie ; __be32 verf [ 2 ] ; int plus ; unsigned int count ; struct page * * pages ; } ;

struct nfs3_diropres { struct nfs_fattr * dir_attr ; struct nfs_fh * fh ; struct nfs_fattr * fattr ; } ;

struct nfs3_accessres { struct nfs_fattr * fattr ; __u32 access ; } ;

struct nfs3_readlinkargs { struct nfs_fh * fh ; unsigned int pgbase ; unsigned int pglen ; struct page * * pages ; } ;

struct nfs3_renameres { struct nfs_fattr * fromattr ; struct nfs_fattr * toattr ; } ;

struct nfs3_linkres { struct nfs_fattr * dir_attr ; struct nfs_fattr * fattr ; } ;

struct nfs3_readdirres { struct nfs_fattr * dir_attr ; __be32 * verf ; int plus ; } ;

struct nfs3_getaclres { struct nfs_fattr * fattr ; int mask ; unsigned int acl_access_count ; unsigned int acl_default_count ; struct posix_acl * acl_access ; struct posix_acl * acl_default ; } ;

struct nfstime4 { u64 seconds ; u32 nseconds ; } ;

struct nfs_page ;

struct nfs_read_data { int flags ; struct rpc_task task ; struct inode * inode ; struct rpc_cred * cred ; struct nfs_fattr fattr ; struct list_head pages ; struct nfs_page * req ; struct page * * pagevec ; unsigned int npages ; struct nfs_readargs args ; struct nfs_readres res ; struct page * page_array [ ( 8U ) ] ; } ;

struct nfs_write_data { int flags ; struct rpc_task task ; struct inode * inode ; struct rpc_cred * cred ; struct nfs_fattr fattr ; struct nfs_writeverf verf ; struct list_head pages ; struct nfs_page * req ; struct page * * pagevec ; unsigned int npages ; struct nfs_writeargs args ; struct nfs_writeres res ; struct page * page_array [ ( 8U ) ] ; } ;

struct nfs_access_entry ;

struct nfs_rpc_ops { u32 version ; const struct dentry_operations * dentry_ops ; const struct inode_operations * dir_inode_ops ; const struct inode_operations * file_inode_ops ; int ( * getroot ) ( struct nfs_server * , struct nfs_fh * , struct nfs_fsinfo * ) ; int ( * lookupfh ) ( struct nfs_server * , struct nfs_fh * , struct qstr * , struct nfs_fh * , struct nfs_fattr * ) ; int ( * getattr ) ( struct nfs_server * , struct nfs_fh * , struct nfs_fattr * ) ; int ( * setattr ) ( struct dentry * , struct nfs_fattr * , struct iattr * ) ; int ( * lookup ) ( struct inode * , struct qstr * , struct nfs_fh * , struct nfs_fattr * ) ; int ( * access ) ( struct inode * , struct nfs_access_entry * ) ; int ( * readlink ) ( struct inode * , struct page * , unsigned int , unsigned int ) ; int ( * create ) ( struct inode * , struct dentry * , struct iattr * , int , struct nameidata * ) ; int ( * remove ) ( struct inode * , struct qstr * ) ; void ( * unlink_setup ) ( struct rpc_message * , struct inode * dir ) ; int ( * unlink_done ) ( struct rpc_task * , struct inode * ) ; int ( * rename ) ( struct inode * , struct qstr * , struct inode * , struct qstr * ) ; int ( * link ) ( struct inode * , struct inode * , struct qstr * ) ; int ( * symlink ) ( struct inode * , struct dentry * , struct page * , unsigned int , struct iattr * ) ; int ( * mkdir ) ( struct inode * , struct dentry * , struct iattr * ) ; int ( * rmdir ) ( struct inode * , struct qstr * ) ; int ( * readdir ) ( struct dentry * , struct rpc_cred * , u64 , struct page * , unsigned int , int ) ; int ( * mknod ) ( struct inode * , struct dentry * , struct iattr * , dev_t ) ; int ( * statfs ) ( struct nfs_server * , struct nfs_fh * , struct nfs_fsstat * ) ; int ( * fsinfo ) ( struct nfs_server * , struct nfs_fh * , struct nfs_fsinfo * ) ; int ( * pathconf ) ( struct nfs_server * , struct nfs_fh * , struct nfs_pathconf * ) ; int ( * set_capabilities ) ( struct nfs_server * , struct nfs_fh * ) ; __be32 * ( * decode_dirent ) ( __be32 * , struct nfs_entry * , int plus ) ; void ( * read_setup ) ( struct nfs_read_data * , struct rpc_message * ) ; int ( * read_done ) ( struct rpc_task * , struct nfs_read_data * ) ; void ( * write_setup ) ( struct nfs_write_data * , struct rpc_message * ) ; int ( * write_done ) ( struct rpc_task * , struct nfs_write_data * ) ; void ( * commit_setup ) ( struct nfs_write_data * , struct rpc_message * ) ; int ( * commit_done ) ( struct rpc_task * , struct nfs_write_data * ) ; int ( * lock ) ( struct file * , int , struct file_lock * ) ; int ( * lock_check_bounds ) ( const struct file_lock * ) ; void ( * clear_acl_cache ) ( struct inode * ) ; void ( * close_context ) ( struct nfs_open_context * ctx , int ) ; } ;

enum bdi_state { BDI_pending , BDI_wb_alloc , BDI_async_congested , BDI_sync_congested , BDI_registered , BDI_unused , } ;

typedef int ( congested_fn ) ( void * , int ) ;
enum bdi_stat_item { BDI_RECLAIMABLE , BDI_WRITEBACK , NR_BDI_STAT_ITEMS } ;

struct bdi_writeback { struct list_head list ; struct backing_dev_info * bdi ; unsigned int nr ; unsigned long last_old_flush ; struct task_struct * task ; struct list_head b_dirty ; struct list_head b_io ; struct list_head b_more_io ; } ;
struct backing_dev_info { struct list_head bdi_list ; struct rcu_head rcu_head ; unsigned long ra_pages ; unsigned long state ; unsigned int capabilities ; congested_fn * congested_fn ; void * congested_data ; void ( * unplug_io_fn ) ( struct backing_dev_info * , struct page * ) ; void * unplug_io_data ; char * name ; struct percpu_counter bdi_stat [ NR_BDI_STAT_ITEMS ] ; struct prop_local_percpu completions ; int dirty_exceeded ; unsigned int min_ratio ; unsigned int max_ratio , max_prop_frac ; struct bdi_writeback wb ; spinlock_t wb_lock ; struct list_head wb_list ; struct list_head work_list ; struct device * dev ; struct dentry * debug_dir ; struct dentry * debug_stats ; } ;
enum { BLK_RW_ASYNC = 0 , BLK_RW_SYNC = 1 , } ;
struct nfs4_session ;

struct nfs_iostats ;

struct nlm_host ;

struct nfs4_sequence_args ;
struct nfs4_sequence_res ;
struct nfs_server ;

struct nfs_client { atomic_t cl_count ; int cl_cons_state ; unsigned long cl_res_state ; struct __kernel_sockaddr_storage cl_addr ; size_t cl_addrlen ; char * cl_hostname ; struct list_head cl_share_link ; struct list_head cl_superblocks ; struct rpc_clnt * cl_rpcclient ; const struct nfs_rpc_ops * rpc_ops ; int cl_proto ; u32 cl_minorversion ; struct rpc_cred * cl_machine_cred ; } ;

struct nfs_server { struct nfs_client * nfs_client ; struct list_head client_link ; struct list_head master_link ; struct rpc_clnt * client ; struct rpc_clnt * client_acl ; struct nlm_host * nlm_host ; struct nfs_iostats * io_stats ; struct backing_dev_info backing_dev_info ; atomic_long_t writeback ; int flags ; unsigned int caps ; unsigned int rsize ; unsigned int rpages ; unsigned int wsize ; unsigned int wpages ; unsigned int wtmult ; unsigned int dtsize ; unsigned short port ; unsigned int bsize ; unsigned int acregmin ; unsigned int acregmax ; unsigned int acdirmin ; unsigned int acdirmax ; unsigned int namelen ; unsigned int options ; struct nfs_fsid fsid ; __u64 maxfilesize ; unsigned long mount_time ; dev_t s_dev ; void ( * destroy ) ( struct nfs_server * ) ; atomic_t active ; struct __kernel_sockaddr_storage mountd_address ; size_t mountd_addrlen ; u32 mountd_version ; unsigned short mountd_port ; unsigned short mountd_protocol ; } ;
struct kmem_cache ;
typedef void * ( mempool_alloc_t ) ( gfp_t gfp_mask , void * pool_data ) ;
typedef void ( mempool_free_t ) ( void * element , void * pool_data ) ;

typedef struct mempool_s { spinlock_t lock ; int min_nr ; int curr_nr ; void * * elements ; void * pool_data ; mempool_alloc_t * alloc ; mempool_free_t * free ; wait_queue_head_t wait ; } mempool_t ;

struct nfs_access_entry { struct rb_node rb_node ; struct list_head lru ; unsigned long jiffies ; struct rpc_cred * cred ; int mask ; } ;
struct nfs4_state ;

struct nfs_open_context { atomic_t count ; struct path path ; struct rpc_cred * cred ; struct nfs4_state * state ; fl_owner_t lockowner ; fmode_t mode ; unsigned long flags ; int error ; struct list_head list ; __u64 dir_cookie ; } ;

struct nfs_delegation ;

struct nfs_inode { __u64 fileid ; struct nfs_fh fh ; unsigned long flags ; unsigned long cache_validity ; unsigned long read_cache_jiffies ; unsigned long attrtimeo ; unsigned long attrtimeo_timestamp ; __u64 change_attr ; unsigned long attr_gencount ; unsigned long cache_change_attribute ; struct rb_root access_cache ; struct list_head access_cache_entry_lru ; struct list_head access_cache_inode_lru ; __be32 cookieverf [ 2 ] ; struct radix_tree_root nfs_page_tree ; unsigned long npages ; struct list_head open_files ; atomic_t silly_count ; struct hlist_head silly_list ; wait_queue_head_t waitqueue ; struct inode vfs_inode ; } ;

struct nfs_mount_data { int version ; int fd ; struct nfs2_fh old_root ; int flags ; int rsize ; int wsize ; int timeo ; int retrans ; int acregmin ; int acregmax ; int acdirmin ; int acdirmax ; struct sockaddr_in addr ; char hostname [ 255 + 1 ] ; int namlen ; unsigned int bsize ; struct nfs3_fh root ; int pseudoflavor ; char context [ 256 + 1 ] ; } ;

struct as_io_context { spinlock_t lock ; void ( * dtor ) ( struct as_io_context * aic ) ; void ( * exit ) ( struct as_io_context * aic ) ; unsigned long state ; atomic_t nr_queued ; atomic_t nr_dispatched ; unsigned long last_end_request ; unsigned long ttime_total ; unsigned long ttime_samples ; unsigned long ttime_mean ; unsigned int seek_samples ; sector_t last_request_pos ; u64 seek_total ; sector_t seek_mean ; } ;

struct cfq_queue ;

struct cfq_io_context { void * key ; unsigned long dead_key ; struct cfq_queue * cfqq [ 2 ] ; struct io_context * ioc ; unsigned long last_end_request ; sector_t last_request_pos ; unsigned long ttime_total ; unsigned long ttime_samples ; unsigned long ttime_mean ; unsigned int seek_samples ; u64 seek_total ; sector_t seek_mean ; struct list_head queue_list ; struct hlist_node cic_list ; void ( * dtor ) ( struct io_context * ) ; void ( * exit ) ( struct io_context * ) ; struct rcu_head rcu_head ; } ;

struct io_context { atomic_long_t refcount ; atomic_t nr_tasks ; spinlock_t lock ; unsigned short ioprio ; unsigned short ioprio_changed ; unsigned long last_waited ; int nr_batch_requests ; struct as_io_context * aic ; struct radix_tree_root radix_root ; struct hlist_head cic_list ; void * ioc_data ; } ;
enum { IOPRIO_CLASS_NONE , IOPRIO_CLASS_RT , IOPRIO_CLASS_BE , IOPRIO_CLASS_IDLE , } ;
enum { IOPRIO_WHO_PROCESS = 1 , IOPRIO_WHO_PGRP , IOPRIO_WHO_USER , } ;
struct bio_vec { struct page * bv_page ; unsigned int bv_len ; unsigned int bv_offset ; } ;

struct bio_set ;

struct bio_integrity_payload ;

typedef void ( bio_end_io_t ) ( struct bio * , int ) ;
typedef void ( bio_destructor_t ) ( struct bio * ) ;
struct bio { sector_t bi_sector ; struct bio * bi_next ; struct block_device * bi_bdev ; unsigned long bi_flags ; unsigned long bi_rw ; unsigned short bi_vcnt ; unsigned short bi_idx ; unsigned int bi_phys_segments ; unsigned int bi_size ; unsigned int bi_seg_front_size ; unsigned int bi_seg_back_size ; unsigned int bi_max_vecs ; unsigned int bi_comp_cpu ; atomic_t bi_cnt ; struct bio_vec * bi_io_vec ; bio_end_io_t * bi_end_io ; void * bi_private ; struct bio_integrity_payload * bi_integrity ; bio_destructor_t * bi_destructor ; struct bio_vec bi_inline_vecs [ 0 ] ; } ;
enum bio_rw_flags { BIO_RW , BIO_RW_FAILFAST_DEV , BIO_RW_FAILFAST_TRANSPORT , BIO_RW_FAILFAST_DRIVER , BIO_RW_AHEAD , BIO_RW_BARRIER , BIO_RW_SYNCIO , BIO_RW_UNPLUG , BIO_RW_META , BIO_RW_DISCARD , BIO_RW_NOIDLE , } ;

struct bio_integrity_payload { struct bio * bip_bio ; sector_t bip_sector ; void * bip_buf ; bio_end_io_t * bip_end_io ; unsigned int bip_size ; unsigned short bip_slab ; unsigned short bip_vcnt ; unsigned short bip_idx ; struct work_struct bip_work ; struct bio_vec bip_vec [ 0 ] ; } ;
struct bio_pair { struct bio bio1 , bio2 ; struct bio_vec bv1 , bv2 ; struct bio_integrity_payload bip1 , bip2 ; struct bio_vec iv1 , iv2 ; atomic_t cnt ; int error ; } ;

struct request_queue ;

struct sg_iovec ;

struct rq_map_data ;

struct bio_set { struct kmem_cache * bio_slab ; unsigned int front_pad ; mempool_t * bio_pool ; mempool_t * bio_integrity_pool ; mempool_t * bvec_pool ; } ;
struct biovec_slab { int nr_vecs ; char * name ; struct kmem_cache * slab ; } ;

struct bio_list { struct bio * head ; struct bio * tail ; } ;

struct sg_io_v4 { __s32 guard ; __u32 protocol ; __u32 subprotocol ; __u32 request_len ; __u64 request ; __u64 request_tag ; __u32 request_attr ; __u32 request_priority ; __u32 request_extra ; __u32 max_response_len ; __u64 response ; __u32 dout_iovec_count ; __u32 dout_xfer_len ; __u32 din_iovec_count ; __u32 din_xfer_len ; __u64 dout_xferp ; __u64 din_xferp ; __u32 timeout ; __u32 flags ; __u64 usr_ptr ; __u32 spare_in ; __u32 driver_status ; __u32 transport_status ; __u32 device_status ; __u32 retry_delay ; __u32 info ; __u32 duration ; __u32 response_len ; __s32 din_resid ; __s32 dout_resid ; __u64 generated_tag ; __u32 spare_out ; __u32 padding ; } ;

struct bsg_class_device { struct device * class_dev ; struct device * parent ; int minor ; struct request_queue * queue ; struct kref ref ; void ( * release ) ( struct device * ) ; } ;

struct scsi_ioctl_command ;

struct elevator_queue ;

struct request_pm_state ;

struct blk_trace ;

struct request ;

struct sg_io_hdr ;

typedef void ( rq_end_io_fn ) ( struct request * , int ) ;
struct request_list { int count [ 2 ] ; int starved [ 2 ] ; int elvpriv ; mempool_t * rq_pool ; wait_queue_head_t wait [ 2 ] ; } ;

enum rq_cmd_type_bits { REQ_TYPE_FS = 1 , REQ_TYPE_BLOCK_PC , REQ_TYPE_SENSE , REQ_TYPE_PM_SUSPEND , REQ_TYPE_PM_RESUME , REQ_TYPE_PM_SHUTDOWN , REQ_TYPE_SPECIAL , REQ_TYPE_LINUX_BLOCK , REQ_TYPE_ATA_TASKFILE , REQ_TYPE_ATA_PC , } ;

enum { REQ_LB_OP_EJECT = 0x40 , REQ_LB_OP_FLUSH = 0x41 , } ;
enum rq_flag_bits { __REQ_RW , __REQ_FAILFAST_DEV , __REQ_FAILFAST_TRANSPORT , __REQ_FAILFAST_DRIVER , __REQ_DISCARD , __REQ_SORTED , __REQ_SOFTBARRIER , __REQ_HARDBARRIER , __REQ_FUA , __REQ_NOMERGE , __REQ_STARTED , __REQ_DONTPREP , __REQ_QUEUED , __REQ_ELVPRIV , __REQ_FAILED , __REQ_QUIET , __REQ_PREEMPT , __REQ_ORDERED_COLOR , __REQ_RW_SYNC , __REQ_ALLOCED , __REQ_RW_META , __REQ_COPY_USER , __REQ_INTEGRITY , __REQ_NOIDLE , __REQ_IO_STAT , __REQ_MIXED_MERGE , __REQ_NR_BITS , } ;

struct request { struct list_head queuelist ; struct call_single_data csd ; int cpu ; struct request_queue * q ; unsigned int cmd_flags ; enum rq_cmd_type_bits cmd_type ; unsigned long atomic_flags ; sector_t __sector ; unsigned int __data_len ; struct bio * bio ; struct bio * biotail ; struct hlist_node hash ; union { struct rb_node rb_node ; void * completion_data ; } ; void * elevator_private ; void * elevator_private2 ; struct gendisk * rq_disk ; unsigned long start_time ; unsigned short nr_phys_segments ; unsigned short ioprio ; void * special ; char * buffer ; int tag ; int errors ; int ref_count ; unsigned short cmd_len ; unsigned char __cmd [ 16 ] ; unsigned char * cmd ; unsigned int extra_len ; unsigned int sense_len ; unsigned int resid_len ; void * sense ; unsigned long deadline ; struct list_head timeout_list ; unsigned int timeout ; int retries ; rq_end_io_fn * end_io ; void * end_io_data ; struct request * next_rq ; } ;
struct request_pm_state { int pm_step ; u32 pm_state ; void * data ; } ;
typedef int ( elevator_merge_fn ) ( struct request_queue * , struct request * * , struct bio * ) ;
typedef void ( elevator_merge_req_fn ) ( struct request_queue * , struct request * , struct request * ) ;
typedef void ( elevator_merged_fn ) ( struct request_queue * , struct request * , int ) ;
typedef int ( elevator_allow_merge_fn ) ( struct request_queue * , struct request * , struct bio * ) ;
typedef int ( elevator_dispatch_fn ) ( struct request_queue * , int ) ;
typedef void ( elevator_add_req_fn ) ( struct request_queue * , struct request * ) ;
typedef int ( elevator_queue_empty_fn ) ( struct request_queue * ) ;
typedef struct request * ( elevator_request_list_fn ) ( struct request_queue * , struct request * ) ;
typedef void ( elevator_completed_req_fn ) ( struct request_queue * , struct request * ) ;
typedef int ( elevator_may_queue_fn ) ( struct request_queue * , int ) ;
typedef int ( elevator_set_req_fn ) ( struct request_queue * , struct request * , gfp_t ) ;
typedef void ( elevator_put_req_fn ) ( struct request * ) ;
typedef void ( elevator_activate_req_fn ) ( struct request_queue * , struct request * ) ;
typedef void ( elevator_deactivate_req_fn ) ( struct request_queue * , struct request * ) ;
typedef void * ( elevator_init_fn ) ( struct request_queue * ) ;
typedef void ( elevator_exit_fn ) ( struct elevator_queue * ) ;
struct elevator_ops { elevator_merge_fn * elevator_merge_fn ; elevator_merged_fn * elevator_merged_fn ; elevator_merge_req_fn * elevator_merge_req_fn ; elevator_allow_merge_fn * elevator_allow_merge_fn ; elevator_dispatch_fn * elevator_dispatch_fn ; elevator_add_req_fn * elevator_add_req_fn ; elevator_activate_req_fn * elevator_activate_req_fn ; elevator_deactivate_req_fn * elevator_deactivate_req_fn ; elevator_queue_empty_fn * elevator_queue_empty_fn ; elevator_completed_req_fn * elevator_completed_req_fn ; elevator_request_list_fn * elevator_former_req_fn ; elevator_request_list_fn * elevator_latter_req_fn ; elevator_set_req_fn * elevator_set_req_fn ; elevator_put_req_fn * elevator_put_req_fn ; elevator_may_queue_fn * elevator_may_queue_fn ; elevator_init_fn * elevator_init_fn ; elevator_exit_fn * elevator_exit_fn ; void ( * trim ) ( struct io_context * ) ; } ;

struct elv_fs_entry { struct attribute attr ; ssize_t ( * show ) ( struct elevator_queue * , char * ) ; ssize_t ( * store ) ( struct elevator_queue * , const char * , size_t ) ; } ;

struct elevator_type { struct list_head list ; struct elevator_ops ops ; struct elv_fs_entry * elevator_attrs ; char elevator_name [ ( 16 ) ] ; struct module * elevator_owner ; } ;

struct elevator_queue { struct elevator_ops * ops ; void * elevator_data ; struct kobject kobj ; struct elevator_type * elevator_type ; struct mutex sysfs_lock ; struct hlist_head * hash ; } ;
enum { ELV_MQUEUE_MAY , ELV_MQUEUE_NO , ELV_MQUEUE_MUST , } ;
typedef void ( request_fn_proc ) ( struct request_queue * q ) ;
typedef int ( make_request_fn ) ( struct request_queue * q , struct bio * bio ) ;
typedef int ( prep_rq_fn ) ( struct request_queue * , struct request * ) ;
typedef void ( unplug_fn ) ( struct request_queue * ) ;
struct bio_vec ;
struct bvec_merge_data { struct block_device * bi_bdev ; sector_t bi_sector ; unsigned bi_size ; unsigned long bi_rw ; } ;

typedef int ( merge_bvec_fn ) ( struct request_queue * , struct bvec_merge_data * , struct bio_vec * ) ;
typedef void ( prepare_flush_fn ) ( struct request_queue * , struct request * ) ;
typedef void ( softirq_done_fn ) ( struct request * ) ;
typedef int ( dma_drain_needed_fn ) ( struct request * ) ;
typedef int ( lld_busy_fn ) ( struct request_queue * q ) ;
enum blk_eh_timer_return { BLK_EH_NOT_HANDLED , BLK_EH_HANDLED , BLK_EH_RESET_TIMER , } ;

typedef enum blk_eh_timer_return ( rq_timed_out_fn ) ( struct request * ) ;

enum blk_queue_state { Queue_down , Queue_up , } ;

struct blk_queue_tag { struct request * * tag_index ; unsigned long * tag_map ; int busy ; int max_depth ; int real_max_depth ; atomic_t refcnt ; } ;

struct queue_limits { unsigned long bounce_pfn ; unsigned long seg_boundary_mask ; unsigned int max_hw_sectors ; unsigned int max_sectors ; unsigned int max_segment_size ; unsigned int physical_block_size ; unsigned int alignment_offset ; unsigned int io_min ; unsigned int io_opt ; unsigned int max_discard_sectors ; unsigned short logical_block_size ; unsigned short max_hw_segments ; unsigned short max_phys_segments ; unsigned char misaligned ; unsigned char no_cluster ; } ;

struct request_queue { struct list_head queue_head ; struct request * last_merge ; struct elevator_queue * elevator ; struct request_list rq ; request_fn_proc * request_fn ; make_request_fn * make_request_fn ; prep_rq_fn * prep_rq_fn ; unplug_fn * unplug_fn ; merge_bvec_fn * merge_bvec_fn ; prepare_flush_fn * prepare_flush_fn ; softirq_done_fn * softirq_done_fn ; rq_timed_out_fn * rq_timed_out_fn ; dma_drain_needed_fn * dma_drain_needed ; lld_busy_fn * lld_busy_fn ; sector_t end_sector ; struct request * boundary_rq ; struct timer_list unplug_timer ; int unplug_thresh ; unsigned long unplug_delay ; struct work_struct unplug_work ; struct backing_dev_info backing_dev_info ; void * queuedata ; gfp_t bounce_gfp ; unsigned long queue_flags ; spinlock_t __queue_lock ; spinlock_t * queue_lock ; struct kobject kobj ; unsigned long nr_requests ; unsigned int nr_congestion_on ; unsigned int nr_congestion_off ; unsigned int nr_batching ; void * dma_drain_buffer ; unsigned int dma_drain_size ; unsigned int dma_pad_mask ; unsigned int dma_alignment ; struct blk_queue_tag * queue_tags ; struct list_head tag_busy_list ; unsigned int nr_sorted ; unsigned int in_flight [ 2 ] ; unsigned int rq_timeout ; struct timer_list timeout ; struct list_head timeout_list ; struct queue_limits limits ; unsigned int sg_timeout ; unsigned int sg_reserved_size ; int node ; struct blk_trace * blk_trace ; unsigned int ordered , next_ordered , ordseq ; int orderr , ordcolor ; struct request pre_flush_rq , bar_rq , post_flush_rq ; struct request * orig_bar_rq ; struct mutex sysfs_lock ; struct bsg_class_device bsg_dev ; } ;
enum { QUEUE_ORDERED_BY_DRAIN = 0x01 , QUEUE_ORDERED_BY_TAG = 0x02 , QUEUE_ORDERED_DO_PREFLUSH = 0x10 , QUEUE_ORDERED_DO_BAR = 0x20 , QUEUE_ORDERED_DO_POSTFLUSH = 0x40 , QUEUE_ORDERED_DO_FUA = 0x80 , QUEUE_ORDERED_NONE = 0x00 , QUEUE_ORDERED_DRAIN = QUEUE_ORDERED_BY_DRAIN | QUEUE_ORDERED_DO_BAR , QUEUE_ORDERED_DRAIN_FLUSH = QUEUE_ORDERED_DRAIN | QUEUE_ORDERED_DO_PREFLUSH | QUEUE_ORDERED_DO_POSTFLUSH , QUEUE_ORDERED_DRAIN_FUA = QUEUE_ORDERED_DRAIN | QUEUE_ORDERED_DO_PREFLUSH | QUEUE_ORDERED_DO_FUA , QUEUE_ORDERED_TAG = QUEUE_ORDERED_BY_TAG | QUEUE_ORDERED_DO_BAR , QUEUE_ORDERED_TAG_FLUSH = QUEUE_ORDERED_TAG | QUEUE_ORDERED_DO_PREFLUSH | QUEUE_ORDERED_DO_POSTFLUSH , QUEUE_ORDERED_TAG_FUA = QUEUE_ORDERED_TAG | QUEUE_ORDERED_DO_PREFLUSH | QUEUE_ORDERED_DO_FUA , QUEUE_ORDSEQ_STARTED = 0x01 , QUEUE_ORDSEQ_DRAIN = 0x02 , QUEUE_ORDSEQ_PREFLUSH = 0x04 , QUEUE_ORDSEQ_BAR = 0x08 , QUEUE_ORDSEQ_POSTFLUSH = 0x10 , QUEUE_ORDSEQ_DONE = 0x20 , } ;
struct rq_map_data { struct page * * pages ; int page_order ; int nr_entries ; unsigned long offset ; int null_mapped ; int from_user ; } ;
struct req_iterator { int i ; struct bio * bio ; } ;

typedef struct { struct page * v ; } Sector ;

struct blk_integrity_exchg { void * prot_buf ; void * data_buf ; sector_t sector ; unsigned int data_size ; unsigned short sector_size ; const char * disk_name ; } ;

typedef void ( integrity_gen_fn ) ( struct blk_integrity_exchg * ) ;
typedef int ( integrity_vrfy_fn ) ( struct blk_integrity_exchg * ) ;
typedef void ( integrity_set_tag_fn ) ( void * , void * , unsigned int ) ;
typedef void ( integrity_get_tag_fn ) ( void * , void * , unsigned int ) ;
struct blk_integrity { integrity_gen_fn * generate_fn ; integrity_vrfy_fn * verify_fn ; integrity_set_tag_fn * set_tag_fn ; integrity_get_tag_fn * get_tag_fn ; unsigned short flags ; unsigned short tuple_size ; unsigned short sector_size ; unsigned short tag_size ; const char * name ; struct kobject kobj ; } ;

struct block_device_operations { int ( * open ) ( struct block_device * , fmode_t ) ; int ( * release ) ( struct gendisk * , fmode_t ) ; int ( * locked_ioctl ) ( struct block_device * , fmode_t , unsigned , unsigned long ) ; int ( * ioctl ) ( struct block_device * , fmode_t , unsigned , unsigned long ) ; int ( * compat_ioctl ) ( struct block_device * , fmode_t , unsigned , unsigned long ) ; int ( * direct_access ) ( struct block_device * , sector_t , void * * , unsigned long * ) ; int ( * media_changed ) ( struct gendisk * ) ; unsigned long long ( * set_capacity ) ( struct gendisk * , unsigned long long ) ; int ( * revalidate_disk ) ( struct gendisk * ) ; int ( * getgeo ) ( struct block_device * , struct hd_geometry * ) ; struct module * owner ; } ;
dev_t name_to_dev_t ( char * name ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mount_block_root ( char * name , int flags ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) change_floppy ( char * fmt , ... ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mount_root ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) prepare_namespace ( void ) ;

struct minix_inode { __u16 i_mode ; __u16 i_uid ; __u32 i_size ; __u32 i_time ; __u8 i_gid ; __u8 i_nlinks ; __u16 i_zone [ 9 ] ; } ;

struct minix2_inode { __u16 i_mode ; __u16 i_nlinks ; __u16 i_uid ; __u16 i_gid ; __u32 i_size ; __u32 i_atime ; __u32 i_mtime ; __u32 i_ctime ; __u32 i_zone [ 10 ] ; } ;

struct minix_super_block { __u16 s_ninodes ; __u16 s_nzones ; __u16 s_imap_blocks ; __u16 s_zmap_blocks ; __u16 s_firstdatazone ; __u16 s_log_zone_size ; __u32 s_max_size ; __u16 s_magic ; __u16 s_state ; __u32 s_zones ; } ;

struct minix3_super_block { __u32 s_ninodes ; __u16 s_pad0 ; __u16 s_imap_blocks ; __u16 s_zmap_blocks ; __u16 s_firstdatazone ; __u16 s_log_zone_size ; __u16 s_pad1 ; __u32 s_max_size ; __u32 s_zones ; __u16 s_magic ; __u16 s_pad2 ; __u16 s_blocksize ; __u8 s_disk_version ; } ;

struct minix_dir_entry { __u16 inode ; char name [ 0 ] ; } ;

struct minix3_dir_entry { __u32 inode ; char name [ 0 ] ; } ;

struct bgl_lock { spinlock_t lock ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct blockgroup_lock { struct bgl_lock locks [ 128 ] ; } ;

typedef int ext2_grpblk_t ;

typedef unsigned long ext2_fsblk_t ;

struct ext2_reserve_window { ext2_fsblk_t _rsv_start ; ext2_fsblk_t _rsv_end ; } ;

struct ext2_reserve_window_node { struct rb_node rsv_node ; __u32 rsv_goal_size ; __u32 rsv_alloc_hit ; struct ext2_reserve_window rsv_window ; } ;

struct ext2_block_alloc_info { struct ext2_reserve_window_node rsv_window_node ; __u32 last_alloc_logical_block ; ext2_fsblk_t last_alloc_physical_block ; } ;

struct ext2_sb_info { unsigned long s_frag_size ; unsigned long s_frags_per_block ; unsigned long s_inodes_per_block ; unsigned long s_frags_per_group ; unsigned long s_blocks_per_group ; unsigned long s_inodes_per_group ; unsigned long s_itb_per_group ; unsigned long s_gdb_count ; unsigned long s_desc_per_block ; unsigned long s_groups_count ; unsigned long s_overhead_last ; unsigned long s_blocks_last ; struct buffer_head * s_sbh ; struct ext2_super_block * s_es ; struct buffer_head * * s_group_desc ; unsigned long s_mount_opt ; unsigned long s_sb_block ; uid_t s_resuid ; gid_t s_resgid ; unsigned short s_mount_state ; unsigned short s_pad ; int s_addr_per_block_bits ; int s_desc_per_block_bits ; int s_inode_size ; int s_first_ino ; spinlock_t s_next_gen_lock ; u32 s_next_generation ; unsigned long s_dir_count ; u8 * s_debts ; struct percpu_counter s_freeblocks_counter ; struct percpu_counter s_freeinodes_counter ; struct percpu_counter s_dirs_counter ; struct blockgroup_lock * s_blockgroup_lock ; spinlock_t s_rsv_window_lock ; struct rb_root s_rsv_window_root ; struct ext2_reserve_window_node s_rsv_window_head ; } ;

struct ext2_group_desc { __le32 bg_block_bitmap ; __le32 bg_inode_bitmap ; __le32 bg_inode_table ; __le16 bg_free_blocks_count ; __le16 bg_free_inodes_count ; __le16 bg_used_dirs_count ; __le16 bg_pad ; __le32 bg_reserved [ 3 ] ; } ;

struct ext2_inode { __le16 i_mode ; __le16 i_uid ; __le32 i_size ; __le32 i_atime ; __le32 i_ctime ; __le32 i_mtime ; __le32 i_dtime ; __le16 i_gid ; __le16 i_links_count ; __le32 i_blocks ; __le32 i_flags ; union { struct { __le32 l_i_reserved1 ; } linux1 ; struct { __le32 h_i_translator ; } hurd1 ; struct { __le32 m_i_reserved1 ; } masix1 ; } osd1 ; __le32 i_block [ ( ( ( 12 + 1 ) + 1 ) + 1 ) ] ; __le32 i_generation ; __le32 i_file_acl ; __le32 i_dir_acl ; __le32 i_faddr ; union { struct { __u8 l_i_frag ; __u8 l_i_fsize ; __u16 i_pad1 ; __le16 l_i_uid_high ; __le16 l_i_gid_high ; __u32 l_i_reserved2 ; } linux2 ; struct { __u8 h_i_frag ; __u8 h_i_fsize ; __le16 h_i_mode_high ; __le16 h_i_uid_high ; __le16 h_i_gid_high ; __le32 h_i_author ; } hurd2 ; struct { __u8 m_i_frag ; __u8 m_i_fsize ; __u16 m_pad1 ; __u32 m_i_reserved2 [ 2 ] ; } masix2 ; } osd2 ; } ;

struct ext2_super_block { __le32 s_inodes_count ; __le32 s_blocks_count ; __le32 s_r_blocks_count ; __le32 s_free_blocks_count ; __le32 s_free_inodes_count ; __le32 s_first_data_block ; __le32 s_log_block_size ; __le32 s_log_frag_size ; __le32 s_blocks_per_group ; __le32 s_frags_per_group ; __le32 s_inodes_per_group ; __le32 s_mtime ; __le32 s_wtime ; __le16 s_mnt_count ; __le16 s_max_mnt_count ; __le16 s_magic ; __le16 s_state ; __le16 s_errors ; __le16 s_minor_rev_level ; __le32 s_lastcheck ; __le32 s_checkinterval ; __le32 s_creator_os ; __le32 s_rev_level ; __le16 s_def_resuid ; __le16 s_def_resgid ; __le32 s_first_ino ; __le16 s_inode_size ; __le16 s_block_group_nr ; __le32 s_feature_compat ; __le32 s_feature_incompat ; __le32 s_feature_ro_compat ; __u8 s_uuid [ 16 ] ; char s_volume_name [ 16 ] ; char s_last_mounted [ 64 ] ; __le32 s_algorithm_usage_bitmap ; __u8 s_prealloc_blocks ; __u8 s_prealloc_dir_blocks ; __u16 s_padding1 ; __u8 s_journal_uuid [ 16 ] ; __u32 s_journal_inum ; __u32 s_journal_dev ; __u32 s_last_orphan ; __u32 s_hash_seed [ 4 ] ; __u8 s_def_hash_version ; __u8 s_reserved_char_pad ; __u16 s_reserved_word_pad ; __le32 s_default_mount_opts ; __le32 s_first_meta_bg ; __u32 s_reserved [ 190 ] ; } ;

struct ext2_dir_entry { __le32 inode ; __le16 rec_len ; __le16 name_len ; char name [ 255 ] ; } ;

struct ext2_dir_entry_2 { __le32 inode ; __le16 rec_len ; __u8 name_len ; __u8 file_type ; char name [ 255 ] ; } ;

enum { EXT2_FT_UNKNOWN , EXT2_FT_REG_FILE , EXT2_FT_DIR , EXT2_FT_CHRDEV , EXT2_FT_BLKDEV , EXT2_FT_FIFO , EXT2_FT_SOCK , EXT2_FT_SYMLINK , EXT2_FT_MAX } ;
struct romfs_super_block { __be32 word0 ; __be32 word1 ; __be32 size ; __be32 checksum ; char name [ 0 ] ; } ;

struct romfs_inode { __be32 next ; __be32 spec ; __be32 size ; __be32 checksum ; char name [ 0 ] ; } ;

struct cramfs_inode { __u32 mode : 16 , uid : 16 ; __u32 size : 24 , gid : 8 ; __u32 namelen : 6 , offset : 26 ; } ;

struct cramfs_info { __u32 crc ; __u32 edition ; __u32 blocks ; __u32 files ; } ;

struct cramfs_super { __u32 magic ; __u32 size ; __u32 flags ; __u32 future ; __u8 signature [ 16 ] ; struct cramfs_info fsid ; __u8 name [ 16 ] ; struct cramfs_inode root ; } ;

struct meta_entry { u64 data_block ; unsigned int index_block ; unsigned short offset ; unsigned short pad ; } ;

struct meta_index { unsigned int inode_number ; unsigned int offset ; unsigned short entries ; unsigned short skip ; unsigned short locked ; unsigned short pad ; struct meta_entry meta_entry [ 127 ] ; } ;

struct squashfs_super_block { __le32 s_magic ; __le32 inodes ; __le32 mkfs_time ; __le32 block_size ; __le32 fragments ; __le16 compression ; __le16 block_log ; __le16 flags ; __le16 no_ids ; __le16 s_major ; __le16 s_minor ; __le64 root_inode ; __le64 bytes_used ; __le64 id_table_start ; __le64 xattr_table_start ; __le64 inode_table_start ; __le64 directory_table_start ; __le64 fragment_table_start ; __le64 lookup_table_start ; } ;

struct squashfs_dir_index { __le32 index ; __le32 start_block ; __le32 size ; unsigned char name [ 0 ] ; } ;

struct squashfs_base_inode { __le16 inode_type ; __le16 mode ; __le16 uid ; __le16 guid ; __le32 mtime ; __le32 inode_number ; } ;

struct squashfs_ipc_inode { __le16 inode_type ; __le16 mode ; __le16 uid ; __le16 guid ; __le32 mtime ; __le32 inode_number ; __le32 nlink ; } ;

struct squashfs_dev_inode { __le16 inode_type ; __le16 mode ; __le16 uid ; __le16 guid ; __le32 mtime ; __le32 inode_number ; __le32 nlink ; __le32 rdev ; } ;

struct squashfs_symlink_inode { __le16 inode_type ; __le16 mode ; __le16 uid ; __le16 guid ; __le32 mtime ; __le32 inode_number ; __le32 nlink ; __le32 symlink_size ; char symlink [ 0 ] ; } ;

struct squashfs_reg_inode { __le16 inode_type ; __le16 mode ; __le16 uid ; __le16 guid ; __le32 mtime ; __le32 inode_number ; __le32 start_block ; __le32 fragment ; __le32 offset ; __le32 file_size ; __le16 block_list [ 0 ] ; } ;

struct squashfs_lreg_inode { __le16 inode_type ; __le16 mode ; __le16 uid ; __le16 guid ; __le32 mtime ; __le32 inode_number ; __le64 start_block ; __le64 file_size ; __le64 sparse ; __le32 nlink ; __le32 fragment ; __le32 offset ; __le32 xattr ; __le16 block_list [ 0 ] ; } ;

struct squashfs_dir_inode { __le16 inode_type ; __le16 mode ; __le16 uid ; __le16 guid ; __le32 mtime ; __le32 inode_number ; __le32 start_block ; __le32 nlink ; __le16 file_size ; __le16 offset ; __le32 parent_inode ; } ;

struct squashfs_ldir_inode { __le16 inode_type ; __le16 mode ; __le16 uid ; __le16 guid ; __le32 mtime ; __le32 inode_number ; __le32 nlink ; __le32 file_size ; __le32 start_block ; __le32 parent_inode ; __le16 i_count ; __le16 offset ; __le32 xattr ; struct squashfs_dir_index index [ 0 ] ; } ;

union squashfs_inode { struct squashfs_base_inode base ; struct squashfs_dev_inode dev ; struct squashfs_symlink_inode symlink ; struct squashfs_reg_inode reg ; struct squashfs_lreg_inode lreg ; struct squashfs_dir_inode dir ; struct squashfs_ldir_inode ldir ; struct squashfs_ipc_inode ipc ; } ;

struct squashfs_dir_entry { __le16 offset ; __le16 inode_number ; __le16 type ; __le16 size ; char name [ 0 ] ; } ;

struct squashfs_dir_header { __le32 count ; __le32 start_block ; __le32 inode_number ; } ;

struct squashfs_fragment_entry { __le64 start_block ; __le32 size ; unsigned int unused ; } ;

typedef int ( * decompress_fn ) ( unsigned char * inbuf , int len , int ( * fill ) ( void * , unsigned int ) , int ( * flush ) ( void * , unsigned int ) , unsigned char * outbuf , int * posp , void ( * error ) ( char * x ) ) ;
int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rd_load_image ( char * from ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rd_load_disk ( int n ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) initrd_load ( void ) ;


typedef struct mdu_version_s { int major ; int minor ; int patchlevel ; } mdu_version_t ;


typedef struct mdu_array_info_s { int major_version ; int minor_version ; int patch_version ; int ctime ; int level ; int size ; int nr_disks ; int raid_disks ; int md_minor ; int not_persistent ; int utime ; int state ; int active_disks ; int working_disks ; int failed_disks ; int spare_disks ; int layout ; int chunk_size ; } mdu_array_info_t ;


typedef struct mdu_disk_info_s { int number ; int major ; int minor ; int raid_disk ; int state ; } mdu_disk_info_t ;


typedef struct mdu_start_info_s { int major ; int minor ; int raid_disk ; int state ; } mdu_start_info_t ;


typedef struct mdu_bitmap_file_s { char pathname [ 4096 ] ; } mdu_bitmap_file_t ;


typedef struct mdu_param_s { int personality ; int chunk_size ; int max_fault ; } mdu_param_t ;


typedef struct mdp_device_descriptor_s { __u32 number ; __u32 major ; __u32 minor ; __u32 raid_disk ; __u32 state ; __u32 reserved [ 32 - 5 ] ; } mdp_disk_t ;


typedef struct mdp_superblock_s { __u32 md_magic ; __u32 major_version ; __u32 minor_version ; __u32 patch_version ; __u32 gvalid_words ; __u32 set_uuid0 ; __u32 ctime ; __u32 level ; __u32 size ; __u32 nr_disks ; __u32 raid_disks ; __u32 md_minor ; __u32 not_persistent ; __u32 set_uuid1 ; __u32 set_uuid2 ; __u32 set_uuid3 ; __u32 gstate_creserved [ 32 - 16 ] ; __u32 utime ; __u32 state ; __u32 active_disks ; __u32 working_disks ; __u32 failed_disks ; __u32 spare_disks ; __u32 sb_csum ; __u32 events_lo ; __u32 events_hi ; __u32 cp_events_lo ; __u32 cp_events_hi ; __u32 recovery_cp ; __u64 reshape_position ; __u32 new_level ; __u32 delta_disks ; __u32 new_layout ; __u32 new_chunk ; __u32 gstate_sreserved [ 32 - 18 ] ; __u32 layout ; __u32 chunk_size ; __u32 root_pv ; __u32 root_block ; __u32 pstate_reserved [ 64 - 4 ] ; mdp_disk_t disks [ 27 ] ; __u32 reserved [ ( 1024 - ( 32 + 32 ) - 64 - ( 27 * 32 ) - 32 ) ] ; mdp_disk_t this_disk ; } mdp_super_t ;

struct mdp_superblock_1 { __le32 magic ; __le32 major_version ; __le32 feature_map ; __le32 pad0 ; __u8 set_uuid [ 16 ] ; char set_name [ 32 ] ; __le64 ctime ; __le32 level ; __le32 layout ; __le64 size ; __le32 chunksize ; __le32 raid_disks ; __le32 bitmap_offset ; __le32 new_level ; __le64 reshape_position ; __le32 delta_disks ; __le32 new_layout ; __le32 new_chunk ; __u8 pad1 [ 128 - 124 ] ; __le64 data_offset ; __le64 data_size ; __le64 super_offset ; __le64 recovery_offset ; __le32 dev_number ; __le32 cnt_corrected_read ; __u8 device_uuid [ 16 ] ; __u8 devflags ; __u8 pad2 [ 64 - 57 ] ; __le64 utime ; __le64 events ; __le64 resync_offset ; __le32 sb_csum ; __le32 max_dev ; __u8 pad3 [ 64 - 32 ] ; __le16 dev_roles [ 0 ] ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) md_run_setup ( void ) ;

struct linux_dirent64 { u64 d_ino ; s64 d_off ; unsigned short d_reclen ; unsigned char d_type ; char d_name [ 0 ] ; } ;
struct utimbuf { __kernel_time_t actime ; __kernel_time_t modtime ; } ;

struct dir_entry { struct list_head list ; char * name ; time_t mtime ; } ;


struct elf_siginfo { int si_signo ; int si_code ; int si_errno ; } ;

struct elf_prstatus { struct elf_siginfo pr_info ; short pr_cursig ; unsigned long pr_sigpend ; unsigned long pr_sighold ; pid_t pr_pid ; pid_t pr_ppid ; pid_t pr_pgrp ; pid_t pr_sid ; struct timeval pr_utime ; struct timeval pr_stime ; struct timeval pr_cutime ; struct timeval pr_cstime ; elf_gregset_t pr_reg ; int pr_fpvalid ; } ;

struct elf_prpsinfo { char pr_state ; char pr_sname ; char pr_zomb ; char pr_nice ; unsigned long pr_flag ; __kernel_uid_t pr_uid ; __kernel_gid_t pr_gid ; pid_t pr_pid , pr_ppid , pr_pgrp , pr_sid ; char pr_fname [ 16 ] ; char pr_psargs [ ( 80 ) ] ; } ;

struct kimage_arch { pud_t * pud ; pmd_t * pmd ; pte_t * pte ; } ;

typedef unsigned long kimage_entry_t ;

struct kexec_segment { void * buf ; size_t bufsz ; unsigned long mem ; size_t memsz ; } ;
struct compat_kexec_segment { compat_uptr_t buf ; compat_size_t bufsz ; compat_ulong_t mem ; compat_size_t memsz ; } ;

struct kimage { kimage_entry_t head ; kimage_entry_t * entry ; kimage_entry_t * last_entry ; unsigned long destination ; unsigned long start ; struct page * control_code_page ; struct page * swap_page ; unsigned long nr_segments ; struct kexec_segment segment [ 16 ] ; struct list_head control_pages ; struct list_head dest_pages ; struct list_head unuseable_pages ; unsigned long control_page ; unsigned int type : 1 ; unsigned int preserve_context : 1 ; struct kimage_arch arch ; } ;

typedef u32 note_buf_t [ ( ( ( ( ( sizeof ( struct elf64_note ) ) + ( ( typeof ( sizeof ( struct elf64_note ) ) ) ( 4 ) - 1 ) ) & ~ ( ( typeof ( sizeof ( struct elf64_note ) ) ) ( 4 ) - 1 ) ) * 2 ) + ( ( ( sizeof ( ) ) + ( ( typeof ( sizeof ( ) ) ) ( 4 ) - 1 ) ) & ~ ( ( typeof ( sizeof ( ) ) ) ( 4 ) - 1 ) ) + ( ( ( sizeof ( struct elf_prstatus ) ) + ( ( typeof ( sizeof ( struct elf_prstatus ) ) ) ( 4 ) - 1 ) ) & ~ ( ( typeof ( sizeof ( struct elf_prstatus ) ) ) ( 4 ) - 1 ) ) ) / 4 ] ;
void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) calibrate_delay ( void ) ;

struct file_handler { const char * type ; int ( * handler ) ( const char * line ) ; } ;

enum generic_types { GT_DIR , GT_PIPE , GT_SOCK } ;

struct generic_type { const char * type ; mode_t mode ; } ;

struct tms { __kernel_clock_t tms_utime ; __kernel_clock_t tms_stime ; __kernel_clock_t tms_cutime ; __kernel_clock_t tms_cstime ; } ;
typedef __kernel_fsid_t fsid_t ;
struct statfs { long f_type ; long f_bsize ; long f_blocks ; long f_bfree ; long f_bavail ; long f_files ; long f_ffree ; __kernel_fsid_t f_fsid ; long f_namelen ; long f_frsize ; long f_spare [ 5 ] ; } ;
struct statfs64 { long f_type ; long f_bsize ; __u64 f_blocks ; __u64 f_bfree ; __u64 f_bavail ; __u64 f_files ; __u64 f_ffree ; __kernel_fsid_t f_fsid ; long f_namelen ; long f_frsize ; long f_spare [ 5 ] ; } ;
struct compat_statfs64 { __u32 f_type ; __u32 f_bsize ; __u64 f_blocks ; __u64 f_bfree ; __u64 f_bavail ; __u64 f_files ; __u64 f_ffree ; __kernel_fsid_t f_fsid ; __u32 f_namelen ; __u32 f_frsize ; __u32 f_spare [ 5 ] ; } __attribute__ ( ( packed , aligned ( 4 ) ) ) ;
struct kstatfs { long f_type ; long f_bsize ; u64 f_blocks ; u64 f_bfree ; u64 f_bavail ; u64 f_files ; u64 f_ffree ; __kernel_fsid_t f_fsid ; long f_namelen ; long f_frsize ; long f_spare [ 5 ] ; } ;
struct vsyscall_gtod_data { seqlock_t lock ; time_t wall_time_sec ; u32 wall_time_nsec ; int sysctl_enabled ; struct timezone sys_tz ; struct { cycle_t ( * vread ) ( void ) ; cycle_t cycle_last ; cycle_t mask ; u32 mult ; u32 shift ; } clock ; struct timespec wall_to_monotonic ; struct timespec wall_time_coarse ; } ;

struct mmap_arg_struct ;

struct sigaction32 ;
struct old_sigaction32 ;
struct sel_arg_struct ;

struct sysctl_ia32 ;

struct oldold_utsname ;
struct old_utsname ;
long sys32_truncate64 ( char * filename , unsigned long offset_low , unsigned long offset_high ) ;

long sys32_ftruncate64 ( unsigned int fd , unsigned long offset_low , unsigned long offset_high ) ;

long sys32_stat64 ( char * filename , struct stat64 * statbuf ) ;

long sys32_lstat64 ( char * filename , struct stat64 * statbuf ) ;

long sys32_fstat64 ( unsigned int fd , struct stat64 * statbuf ) ;

long sys32_fstatat ( unsigned int dfd , char * filename , struct stat64 * statbuf , int flag ) ;

struct mmap_arg_struct { unsigned int addr ; unsigned int len ; unsigned int prot ; unsigned int flags ; unsigned int fd ; unsigned int offset ; } ;
long sys32_mmap ( struct mmap_arg_struct * arg ) ;

long sys32_mprotect ( unsigned long start , size_t len , unsigned long prot ) ;

long sys32_rt_sigaction ( int sig , struct sigaction32 * act , struct sigaction32 * oact , unsigned int sigsetsize ) ;

long sys32_sigaction ( int sig , struct old_sigaction32 * act , struct old_sigaction32 * oact ) ;

long sys32_rt_sigprocmask ( int how , compat_sigset_t * set , compat_sigset_t * oset , unsigned int sigsetsize ) ;

long sys32_alarm ( unsigned int seconds ) ;

struct sel_arg_struct { unsigned int n ; unsigned int inp ; unsigned int outp ; unsigned int exp ; unsigned int tvp ; } ;
long sys32_old_select ( struct sel_arg_struct * arg ) ;

long sys32_waitpid ( compat_pid_t pid , unsigned int * stat_addr , int options ) ;

long sys32_sysfs ( int option , u32 arg1 , u32 arg2 ) ;

long sys32_sched_rr_get_interval ( compat_pid_t pid , struct compat_timespec * interval ) ;

long sys32_rt_sigpending ( compat_sigset_t * set , compat_size_t sigsetsize ) ;

long sys32_rt_sigqueueinfo ( int pid , int sig , compat_siginfo_t * uinfo ) ;

struct sysctl_ia32 { unsigned int name ; int nlen ; unsigned int oldval ; unsigned int oldlenp ; unsigned int newval ; unsigned int newlen ; unsigned int __unused [ 4 ] ; } ;
long sys32_sysctl ( struct sysctl_ia32 * args32 ) ;

long sys32_pread ( unsigned int fd , char * ubuf , u32 count , u32 poslo , u32 poshi ) ;

long sys32_pwrite ( unsigned int fd , char * ubuf , u32 count , u32 poslo , u32 poshi ) ;

long sys32_personality ( unsigned long personality ) ;

long sys32_sendfile ( int out_fd , int in_fd , compat_off_t * offset , s32 count ) ;

long sys32_olduname ( struct oldold_utsname * name ) ;

long sys32_uname ( struct old_utsname * name ) ;

long sys32_execve ( char * name , compat_uptr_t * argv , compat_uptr_t * envp , struct pt_regs * regs ) ;

long sys32_clone ( unsigned int clone_flags , unsigned int newsp , struct pt_regs * regs ) ;

long sys32_lseek ( unsigned int fd , int offset , unsigned int whence ) ;

long sys32_kill ( int pid , int sig ) ;

long sys32_fadvise64_64 ( int fd , __u32 offset_low , __u32 offset_high , __u32 len_low , __u32 len_high , int advice ) ;

long sys32_vm86_warning ( void ) ;

long sys32_lookup_dcookie ( u32 addr_low , u32 addr_high , char * buf , size_t len ) ;

ssize_t sys32_readahead ( int fd , unsigned off_lo , unsigned off_hi , size_t count ) ;

long sys32_sync_file_range ( int fd , unsigned off_low , unsigned off_hi , unsigned n_low , unsigned n_hi , int flags ) ;

long sys32_fadvise64 ( int fd , unsigned offset_lo , unsigned offset_hi , size_t len , int advice ) ;

long sys32_fallocate ( int fd , int mode , unsigned offset_lo , unsigned offset_hi , unsigned len_lo , unsigned len_hi ) ;

int copy_siginfo_to_user32 ( compat_siginfo_t * to , siginfo_t * from ) ;

int copy_siginfo_from_user32 ( siginfo_t * to , compat_siginfo_t * from ) ;

long sys32_sigsuspend ( int history0 , int history1 , old_sigset_t mask ) ;

long sys32_sigaltstack ( const stack_ia32_t * uss_ptr , stack_ia32_t * uoss_ptr , struct pt_regs * regs ) ;

long sys32_sigreturn ( struct pt_regs * regs ) ;

long sys32_rt_sigreturn ( struct pt_regs * regs ) ;

int ia32_setup_frame ( int sig , struct k_sigaction * ka , compat_sigset_t * set , struct pt_regs * regs ) ;

int ia32_setup_rt_frame ( int sig , struct k_sigaction * ka , siginfo_t * info , compat_sigset_t * set , struct pt_regs * regs ) ;

long sys32_ipc ( u32 call , int first , int second , int third , compat_uptr_t ptr , u32 fifth ) ;

int ia32_classify_syscall ( unsigned syscall ) ;

struct kprobe ;

typedef u8 kprobe_opcode_t ;

struct arch_specific_insn { kprobe_opcode_t * insn ; int boostable ; } ;

struct prev_kprobe { struct kprobe * kp ; unsigned long status ; unsigned long old_flags ; unsigned long saved_flags ; } ;

struct kprobe_ctlblk { unsigned long kprobe_status ; unsigned long kprobe_old_flags ; unsigned long kprobe_saved_flags ; unsigned long * jprobe_saved_sp ; struct pt_regs jprobe_saved_regs ; kprobe_opcode_t jprobes_stack [ 64 ] ; struct prev_kprobe prev_kprobe ; } ;

struct kretprobe ;

struct kretprobe_instance ;

typedef int ( * kprobe_pre_handler_t ) ( struct kprobe * , struct pt_regs * ) ;
typedef int ( * kprobe_break_handler_t ) ( struct kprobe * , struct pt_regs * ) ;
typedef void ( * kprobe_post_handler_t ) ( struct kprobe * , struct pt_regs * , unsigned long flags ) ;
typedef int ( * kprobe_fault_handler_t ) ( struct kprobe * , struct pt_regs * , int trapnr ) ;
typedef int ( * kretprobe_handler_t ) ( struct kretprobe_instance * , struct pt_regs * ) ;
struct kprobe { struct hlist_node hlist ; struct list_head list ; unsigned long nmissed ; kprobe_opcode_t * addr ; const char * symbol_name ; unsigned int offset ; kprobe_pre_handler_t pre_handler ; kprobe_post_handler_t post_handler ; kprobe_fault_handler_t fault_handler ; kprobe_break_handler_t break_handler ; kprobe_opcode_t opcode ; struct arch_specific_insn ainsn ; u32 flags ; } ;
struct jprobe { struct kprobe kp ; void * entry ; } ;

struct kretprobe { struct kprobe kp ; kretprobe_handler_t handler ; kretprobe_handler_t entry_handler ; int maxactive ; int nmissed ; size_t data_size ; struct hlist_head free_instances ; spinlock_t lock ; } ;
struct kretprobe_instance { struct hlist_node hlist ; struct kretprobe * rp ; kprobe_opcode_t * ret_addr ; struct task_struct * task ; char data [ 0 ] ; } ;
struct kretprobe_blackpoint { const char * name ; void * addr ; } ;

struct kprobe_blackpoint { const char * name ; unsigned long start_addr ; unsigned long range ; } ;

enum die_val { DIE_OOPS = 1 , DIE_INT3 , DIE_DEBUG , DIE_PANIC , DIE_NMI , DIE_DIE , DIE_NMIWATCHDOG , DIE_KERNELDEBUG , DIE_TRAP , DIE_GPF , DIE_CALL , DIE_NMI_IPI , DIE_PAGE_FAULT , DIE_NMIUNKNOWN , } ;

struct die_args { struct pt_regs * regs ; const char * str ; long err ; int trapnr ; int signr ; } ;

enum dmi_device_type { DMI_DEV_TYPE_ANY = 0 , DMI_DEV_TYPE_OTHER , DMI_DEV_TYPE_UNKNOWN , DMI_DEV_TYPE_VIDEO , DMI_DEV_TYPE_SCSI , DMI_DEV_TYPE_ETHERNET , DMI_DEV_TYPE_TOKENRING , DMI_DEV_TYPE_SOUND , DMI_DEV_TYPE_PATA , DMI_DEV_TYPE_SATA , DMI_DEV_TYPE_SAS , DMI_DEV_TYPE_IPMI = - 1 , DMI_DEV_TYPE_OEM_STRING = - 2 , } ;

struct dmi_header { u8 type ; u8 length ; u16 handle ; } ;

struct dmi_device { struct list_head list ; int type ; const char * name ; void * device_data ; } ;

struct tlb_state { struct mm_struct * active_mm ; int state ; } ;

void idle_notifier_register ( struct notifier_block * n ) ;

void idle_notifier_unregister ( struct notifier_block * n ) ;

void enter_idle ( void ) ;

void exit_idle ( void ) ;

void cpu_idle ( void ) ;

void __show_regs ( struct pt_regs * regs , int all ) ;

void show_regs ( struct pt_regs * regs ) ;

void release_thread ( struct task_struct * dead_task ) ;

void prepare_to_copy ( struct task_struct * tsk ) ;

int copy_thread ( unsigned long clone_flags , unsigned long sp , unsigned long unused , struct task_struct * p , struct pt_regs * regs ) ;

void start_thread ( struct pt_regs * regs , unsigned long new_ip , unsigned long new_sp ) ;

__attribute__ ( ( no_instrument_function ) ) struct task_struct * __switch_to ( struct task_struct * prev_p , struct task_struct * next_p ) ;

long sys_execve ( char * name , char * * argv , char * * envp , struct pt_regs * regs ) ;

void set_personality_64bit ( void ) ;

long sys_clone ( unsigned long clone_flags , unsigned long newsp , void * parent_tid , void * child_tid , struct pt_regs * regs ) ;

void set_personality_ia32 ( void ) ;

unsigned long get_wchan ( struct task_struct * p ) ;

long do_arch_prctl ( struct task_struct * task , int code , unsigned long addr ) ;

long sys_arch_prctl ( int code , unsigned long addr ) ;

unsigned long KSTK_ESP ( struct task_struct * task ) ;

struct mce { __u64 status ; __u64 misc ; __u64 addr ; __u64 mcgstatus ; __u64 ip ; __u64 tsc ; __u64 time ; __u8 cpuvendor ; __u8 inject_flags ; __u16 pad ; __u32 cpuid ; __u8 cs ; __u8 bank ; __u8 cpu ; __u8 finished ; __u32 extcpu ; __u32 socketid ; __u32 apicid ; __u64 mcgcap ; __u64 aux0 ; __u64 aux1 ; } ;

struct mce_log { char signature [ 12 ] ; unsigned len ; unsigned next ; unsigned flags ; unsigned recordlen ; struct mce entry [ 32 ] ; } ;

typedef unsigned long mce_banks_t [ ( ( ( 32 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ;

enum mcp_flags { MCP_TIMESTAMP = ( 1 << 0 ) , MCP_UC = ( 1 << 1 ) , MCP_DONTLOG = ( 1 << 2 ) , } ;

long sys_sigaltstack ( const stack_t * uss , stack_t * uoss , struct pt_regs * regs ) ;

long sys_rt_sigreturn ( struct pt_regs * regs ) ;

void do_notify_resume ( struct pt_regs * regs , void * unused , __u32 thread_info_flags ) ;

void signal_fault ( struct pt_regs * regs , void * frame , char * where ) ;

struct stacktrace_ops { void ( * warning ) ( void * data , char * msg ) ; void ( * warning_symbol ) ( void * data , char * msg , unsigned long symbol ) ; void ( * address ) ( void * data , unsigned long address , int reliable ) ; int ( * stack ) ( void * data , char * name ) ; } ;

struct cmos_rtc_board_info { void ( * wake_on ) ( struct device * dev ) ; void ( * wake_off ) ( struct device * dev ) ; u8 rtc_day_alarm ; u8 rtc_mon_alarm ; u8 rtc_century ; } ;

void do_divide_error ( struct pt_regs * regs , long error_code ) ;

void do_overflow ( struct pt_regs * regs , long error_code ) ;

void do_bounds ( struct pt_regs * regs , long error_code ) ;

void do_invalid_op ( struct pt_regs * regs , long error_code ) ;

void do_coprocessor_segment_overrun ( struct pt_regs * regs , long error_code ) ;

void do_invalid_TSS ( struct pt_regs * regs , long error_code ) ;

void do_segment_not_present ( struct pt_regs * regs , long error_code ) ;

void do_alignment_check ( struct pt_regs * regs , long error_code ) ;

void do_stack_segment ( struct pt_regs * regs , long error_code ) ;

void do_double_fault ( struct pt_regs * regs , long error_code ) ;

void __attribute__ ( ( __section__ ( ) ) ) do_general_protection ( struct pt_regs * regs , long error_code ) ;

__attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( __section__ ( ) ) ) void do_nmi ( struct pt_regs * regs , long error_code ) ;

void stop_nmi ( void ) ;

void restart_nmi ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) do_int3 ( struct pt_regs * regs , long error_code ) ;

__attribute__ ( ( __section__ ( ) ) ) struct pt_regs * sync_regs ( struct pt_regs * eregs ) ;

void __attribute__ ( ( __section__ ( ) ) ) do_debug ( struct pt_regs * regs , long error_code ) ;

void math_error ( void * ip ) ;

void do_coprocessor_error ( struct pt_regs * regs , long error_code ) ;

void do_simd_coprocessor_error ( struct pt_regs * regs , long error_code ) ;

void do_spurious_interrupt_bug ( struct pt_regs * regs , long error_code ) ;

void __attribute__ ( ( weak ) ) smp_thermal_interrupt ( void ) ;

void __attribute__ ( ( weak ) ) smp_threshold_interrupt ( void ) ;

__attribute__ ( ( noinline ) ) void bad_math_state_restore ( void ) ;

void __math_state_restore ( void ) ;

void math_state_restore ( void ) ;

void math_emulate ( struct math_emu_info * info ) ;

void __attribute__ ( ( __section__ ( ) ) ) do_device_not_available ( struct pt_regs * regs , long error_code ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) trap_init ( void ) ;

void ack_bad_irq ( unsigned int irq ) ;

int show_interrupts ( struct seq_file * p , void * v ) ;

u64 arch_irq_stat_cpu ( unsigned int cpu ) ;

u64 arch_irq_stat ( void ) ;

unsigned int __attribute__ ( ( __section__ ( ) ) ) do_IRQ ( struct pt_regs * regs ) ;

void smp_generic_interrupt ( struct pt_regs * regs ) ;

bool handle_irq ( unsigned irq , struct pt_regs * regs ) ;

void fixup_irqs ( void ) ;

void do_softirq ( void ) ;

struct stack_frame { struct stack_frame * next_frame ; unsigned long return_address ; } ;

int x86_is_stack_id ( int id , char * name ) ;

void dump_trace ( struct task_struct * task , struct pt_regs * regs , unsigned long * stack , unsigned long bp , const struct stacktrace_ops * ops , void * data ) ;

void show_stack_log_lvl ( struct task_struct * task , struct pt_regs * regs , unsigned long * sp , unsigned long bp , char * log_lvl ) ;

void show_registers ( struct pt_regs * regs ) ;

int is_valid_bugaddr ( unsigned long ip ) ;

typedef int ( * MCA_ProcFn ) ( char * buf , int slot , void * dev ) ;
enum MCA_AdapterStatus { MCA_ADAPTER_NORMAL = 0 , MCA_ADAPTER_NONE = 1 , MCA_ADAPTER_DISABLED = 2 , MCA_ADAPTER_ERROR = 3 } ;

struct mca_device { u64 dma_mask ; int pos_id ; int slot ; int index ; int driver_loaded ; unsigned char pos [ 8 ] ; short pos_register ; enum MCA_AdapterStatus status ; struct device dev ; char name [ 32 ] ; } ;

struct mca_bus_accessor_functions { unsigned char ( * mca_read_pos ) ( struct mca_device * , int reg ) ; void ( * mca_write_pos ) ( struct mca_device * , int reg , unsigned char byte ) ; int ( * mca_transform_irq ) ( struct mca_device * , int irq ) ; int ( * mca_transform_ioport ) ( struct mca_device * , int region ) ; void * ( * mca_transform_memory ) ( struct mca_device * , void * memory ) ; } ;

struct mca_bus { u64 default_dma_mask ; int number ; struct mca_bus_accessor_functions f ; struct device dev ; char name [ 32 ] ; } ;

struct mca_driver { const short * id_table ; void * driver_data ; int integrated_id ; struct device_driver driver ; } ;

struct msi_msg { u32 address_lo ; u32 address_hi ; u32 data ; } ;

struct msi_desc { struct { __u8 is_msix : 1 ; __u8 multiple : 3 ; __u8 maskbit : 1 ; __u8 is_64 : 1 ; __u8 pos ; __u16 entry_nr ; unsigned default_irq ; } msi_attrib ; u32 masked ; unsigned int irq ; struct list_head list ; union { void * mask_base ; u8 mask_pos ; } ; struct pci_dev * dev ; struct msi_msg msg ; } ;
typedef irqreturn_t ( * rtc_irq_handler ) ( int interrupt , void * cookie ) ;
unsigned long profile_pc ( struct pt_regs * regs ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_default_timer_irq ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) hpet_time_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) time_init ( void ) ;

long sys_ioperm ( unsigned long from , unsigned long num , int turn_on ) ;

long sys_iopl ( unsigned int level , struct pt_regs * regs ) ;

int init_new_context ( struct task_struct * tsk , struct mm_struct * mm ) ;

void destroy_context ( struct mm_struct * mm ) ;

int sys_modify_ldt ( int func , void * ptr , unsigned long bytecount ) ;

void printk_address ( unsigned long address , int reliable ) ;

unsigned long print_context_stack ( struct thread_info * tinfo , unsigned long * stack , unsigned long bp , const struct stacktrace_ops * ops , void * data , unsigned long * end , int * graph ) ;

void show_trace_log_lvl ( struct task_struct * task , struct pt_regs * regs , unsigned long * stack , unsigned long bp , char * log_lvl ) ;

void show_trace ( struct task_struct * task , struct pt_regs * regs , unsigned long * stack , unsigned long bp ) ;

void show_stack ( struct task_struct * task , unsigned long * sp ) ;

void dump_stack ( void ) ;

unsigned __attribute__ ( ( __section__ ( ) ) ) long oops_begin ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) oops_end ( unsigned long flags , struct pt_regs * regs , int signr ) ;

int __attribute__ ( ( __section__ ( ) ) ) __die ( const char * str , struct pt_regs * regs , long err ) ;

void die ( const char * str , struct pt_regs * regs , long err ) ;

void __attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( __section__ ( ) ) ) die_nmi ( char * str , struct pt_regs * regs , int do_panic ) ;

struct vc_data ;

struct console_font_op ;

struct console_font ;

struct consw { struct module * owner ; const char * ( * con_startup ) ( void ) ; void ( * con_init ) ( struct vc_data * , int ) ; void ( * con_deinit ) ( struct vc_data * ) ; void ( * con_clear ) ( struct vc_data * , int , int , int , int ) ; void ( * con_putc ) ( struct vc_data * , int , int , int ) ; void ( * con_putcs ) ( struct vc_data * , const unsigned short * , int , int , int ) ; void ( * con_cursor ) ( struct vc_data * , int ) ; int ( * con_scroll ) ( struct vc_data * , int , int , int , int ) ; void ( * con_bmove ) ( struct vc_data * , int , int , int , int , int , int ) ; int ( * con_switch ) ( struct vc_data * ) ; int ( * con_blank ) ( struct vc_data * , int , int ) ; int ( * con_font_set ) ( struct vc_data * , struct console_font * , unsigned ) ; int ( * con_font_get ) ( struct vc_data * , struct console_font * ) ; int ( * con_font_default ) ( struct vc_data * , struct console_font * , char * ) ; int ( * con_font_copy ) ( struct vc_data * , int ) ; int ( * con_resize ) ( struct vc_data * , unsigned int , unsigned int , unsigned int ) ; int ( * con_set_palette ) ( struct vc_data * , unsigned char * ) ; int ( * con_scrolldelta ) ( struct vc_data * , int ) ; int ( * con_set_origin ) ( struct vc_data * ) ; void ( * con_save_screen ) ( struct vc_data * ) ; u8 ( * con_build_attr ) ( struct vc_data * , u8 , u8 , u8 , u8 , u8 , u8 ) ; void ( * con_invert_region ) ( struct vc_data * , u16 * , int ) ; u16 * ( * con_screen_pos ) ( struct vc_data * , int ) ; unsigned long ( * con_getxy ) ( struct vc_data * , unsigned long , int * , int * ) ; } ;

struct console { char name [ 16 ] ; void ( * write ) ( struct console * , const char * , unsigned ) ; int ( * read ) ( struct console * , char * , unsigned ) ; struct tty_driver * ( * device ) ( struct console * , int * ) ; void ( * unblank ) ( void ) ; int ( * setup ) ( struct console * , char * ) ; int ( * early_setup ) ( void ) ; short flags ; short index ; int cflag ; void * data ; struct console * next ; } ;

struct ibft_table_header { char signature [ 4 ] ; u32 length ; u8 revision ; u8 checksum ; char oem_id [ 6 ] ; char oem_table_id [ 8 ] ; char reserved [ 24 ] ; } __attribute__ ( ( __packed__ ) ) ;
struct pci_slot { struct pci_bus * bus ; struct list_head list ; struct hotplug_slot * hotplug ; unsigned char number ; struct kobject kobj ; } ;

enum pci_mmap_state { pci_mmap_io , pci_mmap_mem } ;

enum { PCI_STD_RESOURCES , PCI_STD_RESOURCE_END = 5 , PCI_ROM_RESOURCE , PCI_IOV_RESOURCES , PCI_IOV_RESOURCE_END = PCI_IOV_RESOURCES + 6 - 1 , PCI_BRIDGE_RESOURCES , PCI_BRIDGE_RESOURCE_END = PCI_BRIDGE_RESOURCES + 4 - 1 , PCI_NUM_RESOURCES , DEVICE_COUNT_RESOURCE } ;
typedef int pci_power_t ;

typedef unsigned int pci_channel_state_t ;

enum pci_channel_state { pci_channel_io_normal = ( pci_channel_state_t ) 1 , pci_channel_io_frozen = ( pci_channel_state_t ) 2 , pci_channel_io_perm_failure = ( pci_channel_state_t ) 3 , } ;

typedef unsigned int pcie_reset_state_t ;

enum pcie_reset_state { pcie_deassert_reset = ( pcie_reset_state_t ) 1 , pcie_warm_reset = ( pcie_reset_state_t ) 2 , pcie_hot_reset = ( pcie_reset_state_t ) 3 } ;

typedef unsigned short pci_dev_flags_t ;

enum pci_dev_flags { PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = ( pci_dev_flags_t ) 1 , PCI_DEV_FLAGS_NO_D3 = ( pci_dev_flags_t ) 2 , } ;

enum pci_irq_reroute_variant { INTEL_IRQ_REROUTE_VARIANT = 1 , MAX_IRQ_REROUTE_VARIANTS = 3 } ;

typedef unsigned short pci_bus_flags_t ;

enum pci_bus_flags { PCI_BUS_FLAGS_NO_MSI = ( pci_bus_flags_t ) 1 , PCI_BUS_FLAGS_NO_MMRBC = ( pci_bus_flags_t ) 2 , } ;

struct pci_cap_saved_state { struct hlist_node next ; char cap_nr ; u32 data [ 0 ] ; } ;

struct pcie_link_state ;

struct pci_vpd ;

struct pci_sriov ;

struct pci_ats ;

struct pci_dev { struct list_head bus_list ; struct pci_bus * bus ; struct pci_bus * subordinate ; void * sysdata ; struct proc_dir_entry * procent ; struct pci_slot * slot ; unsigned int devfn ; unsigned short vendor ; unsigned short device ; unsigned short subsystem_vendor ; unsigned short subsystem_device ; unsigned int class ; u8 revision ; u8 hdr_type ; u8 pcie_type ; u8 rom_base_reg ; u8 pin ; struct pci_driver * driver ; u64 dma_mask ; struct device_dma_parameters dma_parms ; pci_power_t current_state ; int pm_cap ; unsigned int pme_support : 5 ; unsigned int d1_support : 1 ; unsigned int d2_support : 1 ; unsigned int no_d1d2 : 1 ; unsigned int wakeup_prepared : 1 ; pci_channel_state_t error_state ; struct device dev ; int cfg_size ; unsigned int irq ; struct resource resource [ DEVICE_COUNT_RESOURCE ] ; unsigned int transparent : 1 ; unsigned int multifunction : 1 ; unsigned int is_added : 1 ; unsigned int is_busmaster : 1 ; unsigned int no_msi : 1 ; unsigned int block_ucfg_access : 1 ; unsigned int broken_parity_status : 1 ; unsigned int irq_reroute_variant : 2 ; unsigned int msi_enabled : 1 ; unsigned int msix_enabled : 1 ; unsigned int ari_enabled : 1 ; unsigned int is_managed : 1 ; unsigned int is_pcie : 1 ; unsigned int needs_freset : 1 ; unsigned int state_saved : 1 ; unsigned int is_physfn : 1 ; unsigned int is_virtfn : 1 ; unsigned int reset_fn : 1 ; unsigned int is_hotplug_bridge : 1 ; pci_dev_flags_t dev_flags ; atomic_t enable_cnt ; u32 saved_config_space [ 16 ] ; struct hlist_head saved_cap_space ; struct bin_attribute * rom_attr ; int rom_attr_enabled ; struct bin_attribute * res_attr [ DEVICE_COUNT_RESOURCE ] ; struct bin_attribute * res_attr_wc [ DEVICE_COUNT_RESOURCE ] ; struct list_head msi_list ; struct pci_vpd * vpd ; union { struct pci_sriov * sriov ; struct pci_dev * physfn ; } ; struct pci_ats * ats ; } ;
struct pci_bus { struct list_head node ; struct pci_bus * parent ; struct list_head children ; struct list_head devices ; struct pci_dev * self ; struct list_head slots ; struct resource * resource [ 16 ] ; struct pci_ops * ops ; void * sysdata ; struct proc_dir_entry * procdir ; unsigned char number ; unsigned char primary ; unsigned char secondary ; unsigned char subordinate ; char name [ 48 ] ; unsigned short bridge_ctl ; pci_bus_flags_t bus_flags ; struct device * bridge ; struct device dev ; struct bin_attribute * legacy_io ; struct bin_attribute * legacy_mem ; unsigned int is_added : 1 ; } ;
struct pci_ops { int ( * read ) ( struct pci_bus * bus , unsigned int devfn , int where , int size , u32 * val ) ; int ( * write ) ( struct pci_bus * bus , unsigned int devfn , int where , int size , u32 val ) ; } ;

struct pci_bus_region { resource_size_t start ; resource_size_t end ; } ;

struct pci_dynids { spinlock_t lock ; struct list_head list ; } ;

typedef unsigned int pci_ers_result_t ;

enum pci_ers_result { PCI_ERS_RESULT_NONE = ( pci_ers_result_t ) 1 , PCI_ERS_RESULT_CAN_RECOVER = ( pci_ers_result_t ) 2 , PCI_ERS_RESULT_NEED_RESET = ( pci_ers_result_t ) 3 , PCI_ERS_RESULT_DISCONNECT = ( pci_ers_result_t ) 4 , PCI_ERS_RESULT_RECOVERED = ( pci_ers_result_t ) 5 , } ;

struct pci_error_handlers { pci_ers_result_t ( * error_detected ) ( struct pci_dev * dev , enum pci_channel_state error ) ; pci_ers_result_t ( * mmio_enabled ) ( struct pci_dev * dev ) ; pci_ers_result_t ( * link_reset ) ( struct pci_dev * dev ) ; pci_ers_result_t ( * slot_reset ) ( struct pci_dev * dev ) ; void ( * resume ) ( struct pci_dev * dev ) ; } ;

struct pci_driver { struct list_head node ; char * name ; const struct pci_device_id * id_table ; int ( * probe ) ( struct pci_dev * dev , const struct pci_device_id * id ) ; void ( * remove ) ( struct pci_dev * dev ) ; int ( * suspend ) ( struct pci_dev * dev , pm_message_t state ) ; int ( * suspend_late ) ( struct pci_dev * dev , pm_message_t state ) ; int ( * resume_early ) ( struct pci_dev * dev ) ; int ( * resume ) ( struct pci_dev * dev ) ; void ( * shutdown ) ( struct pci_dev * dev ) ; struct pci_error_handlers * err_handler ; struct device_driver driver ; struct pci_dynids dynids ; } ;

enum pci_lost_interrupt_reason { PCI_LOST_IRQ_NO_INFORMATION = 0 , PCI_LOST_IRQ_DISABLE_MSI , PCI_LOST_IRQ_DISABLE_MSIX , PCI_LOST_IRQ_DISABLE_ACPI , } ;

enum pci_dma_burst_strategy { PCI_DMA_BURST_INFINITY , PCI_DMA_BURST_BOUNDARY , PCI_DMA_BURST_MULTIPLE , } ;

struct msix_entry { u32 vector ; u16 entry ; } ;

typedef int ( * arch_set_vga_state_t ) ( struct pci_dev * pdev , bool decode , unsigned int command_bits , bool change_bridge ) ;
struct pci_sysdata { int domain ; int node ; void * iommu ; } ;

struct pci_fixup { u16 vendor , device ; void ( * hook ) ( struct pci_dev * dev ) ; } ;

enum pci_fixup_pass { pci_fixup_early , pci_fixup_header , pci_fixup_final , pci_fixup_enable , pci_fixup_resume , pci_fixup_suspend , pci_fixup_resume_early , } ;

struct kvm_mmu_op_header { __u32 op ; __u32 pad ; } ;

struct kvm_mmu_op_write_pte { struct kvm_mmu_op_header header ; __u64 pte_phys ; __u64 pte_val ; } ;

struct kvm_mmu_op_flush_tlb { struct kvm_mmu_op_header header ; } ;

struct kvm_mmu_op_release_pt { struct kvm_mmu_op_header header ; __u64 pt_phys ; } ;

struct cpufreq_governor ;

struct cpufreq_cpuinfo { unsigned int max_freq ; unsigned int min_freq ; unsigned int transition_latency ; } ;

struct cpufreq_real_policy { unsigned int min ; unsigned int max ; unsigned int policy ; struct cpufreq_governor * governor ; } ;

struct cpufreq_policy { cpumask_var_t cpus ; cpumask_var_t related_cpus ; unsigned int shared_type ; unsigned int cpu ; struct cpufreq_cpuinfo cpuinfo ; unsigned int min ; unsigned int max ; unsigned int cur ; unsigned int policy ; struct cpufreq_governor * governor ; struct work_struct update ; struct cpufreq_real_policy user_policy ; struct kobject kobj ; struct completion kobj_unregister ; } ;

struct cpufreq_freqs { unsigned int cpu ; unsigned int old ; unsigned int new ; u8 flags ; } ;

struct cpufreq_governor { char name [ 16 ] ; int ( * governor ) ( struct cpufreq_policy * policy , unsigned int event ) ; ssize_t ( * show_setspeed ) ( struct cpufreq_policy * policy , char * buf ) ; int ( * store_setspeed ) ( struct cpufreq_policy * policy , unsigned int freq ) ; unsigned int max_transition_latency ; struct list_head governor_list ; struct module * owner ; } ;
struct freq_attr ;

struct cpufreq_driver { struct module * owner ; char name [ 16 ] ; u8 flags ; int ( * init ) ( struct cpufreq_policy * policy ) ; int ( * verify ) ( struct cpufreq_policy * policy ) ; int ( * setpolicy ) ( struct cpufreq_policy * policy ) ; int ( * target ) ( struct cpufreq_policy * policy , unsigned int target_freq , unsigned int relation ) ; unsigned int ( * get ) ( unsigned int cpu ) ; unsigned int ( * getavg ) ( struct cpufreq_policy * policy , unsigned int cpu ) ; int ( * exit ) ( struct cpufreq_policy * policy ) ; int ( * suspend ) ( struct cpufreq_policy * policy , pm_message_t pmsg ) ; int ( * resume ) ( struct cpufreq_policy * policy ) ; struct freq_attr * * attr ; } ;

struct freq_attr { struct attribute attr ; ssize_t ( * show ) ( struct cpufreq_policy * , char * ) ; ssize_t ( * store ) ( struct cpufreq_policy * , const char * , size_t count ) ; } ;
struct global_attr { struct attribute attr ; ssize_t ( * show ) ( struct kobject * kobj , struct attribute * attr , char * buf ) ; ssize_t ( * store ) ( struct kobject * a , struct attribute * b , const char * c , size_t count ) ; } ;

struct cpufreq_frequency_table { unsigned int index ; unsigned int frequency ; } ;

enum { TB_SHUTDOWN_REBOOT = 0 , TB_SHUTDOWN_S5 , TB_SHUTDOWN_S4 , TB_SHUTDOWN_S3 , TB_SHUTDOWN_HALT , TB_SHUTDOWN_WFS } ;
struct mtrr_sentry { unsigned long base ; unsigned int size ; unsigned int type ; } ;

struct mtrr_gentry { unsigned long base ; unsigned int size ; unsigned int regnum ; unsigned int type ; } ;

struct mtrr_var_range { __u32 base_lo ; __u32 base_hi ; __u32 mask_lo ; __u32 mask_hi ; } ;

typedef __u8 mtrr_type ;

struct mtrr_state_type { struct mtrr_var_range var_ranges [ 256 ] ; mtrr_type fixed_ranges [ 88 ] ; unsigned char enabled ; unsigned char have_fixed ; mtrr_type def_type ; } ;

struct mtrr_sentry32 { compat_ulong_t base ; compat_uint_t size ; compat_uint_t type ; } ;

struct mtrr_gentry32 { compat_ulong_t regnum ; compat_uint_t base ; compat_uint_t size ; compat_uint_t type ; } ;

struct vmi_relocation_info { unsigned char * eip ; unsigned char type ; unsigned char reserved [ 3 ] ; } ;

struct vrom_header { u16 rom_signature ; u8 rom_length ; u8 rom_entry [ 4 ] ; u8 rom_pad0 ; u32 vrom_signature ; u8 api_version_min ; u8 api_version_maj ; u8 jump_slots ; u8 reserved1 ; u32 virtual_top ; u16 reserved2 ; u16 license_offs ; u16 pci_header_offs ; u16 pnp_header_offs ; u32 rom_pad3 ; u8 reserved [ 96 ] ; char vmi_init [ 8 ] ; char get_reloc [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct pnp_header { char sig [ 4 ] ; char rev ; char size ; short next ; short res ; long devID ; unsigned short manufacturer_offset ; unsigned short product_offset ; } __attribute__ ( ( packed ) ) ;
struct pci_header { char sig [ 4 ] ; short vendorID ; short deviceID ; short vpdData ; short size ; char rev ; char class ; char subclass ; char interface ; short chunks ; char rom_version_min ; char rom_version_maj ; char codetype ; char lastRom ; short reserved ; } __attribute__ ( ( packed ) ) ;
struct vmi_ap_state { u32 cr0 ; u32 cr2 ; u32 cr3 ; u32 cr4 ; u64 efer ; u32 eip ; u32 eflags ; u32 eax ; u32 ebx ; u32 ecx ; u32 edx ; u32 esp ; u32 ebp ; u32 esi ; u32 edi ; u16 cs ; u16 ss ; u16 ds ; u16 es ; u16 fs ; u16 gs ; u16 ldtr ; u16 gdtr_limit ; u32 gdtr_base ; u32 idtr_base ; u16 idtr_limit ; } ;

struct x86_cpu { struct cpu cpu ; } ;

int default_cpu_present_to_apicid ( int mps_cpu ) ;

int default_check_phys_apicid_present ( int phys_apicid ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) extend_brk ( size_t size , size_t align ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_standard_io_resources ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_arch ( char * * cmdline_p ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) x86_init_noop ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) x86_init_uint_noop ( unsigned int unused ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) x86_init_pgd_noop ( pgd_t * unused ) ;

void disable_8259A_irq ( unsigned int irq ) ;

void enable_8259A_irq ( unsigned int irq ) ;

int i8259A_irq_pending ( unsigned int irq ) ;

void make_8259A_irq ( unsigned int irq ) ;

void mask_8259A ( void ) ;

void unmask_8259A ( void ) ;

void init_8259A ( int auto_eoi ) ;

int vector_used_by_percpu_irq ( unsigned int vector ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_ISA_irqs ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_IRQ ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) native_init_IRQ ( void ) ;

long sys_mmap ( unsigned long addr , unsigned long len , unsigned long prot , unsigned long flags , unsigned long fd , unsigned long off ) ;

unsigned long arch_get_unmapped_area ( struct file * filp , unsigned long addr , unsigned long len , unsigned long pgoff , unsigned long flags ) ;

unsigned long arch_get_unmapped_area_topdown ( struct file * filp , const unsigned long addr0 , const unsigned long len , const unsigned long pgoff , const unsigned long flags ) ;

long sys_uname ( struct new_utsname * name ) ;

typedef void ( * sys_call_ptr_t ) ( void ) ;
struct getcpu_cache { unsigned long blob [ 128 / sizeof ( long ) ] ; } ;
void update_vsyscall_tz ( void ) ;

void update_vsyscall ( struct timespec * wall_time , struct clocksource * clock , u32 mult ) ;

int __attribute__ ( ( unused , __section__ ( ) ) ) __attribute__ ( ( no_instrument_function ) ) vgettimeofday ( struct timeval * tv , struct timezone * tz ) ;

time_t __attribute__ ( ( unused , __section__ ( ) ) ) __attribute__ ( ( no_instrument_function ) ) vtime ( time_t * t ) ;

long __attribute__ ( ( unused , __section__ ( ) ) ) __attribute__ ( ( no_instrument_function ) ) vgetcpu ( unsigned * cpu , unsigned * node , struct getcpu_cache * tcache ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) map_vsyscall ( void ) ;

int e820_any_mapped ( u64 start , u64 end , unsigned type ) ;

int e820_all_mapped ( u64 start , u64 end , unsigned type ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_add_region ( u64 start , u64 size , int type ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_print_map ( char * who ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sanitize_e820_map ( struct e820entry * biosmap , int max_nr_map , u32 * pnr_map ) ;

u64 __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_update_range ( u64 start , u64 size , unsigned old_type , unsigned new_type ) ;

u64 __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_remove_range ( u64 start , u64 size , unsigned old_type , int checktype ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) update_e820 ( void ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) int e820_search_gap ( unsigned long * gapstart , unsigned long * gapsize , unsigned long start_addr , unsigned long long end_addr ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) void e820_setup_gap ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) parse_e820_ext ( struct setup_data * sdata , unsigned long pa_data ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_mark_nosave_regions ( unsigned long limit_pfn ) ;

struct early_res { u64 start , end ; char name [ 16 ] ; char overlap_ok ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_early_overlap_ok ( u64 start , u64 end , char * name ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_early ( u64 start , u64 end , char * name ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) free_early ( u64 start , u64 end ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_res_to_bootmem ( u64 start , u64 end ) ;

u64 __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) find_e820_area ( u64 start , u64 end , u64 size , u64 align ) ;

u64 __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) find_e820_area_size ( u64 start , u64 * sizep , u64 align ) ;

u64 __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_reserve_e820 ( u64 startt , u64 sizet , u64 align ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_end_of_ram_pfn ( void ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_end_of_low_ram_pfn ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_find_active_region ( const struct e820entry * ei , unsigned long start_pfn , unsigned long last_pfn , unsigned long * ei_startpfn , unsigned long * ei_endpfn ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_register_active_regions ( int nid , unsigned long start_pfn , unsigned long last_pfn ) ;

u64 __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_hole_size ( u64 start , u64 end ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) finish_e820_parsing ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_reserve_resources ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) e820_reserve_resources_late ( void ) ;

char * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) default_machine_specific_memory_setup ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_memory_map ( void ) ;

struct intel_iommu ;

struct irte { union { struct { __u64 present : 1 , fpd : 1 , dst_mode : 1 , redir_hint : 1 , trigger_mode : 1 , dlvry_mode : 3 , avail : 4 , __reserved_1 : 4 , vector : 8 , __reserved_2 : 8 , dest_id : 32 ; } ; __u64 low ; } ; union { struct { __u64 sid : 16 , sq : 2 , svt : 2 , __reserved_3 : 44 ; } ; __u64 high ; } ; } ;

struct iommu_table { struct cal_chipset_ops * chip_ops ; unsigned long it_base ; unsigned long it_hint ; unsigned long * it_map ; void * bbar ; u64 tar_val ; struct timer_list watchdog_timer ; spinlock_t it_lock ; unsigned int it_size ; unsigned char it_busno ; } ;

struct cal_chipset_ops { void ( * handle_quirks ) ( struct iommu_table * tbl , struct pci_dev * dev ) ; void ( * tce_cache_blast ) ( struct iommu_table * tbl ) ; void ( * dump_error_regs ) ( struct iommu_table * tbl ) ; } ;

int dma_set_mask ( struct device * dev , u64 mask ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dma32_reserve_bootmem ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_iommu_alloc ( void ) ;

void * dma_generic_alloc_coherent ( struct device * dev , size_t size , dma_addr_t * dma_addr , gfp_t flag ) ;

int dma_supported ( struct device * dev , u64 mask ) ;

void pci_iommu_shutdown ( void ) ;

void force_hpet_resume ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) arch_register_cpu ( int num ) ;

void arch_unregister_cpu ( int num ) ;

struct debugfs_blob_wrapper { void * data ; unsigned long size ; } ;

struct memory_block { unsigned long phys_index ; unsigned long state ; struct mutex state_mutex ; int phys_device ; void * hw ; int ( * phys_callback ) ( struct memory_block * ) ; struct sys_device sysdev ; } ;
struct memory_notify { unsigned long start_pfn ; unsigned long nr_pages ; int status_change_nid ; } ;

enum mem_add_context { BOOT , HOTPLUG } ;

struct memory_accessor { ssize_t ( * read ) ( struct memory_accessor * , char * buf , off_t offset , size_t count ) ; ssize_t ( * write ) ( struct memory_accessor * , const char * buf , off_t offset , size_t count ) ; } ;

void apply_alternatives ( struct alt_instr * start , struct alt_instr * end ) ;

struct smp_alt_module { struct module * mod ; char * name ; u8 * * locks ; u8 * * locks_end ; u8 * text ; u8 * text_end ; struct list_head next ; } ;

void alternatives_smp_module_add ( struct module * mod , char * name , void * locks , void * locks_end , void * text , void * text_end ) ;

void alternatives_smp_module_del ( struct module * mod ) ;

void alternatives_smp_switch ( int smp ) ;

void apply_paravirt ( struct paravirt_patch_site * start , struct paravirt_patch_site * end ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) alternative_instructions ( void ) ;

void * __attribute__ ( ( __section__ ( ) ) ) text_poke ( void * addr , const void * opcode , size_t len ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_pit_timer ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) no_iommu_init ( void ) ;

u64 native_sched_clock ( void ) ;

unsigned long long sched_clock ( void ) ;

int check_tsc_unstable ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) notsc_setup ( char * str ) ;

unsigned long native_calibrate_tsc ( void ) ;

int recalibrate_cpu_khz ( void ) ;

void mark_tsc_unstable ( char * reason ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) int unsynchronized_tsc ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) tsc_init ( void ) ;

void native_io_delay ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) io_delay_init ( void ) ;

struct platform_device { const char * name ; int id ; struct device dev ; u32 num_resources ; struct resource * resource ; struct platform_device_id * id_entry ; struct pdev_archdata archdata ; } ;

struct platform_driver { int ( * probe ) ( struct platform_device * ) ; int ( * remove ) ( struct platform_device * ) ; void ( * shutdown ) ( struct platform_device * ) ; int ( * suspend ) ( struct platform_device * , pm_message_t state ) ; int ( * resume ) ( struct platform_device * ) ; struct device_driver driver ; struct platform_device_id * id_table ; } ;

struct early_platform_driver { const char * class_str ; struct platform_driver * pdrv ; struct list_head list ; int requested_id ; } ;

struct pnp_protocol ;

struct pnp_dev ;

struct pnp_card { struct device dev ; unsigned char number ; struct list_head global_list ; struct list_head protocol_list ; struct list_head devices ; struct pnp_protocol * protocol ; struct pnp_id * id ; char name [ 50 ] ; unsigned char pnpver ; unsigned char productver ; unsigned int serial ; unsigned char checksum ; struct proc_dir_entry * procdir ; } ;

struct pnp_card_link { struct pnp_card * card ; struct pnp_card_driver * driver ; void * driver_data ; pm_message_t pm_state ; } ;

struct pnp_dev { struct device dev ; u64 dma_mask ; unsigned int number ; int status ; struct list_head global_list ; struct list_head protocol_list ; struct list_head card_list ; struct list_head rdev_list ; struct pnp_protocol * protocol ; struct pnp_card * card ; struct pnp_driver * driver ; struct pnp_card_link * card_link ; struct pnp_id * id ; int active ; int capabilities ; unsigned int num_dependent_sets ; struct list_head resources ; struct list_head options ; char name [ 50 ] ; int flags ; struct proc_dir_entry * procent ; void * data ; } ;
struct pnp_fixup { char id [ 7 ] ; void ( * quirk_function ) ( struct pnp_dev * dev ) ; } ;

struct pnp_id { char id [ 8 ] ; struct pnp_id * next ; } ;

struct pnp_driver { char * name ; const struct pnp_device_id * id_table ; unsigned int flags ; int ( * probe ) ( struct pnp_dev * dev , const struct pnp_device_id * dev_id ) ; void ( * remove ) ( struct pnp_dev * dev ) ; void ( * shutdown ) ( struct pnp_dev * dev ) ; int ( * suspend ) ( struct pnp_dev * dev , pm_message_t state ) ; int ( * resume ) ( struct pnp_dev * dev ) ; struct device_driver driver ; } ;

struct pnp_card_driver { struct list_head global_list ; char * name ; const struct pnp_card_device_id * id_table ; unsigned int flags ; int ( * probe ) ( struct pnp_card_link * card , const struct pnp_card_device_id * card_id ) ; void ( * remove ) ( struct pnp_card_link * card ) ; int ( * suspend ) ( struct pnp_card_link * card , pm_message_t state ) ; int ( * resume ) ( struct pnp_card_link * card ) ; struct pnp_driver link ; } ;

struct pnp_protocol { struct list_head protocol_list ; char * name ; int ( * get ) ( struct pnp_dev * dev ) ; int ( * set ) ( struct pnp_dev * dev ) ; int ( * disable ) ( struct pnp_dev * dev ) ; int ( * suspend ) ( struct pnp_dev * dev , pm_message_t state ) ; int ( * resume ) ( struct pnp_dev * dev ) ; unsigned char number ; struct device dev ; struct list_head cards ; struct list_head devices ; } ;
int mach_set_rtc_mmss ( unsigned long nowtime ) ;

unsigned long mach_get_cmos_time ( void ) ;

unsigned char rtc_cmos_read ( unsigned char addr ) ;

void rtc_cmos_write ( unsigned char val , unsigned char addr ) ;

int update_persistent_clock ( struct timespec now ) ;

void read_persistent_clock ( struct timespec * ts ) ;

unsigned long long native_read_tsc ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_trampoline_memory ( void ) ;

unsigned long setup_trampoline ( void ) ;

enum { POWER_NONE = 0 , POWER_CSTATE = 1 , POWER_PSTATE = 2 , } ;
int arch_dup_task_struct ( struct task_struct * dst , struct task_struct * src ) ;

void free_thread_xstate ( struct task_struct * tsk ) ;

void free_thread_info ( struct thread_info * ti ) ;

void arch_task_cache_init ( void ) ;

void exit_thread ( void ) ;

void flush_thread ( void ) ;

void disable_TSC ( void ) ;

int get_tsc_mode ( unsigned long adr ) ;

int set_tsc_mode ( unsigned int val ) ;

void __switch_to_xtra ( struct task_struct * prev_p , struct task_struct * next_p , struct tss_struct * tss ) ;

int sys_fork ( struct pt_regs * regs ) ;

int sys_vfork ( struct pt_regs * regs ) ;

void default_idle ( void ) ;

void stop_this_cpu ( void * dummy ) ;

void cpu_idle_wait ( void ) ;

void mwait_idle_with_hints ( unsigned long ax , unsigned long cx ) ;

void c1e_remove_cpu ( int cpu ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) select_idle_routine ( const struct cpuinfo_x86 * c ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_c1e_mask ( void ) ;

unsigned long arch_align_stack ( unsigned long sp ) ;

unsigned long arch_randomize_brk ( struct mm_struct * mm ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) mxcsr_feature_mask_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) init_thread_xstate ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) fpu_init ( void ) ;

int init_fpu ( struct task_struct * tsk ) ;

int fpregs_active ( struct task_struct * target , const struct user_regset * regset ) ;

int xfpregs_active ( struct task_struct * target , const struct user_regset * regset ) ;

int xfpregs_get ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , void * kbuf , void * ubuf ) ;

int xfpregs_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void * ubuf ) ;

int fpregs_get ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , void * kbuf , void * ubuf ) ;

int fpregs_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void * ubuf ) ;

int save_i387_xstate_ia32 ( void * buf ) ;

int restore_i387_xstate_ia32 ( void * buf ) ;

int dump_fpu ( struct pt_regs * regs , struct user_i387_struct * fpu ) ;

int check_for_xstate ( struct i387_fxsave_struct * buf , void * fpstate , struct _fpx_sw_bytes * fx_sw_user ) ;

int save_i387_xstate ( void * buf ) ;

int restore_i387_xstate ( void * buf ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) xsave_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) xsave_cntxt_init ( void ) ;

enum { Audit_equal , Audit_not_equal , Audit_bitmask , Audit_bittest , Audit_lt , Audit_gt , Audit_le , Audit_ge , Audit_bad } ;
struct audit_status { __u32 mask ; __u32 enabled ; __u32 failure ; __u32 pid ; __u32 rate_limit ; __u32 backlog_limit ; __u32 lost ; __u32 backlog ; } ;

struct audit_tty_status { __u32 enabled ; } ;

struct audit_rule_data { __u32 flags ; __u32 action ; __u32 field_count ; __u32 mask [ 64 ] ; __u32 fields [ 64 ] ; __u32 values [ 64 ] ; __u32 fieldflags [ 64 ] ; __u32 buflen ; char buf [ 0 ] ; } ;

struct audit_rule { __u32 flags ; __u32 action ; __u32 field_count ; __u32 mask [ 64 ] ; __u32 fields [ 64 ] ; __u32 values [ 64 ] ; } ;

struct audit_sig_info { uid_t uid ; pid_t pid ; char ctx [ 0 ] ; } ;

struct audit_buffer ;

struct netlink_skb_parms ;
struct mqstat ;

struct audit_watch ;

struct audit_tree ;

struct audit_krule { int vers_ops ; u32 flags ; u32 listnr ; u32 action ; u32 mask [ 64 ] ; u32 buflen ; u32 field_count ; char * filterkey ; struct audit_field * fields ; struct audit_field * arch_f ; struct audit_field * inode_f ; struct audit_watch * watch ; struct audit_tree * tree ; struct list_head rlist ; struct list_head list ; u64 prio ; } ;
struct audit_field { u32 type ; u32 val ; u32 op ; char * lsm_str ; void * lsm_rule ; } ;

struct ftrace_raw_sys_enter { struct trace_entry ent ; long id ; unsigned long args [ 6 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_sys_exit { struct trace_entry ent ; long id ; long ret ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_sys_enter { ; } ;

struct ftrace_data_offsets_sys_exit { ; } ;

enum x86_regset { REGSET_GENERAL , REGSET_FP , REGSET_XFP , REGSET_IOPERM64 = REGSET_XFP , REGSET_TLS , REGSET_IOPERM32 , } ;

void ptrace_disable ( struct task_struct * child ) ;

long arch_ptrace ( struct task_struct * child , long request , long addr , long data ) ;

long compat_arch_ptrace ( struct task_struct * child , compat_long_t request , compat_ulong_t caddr , compat_ulong_t cdata ) ;

const struct user_regset_view * task_user_regset_view ( struct task_struct * task ) ;

void send_sigtrap ( struct task_struct * tsk , struct pt_regs * regs , int error_code , int si_code ) ;

long syscall_trace_enter ( struct pt_regs * regs ) ;

void syscall_trace_leave ( struct pt_regs * regs ) ;

int do_set_thread_area ( struct task_struct * p , int idx , struct user_desc * u_info , int can_allocate ) ;

int sys_set_thread_area ( struct user_desc * u_info ) ;

int do_get_thread_area ( struct task_struct * p , int idx , struct user_desc * u_info ) ;

int sys_get_thread_area ( struct user_desc * u_info ) ;

int regset_tls_active ( struct task_struct * target , const struct user_regset * regset ) ;

int regset_tls_get ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , void * kbuf , void * ubuf ) ;

int regset_tls_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void * ubuf ) ;

unsigned long convert_ip_to_linear ( struct task_struct * child , struct pt_regs * regs ) ;

void user_enable_single_step ( struct task_struct * child ) ;

void user_enable_block_step ( struct task_struct * child ) ;

void user_disable_single_step ( struct task_struct * child ) ;

struct stack_trace { unsigned int nr_entries , max_entries ; unsigned long * entries ; int skip ; } ;

void save_stack_trace ( struct stack_trace * trace ) ;

void save_stack_trace_bp ( struct stack_trace * trace , unsigned long bp ) ;

void save_stack_trace_tsk ( struct task_struct * tsk , struct stack_trace * trace ) ;

struct stack_frame { const void * next_fp ; unsigned long ret_addr ; } ;
void save_stack_trace_user ( struct stack_trace * trace ) ;

char * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __acpi_map_table ( unsigned long phys , unsigned long size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __acpi_unmap_table ( char * map , unsigned long size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_pic_sci_set_trigger ( unsigned int irq , u16 trigger ) ;

int acpi_gsi_to_irq ( u32 gsi , unsigned int * irq ) ;

int acpi_register_gsi ( struct device * dev , u32 gsi , int trigger , int polarity ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) acpi_map_lsapic ( acpi_handle handle , int * pcpu ) ;

int acpi_unmap_lsapic ( int cpu ) ;

int acpi_register_ioapic ( acpi_handle handle , u64 phys_addr , u32 gsi_base ) ;

int acpi_unregister_ioapic ( acpi_handle handle , u32 gsi_base ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_probe_gsi ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mp_override_legacy_irq ( u8 bus_irq , u8 polarity , u8 trigger , u32 gsi ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mp_config_acpi_legacy_irqs ( void ) ;

int mp_register_gsi ( struct device * dev , u32 gsi , int trigger , int polarity ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_boot_table_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_acpi_boot_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_boot_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_mps_check ( void ) ;

int __acpi_acquire_global_lock ( unsigned int * lock ) ;

int __acpi_release_global_lock ( unsigned int * lock ) ;

struct wakeup_header { u16 video_mode ; u16 _jmp1 ; u32 pmode_entry ; u16 _jmp2 ; u32 pmode_cr0 ; u32 pmode_cr3 ; u32 pmode_cr4 ; u32 pmode_efer_low ; u32 pmode_efer_high ; u64 pmode_gdt ; u32 realmode_flags ; u32 real_magic ; u16 trampoline_segment ; u8 _pad1 ; u8 wakeup_jmp ; u16 wakeup_jmp_off ; u16 wakeup_jmp_seg ; u64 wakeup_gdt [ 3 ] ; u32 signature ; } __attribute__ ( ( __packed__ ) ) ;
int acpi_save_state_mem ( void ) ;

void acpi_restore_state_mem ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_reserve_bootmem ( void ) ;

typedef unsigned int addr_t ;

struct biosregs { union { struct { u32 edi ; u32 esi ; u32 ebp ; u32 _esp ; u32 ebx ; u32 edx ; u32 ecx ; u32 eax ; u32 _fsgs ; u32 _dses ; u32 eflags ; } ; struct { u16 di , hdi ; u16 si , hsi ; u16 bp , hbp ; u16 _sp , _hsp ; u16 bx , hbx ; u16 dx , hdx ; u16 cx , hcx ; u16 ax , hax ; u16 gs , fs ; u16 es , ds ; u16 flags , hflags ; } ; struct { u8 dil , dih , edi2 , edi3 ; u8 sil , sih , esi2 , esi3 ; u8 bpl , bph , ebp2 , ebp3 ; u8 _spl , _sph , _esp2 , _esp3 ; u8 bl , bh , ebx2 , ebx3 ; u8 dl , dh , edx2 , edx3 ; u8 cl , ch , ecx2 , ecx3 ; u8 al , ah , eax2 , eax3 ; } ; } ; } ;

struct cpu_features { int level ; int model ; u32 flags [ 9 ] ; } ;

void main ( void ) ;
struct mode_info { u16 mode ; u16 x , y ; u16 depth ; } ;

struct card_info { const char * card_name ; int ( * set_mode ) ( struct mode_info * mode ) ; int ( * probe ) ( void ) ; struct mode_info * modes ; int nmodes ; int unsafe ; u16 xmode_first ; u16 xmode_n ; } ;

typedef struct { u16 off , seg ; } far_ptr ;

struct vesa_general_info { u32 signature ; u16 version ; far_ptr vendor_string ; u32 capabilities ; far_ptr video_mode_ptr ; u16 total_memory ; u8 reserved [ 236 ] ; } __attribute__ ( ( packed ) ) ;
struct vesa_mode_info { u16 mode_attr ; u8 win_attr [ 2 ] ; u16 win_grain ; u16 win_size ; u16 win_seg [ 2 ] ; far_ptr win_scheme ; u16 logical_scan ; u16 h_res ; u16 v_res ; u8 char_width ; u8 char_height ; u8 memory_planes ; u8 bpp ; u8 banks ; u8 memory_layout ; u8 bank_size ; u8 image_planes ; u8 page_function ; u8 rmask ; u8 rpos ; u8 gmask ; u8 gpos ; u8 bmask ; u8 bpos ; u8 resv_mask ; u8 resv_pos ; u8 dcm_info ; u32 lfb_ptr ; u32 offscreen_ptr ; u16 offscreen_size ; u8 reserved [ 206 ] ; } __attribute__ ( ( packed ) ) ;
void probe_cards ( int unsafe ) ;

int mode_defined ( u16 mode ) ;

int set_mode ( u16 mode ) ;

void initregs ( struct biosregs * reg ) ;

u16 vga_crtc ( void ) ;

struct cpuidle_device ;

struct cpuidle_state { char name [ 16 ] ; char desc [ 32 ] ; void * driver_data ; unsigned int flags ; unsigned int exit_latency ; unsigned int power_usage ; unsigned int target_residency ; unsigned long long usage ; unsigned long long time ; int ( * enter ) ( struct cpuidle_device * dev , struct cpuidle_state * state ) ; } ;

struct cpuidle_state_kobj { struct cpuidle_state * state ; struct completion kobj_unregister ; struct kobject kobj ; } ;

struct cpuidle_device { unsigned int registered : 1 ; unsigned int enabled : 1 ; unsigned int cpu ; int last_residency ; int state_count ; struct cpuidle_state states [ 8 ] ; struct cpuidle_state_kobj * kobjs [ 8 ] ; struct cpuidle_state * last_state ; struct list_head device_list ; struct kobject kobj ; struct completion kobj_unregister ; void * governor_data ; struct cpuidle_state * safe_state ; } ;
struct cpuidle_driver { char name [ 16 ] ; struct module * owner ; } ;

struct cpuidle_governor { char name [ 16 ] ; struct list_head governor_list ; unsigned int rating ; int ( * enable ) ( struct cpuidle_device * dev ) ; void ( * disable ) ( struct cpuidle_device * dev ) ; int ( * select ) ( struct cpuidle_device * dev ) ; void ( * reflect ) ( struct cpuidle_device * dev ) ; struct module * owner ; } ;

struct thermal_zone_device ;

struct thermal_cooling_device ;

enum thermal_device_mode { THERMAL_DEVICE_DISABLED = 0 , THERMAL_DEVICE_ENABLED , } ;

enum thermal_trip_type { THERMAL_TRIP_ACTIVE = 0 , THERMAL_TRIP_PASSIVE , THERMAL_TRIP_HOT , THERMAL_TRIP_CRITICAL , } ;

struct thermal_zone_device_ops { int ( * bind ) ( struct thermal_zone_device * , struct thermal_cooling_device * ) ; int ( * unbind ) ( struct thermal_zone_device * , struct thermal_cooling_device * ) ; int ( * get_temp ) ( struct thermal_zone_device * , unsigned long * ) ; int ( * get_mode ) ( struct thermal_zone_device * , enum thermal_device_mode * ) ; int ( * set_mode ) ( struct thermal_zone_device * , enum thermal_device_mode ) ; int ( * get_trip_type ) ( struct thermal_zone_device * , int , enum thermal_trip_type * ) ; int ( * get_trip_temp ) ( struct thermal_zone_device * , int , unsigned long * ) ; int ( * get_crit_temp ) ( struct thermal_zone_device * , unsigned long * ) ; int ( * notify ) ( struct thermal_zone_device * , int , enum thermal_trip_type ) ; } ;

struct thermal_cooling_device_ops { int ( * get_max_state ) ( struct thermal_cooling_device * , unsigned long * ) ; int ( * get_cur_state ) ( struct thermal_cooling_device * , unsigned long * ) ; int ( * set_cur_state ) ( struct thermal_cooling_device * , unsigned long ) ; } ;

struct thermal_cooling_device { int id ; char type [ 20 ] ; struct device device ; void * devdata ; struct thermal_cooling_device_ops * ops ; struct list_head node ; } ;
struct thermal_hwmon_device { char type [ 20 ] ; struct device * device ; int count ; struct list_head tz_list ; struct list_head node ; } ;

struct thermal_hwmon_attr { struct device_attribute attr ; char name [ 16 ] ; } ;

struct thermal_zone_device { int id ; char type [ 20 ] ; struct device device ; void * devdata ; int trips ; int tc1 ; int tc2 ; int passive_delay ; int polling_delay ; int last_temperature ; bool passive ; unsigned int forced_passive ; struct thermal_zone_device_ops * ops ; struct list_head cooling_devices ; struct idr idr ; struct mutex lock ; struct list_head node ; struct delayed_work poll_queue ; struct list_head hwmon_node ; struct thermal_hwmon_device * hwmon ; struct thermal_hwmon_attr temp_input ; struct thermal_hwmon_attr temp_crit ; } ;
struct acpi_processor_cx ;

struct acpi_power_register { u8 descriptor ; u16 length ; u8 space_id ; u8 bit_width ; u8 bit_offset ; u8 access_size ; u64 address ; } __attribute__ ( ( packed ) ) ;
struct acpi_processor_cx_policy { u32 count ; struct acpi_processor_cx * state ; struct { u32 time ; u32 ticks ; u32 count ; u32 bm ; } threshold ; } ;

struct acpi_processor_cx { u8 valid ; u8 type ; u32 address ; u8 entry_method ; u8 index ; u32 latency ; u32 latency_ticks ; u32 power ; u32 usage ; u64 time ; u8 bm_sts_skip ; struct acpi_processor_cx_policy promotion ; struct acpi_processor_cx_policy demotion ; char desc [ 32 ] ; } ;
struct acpi_processor_power { struct cpuidle_device dev ; struct acpi_processor_cx * state ; unsigned long bm_check_timestamp ; u32 default_state ; int count ; struct acpi_processor_cx states [ 8 ] ; int timer_broadcast_on_state ; } ;

struct acpi_psd_package { acpi_integer num_entries ; acpi_integer revision ; acpi_integer domain ; acpi_integer coord_type ; acpi_integer num_processors ; } __attribute__ ( ( packed ) ) ;
struct acpi_pct_register { u8 descriptor ; u16 length ; u8 space_id ; u8 bit_width ; u8 bit_offset ; u8 reserved ; u64 address ; } __attribute__ ( ( packed ) ) ;
struct acpi_processor_px { acpi_integer core_frequency ; acpi_integer power ; acpi_integer transition_latency ; acpi_integer bus_master_latency ; acpi_integer control ; acpi_integer status ; } ;

struct acpi_processor_performance { unsigned int state ; unsigned int platform_limit ; struct acpi_pct_register control_register ; struct acpi_pct_register status_register ; unsigned int state_count ; struct acpi_processor_px * states ; struct acpi_psd_package domain_info ; cpumask_var_t shared_cpu_map ; unsigned int shared_type ; } ;

struct acpi_tsd_package { acpi_integer num_entries ; acpi_integer revision ; acpi_integer domain ; acpi_integer coord_type ; acpi_integer num_processors ; } __attribute__ ( ( packed ) ) ;
struct acpi_ptc_register { u8 descriptor ; u16 length ; u8 space_id ; u8 bit_width ; u8 bit_offset ; u8 reserved ; u64 address ; } __attribute__ ( ( packed ) ) ;
struct acpi_processor_tx_tss { acpi_integer freqpercentage ; acpi_integer power ; acpi_integer transition_latency ; acpi_integer control ; acpi_integer status ; } ;

struct acpi_processor_tx { u16 power ; u16 performance ; } ;

struct acpi_processor ;

struct acpi_processor_throttling { unsigned int state ; unsigned int platform_limit ; struct acpi_pct_register control_register ; struct acpi_pct_register status_register ; unsigned int state_count ; struct acpi_processor_tx_tss * states_tss ; struct acpi_tsd_package domain_info ; cpumask_var_t shared_cpu_map ; int ( * acpi_processor_get_throttling ) ( struct acpi_processor * pr ) ; int ( * acpi_processor_set_throttling ) ( struct acpi_processor * pr , int state , bool force ) ; u32 address ; u8 duty_offset ; u8 duty_width ; u8 tsd_valid_flag ; unsigned int shared_type ; struct acpi_processor_tx states [ 16 ] ; } ;

struct acpi_processor_lx { int px ; int tx ; } ;

struct acpi_processor_limit { struct acpi_processor_lx state ; struct acpi_processor_lx thermal ; struct acpi_processor_lx user ; } ;

struct acpi_processor_flags { u8 power : 1 ; u8 performance : 1 ; u8 throttling : 1 ; u8 limit : 1 ; u8 bm_control : 1 ; u8 bm_check : 1 ; u8 has_cst : 1 ; u8 power_setup_done : 1 ; u8 bm_rld_set : 1 ; } ;

struct acpi_processor { acpi_handle handle ; u32 acpi_id ; u32 id ; u32 pblk ; int performance_platform_limit ; int throttling_platform_limit ; struct acpi_processor_flags flags ; struct acpi_processor_power power ; struct acpi_processor_performance * performance ; struct acpi_processor_throttling throttling ; struct acpi_processor_limit limit ; struct thermal_cooling_device * cdev ; struct acpi_object_list * pdc ; } ;
struct acpi_processor_errata { u8 smp ; struct { u8 throttle : 1 ; u8 fdma : 1 ; u8 reserved : 6 ; u32 bmisx ; } piix4 ; } ;

void acpi_processor_power_init_bm_check ( struct acpi_processor_flags * flags , unsigned int cpu ) ;

struct cstate_entry { struct { unsigned int eax ; unsigned int ecx ; } states [ 8 ] ; } ;

int acpi_processor_ffh_cstate_probe ( unsigned int cpu , struct acpi_processor_cx * cx , struct acpi_power_register * reg ) ;

void acpi_processor_ffh_cstate_enter ( struct acpi_processor_cx * cx ) ;

void arch_acpi_processor_init_pdc ( struct acpi_processor * pr ) ;

void arch_acpi_processor_cleanup_pdc ( struct acpi_processor * pr ) ;

enum perf_type_id { PERF_TYPE_HARDWARE = 0 , PERF_TYPE_SOFTWARE = 1 , PERF_TYPE_TRACEPOINT = 2 , PERF_TYPE_HW_CACHE = 3 , PERF_TYPE_RAW = 4 , PERF_TYPE_MAX , } ;

enum perf_hw_id { PERF_COUNT_HW_CPU_CYCLES = 0 , PERF_COUNT_HW_INSTRUCTIONS = 1 , PERF_COUNT_HW_CACHE_REFERENCES = 2 , PERF_COUNT_HW_CACHE_MISSES = 3 , PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4 , PERF_COUNT_HW_BRANCH_MISSES = 5 , PERF_COUNT_HW_BUS_CYCLES = 6 , PERF_COUNT_HW_MAX , } ;

enum perf_hw_cache_id { PERF_COUNT_HW_CACHE_L1D = 0 , PERF_COUNT_HW_CACHE_L1I = 1 , PERF_COUNT_HW_CACHE_LL = 2 , PERF_COUNT_HW_CACHE_DTLB = 3 , PERF_COUNT_HW_CACHE_ITLB = 4 , PERF_COUNT_HW_CACHE_BPU = 5 , PERF_COUNT_HW_CACHE_MAX , } ;

enum perf_hw_cache_op_id { PERF_COUNT_HW_CACHE_OP_READ = 0 , PERF_COUNT_HW_CACHE_OP_WRITE = 1 , PERF_COUNT_HW_CACHE_OP_PREFETCH = 2 , PERF_COUNT_HW_CACHE_OP_MAX , } ;

enum perf_hw_cache_op_result_id { PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0 , PERF_COUNT_HW_CACHE_RESULT_MISS = 1 , PERF_COUNT_HW_CACHE_RESULT_MAX , } ;

enum perf_sw_ids { PERF_COUNT_SW_CPU_CLOCK = 0 , PERF_COUNT_SW_TASK_CLOCK = 1 , PERF_COUNT_SW_PAGE_FAULTS = 2 , PERF_COUNT_SW_CONTEXT_SWITCHES = 3 , PERF_COUNT_SW_CPU_MIGRATIONS = 4 , PERF_COUNT_SW_PAGE_FAULTS_MIN = 5 , PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6 , PERF_COUNT_SW_MAX , } ;

enum perf_event_sample_format { PERF_SAMPLE_IP = 1U << 0 , PERF_SAMPLE_TID = 1U << 1 , PERF_SAMPLE_TIME = 1U << 2 , PERF_SAMPLE_ADDR = 1U << 3 , PERF_SAMPLE_READ = 1U << 4 , PERF_SAMPLE_CALLCHAIN = 1U << 5 , PERF_SAMPLE_ID = 1U << 6 , PERF_SAMPLE_CPU = 1U << 7 , PERF_SAMPLE_PERIOD = 1U << 8 , PERF_SAMPLE_STREAM_ID = 1U << 9 , PERF_SAMPLE_RAW = 1U << 10 , PERF_SAMPLE_MAX = 1U << 11 , } ;

enum perf_event_read_format { PERF_FORMAT_TOTAL_TIME_ENABLED = 1U << 0 , PERF_FORMAT_TOTAL_TIME_RUNNING = 1U << 1 , PERF_FORMAT_ID = 1U << 2 , PERF_FORMAT_GROUP = 1U << 3 , PERF_FORMAT_MAX = 1U << 4 , } ;

struct perf_event_attr { __u32 type ; __u32 size ; __u64 config ; union { __u64 sample_period ; __u64 sample_freq ; } ; __u64 sample_type ; __u64 read_format ; __u64 disabled : 1 , inherit : 1 , pinned : 1 , exclusive : 1 , exclude_user : 1 , exclude_kernel : 1 , exclude_hv : 1 , exclude_idle : 1 , mmap : 1 , comm : 1 , freq : 1 , inherit_stat : 1 , enable_on_exec : 1 , task : 1 , watermark : 1 , __reserved_1 : 49 ; union { __u32 wakeup_events ; __u32 wakeup_watermark ; } ; __u32 __reserved_2 ; __u64 __reserved_3 ; } ;
enum perf_event_ioc_flags { PERF_IOC_FLAG_GROUP = 1U << 0 , } ;

struct perf_event_mmap_page { __u32 version ; __u32 compat_version ; __u32 lock ; __u32 index ; __s64 offset ; __u64 time_enabled ; __u64 time_running ; __u64 __reserved [ 123 ] ; __u64 data_head ; __u64 data_tail ; } ;

struct perf_event_header { __u32 type ; __u16 misc ; __u16 size ; } ;

enum perf_event_type { PERF_RECORD_MMAP = 1 , PERF_RECORD_LOST = 2 , PERF_RECORD_COMM = 3 , PERF_RECORD_EXIT = 4 , PERF_RECORD_THROTTLE = 5 , PERF_RECORD_UNTHROTTLE = 6 , PERF_RECORD_FORK = 7 , PERF_RECORD_READ = 8 , PERF_RECORD_SAMPLE = 9 , PERF_RECORD_MAX , } ;

enum perf_callchain_context { PERF_CONTEXT_HV = ( __u64 ) - 32 , PERF_CONTEXT_KERNEL = ( __u64 ) - 128 , PERF_CONTEXT_USER = ( __u64 ) - 512 , PERF_CONTEXT_GUEST = ( __u64 ) - 2048 , PERF_CONTEXT_GUEST_KERNEL = ( __u64 ) - 2176 , PERF_CONTEXT_GUEST_USER = ( __u64 ) - 2560 , PERF_CONTEXT_MAX = ( __u64 ) - 4095 , } ;

union cpuid10_eax { struct { unsigned int version_id : 8 ; unsigned int num_events : 8 ; unsigned int bit_width : 8 ; unsigned int mask_length : 8 ; } split ; unsigned int full ; } ;

union cpuid10_edx { struct { unsigned int num_events_fixed : 4 ; unsigned int reserved : 28 ; } split ; unsigned int full ; } ;

struct perf_callchain_entry { __u64 nr ; __u64 ip [ 255 ] ; } ;

struct perf_raw_record { u32 size ; void * data ; } ;

struct hw_perf_event { union { struct { u64 config ; unsigned long config_base ; unsigned long event_base ; int idx ; } ; struct { s64 remaining ; struct hrtimer hrtimer ; } ; } ; atomic64_t prev_count ; u64 sample_period ; u64 last_period ; atomic64_t period_left ; u64 interrupts ; u64 freq_count ; u64 freq_interrupts ; u64 freq_stamp ; } ;

struct perf_event ;

struct pmu { int ( * enable ) ( struct perf_event * event ) ; void ( * disable ) ( struct perf_event * event ) ; void ( * read ) ( struct perf_event * event ) ; void ( * unthrottle ) ( struct perf_event * event ) ; } ;

enum perf_event_active_state { PERF_EVENT_STATE_ERROR = - 2 , PERF_EVENT_STATE_OFF = - 1 , PERF_EVENT_STATE_INACTIVE = 0 , PERF_EVENT_STATE_ACTIVE = 1 , } ;

struct perf_mmap_data { struct rcu_head rcu_head ; int data_order ; int nr_pages ; int writable ; int nr_locked ; atomic_t poll ; atomic_t events ; atomic_long_t head ; atomic_long_t done_head ; atomic_t lock ; atomic_t wakeup ; atomic_t lost ; long watermark ; struct perf_event_mmap_page * user_page ; void * data_pages [ 0 ] ; } ;

struct perf_pending_entry { struct perf_pending_entry * next ; void ( * func ) ( struct perf_pending_entry * ) ; } ;

struct perf_event { struct list_head group_entry ; struct list_head event_entry ; struct list_head sibling_list ; int nr_siblings ; struct perf_event * group_leader ; struct perf_event * output ; const struct pmu * pmu ; enum perf_event_active_state state ; atomic64_t count ; u64 total_time_enabled ; u64 total_time_running ; u64 tstamp_enabled ; u64 tstamp_running ; u64 tstamp_stopped ; struct perf_event_attr attr ; struct hw_perf_event hw ; struct perf_event_context * ctx ; struct file * filp ; atomic64_t child_total_time_enabled ; atomic64_t child_total_time_running ; struct mutex child_mutex ; struct list_head child_list ; struct perf_event * parent ; int oncpu ; int cpu ; struct list_head owner_entry ; struct task_struct * owner ; struct mutex mmap_mutex ; atomic_t mmap_count ; struct perf_mmap_data * data ; wait_queue_head_t waitq ; struct fasync_struct * fasync ; int pending_wakeup ; int pending_kill ; int pending_disable ; struct perf_pending_entry pending ; atomic_t event_limit ; void ( * destroy ) ( struct perf_event * ) ; struct rcu_head rcu_head ; struct pid_namespace * ns ; u64 id ; } ;
struct perf_event_context { spinlock_t lock ; struct mutex mutex ; struct list_head group_list ; struct list_head event_list ; int nr_events ; int nr_active ; int is_active ; int nr_stat ; atomic_t refcount ; struct task_struct * task ; u64 time ; u64 timestamp ; struct perf_event_context * parent_ctx ; u64 parent_gen ; u64 generation ; int pin_count ; struct rcu_head rcu_head ; } ;
struct perf_cpu_context { struct perf_event_context ctx ; struct perf_event_context * task_ctx ; int active_oncpu ; int max_pertask ; int exclusive ; int recursion [ 4 ] ; } ;

struct perf_output_handle { struct perf_event * event ; struct perf_mmap_data * data ; unsigned long head ; unsigned long offset ; int nmi ; int sample ; int locked ; unsigned long flags ; } ;

struct perf_sample_data { u64 type ; u64 ip ; struct { u32 pid ; u32 tid ; } tid_entry ; u64 time ; u64 addr ; u64 id ; u64 stream_id ; struct { u32 cpu ; u32 reserved ; } cpu_entry ; u64 period ; struct perf_callchain_entry * callchain ; struct perf_raw_record * raw ; } ;

void apic_disable ( void ) ;

void native_apic_wait_icr_idle ( void ) ;

u32 native_safe_apic_wait_icr_idle ( void ) ;

void native_apic_icr_write ( u32 low , u32 id ) ;

u64 native_apic_icr_read ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) enable_NMI_through_LVT0 ( void ) ;

int lapic_get_maxlvt ( void ) ;

u8 setup_APIC_eilvt_mce ( u8 vector , u8 msg_type , u8 mask ) ;

u8 setup_APIC_eilvt_ibs ( u8 vector , u8 msg_type , u8 mask ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_boot_APIC_clock ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) setup_secondary_APIC_clock ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) smp_apic_timer_interrupt ( struct pt_regs * regs ) ;

int setup_profiling_timer ( unsigned int multiplier ) ;

void clear_local_APIC ( void ) ;

void disable_local_APIC ( void ) ;

void lapic_shutdown ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) verify_local_APIC ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sync_Arb_IDs ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_bsp_APIC ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) setup_local_APIC ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) end_local_APIC_setup ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) enable_IR ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) enable_IR_x2apic ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_init_lapic_mapping ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_apic_mappings ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) APIC_init_uniprocessor ( void ) ;

void smp_spurious_interrupt ( struct pt_regs * regs ) ;

void smp_error_interrupt ( struct pt_regs * regs ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) connect_bsp_APIC ( void ) ;

void disconnect_bsp_APIC ( int virt_wire_setup ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) generic_processor_info ( int apicid , int version ) ;

int hard_smp_processor_id ( void ) ;

void default_init_apic_ldr ( void ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) int apic_is_clustered_box ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) default_setup_apic_routing ( void ) ;

void apic_send_IPI_self ( int vector ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) default_acpi_madt_oem_check ( char * oem_id , char * oem_table_id ) ;

void default_send_IPI_mask_sequence_phys ( const struct cpumask * mask , int vector ) ;

void default_send_IPI_mask_allbutself_phys ( const struct cpumask * mask , int vector ) ;

void default_send_IPI_mask_sequence_logical ( const struct cpumask * mask , int vector ) ;

void default_send_IPI_mask_allbutself_logical ( const struct cpumask * mask , int vector ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) check_nmi_watchdog ( void ) ;

void acpi_nmi_enable ( void ) ;

void acpi_nmi_disable ( void ) ;

void cpu_nmi_set_wd_enabled ( void ) ;

void setup_apic_nmi_watchdog ( void * unused ) ;

void stop_apic_nmi_watchdog ( void * unused ) ;

void touch_nmi_watchdog ( void ) ;

__attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( __section__ ( ) ) ) int nmi_watchdog_tick ( struct pt_regs * regs , unsigned reason ) ;

int proc_nmi_enabled ( struct ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

int do_nmi_callback ( struct pt_regs * regs , int cpu ) ;

void arch_trigger_all_cpu_backtrace ( void ) ;

struct ht_irq_msg { u32 address_lo ; u32 address_hi ; } ;

typedef void ( ht_irq_update_t ) ( struct pci_dev * dev , int irq , struct ht_irq_msg * msg ) ;

struct hpet { u64 hpet_cap ; u64 res0 ; u64 hpet_config ; u64 res1 ; u64 hpet_isr ; u64 res2 [ 25 ] ; union { u64 _hpet_mc64 ; u32 _hpet_mc32 ; unsigned long _hpet_mc ; } _u0 ; u64 res3 ; struct hpet_timer { u64 hpet_config ; union { u64 _hpet_hc64 ; u32 _hpet_hc32 ; unsigned long _hpet_compare ; } _u1 ; u64 hpet_fsb [ 2 ] ; } hpet_timers [ 1 ] ; } ;

struct hpet_data { unsigned long hd_phys_address ; void * hd_address ; unsigned short hd_nirqs ; unsigned int hd_state ; unsigned int hd_irq [ ( 32 ) ] ; } ;

struct hpet_info { unsigned long hi_ireqfreq ; unsigned long hi_flags ; unsigned short hi_hpet ; unsigned short hi_timer ; } ;

union uvh_bau_data_config_u { unsigned long v ; struct uvh_bau_data_config_s { unsigned long vector_ : 8 ; unsigned long dm : 3 ; unsigned long destmode : 1 ; unsigned long status : 1 ; unsigned long p : 1 ; unsigned long rsvd_14 : 1 ; unsigned long t : 1 ; unsigned long m : 1 ; unsigned long rsvd_17_31 : 15 ; unsigned long apic_id : 32 ; } s ; } ;

union uvh_event_occurred0_u { unsigned long v ; struct uvh_event_occurred0_s { unsigned long lb_hcerr : 1 ; unsigned long gr0_hcerr : 1 ; unsigned long gr1_hcerr : 1 ; unsigned long lh_hcerr : 1 ; unsigned long rh_hcerr : 1 ; unsigned long xn_hcerr : 1 ; unsigned long si_hcerr : 1 ; unsigned long lb_aoerr0 : 1 ; unsigned long gr0_aoerr0 : 1 ; unsigned long gr1_aoerr0 : 1 ; unsigned long lh_aoerr0 : 1 ; unsigned long rh_aoerr0 : 1 ; unsigned long xn_aoerr0 : 1 ; unsigned long si_aoerr0 : 1 ; unsigned long lb_aoerr1 : 1 ; unsigned long gr0_aoerr1 : 1 ; unsigned long gr1_aoerr1 : 1 ; unsigned long lh_aoerr1 : 1 ; unsigned long rh_aoerr1 : 1 ; unsigned long xn_aoerr1 : 1 ; unsigned long si_aoerr1 : 1 ; unsigned long rh_vpi_int : 1 ; unsigned long system_shutdown_int : 1 ; unsigned long lb_irq_int_0 : 1 ; unsigned long lb_irq_int_1 : 1 ; unsigned long lb_irq_int_2 : 1 ; unsigned long lb_irq_int_3 : 1 ; unsigned long lb_irq_int_4 : 1 ; unsigned long lb_irq_int_5 : 1 ; unsigned long lb_irq_int_6 : 1 ; unsigned long lb_irq_int_7 : 1 ; unsigned long lb_irq_int_8 : 1 ; unsigned long lb_irq_int_9 : 1 ; unsigned long lb_irq_int_10 : 1 ; unsigned long lb_irq_int_11 : 1 ; unsigned long lb_irq_int_12 : 1 ; unsigned long lb_irq_int_13 : 1 ; unsigned long lb_irq_int_14 : 1 ; unsigned long lb_irq_int_15 : 1 ; unsigned long l1_nmi_int : 1 ; unsigned long stop_clock : 1 ; unsigned long asic_to_l1 : 1 ; unsigned long l1_to_asic : 1 ; unsigned long ltc_int : 1 ; unsigned long la_seq_trigger : 1 ; unsigned long ipi_int : 1 ; unsigned long extio_int0 : 1 ; unsigned long extio_int1 : 1 ; unsigned long extio_int2 : 1 ; unsigned long extio_int3 : 1 ; unsigned long profile_int : 1 ; unsigned long rtc0 : 1 ; unsigned long rtc1 : 1 ; unsigned long rtc2 : 1 ; unsigned long rtc3 : 1 ; unsigned long bau_data : 1 ; unsigned long power_management_req : 1 ; unsigned long rsvd_57_63 : 7 ; } s ; } ;

union uvh_gr0_tlb_int0_config_u { unsigned long v ; struct uvh_gr0_tlb_int0_config_s { unsigned long vector_ : 8 ; unsigned long dm : 3 ; unsigned long destmode : 1 ; unsigned long status : 1 ; unsigned long p : 1 ; unsigned long rsvd_14 : 1 ; unsigned long t : 1 ; unsigned long m : 1 ; unsigned long rsvd_17_31 : 15 ; unsigned long apic_id : 32 ; } s ; } ;

union uvh_gr0_tlb_int1_config_u { unsigned long v ; struct uvh_gr0_tlb_int1_config_s { unsigned long vector_ : 8 ; unsigned long dm : 3 ; unsigned long destmode : 1 ; unsigned long status : 1 ; unsigned long p : 1 ; unsigned long rsvd_14 : 1 ; unsigned long t : 1 ; unsigned long m : 1 ; unsigned long rsvd_17_31 : 15 ; unsigned long apic_id : 32 ; } s ; } ;

union uvh_gr1_tlb_int0_config_u { unsigned long v ; struct uvh_gr1_tlb_int0_config_s { unsigned long vector_ : 8 ; unsigned long dm : 3 ; unsigned long destmode : 1 ; unsigned long status : 1 ; unsigned long p : 1 ; unsigned long rsvd_14 : 1 ; unsigned long t : 1 ; unsigned long m : 1 ; unsigned long rsvd_17_31 : 15 ; unsigned long apic_id : 32 ; } s ; } ;

union uvh_gr1_tlb_int1_config_u { unsigned long v ; struct uvh_gr1_tlb_int1_config_s { unsigned long vector_ : 8 ; unsigned long dm : 3 ; unsigned long destmode : 1 ; unsigned long status : 1 ; unsigned long p : 1 ; unsigned long rsvd_14 : 1 ; unsigned long t : 1 ; unsigned long m : 1 ; unsigned long rsvd_17_31 : 15 ; unsigned long apic_id : 32 ; } s ; } ;

union uvh_int_cmpb_u { unsigned long v ; struct uvh_int_cmpb_s { unsigned long real_time_cmpb : 56 ; unsigned long rsvd_56_63 : 8 ; } s ; } ;

union uvh_int_cmpc_u { unsigned long v ; struct uvh_int_cmpc_s { unsigned long real_time_cmpc : 56 ; unsigned long rsvd_56_63 : 8 ; } s ; } ;

union uvh_int_cmpd_u { unsigned long v ; struct uvh_int_cmpd_s { unsigned long real_time_cmpd : 56 ; unsigned long rsvd_56_63 : 8 ; } s ; } ;

union uvh_ipi_int_u { unsigned long v ; struct uvh_ipi_int_s { unsigned long vector_ : 8 ; unsigned long delivery_mode : 3 ; unsigned long destmode : 1 ; unsigned long rsvd_12_15 : 4 ; unsigned long apic_id : 32 ; unsigned long rsvd_48_62 : 15 ; unsigned long send : 1 ; } s ; } ;

union uvh_lb_bau_intd_payload_queue_first_u { unsigned long v ; struct uvh_lb_bau_intd_payload_queue_first_s { unsigned long rsvd_0_3 : 4 ; unsigned long address : 39 ; unsigned long rsvd_43_48 : 6 ; unsigned long node_id : 14 ; unsigned long rsvd_63 : 1 ; } s ; } ;

union uvh_lb_bau_intd_payload_queue_last_u { unsigned long v ; struct uvh_lb_bau_intd_payload_queue_last_s { unsigned long rsvd_0_3 : 4 ; unsigned long address : 39 ; unsigned long rsvd_43_63 : 21 ; } s ; } ;

union uvh_lb_bau_intd_payload_queue_tail_u { unsigned long v ; struct uvh_lb_bau_intd_payload_queue_tail_s { unsigned long rsvd_0_3 : 4 ; unsigned long address : 39 ; unsigned long rsvd_43_63 : 21 ; } s ; } ;

union uvh_lb_bau_intd_software_acknowledge_u { unsigned long v ; struct uvh_lb_bau_intd_software_acknowledge_s { unsigned long pending_0 : 1 ; unsigned long pending_1 : 1 ; unsigned long pending_2 : 1 ; unsigned long pending_3 : 1 ; unsigned long pending_4 : 1 ; unsigned long pending_5 : 1 ; unsigned long pending_6 : 1 ; unsigned long pending_7 : 1 ; unsigned long timeout_0 : 1 ; unsigned long timeout_1 : 1 ; unsigned long timeout_2 : 1 ; unsigned long timeout_3 : 1 ; unsigned long timeout_4 : 1 ; unsigned long timeout_5 : 1 ; unsigned long timeout_6 : 1 ; unsigned long timeout_7 : 1 ; unsigned long rsvd_16_63 : 48 ; } s ; } ;

union uvh_lb_bau_sb_activation_control_u { unsigned long v ; struct uvh_lb_bau_sb_activation_control_s { unsigned long index : 6 ; unsigned long rsvd_6_61 : 56 ; unsigned long push : 1 ; unsigned long init : 1 ; } s ; } ;

union uvh_lb_bau_sb_activation_status_0_u { unsigned long v ; struct uvh_lb_bau_sb_activation_status_0_s { unsigned long status : 64 ; } s ; } ;

union uvh_lb_bau_sb_activation_status_1_u { unsigned long v ; struct uvh_lb_bau_sb_activation_status_1_s { unsigned long status : 64 ; } s ; } ;

union uvh_lb_bau_sb_descriptor_base_u { unsigned long v ; struct uvh_lb_bau_sb_descriptor_base_s { unsigned long rsvd_0_11 : 12 ; unsigned long page_address : 31 ; unsigned long rsvd_43_48 : 6 ; unsigned long node_id : 14 ; unsigned long rsvd_63 : 1 ; } s ; } ;

union uvh_lb_mcast_aoerr0_rpt_enable_u { unsigned long v ; struct uvh_lb_mcast_aoerr0_rpt_enable_s { unsigned long mcast_obese_msg : 1 ; unsigned long mcast_data_sb_err : 1 ; unsigned long mcast_nack_buff_parity : 1 ; unsigned long mcast_timeout : 1 ; unsigned long mcast_inactive_reply : 1 ; unsigned long mcast_upgrade_error : 1 ; unsigned long mcast_reg_count_underflow : 1 ; unsigned long mcast_rep_obese_msg : 1 ; unsigned long ucache_req_runt_msg : 1 ; unsigned long ucache_req_obese_msg : 1 ; unsigned long ucache_req_data_sb_err : 1 ; unsigned long ucache_rep_runt_msg : 1 ; unsigned long ucache_rep_obese_msg : 1 ; unsigned long ucache_rep_data_sb_err : 1 ; unsigned long ucache_rep_command_err : 1 ; unsigned long ucache_pend_timeout : 1 ; unsigned long macc_req_runt_msg : 1 ; unsigned long macc_req_obese_msg : 1 ; unsigned long macc_req_data_sb_err : 1 ; unsigned long macc_rep_runt_msg : 1 ; unsigned long macc_rep_obese_msg : 1 ; unsigned long macc_rep_data_sb_err : 1 ; unsigned long macc_amo_timeout : 1 ; unsigned long macc_put_timeout : 1 ; unsigned long macc_spurious_event : 1 ; unsigned long ioh_destination_table_parity : 1 ; unsigned long get_had_error_reply : 1 ; unsigned long get_timeout : 1 ; unsigned long lock_manager_had_error_reply : 1 ; unsigned long put_had_error_reply : 1 ; unsigned long put_timeout : 1 ; unsigned long sb_activation_overrun : 1 ; unsigned long completed_gb_activation_had_error_reply : 1 ; unsigned long completed_gb_activation_timeout : 1 ; unsigned long descriptor_buffer_0_parity : 1 ; unsigned long descriptor_buffer_1_parity : 1 ; unsigned long socket_destination_table_parity : 1 ; unsigned long bau_reply_payload_corruption : 1 ; unsigned long io_port_destination_table_parity : 1 ; unsigned long intd_soft_ack_timeout : 1 ; unsigned long int_rep_obese_msg : 1 ; unsigned long int_rep_command_err : 1 ; unsigned long int_timeout : 1 ; unsigned long rsvd_43_63 : 21 ; } s ; } ;

union uvh_local_int0_config_u { unsigned long v ; struct uvh_local_int0_config_s { unsigned long vector_ : 8 ; unsigned long dm : 3 ; unsigned long destmode : 1 ; unsigned long status : 1 ; unsigned long p : 1 ; unsigned long rsvd_14 : 1 ; unsigned long t : 1 ; unsigned long m : 1 ; unsigned long rsvd_17_31 : 15 ; unsigned long apic_id : 32 ; } s ; } ;

union uvh_local_int0_enable_u { unsigned long v ; struct uvh_local_int0_enable_s { unsigned long lb_hcerr : 1 ; unsigned long gr0_hcerr : 1 ; unsigned long gr1_hcerr : 1 ; unsigned long lh_hcerr : 1 ; unsigned long rh_hcerr : 1 ; unsigned long xn_hcerr : 1 ; unsigned long si_hcerr : 1 ; unsigned long lb_aoerr0 : 1 ; unsigned long gr0_aoerr0 : 1 ; unsigned long gr1_aoerr0 : 1 ; unsigned long lh_aoerr0 : 1 ; unsigned long rh_aoerr0 : 1 ; unsigned long xn_aoerr0 : 1 ; unsigned long si_aoerr0 : 1 ; unsigned long lb_aoerr1 : 1 ; unsigned long gr0_aoerr1 : 1 ; unsigned long gr1_aoerr1 : 1 ; unsigned long lh_aoerr1 : 1 ; unsigned long rh_aoerr1 : 1 ; unsigned long xn_aoerr1 : 1 ; unsigned long si_aoerr1 : 1 ; unsigned long rh_vpi_int : 1 ; unsigned long system_shutdown_int : 1 ; unsigned long lb_irq_int_0 : 1 ; unsigned long lb_irq_int_1 : 1 ; unsigned long lb_irq_int_2 : 1 ; unsigned long lb_irq_int_3 : 1 ; unsigned long lb_irq_int_4 : 1 ; unsigned long lb_irq_int_5 : 1 ; unsigned long lb_irq_int_6 : 1 ; unsigned long lb_irq_int_7 : 1 ; unsigned long lb_irq_int_8 : 1 ; unsigned long lb_irq_int_9 : 1 ; unsigned long lb_irq_int_10 : 1 ; unsigned long lb_irq_int_11 : 1 ; unsigned long lb_irq_int_12 : 1 ; unsigned long lb_irq_int_13 : 1 ; unsigned long lb_irq_int_14 : 1 ; unsigned long lb_irq_int_15 : 1 ; unsigned long l1_nmi_int : 1 ; unsigned long stop_clock : 1 ; unsigned long asic_to_l1 : 1 ; unsigned long l1_to_asic : 1 ; unsigned long ltc_int : 1 ; unsigned long la_seq_trigger : 1 ; unsigned long rsvd_45_63 : 19 ; } s ; } ;

union uvh_node_id_u { unsigned long v ; struct uvh_node_id_s { unsigned long force1 : 1 ; unsigned long manufacturer : 11 ; unsigned long part_number : 16 ; unsigned long revision : 4 ; unsigned long node_id : 15 ; unsigned long rsvd_47 : 1 ; unsigned long nodes_per_bit : 7 ; unsigned long rsvd_55 : 1 ; unsigned long ni_port : 4 ; unsigned long rsvd_60_63 : 4 ; } s ; } ;

union uvh_node_present_table_u { unsigned long v ; struct uvh_node_present_table_s { unsigned long nodes : 64 ; } s ; } ;

union uvh_rh_gam_alias210_redirect_config_0_mmr_u { unsigned long v ; struct uvh_rh_gam_alias210_redirect_config_0_mmr_s { unsigned long rsvd_0_23 : 24 ; unsigned long dest_base : 22 ; unsigned long rsvd_46_63 : 18 ; } s ; } ;

union uvh_rh_gam_alias210_redirect_config_1_mmr_u { unsigned long v ; struct uvh_rh_gam_alias210_redirect_config_1_mmr_s { unsigned long rsvd_0_23 : 24 ; unsigned long dest_base : 22 ; unsigned long rsvd_46_63 : 18 ; } s ; } ;

union uvh_rh_gam_alias210_redirect_config_2_mmr_u { unsigned long v ; struct uvh_rh_gam_alias210_redirect_config_2_mmr_s { unsigned long rsvd_0_23 : 24 ; unsigned long dest_base : 22 ; unsigned long rsvd_46_63 : 18 ; } s ; } ;

union uvh_rh_gam_cfg_overlay_config_mmr_u { unsigned long v ; struct uvh_rh_gam_cfg_overlay_config_mmr_s { unsigned long rsvd_0_25 : 26 ; unsigned long base : 20 ; unsigned long rsvd_46_62 : 17 ; unsigned long enable : 1 ; } s ; } ;

union uvh_rh_gam_gru_overlay_config_mmr_u { unsigned long v ; struct uvh_rh_gam_gru_overlay_config_mmr_s { unsigned long rsvd_0_27 : 28 ; unsigned long base : 18 ; unsigned long rsvd_46_47 : 2 ; unsigned long gr4 : 1 ; unsigned long rsvd_49_51 : 3 ; unsigned long n_gru : 4 ; unsigned long rsvd_56_62 : 7 ; unsigned long enable : 1 ; } s ; } ;

union uvh_rh_gam_mmioh_overlay_config_mmr_u { unsigned long v ; struct uvh_rh_gam_mmioh_overlay_config_mmr_s { unsigned long rsvd_0_29 : 30 ; unsigned long base : 16 ; unsigned long m_io : 6 ; unsigned long n_io : 4 ; unsigned long rsvd_56_62 : 7 ; unsigned long enable : 1 ; } s ; } ;

union uvh_rh_gam_mmr_overlay_config_mmr_u { unsigned long v ; struct uvh_rh_gam_mmr_overlay_config_mmr_s { unsigned long rsvd_0_25 : 26 ; unsigned long base : 20 ; unsigned long dual_hub : 1 ; unsigned long rsvd_47_62 : 16 ; unsigned long enable : 1 ; } s ; } ;

union uvh_rtc_u { unsigned long v ; struct uvh_rtc_s { unsigned long real_time_clock : 56 ; unsigned long rsvd_56_63 : 8 ; } s ; } ;

union uvh_rtc1_int_config_u { unsigned long v ; struct uvh_rtc1_int_config_s { unsigned long vector_ : 8 ; unsigned long dm : 3 ; unsigned long destmode : 1 ; unsigned long status : 1 ; unsigned long p : 1 ; unsigned long rsvd_14 : 1 ; unsigned long t : 1 ; unsigned long m : 1 ; unsigned long rsvd_17_31 : 15 ; unsigned long apic_id : 32 ; } s ; } ;

union uvh_rtc2_int_config_u { unsigned long v ; struct uvh_rtc2_int_config_s { unsigned long vector_ : 8 ; unsigned long dm : 3 ; unsigned long destmode : 1 ; unsigned long status : 1 ; unsigned long p : 1 ; unsigned long rsvd_14 : 1 ; unsigned long t : 1 ; unsigned long m : 1 ; unsigned long rsvd_17_31 : 15 ; unsigned long apic_id : 32 ; } s ; } ;

union uvh_rtc3_int_config_u { unsigned long v ; struct uvh_rtc3_int_config_s { unsigned long vector_ : 8 ; unsigned long dm : 3 ; unsigned long destmode : 1 ; unsigned long status : 1 ; unsigned long p : 1 ; unsigned long rsvd_14 : 1 ; unsigned long t : 1 ; unsigned long m : 1 ; unsigned long rsvd_17_31 : 15 ; unsigned long apic_id : 32 ; } s ; } ;

union uvh_rtc_inc_ratio_u { unsigned long v ; struct uvh_rtc_inc_ratio_s { unsigned long fraction : 20 ; unsigned long ratio : 3 ; unsigned long rsvd_23_63 : 41 ; } s ; } ;

union uvh_si_addr_map_config_u { unsigned long v ; struct uvh_si_addr_map_config_s { unsigned long m_skt : 6 ; unsigned long rsvd_6_7 : 2 ; unsigned long n_skt : 4 ; unsigned long rsvd_12_63 : 52 ; } s ; } ;

union uvh_si_alias0_overlay_config_u { unsigned long v ; struct uvh_si_alias0_overlay_config_s { unsigned long rsvd_0_23 : 24 ; unsigned long base : 8 ; unsigned long rsvd_32_47 : 16 ; unsigned long m_alias : 5 ; unsigned long rsvd_53_62 : 10 ; unsigned long enable : 1 ; } s ; } ;

union uvh_si_alias1_overlay_config_u { unsigned long v ; struct uvh_si_alias1_overlay_config_s { unsigned long rsvd_0_23 : 24 ; unsigned long base : 8 ; unsigned long rsvd_32_47 : 16 ; unsigned long m_alias : 5 ; unsigned long rsvd_53_62 : 10 ; unsigned long enable : 1 ; } s ; } ;

union uvh_si_alias2_overlay_config_u { unsigned long v ; struct uvh_si_alias2_overlay_config_s { unsigned long rsvd_0_23 : 24 ; unsigned long base : 8 ; unsigned long rsvd_32_47 : 16 ; unsigned long m_alias : 5 ; unsigned long rsvd_53_62 : 10 ; unsigned long enable : 1 ; } s ; } ;

struct uv_scir_s { struct timer_list timer ; unsigned long offset ; unsigned long last ; unsigned long idle_on ; unsigned long idle_off ; unsigned char state ; unsigned char enabled ; } ;

struct uv_hub_info_s { unsigned long global_mmr_base ; unsigned long gpa_mask ; unsigned int gnode_extra ; unsigned long gnode_upper ; unsigned long lowmem_remap_top ; unsigned long lowmem_remap_base ; unsigned short pnode ; unsigned short pnode_mask ; unsigned short coherency_domain_number ; unsigned short numa_blade_id ; unsigned char blade_processor_id ; unsigned char m_val ; unsigned char n_val ; struct uv_scir_s scir ; } ;

struct uv_blade_info { unsigned short nr_possible_cpus ; unsigned short nr_online_cpus ; unsigned short pnode ; short memory_nid ; } ;

struct uv_IO_APIC_route_entry { __u64 vector : 8 , delivery_mode : 3 , dest_mode : 1 , delivery_status : 1 , polarity : 1 , __reserved_1 : 1 , trigger : 1 , mask : 1 , __reserved_2 : 15 , dest : 32 ; } ;

void arch_disable_smp_support ( void ) ;
struct irq_pin_list { int apic , pin ; struct irq_pin_list * next ; } ;

struct irq_cfg { struct irq_pin_list * irq_2_pin ; cpumask_var_t domain ; cpumask_var_t old_domain ; unsigned move_cleanup_count ; u8 vector ; u8 move_in_progress : 1 ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) io_apic_disable_legacy ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) arch_early_irq_init ( void ) ;

int arch_init_chip_data ( struct irq_desc * desc , int node ) ;

void arch_init_copy_chip_data ( struct irq_desc * old_desc , struct irq_desc * desc , int node ) ;

void arch_free_chip_data ( struct irq_desc * old_desc , struct irq_desc * desc ) ;

struct io_apic { unsigned int index ; unsigned int unused [ 3 ] ; unsigned int data ; unsigned int unused2 [ 11 ] ; unsigned int eoi ; } ;

union entry_union { struct { u32 w1 , w2 ; } ; struct IO_APIC_route_entry entry ; } ;

void ioapic_write_entry ( int apic , int pin , struct IO_APIC_route_entry e ) ;

struct IO_APIC_route_entry * * alloc_ioapic_entries ( void ) ;

int save_IO_APIC_setup ( struct IO_APIC_route_entry * * ioapic_entries ) ;

void mask_IO_APIC_setup ( struct IO_APIC_route_entry * * ioapic_entries ) ;

int restore_IO_APIC_setup ( struct IO_APIC_route_entry * * ioapic_entries ) ;

void free_ioapic_entries ( struct IO_APIC_route_entry * * ioapic_entries ) ;

int IO_APIC_get_PCI_irq_vector ( int bus , int slot , int pin , struct io_apic_irq_attr * irq_attr ) ;

void lock_vector_lock ( void ) ;

void unlock_vector_lock ( void ) ;

void __setup_vector_irq ( int cpu ) ;

int setup_ioapic_entry ( int apic_id , int irq , struct IO_APIC_route_entry * entry , unsigned int destination , int trigger , int polarity , int vector , int pin ) ;

void setup_IO_APIC_irq_extra ( u32 gsi ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) enable_IO_APIC ( void ) ;

void disable_IO_APIC ( void ) ;

void smp_irq_move_cleanup_interrupt ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_IO_APIC ( void ) ;

struct sysfs_ioapic_data { struct sys_device dev ; struct IO_APIC_route_entry entry [ 0 ] ; } ;

unsigned int create_irq_nr ( unsigned int irq_want , int node ) ;

int create_irq ( void ) ;

void destroy_irq ( unsigned int irq ) ;

int arch_setup_msi_irqs ( struct pci_dev * dev , int nvec , int type ) ;

void arch_teardown_msi_irq ( unsigned int irq ) ;

int arch_setup_hpet_msi ( unsigned int irq ) ;

int arch_setup_ht_irq ( unsigned int irq , struct pci_dev * dev ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) io_apic_get_redir_entries ( int ioapic ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) probe_nr_irqs_gsi ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) arch_probe_nr_irqs ( void ) ;

int io_apic_set_pci_routing ( struct device * dev , int irq , struct io_apic_irq_attr * irq_attr ) ;

u8 __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) io_apic_unique_id ( u8 id ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) io_apic_get_version ( int ioapic ) ;

int acpi_get_override_irq ( int bus_irq , int * trigger , int * polarity ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_ioapic_dest ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ioapic_init_mappings ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ioapic_insert_resources ( void ) ;

int mp_find_ioapic ( int gsi ) ;

int mp_find_ioapic_pin ( int ioapic , int gsi ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mp_register_ioapic ( int id , u32 address , u32 gsi_base ) ;

struct _cache_table { unsigned char descriptor ; char cache_type ; short size ; } ;

enum _cache_type { CACHE_TYPE_NULL = 0 , CACHE_TYPE_DATA = 1 , CACHE_TYPE_INST = 2 , CACHE_TYPE_UNIFIED = 3 } ;

union _cpuid4_leaf_eax { struct { enum _cache_type type : 5 ; unsigned int level : 3 ; unsigned int is_self_initializing : 1 ; unsigned int is_fully_associative : 1 ; unsigned int reserved : 4 ; unsigned int num_threads_sharing : 12 ; unsigned int num_cores_on_die : 6 ; } split ; u32 full ; } ;

union _cpuid4_leaf_ebx { struct { unsigned int coherency_line_size : 12 ; unsigned int physical_line_partition : 10 ; unsigned int ways_of_associativity : 10 ; } split ; u32 full ; } ;

union _cpuid4_leaf_ecx { struct { unsigned int number_of_sets : 32 ; } split ; u32 full ; } ;

struct _cpuid4_info { union _cpuid4_leaf_eax eax ; union _cpuid4_leaf_ebx ebx ; union _cpuid4_leaf_ecx ecx ; unsigned long size ; bool can_disable ; unsigned int l3_indices ; unsigned long shared_cpu_map [ ( ( ( 64 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;

struct _cpuid4_info_regs { union _cpuid4_leaf_eax eax ; union _cpuid4_leaf_ebx ebx ; union _cpuid4_leaf_ecx ecx ; unsigned long size ; bool can_disable ; unsigned int l3_indices ; } ;

union l1_cache { struct { unsigned line_size : 8 ; unsigned lines_per_tag : 8 ; unsigned assoc : 8 ; unsigned size_in_kb : 8 ; } ; unsigned val ; } ;

union l2_cache { struct { unsigned line_size : 8 ; unsigned lines_per_tag : 4 ; unsigned assoc : 4 ; unsigned size_in_kb : 16 ; } ; unsigned val ; } ;

union l3_cache { struct { unsigned line_size : 8 ; unsigned lines_per_tag : 4 ; unsigned assoc : 4 ; unsigned res : 2 ; unsigned size_encoded : 14 ; } ; unsigned val ; } ;

struct _cache_attr { struct attribute attr ; ssize_t ( * show ) ( struct _cpuid4_info * , char * ) ; ssize_t ( * store ) ( struct _cpuid4_info * , const char * , size_t count ) ; } ;

unsigned int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) init_intel_cacheinfo ( struct cpuinfo_x86 * c ) ;

struct _index_kobject { struct kobject kobj ; unsigned int cpu ; unsigned short index ; } ;

struct cpuid_bit { u16 feature ; u8 reg ; u8 bit ; u32 level ; } ;

enum cpuid_regs { CR_EAX = 0 , CR_ECX , CR_EDX , CR_EBX } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) init_scattered_cpuid_features ( struct cpuinfo_x86 * c ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) detect_extended_topology ( struct cpuinfo_x86 * c ) ;

struct async_icount { __u32 cts , dsr , rng , dcd , tx , rx ; __u32 frame , parity , overrun , brk ; __u32 buf_overrun ; } ;

struct serial_struct { int type ; int line ; unsigned int port ; int irq ; int flags ; int xmit_fifo_size ; int custom_divisor ; int baud_base ; unsigned short close_delay ; char io_type ; char reserved_char [ 1 ] ; int hub6 ; unsigned short closing_wait ; unsigned short closing_wait2 ; unsigned char * iomem_base ; unsigned short iomem_reg_shift ; unsigned int port_high ; unsigned long iomap_base ; } ;

struct serial_uart_config { char * name ; int dfl_xmit_fifo_size ; int flags ; } ;

struct serial_multiport_struct { int irq ; int port1 ; unsigned char mask1 , match1 ; int port2 ; unsigned char mask2 , match2 ; int port3 ; unsigned char mask3 , match3 ; int port4 ; unsigned char mask4 , match4 ; int port_monitor ; int reserved [ 32 ] ; } ;

struct serial_icounter_struct { int cts , dsr , rng , dcd ; int rx , tx ; int frame , overrun , parity , brk ; int buf_overrun ; int reserved [ 9 ] ; } ;

struct serial_rs485 { __u32 flags ; __u32 delay_rts_before_send ; __u32 padding [ 6 ] ; } ;

struct circ_buf { char * buf ; int head ; int tail ; } ;

struct sysrq_key_op { void ( * handler ) ( int , struct tty_struct * ) ; char * help_msg ; char * action_msg ; int enable_mask ; } ;

struct uart_port ;

struct serial_struct ;
struct uart_ops { unsigned int ( * tx_empty ) ( struct uart_port * ) ; void ( * set_mctrl ) ( struct uart_port * , unsigned int mctrl ) ; unsigned int ( * get_mctrl ) ( struct uart_port * ) ; void ( * stop_tx ) ( struct uart_port * ) ; void ( * start_tx ) ( struct uart_port * ) ; void ( * send_xchar ) ( struct uart_port * , char ch ) ; void ( * stop_rx ) ( struct uart_port * ) ; void ( * enable_ms ) ( struct uart_port * ) ; void ( * break_ctl ) ( struct uart_port * , int ctl ) ; int ( * startup ) ( struct uart_port * ) ; void ( * shutdown ) ( struct uart_port * ) ; void ( * flush_buffer ) ( struct uart_port * ) ; void ( * set_termios ) ( struct uart_port * , struct ktermios * new , struct ktermios * old ) ; void ( * set_ldisc ) ( struct uart_port * ) ; void ( * pm ) ( struct uart_port * , unsigned int state , unsigned int oldstate ) ; int ( * set_wake ) ( struct uart_port * , unsigned int state ) ; const char * ( * type ) ( struct uart_port * ) ; void ( * release_port ) ( struct uart_port * ) ; int ( * request_port ) ( struct uart_port * ) ; void ( * config_port ) ( struct uart_port * , int ) ; int ( * verify_port ) ( struct uart_port * , struct serial_struct * ) ; int ( * ioctl ) ( struct uart_port * , unsigned int , unsigned long ) ; void ( * poll_put_char ) ( struct uart_port * , unsigned char ) ; int ( * poll_get_char ) ( struct uart_port * ) ; } ;

struct uart_icount { __u32 cts ; __u32 dsr ; __u32 rng ; __u32 dcd ; __u32 rx ; __u32 tx ; __u32 frame ; __u32 overrun ; __u32 parity ; __u32 brk ; __u32 buf_overrun ; } ;

typedef unsigned int upf_t ;

struct uart_port { spinlock_t lock ; unsigned long iobase ; unsigned char * membase ; unsigned int ( * serial_in ) ( struct uart_port * , int ) ; void ( * serial_out ) ( struct uart_port * , int , int ) ; unsigned int irq ; unsigned long irqflags ; unsigned int uartclk ; unsigned int fifosize ; unsigned char x_char ; unsigned char regshift ; unsigned char iotype ; unsigned char unused1 ; unsigned int read_status_mask ; unsigned int ignore_status_mask ; struct uart_state * state ; struct uart_icount icount ; struct console * cons ; unsigned long sysrq ; upf_t flags ; unsigned int mctrl ; unsigned int timeout ; unsigned int type ; const struct uart_ops * ops ; unsigned int custom_divisor ; unsigned int line ; resource_size_t mapbase ; struct device * dev ; unsigned char hub6 ; unsigned char suspended ; unsigned char unused [ 2 ] ; void * private_data ; } ;
struct uart_state { struct tty_port port ; int pm_state ; struct circ_buf xmit ; struct tasklet_struct tlet ; struct uart_port * uart_port ; } ;

struct uart_driver { struct module * owner ; const char * driver_name ; const char * dev_name ; int major ; int minor ; int nr ; struct console * cons ; struct uart_state * state ; struct tty_driver * tty_driver ; } ;

struct plat_serial8250_port { unsigned long iobase ; void * membase ; resource_size_t mapbase ; unsigned int irq ; unsigned long irqflags ; unsigned int uartclk ; void * private_data ; unsigned char regshift ; unsigned char iotype ; unsigned char hub6 ; upf_t flags ; unsigned int type ; unsigned int ( * serial_in ) ( struct uart_port * , int ) ; void ( * serial_out ) ( struct uart_port * , int , int ) ; } ;

enum { PLAT8250_DEV_LEGACY = - 1 , PLAT8250_DEV_PLATFORM , PLAT8250_DEV_PLATFORM1 , PLAT8250_DEV_PLATFORM2 , PLAT8250_DEV_FOURPORT , PLAT8250_DEV_ACCENT , PLAT8250_DEV_BOCA , PLAT8250_DEV_EXAR_ST16C554 , PLAT8250_DEV_HUB6 , PLAT8250_DEV_MCA , PLAT8250_DEV_AU1X00 , PLAT8250_DEV_SM501 , } ;
enum regnames64 { GDB_AX , GDB_BX , GDB_CX , GDB_DX , GDB_SI , GDB_DI , GDB_BP , GDB_SP , GDB_R8 , GDB_R9 , GDB_R10 , GDB_R11 , GDB_R12 , GDB_R13 , GDB_R14 , GDB_R15 , GDB_PC , } ;

enum regnames32 { GDB_PS = 34 , GDB_CS , GDB_SS , } ;

struct tasklet_struct ;
enum kgdb_bptype { BP_BREAKPOINT = 0 , BP_HARDWARE_BREAKPOINT , BP_WRITE_WATCHPOINT , BP_READ_WATCHPOINT , BP_ACCESS_WATCHPOINT } ;

enum kgdb_bpstate { BP_UNDEFINED = 0 , BP_REMOVED , BP_SET , BP_ACTIVE } ;

struct kgdb_bkpt { unsigned long bpt_addr ; unsigned char saved_instr [ 1 ] ; enum kgdb_bptype type ; enum kgdb_bpstate state ; } ;

struct kgdb_arch { unsigned char gdb_bpt_instr [ 1 ] ; unsigned long flags ; int ( * set_breakpoint ) ( unsigned long , char * ) ; int ( * remove_breakpoint ) ( unsigned long , char * ) ; int ( * set_hw_breakpoint ) ( unsigned long , int , enum kgdb_bptype ) ; int ( * remove_hw_breakpoint ) ( unsigned long , int , enum kgdb_bptype ) ; void ( * remove_all_hw_break ) ( void ) ; void ( * correct_hw_break ) ( void ) ; } ;

struct kgdb_io { const char * name ; int ( * read_char ) ( void ) ; void ( * write_char ) ( u8 ) ; void ( * flush ) ( void ) ; int ( * init ) ( void ) ; void ( * pre_exception ) ( void ) ; void ( * post_exception ) ( void ) ; } ;

enum uv_system_type { UV_NONE , UV_LEGACY_APIC , UV_X2APIC , UV_NON_UNIQUE_APIC } ;

struct cpu_model_info { int vendor ; int family ; const char * model_names [ 16 ] ; } ;

struct cpu_dev { const char * c_vendor ; const char * c_ident [ 2 ] ; struct cpu_model_info c_models [ 4 ] ; void ( * c_early_init ) ( struct cpuinfo_x86 * ) ; void ( * c_init ) ( struct cpuinfo_x86 * ) ; void ( * c_identify ) ( struct cpuinfo_x86 * ) ; unsigned int ( * c_size_cache ) ( struct cpuinfo_x86 * , unsigned int ) ; int c_x86_vendor ; } ;

struct dynamorio_page { char padding [ ( ( 1UL ) << 12 ) ] ; } __attribute__ ( ( packed ) ) ;
void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_cpu_local_masks ( void ) ;

struct cpuid_dependent_feature { u32 feature ; u32 level ; } ;

void load_percpu_segment ( int cpu ) ;

void switch_to_new_gdt ( int cpu ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) display_cacheinfo ( struct cpuinfo_x86 * c ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) detect_ht ( struct cpuinfo_x86 * c ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) cpu_detect ( struct cpuinfo_x86 * c ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_cpu_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) identify_boot_cpu ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) identify_secondary_cpu ( struct cpuinfo_x86 * c ) ;

struct msr_range { unsigned min ; unsigned max ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) print_cpu_info ( struct cpuinfo_x86 * c ) ;

void syscall_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) cpu_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) vmware_platform_setup ( void ) ;

int vmware_platform ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmware_set_feature_bits ( struct cpuinfo_x86 * c ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) init_hypervisor ( struct cpuinfo_x86 * c ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_hypervisor_platform ( void ) ;

unsigned long arch_scale_freq_power ( struct sched_domain * sd , int cpu ) ;

unsigned long arch_scale_smt_power ( struct sched_domain * sd , int cpu ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) check_bugs ( void ) ;

int amd_get_nb_id ( int cpu ) ;

enum { ECX8 = 1 << 1 , EIERRINT = 1 << 2 , DPM = 1 << 3 , DMCE = 1 << 4 , DSTPCLK = 1 << 5 , ELINEAR = 1 << 6 , DSMC = 1 << 7 , DTLOCK = 1 << 8 , EDCTLB = 1 << 8 , EMMX = 1 << 9 , DPDC = 1 << 11 , EBRPRED = 1 << 12 , DIC = 1 << 13 , DDC = 1 << 14 , DNA = 1 << 15 , ERETSTK = 1 << 16 , E2MMX = 1 << 19 , EAMD3D = 1 << 20 , } ;
struct debug_store { u64 bts_buffer_base ; u64 bts_index ; u64 bts_absolute_maximum ; u64 bts_interrupt_threshold ; u64 pebs_buffer_base ; u64 pebs_index ; u64 pebs_absolute_maximum ; u64 pebs_interrupt_threshold ; u64 pebs_event_reset [ 4 ] ; } ;

struct cpu_hw_events { struct perf_event * events [ 64 ] ; unsigned long used_mask [ ( ( ( 64 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long active_mask [ ( ( ( 64 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long interrupts ; int enabled ; struct debug_store * ds ; } ;

struct x86_pmu { const char * name ; int version ; int ( * handle_irq ) ( struct pt_regs * ) ; void ( * disable_all ) ( void ) ; void ( * enable_all ) ( void ) ; void ( * enable ) ( struct hw_perf_event * , int ) ; void ( * disable ) ( struct hw_perf_event * , int ) ; unsigned eventsel ; unsigned perfctr ; u64 ( * event_map ) ( int ) ; u64 ( * raw_event ) ( u64 ) ; int max_events ; int num_events ; int num_events_fixed ; int event_bits ; u64 event_mask ; int apic ; u64 max_period ; u64 intel_ctrl ; void ( * enable_bts ) ( u64 config ) ; void ( * disable_bts ) ( void ) ; } ;

void hw_perf_disable ( void ) ;

void hw_perf_enable ( void ) ;

void perf_event_print_debug ( void ) ;

void smp_perf_pending_interrupt ( struct pt_regs * regs ) ;

void set_perf_event_pending ( void ) ;

void perf_events_lapic_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_hw_perf_events ( void ) ;

const struct pmu * hw_perf_event_init ( struct perf_event * event ) ;

struct perf_callchain_entry * perf_callchain ( struct pt_regs * regs ) ;

void hw_perf_event_setup_online ( int cpu ) ;

enum pstate { HW_PSTATE_INVALID = 0xff , HW_PSTATE_0 = 0 , HW_PSTATE_1 = 1 , HW_PSTATE_2 = 2 , HW_PSTATE_3 = 3 , HW_PSTATE_4 = 4 , HW_PSTATE_5 = 5 , HW_PSTATE_6 = 6 , HW_PSTATE_7 = 7 , } ;

struct powernow_k8_data { unsigned int cpu ; u32 numps ; u32 batps ; u32 max_hw_pstate ; u32 rvo ; u32 irt ; u32 vidmvs ; u32 vstable ; u32 plllock ; u32 exttype ; u32 currvid ; u32 currfid ; enum pstate currpstate ; struct cpufreq_frequency_table * powernow_table ; struct acpi_processor_performance acpi_data ; struct cpumask * available_cores ; } ;

struct psb_s { u8 signature [ 10 ] ; u8 tableversion ; u8 flags1 ; u16 vstable ; u8 flags2 ; u8 num_tables ; u32 cpuid ; u8 plllocktime ; u8 maxfid ; u8 maxvid ; u8 numps ; } ;

struct pst_s { u8 fid ; u8 vid ; } ;

struct init_on_cpu { struct powernow_k8_data * data ; int rc ; } ;

; ; ; enum { UNDEFINED_CAPABLE = 0 , SYSTEM_INTEL_MSR_CAPABLE , SYSTEM_IO_CAPABLE , } ;
struct acpi_cpufreq_data { struct acpi_processor_performance * acpi_data ; struct cpufreq_frequency_table * freq_table ; unsigned int resume ; unsigned int cpu_feature ; } ;

struct msr_addr { u32 reg ; } ;

struct io_addr { u16 port ; u8 bit_width ; } ;

struct drv_cmd { unsigned int type ; const struct cpumask * mask ; union { struct msr_addr msr ; struct io_addr io ; } addr ; u32 val ; } ;

struct cpu_id { __u8 x86 ; __u8 x86_model ; __u8 x86_mask ; } ;

enum { CPU_BANIAS , CPU_DOTHAN_A1 , CPU_DOTHAN_A2 , CPU_DOTHAN_B0 , CPU_DOTHAN_C0 , CPU_MP4HT_D0 , CPU_MP4HT_E0 , } ;
struct cpu_model { const struct cpu_id * cpu_id ; const char * model_name ; unsigned max_freq ; struct cpufreq_frequency_table * op_points ; } ;

struct miscdevice { int minor ; const char * name ; const struct file_operations * fops ; struct list_head list ; struct device * parent ; struct device * this_device ; const char * nodename ; mode_t mode ; } ;

enum severity_level { MCE_NO_SEVERITY , MCE_KEEP_SEVERITY , MCE_SOME_SEVERITY , MCE_AO_SEVERITY , MCE_UC_SEVERITY , MCE_AR_SEVERITY , MCE_PANIC_SEVERITY , } ;

struct mce_bank { u64 ctl ; unsigned char init ; struct sysdev_attribute attr ; char attrname [ 16 ] ; } ;

void mce_setup ( struct mce * m ) ;

void mce_log ( struct mce * mce ) ;
struct mce_ring { unsigned short start ; unsigned short end ; unsigned long ring [ 16 ] ; } ;

int mce_available ( struct cpuinfo_x86 * c ) ;

void smp_mce_self_interrupt ( struct pt_regs * regs ) ;

void machine_check_poll ( enum mcp_flags flags , mce_banks_t * b ) ;

void do_machine_check ( struct pt_regs * regs , long error_code ) ;

void __attribute__ ( ( weak ) ) memory_failure ( unsigned long pfn , int vector ) ;

void mce_notify_process ( void ) ;

void mce_log_therm_throt_event ( __u64 status ) ;

int mce_notify_irq ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) mcheck_init ( struct cpuinfo_x86 * c ) ;

struct dentry * mce_get_debugfs_dir ( void ) ;

enum context { IN_KERNEL = 1 , IN_USER = 2 } ;

enum ser { SER_REQUIRED = 1 , NO_SER = 2 } ;


int mce_severity ( struct mce * a , int tolerant , char * * msg ) ;

void cmci_recheck ( void ) ;

void cmci_clear ( void ) ;

void cmci_rediscover ( int dying ) ;

void cmci_reenable ( void ) ;

void mce_intel_feature_init ( struct cpuinfo_x86 * c ) ;

struct threshold_block { unsigned int block ; unsigned int bank ; unsigned int cpu ; u32 address ; u16 interrupt_enable ; u16 threshold_limit ; struct kobject kobj ; struct list_head miscj ; } ;

struct threshold_bank { struct kobject * kobj ; struct threshold_block * blocks ; cpumask_var_t cpus ; } ;

struct thresh_restart { struct threshold_block * b ; int reset ; u16 old_limit ; } ;

void mce_amd_feature_init ( struct cpuinfo_x86 * c ) ;

struct threshold_attr { struct attribute attr ; ssize_t ( * show ) ( struct threshold_block * , char * ) ; ssize_t ( * store ) ( struct threshold_block * , const char * , size_t count ) ; } ;

struct threshold_block_cross_cpu { struct threshold_block * tb ; long retval ; } ;

void smp_threshold_interrupt ( void ) ;
struct thermal_state { bool is_throttled ; u64 next_check ; unsigned long throttle_count ; unsigned long last_throttle_count ; } ;

void smp_thermal_interrupt ( struct pt_regs * regs ) ;
void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mcheck_intel_therm_init ( void ) ;

void intel_init_thermal ( struct cpuinfo_x86 * c ) ;

struct mtrr_ops { u32 vendor ; u32 use_intel_if ; void ( * set ) ( unsigned int reg , unsigned long base , unsigned long size , mtrr_type type ) ; void ( * set_all ) ( void ) ; void ( * get ) ( unsigned int reg , unsigned long * base , unsigned long * size , mtrr_type * type ) ; int ( * get_free_region ) ( unsigned long base , unsigned long size , int replace_reg ) ; int ( * validate_add_page ) ( unsigned long base , unsigned long size , unsigned int type ) ; int ( * have_wrcomb ) ( void ) ; } ;

struct set_mtrr_context { unsigned long flags ; unsigned long cr4val ; u32 deftype_lo ; u32 deftype_hi ; u32 ccr3 ; } ;

void set_mtrr_ops ( struct mtrr_ops * ops ) ;

struct set_mtrr_data { atomic_t count ; atomic_t gate ; unsigned long smp_base ; unsigned long smp_size ; unsigned int smp_reg ; mtrr_type smp_type ; } ;

int mtrr_add_page ( unsigned long base , unsigned long size , unsigned int type , bool increment ) ;

int mtrr_add ( unsigned long base , unsigned long size , unsigned int type , bool increment ) ;

int mtrr_del_page ( int reg , unsigned long base , unsigned long size ) ;

int mtrr_del ( int reg , unsigned long base , unsigned long size ) ;

struct mtrr_value { mtrr_type ltype ; unsigned long lbase ; unsigned long lsize ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mtrr_bp_init ( void ) ;

void mtrr_ap_init ( void ) ;

void mtrr_save_state ( void ) ;

void set_mtrr_aps_delayed_init ( void ) ;

void mtrr_aps_init ( void ) ;

void mtrr_bp_restore ( void ) ;

const char * mtrr_attrib_to_str ( int x ) ;

struct fixed_range_block { int base_msr ; int ranges ; } ;

u8 mtrr_type_lookup ( u64 start , u64 end ) ;

void fill_mtrr_var_range ( unsigned int index , u32 base_lo , u32 base_hi , u32 mask_lo , u32 mask_hi ) ;

void mtrr_save_fixed_ranges ( void * info ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) get_mtrr_state ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mtrr_state_warn ( void ) ;

void mtrr_wrmsr ( unsigned msr , unsigned a , unsigned b ) ;

int generic_get_free_region ( unsigned long base , unsigned long size , int replace_reg ) ;

int generic_validate_add_page ( unsigned long base , unsigned long size , unsigned int type ) ;

int positive_have_wrcomb ( void ) ;

void set_mtrr_prepare_save ( struct set_mtrr_context * ctxt ) ;

void set_mtrr_cache_disable ( struct set_mtrr_context * ctxt ) ;

void set_mtrr_done ( struct set_mtrr_context * ctxt ) ;

struct res_range { unsigned long start ; unsigned long end ; } ;

struct var_mtrr_range_state { unsigned long base_pfn ; unsigned long size_pfn ; mtrr_type type ; } ;

struct var_mtrr_state { unsigned long range_startk ; unsigned long range_sizek ; unsigned long chunk_sizek ; unsigned long gran_sizek ; unsigned int reg ; } ;

struct mtrr_cleanup_result { unsigned long gran_sizek ; unsigned long chunk_sizek ; unsigned long lose_cover_sizek ; unsigned int num_reg ; int bad ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mtrr_cleanup ( unsigned address_bits ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) amd_special_default_mtrr ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mtrr_trim_uncached_memory ( unsigned long end_pfn ) ;

struct nmi_watchdog_ctlblk { unsigned int cccr_msr ; unsigned int perfctr_msr ; unsigned int evntsel_msr ; } ;

struct wd_ops { int ( * reserve ) ( void ) ; void ( * unreserve ) ( void ) ; int ( * setup ) ( unsigned nmi_hz ) ; void ( * rearm ) ( struct nmi_watchdog_ctlblk * wd , unsigned nmi_hz ) ; void ( * stop ) ( void ) ; unsigned perfctr ; unsigned evntsel ; u64 checkbit ; } ;

int avail_to_resrv_perfctr_nmi_bit ( unsigned int counter ) ;

int avail_to_resrv_perfctr_nmi ( unsigned int msr ) ;

int reserve_perfctr_nmi ( unsigned int msr ) ;

void release_perfctr_nmi ( unsigned int msr ) ;

int reserve_evntsel_nmi ( unsigned int msr ) ;

void release_evntsel_nmi ( unsigned int msr ) ;

void disable_lapic_nmi_watchdog ( void ) ;

void enable_lapic_nmi_watchdog ( void ) ;

int lapic_watchdog_init ( unsigned nmi_hz ) ;

void lapic_watchdog_stop ( void ) ;

unsigned lapic_adjust_nmi_hz ( unsigned hz ) ;

int __attribute__ ( ( __section__ ( ) ) ) lapic_wd_event ( unsigned nmi_hz ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mp_sfi_register_lapic_address ( unsigned long address ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) mp_sfi_register_lapic ( u8 id ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sfi_platform_init ( void ) ;

enum reboot_type { BOOT_TRIPLE = 't' , BOOT_KBD = 'k' , BOOT_ACPI = 'a' , BOOT_EFI = 'e' , BOOT_CF9 = 'p' , BOOT_CF9_COND = 'q' , } ;

struct machine_ops { void ( * restart ) ( char * cmd ) ; void ( * halt ) ( void ) ; void ( * power_off ) ( void ) ; void ( * shutdown ) ( void ) ; void ( * crash_shutdown ) ( struct pt_regs * ) ; void ( * emergency_restart ) ( void ) ; } ;

typedef void ( * nmi_shootdown_cb ) ( int , struct die_args * ) ;

enum pci_bf_sort_state { pci_bf_sort_default , pci_force_nobf , pci_force_bf , pci_dmi_bf , } ;

struct irq_info { u8 bus , devfn ; struct { u8 link ; u16 bitmap ; } __attribute__ ( ( packed ) ) irq [ 4 ] ; u8 slot ; u8 rfu ; } __attribute__ ( ( packed ) ) ;
struct irq_routing_table { u32 signature ; u16 version ; u16 size ; u8 rtr_bus , rtr_devfn ; u16 exclusive_irqs ; u16 rtr_vendor , rtr_device ; u32 miniport_data ; u8 rfu [ 11 ] ; u8 checksum ; struct irq_info slots [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct pci_raw_ops { int ( * read ) ( unsigned int domain , unsigned int bus , unsigned int devfn , int reg , int len , u32 * val ) ; int ( * write ) ( unsigned int domain , unsigned int bus , unsigned int devfn , int reg , int len , u32 val ) ; } ;

enum vmcs_field { VIRTUAL_PROCESSOR_ID = 0x00000000 , GUEST_ES_SELECTOR = 0x00000800 , GUEST_CS_SELECTOR = 0x00000802 , GUEST_SS_SELECTOR = 0x00000804 , GUEST_DS_SELECTOR = 0x00000806 , GUEST_FS_SELECTOR = 0x00000808 , GUEST_GS_SELECTOR = 0x0000080a , GUEST_LDTR_SELECTOR = 0x0000080c , GUEST_TR_SELECTOR = 0x0000080e , HOST_ES_SELECTOR = 0x00000c00 , HOST_CS_SELECTOR = 0x00000c02 , HOST_SS_SELECTOR = 0x00000c04 , HOST_DS_SELECTOR = 0x00000c06 , HOST_FS_SELECTOR = 0x00000c08 , HOST_GS_SELECTOR = 0x00000c0a , HOST_TR_SELECTOR = 0x00000c0c , IO_BITMAP_A = 0x00002000 , IO_BITMAP_A_HIGH = 0x00002001 , IO_BITMAP_B = 0x00002002 , IO_BITMAP_B_HIGH = 0x00002003 , MSR_BITMAP = 0x00002004 , MSR_BITMAP_HIGH = 0x00002005 , VM_EXIT_MSR_STORE_ADDR = 0x00002006 , VM_EXIT_MSR_STORE_ADDR_HIGH = 0x00002007 , VM_EXIT_MSR_LOAD_ADDR = 0x00002008 , VM_EXIT_MSR_LOAD_ADDR_HIGH = 0x00002009 , VM_ENTRY_MSR_LOAD_ADDR = 0x0000200a , VM_ENTRY_MSR_LOAD_ADDR_HIGH = 0x0000200b , TSC_OFFSET = 0x00002010 , TSC_OFFSET_HIGH = 0x00002011 , VIRTUAL_APIC_PAGE_ADDR = 0x00002012 , VIRTUAL_APIC_PAGE_ADDR_HIGH = 0x00002013 , APIC_ACCESS_ADDR = 0x00002014 , APIC_ACCESS_ADDR_HIGH = 0x00002015 , EPT_POINTER = 0x0000201a , EPT_POINTER_HIGH = 0x0000201b , GUEST_PHYSICAL_ADDRESS = 0x00002400 , GUEST_PHYSICAL_ADDRESS_HIGH = 0x00002401 , VMCS_LINK_POINTER = 0x00002800 , VMCS_LINK_POINTER_HIGH = 0x00002801 , GUEST_IA32_DEBUGCTL = 0x00002802 , GUEST_IA32_DEBUGCTL_HIGH = 0x00002803 , GUEST_IA32_PAT = 0x00002804 , GUEST_IA32_PAT_HIGH = 0x00002805 , GUEST_PDPTR0 = 0x0000280a , GUEST_PDPTR0_HIGH = 0x0000280b , GUEST_PDPTR1 = 0x0000280c , GUEST_PDPTR1_HIGH = 0x0000280d , GUEST_PDPTR2 = 0x0000280e , GUEST_PDPTR2_HIGH = 0x0000280f , GUEST_PDPTR3 = 0x00002810 , GUEST_PDPTR3_HIGH = 0x00002811 , HOST_IA32_PAT = 0x00002c00 , HOST_IA32_PAT_HIGH = 0x00002c01 , PIN_BASED_VM_EXEC_CONTROL = 0x00004000 , CPU_BASED_VM_EXEC_CONTROL = 0x00004002 , EXCEPTION_BITMAP = 0x00004004 , PAGE_FAULT_ERROR_CODE_MASK = 0x00004006 , PAGE_FAULT_ERROR_CODE_MATCH = 0x00004008 , CR3_TARGET_COUNT = 0x0000400a , VM_EXIT_CONTROLS = 0x0000400c , VM_EXIT_MSR_STORE_COUNT = 0x0000400e , VM_EXIT_MSR_LOAD_COUNT = 0x00004010 , VM_ENTRY_CONTROLS = 0x00004012 , VM_ENTRY_MSR_LOAD_COUNT = 0x00004014 , VM_ENTRY_INTR_INFO_FIELD = 0x00004016 , VM_ENTRY_EXCEPTION_ERROR_CODE = 0x00004018 , VM_ENTRY_INSTRUCTION_LEN = 0x0000401a , TPR_THRESHOLD = 0x0000401c , SECONDARY_VM_EXEC_CONTROL = 0x0000401e , PLE_GAP = 0x00004020 , PLE_WINDOW = 0x00004022 , VM_INSTRUCTION_ERROR = 0x00004400 , VM_EXIT_REASON = 0x00004402 , VM_EXIT_INTR_INFO = 0x00004404 , VM_EXIT_INTR_ERROR_CODE = 0x00004406 , IDT_VECTORING_INFO_FIELD = 0x00004408 , IDT_VECTORING_ERROR_CODE = 0x0000440a , VM_EXIT_INSTRUCTION_LEN = 0x0000440c , VMX_INSTRUCTION_INFO = 0x0000440e , GUEST_ES_LIMIT = 0x00004800 , GUEST_CS_LIMIT = 0x00004802 , GUEST_SS_LIMIT = 0x00004804 , GUEST_DS_LIMIT = 0x00004806 , GUEST_FS_LIMIT = 0x00004808 , GUEST_GS_LIMIT = 0x0000480a , GUEST_LDTR_LIMIT = 0x0000480c , GUEST_TR_LIMIT = 0x0000480e , GUEST_GDTR_LIMIT = 0x00004810 , GUEST_IDTR_LIMIT = 0x00004812 , GUEST_ES_AR_BYTES = 0x00004814 , GUEST_CS_AR_BYTES = 0x00004816 , GUEST_SS_AR_BYTES = 0x00004818 , GUEST_DS_AR_BYTES = 0x0000481a , GUEST_FS_AR_BYTES = 0x0000481c , GUEST_GS_AR_BYTES = 0x0000481e , GUEST_LDTR_AR_BYTES = 0x00004820 , GUEST_TR_AR_BYTES = 0x00004822 , GUEST_INTERRUPTIBILITY_INFO = 0x00004824 , GUEST_ACTIVITY_STATE = 0X00004826 , GUEST_SYSENTER_CS = 0x0000482A , HOST_IA32_SYSENTER_CS = 0x00004c00 , CR0_GUEST_HOST_MASK = 0x00006000 , CR4_GUEST_HOST_MASK = 0x00006002 , CR0_READ_SHADOW = 0x00006004 , CR4_READ_SHADOW = 0x00006006 , CR3_TARGET_VALUE0 = 0x00006008 , CR3_TARGET_VALUE1 = 0x0000600a , CR3_TARGET_VALUE2 = 0x0000600c , CR3_TARGET_VALUE3 = 0x0000600e , EXIT_QUALIFICATION = 0x00006400 , GUEST_LINEAR_ADDRESS = 0x0000640a , GUEST_CR0 = 0x00006800 , GUEST_CR3 = 0x00006802 , GUEST_CR4 = 0x00006804 , GUEST_ES_BASE = 0x00006806 , GUEST_CS_BASE = 0x00006808 , GUEST_SS_BASE = 0x0000680a , GUEST_DS_BASE = 0x0000680c , GUEST_FS_BASE = 0x0000680e , GUEST_GS_BASE = 0x00006810 , GUEST_LDTR_BASE = 0x00006812 , GUEST_TR_BASE = 0x00006814 , GUEST_GDTR_BASE = 0x00006816 , GUEST_IDTR_BASE = 0x00006818 , GUEST_DR7 = 0x0000681a , GUEST_RSP = 0x0000681c , GUEST_RIP = 0x0000681e , GUEST_RFLAGS = 0x00006820 , GUEST_PENDING_DBG_EXCEPTIONS = 0x00006822 , GUEST_SYSENTER_ESP = 0x00006824 , GUEST_SYSENTER_EIP = 0x00006826 , HOST_CR0 = 0x00006c00 , HOST_CR3 = 0x00006c02 , HOST_CR4 = 0x00006c04 , HOST_FS_BASE = 0x00006c06 , HOST_GS_BASE = 0x00006c08 , HOST_TR_BASE = 0x00006c0a , HOST_GDTR_BASE = 0x00006c0c , HOST_IDTR_BASE = 0x00006c0e , HOST_IA32_SYSENTER_ESP = 0x00006c10 , HOST_IA32_SYSENTER_EIP = 0x00006c12 , HOST_RSP = 0x00006c14 , HOST_RIP = 0x00006c16 , } ;

enum { INTERCEPT_INTR , INTERCEPT_NMI , INTERCEPT_SMI , INTERCEPT_INIT , INTERCEPT_VINTR , INTERCEPT_SELECTIVE_CR0 , INTERCEPT_STORE_IDTR , INTERCEPT_STORE_GDTR , INTERCEPT_STORE_LDTR , INTERCEPT_STORE_TR , INTERCEPT_LOAD_IDTR , INTERCEPT_LOAD_GDTR , INTERCEPT_LOAD_LDTR , INTERCEPT_LOAD_TR , INTERCEPT_RDTSC , INTERCEPT_RDPMC , INTERCEPT_PUSHF , INTERCEPT_POPF , INTERCEPT_CPUID , INTERCEPT_RSM , INTERCEPT_IRET , INTERCEPT_INTn , INTERCEPT_INVD , INTERCEPT_PAUSE , INTERCEPT_HLT , INTERCEPT_INVLPG , INTERCEPT_INVLPGA , INTERCEPT_IOIO_PROT , INTERCEPT_MSR_PROT , INTERCEPT_TASK_SWITCH , INTERCEPT_FERR_FREEZE , INTERCEPT_SHUTDOWN , INTERCEPT_VMRUN , INTERCEPT_VMMCALL , INTERCEPT_VMLOAD , INTERCEPT_VMSAVE , INTERCEPT_STGI , INTERCEPT_CLGI , INTERCEPT_SKINIT , INTERCEPT_RDTSCP , INTERCEPT_ICEBP , INTERCEPT_WBINVD , INTERCEPT_MONITOR , INTERCEPT_MWAIT , INTERCEPT_MWAIT_COND , } ;
struct __attribute__ ( ( __packed__ ) ) vmcb_control_area { u16 intercept_cr_read ; u16 intercept_cr_write ; u16 intercept_dr_read ; u16 intercept_dr_write ; u32 intercept_exceptions ; u64 intercept ; u8 reserved_1 [ 44 ] ; u64 iopm_base_pa ; u64 msrpm_base_pa ; u64 tsc_offset ; u32 asid ; u8 tlb_ctl ; u8 reserved_2 [ 3 ] ; u32 int_ctl ; u32 int_vector ; u32 int_state ; u8 reserved_3 [ 4 ] ; u32 exit_code ; u32 exit_code_hi ; u64 exit_info_1 ; u64 exit_info_2 ; u32 exit_int_info ; u32 exit_int_info_err ; u64 nested_ctl ; u8 reserved_4 [ 16 ] ; u32 event_inj ; u32 event_inj_err ; u64 nested_cr3 ; u64 lbr_ctl ; u8 reserved_5 [ 832 ] ; } ;

struct __attribute__ ( ( __packed__ ) ) vmcb_seg { u16 selector ; u16 attrib ; u32 limit ; u64 base ; } ;

struct __attribute__ ( ( __packed__ ) ) vmcb_save_area { struct vmcb_seg es ; struct vmcb_seg cs ; struct vmcb_seg ss ; struct vmcb_seg ds ; struct vmcb_seg fs ; struct vmcb_seg gs ; struct vmcb_seg gdtr ; struct vmcb_seg ldtr ; struct vmcb_seg idtr ; struct vmcb_seg tr ; u8 reserved_1 [ 43 ] ; u8 cpl ; u8 reserved_2 [ 4 ] ; u64 efer ; u8 reserved_3 [ 112 ] ; u64 cr4 ; u64 cr3 ; u64 cr0 ; u64 dr7 ; u64 dr6 ; u64 rflags ; u64 rip ; u8 reserved_4 [ 88 ] ; u64 rsp ; u8 reserved_5 [ 24 ] ; u64 rax ; u64 star ; u64 lstar ; u64 cstar ; u64 sfmask ; u64 kernel_gs_base ; u64 sysenter_cs ; u64 sysenter_esp ; u64 sysenter_eip ; u64 cr2 ; u8 reserved_6 [ 32 ] ; u64 g_pat ; u64 dbgctl ; u64 br_from ; u64 br_to ; u64 last_excp_from ; u64 last_excp_to ; } ;

struct __attribute__ ( ( __packed__ ) ) vmcb { struct vmcb_control_area control ; struct vmcb_save_area save ; } ;

void __attribute__ ( ( weak ) ) mach_reboot_fixups ( void ) ;

void native_machine_shutdown ( void ) ;

void machine_power_off ( void ) ;

void machine_shutdown ( void ) ;

void machine_emergency_restart ( void ) ;

void machine_restart ( char * cmd ) ;

void machine_halt ( void ) ;

void machine_crash_shutdown ( struct pt_regs * regs ) ;

void nmi_shootdown_cpus ( nmi_shootdown_cb callback ) ;

struct chipset { u32 vendor ; u32 device ; u32 class ; u32 class_mask ; u32 flags ; void ( * f ) ( int num , int slot , int func ) ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_quirks ( void ) ;

void native_send_call_func_single_ipi ( int cpu ) ;

void native_send_call_func_ipi ( const struct cpumask * mask ) ;

void smp_reboot_interrupt ( void ) ;

void smp_reschedule_interrupt ( struct pt_regs * regs ) ;

void smp_call_function_interrupt ( struct pt_regs * regs ) ;

void smp_call_function_single_interrupt ( struct pt_regs * regs ) ;

void cpu_hotplug_driver_lock ( ) ;

void cpu_hotplug_driver_unlock ( ) ;

ssize_t arch_cpu_probe ( const char * buf , size_t count ) ;

ssize_t arch_cpu_release ( const char * buf , size_t count ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) smp_store_cpu_info ( int id ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) set_cpu_sibling_map ( int cpu ) ;

const struct cpumask * cpu_coregroup_mask ( int cpu ) ;

void __inquire_remote_apic ( int apicid ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) wakeup_secondary_cpu_via_nmi ( int logical_apicid , unsigned long start_eip ) ;

struct create_idle { struct work_struct work ; struct task_struct * idle ; struct completion done ; int cpu ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) native_cpu_up ( unsigned int cpu ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) native_smp_prepare_cpus ( unsigned int max_cpus ) ;

void arch_enable_nonboot_cpus_begin ( void ) ;

void arch_enable_nonboot_cpus_end ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) native_smp_prepare_boot_cpu ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) native_smp_cpus_done ( unsigned int max_cpus ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) void prefill_possible_map ( void ) ;

void cpu_disable_common ( void ) ;

int native_cpu_disable ( void ) ;

void native_cpu_die ( unsigned int cpu ) ;

void play_dead_common ( void ) ;

void native_play_dead ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) check_tsc_sync_source ( int cpu ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) check_tsc_sync_target ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_per_cpu_areas ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) default_mpc_apic_id ( struct mpc_cpu * m ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) default_mpc_oem_bus_info ( struct mpc_bus * m , char * str ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) default_smp_read_mpc_oem ( struct mpc_table * mpc ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) default_get_smp_config ( unsigned int early ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) default_find_smp_config ( unsigned int reserve ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_reserve_e820_mpc_new ( void ) ;

int ftrace_arch_code_modify_prepare ( void ) ;

int ftrace_arch_code_modify_post_process ( void ) ;

union ftrace_code_union { char code [ 5 ] ; struct { char e8 ; int offset ; } __attribute__ ( ( packed ) ) ; } ;

int ftrace_arch_read_dyn_info ( char * buf , int size ) ;

void ftrace_nmi_enter ( void ) ;

void ftrace_nmi_exit ( void ) ;

int ftrace_make_nop ( struct module * mod , struct dyn_ftrace * rec , unsigned long addr ) ;

int ftrace_make_call ( struct dyn_ftrace * rec , unsigned long addr ) ;

int ftrace_update_ftrace_func ( ftrace_func_t func ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ftrace_dyn_arch_init ( void * data ) ;

int ftrace_enable_ftrace_graph_caller ( void ) ;

int ftrace_disable_ftrace_graph_caller ( void ) ;

void prepare_ftrace_return ( unsigned long * parent , unsigned long self_addr , unsigned long frame_pointer ) ;

int machine_kexec_prepare ( struct kimage * image ) ;

void machine_kexec_cleanup ( struct kimage * image ) ;

void machine_kexec ( struct kimage * image ) ;

void arch_crash_save_vmcoreinfo ( void ) ;

void native_machine_crash_shutdown ( struct pt_regs * regs ) ;

ssize_t copy_oldmem_page ( unsigned long pfn , char * buf , size_t csize , unsigned long offset , int userbuf ) ;

int __attribute__ ( ( __section__ ( ) ) ) arch_prepare_kprobe ( struct kprobe * p ) ;

void __attribute__ ( ( __section__ ( ) ) ) arch_arm_kprobe ( struct kprobe * p ) ;

void __attribute__ ( ( __section__ ( ) ) ) arch_disarm_kprobe ( struct kprobe * p ) ;

void __attribute__ ( ( __section__ ( ) ) ) arch_remove_kprobe ( struct kprobe * p ) ;

void __attribute__ ( ( __section__ ( ) ) ) arch_prepare_kretprobe ( struct kretprobe_instance * ri , struct pt_regs * regs ) ;

int __attribute__ ( ( __section__ ( ) ) ) kprobe_fault_handler ( struct pt_regs * regs , int trapnr ) ;

int __attribute__ ( ( __section__ ( ) ) ) kprobe_exceptions_notify ( struct notifier_block * self , unsigned long val , void * data ) ;

int __attribute__ ( ( __section__ ( ) ) ) setjmp_pre_handler ( struct kprobe * p , struct pt_regs * regs ) ;

void __attribute__ ( ( __section__ ( ) ) ) jprobe_return ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) longjmp_break_handler ( struct kprobe * p , struct pt_regs * regs ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) arch_init_kprobes ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) arch_trampoline_kprobe ( struct kprobe * p ) ;

void * module_alloc ( unsigned long size ) ;

void * module_shadow_alloc ( unsigned long size ) ;

void module_free ( struct module * mod , void * module_region ) ;

int module_frob_arch_sections ( Elf64_Ehdr * hdr , Elf64_Shdr * sechdrs , char * secstrings , struct module * mod ) ;

int apply_relocate_add ( Elf64_Shdr * sechdrs , const char * strtab , unsigned int symindex , unsigned int relsec , struct module * me ) ;

int apply_relocate ( Elf64_Shdr * sechdrs , const char * strtab , unsigned int symindex , unsigned int relsec , struct module * me ) ;

int module_finalize ( const Elf64_Ehdr * hdr , const Elf64_Shdr * sechdrs , struct module * me ) ;

void module_arch_cleanup ( struct module * mod ) ;

int efi_set_rtc_mmss ( unsigned long nowtime ) ;

unsigned long efi_get_time ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) efi_reserve_early ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) efi_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) efi_enter_virtual_mode ( void ) ;

u32 efi_mem_type ( unsigned long phys_addr ) ;

u64 efi_mem_attributes ( unsigned long phys_addr ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) efi_call_phys_prelog ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) efi_call_phys_epilog ( void ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) efi_ioremap ( unsigned long phys_addr , unsigned long size , u32 type ) ;

void pt_regs_to_gdb_regs ( unsigned long * gdb_regs , struct pt_regs * regs ) ;

void sleeping_thread_to_gdb_regs ( unsigned long * gdb_regs , struct task_struct * p ) ;

void gdb_regs_to_pt_regs ( unsigned long * gdb_regs , struct pt_regs * regs ) ;


void kgdb_disable_hw_debug ( struct pt_regs * regs ) ;

void kgdb_post_primary_code ( struct pt_regs * regs , int e_vector , int err_code ) ;

void kgdb_roundup_cpus ( unsigned long flags ) ;

int kgdb_arch_handle_exception ( int e_vector , int signo , int err_code , char * remcomInBuffer , char * remcomOutBuffer , struct pt_regs * linux_regs ) ;

int kgdb_arch_init ( void ) ;

void kgdb_arch_exit ( void ) ;

int kgdb_skipexception ( int exception , struct pt_regs * regs ) ;

unsigned long kgdb_arch_pc ( int exception , struct pt_regs * regs ) ;

struct usb_ctrlrequest { __u8 bRequestType ; __u8 bRequest ; __le16 wValue ; __le16 wIndex ; __le16 wLength ; } __attribute__ ( ( packed ) ) ;
struct usb_descriptor_header { __u8 bLength ; __u8 bDescriptorType ; } __attribute__ ( ( packed ) ) ;
struct usb_device_descriptor { __u8 bLength ; __u8 bDescriptorType ; __le16 bcdUSB ; __u8 bDeviceClass ; __u8 bDeviceSubClass ; __u8 bDeviceProtocol ; __u8 bMaxPacketSize0 ; __le16 idVendor ; __le16 idProduct ; __le16 bcdDevice ; __u8 iManufacturer ; __u8 iProduct ; __u8 iSerialNumber ; __u8 bNumConfigurations ; } __attribute__ ( ( packed ) ) ;
struct usb_config_descriptor { __u8 bLength ; __u8 bDescriptorType ; __le16 wTotalLength ; __u8 bNumInterfaces ; __u8 bConfigurationValue ; __u8 iConfiguration ; __u8 bmAttributes ; __u8 bMaxPower ; } __attribute__ ( ( packed ) ) ;
struct usb_string_descriptor { __u8 bLength ; __u8 bDescriptorType ; __le16 wData [ 1 ] ; } __attribute__ ( ( packed ) ) ;
struct usb_interface_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bInterfaceNumber ; __u8 bAlternateSetting ; __u8 bNumEndpoints ; __u8 bInterfaceClass ; __u8 bInterfaceSubClass ; __u8 bInterfaceProtocol ; __u8 iInterface ; } __attribute__ ( ( packed ) ) ;
struct usb_endpoint_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bEndpointAddress ; __u8 bmAttributes ; __le16 wMaxPacketSize ; __u8 bInterval ; __u8 bRefresh ; __u8 bSynchAddress ; } __attribute__ ( ( packed ) ) ;
struct usb_ss_ep_comp_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bMaxBurst ; __u8 bmAttributes ; __u16 wBytesPerInterval ; } __attribute__ ( ( packed ) ) ;
struct usb_qualifier_descriptor { __u8 bLength ; __u8 bDescriptorType ; __le16 bcdUSB ; __u8 bDeviceClass ; __u8 bDeviceSubClass ; __u8 bDeviceProtocol ; __u8 bMaxPacketSize0 ; __u8 bNumConfigurations ; __u8 bRESERVED ; } __attribute__ ( ( packed ) ) ;
struct usb_otg_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bmAttributes ; } __attribute__ ( ( packed ) ) ;
struct usb_debug_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bDebugInEndpoint ; __u8 bDebugOutEndpoint ; } __attribute__ ( ( packed ) ) ;
struct usb_interface_assoc_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bFirstInterface ; __u8 bInterfaceCount ; __u8 bFunctionClass ; __u8 bFunctionSubClass ; __u8 bFunctionProtocol ; __u8 iFunction ; } __attribute__ ( ( packed ) ) ;
struct usb_security_descriptor { __u8 bLength ; __u8 bDescriptorType ; __le16 wTotalLength ; __u8 bNumEncryptionTypes ; } __attribute__ ( ( packed ) ) ;
struct usb_key_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 tTKID [ 3 ] ; __u8 bReserved ; __u8 bKeyData [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct usb_encryption_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bEncryptionType ; __u8 bEncryptionValue ; __u8 bAuthKeyIndex ; } __attribute__ ( ( packed ) ) ;
struct usb_bos_descriptor { __u8 bLength ; __u8 bDescriptorType ; __le16 wTotalLength ; __u8 bNumDeviceCaps ; } __attribute__ ( ( packed ) ) ;
struct usb_dev_cap_header { __u8 bLength ; __u8 bDescriptorType ; __u8 bDevCapabilityType ; } __attribute__ ( ( packed ) ) ;
struct usb_wireless_cap_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bDevCapabilityType ; __u8 bmAttributes ; __le16 wPHYRates ; __u8 bmTFITXPowerInfo ; __u8 bmFFITXPowerInfo ; __le16 bmBandGroup ; __u8 bReserved ; } __attribute__ ( ( packed ) ) ;
struct usb_ext_cap_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bDevCapabilityType ; __u8 bmAttributes ; } __attribute__ ( ( packed ) ) ;
struct usb_wireless_ep_comp_descriptor { __u8 bLength ; __u8 bDescriptorType ; __u8 bMaxBurst ; __u8 bMaxSequence ; __le16 wMaxStreamDelay ; __le16 wOverTheAirPacketSize ; __u8 bOverTheAirInterval ; __u8 bmCompAttributes ; } __attribute__ ( ( packed ) ) ;
struct usb_handshake { __u8 bMessageNumber ; __u8 bStatus ; __u8 tTKID [ 3 ] ; __u8 bReserved ; __u8 CDID [ 16 ] ; __u8 nonce [ 16 ] ; __u8 MIC [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct usb_connection_context { __u8 CHID [ 16 ] ; __u8 CDID [ 16 ] ; __u8 CK [ 16 ] ; } __attribute__ ( ( packed ) ) ;
enum usb_device_speed { USB_SPEED_UNKNOWN = 0 , USB_SPEED_LOW , USB_SPEED_FULL , USB_SPEED_HIGH , USB_SPEED_VARIABLE , USB_SPEED_SUPER , } ;

enum usb_device_state { USB_STATE_NOTATTACHED = 0 , USB_STATE_ATTACHED , USB_STATE_POWERED , USB_STATE_RECONNECTING , USB_STATE_UNAUTHENTICATED , USB_STATE_DEFAULT , USB_STATE_ADDRESS , USB_STATE_CONFIGURED , USB_STATE_SUSPENDED } ;

struct ehci_caps { u32 hc_capbase ; u32 hcs_params ; u32 hcc_params ; u8 portroute [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct ehci_regs { u32 command ; u32 status ; u32 intr_enable ; u32 frame_index ; u32 segment ; u32 frame_list ; u32 async_next ; u32 reserved [ 9 ] ; u32 configured_flag ; u32 port_status [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct ehci_dbg_port { u32 control ; u32 pids ; u32 data03 ; u32 data47 ; u32 address ; } __attribute__ ( ( packed ) ) ;
void early_printk ( const char * fmt , ... ) ;

struct hpet_dev { struct clock_event_device evt ; unsigned int num ; int cpu ; unsigned int irq ; unsigned int flags ; char name [ 10 ] ; } ;

unsigned long hpet_readl ( unsigned long a ) ;

int is_hpet_enabled ( void ) ;

void hpet_msi_unmask ( unsigned int irq ) ;

void hpet_msi_mask ( unsigned int irq ) ;

void hpet_msi_write ( unsigned int irq , struct msi_msg * msg ) ;

void hpet_msi_read ( unsigned int irq , struct msi_msg * msg ) ;

struct hpet_work_struct { struct delayed_work work ; struct completion complete ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) hpet_enable ( void ) ;

void hpet_disable ( void ) ;

int hpet_register_irq_handler ( rtc_irq_handler handler ) ;

void hpet_unregister_irq_handler ( rtc_irq_handler handler ) ;

int hpet_rtc_timer_init ( void ) ;

int hpet_mask_rtc_irq_bit ( unsigned long bit_mask ) ;

int hpet_set_rtc_irq_bit ( unsigned long bit_mask ) ;

int hpet_set_alarm_time ( unsigned char hrs , unsigned char min , unsigned char sec ) ;

int hpet_set_periodic_freq ( unsigned long freq ) ;

int hpet_rtc_dropped_irq ( void ) ;

irqreturn_t hpet_rtc_interrupt ( int irq , void * dev_id ) ;

int cache_k8_northbridges ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_is_k8_nb ( u32 device ) ;

void k8_flush_garts ( void ) ;

struct kvm_para_state { u8 mmu_queue [ 1024 ] ; int mmu_queue_len ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) kvm_guest_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) kvmclock_init ( void ) ;

void _paravirt_nop ( void ) ;

u32 _paravirt_ident_32 ( u32 x ) ;

u64 _paravirt_ident_64 ( u64 x ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) default_banner ( void ) ;

unsigned paravirt_patch_nop ( void ) ;

unsigned paravirt_patch_ignore ( unsigned len ) ;

struct branch { unsigned char opcode ; u32 delta ; } __attribute__ ( ( packed ) ) ;
unsigned paravirt_patch_call ( void * insnbuf , const void * target , u16 tgt_clobbers , unsigned long addr , u16 site_clobbers , unsigned len ) ;

unsigned paravirt_patch_jmp ( void * insnbuf , const void * target , unsigned long addr , unsigned len ) ;

unsigned paravirt_patch_default ( u8 type , u16 clobbers , void * insnbuf , unsigned long addr , unsigned len ) ;

unsigned paravirt_patch_insns ( void * insnbuf , unsigned len , const char * start , const char * end ) ;

int paravirt_disable_iospace ( void ) ;

void paravirt_enter_lazy_mmu ( void ) ;

void paravirt_leave_lazy_mmu ( void ) ;

void paravirt_start_context_switch ( struct task_struct * prev ) ;

void paravirt_end_context_switch ( struct task_struct * next ) ;

enum paravirt_lazy_mode paravirt_get_lazy_mode ( void ) ;

void arch_flush_lazy_mmu_mode ( void ) ;

unsigned paravirt_patch_ident_32 ( void * insnbuf , unsigned len ) ;

unsigned paravirt_patch_ident_64 ( void * insnbuf , unsigned len ) ;

unsigned native_patch ( u8 type , u16 clobbers , void * ibuf , unsigned long addr , unsigned len ) ;

struct pvclock_shadow_time { u64 tsc_timestamp ; u64 system_timestamp ; u32 tsc_to_nsec_mul ; int tsc_shift ; u32 version ; } ;

unsigned long pvclock_tsc_khz ( struct pvclock_vcpu_time_info * src ) ;

cycle_t pvclock_clocksource_read ( struct pvclock_vcpu_time_info * src ) ;

void pvclock_read_wallclock ( struct pvclock_wall_clock * wall_clock , struct pvclock_vcpu_time_info * vcpu_time , struct timespec * ts ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_bios_corruption_check ( void ) ;

void check_for_bios_corruption ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_swiotlb_init ( void ) ;

void pmtimer_wait ( unsigned us ) ;

int audit_classify_arch ( int arch ) ;

int audit_classify_syscall ( int abi , unsigned syscall ) ;

enum chipset_type { NOT_SUPPORTED , SUPPORTED , } ;

struct agp_version { u16 major ; u16 minor ; } ;

struct agp_kern_info { struct agp_version version ; struct pci_dev * device ; enum chipset_type chipset ; unsigned long mode ; unsigned long aper_base ; size_t aper_size ; int max_memory ; int current_memory ; bool cant_use_aperture ; unsigned long page_mask ; const struct vm_operations_struct * vm_ops ; } ;

struct agp_bridge_data ;

struct agp_memory { struct agp_memory * next ; struct agp_memory * prev ; struct agp_bridge_data * bridge ; struct page * * pages ; size_t page_count ; int key ; int num_scratch_pages ; off_t pg_start ; u32 type ; u32 physical ; bool is_bound ; bool is_flushed ; bool vmalloc_flag ; struct list_head mapped_list ; struct scatterlist * sg_list ; int num_sg ; } ;

void set_up_gart_resume ( u32 aper_order , u32 aper_alloc ) ;

void gart_iommu_shutdown ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) gart_iommu_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) gart_parse_options ( char * p ) ;

struct bus_dev_range { int bus ; int dev_base ; int dev_limit ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_gart_iommu_check ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) gart_iommu_hole_init ( void ) ;

struct iommu_table ;
struct rio_table_hdr { u8 version ; u8 num_scal_dev ; u8 num_rio_dev ; } __attribute__ ( ( packed ) ) ;
struct scal_detail { u8 node_id ; u32 CBAR ; u8 port0node ; u8 port0port ; u8 port1node ; u8 port1port ; u8 port2node ; u8 port2port ; u8 chassis_num ; } __attribute__ ( ( packed ) ) ;
struct rio_detail { u8 node_id ; u32 BBAR ; u8 type ; u8 owner_id ; u8 port0node ; u8 port0port ; u8 port1node ; u8 port1port ; u8 first_slot ; u8 status ; u8 WP_index ; u8 chassis_num ; } __attribute__ ( ( packed ) ) ;
enum { HURR_SCALABILTY = 0 , HURR_RIOIB = 2 , COMPAT_CALGARY = 4 , ALT_CALGARY = 5 , } ;
struct calgary_bus_info { void * tce_space ; unsigned char translation_disabled ; signed char phbid ; void * bbar ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) detect_calgary ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) calgary_iommu_init ( void ) ;

void tce_build ( struct iommu_table * tbl , unsigned long index , unsigned int npages , unsigned long uaddr , int direction ) ;

void tce_free ( struct iommu_table * tbl , long index , unsigned int npages ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) build_tce_table ( struct pci_dev * dev , void * bbar ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) alloc_tce_table ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) free_tce_table ( void * tbl ) ;

struct protection_domain { spinlock_t lock ; u16 id ; int mode ; u64 * pt_root ; unsigned long flags ; bool updated ; unsigned dev_cnt ; void * priv ; } ;

struct aperture_range { unsigned long * bitmap ; u64 * pte_pages [ 64 ] ; unsigned long offset ; } ;

struct dma_ops_domain { struct list_head list ; struct protection_domain domain ; unsigned long aperture_size ; unsigned long next_address ; struct aperture_range * aperture [ 32 ] ; bool need_flush ; u16 target_dev ; } ;

struct amd_iommu { struct list_head list ; spinlock_t lock ; struct pci_dev * dev ; u64 mmio_phys ; u8 * mmio_base ; u32 cap ; u16 cap_ptr ; u16 pci_seg ; u16 first_device ; u16 last_device ; u64 exclusion_start ; u64 exclusion_length ; u8 * cmd_buf ; u32 cmd_buf_size ; u32 evt_buf_size ; u8 * evt_buf ; u16 evt_msi_num ; bool int_enabled ; bool need_sync ; bool reset_in_progress ; struct dma_ops_domain * default_dom ; } ;

struct dev_table_entry { u32 data [ 8 ] ; } ;

struct unity_map_entry { struct list_head list ; u16 devid_start ; u16 devid_end ; u64 address_start ; u64 address_end ; int prot ; } ;

struct __iommu_counter { char * name ; struct dentry * dent ; u64 value ; } ;

struct ivhd_header { u8 type ; u8 flags ; u16 length ; u16 devid ; u16 cap_ptr ; u64 mmio_phys ; u16 pci_seg ; u16 info ; u32 reserved ; } __attribute__ ( ( packed ) ) ;
struct ivhd_entry { u8 type ; u16 devid ; u8 flags ; u32 ext ; } __attribute__ ( ( packed ) ) ;
struct ivmd_header { u8 type ; u8 flags ; u16 length ; u16 devid ; u16 aux ; u64 resv ; u64 range_start ; u64 range_length ; } __attribute__ ( ( packed ) ) ;
void amd_iommu_reset_cmd_buffer ( struct amd_iommu * iommu ) ;

void amd_iommu_apply_erratum_63 ( u16 devid ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) amd_iommu_init ( void ) ;

void amd_iommu_shutdown ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) amd_iommu_detect ( void ) ;

struct iommu_domain { void * priv ; } ;

struct iommu_ops { int ( * domain_init ) ( struct iommu_domain * domain ) ; void ( * domain_destroy ) ( struct iommu_domain * domain ) ; int ( * attach_dev ) ( struct iommu_domain * domain , struct device * dev ) ; void ( * detach_dev ) ( struct iommu_domain * domain , struct device * dev ) ; int ( * map ) ( struct iommu_domain * domain , unsigned long iova , phys_addr_t paddr , size_t size , int prot ) ; void ( * unmap ) ( struct iommu_domain * domain , unsigned long iova , size_t size ) ; phys_addr_t ( * iova_to_phys ) ( struct iommu_domain * domain , unsigned long iova ) ; int ( * domain_has_cap ) ( struct iommu_domain * domain , unsigned long cap ) ; } ;

struct iommu_cmd { u32 data [ 4 ] ; } ;

irqreturn_t amd_iommu_int_handler ( int irq , void * data ) ;

void amd_iommu_flush_all_domains ( void ) ;

void amd_iommu_flush_all_devices ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) amd_iommu_init_api ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) amd_iommu_init_dma_ops ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) amd_iommu_init_passthrough ( void ) ;

struct pci_hostbridge_probe { u32 bus ; u32 slot ; u32 vendor ; u32 device ; } ;

struct range { u64 start ; u64 end ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) fam10h_check_enable_mmcfg ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) check_enable_amd_mmconf_dmi ( void ) ;

int is_vsmp_box ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) vsmp_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) x86_64_start_kernel ( char * real_mode_data ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) x86_64_start_reservations ( char * real_mode_data ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_ebda_region ( void ) ;

struct user_namespace { struct kref kref ; struct hlist_head uidhash_table [ ( 1 << ( 0 ? 3 : 8 ) ) ] ; struct user_struct * creator ; struct work_struct destroyer ; } ;
struct mq_attr { long mq_flags ; long mq_maxmsg ; long mq_msgsize ; long mq_curmsgs ; long __reserved [ 4 ] ; } ;
struct kvm_memory_alias { __u32 slot ; __u32 flags ; __u64 guest_phys_addr ; __u64 memory_size ; __u64 target_phys_addr ; } ;

struct kvm_pic_state { __u8 last_irr ; __u8 irr ; __u8 imr ; __u8 isr ; __u8 priority_add ; __u8 irq_base ; __u8 read_reg_select ; __u8 poll ; __u8 special_mask ; __u8 init_state ; __u8 auto_eoi ; __u8 rotate_on_auto_eoi ; __u8 special_fully_nested_mode ; __u8 init4 ; __u8 elcr ; __u8 elcr_mask ; } ;

struct kvm_ioapic_state { __u64 base_address ; __u32 ioregsel ; __u32 id ; __u32 irr ; __u32 pad ; union { __u64 bits ; struct { __u8 vector ; __u8 delivery_mode : 3 ; __u8 dest_mode : 1 ; __u8 delivery_status : 1 ; __u8 polarity : 1 ; __u8 remote_irr : 1 ; __u8 trig_mode : 1 ; __u8 mask : 1 ; __u8 reserve : 7 ; __u8 reserved [ 4 ] ; __u8 dest_id ; } fields ; } redirtbl [ 24 ] ; } ;

struct kvm_regs { __u64 rax , rbx , rcx , rdx ; __u64 rsi , rdi , rsp , rbp ; __u64 r8 , r9 , r10 , r11 ; __u64 r12 , r13 , r14 , r15 ; __u64 rip , rflags ; } ;

struct kvm_lapic_state { char regs [ 0x400 ] ; } ;

struct kvm_segment { __u64 base ; __u32 limit ; __u16 selector ; __u8 type ; __u8 present , dpl , db , s , l , g , avl ; __u8 unusable ; __u8 padding ; } ;

struct kvm_dtable { __u64 base ; __u16 limit ; __u16 padding [ 3 ] ; } ;

struct kvm_sregs { struct kvm_segment cs , ds , es , fs , gs , ss ; struct kvm_segment tr , ldt ; struct kvm_dtable gdt , idt ; __u64 cr0 , cr2 , cr3 , cr4 , cr8 ; __u64 efer ; __u64 apic_base ; __u64 interrupt_bitmap [ ( 256 + 63 ) / 64 ] ; } ;

struct kvm_fpu { __u8 fpr [ 8 ] [ 16 ] ; __u16 fcw ; __u16 fsw ; __u8 ftwx ; __u8 pad1 ; __u16 last_opcode ; __u64 last_ip ; __u64 last_dp ; __u8 xmm [ 16 ] [ 16 ] ; __u32 mxcsr ; __u32 pad2 ; } ;

struct kvm_msr_entry { __u32 index ; __u32 reserved ; __u64 data ; } ;

struct kvm_msrs { __u32 nmsrs ; __u32 pad ; struct kvm_msr_entry entries [ 0 ] ; } ;

struct kvm_msr_list { __u32 nmsrs ; __u32 indices [ 0 ] ; } ;

struct kvm_cpuid_entry { __u32 function ; __u32 eax ; __u32 ebx ; __u32 ecx ; __u32 edx ; __u32 padding ; } ;

struct kvm_cpuid { __u32 nent ; __u32 padding ; struct kvm_cpuid_entry entries [ 0 ] ; } ;

struct kvm_cpuid_entry2 { __u32 function ; __u32 index ; __u32 flags ; __u32 eax ; __u32 ebx ; __u32 ecx ; __u32 edx ; __u32 padding [ 3 ] ; } ;

struct kvm_cpuid2 { __u32 nent ; __u32 padding ; struct kvm_cpuid_entry2 entries [ 0 ] ; } ;

struct kvm_pit_channel_state { __u32 count ; __u16 latched_count ; __u8 count_latched ; __u8 status_latched ; __u8 status ; __u8 read_state ; __u8 write_state ; __u8 write_latch ; __u8 rw_mode ; __u8 mode ; __u8 bcd ; __u8 gate ; __s64 count_load_time ; } ;

struct kvm_debug_exit_arch { __u32 exception ; __u32 pad ; __u64 pc ; __u64 dr6 ; __u64 dr7 ; } ;

struct kvm_guest_debug_arch { __u64 debugreg [ 8 ] ; } ;

struct kvm_pit_state { struct kvm_pit_channel_state channels [ 3 ] ; } ;

struct kvm_pit_state2 { struct kvm_pit_channel_state channels [ 3 ] ; __u32 flags ; __u32 reserved [ 9 ] ; } ;

struct kvm_reinject_control { __u8 pit_reinject ; __u8 reserved [ 31 ] ; } ;

struct kvm_user_trace_setup { __u32 buf_size ; __u32 buf_nr ; } ;

struct kvm_memory_region { __u32 slot ; __u32 flags ; __u64 guest_phys_addr ; __u64 memory_size ; } ;

struct kvm_userspace_memory_region { __u32 slot ; __u32 flags ; __u64 guest_phys_addr ; __u64 memory_size ; __u64 userspace_addr ; } ;

struct kvm_irq_level { union { __u32 irq ; __s32 status ; } ; __u32 level ; } ;

struct kvm_irqchip { __u32 chip_id ; __u32 pad ; union { char dummy [ 512 ] ; struct kvm_pic_state pic ; struct kvm_ioapic_state ioapic ; } chip ; } ;

struct kvm_pit_config { __u32 flags ; __u32 pad [ 15 ] ; } ;

struct kvm_run { __u8 request_interrupt_window ; __u8 padding1 [ 7 ] ; __u32 exit_reason ; __u8 ready_for_interrupt_injection ; __u8 if_flag ; __u8 padding2 [ 2 ] ; __u64 cr8 ; __u64 apic_base ; union { struct { __u64 hardware_exit_reason ; } hw ; struct { __u64 hardware_entry_failure_reason ; } fail_entry ; struct { __u32 exception ; __u32 error_code ; } ex ; struct { __u8 direction ; __u8 size ; __u16 port ; __u32 count ; __u64 data_offset ; } io ; struct { struct kvm_debug_exit_arch arch ; } debug ; struct { __u64 phys_addr ; __u8 data [ 8 ] ; __u32 len ; __u8 is_write ; } mmio ; struct { __u64 nr ; __u64 args [ 6 ] ; __u64 ret ; __u32 longmode ; __u32 pad ; } hypercall ; struct { __u64 rip ; __u32 is_write ; __u32 pad ; } tpr_access ; struct { __u8 icptcode ; __u16 ipa ; __u32 ipb ; } s390_sieic ; __u64 s390_reset_flags ; struct { __u32 dcrn ; __u32 data ; __u8 is_write ; } dcr ; struct { __u32 suberror ; } internal ; char padding [ 256 ] ; } ; } ;

struct kvm_coalesced_mmio_zone { __u64 addr ; __u32 size ; __u32 pad ; } ;

struct kvm_coalesced_mmio { __u64 phys_addr ; __u32 len ; __u32 pad ; __u8 data [ 8 ] ; } ;

struct kvm_coalesced_mmio_ring { __u32 first , last ; struct kvm_coalesced_mmio coalesced_mmio [ 0 ] ; } ;

struct kvm_translation { __u64 linear_address ; __u64 physical_address ; __u8 valid ; __u8 writeable ; __u8 usermode ; __u8 pad [ 5 ] ; } ;

struct kvm_interrupt { __u32 irq ; } ;

struct kvm_dirty_log { __u32 slot ; __u32 padding1 ; union { void * dirty_bitmap ; __u64 padding2 ; } ; } ;

struct kvm_signal_mask { __u32 len ; __u8 sigset [ 0 ] ; } ;

struct kvm_tpr_access_ctl { __u32 enabled ; __u32 flags ; __u32 reserved [ 8 ] ; } ;

struct kvm_vapic_addr { __u64 vapic_addr ; } ;

struct kvm_mp_state { __u32 mp_state ; } ;

struct kvm_s390_psw { __u64 mask ; __u64 addr ; } ;

struct kvm_s390_interrupt { __u32 type ; __u32 parm ; __u64 parm64 ; } ;

struct kvm_guest_debug { __u32 control ; __u32 pad ; struct kvm_guest_debug_arch arch ; } ;

enum { kvm_ioeventfd_flag_nr_datamatch , kvm_ioeventfd_flag_nr_pio , kvm_ioeventfd_flag_nr_deassign , kvm_ioeventfd_flag_nr_max , } ;
struct kvm_ioeventfd { __u64 datamatch ; __u64 addr ; __u32 len ; __s32 fd ; __u32 flags ; __u8 pad [ 36 ] ; } ;

struct kvm_irq_routing_irqchip { __u32 irqchip ; __u32 pin ; } ;

struct kvm_irq_routing_msi { __u32 address_lo ; __u32 address_hi ; __u32 data ; __u32 pad ; } ;

struct kvm_irq_routing_entry { __u32 gsi ; __u32 type ; __u32 flags ; __u32 pad ; union { struct kvm_irq_routing_irqchip irqchip ; struct kvm_irq_routing_msi msi ; __u32 pad [ 8 ] ; } u ; } ;

struct kvm_irq_routing { __u32 nr ; __u32 flags ; struct kvm_irq_routing_entry entries [ 0 ] ; } ;

struct kvm_x86_mce { __u64 status ; __u64 addr ; __u64 misc ; __u64 mcg_status ; __u8 bank ; __u8 pad1 [ 7 ] ; __u64 pad2 [ 3 ] ; } ;

struct kvm_irqfd { __u32 fd ; __u32 gsi ; __u32 flags ; __u8 pad [ 20 ] ; } ;

struct kvm_clock_data { __u64 clock ; __u32 flags ; __u32 pad [ 9 ] ; } ;

struct kvm_breakpoint { __u32 enabled ; __u32 padding ; __u64 address ; } ;

struct kvm_debug_guest { __u32 enabled ; __u32 pad ; struct kvm_breakpoint breakpoints [ 4 ] ; __u32 singlestep ; } ;

struct kvm_assigned_pci_dev { __u32 assigned_dev_id ; __u32 busnr ; __u32 devfn ; __u32 flags ; union { __u32 reserved [ 12 ] ; } ; } ;

struct kvm_assigned_irq { __u32 assigned_dev_id ; __u32 host_irq ; __u32 guest_irq ; __u32 flags ; union { struct { __u32 addr_lo ; __u32 addr_hi ; __u32 data ; } guest_msi ; __u32 reserved [ 12 ] ; } ; } ;

struct kvm_assigned_msix_nr { __u32 assigned_dev_id ; __u16 entry_nr ; __u16 padding ; } ;

struct kvm_assigned_msix_entry { __u32 assigned_dev_id ; __u32 gsi ; __u16 entry ; __u16 padding [ 3 ] ; } ;

typedef unsigned long gva_t ;

typedef u64 gpa_t ;

typedef unsigned long gfn_t ;

typedef unsigned long hva_t ;

typedef u64 hpa_t ;

typedef unsigned long hfn_t ;

typedef hfn_t pfn_t ;

union kvm_ioapic_redirect_entry { u64 bits ; struct { u8 vector ; u8 delivery_mode : 3 ; u8 dest_mode : 1 ; u8 delivery_status : 1 ; u8 polarity : 1 ; u8 remote_irr : 1 ; u8 trig_mode : 1 ; u8 mask : 1 ; u8 reserve : 7 ; u8 reserved [ 4 ] ; u8 dest_id ; } fields ; } ;

struct kvm_lapic_irq { u32 vector ; u32 delivery_mode ; u32 dest_mode ; u32 level ; u32 trig_mode ; u32 shorthand ; u32 dest_id ; } ;

struct mmu_notifier ;

struct mmu_notifier_ops ;

struct mmu_notifier_mm { struct hlist_head list ; spinlock_t lock ; } ;

struct mmu_notifier_ops { void ( * release ) ( struct mmu_notifier * mn , struct mm_struct * mm ) ; int ( * clear_flush_young ) ( struct mmu_notifier * mn , struct mm_struct * mm , unsigned long address ) ; void ( * change_pte ) ( struct mmu_notifier * mn , struct mm_struct * mm , unsigned long address , pte_t pte ) ; void ( * invalidate_page ) ( struct mmu_notifier * mn , struct mm_struct * mm , unsigned long address ) ; void ( * invalidate_range_start ) ( struct mmu_notifier * mn , struct mm_struct * mm , unsigned long start , unsigned long end ) ; void ( * invalidate_range_end ) ( struct mmu_notifier * mn , struct mm_struct * mm , unsigned long start , unsigned long end ) ; } ;
struct mmu_notifier { struct hlist_node hlist ; const struct mmu_notifier_ops * ops ; } ;
struct kvm_vcpu ;

struct kvm ;

enum kvm_reg { VCPU_REGS_RAX = 0 , VCPU_REGS_RCX = 1 , VCPU_REGS_RDX = 2 , VCPU_REGS_RBX = 3 , VCPU_REGS_RSP = 4 , VCPU_REGS_RBP = 5 , VCPU_REGS_RSI = 6 , VCPU_REGS_RDI = 7 , VCPU_REGS_R8 = 8 , VCPU_REGS_R9 = 9 , VCPU_REGS_R10 = 10 , VCPU_REGS_R11 = 11 , VCPU_REGS_R12 = 12 , VCPU_REGS_R13 = 13 , VCPU_REGS_R14 = 14 , VCPU_REGS_R15 = 15 , VCPU_REGS_RIP , NR_VCPU_REGS } ;

enum kvm_reg_ex { VCPU_EXREG_PDPTR = NR_VCPU_REGS , } ;

enum { VCPU_SREG_ES , VCPU_SREG_CS , VCPU_SREG_SS , VCPU_SREG_DS , VCPU_SREG_FS , VCPU_SREG_GS , VCPU_SREG_TR , VCPU_SREG_LDTR , } ;
struct x86_emulate_ctxt ;

struct x86_emulate_ops { int ( * read_std ) ( unsigned long addr , void * val , unsigned int bytes , struct kvm_vcpu * vcpu , u32 * error ) ; int ( * fetch ) ( unsigned long addr , void * val , unsigned int bytes , struct kvm_vcpu * vcpu , u32 * error ) ; int ( * read_emulated ) ( unsigned long addr , void * val , unsigned int bytes , struct kvm_vcpu * vcpu ) ; int ( * write_emulated ) ( unsigned long addr , const void * val , unsigned int bytes , struct kvm_vcpu * vcpu ) ; int ( * cmpxchg_emulated ) ( unsigned long addr , const void * old , const void * new , unsigned int bytes , struct kvm_vcpu * vcpu ) ; } ;

struct operand { enum { OP_REG , OP_MEM , OP_IMM , OP_NONE } type ; unsigned int bytes ; unsigned long val , orig_val , * ptr ; } ;

struct fetch_cache { u8 data [ 15 ] ; unsigned long start ; unsigned long end ; } ;

struct decode_cache { u8 twobyte ; u8 b ; u8 lock_prefix ; u8 rep_prefix ; u8 op_bytes ; u8 ad_bytes ; u8 rex_prefix ; struct operand src ; struct operand src2 ; struct operand dst ; bool has_seg_override ; u8 seg_override ; unsigned int d ; unsigned long regs [ NR_VCPU_REGS ] ; unsigned long eip , eip_orig ; u8 modrm ; u8 modrm_mod ; u8 modrm_reg ; u8 modrm_rm ; u8 use_modrm_ea ; bool rip_relative ; unsigned long modrm_ea ; void * modrm_ptr ; unsigned long modrm_val ; struct fetch_cache fetch ; } ;

struct x86_emulate_ctxt { struct kvm_vcpu * vcpu ; unsigned long eflags ; int mode ; u32 cs_base ; int interruptibility ; struct decode_cache decode ; } ;
struct kvm_mmu_memory_cache { int nobjs ; void * objects [ 40 ] ; } ;

struct kvm_pte_chain { u64 * parent_ptes [ 5 ] ; struct hlist_node link ; } ;

union kvm_mmu_page_role { unsigned word ; struct { unsigned glevels : 4 ; unsigned level : 4 ; unsigned quadrant : 2 ; unsigned pad_for_nice_hex_output : 6 ; unsigned direct : 1 ; unsigned access : 3 ; unsigned invalid : 1 ; unsigned cr4_pge : 1 ; unsigned nxe : 1 ; unsigned cr0_wp : 1 ; } ; } ;

struct kvm_mmu_page { struct list_head link ; struct hlist_node hash_link ; struct list_head oos_link ; gfn_t gfn ; union kvm_mmu_page_role role ; u64 * spt ; gfn_t * gfns ; unsigned long slot_bitmap [ ( ( ( 32 + 4 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; int multimapped ; int root_count ; bool unsync ; unsigned int unsync_children ; union { u64 * parent_pte ; struct hlist_head parent_ptes ; } ; unsigned long unsync_child_bitmap [ ( ( ( 512 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;

struct kvm_pv_mmu_op_buffer { void * ptr ; unsigned len ; unsigned processed ; char buf [ 512 ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; } ;

struct kvm_pio_request { unsigned long count ; int cur_count ; gva_t guest_gva ; int in ; int port ; int size ; int string ; int down ; int rep ; } ;

struct kvm_mmu { void ( * new_cr3 ) ( struct kvm_vcpu * vcpu ) ; int ( * page_fault ) ( struct kvm_vcpu * vcpu , gva_t gva , u32 err ) ; void ( * free ) ( struct kvm_vcpu * vcpu ) ; gpa_t ( * gva_to_gpa ) ( struct kvm_vcpu * vcpu , gva_t gva , u32 access , u32 * error ) ; void ( * prefetch_page ) ( struct kvm_vcpu * vcpu , struct kvm_mmu_page * page ) ; int ( * sync_page ) ( struct kvm_vcpu * vcpu , struct kvm_mmu_page * sp ) ; void ( * invlpg ) ( struct kvm_vcpu * vcpu , gva_t gva ) ; hpa_t root_hpa ; int root_level ; int shadow_root_level ; union kvm_mmu_page_role base_role ; u64 * pae_root ; u64 rsvd_bits_mask [ 2 ] [ 4 ] ; } ;

struct kvm_vcpu_arch { u64 host_tsc ; unsigned long regs [ NR_VCPU_REGS ] ; u32 regs_avail ; u32 regs_dirty ; unsigned long cr0 ; unsigned long cr2 ; unsigned long cr3 ; unsigned long cr4 ; unsigned long cr8 ; u32 hflags ; u64 pdptrs [ 4 ] ; u64 shadow_efer ; u64 apic_base ; struct kvm_lapic * apic ; int32_t apic_arb_prio ; int mp_state ; int sipi_vector ; u64 ia32_misc_enable_msr ; bool tpr_access_reporting ; struct kvm_mmu mmu ; struct kvm_pv_mmu_op_buffer mmu_op_buffer ; struct kvm_mmu_memory_cache mmu_pte_chain_cache ; struct kvm_mmu_memory_cache mmu_rmap_desc_cache ; struct kvm_mmu_memory_cache mmu_page_cache ; struct kvm_mmu_memory_cache mmu_page_header_cache ; gfn_t last_pt_write_gfn ; int last_pt_write_count ; u64 * last_pte_updated ; gfn_t last_pte_gfn ; struct { gfn_t gfn ; pfn_t pfn ; unsigned long mmu_seq ; } update_pte ; struct i387_fxsave_struct host_fx_image ; struct i387_fxsave_struct guest_fx_image ; gva_t mmio_fault_cr2 ; struct kvm_pio_request pio ; void * pio_data ; u8 event_exit_inst_len ; struct kvm_queued_exception { bool pending ; bool has_error_code ; u8 nr ; u32 error_code ; } exception ; struct kvm_queued_interrupt { bool pending ; bool soft ; u8 nr ; } interrupt ; int halt_request ; int cpuid_nent ; struct kvm_cpuid_entry2 cpuid_entries [ 40 ] ; struct x86_emulate_ctxt emulate_ctxt ; gpa_t time ; struct pvclock_vcpu_time_info hv_clock ; unsigned int hv_clock_tsc_khz ; unsigned int time_offset ; struct page * time_page ; bool singlestep ; bool nmi_pending ; bool nmi_injected ; struct mtrr_state_type mtrr_state ; u32 pat ; int switch_db_regs ; unsigned long db [ 4 ] ; unsigned long dr6 ; unsigned long dr7 ; unsigned long eff_db [ 4 ] ; u64 mcg_cap ; u64 mcg_status ; u64 mcg_ctl ; u64 * mce_banks ; } ;

struct kvm_mem_alias { gfn_t base_gfn ; unsigned long npages ; gfn_t target_gfn ; } ;

struct kvm_arch { int naliases ; struct kvm_mem_alias aliases [ 4 ] ; unsigned int n_free_mmu_pages ; unsigned int n_requested_mmu_pages ; unsigned int n_alloc_mmu_pages ; struct hlist_head mmu_page_hash [ ( 1 << 10 ) ] ; struct list_head active_mmu_pages ; struct list_head assigned_dev_head ; struct iommu_domain * iommu_domain ; int iommu_flags ; struct kvm_pic * vpic ; struct kvm_ioapic * vioapic ; struct kvm_pit * vpit ; struct hlist_head irq_ack_notifier_list ; int vapics_in_nmi_mode ; unsigned int tss_addr ; struct page * apic_access_page ; gpa_t wall_clock ; struct page * ept_identity_pagetable ; bool ept_identity_pagetable_done ; gpa_t ept_identity_map_addr ; unsigned long irq_sources_bitmap ; unsigned long irq_states [ 24 ] ; u64 vm_init_tsc ; s64 kvmclock_offset ; } ;

struct kvm_vm_stat { u32 mmu_shadow_zapped ; u32 mmu_pte_write ; u32 mmu_pte_updated ; u32 mmu_pde_zapped ; u32 mmu_flooded ; u32 mmu_recycled ; u32 mmu_cache_miss ; u32 mmu_unsync ; u32 remote_tlb_flush ; u32 lpages ; } ;

struct kvm_vcpu_stat { u32 pf_fixed ; u32 pf_guest ; u32 tlb_flush ; u32 invlpg ; u32 exits ; u32 io_exits ; u32 mmio_exits ; u32 signal_exits ; u32 irq_window_exits ; u32 nmi_window_exits ; u32 halt_exits ; u32 halt_wakeup ; u32 request_irq_exits ; u32 irq_exits ; u32 host_state_reload ; u32 efer_reload ; u32 fpu_reload ; u32 insn_emulation ; u32 insn_emulation_fail ; u32 hypercalls ; u32 irq_injections ; u32 nmi_injections ; } ;

struct descriptor_table { u16 limit ; unsigned long base ; } __attribute__ ( ( packed ) ) ;
struct kvm_x86_ops { int ( * cpu_has_kvm_support ) ( void ) ; int ( * disabled_by_bios ) ( void ) ; void ( * hardware_enable ) ( void * dummy ) ; void ( * hardware_disable ) ( void * dummy ) ; void ( * check_processor_compatibility ) ( void * rtn ) ; int ( * hardware_setup ) ( void ) ; void ( * hardware_unsetup ) ( void ) ; bool ( * cpu_has_accelerated_tpr ) ( void ) ; struct kvm_vcpu * ( * vcpu_create ) ( struct kvm * kvm , unsigned id ) ; void ( * vcpu_free ) ( struct kvm_vcpu * vcpu ) ; int ( * vcpu_reset ) ( struct kvm_vcpu * vcpu ) ; void ( * prepare_guest_switch ) ( struct kvm_vcpu * vcpu ) ; void ( * vcpu_load ) ( struct kvm_vcpu * vcpu , int cpu ) ; void ( * vcpu_put ) ( struct kvm_vcpu * vcpu ) ; int ( * set_guest_debug ) ( struct kvm_vcpu * vcpu , struct kvm_guest_debug * dbg ) ; int ( * get_msr ) ( struct kvm_vcpu * vcpu , u32 msr_index , u64 * pdata ) ; int ( * set_msr ) ( struct kvm_vcpu * vcpu , u32 msr_index , u64 data ) ; u64 ( * get_segment_base ) ( struct kvm_vcpu * vcpu , int seg ) ; void ( * get_segment ) ( struct kvm_vcpu * vcpu , struct kvm_segment * var , int seg ) ; int ( * get_cpl ) ( struct kvm_vcpu * vcpu ) ; void ( * set_segment ) ( struct kvm_vcpu * vcpu , struct kvm_segment * var , int seg ) ; void ( * get_cs_db_l_bits ) ( struct kvm_vcpu * vcpu , int * db , int * l ) ; void ( * decache_cr4_guest_bits ) ( struct kvm_vcpu * vcpu ) ; void ( * set_cr0 ) ( struct kvm_vcpu * vcpu , unsigned long cr0 ) ; void ( * set_cr3 ) ( struct kvm_vcpu * vcpu , unsigned long cr3 ) ; void ( * set_cr4 ) ( struct kvm_vcpu * vcpu , unsigned long cr4 ) ; void ( * set_efer ) ( struct kvm_vcpu * vcpu , u64 efer ) ; void ( * get_idt ) ( struct kvm_vcpu * vcpu , struct descriptor_table * dt ) ; void ( * set_idt ) ( struct kvm_vcpu * vcpu , struct descriptor_table * dt ) ; void ( * get_gdt ) ( struct kvm_vcpu * vcpu , struct descriptor_table * dt ) ; void ( * set_gdt ) ( struct kvm_vcpu * vcpu , struct descriptor_table * dt ) ; unsigned long ( * get_dr ) ( struct kvm_vcpu * vcpu , int dr ) ; void ( * set_dr ) ( struct kvm_vcpu * vcpu , int dr , unsigned long value , int * exception ) ; void ( * cache_reg ) ( struct kvm_vcpu * vcpu , enum kvm_reg reg ) ; unsigned long ( * get_rflags ) ( struct kvm_vcpu * vcpu ) ; void ( * set_rflags ) ( struct kvm_vcpu * vcpu , unsigned long rflags ) ; void ( * tlb_flush ) ( struct kvm_vcpu * vcpu ) ; void ( * run ) ( struct kvm_vcpu * vcpu , struct kvm_run * run ) ; int ( * handle_exit ) ( struct kvm_run * run , struct kvm_vcpu * vcpu ) ; void ( * skip_emulated_instruction ) ( struct kvm_vcpu * vcpu ) ; void ( * set_interrupt_shadow ) ( struct kvm_vcpu * vcpu , int mask ) ; u32 ( * get_interrupt_shadow ) ( struct kvm_vcpu * vcpu , int mask ) ; void ( * patch_hypercall ) ( struct kvm_vcpu * vcpu , unsigned char * hypercall_addr ) ; void ( * set_irq ) ( struct kvm_vcpu * vcpu ) ; void ( * set_nmi ) ( struct kvm_vcpu * vcpu ) ; void ( * queue_exception ) ( struct kvm_vcpu * vcpu , unsigned nr , bool has_error_code , u32 error_code ) ; int ( * interrupt_allowed ) ( struct kvm_vcpu * vcpu ) ; int ( * nmi_allowed ) ( struct kvm_vcpu * vcpu ) ; void ( * enable_nmi_window ) ( struct kvm_vcpu * vcpu ) ; void ( * enable_irq_window ) ( struct kvm_vcpu * vcpu ) ; void ( * update_cr8_intercept ) ( struct kvm_vcpu * vcpu , int tpr , int irr ) ; int ( * set_tss_addr ) ( struct kvm * kvm , unsigned int addr ) ; int ( * get_tdp_level ) ( void ) ; u64 ( * get_mt_mask ) ( struct kvm_vcpu * vcpu , gfn_t gfn , bool is_mmio ) ; bool ( * gb_page_enable ) ( void ) ; const struct trace_print_flags * exit_reasons_str ; } ;

enum emulation_result { EMULATE_DONE , EMULATE_DO_MMIO , EMULATE_FAIL , } ;

enum { TASK_SWITCH_CALL = 0 , TASK_SWITCH_IRET = 1 , TASK_SWITCH_JMP = 2 , TASK_SWITCH_GATE = 3 , } ;
struct kvm_io_bus { int dev_count ; struct kvm_io_device * devs [ 200 ] ; } ;

struct kvm_vcpu { struct kvm * kvm ; struct preempt_notifier preempt_notifier ; int vcpu_id ; struct mutex mutex ; int cpu ; struct kvm_run * run ; unsigned long requests ; unsigned long guest_debug ; int fpu_active ; int guest_fpu_loaded ; wait_queue_head_t wq ; int sigset_active ; sigset_t sigset ; struct kvm_vcpu_stat stat ; int mmio_needed ; int mmio_read_completed ; int mmio_is_write ; int mmio_size ; unsigned char mmio_data [ 8 ] ; gpa_t mmio_phys_addr ; struct kvm_vcpu_arch arch ; } ;
struct kvm_memory_slot { gfn_t base_gfn ; unsigned long npages ; unsigned long flags ; unsigned long * rmap ; unsigned long * dirty_bitmap ; struct { unsigned long rmap_pde ; int write_count ; } * lpage_info [ 3 - 1 ] ; unsigned long userspace_addr ; int user_alloc ; } ;

struct kvm_kernel_irq_routing_entry { u32 gsi ; u32 type ; int ( * set ) ( struct kvm_kernel_irq_routing_entry * e , struct kvm * kvm , int level ) ; union { struct { unsigned irqchip ; unsigned pin ; } irqchip ; struct msi_msg msi ; } ; struct list_head link ; } ;

struct kvm { spinlock_t mmu_lock ; spinlock_t requests_lock ; struct rw_semaphore slots_lock ; struct mm_struct * mm ; int nmemslots ; struct kvm_memory_slot memslots [ 32 + 4 ] ; u32 bsp_vcpu_id ; struct kvm_vcpu * bsp_vcpu ; struct kvm_vcpu * vcpus [ 16 ] ; atomic_t online_vcpus ; struct list_head vm_list ; struct mutex lock ; struct kvm_io_bus mmio_bus ; struct kvm_io_bus pio_bus ; struct { spinlock_t lock ; struct list_head items ; } irqfds ; struct list_head ioeventfds ; struct kvm_vm_stat stat ; struct kvm_arch arch ; atomic_t users_count ; struct kvm_coalesced_mmio_dev * coalesced_mmio_dev ; struct kvm_coalesced_mmio_ring * coalesced_mmio_ring ; struct mutex irq_lock ; struct list_head irq_routing ; struct hlist_head mask_notifier_list ; struct mmu_notifier mmu_notifier ; unsigned long mmu_notifier_seq ; long mmu_notifier_count ; } ;
struct kvm_irq_ack_notifier { struct hlist_node link ; unsigned gsi ; void ( * irq_acked ) ( struct kvm_irq_ack_notifier * kian ) ; } ;

struct kvm_guest_msix_entry { u32 vector ; u16 entry ; u16 flags ; } ;

struct kvm_assigned_dev_kernel { struct kvm_irq_ack_notifier ack_notifier ; struct work_struct interrupt_work ; struct list_head list ; int assigned_dev_id ; int host_busnr ; int host_devfn ; unsigned int entries_nr ; int host_irq ; bool host_irq_disabled ; struct msix_entry * host_msix_entries ; int guest_irq ; struct kvm_guest_msix_entry * guest_msix_entries ; unsigned long irq_requested_type ; int irq_source_id ; int flags ; struct pci_dev * dev ; struct kvm * kvm ; spinlock_t assigned_dev_lock ; } ;

struct kvm_irq_mask_notifier { void ( * func ) ( struct kvm_irq_mask_notifier * kimn , bool masked ) ; int irq ; struct hlist_node link ; } ;

enum kvm_stat_kind { KVM_STAT_VM , KVM_STAT_VCPU , } ;

struct kvm_stats_debugfs_item { const char * name ; int offset ; enum kvm_stat_kind kind ; struct dentry * dentry ; } ;

struct kvm_io_device ;

struct kvm_io_device_ops { int ( * read ) ( struct kvm_io_device * this , gpa_t addr , int len , void * val ) ; int ( * write ) ( struct kvm_io_device * this , gpa_t addr , int len , const void * val ) ; void ( * destructor ) ( struct kvm_io_device * this ) ; } ;

struct kvm_io_device { const struct kvm_io_device_ops * ops ; } ;
struct kvm_ioapic { u64 base_address ; u32 ioregsel ; u32 id ; u32 irr ; u32 pad ; union kvm_ioapic_redirect_entry redirtbl [ 24 ] ; struct kvm_io_device dev ; struct kvm * kvm ; void ( * ack_notifier ) ( void * opaque , int irq ) ; } ;

struct kvm_timer { struct hrtimer timer ; s64 period ; atomic_t pending ; bool reinject ; struct kvm_timer_ops * t_ops ; struct kvm * kvm ; struct kvm_vcpu * vcpu ; } ;

struct kvm_timer_ops { bool ( * is_periodic ) ( struct kvm_timer * ) ; } ;

struct kvm_lapic { unsigned long base_address ; struct kvm_io_device dev ; struct kvm_timer lapic_timer ; u32 divide_count ; struct kvm_vcpu * vcpu ; bool irr_pending ; struct page * regs_page ; void * regs ; gpa_t vapic_addr ; struct page * vapic_page ; } ;

typedef void irq_request_func ( void * opaque , int level ) ;

struct kvm_kpic_state { u8 last_irr ; u8 irr ; u8 imr ; u8 isr ; u8 isr_ack ; u8 priority_add ; u8 irq_base ; u8 read_reg_select ; u8 poll ; u8 special_mask ; u8 init_state ; u8 auto_eoi ; u8 rotate_on_auto_eoi ; u8 special_fully_nested_mode ; u8 init4 ; u8 elcr ; u8 elcr_mask ; struct kvm_pic * pics_state ; } ;

struct kvm_pic { spinlock_t lock ; unsigned pending_acks ; struct kvm * kvm ; struct kvm_kpic_state pics [ 2 ] ; irq_request_func * irq_request ; void * irq_request_opaque ; int output ; struct kvm_io_device dev ; void ( * ack_notifier ) ( void * opaque , int irq ) ; } ;

struct vmcs { u32 revision_id ; u32 abort ; char data [ 0 ] ; } ;

struct vcpu_vmx { struct kvm_vcpu vcpu ; struct list_head local_vcpus_link ; unsigned long host_rsp ; int launched ; u8 fail ; u32 idt_vectoring_info ; struct kvm_msr_entry * guest_msrs ; struct kvm_msr_entry * host_msrs ; int nmsrs ; int save_nmsrs ; int msr_offset_efer ; int msr_offset_kernel_gs_base ; struct vmcs * vmcs ; struct { int loaded ; u16 fs_sel , gs_sel , ldt_sel ; int gs_ldt_reload_needed ; int fs_reload_needed ; int guest_efer_loaded ; } host_state ; struct { int vm86_active ; ulong save_rflags ; struct kvm_save_segment { u16 selector ; unsigned long base ; u32 limit ; u32 ar ; } tr , es , ds , fs , gs ; struct { bool pending ; u8 vector ; unsigned rip ; } irq ; } rmode ; int vpid ; bool emulation_required ; enum emulation_result invalid_state_emulation_result ; int soft_vnmi_blocked ; ktime_t entry_time ; s64 vnmi_blocked_time ; u32 exit_reason ; } ;




struct kvm_coalesced_mmio_dev { struct kvm_io_device dev ; struct kvm * kvm ; spinlock_t lock ; int nb_zones ; struct kvm_coalesced_mmio_zone zone [ 100 ] ; } ;

struct ftrace_raw_kvm_set_irq { struct trace_entry ent ; unsigned int gsi ; int level ; int irq_source_id ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_ioapic_set_irq { struct trace_entry ent ; __u64 e ; int pin ; bool coalesced ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_msi_set_irq { struct trace_entry ent ; __u64 address ; __u64 data ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_ack_irq { struct trace_entry ent ; unsigned int irqchip ; unsigned int pin ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_mmio { struct trace_entry ent ; u32 type ; u32 len ; u64 gpa ; u64 val ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_kvm_set_irq { ; } ;

struct ftrace_data_offsets_kvm_ioapic_set_irq { ; } ;

struct ftrace_data_offsets_kvm_msi_set_irq { ; } ;

struct ftrace_data_offsets_kvm_ack_irq { ; } ;

struct ftrace_data_offsets_kvm_mmio { ; } ;

void kvm_free_all_assigned_devices ( struct kvm * kvm ) ;

void vcpu_load ( struct kvm_vcpu * vcpu ) ;

void vcpu_put ( struct kvm_vcpu * vcpu ) ;

void kvm_flush_remote_tlbs ( struct kvm * kvm ) ;

void kvm_reload_remote_mmus ( struct kvm * kvm ) ;

int kvm_vcpu_init ( struct kvm_vcpu * vcpu , struct kvm * kvm , unsigned id ) ;

void kvm_vcpu_uninit ( struct kvm_vcpu * vcpu ) ;

void kvm_free_physmem ( struct kvm * kvm ) ;

void kvm_get_kvm ( struct kvm * kvm ) ;

void kvm_put_kvm ( struct kvm * kvm ) ;

int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) ;

int kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) ;

int kvm_vm_ioctl_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) ;

int kvm_get_dirty_log ( struct kvm * kvm , struct kvm_dirty_log * log , int * is_dirty ) ;

void kvm_disable_largepages ( void ) ;

int is_error_page ( struct page * page ) ;

int is_error_pfn ( pfn_t pfn ) ;

int kvm_is_error_hva ( unsigned long addr ) ;

struct kvm_memory_slot * gfn_to_memslot_unaliased ( struct kvm * kvm , gfn_t gfn ) ;

struct kvm_memory_slot * gfn_to_memslot ( struct kvm * kvm , gfn_t gfn ) ;

int kvm_is_visible_gfn ( struct kvm * kvm , gfn_t gfn ) ;

unsigned long gfn_to_hva ( struct kvm * kvm , gfn_t gfn ) ;

pfn_t gfn_to_pfn ( struct kvm * kvm , gfn_t gfn ) ;

struct page * gfn_to_page ( struct kvm * kvm , gfn_t gfn ) ;

void kvm_release_page_clean ( struct page * page ) ;

void kvm_release_pfn_clean ( pfn_t pfn ) ;

void kvm_release_page_dirty ( struct page * page ) ;

void kvm_release_pfn_dirty ( pfn_t pfn ) ;

void kvm_set_page_dirty ( struct page * page ) ;

void kvm_set_pfn_dirty ( pfn_t pfn ) ;

void kvm_set_pfn_accessed ( pfn_t pfn ) ;

void kvm_get_pfn ( pfn_t pfn ) ;

int kvm_read_guest_page ( struct kvm * kvm , gfn_t gfn , void * data , int offset , int len ) ;

int kvm_read_guest ( struct kvm * kvm , gpa_t gpa , void * data , unsigned long len ) ;

int kvm_read_guest_atomic ( struct kvm * kvm , gpa_t gpa , void * data , unsigned long len ) ;

int kvm_write_guest_page ( struct kvm * kvm , gfn_t gfn , const void * data , int offset , int len ) ;

int kvm_write_guest ( struct kvm * kvm , gpa_t gpa , const void * data , unsigned long len ) ;

int kvm_clear_guest_page ( struct kvm * kvm , gfn_t gfn , int offset , int len ) ;

int kvm_clear_guest ( struct kvm * kvm , gpa_t gpa , unsigned long len ) ;

void mark_page_dirty ( struct kvm * kvm , gfn_t gfn ) ;

void kvm_vcpu_block ( struct kvm_vcpu * vcpu ) ;

void kvm_resched ( struct kvm_vcpu * vcpu ) ;

void kvm_vcpu_on_spin ( struct kvm_vcpu * vcpu ) ;

void kvm_handle_fault_on_reboot ( void ) ;

void kvm_io_bus_init ( struct kvm_io_bus * bus ) ;

void kvm_io_bus_destroy ( struct kvm_io_bus * bus ) ;

int kvm_io_bus_write ( struct kvm_io_bus * bus , gpa_t addr , int len , const void * val ) ;

int kvm_io_bus_read ( struct kvm_io_bus * bus , gpa_t addr , int len , void * val ) ;

int kvm_io_bus_register_dev ( struct kvm * kvm , struct kvm_io_bus * bus , struct kvm_io_device * dev ) ;

int __kvm_io_bus_register_dev ( struct kvm_io_bus * bus , struct kvm_io_device * dev ) ;

void kvm_io_bus_unregister_dev ( struct kvm * kvm , struct kvm_io_bus * bus , struct kvm_io_device * dev ) ;

void __kvm_io_bus_unregister_dev ( struct kvm_io_bus * bus , struct kvm_io_device * dev ) ;

int kvm_init ( void * opaque , unsigned int vcpu_size , struct module * module ) ;

void kvm_exit ( void ) ;

int kvm_ioapic_set_irq ( struct kvm_ioapic * ioapic , int irq , int level ) ;

void kvm_ioapic_update_eoi ( struct kvm * kvm , int vector , int trigger_mode ) ;

void kvm_ioapic_reset ( struct kvm_ioapic * ioapic ) ;

int kvm_ioapic_init ( struct kvm * kvm ) ;

int kvm_coalesced_mmio_init ( struct kvm * kvm ) ;

int kvm_vm_ioctl_register_coalesced_mmio ( struct kvm * kvm , struct kvm_coalesced_mmio_zone * zone ) ;

int kvm_vm_ioctl_unregister_coalesced_mmio ( struct kvm * kvm , struct kvm_coalesced_mmio_zone * zone ) ;

int kvm_irq_delivery_to_apic ( struct kvm * kvm , struct kvm_lapic * src , struct kvm_lapic_irq * irq ) ;

int kvm_set_irq ( struct kvm * kvm , int irq_source_id , int irq , int level ) ;

void kvm_notify_acked_irq ( struct kvm * kvm , unsigned irqchip , unsigned pin ) ;

void kvm_register_irq_ack_notifier ( struct kvm * kvm , struct kvm_irq_ack_notifier * kian ) ;

void kvm_unregister_irq_ack_notifier ( struct kvm * kvm , struct kvm_irq_ack_notifier * kian ) ;

int kvm_request_irq_source_id ( struct kvm * kvm ) ;

void kvm_free_irq_source_id ( struct kvm * kvm , int irq_source_id ) ;

void kvm_register_irq_mask_notifier ( struct kvm * kvm , int irq , struct kvm_irq_mask_notifier * kimn ) ;

void kvm_unregister_irq_mask_notifier ( struct kvm * kvm , int irq , struct kvm_irq_mask_notifier * kimn ) ;

void kvm_fire_mask_notifiers ( struct kvm * kvm , int irq , bool mask ) ;

void kvm_free_irq_routing ( struct kvm * kvm ) ;

int kvm_set_irq_routing ( struct kvm * kvm , const struct kvm_irq_routing_entry * ue , unsigned nr , unsigned flags ) ;

int kvm_setup_default_irq_routing ( struct kvm * kvm ) ;

struct _irqfd { struct kvm * kvm ; struct eventfd_ctx * eventfd ; int gsi ; struct list_head list ; poll_table pt ; wait_queue_head_t * wqh ; wait_queue_t wait ; struct work_struct inject ; struct work_struct shutdown ; } ;

void kvm_eventfd_init ( struct kvm * kvm ) ;

int kvm_irqfd ( struct kvm * kvm , int fd , int gsi , int flags ) ;
void kvm_irqfd_release ( struct kvm * kvm ) ;

; struct _ioeventfd { struct list_head list ; u64 addr ; int length ; struct eventfd_ctx * eventfd ; u64 datamatch ; struct kvm_io_device dev ; bool wildcard ; } ;

int kvm_ioeventfd ( struct kvm * kvm , struct kvm_ioeventfd * args ) ;
struct iova { struct rb_node node ; unsigned long pfn_hi ; unsigned long pfn_lo ; } ;

struct iova_domain { spinlock_t iova_rbtree_lock ; struct rb_root rbroot ; struct rb_node * cached32_node ; unsigned long dma_32bit_pfn ; } ;

struct dmar_domain ;

struct root_entry ;

enum { QI_FREE , QI_IN_USE , QI_DONE , QI_ABORT } ;
struct qi_desc { u64 low , high ; } ;

struct q_inval { spinlock_t q_lock ; struct qi_desc * desc ; int * desc_status ; int free_head ; int free_tail ; int free_cnt ; } ;

struct iommu_flush { void ( * flush_context ) ( struct intel_iommu * iommu , u16 did , u16 sid , u8 fm , u64 type ) ; void ( * flush_iotlb ) ( struct intel_iommu * iommu , u16 did , u64 addr , unsigned int size_order , u64 type ) ; } ;

enum { SR_DMAR_FECTL_REG , SR_DMAR_FEDATA_REG , SR_DMAR_FEADDR_REG , SR_DMAR_FEUADDR_REG , MAX_SR_DMAR_REGS } ;
struct intel_iommu { void * reg ; u64 cap ; u64 ecap ; u32 gcmd ; spinlock_t register_lock ; int seq_id ; int agaw ; int msagaw ; unsigned int irq ; unsigned char name [ 13 ] ; struct q_inval * qi ; u32 * iommu_state ; } ;
int kvm_iommu_map_pages ( struct kvm * kvm , gfn_t base_gfn , unsigned long npages ) ;

int kvm_assign_device ( struct kvm * kvm , struct kvm_assigned_dev_kernel * assigned_dev ) ;

int kvm_deassign_device ( struct kvm * kvm , struct kvm_assigned_dev_kernel * assigned_dev ) ;

int kvm_iommu_map_guest ( struct kvm * kvm ) ;

int kvm_iommu_unmap_guest ( struct kvm * kvm ) ;

struct kvm_kpit_channel_state { u32 count ; u16 latched_count ; u8 count_latched ; u8 status_latched ; u8 status ; u8 read_state ; u8 write_state ; u8 write_latch ; u8 rw_mode ; u8 mode ; u8 bcd ; u8 gate ; ktime_t count_load_time ; } ;

struct kvm_kpit_state { struct kvm_kpit_channel_state channels [ 3 ] ; u32 flags ; struct kvm_timer pit_timer ; bool is_periodic ; u32 speaker_data_on ; struct mutex lock ; struct kvm_pit * pit ; spinlock_t inject_lock ; unsigned long irq_ack ; struct kvm_irq_ack_notifier irq_ack_notifier ; } ;

struct kvm_pit { unsigned long base_addresss ; struct kvm_io_device dev ; struct kvm_io_device speaker_dev ; struct kvm * kvm ; struct kvm_kpit_state pit_state ; int irq_source_id ; struct kvm_irq_mask_notifier mask_notifier ; } ;

struct tss_segment_32 { u32 prev_task_link ; u32 esp0 ; u32 ss0 ; u32 esp1 ; u32 ss1 ; u32 esp2 ; u32 ss2 ; u32 cr3 ; u32 eip ; u32 eflags ; u32 eax ; u32 ecx ; u32 edx ; u32 ebx ; u32 esp ; u32 ebp ; u32 esi ; u32 edi ; u32 es ; u32 cs ; u32 ss ; u32 ds ; u32 fs ; u32 gs ; u32 ldt_selector ; u16 t ; u16 io_map ; } ;

struct tss_segment_16 { u16 prev_task_link ; u16 sp0 ; u16 ss0 ; u16 sp1 ; u16 ss1 ; u16 sp2 ; u16 ss2 ; u16 ip ; u16 flag ; u16 ax ; u16 cx ; u16 dx ; u16 bx ; u16 sp ; u16 bp ; u16 si ; u16 di ; u16 es ; u16 cs ; u16 ss ; u16 ds ; u16 ldt ; } ;

struct ftrace_raw_kvm_entry { struct trace_entry ent ; unsigned int vcpu_id ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_hypercall { struct trace_entry ent ; unsigned long nr ; unsigned long a0 ; unsigned long a1 ; unsigned long a2 ; unsigned long a3 ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_pio { struct trace_entry ent ; unsigned int rw ; unsigned int port ; unsigned int size ; unsigned int count ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_cpuid { struct trace_entry ent ; unsigned int function ; unsigned long rax ; unsigned long rbx ; unsigned long rcx ; unsigned long rdx ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_apic { struct trace_entry ent ; unsigned int rw ; unsigned int reg ; unsigned int val ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_exit { struct trace_entry ent ; unsigned int exit_reason ; unsigned long guest_rip ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_inj_virq { struct trace_entry ent ; unsigned int irq ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_page_fault { struct trace_entry ent ; unsigned long fault_address ; unsigned int error_code ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_msr { struct trace_entry ent ; unsigned int rw ; unsigned int ecx ; unsigned long data ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_cr { struct trace_entry ent ; unsigned int rw ; unsigned int cr ; unsigned long val ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_pic_set_irq { struct trace_entry ent ; __u8 chip ; __u8 pin ; __u8 elcr ; __u8 imr ; bool coalesced ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_apic_ipi { struct trace_entry ent ; __u32 icr_low ; __u32 dest_id ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_apic_accept_irq { struct trace_entry ent ; __u32 apicid ; __u16 dm ; __u8 tm ; __u8 vec ; bool coalesced ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_kvm_entry { ; } ;

struct ftrace_data_offsets_kvm_hypercall { ; } ;

struct ftrace_data_offsets_kvm_pio { ; } ;

struct ftrace_data_offsets_kvm_cpuid { ; } ;

struct ftrace_data_offsets_kvm_apic { ; } ;

struct ftrace_data_offsets_kvm_exit { ; } ;

struct ftrace_data_offsets_kvm_inj_virq { ; } ;

struct ftrace_data_offsets_kvm_page_fault { ; } ;

struct ftrace_data_offsets_kvm_msr { ; } ;

struct ftrace_data_offsets_kvm_cr { ; } ;

struct ftrace_data_offsets_kvm_pic_set_irq { ; } ;

struct ftrace_data_offsets_kvm_apic_ipi { ; } ;

struct ftrace_data_offsets_kvm_apic_accept_irq { ; } ;

unsigned long segment_base ( u16 selector ) ;

u64 kvm_get_apic_base ( struct kvm_vcpu * vcpu ) ;

void kvm_set_apic_base ( struct kvm_vcpu * vcpu , u64 data ) ;

void kvm_queue_exception ( struct kvm_vcpu * vcpu , unsigned nr ) ;

void kvm_inject_page_fault ( struct kvm_vcpu * vcpu , unsigned long addr , u32 error_code ) ;

void kvm_inject_nmi ( struct kvm_vcpu * vcpu ) ;

void kvm_queue_exception_e ( struct kvm_vcpu * vcpu , unsigned nr , u32 error_code ) ;

bool kvm_require_cpl ( struct kvm_vcpu * vcpu , int required_cpl ) ;

int load_pdptrs ( struct kvm_vcpu * vcpu , unsigned long cr3 ) ;

void kvm_set_cr0 ( struct kvm_vcpu * vcpu , unsigned long cr0 ) ;

void kvm_lmsw ( struct kvm_vcpu * vcpu , unsigned long msw ) ;

void kvm_set_cr4 ( struct kvm_vcpu * vcpu , unsigned long cr4 ) ;

void kvm_set_cr3 ( struct kvm_vcpu * vcpu , unsigned long cr3 ) ;

void kvm_set_cr8 ( struct kvm_vcpu * vcpu , unsigned long cr8 ) ;

unsigned long kvm_get_cr8 ( struct kvm_vcpu * vcpu ) ;

void kvm_enable_efer_bits ( u64 mask ) ;

int kvm_set_msr ( struct kvm_vcpu * vcpu , u32 msr_index , u64 data ) ;

int kvm_set_msr_common ( struct kvm_vcpu * vcpu , u32 msr , u64 data ) ;

int kvm_get_msr ( struct kvm_vcpu * vcpu , u32 msr_index , u64 * pdata ) ;

int kvm_get_msr_common ( struct kvm_vcpu * vcpu , u32 msr , u64 * pdata ) ;

int kvm_dev_ioctl_check_extension ( long ext ) ;

long kvm_arch_dev_ioctl ( struct file * filp , unsigned int ioctl , unsigned long arg ) ;

void kvm_arch_vcpu_load ( struct kvm_vcpu * vcpu , int cpu ) ;

void kvm_arch_vcpu_put ( struct kvm_vcpu * vcpu ) ;

long kvm_arch_vcpu_ioctl ( struct file * filp , unsigned int ioctl , unsigned long arg ) ;

gfn_t unalias_gfn ( struct kvm * kvm , gfn_t gfn ) ;

int kvm_vm_ioctl_get_dirty_log ( struct kvm * kvm , struct kvm_dirty_log * log ) ;

long kvm_arch_vm_ioctl ( struct file * filp , unsigned int ioctl , unsigned long arg ) ;

gpa_t kvm_mmu_gva_to_gpa_read ( struct kvm_vcpu * vcpu , gva_t gva , u32 * error ) ;

gpa_t kvm_mmu_gva_to_gpa_fetch ( struct kvm_vcpu * vcpu , gva_t gva , u32 * error ) ;

gpa_t kvm_mmu_gva_to_gpa_write ( struct kvm_vcpu * vcpu , gva_t gva , u32 * error ) ;

gpa_t kvm_mmu_gva_to_gpa_system ( struct kvm_vcpu * vcpu , gva_t gva , u32 * error ) ;

int emulator_write_phys ( struct kvm_vcpu * vcpu , gpa_t gpa , const void * val , int bytes ) ;

int emulator_write_emulated ( unsigned long addr , const void * val , unsigned int bytes , struct kvm_vcpu * vcpu ) ;

int emulate_invlpg ( struct kvm_vcpu * vcpu , gva_t address ) ;

int emulate_clts ( struct kvm_vcpu * vcpu ) ;

int emulator_get_dr ( struct x86_emulate_ctxt * ctxt , int dr , unsigned long * dest ) ;

int emulator_set_dr ( struct x86_emulate_ctxt * ctxt , int dr , unsigned long value ) ;

void kvm_report_emulation_failure ( struct kvm_vcpu * vcpu , const char * context ) ;

int emulate_instruction ( struct kvm_vcpu * vcpu , struct kvm_run * run , unsigned long cr2 , u16 error_code , int emulation_type ) ;

int complete_pio ( struct kvm_vcpu * vcpu ) ;

int kvm_emulate_pio ( struct kvm_vcpu * vcpu , struct kvm_run * run , int in , int size , unsigned port ) ;

int kvm_emulate_pio_string ( struct kvm_vcpu * vcpu , struct kvm_run * run , int in , int size , unsigned long count , int down , gva_t address , int rep , unsigned port ) ;

int kvm_arch_init ( void * opaque ) ;

void kvm_arch_exit ( void ) ;

int kvm_emulate_halt ( struct kvm_vcpu * vcpu ) ;

int kvm_emulate_hypercall ( struct kvm_vcpu * vcpu ) ;

int kvm_fix_hypercall ( struct kvm_vcpu * vcpu ) ;

void realmode_lgdt ( struct kvm_vcpu * vcpu , u16 limit , unsigned long base ) ;

void realmode_lidt ( struct kvm_vcpu * vcpu , u16 limit , unsigned long base ) ;

void realmode_lmsw ( struct kvm_vcpu * vcpu , unsigned long msw , unsigned long * rflags ) ;

unsigned long realmode_get_cr ( struct kvm_vcpu * vcpu , int cr ) ;

void realmode_set_cr ( struct kvm_vcpu * vcpu , int cr , unsigned long val , unsigned long * rflags ) ;

struct kvm_cpuid_entry2 * kvm_find_cpuid_entry ( struct kvm_vcpu * vcpu , u32 function , u32 index ) ;

int cpuid_maxphyaddr ( struct kvm_vcpu * vcpu ) ;

void kvm_emulate_cpuid ( struct kvm_vcpu * vcpu ) ;

int kvm_arch_vcpu_ioctl_run ( struct kvm_vcpu * vcpu , struct kvm_run * kvm_run ) ;

int kvm_arch_vcpu_ioctl_get_regs ( struct kvm_vcpu * vcpu , struct kvm_regs * regs ) ;

int kvm_arch_vcpu_ioctl_set_regs ( struct kvm_vcpu * vcpu , struct kvm_regs * regs ) ;

void kvm_get_segment ( struct kvm_vcpu * vcpu , struct kvm_segment * var , int seg ) ;

void kvm_get_cs_db_l_bits ( struct kvm_vcpu * vcpu , int * db , int * l ) ;

int kvm_arch_vcpu_ioctl_get_sregs ( struct kvm_vcpu * vcpu , struct kvm_sregs * sregs ) ;

int kvm_arch_vcpu_ioctl_get_mpstate ( struct kvm_vcpu * vcpu , struct kvm_mp_state * mp_state ) ;

int kvm_arch_vcpu_ioctl_set_mpstate ( struct kvm_vcpu * vcpu , struct kvm_mp_state * mp_state ) ;

int kvm_load_segment_descriptor ( struct kvm_vcpu * vcpu , u16 selector , int seg ) ;

int kvm_task_switch ( struct kvm_vcpu * vcpu , u16 tss_selector , int reason ) ;

int kvm_arch_vcpu_ioctl_set_sregs ( struct kvm_vcpu * vcpu , struct kvm_sregs * sregs ) ;

int kvm_arch_vcpu_ioctl_set_guest_debug ( struct kvm_vcpu * vcpu , struct kvm_guest_debug * dbg ) ;

struct fxsave { u16 cwd ; u16 swd ; u16 twd ; u16 fop ; u64 rip ; u64 rdp ; u32 mxcsr ; u32 mxcsr_mask ; u32 st_space [ 32 ] ; u32 xmm_space [ 64 ] ; } ;

int kvm_arch_vcpu_ioctl_translate ( struct kvm_vcpu * vcpu , struct kvm_translation * tr ) ;

int kvm_arch_vcpu_ioctl_get_fpu ( struct kvm_vcpu * vcpu , struct kvm_fpu * fpu ) ;

int kvm_arch_vcpu_ioctl_set_fpu ( struct kvm_vcpu * vcpu , struct kvm_fpu * fpu ) ;

void fx_init ( struct kvm_vcpu * vcpu ) ;

void kvm_load_guest_fpu ( struct kvm_vcpu * vcpu ) ;

void kvm_put_guest_fpu ( struct kvm_vcpu * vcpu ) ;

void kvm_arch_vcpu_free ( struct kvm_vcpu * vcpu ) ;

struct kvm_vcpu * kvm_arch_vcpu_create ( struct kvm * kvm , unsigned int id ) ;

int kvm_arch_vcpu_setup ( struct kvm_vcpu * vcpu ) ;

void kvm_arch_vcpu_destroy ( struct kvm_vcpu * vcpu ) ;

int kvm_arch_vcpu_reset ( struct kvm_vcpu * vcpu ) ;

void kvm_arch_hardware_enable ( void * garbage ) ;

void kvm_arch_hardware_disable ( void * garbage ) ;

int kvm_arch_hardware_setup ( void ) ;

void kvm_arch_hardware_unsetup ( void ) ;

void kvm_arch_check_processor_compat ( void * rtn ) ;

int kvm_arch_vcpu_init ( struct kvm_vcpu * vcpu ) ;

void kvm_arch_vcpu_uninit ( struct kvm_vcpu * vcpu ) ;

struct kvm * kvm_arch_create_vm ( void ) ;

void kvm_arch_sync_events ( struct kvm * kvm ) ;

void kvm_arch_destroy_vm ( struct kvm * kvm ) ;

int kvm_arch_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , struct kvm_memory_slot old , int user_alloc ) ;

void kvm_arch_flush_shadow ( struct kvm * kvm ) ;

int kvm_arch_vcpu_runnable ( struct kvm_vcpu * vcpu ) ;

void kvm_vcpu_kick ( struct kvm_vcpu * vcpu ) ;

int kvm_arch_interrupt_allowed ( struct kvm_vcpu * vcpu ) ;

enum { HUGETLB_SHMFS_INODE = 1 , HUGETLB_ANONHUGE_INODE = 2 , } ;
struct hugetlbfs_config { uid_t uid ; gid_t gid ; umode_t mode ; long nr_blocks ; long nr_inodes ; struct hstate * hstate ; } ;

struct hugetlbfs_sb_info { long max_blocks ; long free_blocks ; long max_inodes ; long free_inodes ; spinlock_t stat_lock ; struct hstate * hstate ; } ;

struct hugetlbfs_inode_info { struct shared_policy policy ; struct inode vfs_inode ; } ;

struct hstate { int next_nid_to_alloc ; int next_nid_to_free ; unsigned int order ; unsigned long mask ; unsigned long max_huge_pages ; unsigned long nr_huge_pages ; unsigned long free_huge_pages ; unsigned long resv_huge_pages ; unsigned long surplus_huge_pages ; unsigned long nr_overcommit_huge_pages ; struct list_head hugepage_freelists [ ( 1 << 6 ) ] ; unsigned int nr_huge_pages_node [ ( 1 << 6 ) ] ; unsigned int free_huge_pages_node [ ( 1 << 6 ) ] ; unsigned int surplus_huge_pages_node [ ( 1 << 6 ) ] ; char name [ 32 ] ; } ;

struct huge_bootmem_page { struct list_head list ; struct hstate * hstate ; } ;

struct ftrace_raw_kvm_mmu_pagetable_walk { struct trace_entry ent ; __u64 addr ; __u32 pferr ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_mmu_paging_element { struct trace_entry ent ; __u64 pte ; __u32 level ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_mmu_set_accessed_bit { struct trace_entry ent ; __u64 gpa ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_mmu_set_dirty_bit { struct trace_entry ent ; __u64 gpa ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_mmu_walker_error { struct trace_entry ent ; __u32 pferr ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_mmu_get_page { struct trace_entry ent ; __u64 gfn ; __u32 role ; __u32 root_count ; __u32 unsync ; bool created ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_mmu_sync_page { struct trace_entry ent ; __u64 gfn ; __u32 role ; __u32 root_count ; __u32 unsync ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_mmu_unsync_page { struct trace_entry ent ; __u64 gfn ; __u32 role ; __u32 root_count ; __u32 unsync ; char __data [ 0 ] ; } ;

struct ftrace_raw_kvm_mmu_zap_page { struct trace_entry ent ; __u64 gfn ; __u32 role ; __u32 root_count ; __u32 unsync ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_kvm_mmu_pagetable_walk { ; } ;

struct ftrace_data_offsets_kvm_mmu_paging_element { ; } ;

struct ftrace_data_offsets_kvm_mmu_set_accessed_bit { ; } ;

struct ftrace_data_offsets_kvm_mmu_set_dirty_bit { ; } ;

struct ftrace_data_offsets_kvm_mmu_walker_error { ; } ;

struct ftrace_data_offsets_kvm_mmu_get_page { ; } ;

struct ftrace_data_offsets_kvm_mmu_sync_page { ; } ;

struct ftrace_data_offsets_kvm_mmu_unsync_page { ; } ;

struct ftrace_data_offsets_kvm_mmu_zap_page { ; } ;

struct kvm_rmap_desc { u64 * sptes [ 4 ] ; struct kvm_rmap_desc * more ; } ;

struct kvm_shadow_walk_iterator { u64 addr ; hpa_t shadow_addr ; int level ; u64 * sptep ; unsigned index ; } ;

struct kvm_unsync_walk { int ( * entry ) ( struct kvm_mmu_page * sp , struct kvm_unsync_walk * walk ) ; } ;

typedef int ( * mmu_parent_walk_fn ) ( struct kvm_vcpu * vcpu , struct kvm_mmu_page * sp ) ;
void kvm_mmu_set_nonpresent_ptes ( u64 trap_pte , u64 notrap_pte ) ;

void kvm_mmu_set_base_ptes ( u64 base_pte ) ;

void kvm_mmu_set_mask_ptes ( u64 user_mask , u64 accessed_mask , u64 dirty_mask , u64 nx_mask , u64 x_mask ) ;

int kvm_unmap_hva ( struct kvm * kvm , unsigned long hva ) ;

void kvm_set_spte_hva ( struct kvm * kvm , unsigned long hva , pte_t pte ) ;

int kvm_age_hva ( struct kvm * kvm , unsigned long hva ) ;

struct kvm_mmu_pages { struct mmu_page_and_offset { struct kvm_mmu_page * sp ; unsigned int idx ; } page [ 16 ] ; unsigned int nr ; } ;

struct mmu_page_path { struct kvm_mmu_page * parent [ 4 - 1 ] ; unsigned int idx [ 4 - 1 ] ; } ;

void kvm_mmu_change_mmu_pages ( struct kvm * kvm , unsigned int kvm_nr_mmu_pages ) ;

struct page * gva_to_page ( struct kvm_vcpu * vcpu , gva_t gva ) ;

u8 kvm_get_guest_memory_type ( struct kvm_vcpu * vcpu , gfn_t gfn ) ;

void kvm_mmu_sync_roots ( struct kvm_vcpu * vcpu ) ;

void kvm_mmu_flush_tlb ( struct kvm_vcpu * vcpu ) ;

struct guest_walker64 { int level ; gfn_t table_gfn [ 4 ] ; u64 ptes [ 4 ] ; gpa_t pte_gpa [ 4 ] ; unsigned pt_access ; unsigned pte_access ; gfn_t gfn ; u32 error_code ; } ;

struct guest_walker32 { int level ; gfn_t table_gfn [ 2 ] ; u32 ptes [ 2 ] ; gpa_t pte_gpa [ 2 ] ; unsigned pt_access ; unsigned pte_access ; gfn_t gfn ; u32 error_code ; } ;

int kvm_mmu_reset_context ( struct kvm_vcpu * vcpu ) ;

int kvm_mmu_load ( struct kvm_vcpu * vcpu ) ;

void kvm_mmu_unload ( struct kvm_vcpu * vcpu ) ;

void kvm_mmu_pte_write ( struct kvm_vcpu * vcpu , gpa_t gpa , const u8 * new , int bytes , bool guest_initiated ) ;

int kvm_mmu_unprotect_page_virt ( struct kvm_vcpu * vcpu , gva_t gva ) ;

void __kvm_mmu_free_some_pages ( struct kvm_vcpu * vcpu ) ;

int kvm_mmu_page_fault ( struct kvm_vcpu * vcpu , gva_t cr2 , u32 error_code ) ;

void kvm_mmu_invlpg ( struct kvm_vcpu * vcpu , gva_t gva ) ;

void kvm_enable_tdp ( void ) ;

void kvm_disable_tdp ( void ) ;

int kvm_mmu_create ( struct kvm_vcpu * vcpu ) ;

int kvm_mmu_setup ( struct kvm_vcpu * vcpu ) ;

void kvm_mmu_destroy ( struct kvm_vcpu * vcpu ) ;

void kvm_mmu_slot_remove_write_access ( struct kvm * kvm , int slot ) ;

void kvm_mmu_zap_all ( struct kvm * kvm ) ;

void kvm_mmu_module_exit ( void ) ;

int kvm_mmu_module_init ( void ) ;

unsigned int kvm_mmu_calculate_mmu_pages ( struct kvm * kvm ) ;

int kvm_pv_mmu_op ( struct kvm_vcpu * vcpu , unsigned long bytes , gpa_t addr , unsigned long * ret ) ;

int kvm_mmu_get_spte_hierarchy ( struct kvm_vcpu * vcpu , u64 addr , u64 sptes [ 4 ] ) ;

enum { Group1_80 , Group1_81 , Group1_82 , Group1_83 , Group1A , Group3_Byte , Group3 , Group4 , Group5 , Group7 , Group8 , Group9 , } ;
int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , struct x86_emulate_ops * ops ) ;

int x86_emulate_insn ( struct x86_emulate_ctxt * ctxt , struct x86_emulate_ops * ops ) ;

void kvm_pic_clear_isr_ack ( struct kvm * kvm ) ;

void kvm_pic_update_irq ( struct kvm_pic * s ) ;

int kvm_pic_set_irq ( void * opaque , int irq , int level ) ;

int kvm_pic_read_irq ( struct kvm * kvm ) ;

void kvm_pic_reset ( struct kvm_kpic_state * s ) ;

struct kvm_pic * kvm_create_pic ( struct kvm * kvm ) ;

int kvm_cpu_has_pending_timer ( struct kvm_vcpu * vcpu ) ;

int kvm_cpu_has_interrupt ( struct kvm_vcpu * v ) ;

int kvm_cpu_get_interrupt ( struct kvm_vcpu * v ) ;

void kvm_inject_pending_timer_irqs ( struct kvm_vcpu * vcpu ) ;

void __kvm_migrate_timers ( struct kvm_vcpu * vcpu ) ;

void kvm_apic_set_version ( struct kvm_vcpu * vcpu ) ;

int kvm_lapic_find_highest_irr ( struct kvm_vcpu * vcpu ) ;

int kvm_apic_set_irq ( struct kvm_vcpu * vcpu , struct kvm_lapic_irq * irq ) ;

int kvm_apic_match_physical_addr ( struct kvm_lapic * apic , u16 dest ) ;

int kvm_apic_match_logical_addr ( struct kvm_lapic * apic , u8 mda ) ;

int kvm_apic_match_dest ( struct kvm_vcpu * vcpu , struct kvm_lapic * source , int short_hand , int dest , int dest_mode ) ;

int kvm_apic_compare_prio ( struct kvm_vcpu * vcpu1 , struct kvm_vcpu * vcpu2 ) ;

void kvm_free_lapic ( struct kvm_vcpu * vcpu ) ;

void kvm_lapic_set_tpr ( struct kvm_vcpu * vcpu , unsigned long cr8 ) ;

u64 kvm_lapic_get_cr8 ( struct kvm_vcpu * vcpu ) ;

void kvm_lapic_set_base ( struct kvm_vcpu * vcpu , u64 value ) ;

void kvm_lapic_reset ( struct kvm_vcpu * vcpu ) ;

bool kvm_apic_present ( struct kvm_vcpu * vcpu ) ;

int kvm_lapic_enabled ( struct kvm_vcpu * vcpu ) ;

int apic_has_pending_timer ( struct kvm_vcpu * vcpu ) ;

void kvm_apic_nmi_wd_deliver ( struct kvm_vcpu * vcpu ) ;

int kvm_create_lapic ( struct kvm_vcpu * vcpu ) ;

int kvm_apic_has_interrupt ( struct kvm_vcpu * vcpu ) ;

int kvm_apic_accept_pic_intr ( struct kvm_vcpu * vcpu ) ;

void kvm_inject_apic_timer_irqs ( struct kvm_vcpu * vcpu ) ;

int kvm_get_apic_interrupt ( struct kvm_vcpu * vcpu ) ;

void kvm_apic_post_state_restore ( struct kvm_vcpu * vcpu ) ;

void __kvm_migrate_apic_timer ( struct kvm_vcpu * vcpu ) ;

void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) ;

void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) ;

void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) ;

int kvm_x2apic_msr_write ( struct kvm_vcpu * vcpu , u32 msr , u64 data ) ;

int kvm_x2apic_msr_read ( struct kvm_vcpu * vcpu , u32 msr , u64 * data ) ;

int pit_has_pending_timer ( struct kvm_vcpu * vcpu ) ;

void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) ;

void kvm_pit_load_count ( struct kvm * kvm , int channel , u32 val , int hpet_legacy_start ) ;

void kvm_pit_reset ( struct kvm_pit * pit ) ;

struct kvm_pit * kvm_create_pit ( struct kvm * kvm , u32 flags ) ;

void kvm_free_pit ( struct kvm * kvm ) ;

void kvm_inject_pit_timer_irqs ( struct kvm_vcpu * vcpu ) ;

enum hrtimer_restart kvm_timer_fn ( struct hrtimer * data ) ;

struct mmu_gather { struct mm_struct * mm ; unsigned int nr ; unsigned int need_flush ; unsigned int fullmm ; struct page * pages [ 506 ] ; } ;
struct map_range { unsigned long start ; unsigned long end ; unsigned page_size_mask ; } ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) init_memory_mapping ( unsigned long start , unsigned long end ) ;

int devmem_is_allowed ( unsigned long pagenr ) ;

void free_init_pages ( char * what , unsigned long begin , unsigned long end ) ;

void free_initmem ( void ) ;

void free_initrd_mem ( unsigned long start , unsigned long end ) ;

void set_pte_vaddr_pud ( pud_t * pud_page , unsigned long vaddr , pte_t new_pte ) ;

void set_pte_vaddr ( unsigned long vaddr , pte_t pteval ) ;

pmd_t * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) populate_extra_pmd ( unsigned long vaddr ) ;

pte_t * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) populate_extra_pte ( unsigned long vaddr ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_extra_mapping_wb ( unsigned long phys , unsigned long size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_extra_mapping_uc ( unsigned long phys , unsigned long size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) cleanup_highmap ( void ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) kernel_physical_mapping_init ( unsigned long start , unsigned long end , unsigned long page_size_mask ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) paging_init ( void ) ;

int arch_add_memory ( int nid , u64 start , u64 size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mem_init ( void ) ;

void set_kernel_text_rw ( void ) ;

void set_kernel_text_ro ( void ) ;

void mark_rodata_ro ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_bootmem_generic ( unsigned long phys , unsigned long len , int flags ) ;

int kern_addr_valid ( unsigned long addr ) ;

struct vm_area_struct * get_gate_vma ( struct task_struct * tsk ) ;

int in_gate_area ( struct task_struct * task , unsigned long addr ) ;

int in_gate_area_no_task ( unsigned long addr ) ;

const char * arch_vma_name ( struct vm_area_struct * vma ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_populate ( struct page * start_page , unsigned long size , int node ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_populate_print_last ( void ) ;

struct kmmio_probe ;

typedef void ( * kmmio_pre_handler_t ) ( struct kmmio_probe * , struct pt_regs * , unsigned long addr ) ;
typedef void ( * kmmio_post_handler_t ) ( struct kmmio_probe * , unsigned long condition , struct pt_regs * ) ;
struct kmmio_probe { struct list_head list ; unsigned long addr ; unsigned long len ; kmmio_pre_handler_t pre_handler ; kmmio_post_handler_t post_handler ; void * private ; } ;
enum mm_io_opcode { MMIO_READ = 0x1 , MMIO_WRITE = 0x2 , MMIO_PROBE = 0x3 , MMIO_UNPROBE = 0x4 , MMIO_UNKNOWN_OP = 0x5 , } ;

struct mmiotrace_rw { resource_size_t phys ; unsigned long value ; unsigned long pc ; int map_id ; unsigned char opcode ; unsigned char width ; } ;

struct mmiotrace_map { resource_size_t phys ; unsigned long virt ; unsigned long len ; int map_id ; unsigned char opcode ; } ;

enum x86_pf_error_code { PF_PROT = 1 << 0 , PF_WRITE = 1 << 1 , PF_USER = 1 << 2 , PF_RSVD = 1 << 3 , PF_INSTR = 1 << 4 , } ;

int register_page_fault_notifier ( struct notifier_block * nb ) ;

int unregister_page_fault_notifier ( struct notifier_block * nb ) ;

void vmalloc_sync_all ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) do_page_fault ( struct pt_regs * regs , unsigned long error_code ) ;

int page_is_ram ( unsigned long pagenr ) ;

int ioremap_change_attr ( unsigned long vaddr , unsigned long size , unsigned long prot_val ) ;

void * ioremap_nocache ( resource_size_t phys_addr , unsigned long size ) ;

void * ioremap_wc ( resource_size_t phys_addr , unsigned long size ) ;

void * ioremap_cache ( resource_size_t phys_addr , unsigned long size ) ;

void * ioremap_prot ( resource_size_t phys_addr , unsigned long size , unsigned long prot_val ) ;

void iounmap ( volatile void * addr ) ;

void * xlate_dev_mem_ptr ( unsigned long phys ) ;

void unxlate_dev_mem_ptr ( unsigned long phys , void * addr ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_ioremap_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_ioremap_reset ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) * early_ioremap ( resource_size_t phys_addr , unsigned long size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) * early_memremap ( resource_size_t phys_addr , unsigned long size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_iounmap ( void * addr , unsigned long size ) ;

int fixup_exception ( struct pt_regs * regs ) ;

const struct exception_table_entry * search_extable ( const struct exception_table_entry * first , const struct exception_table_entry * last , unsigned long value ) ;

struct cpa_data { unsigned long * vaddr ; pgprot_t mask_set ; pgprot_t mask_clr ; int numpages ; int flags ; unsigned long pfn ; unsigned force_split : 1 ; int curpage ; struct page * * pages ; } ;

void update_page_count ( int level , unsigned long pages ) ;

void arch_report_meminfo ( struct seq_file * m ) ;

void clflush_cache_range ( void * vaddr , unsigned int size ) ;

pte_t * lookup_address ( unsigned long address , unsigned int * level ) ;

int _set_memory_uc ( unsigned long addr , int numpages ) ;

int set_memory_uc ( unsigned long addr , int numpages ) ;

int set_memory_array_uc ( unsigned long * addr , int addrinarray ) ;

int _set_memory_wc ( unsigned long addr , int numpages ) ;

int set_memory_wc ( unsigned long addr , int numpages ) ;

int _set_memory_wb ( unsigned long addr , int numpages ) ;

int set_memory_wb ( unsigned long addr , int numpages ) ;

int set_memory_array_wb ( unsigned long * addr , int addrinarray ) ;

int set_memory_x ( unsigned long addr , int numpages ) ;

int set_memory_nx ( unsigned long addr , int numpages ) ;

int set_memory_ro ( unsigned long addr , int numpages ) ;

int set_memory_rw ( unsigned long addr , int numpages ) ;

int set_memory_np ( unsigned long addr , int numpages ) ;

int set_memory_4k ( unsigned long addr , int numpages ) ;

int set_pages_uc ( struct page * page , int numpages ) ;

int set_pages_array_uc ( struct page * * pages , int addrinarray ) ;

int set_pages_wb ( struct page * page , int numpages ) ;

int set_pages_array_wb ( struct page * * pages , int addrinarray ) ;

int set_pages_x ( struct page * page , int numpages ) ;

int set_pages_nx ( struct page * page , int numpages ) ;

int set_pages_ro ( struct page * page , int numpages ) ;

int set_pages_rw ( struct page * page , int numpages ) ;

void arch_pick_mmap_layout ( struct mm_struct * mm ) ;

enum { PAT_UC = 0 , PAT_WC = 1 , PAT_WT = 4 , PAT_WP = 5 , PAT_WB = 6 , PAT_UC_MINUS = 7 , } ;
void pat_init ( void ) ;

struct memtype { u64 start ; u64 end ; unsigned long type ; struct list_head nd ; struct rb_node rb ; } ;

int reserve_memtype ( u64 start , u64 end , unsigned long req_type , unsigned long * new_type ) ;

int free_memtype ( u64 start , u64 end ) ;

int io_reserve_memtype ( resource_size_t start , resource_size_t end , unsigned long * type ) ;

void io_free_memtype ( resource_size_t start , resource_size_t end ) ;

pgprot_t phys_mem_access_prot ( struct file * file , unsigned long pfn , unsigned long size , pgprot_t vma_prot ) ;

int phys_mem_access_prot_allowed ( struct file * file , unsigned long pfn , unsigned long size , pgprot_t * vma_prot ) ;

int kernel_map_sync_memtype ( u64 base , unsigned long size , unsigned long flags ) ;

int track_pfn_vma_copy ( struct vm_area_struct * vma ) ;

int track_pfn_vma_new ( struct vm_area_struct * vma , pgprot_t * prot , unsigned long pfn , unsigned long size ) ;

void untrack_pfn_vma ( struct vm_area_struct * vma , unsigned long pfn , unsigned long size ) ;

pgprot_t pgprot_writecombine ( pgprot_t prot ) ;

pte_t * pte_alloc_one_kernel ( struct mm_struct * mm , unsigned long address ) ;

pgtable_t pte_alloc_one ( struct mm_struct * mm , unsigned long address ) ;

void ___pte_free_tlb ( struct mmu_gather * tlb , struct page * pte ) ;

void ___pmd_free_tlb ( struct mmu_gather * tlb , pmd_t * pmd ) ;

void ___pud_free_tlb ( struct mmu_gather * tlb , pud_t * pud ) ;

pgd_t * pgd_alloc ( struct mm_struct * mm ) ;

void pgd_free ( struct mm_struct * mm , pgd_t * pgd ) ;

int ptep_set_access_flags ( struct vm_area_struct * vma , unsigned long address , pte_t * ptep , pte_t entry , int dirty ) ;

int ptep_test_and_clear_young ( struct vm_area_struct * vma , unsigned long addr , pte_t * ptep ) ;

int ptep_clear_flush_young ( struct vm_area_struct * vma , unsigned long address , pte_t * ptep ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_top_address ( unsigned long reserve ) ;

void __native_set_fixmap ( enum fixed_addresses idx , pte_t pte ) ;

void native_set_fixmap ( enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) ;

unsigned long __phys_addr ( unsigned long x ) ;

bool __virt_addr_valid ( unsigned long x ) ;

int __get_user_pages_fast ( unsigned long start , int nr_pages , int write , struct page * * pages ) ;

int get_user_pages_fast ( unsigned long start , int nr_pages , int write , struct page * * pages ) ;

void set_nx ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) check_efer ( void ) ;

union smp_flush_state { struct { struct mm_struct * flush_mm ; unsigned long flush_va ; spinlock_t tlbstate_lock ; unsigned long flush_cpumask [ ( ( ( 64 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ; char pad [ 64 ] ; } __attribute__ ( ( __aligned__ ( 1 << ( ( 6 ) ) ) ) ) ;
void leave_mm ( int cpu ) ;

void smp_invalidate_interrupt ( struct pt_regs * regs ) ;

void native_flush_tlb_others ( const struct cpumask * cpumask , struct mm_struct * mm , unsigned long va ) ;

void flush_tlb_current_task ( void ) ;

void flush_tlb_mm ( struct mm_struct * mm ) ;

void flush_tlb_page ( struct vm_area_struct * vma , unsigned long va ) ;

void flush_tlb_all ( void ) ;

int huge_pmd_unshare ( struct mm_struct * mm , unsigned long * addr , pte_t * ptep ) ;

pte_t * huge_pte_alloc ( struct mm_struct * mm , unsigned long addr , unsigned long sz ) ;

pte_t * huge_pte_offset ( struct mm_struct * mm , unsigned long addr ) ;

struct page * follow_huge_addr ( struct mm_struct * mm , unsigned long address , int write ) ;

int pmd_huge ( pmd_t pmd ) ;

int pud_huge ( pud_t pud ) ;

struct page * follow_huge_pmd ( struct mm_struct * mm , unsigned long address , pmd_t * pmd , int write ) ;

struct page * follow_huge_pud ( struct mm_struct * mm , unsigned long address , pud_t * pud , int write ) ;

struct kmmio_fault_page { struct list_head list ; struct kmmio_fault_page * release_next ; unsigned long page ; pteval_t old_presence ; bool armed ; int count ; } ;

struct kmmio_delayed_release { struct rcu_head rcu ; struct kmmio_fault_page * release_list ; } ;

struct kmmio_context { struct kmmio_fault_page * fpage ; struct kmmio_probe * probe ; unsigned long saved_flags ; unsigned long addr ; int active ; } ;

int kmmio_handler ( struct pt_regs * regs , unsigned long addr ) ;

int register_kmmio_probe ( struct kmmio_probe * p ) ;

void unregister_kmmio_probe ( struct kmmio_probe * p ) ;

int kmmio_init ( void ) ;

void kmmio_cleanup ( void ) ;

enum reason_type { NOT_ME , NOTHING , REG_READ , REG_WRITE , IMM_WRITE , OTHERS } ;

struct prefix_bits { unsigned shorted : 1 ; unsigned enlarged : 1 ; unsigned rexr : 1 ; unsigned rex : 1 ; } ;

enum reason_type get_ins_type ( unsigned long ins_addr ) ;

unsigned int get_ins_mem_width ( unsigned long ins_addr ) ;

enum { arg_AL = 0 , arg_CL = 1 , arg_DL = 2 , arg_BL = 3 , arg_AH = 4 , arg_CH = 5 , arg_DH = 6 , arg_BH = 7 , arg_AX = 0 , arg_CX = 1 , arg_DX = 2 , arg_BX = 3 , arg_SP = 4 , arg_BP = 5 , arg_SI = 6 , arg_DI = 7 , arg_R8 = 8 , arg_R9 = 9 , arg_R10 = 10 , arg_R11 = 11 , arg_R12 = 12 , arg_R13 = 13 , arg_R14 = 14 , arg_R15 = 15 } ;
unsigned long get_ins_reg_val ( unsigned long ins_addr , struct pt_regs * regs ) ;

unsigned long get_ins_imm_val ( unsigned long ins_addr ) ;

struct trap_reason { unsigned long addr ; unsigned long ip ; enum reason_type type ; int active_traces ; } ;

struct remap_trace { struct list_head list ; struct kmmio_probe probe ; resource_size_t phys ; unsigned long id ; } ;

void mmiotrace_ioremap ( resource_size_t offset , unsigned long size , void * addr ) ;

void mmiotrace_iounmap ( volatile void * addr ) ;

int mmiotrace_printk ( const char * fmt , ... ) ;

void enable_mmiotrace ( void ) ;

void disable_mmiotrace ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_node_to_cpumask_map ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) compute_hash_shift ( struct bootnode * nodes , int numnodes , int * nodeids ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __early_pfn_to_nid ( unsigned long pfn ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_node_bootmem ( int nodeid , unsigned long start , unsigned long end ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) numa_init_array ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) initmem_init ( unsigned long start_pfn , unsigned long last_pfn ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) numa_free_all_bootmem ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_cpu_to_node ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) numa_set_node ( int cpu , int node ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) numa_clear_node ( int cpu ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) numa_add_cpu ( int cpu ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) numa_remove_cpu ( int cpu ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) k8_scan_nodes ( unsigned long start , unsigned long end ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_numa_slit_init ( struct acpi_table_slit * slit ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_numa_x2apic_affinity_init ( struct acpi_srat_x2apic_cpu_affinity * pa ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_numa_processor_affinity_init ( struct acpi_srat_cpu_affinity * pa ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_numa_memory_affinity_init ( struct acpi_srat_mem_affinity * ma ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_numa_arch_fixup ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_scan_nodes ( unsigned long start , unsigned long end ) ;

int __node_distance ( int a , int b ) ;

int memory_add_physaddr_to_nid ( u64 start ) ;

int arch_setup_additional_pages ( struct linux_binprm * bprm , int uses_interp ) ;

union cpu_time_count { cputime_t cpu ; unsigned long long sched ; } ;

struct cpu_timer_list { struct list_head entry ; union cpu_time_count expires , incr ; struct task_struct * task ; int firing ; } ;

struct k_itimer { struct list_head list ; spinlock_t it_lock ; clockid_t it_clock ; timer_t it_id ; int it_overrun ; int it_overrun_last ; int it_requeue_pending ; int it_sigev_notify ; struct signal_struct * it_signal ; union { struct pid * it_pid ; struct task_struct * it_process ; } ; struct sigqueue * sigq ; union { struct { struct hrtimer timer ; ktime_t interval ; } real ; struct cpu_timer_list cpu ; struct { unsigned int clock ; unsigned int node ; unsigned long incr ; unsigned long expires ; } mmtimer ; } it ; } ;

struct k_clock { int res ; int ( * clock_getres ) ( const clockid_t which_clock , struct timespec * tp ) ; int ( * clock_set ) ( const clockid_t which_clock , struct timespec * tp ) ; int ( * clock_get ) ( const clockid_t which_clock , struct timespec * tp ) ; int ( * timer_create ) ( struct k_itimer * timer ) ; int ( * nsleep ) ( const clockid_t which_clock , int flags , struct timespec * , struct timespec * ) ; long ( * nsleep_restart ) ( struct restart_block * restart_block ) ; int ( * timer_set ) ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) ; int ( * timer_del ) ( struct k_itimer * timr ) ; void ( * timer_get ) ( struct k_itimer * timr , struct itimerspec * cur_setting ) ; } ;

__attribute__ ( ( no_instrument_function ) ) int __vdso_clock_gettime ( clockid_t clock , struct timespec * ts ) ;

__attribute__ ( ( no_instrument_function ) ) int __vdso_gettimeofday ( struct timeval * tv , struct timezone * tz ) ;

__attribute__ ( ( no_instrument_function ) ) long __vdso_getcpu ( unsigned * cpu , unsigned * node , struct getcpu_cache * unused ) ;

enum { VDSO_DISABLED = 0 , VDSO_ENABLED = 1 , VDSO_COMPAT = 2 , } ;
void syscall32_cpu_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sysenter_setup ( void ) ;

int syscall32_setup_pages ( struct linux_binprm * bprm , int uses_interp ) ;

struct xen_extraversion { char extraversion [ 16 ] ; } ;

struct xen_compile_info { char compiler [ 64 ] ; char compile_by [ 16 ] ; char compile_domain [ 32 ] ; char compile_date [ 32 ] ; } ;

struct xen_capabilities_info { char info [ 1024 ] ; } ;

struct xen_changeset_info { char info [ 64 ] ; } ;

struct xen_platform_parameters { unsigned long virt_start ; } ;

struct xen_feature_info { unsigned int submap_idx ; uint32_t submap ; } ;

struct physdev_eoi { uint32_t irq ; } ;

struct physdev_irq_status_query { uint32_t irq ; uint32_t flags ; } ;

struct physdev_set_iopl { uint32_t iopl ; } ;

struct physdev_set_iobitmap { uint8_t * bitmap ; uint32_t nr_ports ; } ;

struct physdev_apic { unsigned long apic_physbase ; uint32_t reg ; uint32_t value ; } ;

struct physdev_irq { uint32_t irq ; uint32_t vector ; } ;

struct physdev_op { uint32_t cmd ; union { struct physdev_irq_status_query irq_status_query ; struct physdev_set_iopl set_iopl ; struct physdev_set_iobitmap set_iobitmap ; struct physdev_apic apic_op ; struct physdev_irq irq_op ; } u ; } ;

struct vcpu_runstate_info { int state ; uint64_t state_entry_time ; uint64_t time [ 4 ] ; } ;

typedef struct vcpu_runstate_info * __guest_handle_vcpu_runstate_info ;

struct vcpu_register_runstate_memory_area { union { __guest_handle_vcpu_runstate_info h ; struct vcpu_runstate_info * v ; uint64_t p ; } addr ; } ;

struct vcpu_set_periodic_timer { uint64_t period_ns ; } ;

typedef struct vcpu_set_periodic_timer * __guest_handle_vcpu_set_periodic_timer ;

struct vcpu_set_singleshot_timer { uint64_t timeout_abs_ns ; uint32_t flags ; } ;

typedef struct vcpu_set_singleshot_timer * __guest_handle_vcpu_set_singleshot_timer ;

struct vcpu_register_vcpu_info { uint64_t mfn ; uint32_t offset ; uint32_t rsvd ; } ;

typedef struct vcpu_register_vcpu_info * __guest_handle_vcpu_register_vcpu_info ;


typedef struct xmaddr { phys_addr_t maddr ; } xmaddr_t ;


typedef struct xpaddr { phys_addr_t paddr ; } xpaddr_t ;

typedef uint32_t evtchn_port_t ;

typedef evtchn_port_t * __guest_handle_evtchn_port_t ;

struct evtchn_alloc_unbound { domid_t dom , remote_dom ; evtchn_port_t port ; } ;

struct evtchn_bind_interdomain { domid_t remote_dom ; evtchn_port_t remote_port ; evtchn_port_t local_port ; } ;

struct evtchn_bind_virq { uint32_t virq ; uint32_t vcpu ; evtchn_port_t port ; } ;

struct evtchn_bind_pirq { uint32_t pirq ; uint32_t flags ; evtchn_port_t port ; } ;

struct evtchn_bind_ipi { uint32_t vcpu ; evtchn_port_t port ; } ;

struct evtchn_close { evtchn_port_t port ; } ;

struct evtchn_send { evtchn_port_t port ; } ;

struct evtchn_status { domid_t dom ; evtchn_port_t port ; uint32_t status ; uint32_t vcpu ; union { struct { domid_t dom ; } unbound ; struct { domid_t dom ; evtchn_port_t port ; } interdomain ; uint32_t pirq ; uint32_t virq ; } u ; } ;

struct evtchn_bind_vcpu { evtchn_port_t port ; uint32_t vcpu ; } ;

struct evtchn_unmask { evtchn_port_t port ; } ;

struct evtchn_op { uint32_t cmd ; union { struct evtchn_alloc_unbound alloc_unbound ; struct evtchn_bind_interdomain bind_interdomain ; struct evtchn_bind_virq bind_virq ; struct evtchn_bind_pirq bind_pirq ; struct evtchn_bind_ipi bind_ipi ; struct evtchn_close close ; struct evtchn_send send ; struct evtchn_status status ; struct evtchn_bind_vcpu bind_vcpu ; struct evtchn_unmask unmask ; } u ; } ;

typedef struct evtchn_op * __guest_handle_evtchn_op ;

struct sched_shutdown { unsigned int reason ; } ;

typedef struct sched_shutdown * __guest_handle_sched_shutdown ;

struct sched_poll { __guest_handle_evtchn_port_t ports ; unsigned int nr_ports ; uint64_t timeout ; } ;

typedef struct sched_poll * __guest_handle_sched_poll ;

enum xen_domain_type { XEN_NATIVE , XEN_PV_DOMAIN , XEN_HVM_DOMAIN , } ;

struct trap_info ;
enum pt_level { PT_PGD , PT_PUD , PT_PMD , PT_PTE } ;

struct multicall_space { struct multicall_entry * mc ; void * args ; } ;

void xen_vcpu_restore ( void ) ;

void xen_copy_trap_info ( struct trap_info * traps ) ;

void xen_setup_shared_info ( void ) ;

void xen_setup_vcpu_info_placement ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_start_kernel ( void ) ;

struct callback_register { uint16_t type ; uint16_t flags ; xen_callback_t address ; } ;

struct callback_unregister { uint16_t type ; uint16_t _unused ; } ;

char * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_memory_setup ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) xen_enable_sysenter ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) xen_enable_syscall ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_arch_setup ( void ) ;

struct mc_buffer { struct multicall_entry entries [ 32 ] ; struct multicall_entry debug [ 32 ] ; void * caller [ 32 ] ; unsigned char args [ ( 32 * 16 ) ] ; struct callback { void ( * fn ) ( void * ) ; void * data ; } callbacks [ 32 ] ; unsigned mcidx , argidx , cbidx ; } ;

enum flush_reasons { FL_SLOTS , FL_ARGS , FL_CALLBACKS , FL_N_REASONS } ;

void xen_mc_flush ( void ) ;

struct multicall_space __xen_mc_entry ( size_t args ) ;

struct multicall_space xen_mc_extend_args ( unsigned long op , size_t size ) ;

void xen_mc_callback ( void ( * fn ) ( void * ) , void * data ) ;

void xen_build_mfn_list_list ( void ) ;

void xen_setup_mfn_list_list ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_build_dynamic_phys_to_machine ( void ) ;

unsigned long get_phys_to_machine ( unsigned long pfn ) ;

bool install_p2mtop_page ( unsigned long pfn , unsigned long * p ) ;

bool __set_phys_to_machine ( unsigned long pfn , unsigned long mfn ) ;

void set_phys_to_machine ( unsigned long pfn , unsigned long mfn ) ;

unsigned long arbitrary_virt_to_mfn ( void * vaddr ) ;

xmaddr_t arbitrary_virt_to_machine ( void * vaddr ) ;

void make_lowmem_page_readonly ( void * vaddr ) ;

void make_lowmem_page_readwrite ( void * vaddr ) ;

void xen_set_pmd_hyper ( pmd_t * ptr , pmd_t val ) ;

void xen_set_pmd ( pmd_t * ptr , pmd_t val ) ;

void set_pte_mfn ( unsigned long vaddr , unsigned long mfn , pgprot_t flags ) ;

void xen_set_pte_at ( struct mm_struct * mm , unsigned long addr , pte_t * ptep , pte_t pteval ) ;

pte_t xen_ptep_modify_prot_start ( struct mm_struct * mm , unsigned long addr , pte_t * ptep ) ;

void xen_ptep_modify_prot_commit ( struct mm_struct * mm , unsigned long addr , pte_t * ptep , pte_t pte ) ;

pteval_t xen_pte_val ( pte_t pte ) ;

pgdval_t xen_pgd_val ( pgd_t pgd ) ;

pte_t xen_make_pte ( pteval_t pte ) ;

pgd_t xen_make_pgd ( pgdval_t pgd ) ;

pmdval_t xen_pmd_val ( pmd_t pmd ) ;

void xen_set_pud_hyper ( pud_t * ptr , pud_t val ) ;

void xen_set_pud ( pud_t * ptr , pud_t val ) ;

void xen_set_pte ( pte_t * ptep , pte_t pte ) ;

pmd_t xen_make_pmd ( pmdval_t pmd ) ;

pudval_t xen_pud_val ( pud_t pud ) ;

pud_t xen_make_pud ( pudval_t pud ) ;

pgd_t * xen_get_user_pgd ( pgd_t * pgd ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_set_pgd_hyper ( pgd_t * ptr , pgd_t val ) ;

void xen_set_pgd ( pgd_t * ptr , pgd_t val ) ;

void xen_mm_pin_all ( void ) ;

void xen_mm_unpin_all ( void ) ;

void xen_activate_mm ( struct mm_struct * prev , struct mm_struct * next ) ;

void xen_dup_mmap ( struct mm_struct * oldmm , struct mm_struct * mm ) ;

void xen_exit_mmap ( struct mm_struct * mm ) ;

unsigned long xen_read_cr2_direct ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_reserve_top ( void ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pgd_t * xen_setup_kernel_pagetable ( pgd_t * pgd , unsigned long max_pfn ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_init_mmu_ops ( void ) ;

void xen_force_evtchn_callback ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_init_irq_ops ( ) ;

enum ipi_vector { XEN_RESCHEDULE_VECTOR , XEN_CALL_FUNCTION_VECTOR , XEN_CALL_FUNCTION_SINGLE_VECTOR , XEN_SPIN_UNLOCK_VECTOR , XEN_NR_IPIS , } ;

bool xen_vcpu_stolen ( int vcpu ) ;

void xen_setup_runstate_info ( int cpu ) ;

unsigned long xen_tsc_khz ( void ) ;

cycle_t xen_clocksource_read ( void ) ;

unsigned long xen_get_wallclock ( void ) ;

int xen_set_wallclock ( unsigned long now ) ;

void xen_setup_timer ( int cpu ) ;

void xen_teardown_timer ( int cpu ) ;

void xen_setup_cpu_clockevents ( void ) ;

void xen_timer_resume ( void ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) void xen_time_init ( void ) ;

struct grant_entry { uint16_t flags ; domid_t domid ; uint32_t frame ; } ;

typedef uint32_t grant_ref_t ;

typedef uint32_t grant_handle_t ;

struct gnttab_map_grant_ref { uint64_t host_addr ; uint32_t flags ; grant_ref_t ref ; domid_t dom ; int16_t status ; grant_handle_t handle ; uint64_t dev_bus_addr ; } ;

typedef struct gnttab_map_grant_ref * __guest_handle_gnttab_map_grant_ref ;

struct gnttab_unmap_grant_ref { uint64_t host_addr ; uint64_t dev_bus_addr ; grant_handle_t handle ; int16_t status ; } ;

typedef struct gnttab_unmap_grant_ref * __guest_handle_gnttab_unmap_grant_ref ;

struct gnttab_setup_table { domid_t dom ; uint32_t nr_frames ; int16_t status ; __guest_handle_ulong frame_list ; } ;

typedef struct gnttab_setup_table * __guest_handle_gnttab_setup_table ;

struct gnttab_dump_table { domid_t dom ; int16_t status ; } ;

typedef struct gnttab_dump_table * __guest_handle_gnttab_dump_table ;

struct gnttab_transfer { unsigned long mfn ; domid_t domid ; grant_ref_t ref ; int16_t status ; } ;

typedef struct gnttab_transfer * __guest_handle_gnttab_transfer ;

struct gnttab_copy { struct { union { grant_ref_t ref ; unsigned long gmfn ; } u ; domid_t domid ; uint16_t offset ; } source , dest ; uint16_t len ; uint16_t flags ; int16_t status ; } ;

typedef struct gnttab_copy * __guest_handle_gnttab_copy ;

struct gnttab_query_size { domid_t dom ; uint32_t nr_frames ; uint32_t max_nr_frames ; int16_t status ; } ;

typedef struct gnttab_query_size * __guest_handle_gnttab_query_size ;

struct gnttab_free_callback { struct gnttab_free_callback * next ; void ( * fn ) ( void * ) ; void * arg ; u16 count ; } ;

int arch_gnttab_map_shared ( unsigned long * frames , unsigned long nr_gframes , unsigned long max_nr_gframes , struct grant_entry * * __shared ) ;

void arch_gnttab_unmap_shared ( struct grant_entry * shared , unsigned long nr_gframes ) ;

void xen_pre_suspend ( void ) ;

void xen_post_suspend ( int suspend_cancelled ) ;

void xen_arch_resume ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_smp_init ( void ) ;

struct xen_spinlock { unsigned char lock ; unsigned short spinners ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) xen_init_lock_cpu ( int cpu ) ;

void xen_uninit_lock_cpu ( int cpu ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_init_spinlocks ( void ) ;

struct cpupri_vec { spinlock_t lock ; int count ; cpumask_var_t mask ; } ;

struct cpupri { struct cpupri_vec pri_to_cpu [ ( 100 + 2 ) ] ; long pri_active [ ( ( ( ( 100 + 2 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; int cpu_to_pri [ 64 ] ; } ;

struct ftrace_raw_sched_kthread_stop { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_kthread_stop_ret { struct trace_entry ent ; int ret ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_wait_task { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; int prio ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_wakeup { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; int prio ; int success ; int cpu ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_wakeup_new { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; int prio ; int success ; int cpu ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_switch { struct trace_entry ent ; char prev_comm [ 16 ] ; pid_t prev_pid ; int prev_prio ; long prev_state ; char next_comm [ 16 ] ; pid_t next_pid ; int next_prio ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_migrate_task { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; int prio ; int orig_cpu ; int dest_cpu ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_process_free { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; int prio ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_process_exit { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; int prio ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_process_wait { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; int prio ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_process_fork { struct trace_entry ent ; char parent_comm [ 16 ] ; pid_t parent_pid ; char child_comm [ 16 ] ; pid_t child_pid ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_signal_send { struct trace_entry ent ; int sig ; char comm [ 16 ] ; pid_t pid ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_stat_wait { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; u64 delay ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_stat_runtime { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; u64 runtime ; u64 vruntime ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_stat_sleep { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; u64 delay ; char __data [ 0 ] ; } ;

struct ftrace_raw_sched_stat_iowait { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; u64 delay ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_sched_kthread_stop { ; } ;

struct ftrace_data_offsets_sched_kthread_stop_ret { ; } ;

struct ftrace_data_offsets_sched_wait_task { ; } ;

struct ftrace_data_offsets_sched_wakeup { ; } ;

struct ftrace_data_offsets_sched_wakeup_new { ; } ;

struct ftrace_data_offsets_sched_switch { ; } ;

struct ftrace_data_offsets_sched_migrate_task { ; } ;

struct ftrace_data_offsets_sched_process_free { ; } ;

struct ftrace_data_offsets_sched_process_exit { ; } ;

struct ftrace_data_offsets_sched_process_wait { ; } ;

struct ftrace_data_offsets_sched_process_fork { ; } ;

struct ftrace_data_offsets_sched_signal_send { ; } ;

struct ftrace_data_offsets_sched_stat_wait { ; } ;

struct ftrace_data_offsets_sched_stat_runtime { ; } ;

struct ftrace_data_offsets_sched_stat_sleep { ; } ;

struct ftrace_data_offsets_sched_stat_iowait { ; } ;

struct rt_prio_array { unsigned long bitmap [ ( ( ( 100 + 1 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; struct list_head queue [ 100 ] ; } ;

struct rt_bandwidth { spinlock_t rt_runtime_lock ; ktime_t rt_period ; u64 rt_runtime ; struct hrtimer rt_period_timer ; } ;

struct task_group { struct cgroup_subsys_state css ; struct sched_entity * * se ; struct cfs_rq * * cfs_rq ; unsigned long shares ; struct sched_rt_entity * * rt_se ; struct rt_rq * * rt_rq ; struct rt_bandwidth rt_bandwidth ; struct rcu_head rcu ; struct list_head list ; struct task_group * parent ; struct list_head siblings ; struct list_head children ; } ;
struct cfs_rq { struct load_weight load ; unsigned long nr_running ; u64 exec_clock ; u64 min_vruntime ; struct rb_root tasks_timeline ; struct rb_node * rb_leftmost ; struct list_head tasks ; struct list_head * balance_iterator ; struct sched_entity * curr , * next , * last ; unsigned int nr_spread_over ; struct rq * rq ; struct list_head leaf_cfs_rq_list ; struct task_group * tg ; unsigned long task_weight ; unsigned long h_load ; unsigned long shares ; unsigned long rq_weight ; } ;
struct rt_rq { struct rt_prio_array active ; unsigned long rt_nr_running ; struct { int curr ; int next ; } highest_prio ; unsigned long rt_nr_migratory ; unsigned long rt_nr_total ; int overloaded ; struct plist_head pushable_tasks ; int rt_throttled ; u64 rt_time ; u64 rt_runtime ; spinlock_t rt_runtime_lock ; unsigned long rt_nr_boosted ; struct rq * rq ; struct list_head leaf_rt_rq_list ; struct task_group * tg ; struct sched_rt_entity * rt_se ; } ;

struct root_domain { atomic_t refcount ; cpumask_var_t span ; cpumask_var_t online ; cpumask_var_t rto_mask ; atomic_t rto_count ; struct cpupri cpupri ; } ;

struct rq { spinlock_t lock ; unsigned long nr_running ; unsigned long cpu_load [ 5 ] ; unsigned long last_tick_seen ; unsigned char in_nohz_recently ; struct load_weight load ; unsigned long nr_load_updates ; u64 nr_switches ; u64 nr_migrations_in ; struct cfs_rq cfs ; struct rt_rq rt ; struct list_head leaf_cfs_rq_list ; struct list_head leaf_rt_rq_list ; unsigned long nr_uninterruptible ; struct task_struct * curr , * idle ; unsigned long next_balance ; struct mm_struct * prev_mm ; u64 clock ; atomic_t nr_iowait ; struct root_domain * rd ; struct sched_domain * sd ; unsigned char idle_at_tick ; int post_schedule ; int active_balance ; int push_cpu ; int cpu ; int online ; unsigned long avg_load_per_task ; struct task_struct * migration_thread ; struct list_head migration_queue ; u64 rt_avg ; u64 age_stamp ; u64 idle_stamp ; u64 avg_idle ; unsigned long calc_load_update ; long calc_load_active ; int hrtick_csd_pending ; struct call_single_data hrtick_csd ; struct hrtimer hrtick_timer ; struct sched_info rq_sched_info ; unsigned long long rq_cpu_time ; unsigned int yld_count ; unsigned int sched_switch ; unsigned int sched_count ; unsigned int sched_goidle ; unsigned int ttwu_count ; unsigned int ttwu_local ; unsigned int bkl_count ; } ;
int runqueue_is_locked ( int cpu ) ;

enum { __SCHED_FEAT_FAIR_SLEEPERS , __SCHED_FEAT_GENTLE_FAIR_SLEEPERS , __SCHED_FEAT_NORMALIZED_SLEEPER , __SCHED_FEAT_START_DEBIT , __SCHED_FEAT_WAKEUP_PREEMPT , __SCHED_FEAT_ADAPTIVE_GRAN , __SCHED_FEAT_ASYM_GRAN , __SCHED_FEAT_WAKEUP_SYNC , __SCHED_FEAT_WAKEUP_OVERLAP , __SCHED_FEAT_WAKEUP_RUNNING , __SCHED_FEAT_SYNC_WAKEUPS , __SCHED_FEAT_AFFINE_WAKEUPS , __SCHED_FEAT_SYNC_LESS , __SCHED_FEAT_SYNC_MORE , __SCHED_FEAT_NEXT_BUDDY , __SCHED_FEAT_LAST_BUDDY , __SCHED_FEAT_CACHE_HOT_BUDDY , __SCHED_FEAT_ARCH_POWER , __SCHED_FEAT_HRTICK , __SCHED_FEAT_DOUBLE_TICK , __SCHED_FEAT_LB_BIAS , __SCHED_FEAT_LB_SHARES_UPDATE , __SCHED_FEAT_ASYM_EFF_LOAD , __SCHED_FEAT_OWNER_SPIN , } ;
void task_rq_unlock_wait ( struct task_struct * p ) ;

void wake_up_idle_cpu ( int cpu ) ;

struct rq_iterator { void * arg ; struct task_struct * ( * start ) ( void * ) ; struct task_struct * ( * next ) ( void * ) ; } ;

enum cpuacct_stat_index { CPUACCT_STAT_USER , CPUACCT_STAT_SYSTEM , CPUACCT_STAT_NSTATS , } ;

typedef int ( * tg_visitor ) ( struct task_group * , void * ) ;
unsigned int get_rr_interval_idle ( struct task_struct * task ) ;

int sched_nr_latency_handler ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

unsigned int get_rr_interval_fair ( struct task_struct * task ) ;

unsigned int get_rr_interval_rt ( struct task_struct * task ) ;

void print_cfs_rq ( struct seq_file * m , int cpu , struct cfs_rq * cfs_rq ) ;

void print_rt_rq ( struct seq_file * m , int cpu , struct rt_rq * rt_rq ) ;

void proc_sched_show_task ( struct task_struct * p , struct seq_file * m ) ;

void proc_sched_set_task ( struct task_struct * p ) ;

void kthread_bind ( struct task_struct * p , unsigned int cpu ) ;

void set_task_cpu ( struct task_struct * p , unsigned int new_cpu ) ;

struct migration_req { struct list_head list ; struct task_struct * task ; int dest_cpu ; struct completion done ; } ;

void wait_task_context_switch ( struct task_struct * p ) ;

unsigned long wait_task_inactive ( struct task_struct * p , long match_state ) ;

void kick_process ( struct task_struct * p ) ;

void task_oncpu_function_call ( struct task_struct * p , void ( * func ) ( void * info ) , void * info ) ;

int wake_up_process ( struct task_struct * p ) ;

int wake_up_state ( struct task_struct * p , unsigned int state ) ;

void sched_fork ( struct task_struct * p , int clone_flags ) ;

void wake_up_new_task ( struct task_struct * p , unsigned long clone_flags ) ;

void preempt_notifier_register ( struct preempt_notifier * notifier ) ;

void preempt_notifier_unregister ( struct preempt_notifier * notifier ) ;

void schedule_tail ( struct task_struct * prev ) ;

unsigned long nr_running ( void ) ;

unsigned long nr_uninterruptible ( void ) ;

unsigned long long nr_context_switches ( void ) ;

unsigned long nr_iowait ( void ) ;

unsigned long nr_iowait_cpu ( void ) ;

unsigned long this_cpu_load ( void ) ;

void get_avenrun ( unsigned long * loads , unsigned long offset , int shift ) ;

void calc_global_load ( void ) ;

u64 cpu_nr_migrations ( int cpu ) ;

void sched_exec ( void ) ;

struct sd_lb_stats { struct sched_group * busiest ; struct sched_group * this ; unsigned long total_load ; unsigned long total_pwr ; unsigned long avg_load ; unsigned long this_load ; unsigned long this_load_per_task ; unsigned long this_nr_running ; unsigned long max_load ; unsigned long busiest_load_per_task ; unsigned long busiest_nr_running ; unsigned long busiest_group_capacity ; int group_imb ; int power_savings_balance ; struct sched_group * group_min ; struct sched_group * group_leader ; unsigned long min_load_per_task ; unsigned long leader_nr_running ; unsigned long min_nr_running ; } ;

struct sg_lb_stats { unsigned long avg_load ; unsigned long group_load ; unsigned long sum_nr_running ; unsigned long sum_weighted_load ; unsigned long group_capacity ; int group_imb ; } ;

unsigned long default_scale_freq_power ( struct sched_domain * sd , int cpu ) ;

unsigned long __attribute__ ( ( weak ) ) arch_scale_freq_power ( struct sched_domain * sd , int cpu ) ;
unsigned long default_scale_smt_power ( struct sched_domain * sd , int cpu ) ;

unsigned long __attribute__ ( ( weak ) ) arch_scale_smt_power ( struct sched_domain * sd , int cpu ) ;
unsigned long scale_rt_power ( int cpu ) ;

int get_nohz_load_balancer ( void ) ;

int select_nohz_load_balancer ( int stop_tick ) ;

unsigned long long task_delta_exec ( struct task_struct * p ) ;

unsigned long long task_sched_runtime ( struct task_struct * p ) ;

unsigned long long thread_group_sched_runtime ( struct task_struct * p ) ;

void account_user_time ( struct task_struct * p , cputime_t cputime , cputime_t cputime_scaled ) ;

void account_system_time ( struct task_struct * p , int hardirq_offset , cputime_t cputime , cputime_t cputime_scaled ) ;

void account_steal_time ( cputime_t cputime ) ;

void account_idle_time ( cputime_t cputime ) ;

void account_process_tick ( struct task_struct * p , int user_tick ) ;

void account_steal_ticks ( unsigned long ticks ) ;

void account_idle_ticks ( unsigned long ticks ) ;

cputime_t task_utime ( struct task_struct * p ) ;

cputime_t task_stime ( struct task_struct * p ) ;

void thread_group_times ( struct task_struct * p , cputime_t * ut , cputime_t * st ) ;

void scheduler_tick ( void ) ;

__attribute__ ( ( no_instrument_function ) ) unsigned long get_parent_ip ( unsigned long addr ) ;

void __attribute__ ( ( __section__ ( ) ) ) schedule ( void ) ;

int mutex_spin_on_owner ( struct mutex * lock , struct thread_info * owner ) ;

int default_wake_function ( wait_queue_t * curr , unsigned mode , int wake_flags , void * key ) ;

void __wake_up ( wait_queue_head_t * q , unsigned int mode , int nr_exclusive , void * key ) ;

void __wake_up_locked ( wait_queue_head_t * q , unsigned int mode ) ;

void __wake_up_locked_key ( wait_queue_head_t * q , unsigned int mode , void * key ) ;

void __wake_up_sync_key ( wait_queue_head_t * q , unsigned int mode , int nr_exclusive , void * key ) ;

void __wake_up_sync ( wait_queue_head_t * q , unsigned int mode , int nr_exclusive ) ;

void complete ( struct completion * x ) ;

void complete_all ( struct completion * x ) ;

void __attribute__ ( ( __section__ ( ) ) ) wait_for_completion ( struct completion * x ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) wait_for_completion_timeout ( struct completion * x , unsigned long timeout ) ;

int __attribute__ ( ( __section__ ( ) ) ) wait_for_completion_interruptible ( struct completion * x ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) wait_for_completion_interruptible_timeout ( struct completion * x , unsigned long timeout ) ;

int __attribute__ ( ( __section__ ( ) ) ) wait_for_completion_killable ( struct completion * x ) ;

bool try_wait_for_completion ( struct completion * x ) ;

bool completion_done ( struct completion * x ) ;

void __attribute__ ( ( __section__ ( ) ) ) interruptible_sleep_on ( wait_queue_head_t * q ) ;

long __attribute__ ( ( __section__ ( ) ) ) interruptible_sleep_on_timeout ( wait_queue_head_t * q , long timeout ) ;

void __attribute__ ( ( __section__ ( ) ) ) sleep_on ( wait_queue_head_t * q ) ;

long __attribute__ ( ( __section__ ( ) ) ) sleep_on_timeout ( wait_queue_head_t * q , long timeout ) ;

void rt_mutex_setprio ( struct task_struct * p , int prio ) ;

void set_user_nice ( struct task_struct * p , long nice ) ;

int can_nice ( const struct task_struct * p , const int nice ) ;

long sys_nice ( int increment ) ;

int task_prio ( const struct task_struct * p ) ;

int task_nice ( const struct task_struct * p ) ;

int idle_cpu ( int cpu ) ;

struct task_struct * idle_task ( int cpu ) ;

int sched_setscheduler ( struct task_struct * p , int policy , struct sched_param * param ) ;

int sched_setscheduler_nocheck ( struct task_struct * p , int policy , struct sched_param * param ) ;

long sys_sched_setscheduler ( pid_t pid , int policy , struct sched_param * param ) ;

long sys_sched_setparam ( pid_t pid , struct sched_param * param ) ;

long sys_sched_getscheduler ( pid_t pid ) ;

long sys_sched_getparam ( pid_t pid , struct sched_param * param ) ;

long sched_setaffinity ( pid_t pid , const struct cpumask * in_mask ) ;

long sys_sched_setaffinity ( pid_t pid , unsigned int len , unsigned long * user_mask_ptr ) ;

long sched_getaffinity ( pid_t pid , struct cpumask * mask ) ;

long sys_sched_getaffinity ( pid_t pid , unsigned int len , unsigned long * user_mask_ptr ) ;

long sys_sched_yield ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) _cond_resched ( void ) ;

int __cond_resched_lock ( spinlock_t * lock ) ;

int __attribute__ ( ( __section__ ( ) ) ) __cond_resched_softirq ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) yield ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) io_schedule ( void ) ;

long __attribute__ ( ( __section__ ( ) ) ) io_schedule_timeout ( long timeout ) ;

long sys_sched_get_priority_max ( int policy ) ;

long sys_sched_get_priority_min ( int policy ) ;

long sys_sched_rr_get_interval ( pid_t pid , struct timespec * interval ) ;

void sched_show_task ( struct task_struct * p ) ;

void show_state_filter ( unsigned long state_filter ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) init_idle_bootup_task ( struct task_struct * idle ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) init_idle ( struct task_struct * idle , int cpu ) ;

int set_cpus_allowed_ptr ( struct task_struct * p , const struct cpumask * new_mask ) ;

void sched_idle_next ( void ) ;

void idle_task_exit ( void ) ;

struct static_sched_group { struct sched_group sg ; unsigned long cpus [ ( ( ( 64 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;

struct static_sched_domain { struct sched_domain sd ; unsigned long span [ ( ( ( 64 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;

struct s_data { int sd_allnodes ; cpumask_var_t domainspan ; cpumask_var_t covered ; cpumask_var_t notcovered ; cpumask_var_t nodemask ; cpumask_var_t this_sibling_map ; cpumask_var_t this_core_map ; cpumask_var_t send_covered ; cpumask_var_t tmpmask ; struct sched_group * * sched_group_nodes ; struct root_domain * rd ; } ;

enum s_alloc { sa_sched_groups = 0 , sa_rootdomain , sa_tmpmask , sa_send_covered , sa_this_core_map , sa_this_sibling_map , sa_nodemask , sa_sched_group_nodes , sa_notcovered , sa_covered , sa_domainspan , sa_none , } ;

int __attribute__ ( ( weak ) ) arch_update_cpu_topology ( void ) ;

void partition_sched_domains ( int ndoms_new , struct cpumask * doms_new , struct sched_domain_attr * dattr_new ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sched_create_sysfs_power_savings_entries ( struct sysdev_class * cls ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sched_init_smp ( void ) ;

int in_sched_functions ( unsigned long addr ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sched_init ( void ) ;

void normalize_rt_tasks ( void ) ;

struct task_group * sched_create_group ( struct task_group * parent ) ;

void sched_destroy_group ( struct task_group * tg ) ;

void sched_move_task ( struct task_struct * tsk ) ;

int sched_group_set_shares ( struct task_group * tg , unsigned long shares ) ;

unsigned long sched_group_shares ( struct task_group * tg ) ;

struct rt_schedulable_data { struct task_group * tg ; u64 rt_period ; u64 rt_runtime ; } ;

int sched_group_set_rt_runtime ( struct task_group * tg , long rt_runtime_us ) ;

long sched_group_rt_runtime ( struct task_group * tg ) ;

int sched_group_set_rt_period ( struct task_group * tg , long rt_period_us ) ;

long sched_group_rt_period ( struct task_group * tg ) ;

int sched_rt_can_attach ( struct task_group * tg , struct task_struct * tsk ) ;

int sched_rt_handler ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

struct cpuacct { struct cgroup_subsys_state css ; u64 * cpuusage ; struct percpu_counter cpustat [ CPUACCT_STAT_NSTATS ] ; struct cpuacct * parent ; } ;

int rcu_expedited_torture_stats ( char * page ) ;

void synchronize_sched_expedited ( void ) ;

struct embedded_fd_set { unsigned long fds_bits [ 1 ] ; } ;

struct fdtable { unsigned int max_fds ; struct file * * fd ; fd_set * close_on_exec ; fd_set * open_fds ; struct rcu_head rcu ; struct fdtable * next ; } ;

struct files_struct { atomic_t count ; struct fdtable * fdt ; struct fdtable fdtab ; spinlock_t file_lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; int next_fd ; struct embedded_fd_set close_on_exec_init ; struct embedded_fd_set open_fds_init ; struct file * fd_array [ 64 ] ; } ;

struct robust_list { struct robust_list * next ; } ;

struct robust_list_head { struct robust_list list ; long futex_offset ; struct robust_list * list_op_pending ; } ;
union ktime ;
union futex_key { struct { unsigned long pgoff ; struct inode * inode ; int offset ; } shared ; struct { unsigned long address ; struct mm_struct * mm ; int offset ; } private ; struct { unsigned long word ; void * ptr ; int offset ; } both ; } ;

typedef __u16 comp_t ;

typedef __u32 comp2_t ;

struct acct { char ac_flag ; char ac_version ; __u16 ac_uid16 ; __u16 ac_gid16 ; __u16 ac_tty ; __u32 ac_btime ; comp_t ac_utime ; comp_t ac_stime ; comp_t ac_etime ; comp_t ac_mem ; comp_t ac_io ; comp_t ac_rw ; comp_t ac_minflt ; comp_t ac_majflt ; comp_t ac_swaps ; __u16 ac_ahz ; __u32 ac_exitcode ; char ac_comm [ 16 + 1 ] ; __u8 ac_etime_hi ; __u16 ac_etime_lo ; __u32 ac_uid ; __u32 ac_gid ; } ;

struct acct_v3 { char ac_flag ; char ac_version ; __u16 ac_tty ; __u32 ac_exitcode ; __u32 ac_uid ; __u32 ac_gid ; __u32 ac_pid ; __u32 ac_ppid ; __u32 ac_btime ; __u32 ac_etime ; comp_t ac_utime ; comp_t ac_stime ; comp_t ac_mem ; comp_t ac_io ; comp_t ac_rw ; comp_t ac_minflt ; comp_t ac_majflt ; comp_t ac_swaps ; char ac_comm [ 16 ] ; } ;

struct pacct_struct ;
typedef struct acct_v3 acct_t ;

enum proc_cn_mcast_op { PROC_CN_MCAST_LISTEN = 1 , PROC_CN_MCAST_IGNORE = 2 } ;

struct proc_event { enum what { PROC_EVENT_NONE = 0x00000000 , PROC_EVENT_FORK = 0x00000001 , PROC_EVENT_EXEC = 0x00000002 , PROC_EVENT_UID = 0x00000004 , PROC_EVENT_GID = 0x00000040 , PROC_EVENT_SID = 0x00000080 , PROC_EVENT_EXIT = 0x80000000 } what ; __u32 cpu ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) timestamp_ns ; union { struct { __u32 err ; } ack ; struct fork_proc_event { __kernel_pid_t parent_pid ; __kernel_pid_t parent_tgid ; __kernel_pid_t child_pid ; __kernel_pid_t child_tgid ; } fork ; struct exec_proc_event { __kernel_pid_t process_pid ; __kernel_pid_t process_tgid ; } exec ; struct id_proc_event { __kernel_pid_t process_pid ; __kernel_pid_t process_tgid ; union { __u32 ruid ; __u32 rgid ; } r ; union { __u32 euid ; __u32 egid ; } e ; } id ; struct sid_proc_event { __kernel_pid_t process_pid ; __kernel_pid_t process_tgid ; } sid ; struct exit_proc_event { __kernel_pid_t process_pid ; __kernel_pid_t process_tgid ; __u32 exit_code , exit_signal ; } exit ; } event_data ; } ;

int nr_processes ( void ) ;

void free_task ( struct task_struct * tsk ) ;

void __put_task_struct ( struct task_struct * tsk ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) fork_init ( unsigned long mempages ) ;

int __attribute__ ( ( weak ) ) arch_dup_task_struct ( struct task_struct * dst , struct task_struct * src ) ;
struct mm_struct * mm_alloc ( void ) ;

void __mmdrop ( struct mm_struct * mm ) ;

void mmput ( struct mm_struct * mm ) ;

struct mm_struct * get_task_mm ( struct task_struct * task ) ;

void mm_release ( struct task_struct * tsk , struct mm_struct * mm ) ;

struct mm_struct * dup_mm ( struct task_struct * tsk ) ;

void __cleanup_sighand ( struct sighand_struct * sighand ) ;

void __cleanup_signal ( struct signal_struct * sig ) ;

long sys_set_tid_address ( int * tidptr ) ;

void mm_init_owner ( struct mm_struct * mm , struct task_struct * p ) ;

__attribute__ ( ( noinline ) ) struct pt_regs * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( weak ) ) idle_regs ( struct pt_regs * regs ) ;

struct task_struct * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) fork_idle ( int cpu ) ;

long do_fork ( unsigned long clone_flags , unsigned long stack_start , struct pt_regs * regs , unsigned long stack_size , int * parent_tidptr , int * child_tidptr ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) proc_caches_init ( void ) ;

long sys_unshare ( unsigned long unshare_flags ) ;

int unshare_files ( struct files_struct * * displaced ) ;

int register_exec_domain ( struct exec_domain * ep ) ;

int unregister_exec_domain ( struct exec_domain * ep ) ;

int __set_personality ( u_long personality ) ;

long sys_personality ( u_long personality ) ;

void panic ( const char * fmt , ... ) ;

struct tnt { u8 bit ; char true ; char false ; } ;

const char * print_tainted ( void ) ;

int test_taint ( unsigned flag ) ;

unsigned long get_taint ( void ) ;

void add_taint ( unsigned flag ) ;

int oops_may_print ( void ) ;

void oops_enter ( void ) ;

void oops_exit ( void ) ;

struct slowpath_args { const char * fmt ; va_list args ; } ;

void warn_slowpath_fmt ( const char * file , int line , const char * fmt , ... ) ;

void warn_slowpath_null ( const char * file , int line ) ;

void __stack_chk_fail ( void ) ;

void __attribute__ ( ( weak ) ) early_printk ( const char * fmt , ... ) ;
struct console_cmdline { char name [ 8 ] ; int index ; char * options ; } ;

void log_buf_kexec_setup ( void ) ;

int do_syslog ( int type , char * buf , int len , bool from_file ) ;

long sys_syslog ( int type , char * buf , int len ) ;

int printk ( const char * fmt , ... ) ;

int vprintk ( const char * fmt , va_list args ) ;

int add_preferred_console ( char * name , int idx , char * options ) ;

int update_console_cmdline ( char * name , int idx , char * name_new , int idx_new , char * options ) ;

void suspend_console ( void ) ;

void resume_console ( void ) ;

void acquire_console_sem ( void ) ;

int try_acquire_console_sem ( void ) ;

int is_console_locked ( void ) ;

void printk_tick ( void ) ;

int printk_needs_cpu ( int cpu ) ;

void wake_up_klogd ( void ) ;

void release_console_sem ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) console_conditional_schedule ( void ) ;

void console_unblank ( void ) ;

struct tty_driver * console_device ( int * index ) ;

void console_stop ( struct console * console ) ;

void console_start ( struct console * console ) ;

void register_console ( struct console * newcon ) ;

int unregister_console ( struct console * console ) ;

int printk_ratelimit ( void ) ;

bool printk_timed_ratelimit ( unsigned long * caller_jiffies , unsigned int interval_msecs ) ;

void get_online_cpus ( void ) ;

void put_online_cpus ( void ) ;

void cpu_maps_update_begin ( void ) ;

void cpu_maps_update_done ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) register_cpu_notifier ( struct notifier_block * nb ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) unregister_cpu_notifier ( struct notifier_block * nb ) ;

struct take_cpu_down_param { unsigned long mod ; void * hcpu ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) cpu_down ( unsigned int cpu ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) cpu_up ( unsigned int cpu ) ;

int disable_nonboot_cpus ( void ) ;

void __attribute__ ( ( weak ) ) arch_enable_nonboot_cpus_begin ( void ) ;
void __attribute__ ( ( weak ) ) arch_enable_nonboot_cpus_end ( void ) ;
void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) enable_nonboot_cpus ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) notify_cpu_starting ( unsigned int cpu ) ;

void set_cpu_possible ( unsigned int cpu , bool possible ) ;

void set_cpu_present ( unsigned int cpu , bool present ) ;

void set_cpu_online ( unsigned int cpu , bool online ) ;

void set_cpu_active ( unsigned int cpu , bool active ) ;

void init_cpu_present ( const struct cpumask * src ) ;

void init_cpu_possible ( const struct cpumask * src ) ;

void init_cpu_online ( const struct cpumask * src ) ;

struct pipe_buffer { struct page * page ; unsigned int offset , len ; const struct pipe_buf_operations * ops ; unsigned int flags ; unsigned long private ; } ;

struct pipe_inode_info { wait_queue_head_t wait ; unsigned int nrbufs , curbuf ; struct page * tmp_page ; unsigned int readers ; unsigned int writers ; unsigned int waiting_writers ; unsigned int r_counter ; unsigned int w_counter ; struct fasync_struct * fasync_readers ; struct fasync_struct * fasync_writers ; struct inode * inode ; struct pipe_buffer bufs [ ( 16 ) ] ; } ;
struct pipe_buf_operations { int can_merge ; void * ( * map ) ( struct pipe_inode_info * , struct pipe_buffer * , int ) ; void ( * unmap ) ( struct pipe_inode_info * , struct pipe_buffer * , void * ) ; int ( * confirm ) ( struct pipe_inode_info * , struct pipe_buffer * ) ; void ( * release ) ( struct pipe_inode_info * , struct pipe_buffer * ) ; int ( * steal ) ( struct pipe_inode_info * , struct pipe_buffer * ) ; void ( * get ) ( struct pipe_inode_info * , struct pipe_buffer * ) ; } ;

void release_task ( struct task_struct * p ) ;

struct pid * session_of_pgrp ( struct pid * pgrp ) ;

int is_current_pgrp_orphaned ( void ) ;

void __set_special_pids ( struct pid * pid ) ;

int allow_signal ( int sig ) ;

int disallow_signal ( int sig ) ;

void daemonize ( const char * name , ... ) ;

struct files_struct * get_files_struct ( struct task_struct * task ) ;

void put_files_struct ( struct files_struct * files ) ;

void reset_files_struct ( struct files_struct * files ) ;

void exit_files ( struct task_struct * tsk ) ;

void mm_update_next_owner ( struct mm_struct * mm ) ;

void do_exit ( long code ) ;

void complete_and_exit ( struct completion * comp , long code ) ;

long sys_exit ( int error_code ) ;

void do_group_exit ( int exit_code ) ;

long sys_exit_group ( int error_code ) ;

struct wait_opts { enum pid_type wo_type ; int wo_flags ; struct pid * wo_pid ; struct siginfo * wo_info ; int * wo_stat ; struct rusage * wo_rusage ; wait_queue_t child_wait ; int notask_error ; } ;

void __wake_up_parent ( struct task_struct * p , struct task_struct * parent ) ;

long sys_waitid ( int which , pid_t upid , struct siginfo * infop , int options , struct rusage * ru ) ;

long sys_wait4 ( pid_t upid , int * stat_addr , int options , struct rusage * ru ) ;

long sys_waitpid ( pid_t pid , int * stat_addr , int options ) ;

int do_getitimer ( int which , struct itimerval * value ) ;

long sys_getitimer ( int which , struct itimerval * value ) ;

enum hrtimer_restart it_real_fn ( struct hrtimer * timer ) ;

int do_setitimer ( int which , struct itimerval * value , struct itimerval * ovalue ) ;

unsigned int alarm_setitimer ( unsigned int seconds ) ;

long sys_setitimer ( int which , struct itimerval * value , struct itimerval * ovalue ) ;

long sys_time ( time_t * tloc ) ;

long sys_stime ( time_t * tptr ) ;

long sys_gettimeofday ( struct timeval * tv , struct timezone * tz ) ;

int do_sys_settimeofday ( struct timespec * tv , struct timezone * tz ) ;

long sys_settimeofday ( struct timeval * tv , struct timezone * tz ) ;

long sys_adjtimex ( struct timex * txc_p ) ;

struct timespec current_fs_time ( struct super_block * sb ) ;

struct timespec timespec_trunc ( struct timespec t , unsigned gran ) ;

unsigned long mktime ( const unsigned int year0 , const unsigned int mon0 , const unsigned int day , const unsigned int hour , const unsigned int min , const unsigned int sec ) ;

void set_normalized_timespec ( struct timespec * ts , time_t sec , s64 nsec ) ;

struct timespec ns_to_timespec ( const s64 nsec ) ;

struct timeval ns_to_timeval ( const s64 nsec ) ;

unsigned long msecs_to_jiffies ( const unsigned int m ) ;

unsigned long usecs_to_jiffies ( const unsigned int u ) ;

unsigned long timespec_to_jiffies ( const struct timespec * value ) ;

void jiffies_to_timespec ( const unsigned long jiffies , struct timespec * value ) ;

unsigned long timeval_to_jiffies ( const struct timeval * value ) ;

void jiffies_to_timeval ( const unsigned long jiffies , struct timeval * value ) ;

clock_t jiffies_to_clock_t ( long x ) ;

unsigned long clock_t_to_jiffies ( unsigned long x ) ;

u64 jiffies_64_to_clock_t ( u64 x ) ;

u64 nsec_to_clock_t ( u64 x ) ;

struct timespec timespec_add_safe ( const struct timespec lhs , const struct timespec rhs ) ;

struct ftrace_raw_irq_handler_entry { struct trace_entry ent ; int irq ; u32 __data_loc_name ; char __data [ 0 ] ; } ;

struct ftrace_raw_irq_handler_exit { struct trace_entry ent ; int irq ; int ret ; char __data [ 0 ] ; } ;

struct ftrace_raw_softirq_entry { struct trace_entry ent ; int vec ; char __data [ 0 ] ; } ;

struct ftrace_raw_softirq_exit { struct trace_entry ent ; int vec ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_irq_handler_entry { u32 name ; ; } ;

struct ftrace_data_offsets_irq_handler_exit { ; } ;

struct ftrace_data_offsets_softirq_entry { ; } ;

struct ftrace_data_offsets_softirq_exit { ; } ;

void wakeup_softirqd ( void ) ;

void local_bh_disable ( void ) ;

void _local_bh_enable ( void ) ;

void local_bh_enable ( void ) ;

void local_bh_enable_ip ( unsigned long ip ) ;

void __do_softirq ( void ) ;

void irq_enter ( void ) ;

void irq_exit ( void ) ;

void raise_softirq ( unsigned int nr ) ;

void open_softirq ( int nr , void ( * action ) ( struct softirq_action * ) ) ;

struct tasklet_head { struct tasklet_struct * head ; struct tasklet_struct * * tail ; } ;

void __tasklet_schedule ( struct tasklet_struct * t ) ;

void __tasklet_hi_schedule ( struct tasklet_struct * t ) ;

void __tasklet_hi_schedule_first ( struct tasklet_struct * t ) ;

void tasklet_init ( struct tasklet_struct * t , void ( * func ) ( unsigned long ) , unsigned long data ) ;

void tasklet_kill ( struct tasklet_struct * t ) ;

void tasklet_hrtimer_init ( struct tasklet_hrtimer * ttimer , enum hrtimer_restart ( * function ) ( struct hrtimer * ) , clockid_t which_clock , enum hrtimer_mode mode ) ;

void __send_remote_softirq ( struct call_single_data * cp , int cpu , int this_cpu , int softirq ) ;

void send_remote_softirq ( struct call_single_data * cp , int cpu , int softirq ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) softirq_init ( void ) ;

void tasklet_kill_immediate ( struct tasklet_struct * t , unsigned int cpu ) ;

int on_each_cpu ( void ( * func ) ( void * info ) , void * info , int wait ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( weak ) ) early_irq_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( weak ) ) arch_probe_nr_irqs ( void ) ;
int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( weak ) ) arch_early_irq_init ( void ) ;
int __attribute__ ( ( weak ) ) arch_init_chip_data ( struct irq_desc * desc , int node ) ;
enum { MAX_IORES_LEVEL = 5 } ;
int request_resource ( struct resource * root , struct resource * new ) ;

int release_resource ( struct resource * old ) ;

int walk_system_ram_range ( unsigned long start_pfn , unsigned long nr_pages , void * arg , int ( * func ) ( unsigned long , unsigned long , void * ) ) ;

int allocate_resource ( struct resource * root , struct resource * new , resource_size_t size , resource_size_t min , resource_size_t max , resource_size_t align , void ( * alignf ) ( void * , struct resource * , resource_size_t , resource_size_t ) , void * alignf_data ) ;

int insert_resource ( struct resource * parent , struct resource * new ) ;

void insert_resource_expand_to_fit ( struct resource * root , struct resource * new ) ;

int adjust_resource ( struct resource * res , resource_size_t start , resource_size_t size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_region_with_split ( struct resource * root , resource_size_t start , resource_size_t end , const char * name ) ;

resource_size_t resource_alignment ( struct resource * res ) ;

struct resource * __request_region ( struct resource * parent , resource_size_t start , resource_size_t n , const char * name , int flags ) ;

int __check_region ( struct resource * parent , resource_size_t start , resource_size_t n ) ;

void __release_region ( struct resource * parent , resource_size_t start , resource_size_t n ) ;

struct region_devres { struct resource * parent ; resource_size_t start ; resource_size_t n ; } ;

struct resource * __devm_request_region ( struct device * dev , struct resource * parent , resource_size_t start , resource_size_t n , const char * name ) ;

void __devm_release_region ( struct device * dev , struct resource * parent , resource_size_t start , resource_size_t n ) ;

int iomem_map_sanity_check ( resource_size_t addr , unsigned long size ) ;

int iomem_is_exclusive ( u64 addr ) ;

void sysctl_head_get ( struct ctl_table_header * head ) ;

void sysctl_head_put ( struct ctl_table_header * head ) ;

struct ctl_table_header * sysctl_head_grab ( struct ctl_table_header * head ) ;

void sysctl_head_finish ( struct ctl_table_header * head ) ;

struct ctl_table_header * __sysctl_head_next ( struct nsproxy * namespaces , struct ctl_table_header * prev ) ;

struct ctl_table_header * sysctl_head_next ( struct ctl_table_header * prev ) ;

void register_sysctl_root ( struct ctl_table_root * root ) ;

int do_sysctl ( int * name , int nlen , void * oldval , size_t * oldlenp , void * newval , size_t newlen ) ;

long sys_sysctl ( struct __sysctl_args * args ) ;

int sysctl_perm ( struct ctl_table_root * root , struct ctl_table * table , int op ) ;

struct ctl_table_header * __register_sysctl_paths ( struct ctl_table_root * root , struct nsproxy * namespaces , const struct ctl_path * path , struct ctl_table * table ) ;

struct ctl_table_header * register_sysctl_paths ( const struct ctl_path * path , struct ctl_table * table ) ;

struct ctl_table_header * register_sysctl_table ( struct ctl_table * table ) ;

void unregister_sysctl_table ( struct ctl_table_header * header ) ;

int sysctl_is_seen ( struct ctl_table_header * p ) ;

void setup_sysctl_set ( struct ctl_table_set * p , struct ctl_table_set * parent , int ( * is_seen ) ( struct ctl_table_set * ) ) ;

int proc_dostring ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int proc_dointvec ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

struct do_proc_dointvec_minmax_conv_param { int * min ; int * max ; } ;

int proc_dointvec_minmax ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int proc_doulongvec_minmax ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int proc_doulongvec_ms_jiffies_minmax ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int proc_dointvec_jiffies ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int proc_dointvec_userhz_jiffies ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int proc_dointvec_ms_jiffies ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int sysctl_data ( struct ctl_table * table , void * oldval , size_t * oldlenp , void * newval , size_t newlen ) ;

int sysctl_string ( struct ctl_table * table , void * oldval , size_t * oldlenp , void * newval , size_t newlen ) ;

int sysctl_intvec ( struct ctl_table * table , void * oldval , size_t * oldlenp , void * newval , size_t newlen ) ;

int sysctl_jiffies ( struct ctl_table * table , void * oldval , size_t * oldlenp , void * newval , size_t newlen ) ;

int sysctl_ms_jiffies ( struct ctl_table * table , void * oldval , size_t * oldlenp , void * newval , size_t newlen ) ;

long sys_capget ( cap_user_header_t header , cap_user_data_t dataptr ) ;

long sys_capset ( cap_user_header_t header , const cap_user_data_t data ) ;

int capable ( int cap ) ;

void __ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) ;

void __ptrace_unlink ( struct task_struct * child ) ;

int ptrace_check_attach ( struct task_struct * child , int kill ) ;

int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) ;

bool ptrace_may_access ( struct task_struct * task , unsigned int mode ) ;

int ptrace_attach ( struct task_struct * task ) ;

int ptrace_traceme ( void ) ;

int ptrace_detach ( struct task_struct * child , unsigned int data ) ;

void exit_ptrace ( struct task_struct * tracer ) ;

int ptrace_readdata ( struct task_struct * tsk , unsigned long src , char * dst , int len ) ;

int ptrace_writedata ( struct task_struct * tsk , char * src , unsigned long dst , int len ) ;

int ptrace_request ( struct task_struct * child , long request , long addr , long data ) ;

long sys_ptrace ( long request , long pid , long addr , long data ) ;

int generic_ptrace_peekdata ( struct task_struct * tsk , long addr , long data ) ;

int generic_ptrace_pokedata ( struct task_struct * tsk , long addr , long data ) ;

int compat_ptrace_request ( struct task_struct * child , compat_long_t request , compat_ulong_t addr , compat_ulong_t data ) ;

long compat_sys_ptrace ( compat_long_t request , compat_long_t pid , compat_long_t addr , compat_long_t data ) ;

struct ftrace_raw_timer_init { struct trace_entry ent ; void * timer ; char __data [ 0 ] ; } ;

struct ftrace_raw_timer_start { struct trace_entry ent ; void * timer ; void * function ; unsigned long expires ; unsigned long now ; char __data [ 0 ] ; } ;

struct ftrace_raw_timer_expire_entry { struct trace_entry ent ; void * timer ; unsigned long now ; char __data [ 0 ] ; } ;

struct ftrace_raw_timer_expire_exit { struct trace_entry ent ; void * timer ; char __data [ 0 ] ; } ;

struct ftrace_raw_timer_cancel { struct trace_entry ent ; void * timer ; char __data [ 0 ] ; } ;

struct ftrace_raw_hrtimer_init { struct trace_entry ent ; void * timer ; clockid_t clockid ; enum hrtimer_mode mode ; char __data [ 0 ] ; } ;

struct ftrace_raw_hrtimer_start { struct trace_entry ent ; void * timer ; void * function ; s64 expires ; s64 softexpires ; char __data [ 0 ] ; } ;

struct ftrace_raw_hrtimer_expire_entry { struct trace_entry ent ; void * timer ; s64 now ; char __data [ 0 ] ; } ;

struct ftrace_raw_hrtimer_expire_exit { struct trace_entry ent ; void * timer ; char __data [ 0 ] ; } ;

struct ftrace_raw_hrtimer_cancel { struct trace_entry ent ; void * timer ; char __data [ 0 ] ; } ;

struct ftrace_raw_itimer_state { struct trace_entry ent ; int which ; cputime_t expires ; long value_sec ; long value_usec ; long interval_sec ; long interval_usec ; char __data [ 0 ] ; } ;

struct ftrace_raw_itimer_expire { struct trace_entry ent ; int which ; pid_t pid ; cputime_t now ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_timer_init { ; } ;

struct ftrace_data_offsets_timer_start { ; } ;

struct ftrace_data_offsets_timer_expire_entry { ; } ;

struct ftrace_data_offsets_timer_expire_exit { ; } ;

struct ftrace_data_offsets_timer_cancel { ; } ;

struct ftrace_data_offsets_hrtimer_init { ; } ;

struct ftrace_data_offsets_hrtimer_start { ; } ;

struct ftrace_data_offsets_hrtimer_expire_entry { ; } ;

struct ftrace_data_offsets_hrtimer_expire_exit { ; } ;

struct ftrace_data_offsets_hrtimer_cancel { ; } ;

struct ftrace_data_offsets_itimer_state { ; } ;

struct ftrace_data_offsets_itimer_expire { ; } ;

struct tvec { struct list_head vec [ ( 1 << ( 0 ? 4 : 6 ) ) ] ; } ;

struct tvec_root { struct list_head vec [ ( 1 << ( 0 ? 6 : 8 ) ) ] ; } ;

struct tvec_base { spinlock_t lock ; struct timer_list * running_timer ; unsigned long timer_jiffies ; unsigned long next_timer ; struct tvec_root tv1 ; struct tvec tv2 ; struct tvec tv3 ; struct tvec tv4 ; struct tvec tv5 ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
unsigned long __round_jiffies ( unsigned long j , int cpu ) ;

unsigned long __round_jiffies_relative ( unsigned long j , int cpu ) ;

unsigned long round_jiffies ( unsigned long j ) ;

unsigned long round_jiffies_relative ( unsigned long j ) ;

unsigned long __round_jiffies_up ( unsigned long j , int cpu ) ;

unsigned long __round_jiffies_up_relative ( unsigned long j , int cpu ) ;

unsigned long round_jiffies_up ( unsigned long j ) ;

unsigned long round_jiffies_up_relative ( unsigned long j ) ;

void __timer_stats_timer_set_start_info ( struct timer_list * timer , void * addr ) ;

void init_timer_key ( struct timer_list * timer , const char * name , struct lock_class_key * key ) ;

void init_timer_deferrable_key ( struct timer_list * timer , const char * name , struct lock_class_key * key ) ;

int mod_timer_pending ( struct timer_list * timer , unsigned long expires ) ;

int mod_timer ( struct timer_list * timer , unsigned long expires ) ;

int mod_timer_pinned ( struct timer_list * timer , unsigned long expires ) ;

void add_timer ( struct timer_list * timer ) ;

void add_timer_on ( struct timer_list * timer , int cpu ) ;

int del_timer ( struct timer_list * timer ) ;

int try_to_del_timer_sync ( struct timer_list * timer ) ;

int del_timer_sync ( struct timer_list * timer ) ;

unsigned long get_next_timer_interrupt ( unsigned long now ) ;

void update_process_times ( int user_tick ) ;

void run_local_timers ( void ) ;

void do_timer ( unsigned long ticks ) ;

long sys_alarm ( unsigned int seconds ) ;

long sys_getpid ( void ) ;

long sys_getppid ( void ) ;

long sys_getuid ( void ) ;

long sys_geteuid ( void ) ;

long sys_getgid ( void ) ;

long sys_getegid ( void ) ;

signed long __attribute__ ( ( __section__ ( ) ) ) schedule_timeout ( signed long timeout ) ;

signed long __attribute__ ( ( __section__ ( ) ) ) schedule_timeout_interruptible ( signed long timeout ) ;

signed long __attribute__ ( ( __section__ ( ) ) ) schedule_timeout_killable ( signed long timeout ) ;

signed long __attribute__ ( ( __section__ ( ) ) ) schedule_timeout_uninterruptible ( signed long timeout ) ;

long sys_gettid ( void ) ;

int do_sysinfo ( struct sysinfo * info ) ;

long sys_sysinfo ( struct sysinfo * info ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_timers ( void ) ;

void msleep ( unsigned int msecs ) ;

unsigned long msleep_interruptible ( unsigned int msecs ) ;

int uids_sysfs_init ( void ) ;

int task_can_switch_user ( struct user_struct * up , struct task_struct * tsk ) ;

struct user_struct * find_user ( uid_t uid ) ;

void free_uid ( struct user_struct * up ) ;

struct user_struct * alloc_uid ( struct user_namespace * ns , uid_t uid ) ;

struct signalfd_siginfo { __u32 ssi_signo ; __s32 ssi_errno ; __s32 ssi_code ; __u32 ssi_pid ; __u32 ssi_uid ; __s32 ssi_fd ; __u32 ssi_tid ; __u32 ssi_band ; __u32 ssi_overrun ; __u32 ssi_trapno ; __s32 ssi_status ; __s32 ssi_int ; __u64 ssi_ptr ; __u64 ssi_utime ; __u64 ssi_stime ; __u64 ssi_addr ; __u8 __pad [ 48 ] ; } ;

enum audit_state { AUDIT_DISABLED , AUDIT_SETUP_CONTEXT , AUDIT_BUILD_CONTEXT , AUDIT_RECORD_CONTEXT } ;

struct audit_chunk ;

struct audit_entry { struct list_head list ; struct rcu_head rcu ; struct audit_krule rule ; } ;

struct audit_netlink_list { int pid ; struct sk_buff_head q ; } ;

void recalc_sigpending_and_wake ( struct task_struct * t ) ;

void recalc_sigpending ( void ) ;

int next_signal ( struct sigpending * pending , sigset_t * mask ) ;

void flush_sigqueue ( struct sigpending * queue ) ;

void __flush_signals ( struct task_struct * t ) ;

void flush_signals ( struct task_struct * t ) ;

void flush_itimer_signals ( void ) ;

void ignore_signals ( struct task_struct * t ) ;

void flush_signal_handlers ( struct task_struct * t , int force_default ) ;

int unhandled_signal ( struct task_struct * tsk , int sig ) ;

void block_all_signals ( int ( * notifier ) ( void * priv ) , void * priv , sigset_t * mask ) ;

void unblock_all_signals ( void ) ;

int dequeue_signal ( struct task_struct * tsk , sigset_t * mask , siginfo_t * info ) ;

void signal_wake_up ( struct task_struct * t , int resume ) ;

int __group_send_sig_info ( int sig , struct siginfo * info , struct task_struct * p ) ;

int do_send_sig_info ( int sig , struct siginfo * info , struct task_struct * p , bool group ) ;

int force_sig_info ( int sig , struct siginfo * info , struct task_struct * t ) ;

void force_sig_specific ( int sig , struct task_struct * t ) ;

void zap_other_threads ( struct task_struct * p ) ;

struct sighand_struct * lock_task_sighand ( struct task_struct * tsk , unsigned long * flags ) ;

int group_send_sig_info ( int sig , struct siginfo * info , struct task_struct * p ) ;

int __kill_pgrp_info ( int sig , struct siginfo * info , struct pid * pgrp ) ;

int kill_pid_info ( int sig , struct siginfo * info , struct pid * pid ) ;

int kill_proc_info ( int sig , struct siginfo * info , pid_t pid ) ;

int kill_pid_info_as_uid ( int sig , struct siginfo * info , struct pid * pid , uid_t uid , uid_t euid , u32 secid ) ;

int send_sig_info ( int sig , struct siginfo * info , struct task_struct * p ) ;

int send_sig ( int sig , struct task_struct * p , int priv ) ;

void force_sig ( int sig , struct task_struct * p ) ;

int force_sigsegv ( int sig , struct task_struct * p ) ;

int kill_pgrp ( struct pid * pid , int sig , int priv ) ;

int kill_pid ( struct pid * pid , int sig , int priv ) ;

struct sigqueue * sigqueue_alloc ( void ) ;

void sigqueue_free ( struct sigqueue * q ) ;

int send_sigqueue ( struct sigqueue * q , struct task_struct * t , int group ) ;

int do_notify_parent ( struct task_struct * tsk , int sig ) ;

void ptrace_notify ( int exit_code ) ;

int get_signal_to_deliver ( siginfo_t * info , struct k_sigaction * return_ka , struct pt_regs * regs , void * cookie ) ;

void exit_signals ( struct task_struct * tsk ) ;

long sys_restart_syscall ( void ) ;

long do_no_restart_syscall ( struct restart_block * param ) ;

int sigprocmask ( int how , sigset_t * set , sigset_t * oldset ) ;

long sys_rt_sigprocmask ( int how , sigset_t * set , sigset_t * oset , size_t sigsetsize ) ;

long do_sigpending ( void * set , unsigned long sigsetsize ) ;

long sys_rt_sigpending ( sigset_t * set , size_t sigsetsize ) ;

int copy_siginfo_to_user ( siginfo_t * to , siginfo_t * from ) ;

long sys_rt_sigtimedwait ( const sigset_t * uthese , siginfo_t * uinfo , const struct timespec * uts , size_t sigsetsize ) ;

long sys_kill ( pid_t pid , int sig ) ;

long sys_tgkill ( pid_t tgid , pid_t pid , int sig ) ;

long sys_tkill ( pid_t pid , int sig ) ;

long sys_rt_sigqueueinfo ( pid_t pid , int sig , siginfo_t * uinfo ) ;

long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) ;

long sys_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * uinfo ) ;

int do_sigaction ( int sig , struct k_sigaction * act , struct k_sigaction * oact ) ;

int do_sigaltstack ( const stack_t * uss , stack_t * uoss , unsigned long sp ) ;

long sys_sigpending ( old_sigset_t * set ) ;

long sys_sigprocmask ( int how , old_sigset_t * set , old_sigset_t * oset ) ;

long sys_rt_sigaction ( int sig , const struct sigaction * act , struct sigaction * oact , size_t sigsetsize ) ;

long sys_sgetmask ( void ) ;

long sys_ssetmask ( int newmask ) ;

long sys_signal ( int sig , __sighandler_t handler ) ;

long sys_pause ( void ) ;

long sys_rt_sigsuspend ( sigset_t * unewset , size_t sigsetsize ) ;

__attribute__ ( ( weak ) ) const char * arch_vma_name ( struct vm_area_struct * vma ) ;
void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) signals_init ( void ) ;

struct dcookie_user ;

long sys_setpriority ( int which , int who , int niceval ) ;

long sys_getpriority ( int which , int who ) ;

void emergency_restart ( void ) ;

void kernel_restart_prepare ( char * cmd ) ;

void kernel_restart ( char * cmd ) ;

void kernel_halt ( void ) ;

void kernel_power_off ( void ) ;

long sys_reboot ( int magic1 , int magic2 , unsigned int cmd , void * arg ) ;

void ctrl_alt_del ( void ) ;

long sys_setregid ( gid_t rgid , gid_t egid ) ;

long sys_setgid ( gid_t gid ) ;

long sys_setreuid ( uid_t ruid , uid_t euid ) ;

long sys_setuid ( uid_t uid ) ;

long sys_setresuid ( uid_t ruid , uid_t euid , uid_t suid ) ;

long sys_getresuid ( uid_t * ruid , uid_t * euid , uid_t * suid ) ;

long sys_setresgid ( gid_t rgid , gid_t egid , gid_t sgid ) ;

long sys_getresgid ( gid_t * rgid , gid_t * egid , gid_t * sgid ) ;

long sys_setfsuid ( uid_t uid ) ;

long sys_setfsgid ( gid_t gid ) ;

void do_sys_times ( struct tms * tms ) ;

long sys_times ( struct tms * tbuf ) ;

long sys_setpgid ( pid_t pid , pid_t pgid ) ;

long sys_getpgid ( pid_t pid ) ;

long sys_getpgrp ( void ) ;

long sys_getsid ( pid_t pid ) ;

long sys_setsid ( void ) ;

long sys_newuname ( struct new_utsname * name ) ;

long sys_sethostname ( char * name , int len ) ;

long sys_gethostname ( char * name , int len ) ;

long sys_setdomainname ( char * name , int len ) ;

long sys_getrlimit ( unsigned int resource , struct rlimit * rlim ) ;

long sys_old_getrlimit ( unsigned int resource , struct rlimit * rlim ) ;

long sys_setrlimit ( unsigned int resource , struct rlimit * rlim ) ;

int getrusage ( struct task_struct * p , int who , struct rusage * ru ) ;

long sys_getrusage ( int who , struct rusage * ru ) ;

long sys_umask ( int mask ) ;

long sys_prctl ( int option , unsigned long arg2 , unsigned long arg3 , unsigned long arg4 , unsigned long arg5 ) ;

long sys_getcpu ( unsigned * cpup , unsigned * nodep , struct getcpu_cache * unused ) ;

int orderly_poweroff ( bool force ) ;

int __request_module ( bool wait , const char * fmt , ... ) ;

struct subprocess_info { struct work_struct work ; struct completion * complete ; struct cred * cred ; char * path ; char * * argv ; char * * envp ; enum umh_wait wait ; int retval ; struct file * stdin ; void ( * cleanup ) ( char * * argv , char * * envp ) ; } ;
void call_usermodehelper_freeinfo ( struct subprocess_info * info ) ;

int usermodehelper_disable ( void ) ;

void usermodehelper_enable ( void ) ;

struct subprocess_info * call_usermodehelper_setup ( char * path , char * * argv , char * * envp , gfp_t gfp_mask ) ;

void call_usermodehelper_setkeys ( struct subprocess_info * info , struct key * session_keyring ) ;

void call_usermodehelper_setcleanup ( struct subprocess_info * info , void ( * cleanup ) ( char * * argv , char * * envp ) ) ;

int call_usermodehelper_stdinpipe ( struct subprocess_info * sub_info , struct file * * filp ) ;

int call_usermodehelper_exec ( struct subprocess_info * sub_info , enum umh_wait wait ) ;

int call_usermodehelper_pipe ( char * path , char * * argv , char * * envp , struct file * * filp ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) usermodehelper_init ( void ) ;

struct ftrace_raw_workqueue_insertion { struct trace_entry ent ; char thread_comm [ 16 ] ; pid_t thread_pid ; work_func_t func ; char __data [ 0 ] ; } ;

struct ftrace_raw_workqueue_execution { struct trace_entry ent ; char thread_comm [ 16 ] ; pid_t thread_pid ; work_func_t func ; char __data [ 0 ] ; } ;

struct ftrace_raw_workqueue_creation { struct trace_entry ent ; char thread_comm [ 16 ] ; pid_t thread_pid ; int cpu ; char __data [ 0 ] ; } ;

struct ftrace_raw_workqueue_destruction { struct trace_entry ent ; char thread_comm [ 16 ] ; pid_t thread_pid ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_workqueue_insertion { ; } ;

struct ftrace_data_offsets_workqueue_execution { ; } ;

struct ftrace_data_offsets_workqueue_creation { ; } ;

struct ftrace_data_offsets_workqueue_destruction { ; } ;

struct cpu_workqueue_struct { spinlock_t lock ; struct list_head worklist ; wait_queue_head_t more_work ; struct work_struct * current_work ; struct workqueue_struct * wq ; struct task_struct * thread ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct workqueue_struct { struct cpu_workqueue_struct * cpu_wq ; struct list_head list ; const char * name ; int singlethread ; int freezeable ; int rt ; } ;
int queue_work ( struct workqueue_struct * wq , struct work_struct * work ) ;

int queue_work_on ( int cpu , struct workqueue_struct * wq , struct work_struct * work ) ;

int queue_delayed_work ( struct workqueue_struct * wq , struct delayed_work * dwork , unsigned long delay ) ;

int queue_delayed_work_on ( int cpu , struct workqueue_struct * wq , struct delayed_work * dwork , unsigned long delay ) ;

struct wq_barrier { struct work_struct work ; struct completion done ; } ;

void flush_workqueue ( struct workqueue_struct * wq ) ;

int flush_work ( struct work_struct * work ) ;

int cancel_work_sync ( struct work_struct * work ) ;

int cancel_delayed_work_sync ( struct delayed_work * dwork ) ;

int schedule_work ( struct work_struct * work ) ;

int schedule_work_on ( int cpu , struct work_struct * work ) ;

int schedule_delayed_work ( struct delayed_work * dwork , unsigned long delay ) ;

void flush_delayed_work ( struct delayed_work * dwork ) ;

int schedule_delayed_work_on ( int cpu , struct delayed_work * dwork , unsigned long delay ) ;

int schedule_on_each_cpu ( work_func_t func ) ;

void flush_scheduled_work ( void ) ;

int execute_in_process_context ( work_func_t fn , struct execute_work * ew ) ;

int keventd_up ( void ) ;

int current_is_keventd ( void ) ;

struct workqueue_struct * __create_workqueue_key ( const char * name , int singlethread , int freezeable , int rt , struct lock_class_key * key , const char * lock_name ) ;

void destroy_workqueue ( struct workqueue_struct * wq ) ;

struct work_for_cpu { struct completion completion ; long ( * fn ) ( void * ) ; void * arg ; long ret ; } ;

long work_on_cpu ( unsigned int cpu , long ( * fn ) ( void * ) , void * arg ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_workqueues ( void ) ;

int is_container_init ( struct task_struct * tsk ) ;

int next_pidmap ( struct pid_namespace * pid_ns , int last ) ;

void put_pid ( struct pid * pid ) ;

void free_pid ( struct pid * pid ) ;

struct pid * alloc_pid ( struct pid_namespace * ns ) ;

struct pid * find_pid_ns ( int nr , struct pid_namespace * ns ) ;

struct pid * find_vpid ( int nr ) ;

void attach_pid ( struct task_struct * task , enum pid_type type , struct pid * pid ) ;

void detach_pid ( struct task_struct * task , enum pid_type type ) ;

void change_pid ( struct task_struct * task , enum pid_type type , struct pid * pid ) ;

void transfer_pid ( struct task_struct * old , struct task_struct * new , enum pid_type type ) ;

struct task_struct * pid_task ( struct pid * pid , enum pid_type type ) ;

struct task_struct * find_task_by_pid_ns ( pid_t nr , struct pid_namespace * ns ) ;

struct task_struct * find_task_by_vpid ( pid_t vnr ) ;

struct pid * get_task_pid ( struct task_struct * task , enum pid_type type ) ;

struct task_struct * get_pid_task ( struct pid * pid , enum pid_type type ) ;

struct pid * find_get_pid ( pid_t nr ) ;

pid_t pid_nr_ns ( struct pid * pid , struct pid_namespace * ns ) ;

pid_t pid_vnr ( struct pid * pid ) ;

pid_t __task_pid_nr_ns ( struct task_struct * task , enum pid_type type , struct pid_namespace * ns ) ;

pid_t task_tgid_nr_ns ( struct task_struct * tsk , struct pid_namespace * ns ) ;

struct pid_namespace * task_active_pid_ns ( struct task_struct * tsk ) ;

struct pid * find_ge_pid ( int nr , struct pid_namespace * ns ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pidhash_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pidmap_init ( void ) ;

void wakeme_after_rcu ( struct rcu_head * head ) ;

void synchronize_sched ( void ) ;

void synchronize_rcu_bh ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rcu_init ( void ) ;

void rcu_scheduler_starting ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sort_main_extable ( void ) ;

const struct exception_table_entry * search_exception_tables ( unsigned long addr ) ;

int core_kernel_text ( unsigned long addr ) ;

int __kernel_text_address ( unsigned long addr ) ;

int kernel_text_address ( unsigned long addr ) ;

int func_ptr_is_kernel_text ( void * ptr ) ;

int parse_args ( const char * name , char * args , struct kernel_param * params , unsigned num , int ( * unknown ) ( char * param , char * val ) ) ;

int param_set_byte ( const char * val , struct kernel_param * kp ) ;

int param_get_byte ( char * buffer , struct kernel_param * kp ) ;

int param_set_short ( const char * val , struct kernel_param * kp ) ;

int param_get_short ( char * buffer , struct kernel_param * kp ) ;

int param_set_ushort ( const char * val , struct kernel_param * kp ) ;

int param_get_ushort ( char * buffer , struct kernel_param * kp ) ;

int param_set_int ( const char * val , struct kernel_param * kp ) ;

int param_get_int ( char * buffer , struct kernel_param * kp ) ;

int param_set_uint ( const char * val , struct kernel_param * kp ) ;

int param_get_uint ( char * buffer , struct kernel_param * kp ) ;

int param_set_long ( const char * val , struct kernel_param * kp ) ;

int param_get_long ( char * buffer , struct kernel_param * kp ) ;

int param_set_ulong ( const char * val , struct kernel_param * kp ) ;

int param_get_ulong ( char * buffer , struct kernel_param * kp ) ;

int param_set_charp ( const char * val , struct kernel_param * kp ) ;

int param_get_charp ( char * buffer , struct kernel_param * kp ) ;

int param_set_bool ( const char * val , struct kernel_param * kp ) ;

int param_get_bool ( char * buffer , struct kernel_param * kp ) ;

int param_set_invbool ( const char * val , struct kernel_param * kp ) ;

int param_get_invbool ( char * buffer , struct kernel_param * kp ) ;

int param_array_set ( const char * val , struct kernel_param * kp ) ;

int param_array_get ( char * buffer , struct kernel_param * kp ) ;

int param_set_copystring ( const char * val , struct kernel_param * kp ) ;

int param_get_string ( char * buffer , struct kernel_param * kp ) ;

struct param_attribute { struct module_attribute mattr ; struct kernel_param * param ; } ;

struct module_param_attrs { unsigned int num ; struct attribute_group grp ; struct param_attribute attrs [ 0 ] ; } ;

int module_param_sysfs_setup ( struct module * mod , struct kernel_param * kparam , unsigned int num_params ) ;

void module_param_sysfs_remove ( struct module * mod ) ;

void destroy_params ( const struct kernel_param * params , unsigned num ) ;

int posix_get_coarse_res ( const clockid_t which_clock , struct timespec * tp ) ;

void do_schedule_next_timer ( struct siginfo * info ) ;

int posix_timer_event ( struct k_itimer * timr , int si_private ) ;

void register_posix_clock ( const clockid_t clock_id , struct k_clock * new_clock ) ;

long sys_timer_create ( const clockid_t which_clock , struct sigevent * timer_event_spec , timer_t * created_timer_id ) ;

long sys_timer_gettime ( timer_t timer_id , struct itimerspec * setting ) ;

long sys_timer_getoverrun ( timer_t timer_id ) ;

long sys_timer_settime ( timer_t timer_id , int flags , const struct itimerspec * new_setting , struct itimerspec * old_setting ) ;

long sys_timer_delete ( timer_t timer_id ) ;

void exit_itimers ( struct signal_struct * sig ) ;

int do_posix_clock_nosettime ( const clockid_t clockid , struct timespec * tp ) ;

int do_posix_clock_nonanosleep ( const clockid_t clock , int flags , struct timespec * t , struct timespec * r ) ;

long sys_clock_settime ( const clockid_t which_clock , const struct timespec * tp ) ;

long sys_clock_gettime ( const clockid_t which_clock , struct timespec * tp ) ;

long sys_clock_getres ( const clockid_t which_clock , struct timespec * tp ) ;

long sys_clock_nanosleep ( const clockid_t which_clock , int flags , const struct timespec * rqtp , struct timespec * rmtp ) ;

long clock_nanosleep_restart ( struct restart_block * restart_block ) ;

struct kthread_create_info { int ( * threadfn ) ( void * data ) ; void * data ; struct task_struct * result ; struct completion done ; struct list_head list ; } ;

struct kthread { int should_stop ; struct completion exited ; } ;

int kthread_should_stop ( void ) ;

struct task_struct * kthread_create ( int ( * threadfn ) ( void * data ) , void * data , const char namefmt [ ] , ... ) ;

int kthread_stop ( struct task_struct * k ) ;

int kthreadd ( void * unused ) ;

void __init_waitqueue_head ( wait_queue_head_t * q , struct lock_class_key * key ) ;

void add_wait_queue ( wait_queue_head_t * q , wait_queue_t * wait ) ;

void add_wait_queue_exclusive ( wait_queue_head_t * q , wait_queue_t * wait ) ;

void remove_wait_queue ( wait_queue_head_t * q , wait_queue_t * wait ) ;

void prepare_to_wait ( wait_queue_head_t * q , wait_queue_t * wait , int state ) ;

void prepare_to_wait_exclusive ( wait_queue_head_t * q , wait_queue_t * wait , int state ) ;

void finish_wait ( wait_queue_head_t * q , wait_queue_t * wait ) ;

void abort_exclusive_wait ( wait_queue_head_t * q , wait_queue_t * wait , unsigned int mode , void * key ) ;

int autoremove_wake_function ( wait_queue_t * wait , unsigned mode , int sync , void * key ) ;

int wake_bit_function ( wait_queue_t * wait , unsigned mode , int sync , void * arg ) ;

int __attribute__ ( ( __section__ ( ) ) ) __wait_on_bit ( wait_queue_head_t * wq , struct wait_bit_queue * q , int ( * action ) ( void * ) , unsigned mode ) ;

int __attribute__ ( ( __section__ ( ) ) ) out_of_line_wait_on_bit ( void * word , int bit , int ( * action ) ( void * ) , unsigned mode ) ;

int __attribute__ ( ( __section__ ( ) ) ) __wait_on_bit_lock ( wait_queue_head_t * wq , struct wait_bit_queue * q , int ( * action ) ( void * ) , unsigned mode ) ;

int __attribute__ ( ( __section__ ( ) ) ) out_of_line_wait_on_bit_lock ( void * word , int bit , int ( * action ) ( void * ) , unsigned mode ) ;

void __wake_up_bit ( wait_queue_head_t * wq , void * word , int bit ) ;

void wake_up_bit ( void * word , int bit ) ;

wait_queue_head_t * bit_waitqueue ( void * word , int bit ) ;

struct kfifo { unsigned char * buffer ; unsigned int size ; unsigned int in ; unsigned int out ; spinlock_t * lock ; } ;

struct kfifo * kfifo_init ( unsigned char * buffer , unsigned int size , gfp_t gfp_mask , spinlock_t * lock ) ;

struct kfifo * kfifo_alloc ( unsigned int size , gfp_t gfp_mask , spinlock_t * lock ) ;

void kfifo_free ( struct kfifo * fifo ) ;

unsigned int __kfifo_put ( struct kfifo * fifo , const unsigned char * buffer , unsigned int len ) ;

unsigned int __kfifo_get ( struct kfifo * fifo , unsigned char * buffer , unsigned int len ) ;

long sys_ni_syscall ( void ) ;

void update_rlimit_cpu ( unsigned long rlim_new ) ;

int posix_cpu_clock_getres ( const clockid_t which_clock , struct timespec * tp ) ;

int posix_cpu_clock_set ( const clockid_t which_clock , const struct timespec * tp ) ;

void thread_group_cputime ( struct task_struct * tsk , struct task_cputime * times ) ;

void thread_group_cputimer ( struct task_struct * tsk , struct task_cputime * times ) ;
int posix_cpu_clock_get ( const clockid_t which_clock , struct timespec * tp ) ;

int posix_cpu_timer_create ( struct k_itimer * new_timer ) ;

int posix_cpu_timer_del ( struct k_itimer * timer ) ;

void posix_cpu_timers_exit ( struct task_struct * tsk ) ;

void posix_cpu_timers_exit_group ( struct task_struct * tsk ) ;

int posix_cpu_timer_set ( struct k_itimer * timer , int flags , struct itimerspec * new , struct itimerspec * old ) ;

void posix_cpu_timer_get ( struct k_itimer * timer , struct itimerspec * itp ) ;

void posix_cpu_timer_schedule ( struct k_itimer * timer ) ;

void run_posix_cpu_timers ( struct task_struct * tsk ) ;

void set_process_cpu_timer ( struct task_struct * tsk , unsigned int clock_idx , cputime_t * newval , cputime_t * oldval ) ;

int posix_cpu_nsleep ( const clockid_t which_clock , int flags , struct timespec * rqtp , struct timespec * rmtp ) ;

long posix_cpu_nsleep_restart ( struct restart_block * restart_block ) ;

void __mutex_init ( struct mutex * lock , const char * name , struct lock_class_key * key ) ;

void __attribute__ ( ( __section__ ( ) ) ) mutex_lock ( struct mutex * lock ) ;

void __attribute__ ( ( __section__ ( ) ) ) mutex_unlock ( struct mutex * lock ) ;

int __attribute__ ( ( __section__ ( ) ) ) mutex_lock_interruptible ( struct mutex * lock ) ;

int __attribute__ ( ( __section__ ( ) ) ) mutex_lock_killable ( struct mutex * lock ) ;

int __attribute__ ( ( __section__ ( ) ) ) mutex_trylock ( struct mutex * lock ) ;

int atomic_dec_and_mutex_lock ( atomic_t * cnt , struct mutex * lock ) ;

ktime_t ktime_add_safe ( const ktime_t lhs , const ktime_t rhs ) ;

void clock_was_set ( void ) ;

void hres_timers_resume ( void ) ;

void __timer_stats_hrtimer_set_start_info ( struct hrtimer * timer , void * addr ) ;

u64 hrtimer_forward ( struct hrtimer * timer , ktime_t now , ktime_t interval ) ;

int __hrtimer_start_range_ns ( struct hrtimer * timer , ktime_t tim , unsigned long delta_ns , const enum hrtimer_mode mode , int wakeup ) ;

int hrtimer_start_range_ns ( struct hrtimer * timer , ktime_t tim , unsigned long delta_ns , const enum hrtimer_mode mode ) ;

int hrtimer_start ( struct hrtimer * timer , ktime_t tim , const enum hrtimer_mode mode ) ;

int hrtimer_try_to_cancel ( struct hrtimer * timer ) ;

int hrtimer_cancel ( struct hrtimer * timer ) ;

ktime_t hrtimer_get_remaining ( const struct hrtimer * timer ) ;

ktime_t hrtimer_get_next_event ( void ) ;

void hrtimer_init ( struct hrtimer * timer , clockid_t clock_id , enum hrtimer_mode mode ) ;

int hrtimer_get_res ( const clockid_t which_clock , struct timespec * tp ) ;

void hrtimer_interrupt ( struct clock_event_device * dev ) ;

void hrtimer_peek_ahead_timers ( void ) ;

void hrtimer_run_pending ( void ) ;

void hrtimer_run_queues ( void ) ;

void hrtimer_init_sleeper ( struct hrtimer_sleeper * sl , struct task_struct * task ) ;

long __attribute__ ( ( __section__ ( ) ) ) hrtimer_nanosleep_restart ( struct restart_block * restart ) ;

long hrtimer_nanosleep ( struct timespec * rqtp , struct timespec * rmtp , const enum hrtimer_mode mode , const clockid_t clockid ) ;

long sys_nanosleep ( struct timespec * rqtp , struct timespec * rmtp ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) hrtimers_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) schedule_hrtimeout_range ( ktime_t * expires , unsigned long delta , const enum hrtimer_mode mode ) ;

int __attribute__ ( ( __section__ ( ) ) ) schedule_hrtimeout ( ktime_t * expires , const enum hrtimer_mode mode ) ;

void __attribute__ ( ( __section__ ( ) ) ) down_read ( struct rw_semaphore * sem ) ;

int down_read_trylock ( struct rw_semaphore * sem ) ;

void __attribute__ ( ( __section__ ( ) ) ) down_write ( struct rw_semaphore * sem ) ;

int down_write_trylock ( struct rw_semaphore * sem ) ;

void up_read ( struct rw_semaphore * sem ) ;

void up_write ( struct rw_semaphore * sem ) ;

void downgrade_write ( struct rw_semaphore * sem ) ;

struct mnt_namespace { atomic_t count ; struct vfsmount * root ; struct list_head list ; wait_queue_head_t poll ; int event ; } ;
struct proc_mounts { struct seq_file m ; struct mnt_namespace * ns ; struct path root ; int event ; } ;

struct ipc_ids { int in_use ; unsigned short seq ; unsigned short seq_max ; struct rw_semaphore rw_mutex ; struct idr ipcs_idr ; } ;

struct ipc_namespace { atomic_t count ; struct ipc_ids ids [ 3 ] ; int sem_ctls [ 4 ] ; int used_sems ; int msg_ctlmax ; int msg_ctlmnb ; int msg_ctlmni ; atomic_t msg_bytes ; atomic_t msg_hdrs ; int auto_msgmni ; size_t shm_ctlmax ; size_t shm_ctlall ; int shm_ctlmni ; int shm_tot ; struct notifier_block ipcns_nb ; struct vfsmount * mq_mnt ; unsigned int mq_queues_count ; unsigned int mq_queues_max ; unsigned int mq_msg_max ; unsigned int mq_msgsize_max ; } ;
int copy_namespaces ( unsigned long flags , struct task_struct * tsk ) ;

void free_nsproxy ( struct nsproxy * ns ) ;

int unshare_nsproxy_namespaces ( unsigned long unshare_flags , struct nsproxy * * new_nsp , struct fs_struct * new_fs ) ;

void switch_task_namespaces ( struct task_struct * p , struct nsproxy * new ) ;

void exit_task_namespaces ( struct task_struct * p ) ;

int init_srcu_struct ( struct srcu_struct * sp ) ;

void cleanup_srcu_struct ( struct srcu_struct * sp ) ;

int srcu_read_lock ( struct srcu_struct * sp ) ;

void srcu_read_unlock ( struct srcu_struct * sp , int idx ) ;

void synchronize_srcu ( struct srcu_struct * sp ) ;

long srcu_batches_completed ( struct srcu_struct * sp ) ;

void down ( struct semaphore * sem ) ;

int down_interruptible ( struct semaphore * sem ) ;

int down_killable ( struct semaphore * sem ) ;

int down_trylock ( struct semaphore * sem ) ;

int down_timeout ( struct semaphore * sem , long jiffies ) ;

void up ( struct semaphore * sem ) ;

struct semaphore_waiter { struct list_head list ; struct task_struct * task ; int up ; } ;

int atomic_notifier_chain_register ( struct atomic_notifier_head * nh , struct notifier_block * n ) ;

int atomic_notifier_chain_unregister ( struct atomic_notifier_head * nh , struct notifier_block * n ) ;

int __attribute__ ( ( __section__ ( ) ) ) __atomic_notifier_call_chain ( struct atomic_notifier_head * nh , unsigned long val , void * v , int nr_to_call , int * nr_calls ) ;

int __attribute__ ( ( __section__ ( ) ) ) atomic_notifier_call_chain ( struct atomic_notifier_head * nh , unsigned long val , void * v ) ;

int blocking_notifier_chain_register ( struct blocking_notifier_head * nh , struct notifier_block * n ) ;

int blocking_notifier_chain_cond_register ( struct blocking_notifier_head * nh , struct notifier_block * n ) ;

int blocking_notifier_chain_unregister ( struct blocking_notifier_head * nh , struct notifier_block * n ) ;

int __blocking_notifier_call_chain ( struct blocking_notifier_head * nh , unsigned long val , void * v , int nr_to_call , int * nr_calls ) ;

int blocking_notifier_call_chain ( struct blocking_notifier_head * nh , unsigned long val , void * v ) ;

int raw_notifier_chain_register ( struct raw_notifier_head * nh , struct notifier_block * n ) ;

int raw_notifier_chain_unregister ( struct raw_notifier_head * nh , struct notifier_block * n ) ;

int __raw_notifier_call_chain ( struct raw_notifier_head * nh , unsigned long val , void * v , int nr_to_call , int * nr_calls ) ;

int raw_notifier_call_chain ( struct raw_notifier_head * nh , unsigned long val , void * v ) ;

int srcu_notifier_chain_register ( struct srcu_notifier_head * nh , struct notifier_block * n ) ;

int srcu_notifier_chain_unregister ( struct srcu_notifier_head * nh , struct notifier_block * n ) ;

int __srcu_notifier_call_chain ( struct srcu_notifier_head * nh , unsigned long val , void * v , int nr_to_call , int * nr_calls ) ;

int srcu_notifier_call_chain ( struct srcu_notifier_head * nh , unsigned long val , void * v ) ;

void srcu_init_notifier_head ( struct srcu_notifier_head * nh ) ;

int register_reboot_notifier ( struct notifier_block * nb ) ;

int unregister_reboot_notifier ( struct notifier_block * nb ) ;

int __attribute__ ( ( no_instrument_function ) ) notify_die ( enum die_val val , const char * str , struct pt_regs * regs , long err , int trap , int sig ) ;

int register_die_notifier ( struct notifier_block * nb ) ;

int unregister_die_notifier ( struct notifier_block * nb ) ;

struct requirement_list { struct list_head list ; union { s32 value ; s32 usec ; s32 kbps ; } ; char * name ; } ;

struct pm_qos_object { struct requirement_list requirements ; struct blocking_notifier_head * notifiers ; struct miscdevice pm_qos_power_miscdev ; char * name ; s32 default_value ; atomic_t target_value ; s32 ( * comparitor ) ( s32 , s32 ) ; } ;

int pm_qos_requirement ( int pm_qos_class ) ;

int pm_qos_add_requirement ( int pm_qos_class , char * name , s32 value ) ;

int pm_qos_update_requirement ( int pm_qos_class , char * name , s32 new_value ) ;

void pm_qos_remove_requirement ( int pm_qos_class , char * name ) ;

int pm_qos_add_notifier ( int pm_qos_class , struct notifier_block * notifier ) ;

int pm_qos_remove_notifier ( int pm_qos_class , struct notifier_block * notifier ) ;

unsigned long long __attribute__ ( ( weak ) ) sched_clock ( void ) ;
struct sched_clock_data { u64 tick_raw ; u64 tick_gtod ; u64 clock ; } ;

void sched_clock_init ( void ) ;

u64 sched_clock_cpu ( int cpu ) ;

void sched_clock_tick ( void ) ;

void sched_clock_idle_sleep_event ( void ) ;

void sched_clock_idle_wakeup_event ( u64 delta_ns ) ;

unsigned long long cpu_clock ( int cpu ) ;

void __put_cred ( struct cred * cred ) ;

void exit_creds ( struct task_struct * tsk ) ;

struct cred * cred_alloc_blank ( void ) ;

struct cred * prepare_creds ( void ) ;

struct cred * prepare_exec_creds ( void ) ;

struct cred * prepare_usermodehelper_creds ( void ) ;

int copy_creds ( struct task_struct * p , unsigned long clone_flags ) ;

int commit_creds ( struct cred * new ) ;

void abort_creds ( struct cred * new ) ;

const struct cred * override_creds ( const struct cred * new ) ;

void revert_creds ( const struct cred * old ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) cred_init ( void ) ;

struct cred * prepare_kernel_cred ( struct task_struct * daemon ) ;

int set_security_override ( struct cred * new , u32 secid ) ;

int set_security_override_from_ctx ( struct cred * new , const char * secctx ) ;

int set_create_files_as ( struct cred * new , struct inode * inode ) ;

struct async_entry { struct list_head list ; async_cookie_t cookie ; async_func_ptr * func ; void * data ; struct list_head * running ; } ;

async_cookie_t async_schedule ( async_func_ptr * ptr , void * data ) ;

async_cookie_t async_schedule_domain ( async_func_ptr * ptr , void * data , struct list_head * running ) ;

void async_synchronize_full ( void ) ;

void async_synchronize_full_domain ( struct list_head * list ) ;

void async_synchronize_cookie_domain ( async_cookie_t cookie , struct list_head * running ) ;

void async_synchronize_cookie ( async_cookie_t cookie ) ;

struct group_info * groups_alloc ( int gidsetsize ) ;

void groups_free ( struct group_info * group_info ) ;

int groups_search ( const struct group_info * group_info , gid_t grp ) ;

int set_groups ( struct cred * new , struct group_info * group_info ) ;

int set_current_groups ( struct group_info * group_info ) ;

long sys_getgroups ( int gidsetsize , gid_t * grouplist ) ;

long sys_setgroups ( int gidsetsize , gid_t * grouplist ) ;

int in_group_p ( gid_t grp ) ;

int in_egroup_p ( gid_t grp ) ;

void refrigerator ( void ) ;

bool freeze_task ( struct task_struct * p , bool sig_only ) ;

void cancel_freezing ( struct task_struct * p ) ;

int thaw_process ( struct task_struct * p ) ;

struct profile_hit { u32 pc , hits ; } ;

int profile_setup ( char * str ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) profile_init ( void ) ;

void profile_task_exit ( struct task_struct * task ) ;

int profile_handoff_task ( struct task_struct * task ) ;

void profile_munmap ( unsigned long addr ) ;

int task_handoff_register ( struct notifier_block * n ) ;

int task_handoff_unregister ( struct notifier_block * n ) ;

int profile_event_register ( enum profile_type type , struct notifier_block * n ) ;

int profile_event_unregister ( enum profile_type type , struct notifier_block * n ) ;

int register_timer_hook ( int ( * hook ) ( struct pt_regs * ) ) ;

void unregister_timer_hook ( int ( * hook ) ( struct pt_regs * ) ) ;

void profile_hits ( int type , void * __pc , unsigned int nr_hits ) ;

void profile_tick ( int type ) ;

void create_prof_cpu_mask ( struct proc_dir_entry * root_irq_dir ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) create_proc_profile ( void ) ;


typedef struct xfs_sysctl_val { int min ; int val ; int max ; } xfs_sysctl_val_t ;


typedef struct xfs_param { xfs_sysctl_val_t sgid_inherit ; xfs_sysctl_val_t symlink_mode ; xfs_sysctl_val_t panic_mask ; xfs_sysctl_val_t error_level ; xfs_sysctl_val_t syncd_timer ; xfs_sysctl_val_t stats_clear ; xfs_sysctl_val_t inherit_sync ; xfs_sysctl_val_t inherit_nodump ; xfs_sysctl_val_t inherit_noatim ; xfs_sysctl_val_t xfs_buf_timer ; xfs_sysctl_val_t xfs_buf_age ; xfs_sysctl_val_t inherit_nosym ; xfs_sysctl_val_t rotorstep ; xfs_sysctl_val_t inherit_nodfrg ; xfs_sysctl_val_t fstrm_timer ; } xfs_param_t ;

enum { XFS_SGID_INHERIT = 4 , XFS_SYMLINK_MODE = 5 , XFS_PANIC_MASK = 6 , XFS_ERRLEVEL = 7 , XFS_SYNCD_TIMER = 8 , XFS_STATS_CLEAR = 12 , XFS_INHERIT_SYNC = 13 , XFS_INHERIT_NODUMP = 14 , XFS_INHERIT_NOATIME = 15 , XFS_BUF_TIMER = 16 , XFS_BUF_AGE = 17 , XFS_INHERIT_NOSYM = 19 , XFS_ROTORSTEP = 20 , XFS_INHERIT_NODFRG = 21 , XFS_FILESTREAM_TIMER = 22 , } ;
struct ip_vs_service_user { __u16 protocol ; __be32 addr ; __be16 port ; __u32 fwmark ; char sched_name [ 16 ] ; unsigned flags ; unsigned timeout ; __be32 netmask ; } ;

struct ip_vs_dest_user { __be32 addr ; __be16 port ; unsigned conn_flags ; int weight ; __u32 u_threshold ; __u32 l_threshold ; } ;

struct ip_vs_stats_user { __u32 conns ; __u32 inpkts ; __u32 outpkts ; __u64 inbytes ; __u64 outbytes ; __u32 cps ; __u32 inpps ; __u32 outpps ; __u32 inbps ; __u32 outbps ; } ;

struct ip_vs_getinfo { unsigned int version ; unsigned int size ; unsigned int num_services ; } ;

struct ip_vs_service_entry { __u16 protocol ; __be32 addr ; __be16 port ; __u32 fwmark ; char sched_name [ 16 ] ; unsigned flags ; unsigned timeout ; __be32 netmask ; unsigned int num_dests ; struct ip_vs_stats_user stats ; } ;

struct ip_vs_dest_entry { __be32 addr ; __be16 port ; unsigned conn_flags ; int weight ; __u32 u_threshold ; __u32 l_threshold ; __u32 activeconns ; __u32 inactconns ; __u32 persistconns ; struct ip_vs_stats_user stats ; } ;

struct ip_vs_get_dests { __u16 protocol ; __be32 addr ; __be16 port ; __u32 fwmark ; unsigned int num_dests ; struct ip_vs_dest_entry entrytable [ 0 ] ; } ;

struct ip_vs_get_services { unsigned int num_services ; struct ip_vs_service_entry entrytable [ 0 ] ; } ;

struct ip_vs_timeout_user { int tcp_timeout ; int tcp_fin_timeout ; int udp_timeout ; } ;

struct ip_vs_daemon_user { int state ; char mcast_ifn [ 16 ] ; int syncid ; } ;

struct ip_vs_flags { __be32 flags ; __be32 mask ; } ;

enum { IPVS_CMD_UNSPEC = 0 , IPVS_CMD_NEW_SERVICE , IPVS_CMD_SET_SERVICE , IPVS_CMD_DEL_SERVICE , IPVS_CMD_GET_SERVICE , IPVS_CMD_NEW_DEST , IPVS_CMD_SET_DEST , IPVS_CMD_DEL_DEST , IPVS_CMD_GET_DEST , IPVS_CMD_NEW_DAEMON , IPVS_CMD_DEL_DAEMON , IPVS_CMD_GET_DAEMON , IPVS_CMD_SET_CONFIG , IPVS_CMD_GET_CONFIG , IPVS_CMD_SET_INFO , IPVS_CMD_GET_INFO , IPVS_CMD_ZERO , IPVS_CMD_FLUSH , __IPVS_CMD_MAX , } ;
enum { IPVS_CMD_ATTR_UNSPEC = 0 , IPVS_CMD_ATTR_SERVICE , IPVS_CMD_ATTR_DEST , IPVS_CMD_ATTR_DAEMON , IPVS_CMD_ATTR_TIMEOUT_TCP , IPVS_CMD_ATTR_TIMEOUT_TCP_FIN , IPVS_CMD_ATTR_TIMEOUT_UDP , __IPVS_CMD_ATTR_MAX , } ;
enum { IPVS_SVC_ATTR_UNSPEC = 0 , IPVS_SVC_ATTR_AF , IPVS_SVC_ATTR_PROTOCOL , IPVS_SVC_ATTR_ADDR , IPVS_SVC_ATTR_PORT , IPVS_SVC_ATTR_FWMARK , IPVS_SVC_ATTR_SCHED_NAME , IPVS_SVC_ATTR_FLAGS , IPVS_SVC_ATTR_TIMEOUT , IPVS_SVC_ATTR_NETMASK , IPVS_SVC_ATTR_STATS , __IPVS_SVC_ATTR_MAX , } ;
enum { IPVS_DEST_ATTR_UNSPEC = 0 , IPVS_DEST_ATTR_ADDR , IPVS_DEST_ATTR_PORT , IPVS_DEST_ATTR_FWD_METHOD , IPVS_DEST_ATTR_WEIGHT , IPVS_DEST_ATTR_U_THRESH , IPVS_DEST_ATTR_L_THRESH , IPVS_DEST_ATTR_ACTIVE_CONNS , IPVS_DEST_ATTR_INACT_CONNS , IPVS_DEST_ATTR_PERSIST_CONNS , IPVS_DEST_ATTR_STATS , __IPVS_DEST_ATTR_MAX , } ;
enum { IPVS_DAEMON_ATTR_UNSPEC = 0 , IPVS_DAEMON_ATTR_STATE , IPVS_DAEMON_ATTR_MCAST_IFN , IPVS_DAEMON_ATTR_SYNC_ID , __IPVS_DAEMON_ATTR_MAX , } ;
enum { IPVS_STATS_ATTR_UNSPEC = 0 , IPVS_STATS_ATTR_CONNS , IPVS_STATS_ATTR_INPKTS , IPVS_STATS_ATTR_OUTPKTS , IPVS_STATS_ATTR_INBYTES , IPVS_STATS_ATTR_OUTBYTES , IPVS_STATS_ATTR_CPS , IPVS_STATS_ATTR_INPPS , IPVS_STATS_ATTR_OUTPPS , IPVS_STATS_ATTR_INBPS , IPVS_STATS_ATTR_OUTBPS , __IPVS_STATS_ATTR_MAX , } ;
enum { IPVS_INFO_ATTR_UNSPEC = 0 , IPVS_INFO_ATTR_VERSION , IPVS_INFO_ATTR_CONN_TAB_SIZE , __IPVS_INFO_ATTR_MAX , } ;
struct iphdr { __u8 ihl : 4 , version : 4 ; __u8 tos ; __be16 tot_len ; __be16 id ; __be16 frag_off ; __u8 ttl ; __u8 protocol ; __sum16 check ; __be32 saddr ; __be32 daddr ; } ;

struct ip_auth_hdr { __u8 nexthdr ; __u8 hdrlen ; __be16 reserved ; __be32 spi ; __be32 seq_no ; __u8 auth_data [ 0 ] ; } ;

struct ip_esp_hdr { __be32 spi ; __be32 seq_no ; __u8 enc_data [ 0 ] ; } ;

struct ip_comp_hdr { __u8 nexthdr ; __u8 flags ; __be16 cpi ; } ;

struct ip_beet_phdr { __u8 nexthdr ; __u8 hdrlen ; __u8 padlen ; __u8 reserved ; } ;

struct ip_vs_iphdr { int len ; __u8 protocol ; union nf_inet_addr saddr ; union nf_inet_addr daddr ; } ;

enum { IP_VS_TCP_S_NONE = 0 , IP_VS_TCP_S_ESTABLISHED , IP_VS_TCP_S_SYN_SENT , IP_VS_TCP_S_SYN_RECV , IP_VS_TCP_S_FIN_WAIT , IP_VS_TCP_S_TIME_WAIT , IP_VS_TCP_S_CLOSE , IP_VS_TCP_S_CLOSE_WAIT , IP_VS_TCP_S_LAST_ACK , IP_VS_TCP_S_LISTEN , IP_VS_TCP_S_SYNACK , IP_VS_TCP_S_LAST } ;
enum { IP_VS_UDP_S_NORMAL , IP_VS_UDP_S_LAST , } ;
enum { IP_VS_ICMP_S_NORMAL , IP_VS_ICMP_S_LAST , } ;
struct ip_vs_seq { __u32 init_seq ; __u32 delta ; __u32 previous_delta ; } ;

struct ip_vs_estimator { struct list_head list ; u64 last_inbytes ; u64 last_outbytes ; u32 last_conns ; u32 last_inpkts ; u32 last_outpkts ; u32 cps ; u32 inpps ; u32 outpps ; u32 inbps ; u32 outbps ; } ;

struct ip_vs_stats { struct ip_vs_stats_user ustats ; struct ip_vs_estimator est ; spinlock_t lock ; } ;

struct iphdr ;
struct ip_vs_conn ;

struct ip_vs_app ;

struct ip_vs_protocol { struct ip_vs_protocol * next ; char * name ; u16 protocol ; u16 num_states ; int dont_defrag ; atomic_t appcnt ; int * timeout_table ; void ( * init ) ( struct ip_vs_protocol * pp ) ; void ( * exit ) ( struct ip_vs_protocol * pp ) ; int ( * conn_schedule ) ( int af , struct sk_buff * skb , struct ip_vs_protocol * pp , int * verdict , struct ip_vs_conn * * cpp ) ; struct ip_vs_conn * ( * conn_in_get ) ( int af , const struct sk_buff * skb , struct ip_vs_protocol * pp , const struct ip_vs_iphdr * iph , unsigned int proto_off , int inverse ) ; struct ip_vs_conn * ( * conn_out_get ) ( int af , const struct sk_buff * skb , struct ip_vs_protocol * pp , const struct ip_vs_iphdr * iph , unsigned int proto_off , int inverse ) ; int ( * snat_handler ) ( struct sk_buff * skb , struct ip_vs_protocol * pp , struct ip_vs_conn * cp ) ; int ( * dnat_handler ) ( struct sk_buff * skb , struct ip_vs_protocol * pp , struct ip_vs_conn * cp ) ; int ( * csum_check ) ( int af , struct sk_buff * skb , struct ip_vs_protocol * pp ) ; const char * ( * state_name ) ( int state ) ; int ( * state_transition ) ( struct ip_vs_conn * cp , int direction , const struct sk_buff * skb , struct ip_vs_protocol * pp ) ; int ( * register_app ) ( struct ip_vs_app * inc ) ; void ( * unregister_app ) ( struct ip_vs_app * inc ) ; int ( * app_conn_bind ) ( struct ip_vs_conn * cp ) ; void ( * debug_packet ) ( struct ip_vs_protocol * pp , const struct sk_buff * skb , int offset , const char * msg ) ; void ( * timeout_change ) ( struct ip_vs_protocol * pp , int flags ) ; int ( * set_state_timeout ) ( struct ip_vs_protocol * pp , char * sname , int to ) ; } ;

struct ip_vs_conn { struct list_head c_list ; u16 af ; union nf_inet_addr caddr ; union nf_inet_addr vaddr ; union nf_inet_addr daddr ; __be16 cport ; __be16 vport ; __be16 dport ; __u16 protocol ; atomic_t refcnt ; struct timer_list timer ; volatile unsigned long timeout ; spinlock_t lock ; volatile __u16 flags ; volatile __u16 state ; volatile __u16 old_state ; struct ip_vs_conn * control ; atomic_t n_control ; struct ip_vs_dest * dest ; atomic_t in_pkts ; int ( * packet_xmit ) ( struct sk_buff * skb , struct ip_vs_conn * cp , struct ip_vs_protocol * pp ) ; struct ip_vs_app * app ; void * app_data ; struct ip_vs_seq in_seq ; struct ip_vs_seq out_seq ; } ;
struct ip_vs_service_user_kern { u16 af ; u16 protocol ; union nf_inet_addr addr ; u16 port ; u32 fwmark ; char * sched_name ; unsigned flags ; unsigned timeout ; u32 netmask ; } ;

struct ip_vs_dest_user_kern { union nf_inet_addr addr ; u16 port ; unsigned conn_flags ; int weight ; u32 u_threshold ; u32 l_threshold ; } ;

struct ip_vs_service { struct list_head s_list ; struct list_head f_list ; atomic_t refcnt ; atomic_t usecnt ; u16 af ; __u16 protocol ; union nf_inet_addr addr ; __be16 port ; __u32 fwmark ; unsigned flags ; unsigned timeout ; __be32 netmask ; struct list_head destinations ; __u32 num_dests ; struct ip_vs_stats stats ; struct ip_vs_app * inc ; struct ip_vs_scheduler * scheduler ; rwlock_t sched_lock ; void * sched_data ; } ;

struct ip_vs_dest { struct list_head n_list ; struct list_head d_list ; u16 af ; union nf_inet_addr addr ; __be16 port ; volatile unsigned flags ; atomic_t conn_flags ; atomic_t weight ; atomic_t refcnt ; struct ip_vs_stats stats ; atomic_t activeconns ; atomic_t inactconns ; atomic_t persistconns ; __u32 u_threshold ; __u32 l_threshold ; spinlock_t dst_lock ; struct dst_entry * dst_cache ; u32 dst_rtos ; struct ip_vs_service * svc ; __u16 protocol ; union nf_inet_addr vaddr ; __be16 vport ; __u32 vfwmark ; } ;

struct ip_vs_scheduler { struct list_head n_list ; char * name ; atomic_t refcnt ; struct module * module ; int ( * init_service ) ( struct ip_vs_service * svc ) ; int ( * done_service ) ( struct ip_vs_service * svc ) ; int ( * update_service ) ( struct ip_vs_service * svc ) ; struct ip_vs_dest * ( * schedule ) ( struct ip_vs_service * svc , const struct sk_buff * skb ) ; } ;

struct ip_vs_app { struct list_head a_list ; int type ; char * name ; __u16 protocol ; struct module * module ; struct list_head incs_list ; struct list_head p_list ; struct ip_vs_app * app ; __be16 port ; atomic_t usecnt ; int ( * pkt_out ) ( struct ip_vs_app * , struct ip_vs_conn * , struct sk_buff * , int * diff ) ; int ( * pkt_in ) ( struct ip_vs_app * , struct ip_vs_conn * , struct sk_buff * , int * diff ) ; int ( * init_conn ) ( struct ip_vs_app * , struct ip_vs_conn * ) ; int ( * done_conn ) ( struct ip_vs_app * , struct ip_vs_conn * ) ; int ( * bind_conn ) ( struct ip_vs_app * , struct ip_vs_conn * , struct ip_vs_protocol * ) ; void ( * unbind_conn ) ( struct ip_vs_app * , struct ip_vs_conn * ) ; int * timeout_table ; int * timeouts ; int timeouts_size ; int ( * conn_schedule ) ( struct sk_buff * skb , struct ip_vs_app * app , int * verdict , struct ip_vs_conn * * cpp ) ; struct ip_vs_conn * ( * conn_in_get ) ( const struct sk_buff * skb , struct ip_vs_app * app , const struct iphdr * iph , unsigned int proto_off , int inverse ) ; struct ip_vs_conn * ( * conn_out_get ) ( const struct sk_buff * skb , struct ip_vs_app * app , const struct iphdr * iph , unsigned int proto_off , int inverse ) ; int ( * state_transition ) ( struct ip_vs_conn * cp , int direction , const struct sk_buff * skb , struct ip_vs_app * app ) ; void ( * timeout_change ) ( struct ip_vs_app * app , int flags ) ; } ;
enum { IP_VS_DIR_INPUT = 0 , IP_VS_DIR_OUTPUT , IP_VS_DIR_INPUT_ONLY , IP_VS_DIR_LAST , } ;
struct trans_ctl_table { int ctl_name ; const char * procname ; const struct trans_ctl_table * child ; } ;

int sysctl_check_table ( struct nsproxy * namespaces , struct ctl_table * table ) ;

void print_stack_trace ( struct stack_trace * trace , int spaces ) ;

__attribute__ ( ( weak ) ) void save_stack_trace_tsk ( struct task_struct * tsk , struct stack_trace * trace ) ;
void handle_bad_irq ( unsigned int irq , struct irq_desc * desc ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) init_kstat_irqs ( struct irq_desc * desc , int node , int nr ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_irq_init ( void ) ;
struct irq_desc * irq_to_desc ( unsigned int irq ) ;

struct irq_desc * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) irq_to_desc_alloc_node ( unsigned int irq , int node ) ;

void clear_kstat_irqs ( struct irq_desc * desc ) ;

irqreturn_t no_action ( int cpl , void * dev_id ) ;

irqreturn_t handle_IRQ_event ( unsigned int irq , struct irqaction * action ) ;

void early_init_irq_lock_class ( void ) ;

unsigned int kstat_irqs_cpu ( unsigned int irq , int cpu ) ;

void synchronize_irq ( unsigned int irq ) ;

int irq_can_set_affinity ( unsigned int irq ) ;

void irq_set_thread_affinity ( struct irq_desc * desc ) ;

int irq_set_affinity ( unsigned int irq , const struct cpumask * cpumask ) ;

int irq_select_affinity_usr ( unsigned int irq ) ;

void __disable_irq ( struct irq_desc * desc , unsigned int irq , bool suspend ) ;

void disable_irq_nosync ( unsigned int irq ) ;

void disable_irq ( unsigned int irq ) ;

void __enable_irq ( struct irq_desc * desc , unsigned int irq , bool resume ) ;

void enable_irq ( unsigned int irq ) ;

int set_irq_wake ( unsigned int irq , unsigned int on ) ;

int can_request_irq ( unsigned int irq , unsigned long irqflags ) ;

void compat_irq_chip_set_default_handler ( struct irq_desc * desc ) ;

int __irq_set_trigger ( struct irq_desc * desc , unsigned int irq , unsigned long flags ) ;

void exit_irq_thread ( void ) ;

int setup_irq ( unsigned int irq , struct irqaction * act ) ;

void remove_irq ( unsigned int irq , struct irqaction * act ) ;

void free_irq ( unsigned int irq , void * dev_id ) ;

int request_threaded_irq ( unsigned int irq , irq_handler_t handler , irq_handler_t thread_fn , unsigned long irqflags , const char * devname , void * dev_id ) ;

void note_interrupt ( unsigned int irq , struct irq_desc * desc , irqreturn_t action_ret ) ;

int noirqdebug_setup ( char * str ) ;

void check_irq_resend ( struct irq_desc * desc , unsigned int irq ) ;

void dynamic_irq_init ( unsigned int irq ) ;

void dynamic_irq_init_keep_chip_data ( unsigned int irq ) ;

void dynamic_irq_cleanup ( unsigned int irq ) ;

void dynamic_irq_cleanup_keep_chip_data ( unsigned int irq ) ;

int set_irq_chip ( unsigned int irq , struct irq_chip * chip ) ;

int set_irq_type ( unsigned int irq , unsigned int type ) ;

int set_irq_data ( unsigned int irq , void * data ) ;

int set_irq_msi ( unsigned int irq , struct msi_desc * entry ) ;

int set_irq_chip_data ( unsigned int irq , void * data ) ;

void set_irq_nested_thread ( unsigned int irq , int nest ) ;

void irq_chip_set_defaults ( struct irq_chip * chip ) ;

void handle_nested_irq ( unsigned int irq ) ;

void handle_simple_irq ( unsigned int irq , struct irq_desc * desc ) ;

void handle_level_irq ( unsigned int irq , struct irq_desc * desc ) ;

void handle_fasteoi_irq ( unsigned int irq , struct irq_desc * desc ) ;

void handle_edge_irq ( unsigned int irq , struct irq_desc * desc ) ;

void handle_percpu_irq ( unsigned int irq , struct irq_desc * desc ) ;

void __set_irq_handler ( unsigned int irq , irq_flow_handler_t handle , int is_chained , const char * name ) ;

void set_irq_chip_and_handler ( unsigned int irq , struct irq_chip * chip , irq_flow_handler_t handle ) ;

void set_irq_chip_and_handler_name ( unsigned int irq , struct irq_chip * chip , irq_flow_handler_t handle , const char * name ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) set_irq_noprobe ( unsigned int irq ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) set_irq_probe ( unsigned int irq ) ;

struct irq_devres { unsigned int irq ; void * dev_id ; } ;

int devm_request_threaded_irq ( struct device * dev , unsigned int irq , irq_handler_t handler , irq_handler_t thread_fn , unsigned long irqflags , const char * devname , void * dev_id ) ;

void devm_free_irq ( struct device * dev , unsigned int irq , void * dev_id ) ;

unsigned long probe_irq_on ( void ) ;

unsigned int probe_irq_mask ( unsigned long val ) ;

int probe_irq_off ( unsigned long val ) ;

void register_handler_proc ( unsigned int irq , struct irqaction * action ) ;

void register_irq_proc ( unsigned int irq , struct irq_desc * desc ) ;

void unregister_handler_proc ( unsigned int irq , struct irqaction * action ) ;

void init_irq_proc ( void ) ;

void move_masked_irq ( int irq ) ;

void move_native_irq ( int irq ) ;

struct irq_desc * move_irq_desc ( struct irq_desc * desc , int node ) ;

void suspend_device_irqs ( void ) ;

void resume_device_irqs ( void ) ;

int check_wakeup_irqs ( void ) ;

struct resume_swap_area { __kernel_loff_t offset ; __u32 dev ; } __attribute__ ( ( packed ) ) ;
struct swsusp_info { struct new_utsname uts ; u32 version_code ; unsigned long num_physpages ; int cpus ; unsigned long image_pages ; unsigned long pages ; unsigned long size ; } __attribute__ ( ( aligned ( ( ( 1UL ) << 12 ) ) ) ) ;
struct snapshot_handle { loff_t offset ; unsigned int cur ; unsigned int cur_offset ; unsigned int prev ; void * buffer ; unsigned int buf_offset ; int sync_read ; } ;

enum { TEST_NONE , TEST_CORE , TEST_CPUS , TEST_PLATFORM , TEST_DEVICES , TEST_FREEZER , __TEST_AFTER_LAST } ;
int register_pm_notifier ( struct notifier_block * nb ) ;

int unregister_pm_notifier ( struct notifier_block * nb ) ;

int pm_notifier_call_chain ( unsigned long val ) ;

struct vt_mode { char mode ; char waitv ; short relsig ; short acqsig ; short frsig ; } ;

struct vt_stat { unsigned short v_active ; unsigned short v_signal ; unsigned short v_state ; } ;

struct vt_sizes { unsigned short v_rows ; unsigned short v_cols ; unsigned short v_scrollsize ; } ;

struct vt_consize { unsigned short v_rows ; unsigned short v_cols ; unsigned short v_vlin ; unsigned short v_clin ; unsigned short v_vcol ; unsigned short v_ccol ; } ;

struct vt_event { unsigned int event ; unsigned int oldev ; unsigned int newev ; unsigned int pad [ 4 ] ; } ;

struct vt_setactivate { unsigned int console ; struct vt_mode mode ; } ;

struct consolefontdesc { unsigned short charcount ; unsigned short charheight ; char * chardata ; } ;

typedef char scrnmap_t ;

struct unipair { unsigned short unicode ; unsigned short fontpos ; } ;

struct unimapdesc { unsigned short entry_ct ; struct unipair * entries ; } ;

struct unimapinit { unsigned short advised_hashsize ; unsigned short advised_hashstep ; unsigned short advised_hashlevel ; } ;

struct kbentry { unsigned char kb_table ; unsigned char kb_index ; unsigned short kb_value ; } ;

struct kbsentry { unsigned char kb_func ; unsigned char kb_string [ 512 ] ; } ;

struct kbdiacr { unsigned char diacr , base , result ; } ;

struct kbdiacrs { unsigned int kb_cnt ; struct kbdiacr kbdiacr [ 256 ] ; } ;

struct kbdiacruc { unsigned int diacr , base , result ; } ;

struct kbdiacrsuc { unsigned int kb_cnt ; struct kbdiacruc kbdiacruc [ 256 ] ; } ;

struct kbkeycode { unsigned int scancode , keycode ; } ;

struct kbd_repeat { int delay ; int period ; } ;

struct console_font_op { unsigned int op ; unsigned int flags ; unsigned int width , height ; unsigned int charcount ; unsigned char * data ; } ;
struct console_font { unsigned int width , height ; unsigned int charcount ; unsigned char * data ; } ;
struct vt_struct ;

struct vc_data { unsigned short vc_num ; unsigned int vc_cols ; unsigned int vc_rows ; unsigned int vc_size_row ; unsigned int vc_scan_lines ; unsigned long vc_origin ; unsigned long vc_scr_end ; unsigned long vc_visible_origin ; unsigned int vc_top , vc_bottom ; const struct consw * vc_sw ; unsigned short * vc_screenbuf ; unsigned int vc_screenbuf_size ; unsigned char vc_mode ; unsigned char vc_attr ; unsigned char vc_def_color ; unsigned char vc_color ; unsigned char vc_s_color ; unsigned char vc_ulcolor ; unsigned char vc_itcolor ; unsigned char vc_halfcolor ; unsigned int vc_cursor_type ; unsigned short vc_complement_mask ; unsigned short vc_s_complement_mask ; unsigned int vc_x , vc_y ; unsigned int vc_saved_x , vc_saved_y ; unsigned long vc_pos ; unsigned short vc_hi_font_mask ; struct console_font vc_font ; unsigned short vc_video_erase_char ; unsigned int vc_state ; unsigned int vc_npar , vc_par [ 16 ] ; struct tty_struct * vc_tty ; struct vt_mode vt_mode ; struct pid * vt_pid ; int vt_newvt ; wait_queue_head_t paste_wait ; unsigned int vc_charset : 1 ; unsigned int vc_s_charset : 1 ; unsigned int vc_disp_ctrl : 1 ; unsigned int vc_toggle_meta : 1 ; unsigned int vc_decscnm : 1 ; unsigned int vc_decom : 1 ; unsigned int vc_decawm : 1 ; unsigned int vc_deccm : 1 ; unsigned int vc_decim : 1 ; unsigned int vc_deccolm : 1 ; unsigned int vc_intensity : 2 ; unsigned int vc_italic : 1 ; unsigned int vc_underline : 1 ; unsigned int vc_blink : 1 ; unsigned int vc_reverse : 1 ; unsigned int vc_s_intensity : 2 ; unsigned int vc_s_italic : 1 ; unsigned int vc_s_underline : 1 ; unsigned int vc_s_blink : 1 ; unsigned int vc_s_reverse : 1 ; unsigned int vc_ques : 1 ; unsigned int vc_need_wrap : 1 ; unsigned int vc_can_do_color : 1 ; unsigned int vc_report_mouse : 2 ; unsigned char vc_utf : 1 ; unsigned char vc_utf_count ; int vc_utf_char ; unsigned int vc_tab_stop [ 8 ] ; unsigned char vc_palette [ 16 * 3 ] ; unsigned short * vc_translate ; unsigned char vc_G0_charset ; unsigned char vc_G1_charset ; unsigned char vc_saved_G0 ; unsigned char vc_saved_G1 ; unsigned int vc_resize_user ; unsigned int vc_bell_pitch ; unsigned int vc_bell_duration ; struct vc_data * * vc_display_fg ; unsigned long vc_uni_pagedir ; unsigned long * vc_uni_pagedir_loc ; } ;
struct vc { struct vc_data * d ; struct work_struct SAK_work ; } ;

struct unimapinit ;
struct unipair ;
struct vt_spawn_console { spinlock_t lock ; struct pid * pid ; int sig ; } ;

struct vt_notifier_param { struct vc_data * vc ; unsigned int c ; } ;

struct keyboard_notifier_param { struct vc_data * vc ; int down ; int shift ; int ledstate ; unsigned int value ; } ;

struct kbd_struct { unsigned char lockstate ; unsigned char slockstate ; unsigned char ledmode : 2 ; unsigned char ledflagstate : 4 ; unsigned char default_ledflagstate : 4 ; unsigned char kbdmode : 2 ; unsigned char modeflags : 5 ; } ;

struct console ;
int pm_prepare_console ( void ) ;

void pm_restore_console ( void ) ;

struct zonelist ;
enum oom_constraint { CONSTRAINT_NONE , CONSTRAINT_CPUSET , CONSTRAINT_MEMORY_POLICY , } ;

int freeze_processes ( void ) ;

void thaw_processes ( void ) ;

void suspend_set_ops ( struct platform_suspend_ops * ops ) ;

bool valid_state ( suspend_state_t state ) ;

int suspend_valid_only_mem ( suspend_state_t state ) ;

void __attribute__ ( ( weak ) ) arch_suspend_disable_irqs ( void ) ;

void __attribute__ ( ( weak ) ) arch_suspend_enable_irqs ( void ) ;

int suspend_devices_and_enter ( suspend_state_t state ) ;

int enter_state ( suspend_state_t state ) ;

int pm_suspend ( suspend_state_t state ) ;

void suspend_test_start ( void ) ;

void suspend_test_finish ( const char * label ) ;

struct swsusp_extent { struct rb_node node ; unsigned long start ; unsigned long end ; } ;

sector_t alloc_swapdev_block ( int swap ) ;

void free_all_swap_pages ( int swap ) ;

int swsusp_swap_in_use ( void ) ;

void swsusp_show_speed ( struct timeval * start , struct timeval * stop , unsigned nr_pages , char * msg ) ;

enum { HIBERNATION_INVALID , HIBERNATION_PLATFORM , HIBERNATION_TEST , HIBERNATION_TESTPROC , HIBERNATION_SHUTDOWN , HIBERNATION_REBOOT , __HIBERNATION_AFTER_LAST } ;
void hibernation_set_ops ( struct platform_hibernation_ops * ops ) ;

bool system_entering_hibernation ( void ) ;

int hibernation_snapshot ( int platform_mode ) ;

int hibernation_restore ( int platform_mode ) ;

int hibernation_platform_enter ( void ) ;

int hibernate ( void ) ;

unsigned long get_safe_page ( gfp_t gfp_mask ) ;

struct linked_page { struct linked_page * next ; char data [ ( ( ( 1UL ) << 12 ) - sizeof ( void * ) ) ] ; } __attribute__ ( ( packed ) ) ;
struct chain_allocator { struct linked_page * chain ; unsigned int used_space ; gfp_t gfp_mask ; int safe_needed ; } ;

struct bm_block { struct list_head hook ; unsigned long start_pfn ; unsigned long end_pfn ; unsigned long * data ; } ;

struct bm_position { struct bm_block * block ; int bit ; } ;

struct memory_bitmap { struct list_head blocks ; struct linked_page * p_list ; struct bm_position cur ; } ;

struct mem_extent { struct list_head hook ; unsigned long start ; unsigned long end ; } ;

struct nosave_region { struct list_head list ; unsigned long start_pfn ; unsigned long end_pfn ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __register_nosave_region ( unsigned long start_pfn , unsigned long end_pfn , int use_kmalloc ) ;

void swsusp_set_page_free ( struct page * page ) ;

void swsusp_unset_page_free ( struct page * page ) ;

int swsusp_page_is_forbidden ( struct page * page ) ;

int create_basic_memory_bitmaps ( void ) ;

void free_basic_memory_bitmaps ( void ) ;

unsigned int snapshot_additional_pages ( struct zone * zone ) ;

void swsusp_free ( void ) ;

int hibernate_preallocate_memory ( void ) ;

int swsusp_save ( void ) ;

unsigned long snapshot_get_image_size ( void ) ;

int snapshot_read_next ( struct snapshot_handle * handle , size_t count ) ;

int snapshot_write_next ( struct snapshot_handle * handle , size_t count ) ;

void snapshot_write_finalize ( struct snapshot_handle * handle ) ;

int snapshot_image_loaded ( struct snapshot_handle * handle ) ;

struct swsusp_header { char reserved [ ( ( 1UL ) << 12 ) - 20 - sizeof ( sector_t ) - sizeof ( int ) ] ; sector_t image ; unsigned int flags ; char orig_sig [ 10 ] ; char sig [ 10 ] ; } __attribute__ ( ( packed ) ) ;
struct swap_map_page { sector_t entries [ ( ( ( 1UL ) << 12 ) / sizeof ( sector_t ) - 1 ) ] ; sector_t next_swap ; } ;

struct swap_map_handle { struct swap_map_page * cur ; sector_t cur_swap ; unsigned int k ; } ;

int swsusp_write ( unsigned int flags ) ;

int swsusp_read ( unsigned int * flags_p ) ;

int swsusp_check ( void ) ;

void swsusp_close ( fmode_t mode ) ;


struct nvs_page { unsigned long phys_start ; unsigned int size ; void * kaddr ; void * data ; struct list_head node ; } ;

int hibernate_nvs_register ( unsigned long start , unsigned long size ) ;

void hibernate_nvs_free ( void ) ;

int hibernate_nvs_alloc ( void ) ;

void hibernate_nvs_save ( void ) ;

void hibernate_nvs_restore ( void ) ;

struct timekeeper { struct clocksource * clock ; int shift ; cycle_t cycle_interval ; u64 xtime_interval ; u32 raw_interval ; u64 xtime_nsec ; s64 ntp_error ; int ntp_error_shift ; u32 mult ; } ;

void update_xtime_cache ( u64 nsec ) ;

void timekeeping_leap_insert ( int leapsecond ) ;

void getnstimeofday ( struct timespec * ts ) ;

ktime_t ktime_get ( void ) ;

void ktime_get_ts ( struct timespec * ts ) ;

void do_gettimeofday ( struct timeval * tv ) ;

int do_settimeofday ( struct timespec * tv ) ;

void timekeeping_notify ( struct clocksource * clock ) ;

ktime_t ktime_get_real ( void ) ;

void getrawmonotonic ( struct timespec * ts ) ;

int timekeeping_valid_for_hres ( void ) ;

u64 timekeeping_max_deferment ( void ) ;

void __attribute__ ( ( weak ) ) read_persistent_clock ( struct timespec * ts ) ;
void __attribute__ ( ( weak ) ) read_boot_clock ( struct timespec * ts ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) timekeeping_init ( void ) ;

void update_wall_time ( void ) ;

void getboottime ( struct timespec * ts ) ;

void monotonic_to_bootbased ( struct timespec * ts ) ;

unsigned long get_seconds ( void ) ;

struct timespec __current_kernel_time ( void ) ;

struct timespec current_kernel_time ( void ) ;

struct timespec get_monotonic_coarse ( void ) ;

void ntp_clear ( void ) ;

void second_overflow ( void ) ;

int do_adjtimex ( struct timex * txc ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ntp_init ( void ) ;

void timecounter_init ( struct timecounter * tc , const struct cyclecounter * cc , u64 start_tstamp ) ;

u64 timecounter_read ( struct timecounter * tc ) ;

u64 timecounter_cyc2time ( struct timecounter * tc , cycle_t cycle_tstamp ) ;

void clocksource_mark_unstable ( struct clocksource * cs ) ;

void clocksource_resume ( void ) ;

void clocksource_touch_watchdog ( void ) ;

int clocksource_register ( struct clocksource * cs ) ;

void clocksource_change_rating ( struct clocksource * cs , int rating ) ;

void clocksource_unregister ( struct clocksource * cs ) ;

struct clocksource * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( weak ) ) clocksource_default_clock ( void ) ;

typedef void ( * print_fn_t ) ( struct seq_file * m , unsigned int * classes ) ;
void sysrq_timer_list_show ( void ) ;

struct timecompare { struct timecounter * source ; ktime_t ( * target ) ( void ) ; int num_samples ; s64 offset ; s64 skew ; u64 last_update ; } ;

ktime_t timecompare_transform ( struct timecompare * sync , u64 source_tstamp ) ;

int timecompare_offset ( struct timecompare * sync , s64 * offset , u64 * source_tstamp ) ;

void __timecompare_update ( struct timecompare * sync , u64 source_tstamp ) ;

void time_to_tm ( time_t totalsecs , int offset , struct tm * result ) ;

unsigned long clockevent_delta2ns ( unsigned long latch , struct clock_event_device * evt ) ;

void clockevents_set_mode ( struct clock_event_device * dev , enum clock_event_mode mode ) ;

void clockevents_shutdown ( struct clock_event_device * dev ) ;

int clockevents_program_event ( struct clock_event_device * dev , ktime_t expires , ktime_t now ) ;

int clockevents_register_notifier ( struct notifier_block * nb ) ;

void clockevents_register_device ( struct clock_event_device * dev ) ;

void clockevents_handle_noop ( struct clock_event_device * dev ) ;

void clockevents_exchange_device ( struct clock_event_device * old , struct clock_event_device * new ) ;

void clockevents_notify ( unsigned long reason , void * arg ) ;

struct tick_device * tick_get_device ( int cpu ) ;

int tick_is_oneshot_available ( void ) ;

void tick_handle_periodic ( struct clock_event_device * dev ) ;

void tick_setup_periodic ( struct clock_event_device * dev , int broadcast ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) tick_init ( void ) ;

struct tick_device * tick_get_broadcast_device ( void ) ;

struct cpumask * tick_get_broadcast_mask ( void ) ;

int tick_check_broadcast_device ( struct clock_event_device * dev ) ;

int tick_is_broadcast_device ( struct clock_event_device * dev ) ;

int tick_device_uses_broadcast ( struct clock_event_device * dev , int cpu ) ;

void tick_broadcast_on_off ( unsigned long reason , int * oncpu ) ;

void tick_set_periodic_handler ( struct clock_event_device * dev , int broadcast ) ;

void tick_shutdown_broadcast ( unsigned int * cpup ) ;

void tick_suspend_broadcast ( void ) ;

int tick_resume_broadcast ( void ) ;

struct cpumask * tick_get_broadcast_oneshot_mask ( void ) ;

int tick_resume_broadcast_oneshot ( struct clock_event_device * bc ) ;

void tick_check_oneshot_broadcast ( int cpu ) ;

void tick_broadcast_oneshot_control ( unsigned long reason ) ;

void tick_broadcast_setup_oneshot ( struct clock_event_device * bc ) ;

void tick_broadcast_switch_to_oneshot ( void ) ;

void tick_shutdown_broadcast_oneshot ( unsigned int * cpup ) ;

int tick_broadcast_oneshot_active ( void ) ;

int tick_dev_program_event ( struct clock_event_device * dev , ktime_t expires , int force ) ;

int tick_program_event ( ktime_t expires , int force ) ;

void tick_resume_oneshot ( void ) ;

void tick_setup_oneshot ( struct clock_event_device * newdev , void ( * handler ) ( struct clock_event_device * ) , ktime_t next_event ) ;

int tick_switch_to_oneshot ( void ( * handler ) ( struct clock_event_device * ) ) ;

int tick_oneshot_mode_active ( void ) ;

int tick_init_highres ( void ) ;

struct tick_sched * tick_get_tick_sched ( int cpu ) ;

u64 get_cpu_idle_time_us ( int cpu , u64 * last_update_time ) ;

void tick_nohz_stop_sched_tick ( int inidle ) ;

ktime_t tick_nohz_get_sleep_length ( void ) ;

void tick_nohz_restart_sched_tick ( void ) ;

void tick_check_idle ( int cpu ) ;

void tick_setup_sched_timer ( void ) ;

void tick_cancel_sched_timer ( int cpu ) ;

void tick_clock_notify ( void ) ;

void tick_oneshot_notify ( void ) ;

int tick_check_oneshot_change ( int allow_nohz ) ;

struct entry { struct entry * next ; void * timer ; void * start_func ; void * expire_func ; pid_t pid ; unsigned long count ; unsigned int timer_flag ; char comm [ 16 + 1 ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
void timer_stats_update_stats ( void * timer , pid_t pid , void * startf , void * timerf , char * comm , unsigned int timer_flag ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_timer_stats ( void ) ;

enum trace_type { __TRACE_FIRST_TYPE = 0 , TRACE_FN , TRACE_CTX , TRACE_WAKE , TRACE_STACK , TRACE_PRINT , TRACE_BPRINT , TRACE_SPECIAL , TRACE_MMIO_RW , TRACE_MMIO_MAP , TRACE_BRANCH , TRACE_BOOT_CALL , TRACE_BOOT_RET , TRACE_GRAPH_RET , TRACE_GRAPH_ENT , TRACE_USER_STACK , TRACE_HW_BRANCHES , TRACE_KMEM_ALLOC , TRACE_KMEM_FREE , TRACE_BLK , __TRACE_LAST_TYPE , } ;

enum kmemtrace_type_id { KMEMTRACE_TYPE_KMALLOC = 0 , KMEMTRACE_TYPE_CACHE , KMEMTRACE_TYPE_PAGES , } ;

struct ftrace_entry { struct trace_entry ent ; unsigned long ip ; unsigned long parent_ip ; } ;

struct ftrace_graph_ent_entry { struct trace_entry ent ; struct ftrace_graph_ent graph_ent ; } ;

struct ftrace_graph_ret_entry { struct trace_entry ent ; struct ftrace_graph_ret ret ; } ;

struct ctx_switch_entry { struct trace_entry ent ; unsigned int prev_pid ; unsigned char prev_prio ; unsigned char prev_state ; unsigned int next_pid ; unsigned char next_prio ; unsigned char next_state ; unsigned int next_cpu ; } ;

struct special_entry { struct trace_entry ent ; unsigned long arg1 ; unsigned long arg2 ; unsigned long arg3 ; } ;

struct stack_entry { struct trace_entry ent ; unsigned long caller [ 8 ] ; } ;

struct userstack_entry { struct trace_entry ent ; unsigned int tgid ; unsigned long caller [ 8 ] ; } ;

struct bprint_entry { struct trace_entry ent ; unsigned long ip ; const char * fmt ; u32 buf [ ] ; } ;

struct print_entry { struct trace_entry ent ; unsigned long ip ; char buf [ ] ; } ;

struct trace_mmiotrace_rw { struct trace_entry ent ; struct mmiotrace_rw rw ; } ;

struct trace_mmiotrace_map { struct trace_entry ent ; struct mmiotrace_map map ; } ;

struct trace_boot_call { struct trace_entry ent ; struct boot_trace_call boot_call ; } ;

struct trace_boot_ret { struct trace_entry ent ; struct boot_trace_ret boot_ret ; } ;

struct trace_branch { struct trace_entry ent ; unsigned int line ; char func [ 30 + 1 ] ; char file [ 20 + 1 ] ; char correct ; } ;

struct hw_branch_entry { struct trace_entry ent ; u64 from ; u64 to ; } ;

struct kmemtrace_alloc_entry { struct trace_entry ent ; enum kmemtrace_type_id type_id ; unsigned long call_site ; const void * ptr ; size_t bytes_req ; size_t bytes_alloc ; gfp_t gfp_flags ; int node ; } ;

struct kmemtrace_free_entry { struct trace_entry ent ; enum kmemtrace_type_id type_id ; unsigned long call_site ; const void * ptr ; } ;

struct syscall_trace_enter { struct trace_entry ent ; int nr ; unsigned long args [ ] ; } ;
struct syscall_trace_exit { struct trace_entry ent ; int nr ; unsigned long ret ; } ;

enum trace_flag_type { TRACE_FLAG_IRQS_OFF = 0x01 , TRACE_FLAG_IRQS_NOSUPPORT = 0x02 , TRACE_FLAG_NEED_RESCHED = 0x04 , TRACE_FLAG_HARDIRQ = 0x08 , TRACE_FLAG_SOFTIRQ = 0x10 , } ;

struct trace_array_cpu { atomic_t disabled ; void * buffer_page ; unsigned long saved_latency ; unsigned long critical_start ; unsigned long critical_end ; unsigned long critical_sequence ; unsigned long nice ; unsigned long policy ; unsigned long rt_priority ; unsigned long skipped_entries ; cycle_t preempt_timestamp ; pid_t pid ; uid_t uid ; char comm [ 16 ] ; } ;

struct trace_array { struct ring_buffer * buffer ; unsigned long entries ; int cpu ; cycle_t time_start ; struct task_struct * waiter ; struct trace_array_cpu * data [ 64 ] ; } ;
struct tracer_opt { const char * name ; u32 bit ; } ;

struct tracer_flags { u32 val ; struct tracer_opt * opts ; } ;

struct tracer { const char * name ; int ( * init ) ( struct trace_array * tr ) ; void ( * reset ) ( struct trace_array * tr ) ; void ( * start ) ( struct trace_array * tr ) ; void ( * stop ) ( struct trace_array * tr ) ; void ( * open ) ( struct trace_iterator * iter ) ; void ( * pipe_open ) ( struct trace_iterator * iter ) ; void ( * wait_pipe ) ( struct trace_iterator * iter ) ; void ( * close ) ( struct trace_iterator * iter ) ; ssize_t ( * read ) ( struct trace_iterator * iter , struct file * filp , char * ubuf , size_t cnt , loff_t * ppos ) ; ssize_t ( * splice_read ) ( struct trace_iterator * iter , struct file * filp , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) ; void ( * print_header ) ( struct seq_file * m ) ; enum print_line_t ( * print_line ) ( struct trace_iterator * iter ) ; int ( * set_flag ) ( u32 old_flags , u32 bit , int set ) ; struct tracer * next ; int print_max ; struct tracer_flags * flags ; } ;
struct ring_buffer_event ;
struct trace_parser { bool cont ; char * buffer ; unsigned idx ; unsigned size ; } ;

enum trace_iterator_flags { TRACE_ITER_PRINT_PARENT = 0x01 , TRACE_ITER_SYM_OFFSET = 0x02 , TRACE_ITER_SYM_ADDR = 0x04 , TRACE_ITER_VERBOSE = 0x08 , TRACE_ITER_RAW = 0x10 , TRACE_ITER_HEX = 0x20 , TRACE_ITER_BIN = 0x40 , TRACE_ITER_BLOCK = 0x80 , TRACE_ITER_STACKTRACE = 0x100 , TRACE_ITER_SCHED_TREE = 0x200 , TRACE_ITER_PRINTK = 0x400 , TRACE_ITER_PREEMPTONLY = 0x800 , TRACE_ITER_BRANCH = 0x1000 , TRACE_ITER_ANNOTATE = 0x2000 , TRACE_ITER_USERSTACKTRACE = 0x4000 , TRACE_ITER_SYM_USEROBJ = 0x8000 , TRACE_ITER_PRINTK_MSGONLY = 0x10000 , TRACE_ITER_CONTEXT_INFO = 0x20000 , TRACE_ITER_LATENCY_FMT = 0x40000 , TRACE_ITER_SLEEP_TIME = 0x80000 , TRACE_ITER_GRAPH_TIME = 0x100000 , } ;

enum { TRACE_EVENT_TYPE_PRINTF = 1 , TRACE_EVENT_TYPE_RAW = 2 , } ;
struct ftrace_event_field { struct list_head link ; char * name ; char * type ; int filter_type ; int offset ; int size ; int is_signed ; } ;

struct event_filter { int n_preds ; struct filter_pred * * preds ; char * filter_string ; bool no_reset ; } ;
struct event_subsystem { struct list_head list ; const char * name ; struct dentry * entry ; struct event_filter * filter ; int nr_events ; } ;

struct filter_pred ;

typedef int ( * filter_pred_fn_t ) ( struct filter_pred * pred , void * event , int val1 , int val2 ) ;
struct filter_pred { filter_pred_fn_t fn ; u64 val ; char str_val [ 256 ] ; int str_len ; char * field_name ; int offset ; int not ; int op ; int pop_n ; } ;
int trace_selftest_dynamic_test_func ( void ) ;

u64 __attribute__ ( ( no_instrument_function ) ) trace_clock_local ( void ) ;

u64 __attribute__ ( ( no_instrument_function ) ) trace_clock ( void ) ;

u64 __attribute__ ( ( no_instrument_function ) ) trace_clock_global ( void ) ;

struct tracer_stat { const char * name ; void * ( * stat_start ) ( struct tracer_stat * trace ) ; void * ( * stat_next ) ( void * prev , int idx ) ; int ( * stat_cmp ) ( void * p1 , void * p2 ) ; int ( * stat_show ) ( struct seq_file * s , void * p ) ; void ( * stat_release ) ( void * stat ) ; int ( * stat_headers ) ( struct seq_file * s ) ; } ;

void clear_ftrace_function ( void ) ;

struct ftrace_profile { struct hlist_node node ; unsigned long ip ; unsigned long counter ; unsigned long long time ; } ;

struct ftrace_profile_page { struct ftrace_profile_page * next ; unsigned long index ; struct ftrace_profile records [ ] ; } ;

struct ftrace_profile_stat { atomic_t disabled ; struct hlist_head * hash ; struct ftrace_profile_page * pages ; struct ftrace_profile_page * start ; struct tracer_stat stat ; } ;

int ftrace_profile_pages_init ( struct ftrace_profile_stat * stat ) ;

struct ftrace_func_probe { struct hlist_node node ; struct ftrace_probe_ops * ops ; unsigned long flags ; unsigned long ip ; void * data ; struct rcu_head rcu ; } ;

enum { FTRACE_ENABLE_CALLS = ( 1 << 0 ) , FTRACE_DISABLE_CALLS = ( 1 << 1 ) , FTRACE_UPDATE_TRACE_FUNC = ( 1 << 2 ) , FTRACE_ENABLE_MCOUNT = ( 1 << 3 ) , FTRACE_DISABLE_MCOUNT = ( 1 << 4 ) , FTRACE_START_FUNC_RET = ( 1 << 5 ) , FTRACE_STOP_FUNC_RET = ( 1 << 6 ) , } ;
struct ftrace_page { struct ftrace_page * next ; int index ; struct dyn_ftrace records [ ] ; } ;

int __attribute__ ( ( weak ) ) ftrace_arch_code_modify_prepare ( void ) ;
int __attribute__ ( ( weak ) ) ftrace_arch_code_modify_post_process ( void ) ;
enum { FTRACE_ITER_FILTER = ( 1 << 0 ) , FTRACE_ITER_NOTRACE = ( 1 << 1 ) , FTRACE_ITER_FAILURES = ( 1 << 2 ) , FTRACE_ITER_PRINTALL = ( 1 << 3 ) , FTRACE_ITER_HASH = ( 1 << 4 ) , } ;
struct ftrace_iterator { struct ftrace_page * pg ; int hidx ; int idx ; unsigned flags ; struct trace_parser parser ; } ;

enum { MATCH_FULL , MATCH_FRONT_ONLY , MATCH_MIDDLE_ONLY , MATCH_END_ONLY , } ;
int register_ftrace_function_probe ( char * glob , struct ftrace_probe_ops * ops , void * data ) ;

enum { PROBE_TEST_FUNC = 1 , PROBE_TEST_DATA = 2 } ;
void unregister_ftrace_function_probe ( char * glob , struct ftrace_probe_ops * ops , void * data ) ;

void unregister_ftrace_function_probe_func ( char * glob , struct ftrace_probe_ops * ops ) ;

void unregister_ftrace_function_probe_all ( char * glob ) ;

int register_ftrace_command ( struct ftrace_func_command * cmd ) ;

int unregister_ftrace_command ( struct ftrace_func_command * cmd ) ;

void ftrace_set_filter ( unsigned char * buf , int len , int reset ) ;

void ftrace_set_notrace ( unsigned char * buf , int len , int reset ) ;

void ftrace_release_mod ( struct module * mod ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ftrace_init ( void ) ;

void ftrace_kill ( void ) ;

int register_ftrace_function ( struct ftrace_ops * ops ) ;

int unregister_ftrace_function ( struct ftrace_ops * ops ) ;

int ftrace_enable_sysctl ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int ftrace_graph_entry_stub ( struct ftrace_graph_ent * trace ) ;

int register_ftrace_graph ( trace_func_graph_ret_t retfunc , trace_func_graph_ent_t entryfunc ) ;

void unregister_ftrace_graph ( void ) ;

void ftrace_graph_init_task ( struct task_struct * t ) ;

void ftrace_graph_exit_task ( struct task_struct * t ) ;

void ftrace_graph_stop ( void ) ;

int ring_buffer_print_entry_header ( struct trace_seq * s ) ;

enum { RB_BUFFERS_ON_BIT = 0 , RB_BUFFERS_DISABLED_BIT = 1 , } ;
enum { RB_BUFFERS_ON = 1 << RB_BUFFERS_ON_BIT , RB_BUFFERS_DISABLED = 1 << RB_BUFFERS_DISABLED_BIT , } ;
void tracing_on ( void ) ;

void tracing_off ( void ) ;

void tracing_off_permanent ( void ) ;

int tracing_is_on ( void ) ;

enum { RB_LEN_TIME_EXTEND = 8 , RB_LEN_TIME_STAMP = 16 , } ;
unsigned ring_buffer_event_length ( struct ring_buffer_event * event ) ;

void * ring_buffer_event_data ( struct ring_buffer_event * event ) ;

struct buffer_data_page { u64 time_stamp ; local_t commit ; unsigned char data [ ] ; } ;

struct buffer_page { struct list_head list ; local_t write ; unsigned read ; local_t entries ; struct buffer_data_page * page ; } ;

size_t ring_buffer_page_len ( void * page ) ;

int ring_buffer_print_page_header ( struct trace_seq * s ) ;

struct ring_buffer_per_cpu { int cpu ; struct ring_buffer * buffer ; spinlock_t reader_lock ; raw_spinlock_t lock ; struct lock_class_key lock_key ; struct list_head * pages ; struct buffer_page * head_page ; struct buffer_page * tail_page ; struct buffer_page * commit_page ; struct buffer_page * reader_page ; local_t commit_overrun ; local_t overrun ; local_t entries ; local_t committing ; local_t commits ; unsigned long read ; u64 write_stamp ; u64 read_stamp ; atomic_t record_disabled ; } ;

struct ring_buffer { unsigned pages ; unsigned flags ; int cpus ; atomic_t record_disabled ; cpumask_var_t cpumask ; struct lock_class_key * reader_lock_key ; struct mutex mutex ; struct ring_buffer_per_cpu * * buffers ; struct notifier_block cpu_notify ; u64 ( * clock ) ( void ) ; } ;
struct ring_buffer_iter { struct ring_buffer_per_cpu * cpu_buffer ; unsigned long head ; struct buffer_page * head_page ; u64 read_stamp ; } ;
u64 ring_buffer_time_stamp ( struct ring_buffer * buffer , int cpu ) ;

void ring_buffer_normalize_time_stamp ( struct ring_buffer * buffer , int cpu , u64 * ts ) ;

struct ring_buffer * __ring_buffer_alloc ( unsigned long size , unsigned flags , struct lock_class_key * key ) ;

void ring_buffer_free ( struct ring_buffer * buffer ) ;

void ring_buffer_set_clock ( struct ring_buffer * buffer , u64 ( * clock ) ( void ) ) ;

int ring_buffer_resize ( struct ring_buffer * buffer , unsigned long size ) ;

struct ring_buffer_event * ring_buffer_lock_reserve ( struct ring_buffer * buffer , unsigned long length ) ;

int ring_buffer_unlock_commit ( struct ring_buffer * buffer , struct ring_buffer_event * event ) ;

void ring_buffer_discard_commit ( struct ring_buffer * buffer , struct ring_buffer_event * event ) ;

int ring_buffer_write ( struct ring_buffer * buffer , unsigned long length , void * data ) ;

void ring_buffer_record_disable ( struct ring_buffer * buffer ) ;

void ring_buffer_record_enable ( struct ring_buffer * buffer ) ;

void ring_buffer_record_disable_cpu ( struct ring_buffer * buffer , int cpu ) ;

void ring_buffer_record_enable_cpu ( struct ring_buffer * buffer , int cpu ) ;

unsigned long ring_buffer_entries_cpu ( struct ring_buffer * buffer , int cpu ) ;

unsigned long ring_buffer_overrun_cpu ( struct ring_buffer * buffer , int cpu ) ;

unsigned long ring_buffer_commit_overrun_cpu ( struct ring_buffer * buffer , int cpu ) ;

unsigned long ring_buffer_entries ( struct ring_buffer * buffer ) ;

unsigned long ring_buffer_overruns ( struct ring_buffer * buffer ) ;

void ring_buffer_iter_reset ( struct ring_buffer_iter * iter ) ;

int ring_buffer_iter_empty ( struct ring_buffer_iter * iter ) ;

struct ring_buffer_event * ring_buffer_peek ( struct ring_buffer * buffer , int cpu , u64 * ts ) ;

struct ring_buffer_event * ring_buffer_iter_peek ( struct ring_buffer_iter * iter , u64 * ts ) ;

struct ring_buffer_event * ring_buffer_consume ( struct ring_buffer * buffer , int cpu , u64 * ts ) ;

struct ring_buffer_iter * ring_buffer_read_start ( struct ring_buffer * buffer , int cpu ) ;

void ring_buffer_read_finish ( struct ring_buffer_iter * iter ) ;

struct ring_buffer_event * ring_buffer_read ( struct ring_buffer_iter * iter , u64 * ts ) ;

unsigned long ring_buffer_size ( struct ring_buffer * buffer ) ;

void ring_buffer_reset_cpu ( struct ring_buffer * buffer , int cpu ) ;

void ring_buffer_reset ( struct ring_buffer * buffer ) ;

int ring_buffer_empty ( struct ring_buffer * buffer ) ;

int ring_buffer_empty_cpu ( struct ring_buffer * buffer , int cpu ) ;

void * ring_buffer_alloc_read_page ( struct ring_buffer * buffer ) ;

void ring_buffer_free_read_page ( struct ring_buffer * buffer , void * data ) ;

int ring_buffer_read_page ( struct ring_buffer * buffer , void * * data_page , size_t len , int cpu , int full ) ;

struct splice_desc { unsigned int len , total_len ; unsigned int flags ; union { void * userptr ; struct file * file ; void * data ; } u ; loff_t pos ; size_t num_spliced ; bool need_wakeup ; } ;

struct partial_page { unsigned int offset ; unsigned int len ; unsigned long private ; } ;

struct splice_pipe_desc { struct page * * pages ; struct partial_page * partial ; int nr_pages ; unsigned int flags ; const struct pipe_buf_operations * ops ; void ( * spd_release ) ( struct splice_pipe_desc * , unsigned int ) ; } ;

typedef int ( splice_actor ) ( struct pipe_inode_info * , struct pipe_buffer * , struct splice_desc * ) ;
typedef int ( splice_direct_actor ) ( struct pipe_inode_info * , struct splice_desc * ) ;
unsigned long long ns2usecs ( cycle_t nsec ) ;

int filter_current_check_discard ( struct ring_buffer * buffer , struct ftrace_event_call * call , void * rec , struct ring_buffer_event * event ) ;

cycle_t ftrace_now ( int cpu ) ;

int tracing_is_enabled ( void ) ;

void trace_wake_up ( void ) ;

unsigned long nsecs_to_usecs ( unsigned long nsecs ) ;

int trace_parser_get_init ( struct trace_parser * parser , int size ) ;

void trace_parser_put ( struct trace_parser * parser ) ;

int trace_get_user ( struct trace_parser * parser , const char * ubuf , size_t cnt , loff_t * ppos ) ;

ssize_t trace_seq_to_user ( struct trace_seq * s , char * ubuf , size_t cnt ) ;

int register_tracer ( struct tracer * type ) ;

void unregister_tracer ( struct tracer * type ) ;

void tracing_reset ( struct trace_array * tr , int cpu ) ;

void tracing_reset_online_cpus ( struct trace_array * tr ) ;

void tracing_reset_current ( int cpu ) ;

void tracing_reset_current_online_cpus ( void ) ;

int is_tracing_stopped ( void ) ;

void ftrace_off_permanent ( void ) ;

void tracing_start ( void ) ;

void tracing_stop ( void ) ;

void trace_find_cmdline ( int pid , char comm [ ] ) ;

void tracing_record_cmdline ( struct task_struct * tsk ) ;

void tracing_generic_entry_update ( struct trace_entry * entry , unsigned long flags , int pc ) ;

struct ring_buffer_event * trace_buffer_lock_reserve ( struct ring_buffer * buffer , int type , unsigned long len , unsigned long flags , int pc ) ;

void trace_buffer_unlock_commit ( struct ring_buffer * buffer , struct ring_buffer_event * event , unsigned long flags , int pc ) ;

struct ring_buffer_event * trace_current_buffer_lock_reserve ( struct ring_buffer * * current_rb , int type , unsigned long len , unsigned long flags , int pc ) ;

void trace_current_buffer_unlock_commit ( struct ring_buffer * buffer , struct ring_buffer_event * event , unsigned long flags , int pc ) ;

void trace_nowake_buffer_unlock_commit ( struct ring_buffer * buffer , struct ring_buffer_event * event , unsigned long flags , int pc ) ;

void trace_current_buffer_discard_commit ( struct ring_buffer * buffer , struct ring_buffer_event * event ) ;

void trace_function ( struct trace_array * tr , unsigned long ip , unsigned long parent_ip , unsigned long flags , int pc ) ;

void ftrace ( struct trace_array * tr , struct trace_array_cpu * data , unsigned long ip , unsigned long parent_ip , unsigned long flags , int pc ) ;

void ftrace_trace_stack ( struct ring_buffer * buffer , unsigned long flags , int skip , int pc ) ;

void __trace_stack ( struct trace_array * tr , unsigned long flags , int skip , int pc ) ;

void ftrace_trace_userstack ( struct ring_buffer * buffer , unsigned long flags , int pc ) ;

void __trace_special ( void * __tr , void * __data , unsigned long arg1 , unsigned long arg2 , unsigned long arg3 ) ;

void ftrace_special ( unsigned long arg1 , unsigned long arg2 , unsigned long arg3 ) ;

int trace_vbprintk ( unsigned long ip , const char * fmt , va_list args ) ;

int trace_array_printk ( struct trace_array * tr , unsigned long ip , const char * fmt , ... ) ;

int trace_array_vprintk ( struct trace_array * tr , unsigned long ip , const char * fmt , va_list args ) ;

int trace_vprintk ( unsigned long ip , const char * fmt , va_list args ) ;

enum trace_file_type { TRACE_FILE_LAT_FMT = 1 , TRACE_FILE_ANNOTATE = 2 , } ;

struct trace_entry * trace_find_next_entry ( struct trace_iterator * iter , int * ent_cpu , u64 * ent_ts ) ;

int tracing_open_generic ( struct inode * inode , struct file * filp ) ;

int tracer_init ( struct tracer * t , struct trace_array * tr ) ;

int tracing_update_buffers ( void ) ;

struct trace_option_dentry ;

void default_wait_pipe ( struct trace_iterator * iter ) ;

void poll_wait_pipe ( struct trace_iterator * iter ) ;

struct ftrace_buffer_info { struct trace_array * tr ; void * spare ; int cpu ; unsigned int read ; } ;

struct buffer_ref { struct ring_buffer * buffer ; void * page ; int ref ; } ;

int __attribute__ ( ( weak ) ) ftrace_arch_read_dyn_info ( char * buf , int size ) ;
struct dentry * tracing_init_dentry ( void ) ;

struct dentry * tracing_dentry_percpu ( void ) ;

struct trace_option_dentry { struct tracer_opt * opt ; struct tracer_flags * flags ; struct dentry * entry ; } ;
struct dentry * trace_create_file ( const char * name , mode_t mode , struct dentry * parent , void * data , const struct file_operations * fops ) ;

void ftrace_dump ( void ) ;

void trace_print_seq ( struct seq_file * m , struct trace_seq * s ) ;

enum print_line_t trace_print_bprintk_msg_only ( struct trace_iterator * iter ) ;

enum print_line_t trace_print_printk_msg_only ( struct trace_iterator * iter ) ;

int trace_seq_printf ( struct trace_seq * s , const char * fmt , ... ) ;

int trace_seq_vprintf ( struct trace_seq * s , const char * fmt , va_list args ) ;

int trace_seq_bprintf ( struct trace_seq * s , const char * fmt , const u32 * binary ) ;

int trace_seq_puts ( struct trace_seq * s , const char * str ) ;

int trace_seq_putc ( struct trace_seq * s , unsigned char c ) ;

int trace_seq_putmem ( struct trace_seq * s , const void * mem , size_t len ) ;

int trace_seq_putmem_hex ( struct trace_seq * s , const void * mem , size_t len ) ;

void * trace_seq_reserve ( struct trace_seq * s , size_t len ) ;

int trace_seq_path ( struct trace_seq * s , struct path * path ) ;

const char * ftrace_print_flags_seq ( struct trace_seq * p , const char * delim , unsigned long flags , const struct trace_print_flags * flag_array ) ;

const char * ftrace_print_symbols_seq ( struct trace_seq * p , unsigned long val , const struct trace_print_flags * symbol_array ) ;

int seq_print_user_ip ( struct trace_seq * s , struct mm_struct * mm , unsigned long ip , unsigned long sym_flags ) ;

int seq_print_userip_objs ( const struct userstack_entry * entry , struct trace_seq * s , unsigned long sym_flags ) ;

int seq_print_ip_sym ( struct trace_seq * s , unsigned long ip , unsigned long sym_flags ) ;

int trace_print_lat_fmt ( struct trace_seq * s , struct trace_entry * entry ) ;

int trace_print_context ( struct trace_iterator * iter ) ;

int trace_print_lat_context ( struct trace_iterator * iter ) ;

struct trace_event * ftrace_find_event ( int type ) ;

void trace_event_read_lock ( void ) ;

void trace_event_read_unlock ( void ) ;

int register_ftrace_event ( struct trace_event * event ) ;

int __unregister_ftrace_event ( struct trace_event * event ) ;

int unregister_ftrace_event ( struct trace_event * event ) ;

enum print_line_t trace_nop_print ( struct trace_iterator * iter , int flags ) ;

struct stat_node { struct rb_node node ; void * stat ; } ;

struct stat_session { struct list_head session_list ; struct tracer_stat * ts ; struct rb_root stat_root ; struct mutex stat_mutex ; struct dentry * file ; } ;

typedef int ( * cmp_stat_t ) ( void * , void * ) ;
int register_stat_tracer ( struct tracer_stat * trace ) ;

void unregister_stat_tracer ( struct tracer_stat * trace ) ;

struct trace_bprintk_fmt { struct list_head list ; char fmt [ 0 ] ; } ;

int __trace_bprintk ( unsigned long ip , const char * fmt , ... ) ;

int __ftrace_vbprintk ( unsigned long ip , const char * fmt , va_list ap ) ;

int __trace_printk ( unsigned long ip , const char * fmt , ... ) ;

int __ftrace_vprintk ( unsigned long ip , const char * fmt , va_list ap ) ;

void tracing_sched_switch_trace ( struct trace_array * tr , struct task_struct * prev , struct task_struct * next , unsigned long flags , int pc ) ;

void tracing_sched_wakeup_trace ( struct trace_array * tr , struct task_struct * wakee , struct task_struct * curr , unsigned long flags , int pc ) ;

void tracing_start_cmdline_record ( void ) ;

void tracing_stop_cmdline_record ( void ) ;

void tracing_start_sched_switch_record ( void ) ;

void tracing_stop_sched_switch_record ( void ) ;

void tracing_sched_switch_assign_trace ( struct trace_array * tr ) ;

enum { TRACE_FUNC_OPT_STACK = 0x1 , } ;
enum { TRACE_NOP_OPT_ACCEPT = 0x1 , TRACE_NOP_OPT_REFUSE = 0x2 } ;
struct header_iter { struct pci_dev * dev ; } ;

void mmio_trace_rw ( struct mmiotrace_rw * rw ) ;

void mmio_trace_mapping ( struct mmiotrace_map * map ) ;

int mmio_trace_printk ( const char * fmt , va_list args ) ;

struct fgraph_data { pid_t last_pid ; int depth ; } ;

int ftrace_push_return_trace ( unsigned long ret , unsigned long func , int * depth , unsigned long frame_pointer ) ;

unsigned long ftrace_return_to_handler ( unsigned long frame_pointer ) ;

int trace_graph_entry ( struct ftrace_graph_ent * trace ) ;

void trace_graph_return ( struct ftrace_graph_ret * trace ) ;

void set_graph_array ( struct trace_array * tr ) ;

enum print_line_t trace_print_graph_duration ( unsigned long long duration , struct trace_seq * s ) ;

enum print_line_t print_graph_function ( struct trace_iterator * iter ) ;

struct rchan_buf { void * start ; void * data ; size_t offset ; size_t subbufs_produced ; size_t subbufs_consumed ; struct rchan * chan ; wait_queue_head_t read_wait ; struct timer_list timer ; struct dentry * dentry ; struct kref kref ; struct page * * page_array ; unsigned int page_count ; unsigned int finalized ; size_t * padding ; size_t prev_padding ; size_t bytes_consumed ; size_t early_bytes ; unsigned int cpu ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct rchan { u32 version ; size_t subbuf_size ; size_t n_subbufs ; size_t alloc_size ; struct rchan_callbacks * cb ; struct kref kref ; void * private_data ; size_t last_toobig ; struct rchan_buf * buf [ 64 ] ; int is_global ; struct list_head list ; struct dentry * parent ; int has_base_filename ; char base_filename [ 255 ] ; } ;

struct rchan_callbacks { int ( * subbuf_start ) ( struct rchan_buf * buf , void * subbuf , void * prev_subbuf , size_t prev_padding ) ; void ( * buf_mapped ) ( struct rchan_buf * buf , struct file * filp ) ; void ( * buf_unmapped ) ( struct rchan_buf * buf , struct file * filp ) ; struct dentry * ( * create_buf_file ) ( const char * filename , struct dentry * parent , int mode , struct rchan_buf * buf , int * is_global ) ; int ( * remove_buf_file ) ( struct dentry * dentry ) ; } ;

enum blktrace_cat { BLK_TC_READ = 1 << 0 , BLK_TC_WRITE = 1 << 1 , BLK_TC_BARRIER = 1 << 2 , BLK_TC_SYNC = 1 << 3 , BLK_TC_SYNCIO = BLK_TC_SYNC , BLK_TC_QUEUE = 1 << 4 , BLK_TC_REQUEUE = 1 << 5 , BLK_TC_ISSUE = 1 << 6 , BLK_TC_COMPLETE = 1 << 7 , BLK_TC_FS = 1 << 8 , BLK_TC_PC = 1 << 9 , BLK_TC_NOTIFY = 1 << 10 , BLK_TC_AHEAD = 1 << 11 , BLK_TC_META = 1 << 12 , BLK_TC_DISCARD = 1 << 13 , BLK_TC_DRV_DATA = 1 << 14 , BLK_TC_END = 1 << 15 , } ;

enum blktrace_act { __BLK_TA_QUEUE = 1 , __BLK_TA_BACKMERGE , __BLK_TA_FRONTMERGE , __BLK_TA_GETRQ , __BLK_TA_SLEEPRQ , __BLK_TA_REQUEUE , __BLK_TA_ISSUE , __BLK_TA_COMPLETE , __BLK_TA_PLUG , __BLK_TA_UNPLUG_IO , __BLK_TA_UNPLUG_TIMER , __BLK_TA_INSERT , __BLK_TA_SPLIT , __BLK_TA_BOUNCE , __BLK_TA_REMAP , __BLK_TA_ABORT , __BLK_TA_DRV_DATA , } ;

enum blktrace_notify { __BLK_TN_PROCESS = 0 , __BLK_TN_TIMESTAMP , __BLK_TN_MESSAGE , } ;

struct blk_io_trace { __u32 magic ; __u32 sequence ; __u64 time ; __u64 sector ; __u32 bytes ; __u32 action ; __u32 pid ; __u32 device ; __u32 cpu ; __u16 error ; __u16 pdu_len ; } ;

struct blk_io_trace_remap { __be32 device_from ; __be32 device_to ; __be64 sector_from ; } ;

enum { Blktrace_setup = 1 , Blktrace_running , Blktrace_stopped , } ;
struct blk_user_trace_setup { char name [ 32 ] ; __u16 act_mask ; __u32 buf_size ; __u32 buf_nr ; __u64 start_lba ; __u64 end_lba ; __u32 pid ; } ;

struct blk_trace { int trace_state ; struct rchan * rchan ; unsigned long * sequence ; unsigned char * msg_data ; u16 act_mask ; u64 start_lba ; u64 end_lba ; u32 pid ; u32 dev ; struct dentry * dir ; struct dentry * dropped_file ; struct dentry * msg_file ; atomic_t dropped ; } ;
void __trace_note_message ( struct blk_trace * bt , const char * fmt , ... ) ;

int blk_trace_remove ( struct request_queue * q ) ;

int do_blk_trace_setup ( struct request_queue * q , char * name , dev_t dev , struct block_device * bdev , struct blk_user_trace_setup * buts ) ;

int blk_trace_setup ( struct request_queue * q , char * name , dev_t dev , struct block_device * bdev , char * arg ) ;

int blk_trace_startstop ( struct request_queue * q , int start ) ;

int blk_trace_ioctl ( struct block_device * bdev , unsigned cmd , char * arg ) ;

void blk_trace_shutdown ( struct request_queue * q ) ;

void blk_add_driver_data ( struct request_queue * q , struct request * rq , void * data , size_t len ) ;

typedef int ( blk_log_action_t ) ( struct trace_iterator * iter , const char * act ) ;
int blk_trace_init_sysfs ( struct device * dev ) ;

void blk_trace_remove_sysfs ( struct device * dev ) ;

void blk_dump_cmd ( char * buf , struct request * rq ) ;

void blk_fill_rwbs ( char * rwbs , u32 rw , int bytes ) ;

void blk_fill_rwbs_rq ( char * rwbs , struct request * rq ) ;

int trace_define_field ( struct ftrace_event_call * call , const char * type , const char * name , int offset , int size , int is_signed , int filter_type ) ;

int trace_define_common_fields ( struct ftrace_event_call * call ) ;

int trace_set_clr_event ( const char * system , const char * event , int set ) ;

struct ftrace_module_file_ops { struct list_head list ; struct module * mod ; struct file_operations id ; struct file_operations enable ; struct file_operations format ; struct file_operations filter ; } ;

struct ____ftrace_function { unsigned long ip ; unsigned long parent_ip ; } ;

struct ____ftrace_funcgraph_entry { unsigned long func ; int depth ; } ;

struct ____ftrace_funcgraph_exit { unsigned long func ; unsigned long long calltime ; unsigned long long rettime ; unsigned long overrun ; int depth ; } ;

struct ____ftrace_context_switch { unsigned int prev_pid ; unsigned char prev_prio ; unsigned char prev_state ; unsigned int next_pid ; unsigned char next_prio ; unsigned char next_state ; unsigned int next_cpu ; } ;

struct ____ftrace_wakeup { unsigned int prev_pid ; unsigned char prev_prio ; unsigned char prev_state ; unsigned int next_pid ; unsigned char next_prio ; unsigned char next_state ; unsigned int next_cpu ; } ;

struct ____ftrace_special { unsigned long arg1 ; unsigned long arg2 ; unsigned long arg3 ; } ;

struct ____ftrace_kernel_stack { unsigned long caller [ 8 ] ; } ;

struct ____ftrace_user_stack { unsigned int tgid ; unsigned long caller [ 8 ] ; } ;

struct ____ftrace_bprint { unsigned long ip ; const char * fmt ; u32 buf [ ] ; } ;

struct ____ftrace_print { unsigned long ip ; char buf [ ] ; } ;

struct ____ftrace_mmiotrace_rw { resource_size_t phys ; unsigned long value ; unsigned long pc ; int map_id ; unsigned char opcode ; unsigned char width ; } ;

struct ____ftrace_mmiotrace_map { resource_size_t phys ; unsigned long virt ; unsigned long len ; int map_id ; unsigned char opcode ; } ;

struct ____ftrace_boot_call { pid_t caller ; char func [ ( sizeof ( ) + ( 128 - 1 ) + 2 * ( 64 * 3 / 10 ) + ( ( 64 - sizeof ( unsigned long ) ) - 1 ) + 1 ) ] ; } ;

struct ____ftrace_boot_ret { char func [ ( sizeof ( ) + ( 128 - 1 ) + 2 * ( 64 * 3 / 10 ) + ( ( 64 - sizeof ( unsigned long ) ) - 1 ) + 1 ) ] ; int result ; unsigned long duration ; } ;

struct ____ftrace_branch { unsigned int line ; char func [ 30 + 1 ] ; char file [ 20 + 1 ] ; char correct ; } ;

struct ____ftrace_hw_branch { u64 from ; u64 to ; } ;

struct ____ftrace_kmem_alloc { enum kmemtrace_type_id type_id ; unsigned long call_site ; const void * ptr ; size_t bytes_req ; size_t bytes_alloc ; gfp_t gfp_flags ; int node ; } ;

struct ____ftrace_kmem_free { enum kmemtrace_type_id type_id ; unsigned long call_site ; const void * ptr ; } ;

int ftrace_define_fields_function ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_funcgraph_entry ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_funcgraph_exit ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_context_switch ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_wakeup ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_special ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_kernel_stack ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_user_stack ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_bprint ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_print ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_mmiotrace_rw ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_mmiotrace_map ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_boot_call ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_boot_ret ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_branch ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_hw_branch ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_kmem_alloc ( struct ftrace_event_call * event_call ) ;

int ftrace_define_fields_kmem_free ( struct ftrace_event_call * event_call ) ;

typedef struct { char buf [ 2048 ] ; } profile_buf_t ;

int ftrace_profile_enable ( int event_id ) ;

void ftrace_profile_disable ( int event_id ) ;

enum filter_op_ids { OP_OR , OP_AND , OP_NE , OP_EQ , OP_LT , OP_LE , OP_GT , OP_GE , OP_NONE , OP_OPEN_PAREN , } ;

struct filter_op { int id ; char * string ; int precedence ; } ;

enum { FILT_ERR_NONE , FILT_ERR_INVALID_OP , FILT_ERR_UNBALANCED_PAREN , FILT_ERR_TOO_MANY_OPERANDS , FILT_ERR_OPERAND_TOO_LONG , FILT_ERR_FIELD_NOT_FOUND , FILT_ERR_ILLEGAL_FIELD_OP , FILT_ERR_ILLEGAL_INTVAL , FILT_ERR_BAD_SUBSYS_FILTER , FILT_ERR_TOO_MANY_PREDS , FILT_ERR_MISSING_FIELD , FILT_ERR_INVALID_FILTER , } ;
struct opstack_op { int op ; struct list_head list ; } ;

struct postfix_elt { int op ; char * operand ; struct list_head list ; } ;

struct filter_parse_state { struct filter_op * ops ; struct list_head opstack ; struct list_head postfix ; int lasterr ; int lasterr_pos ; struct { char * string ; unsigned int cnt ; unsigned int tail ; } infix ; struct { char string [ 256 ] ; int pos ; unsigned int tail ; } operand ; } ;

int filter_match_preds ( struct ftrace_event_call * call , void * rec ) ;

void print_event_filter ( struct ftrace_event_call * call , struct trace_seq * s ) ;

void print_subsystem_event_filter ( struct event_subsystem * system , struct trace_seq * s ) ;

void destroy_preds ( struct ftrace_event_call * call ) ;

enum { FILTER_DISABLE_ALL , FILTER_INIT_NO_RESET , FILTER_SKIP_NO_RESET , } ;
int filter_assign_type ( const char * type ) ;

int apply_event_filter ( struct ftrace_event_call * call , char * filter_string ) ;

int apply_subsystem_event_filter ( struct event_subsystem * system , char * filter_string ) ;

struct ftrace_raw_power_start { struct trace_entry ent ; u64 type ; u64 state ; char __data [ 0 ] ; } ;

struct ftrace_raw_power_end { struct trace_entry ent ; u64 dummy ; char __data [ 0 ] ; } ;

struct ftrace_raw_power_frequency { struct trace_entry ent ; u64 type ; u64 state ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_power_start { ; } ;

struct ftrace_data_offsets_power_end { ; } ;

struct ftrace_data_offsets_power_frequency { ; } ;

struct rt_mutex_waiter { struct plist_node list_entry ; struct plist_node pi_list_entry ; struct task_struct * task ; struct rt_mutex * lock ; } ;
struct futex_pi_state { struct list_head list ; struct rt_mutex pi_mutex ; struct task_struct * owner ; atomic_t refcount ; union futex_key key ; } ;
struct futex_q { struct plist_node list ; struct task_struct * task ; spinlock_t * lock_ptr ; union futex_key key ; struct futex_pi_state * pi_state ; struct rt_mutex_waiter * rt_waiter ; union futex_key * requeue_pi_key ; u32 bitset ; } ;

struct futex_hash_bucket { spinlock_t lock ; struct plist_head chain ; } ;

void exit_pi_state_list ( struct task_struct * curr ) ;

long sys_set_robust_list ( struct robust_list_head * head , size_t len ) ;

long sys_get_robust_list ( int pid , struct robust_list_head * * head_ptr , size_t * len_ptr ) ;

int handle_futex_death ( u32 * uaddr , struct task_struct * curr , int pi ) ;

void exit_robust_list ( struct task_struct * curr ) ;

long do_futex ( u32 * uaddr , int op , u32 val , ktime_t * timeout , u32 * uaddr2 , u32 val2 , u32 val3 ) ;

long sys_futex ( u32 * uaddr , int op , u32 val , struct timespec * utime , u32 * uaddr2 , u32 val3 ) ;

void compat_exit_robust_list ( struct task_struct * curr ) ;

long compat_sys_set_robust_list ( struct compat_robust_list_head * head , compat_size_t len ) ;

long compat_sys_get_robust_list ( int pid , compat_uptr_t * head_ptr , compat_size_t * len_ptr ) ;

long compat_sys_futex ( u32 * uaddr , int op , u32 val , struct compat_timespec * utime , u32 * uaddr2 , u32 val3 ) ;

int rt_mutex_getprio ( struct task_struct * task ) ;

void rt_mutex_adjust_pi ( struct task_struct * task ) ;

void __attribute__ ( ( __section__ ( ) ) ) rt_mutex_lock ( struct rt_mutex * lock ) ;

int __attribute__ ( ( __section__ ( ) ) ) rt_mutex_lock_interruptible ( struct rt_mutex * lock , int detect_deadlock ) ;

int rt_mutex_timed_lock ( struct rt_mutex * lock , struct hrtimer_sleeper * timeout , int detect_deadlock ) ;

int __attribute__ ( ( __section__ ( ) ) ) rt_mutex_trylock ( struct rt_mutex * lock ) ;

void __attribute__ ( ( __section__ ( ) ) ) rt_mutex_unlock ( struct rt_mutex * lock ) ;

void rt_mutex_destroy ( struct rt_mutex * lock ) ;

void __rt_mutex_init ( struct rt_mutex * lock , const char * name ) ;

void rt_mutex_init_proxy_locked ( struct rt_mutex * lock , struct task_struct * proxy_owner ) ;

void rt_mutex_proxy_unlock ( struct rt_mutex * lock , struct task_struct * proxy_owner ) ;

int rt_mutex_start_proxy_lock ( struct rt_mutex * lock , struct rt_mutex_waiter * waiter , struct task_struct * task , int detect_deadlock ) ;

struct task_struct * rt_mutex_next_owner ( struct rt_mutex * lock ) ;

int rt_mutex_finish_proxy_lock ( struct rt_mutex * lock , struct hrtimer_sleeper * to , struct rt_mutex_waiter * waiter , int detect_deadlock ) ;

struct dma_chan { int lock ; const char * device_id ; } ;
int request_dma ( unsigned int dmanr , const char * device_id ) ;

void free_dma ( unsigned int dmanr ) ;

enum { CSD_FLAG_LOCK = 0x01 , } ;
struct call_function_data { struct call_single_data csd ; atomic_t refs ; cpumask_var_t cpumask ; } ;

struct call_single_queue { struct list_head list ; spinlock_t lock ; } ;

void generic_smp_call_function_interrupt ( void ) ;

void generic_smp_call_function_single_interrupt ( void ) ;

int smp_call_function_single ( int cpu , void ( * func ) ( void * info ) , void * info , int wait ) ;

void __smp_call_function_single ( int cpu , struct call_single_data * data , int wait ) ;

void smp_call_function_many ( const struct cpumask * mask , void ( * func ) ( void * ) , void * info , bool wait ) ;

int smp_call_function ( void ( * func ) ( void * ) , void * info , int wait ) ;

void ipi_call_lock ( void ) ;

void ipi_call_unlock ( void ) ;

void ipi_call_lock_irq ( void ) ;

void ipi_call_unlock_irq ( void ) ;

int __attribute__ ( ( section ( ) ) ) _spin_trylock ( spinlock_t * lock ) ;

int __attribute__ ( ( section ( ) ) ) _read_trylock ( rwlock_t * lock ) ;

int __attribute__ ( ( section ( ) ) ) _write_trylock ( rwlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _read_lock ( rwlock_t * lock ) ;

unsigned long __attribute__ ( ( section ( ) ) ) _spin_lock_irqsave ( spinlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _spin_lock_irq ( spinlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _spin_lock_bh ( spinlock_t * lock ) ;

unsigned long __attribute__ ( ( section ( ) ) ) _read_lock_irqsave ( rwlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _read_lock_irq ( rwlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _read_lock_bh ( rwlock_t * lock ) ;

unsigned long __attribute__ ( ( section ( ) ) ) _write_lock_irqsave ( rwlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _write_lock_irq ( rwlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _write_lock_bh ( rwlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _spin_lock ( spinlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _write_lock ( rwlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _spin_unlock_irqrestore ( spinlock_t * lock , unsigned long flags ) ;

void __attribute__ ( ( section ( ) ) ) _spin_unlock_bh ( spinlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _read_unlock_irqrestore ( rwlock_t * lock , unsigned long flags ) ;

void __attribute__ ( ( section ( ) ) ) _read_unlock_bh ( rwlock_t * lock ) ;

void __attribute__ ( ( section ( ) ) ) _write_unlock_irqrestore ( rwlock_t * lock , unsigned long flags ) ;

void __attribute__ ( ( section ( ) ) ) _write_unlock_bh ( rwlock_t * lock ) ;

int __attribute__ ( ( section ( ) ) ) _spin_trylock_bh ( spinlock_t * lock ) ;

__attribute__ ( ( no_instrument_function ) ) int in_lock_functions ( unsigned long addr ) ;

long sys_chown16 ( const char * filename , old_uid_t user , old_gid_t group ) ;

long sys_lchown16 ( const char * filename , old_uid_t user , old_gid_t group ) ;

long sys_fchown16 ( unsigned int fd , old_uid_t user , old_gid_t group ) ;

long sys_setregid16 ( old_gid_t rgid , old_gid_t egid ) ;

long sys_setgid16 ( old_gid_t gid ) ;

long sys_setreuid16 ( old_uid_t ruid , old_uid_t euid ) ;

long sys_setuid16 ( old_uid_t uid ) ;

long sys_setresuid16 ( old_uid_t ruid , old_uid_t euid , old_uid_t suid ) ;

long sys_getresuid16 ( old_uid_t * ruid , old_uid_t * euid , old_uid_t * suid ) ;

long sys_setresgid16 ( old_gid_t rgid , old_gid_t egid , old_gid_t sgid ) ;

long sys_getresgid16 ( old_gid_t * rgid , old_gid_t * egid , old_gid_t * sgid ) ;

long sys_setfsuid16 ( old_uid_t uid ) ;

long sys_setfsgid16 ( old_gid_t gid ) ;

long sys_getgroups16 ( int gidsetsize , old_gid_t * grouplist ) ;

long sys_setgroups16 ( int gidsetsize , old_gid_t * grouplist ) ;

long sys_getuid16 ( void ) ;

long sys_geteuid16 ( void ) ;

long sys_getgid16 ( void ) ;

long sys_getegid16 ( void ) ;

struct ftrace_raw_module_load { struct trace_entry ent ; unsigned int taints ; u32 __data_loc_name ; char __data [ 0 ] ; } ;

struct ftrace_raw_module_free { struct trace_entry ent ; u32 __data_loc_name ; char __data [ 0 ] ; } ;

struct ftrace_raw_module_get { struct trace_entry ent ; unsigned long ip ; int refcnt ; u32 __data_loc_name ; char __data [ 0 ] ; } ;

struct ftrace_raw_module_put { struct trace_entry ent ; unsigned long ip ; int refcnt ; u32 __data_loc_name ; char __data [ 0 ] ; } ;

struct ftrace_raw_module_request { struct trace_entry ent ; bool wait ; unsigned long ip ; u32 __data_loc_name ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_module_load { u32 name ; ; } ;

struct ftrace_data_offsets_module_free { u32 name ; ; } ;

struct ftrace_data_offsets_module_get { u32 name ; ; } ;

struct ftrace_data_offsets_module_put { u32 name ; ; } ;

struct ftrace_data_offsets_module_request { u32 name ; ; } ;

int register_module_notifier ( struct notifier_block * nb ) ;

int unregister_module_notifier ( struct notifier_block * nb ) ;

void * shadow_module_alloc ( unsigned long size ) ;

void __module_put_and_exit ( struct module * mod , long code ) ;

bool each_symbol ( bool ( * fn ) ( const struct symsearch * arr , struct module * owner , unsigned int symnum , void * data ) , void * data ) ;

struct find_symbol_arg { const char * name ; bool gplok ; bool warn ; struct module * owner ; const unsigned long * crc ; const struct kernel_symbol * sym ; } ;

const struct kernel_symbol * find_symbol ( const char * name , struct module * * owner , const unsigned long * * crc , bool gplok , bool warn ) ;
struct module * find_module ( const char * name ) ;

struct module_use { struct list_head list ; struct module * module_which_uses ; } ;

int use_module ( struct module * a , struct module * b ) ;

struct stopref { struct module * mod ; int flags ; int * forced ; } ;

unsigned int module_refcount ( struct module * mod ) ;

long sys_delete_module ( const char * name_user , unsigned int flags ) ;

void __symbol_put ( const char * symbol ) ;

void symbol_put_addr ( void * addr ) ;

void module_put ( struct module * module ) ;

struct module_sect_attr { struct module_attribute mattr ; char * name ; unsigned long address ; } ;

struct module_sect_attrs { struct attribute_group grp ; unsigned int nsections ; struct module_sect_attr attrs [ 0 ] ; } ;

struct module_notes_attrs { struct kobject * dir ; unsigned int notes ; struct bin_attribute attrs [ 0 ] ; } ;

int module_add_modinfo_attrs ( struct module * mod ) ;

void module_remove_modinfo_attrs ( struct module * mod ) ;

int mod_sysfs_init ( struct module * mod ) ;

int mod_sysfs_setup ( struct module * mod , struct kernel_param * kparam , unsigned int num_params ) ;

void * __symbol_get ( const char * symbol ) ;

unsigned int __attribute__ ( ( weak ) ) arch_mod_section_prepend ( struct module * mod , unsigned int section ) ;

long sys_init_module ( void * umod , unsigned long len , const char * uargs ) ;

const char * module_address_lookup ( unsigned long addr , unsigned long * size , unsigned long * offset , char * * modname , char * namebuf ) ;

int lookup_module_symbol_name ( unsigned long addr , char * symname ) ;

int lookup_module_symbol_attrs ( unsigned long addr , unsigned long * size , unsigned long * offset , char * modname , char * name ) ;

int module_get_kallsym ( unsigned int symnum , unsigned long * value , char * type , char * name , char * module_name , int * exported ) ;

unsigned long module_kallsyms_lookup_name ( const char * name ) ;

int module_kallsyms_on_each_symbol ( int ( * fn ) ( void * , const char * , struct module * , unsigned long ) , void * data ) ;

const struct exception_table_entry * search_module_extables ( unsigned long addr ) ;

bool is_module_address ( unsigned long addr ) ;

struct module * __module_address ( unsigned long addr ) ;

bool is_module_text_address ( unsigned long addr ) ;

struct module * __module_text_address ( unsigned long addr ) ;

void print_modules ( void ) ;

void module_layout ( struct module * mod , struct modversion_info * ver , struct kernel_param * kp , struct kernel_symbol * ks , struct tracepoint * tp ) ;

void module_update_tracepoints ( void ) ;

int module_get_iter_tracepoints ( struct tracepoint_iter * iter ) ;

unsigned long kallsyms_lookup_name ( const char * name ) ;

int kallsyms_on_each_symbol ( int ( * fn ) ( void * , const char * , struct module * , unsigned long ) , void * data ) ;

int kallsyms_lookup_size_offset ( unsigned long addr , unsigned long * symbolsize , unsigned long * offset ) ;

const char * kallsyms_lookup ( unsigned long addr , unsigned long * symbolsize , unsigned long * offset , char * * modname , char * namebuf ) ;

int lookup_symbol_name ( unsigned long addr , char * symname ) ;

int lookup_symbol_attrs ( unsigned long addr , unsigned long * size , unsigned long * offset , char * modname , char * name ) ;

int sprint_symbol ( char * buffer , unsigned long address ) ;

void __print_symbol ( const char * fmt , unsigned long address ) ;

struct kallsym_iter { loff_t pos ; unsigned long value ; unsigned int nameoff ; char type ; char name [ 128 ] ; char module_name [ ( 64 - sizeof ( unsigned long ) ) ] ; int exported ; } ;

struct bsd_acct_struct { volatile int active ; volatile int needcheck ; struct file * file ; struct pid_namespace * ns ; struct timer_list timer ; struct list_head list ; } ;
long sys_acct ( const char * name ) ;

void acct_auto_close_mnt ( struct vfsmount * m ) ;

void acct_auto_close ( struct super_block * sb ) ;

void acct_exit_ns ( struct pid_namespace * ns ) ;

void acct_init_pacct ( struct pacct_struct * pacct ) ;

void acct_collect ( long exitcode , int group_dead ) ;

void acct_process ( void ) ;

int kexec_should_crash ( struct task_struct * p ) ;

struct page * kimage_alloc_control_pages ( struct kimage * image , unsigned int order ) ;

long sys_kexec_load ( unsigned long entry , unsigned long nr_segments , struct kexec_segment * segments , unsigned long flags ) ;

long compat_sys_kexec_load ( unsigned long entry , unsigned long nr_segments , struct compat_kexec_segment * segments , unsigned long flags ) ;

void crash_kexec ( struct pt_regs * regs ) ;

void crash_save_cpu ( struct pt_regs * regs , int cpu ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) parse_crashkernel ( char * cmdline , unsigned long long system_ram , unsigned long long * crash_size , unsigned long long * crash_base ) ;

void crash_save_vmcoreinfo ( void ) ;

void vmcoreinfo_append_str ( const char * fmt , ... ) ;

void __attribute__ ( ( weak ) ) arch_crash_save_vmcoreinfo ( void ) ;
unsigned long __attribute__ ( ( weak ) ) paddr_vmcoreinfo_note ( void ) ;

int kernel_kexec ( void ) ;

typedef struct page * new_page_t ( struct page * , unsigned long private , int * * ) ;

long compat_sys_gettimeofday ( struct compat_timeval * tv , struct timezone * tz ) ;

long compat_sys_settimeofday ( struct compat_timeval * tv , struct timezone * tz ) ;

int get_compat_timespec ( struct timespec * ts , const struct compat_timespec * cts ) ;

int put_compat_timespec ( const struct timespec * ts , struct compat_timespec * cts ) ;

long compat_sys_nanosleep ( struct compat_timespec * rqtp , struct compat_timespec * rmtp ) ;

long compat_sys_getitimer ( int which , struct compat_itimerval * it ) ;

long compat_sys_setitimer ( int which , struct compat_itimerval * in , struct compat_itimerval * out ) ;

long compat_sys_times ( struct compat_tms * tbuf ) ;

long compat_sys_sigpending ( compat_old_sigset_t * set ) ;

long compat_sys_sigprocmask ( int how , compat_old_sigset_t * set , compat_old_sigset_t * oset ) ;

long compat_sys_setrlimit ( unsigned int resource , struct compat_rlimit * rlim ) ;

long compat_sys_old_getrlimit ( unsigned int resource , struct compat_rlimit * rlim ) ;

long compat_sys_getrlimit ( unsigned int resource , struct compat_rlimit * rlim ) ;

int put_compat_rusage ( const struct rusage * r , struct compat_rusage * ru ) ;

long compat_sys_getrusage ( int who , struct compat_rusage * ru ) ;

long compat_sys_wait4 ( compat_pid_t pid , compat_uint_t * stat_addr , int options , struct compat_rusage * ru ) ;

long compat_sys_waitid ( int which , compat_pid_t pid , struct compat_siginfo * uinfo , int options , struct compat_rusage * uru ) ;

long compat_sys_sched_setaffinity ( compat_pid_t pid , unsigned int len , compat_ulong_t * user_mask_ptr ) ;

long compat_sys_sched_getaffinity ( compat_pid_t pid , unsigned int len , compat_ulong_t * user_mask_ptr ) ;

int get_compat_itimerspec ( struct itimerspec * dst , const struct compat_itimerspec * src ) ;

int put_compat_itimerspec ( struct compat_itimerspec * dst , const struct itimerspec * src ) ;

long compat_sys_timer_create ( clockid_t which_clock , struct compat_sigevent * timer_event_spec , timer_t * created_timer_id ) ;

long compat_sys_timer_settime ( timer_t timer_id , int flags , struct compat_itimerspec * new , struct compat_itimerspec * old ) ;

long compat_sys_timer_gettime ( timer_t timer_id , struct compat_itimerspec * setting ) ;

long compat_sys_clock_settime ( clockid_t which_clock , struct compat_timespec * tp ) ;

long compat_sys_clock_gettime ( clockid_t which_clock , struct compat_timespec * tp ) ;

long compat_sys_clock_getres ( clockid_t which_clock , struct compat_timespec * tp ) ;

long compat_sys_clock_nanosleep ( clockid_t which_clock , int flags , struct compat_timespec * rqtp , struct compat_timespec * rmtp ) ;

int get_compat_sigevent ( struct sigevent * event , const struct compat_sigevent * u_event ) ;

long compat_get_bitmap ( unsigned long * mask , const compat_ulong_t * umask , unsigned long bitmap_size ) ;

long compat_put_bitmap ( compat_ulong_t * umask , unsigned long * mask , unsigned long bitmap_size ) ;

void sigset_from_compat ( sigset_t * set , compat_sigset_t * compat ) ;

long compat_sys_rt_sigtimedwait ( compat_sigset_t * uthese , struct compat_siginfo * uinfo , struct compat_timespec * uts , compat_size_t sigsetsize ) ;

long compat_sys_rt_tgsigqueueinfo ( compat_pid_t tgid , compat_pid_t pid , int sig , struct compat_siginfo * uinfo ) ;

long compat_sys_time ( compat_time_t * tloc ) ;

long compat_sys_stime ( compat_time_t * tptr ) ;

long compat_sys_adjtimex ( struct compat_timex * utp ) ;

long compat_sys_move_pages ( pid_t pid , unsigned long nr_pages , compat_uptr_t * pages32 , const int * nodes , int * status , int flags ) ;

long compat_sys_migrate_pages ( compat_pid_t pid , compat_ulong_t maxnode , const compat_ulong_t * old_nodes , const compat_ulong_t * new_nodes ) ;

struct compat_sysinfo { s32 uptime ; u32 loads [ 3 ] ; u32 totalram ; u32 freeram ; u32 sharedram ; u32 bufferram ; u32 totalswap ; u32 freeswap ; u16 procs ; u16 pad ; u32 totalhigh ; u32 freehigh ; u32 mem_unit ; char _f [ 20 - 2 * sizeof ( u32 ) - sizeof ( int ) ] ; } ;

long compat_sys_sysinfo ( struct compat_sysinfo * info ) ;

void * compat_alloc_user_space ( unsigned long len ) ;

struct open_intent { int flags ; int create_mode ; struct file * file ; } ;

enum { MAX_NESTED_LINKS = 8 } ;
struct nameidata { struct path path ; struct qstr last ; struct path root ; unsigned int flags ; int last_type ; unsigned depth ; char * saved_names [ MAX_NESTED_LINKS + 1 ] ; union { struct open_intent open ; } intent ; } ;
enum { LAST_NORM , LAST_ROOT , LAST_DOT , LAST_DOTDOT , LAST_BIND } ;
struct cgroupfs_root { struct super_block * sb ; unsigned long subsys_bits ; int hierarchy_id ; unsigned long actual_subsys_bits ; struct list_head subsys_list ; struct cgroup top_cgroup ; int number_of_cgroups ; struct list_head root_list ; unsigned long flags ; char release_agent_path [ 4096 ] ; char name [ 64 ] ; } ;
struct css_id { struct cgroup_subsys_state * css ; unsigned short id ; unsigned short depth ; struct rcu_head rcu_head ; unsigned short stack [ 0 ] ; } ;
enum { ROOT_NOPREFIX , } ;
struct cg_cgroup_link { struct list_head cgrp_link_list ; struct cgroup * cgrp ; struct list_head cg_link_list ; struct css_set * cg ; } ;

void cgroup_lock ( void ) ;

void cgroup_unlock ( void ) ;

void cgroup_exclude_rmdir ( struct cgroup_subsys_state * css ) ;

void cgroup_release_and_wakeup_rmdir ( struct cgroup_subsys_state * css ) ;

struct cgroup_sb_opts { unsigned long subsys_bits ; unsigned long flags ; char * release_agent ; char * name ; bool none ; struct cgroupfs_root * new_root ; } ;

int cgroup_path ( const struct cgroup * cgrp , char * buf , int buflen ) ;

int cgroup_attach_task ( struct cgroup * cgrp , struct task_struct * tsk ) ;

bool cgroup_lock_live_group ( struct cgroup * cgrp ) ;

struct cgroup_seqfile_state { struct cftype * cft ; struct cgroup * cgroup ; } ;

int cgroup_add_file ( struct cgroup * cgrp , struct cgroup_subsys * subsys , const struct cftype * cft ) ;

int cgroup_add_files ( struct cgroup * cgrp , struct cgroup_subsys * subsys , const struct cftype cft [ ] , int count ) ;

int cgroup_task_count ( const struct cgroup * cgrp ) ;

void cgroup_iter_start ( struct cgroup * cgrp , struct cgroup_iter * it ) ;

struct task_struct * cgroup_iter_next ( struct cgroup * cgrp , struct cgroup_iter * it ) ;

void cgroup_iter_end ( struct cgroup * cgrp , struct cgroup_iter * it ) ;

int cgroup_scan_tasks ( struct cgroup_scanner * scan ) ;

int cgroupstats_build ( struct cgroupstats * stats , struct dentry * dentry ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) cgroup_init_early ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) cgroup_init ( void ) ;

void cgroup_fork ( struct task_struct * child ) ;

void cgroup_fork_callbacks ( struct task_struct * child ) ;

void cgroup_post_fork ( struct task_struct * child ) ;

void cgroup_exit ( struct task_struct * tsk , int run_callbacks ) ;

int cgroup_clone ( struct task_struct * tsk , struct cgroup_subsys * subsys , char * nodename ) ;

int cgroup_is_descendant ( const struct cgroup * cgrp , struct task_struct * task ) ;

void __css_put ( struct cgroup_subsys_state * css ) ;

unsigned short css_id ( struct cgroup_subsys_state * css ) ;
unsigned short css_depth ( struct cgroup_subsys_state * css ) ;

bool css_is_ancestor ( struct cgroup_subsys_state * child , const struct cgroup_subsys_state * root ) ;

void free_css_id ( struct cgroup_subsys * ss , struct cgroup_subsys_state * css ) ;

struct cgroup_subsys_state * css_lookup ( struct cgroup_subsys * ss , int id ) ;

struct cgroup_subsys_state * css_get_next ( struct cgroup_subsys * ss , int id , struct cgroup_subsys_state * root , int * foundid ) ;

enum freezer_state { CGROUP_THAWED = 0 , CGROUP_FREEZING , CGROUP_FROZEN , } ;

struct freezer { struct cgroup_subsys_state css ; enum freezer_state state ; spinlock_t lock ; } ;

int cgroup_freezing_or_frozen ( struct task_struct * task ) ;

struct cpuset ;

struct fmeter { int cnt ; int val ; time_t time ; spinlock_t lock ; } ;

struct cpuset { struct cgroup_subsys_state css ; unsigned long flags ; cpumask_var_t cpus_allowed ; nodemask_t mems_allowed ; struct cpuset * parent ; struct fmeter fmeter ; int pn ; int relax_domain_level ; struct list_head stack_list ; } ;
typedef enum { CS_CPU_EXCLUSIVE , CS_MEM_EXCLUSIVE , CS_MEM_HARDWALL , CS_MEMORY_MIGRATE , CS_SCHED_LOAD_BALANCE , CS_SPREAD_PAGE , CS_SPREAD_SLAB , } cpuset_flagbits_t ;

void rebuild_sched_domains ( void ) ;

int current_cpuset_is_being_rebound ( void ) ;

typedef enum { FILE_MEMORY_MIGRATE , FILE_CPULIST , FILE_MEMLIST , FILE_CPU_EXCLUSIVE , FILE_MEM_EXCLUSIVE , FILE_MEM_HARDWALL , FILE_SCHED_LOAD_BALANCE , FILE_SCHED_RELAX_DOMAIN_LEVEL , FILE_MEMORY_PRESSURE_ENABLED , FILE_MEMORY_PRESSURE , FILE_SPREAD_PAGE , FILE_SPREAD_SLAB , } cpuset_filetype_t ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) cpuset_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) cpuset_init_smp ( void ) ;

void cpuset_cpus_allowed ( struct task_struct * tsk , struct cpumask * pmask ) ;

void cpuset_cpus_allowed_locked ( struct task_struct * tsk , struct cpumask * pmask ) ;

void cpuset_init_current_mems_allowed ( void ) ;

nodemask_t cpuset_mems_allowed ( struct task_struct * tsk ) ;

int cpuset_nodemask_valid_mems_allowed ( nodemask_t * nodemask ) ;

int __cpuset_node_allowed_softwall ( int node , gfp_t gfp_mask ) ;

int __cpuset_node_allowed_hardwall ( int node , gfp_t gfp_mask ) ;

void cpuset_lock ( void ) ;

void cpuset_unlock ( void ) ;

int cpuset_mem_spread_node ( void ) ;

int cpuset_mems_allowed_intersects ( const struct task_struct * tsk1 , const struct task_struct * tsk2 ) ;

void cpuset_print_task_mems_allowed ( struct task_struct * tsk ) ;

void __cpuset_memory_pressure_bump ( void ) ;

void cpuset_task_status_allowed ( struct seq_file * m , struct task_struct * task ) ;

struct ns_cgroup { struct cgroup_subsys_state css ; } ;

int ns_cgroup_clone ( struct task_struct * task , struct pid * pid ) ;

struct uts_namespace * copy_utsname ( unsigned long flags , struct uts_namespace * old_ns ) ;

void free_uts_ns ( struct kref * kref ) ;

int create_user_ns ( struct cred * new ) ;

void free_user_ns ( struct kref * kref ) ;

struct pid_cache { int nr_ids ; char name [ 16 ] ; struct kmem_cache * cachep ; struct list_head list ; } ;

struct pid_namespace * copy_pid_ns ( unsigned long flags , struct pid_namespace * old_ns ) ;

void free_pid_ns ( struct kref * kref ) ;

void zap_pid_ns_processes ( struct pid_namespace * pid_ns ) ;

struct match_token { int token ; const char * pattern ; } ;

typedef struct match_token match_table_t [ ] ;
enum { MAX_OPT_ARGS = 3 } ;
typedef struct { char * from ; char * to ; } substring_t ;

struct res_counter { unsigned long long usage ; unsigned long long max_usage ; unsigned long long limit ; unsigned long long soft_limit ; unsigned long long failcnt ; spinlock_t lock ; struct res_counter * parent ; } ;

typedef int ( * write_strategy_fn ) ( const char * buf , unsigned long long * val ) ;
enum { RES_USAGE , RES_MAX_USAGE , RES_LIMIT , RES_FAILCNT , RES_SOFT_LIMIT , } ;
void res_counter_init ( struct res_counter * counter , struct res_counter * parent ) ;

int res_counter_charge_locked ( struct res_counter * counter , unsigned long val ) ;

int res_counter_charge ( struct res_counter * counter , unsigned long val , struct res_counter * * limit_fail_at ) ;

void res_counter_uncharge_locked ( struct res_counter * counter , unsigned long val ) ;

void res_counter_uncharge ( struct res_counter * counter , unsigned long val ) ;

ssize_t res_counter_read ( struct res_counter * counter , int member , const char * userbuf , size_t nbytes , loff_t * pos , int ( * read_strategy ) ( unsigned long long val , char * st_buf ) ) ;

u64 res_counter_read_u64 ( struct res_counter * counter , int member ) ;

int res_counter_memparse_write_strategy ( const char * buf , unsigned long long * res ) ;

int res_counter_write ( struct res_counter * counter , int member , const char * buf , write_strategy_fn write_strategy ) ;

enum stopmachine_state { STOPMACHINE_NONE , STOPMACHINE_PREPARE , STOPMACHINE_DISABLE_IRQ , STOPMACHINE_RUN , STOPMACHINE_EXIT , } ;

struct stop_machine_data { int ( * fn ) ( void * ) ; void * data ; int fnret ; } ;

int stop_machine_create ( void ) ;

void stop_machine_destroy ( void ) ;

int __stop_machine ( int ( * fn ) ( void * ) , void * data , const struct cpumask * cpus ) ;

int stop_machine ( int ( * fn ) ( void * ) , void * data , const struct cpumask * cpus ) ;

struct inotify_event { __s32 wd ; __u32 mask ; __u32 cookie ; __u32 len ; char name [ 0 ] ; } ;

struct inotify_watch { struct list_head h_list ; struct list_head i_list ; atomic_t count ; struct inotify_handle * ih ; struct inode * inode ; __s32 wd ; __u32 mask ; } ;

struct inotify_operations { void ( * handle_event ) ( struct inotify_watch * , u32 , u32 , u32 , const char * , struct inode * ) ; void ( * destroy_watch ) ( struct inotify_watch * ) ; } ;

struct audit_buffer { struct list_head list ; struct sk_buff * skb ; struct audit_context * ctx ; gfp_t gfp_mask ; } ;
struct audit_reply { int pid ; struct sk_buff * skb ; } ;

void audit_panic ( const char * message ) ;

void audit_log_lost ( const char * message ) ;

int audit_send_list ( void * _dest ) ;

struct sk_buff * audit_make_reply ( int pid , int seq , int type , int done , int multi , void * payload , int size ) ;

void audit_send_reply ( int pid , int seq , int type , int done , int multi , void * payload , int size ) ;

unsigned int audit_serial ( void ) ;

struct audit_buffer * audit_log_start ( struct audit_context * ctx , gfp_t gfp_mask , int type ) ;

void audit_log_format ( struct audit_buffer * ab , const char * fmt , ... ) ;

void audit_log_n_hex ( struct audit_buffer * ab , const unsigned char * buf , size_t len ) ;

void audit_log_n_string ( struct audit_buffer * ab , const char * string , size_t slen ) ;

int audit_string_contains_control ( const char * string , size_t len ) ;

void audit_log_n_untrustedstring ( struct audit_buffer * ab , const char * string , size_t len ) ;

void audit_log_untrustedstring ( struct audit_buffer * ab , const char * string ) ;

void audit_log_d_path ( struct audit_buffer * ab , const char * prefix , struct path * path ) ;

void audit_log_key ( struct audit_buffer * ab , char * key ) ;

void audit_log_end ( struct audit_buffer * ab ) ;

void audit_log ( struct audit_context * ctx , gfp_t gfp_mask , int type , const char * fmt , ... ) ;

void audit_free_rule_rcu ( struct rcu_head * head ) ;

char * audit_unpack_string ( void * * bufp , size_t * remain , size_t len ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) audit_register_class ( int class , unsigned * list ) ;

int audit_match_class ( int class , unsigned syscall ) ;

struct audit_entry * audit_dupe_rule ( struct audit_krule * old , struct audit_watch * watch ) ;

int audit_receive_filter ( int type , int pid , int uid , int seq , void * data , size_t datasz , uid_t loginuid , u32 sessionid , u32 sid ) ;

int audit_comparator ( u32 left , u32 op , u32 right ) ;

int audit_compare_dname_path ( const char * dname , const char * path , int * dirlen ) ;

int audit_filter_user ( struct netlink_skb_parms * cb ) ;

int audit_filter_type ( int type ) ;

int audit_update_lsm_rules ( void ) ;

struct audit_watch { atomic_t count ; dev_t dev ; char * path ; unsigned long ino ; struct audit_parent * parent ; struct list_head wlist ; struct list_head rules ; } ;
struct audit_parent { struct list_head ilist ; struct list_head watches ; struct inotify_watch wdata ; unsigned flags ; } ;

void audit_get_watch ( struct audit_watch * watch ) ;

void audit_put_watch ( struct audit_watch * watch ) ;

void audit_remove_watch ( struct audit_watch * watch ) ;

char * audit_watch_path ( struct audit_watch * watch ) ;

struct list_head * audit_watch_rules ( struct audit_watch * watch ) ;

unsigned long audit_watch_inode ( struct audit_watch * watch ) ;

dev_t audit_watch_dev ( struct audit_watch * watch ) ;

int audit_to_watch ( struct audit_krule * krule , char * path , int len , u32 op ) ;

void audit_inotify_unregister ( struct list_head * in_list ) ;

int audit_add_watch ( struct audit_krule * krule ) ;

void audit_remove_watch_rule ( struct audit_krule * krule , struct list_head * list ) ;

struct audit_cap_data { kernel_cap_t permitted ; kernel_cap_t inheritable ; union { unsigned int fE ; kernel_cap_t effective ; } ; } ;

struct audit_names { const char * name ; int name_len ; unsigned name_put ; unsigned long ino ; dev_t dev ; umode_t mode ; uid_t uid ; gid_t gid ; dev_t rdev ; u32 osid ; struct audit_cap_data fcap ; unsigned int fcap_ver ; } ;

struct audit_aux_data { struct audit_aux_data * next ; int type ; } ;

struct audit_aux_data_execve { struct audit_aux_data d ; int argc ; int envc ; struct mm_struct * mm ; } ;

struct audit_aux_data_pids { struct audit_aux_data d ; pid_t target_pid [ 16 ] ; uid_t target_auid [ 16 ] ; uid_t target_uid [ 16 ] ; unsigned int target_sessionid [ 16 ] ; u32 target_sid [ 16 ] ; char target_comm [ 16 ] [ 16 ] ; int pid_count ; } ;

struct audit_aux_data_bprm_fcaps { struct audit_aux_data d ; struct audit_cap_data fcap ; unsigned int fcap_ver ; struct audit_cap_data old_pcap ; struct audit_cap_data new_pcap ; } ;

struct audit_aux_data_capset { struct audit_aux_data d ; pid_t pid ; struct audit_cap_data cap ; } ;

struct audit_tree_refs { struct audit_tree_refs * next ; struct audit_chunk * c [ 31 ] ; } ;

struct audit_context { int dummy ; int in_syscall ; enum audit_state state , current_state ; unsigned int serial ; int major ; struct timespec ctime ; unsigned long argv [ 4 ] ; long return_code ; u64 prio ; int return_valid ; int name_count ; struct audit_names names [ 20 ] ; char * filterkey ; struct path pwd ; struct audit_context * previous ; struct audit_aux_data * aux ; struct audit_aux_data * aux_pids ; struct __kernel_sockaddr_storage * sockaddr ; size_t sockaddr_len ; pid_t pid , ppid ; uid_t uid , euid , suid , fsuid ; gid_t gid , egid , sgid , fsgid ; unsigned long personality ; int arch ; pid_t target_pid ; uid_t target_auid ; uid_t target_uid ; unsigned int target_sessionid ; u32 target_sid ; char target_comm [ 16 ] ; struct audit_tree_refs * trees , * first_trees ; struct list_head killed_trees ; int tree_count ; int type ; union { struct { int nargs ; long args [ 6 ] ; } socketcall ; struct { uid_t uid ; gid_t gid ; mode_t mode ; u32 osid ; int has_perm ; uid_t perm_uid ; gid_t perm_gid ; mode_t perm_mode ; unsigned long qbytes ; } ipc ; struct { mqd_t mqdes ; struct mq_attr mqstat ; } mq_getsetattr ; struct { mqd_t mqdes ; int sigev_signo ; } mq_notify ; struct { mqd_t mqdes ; size_t msg_len ; unsigned int msg_prio ; struct timespec abs_timeout ; } mq_sendrecv ; struct { int oflag ; mode_t mode ; struct mq_attr attr ; } mq_open ; struct { pid_t pid ; struct audit_cap_data cap ; } capset ; } ; int fds [ 2 ] ; } ;
void audit_filter_inodes ( struct task_struct * tsk , struct audit_context * ctx ) ;

int audit_alloc ( struct task_struct * tsk ) ;

void audit_log_task_context ( struct audit_buffer * ab ) ;

void audit_free ( struct task_struct * tsk ) ;

void audit_syscall_entry ( int arch , int major , unsigned long a1 , unsigned long a2 , unsigned long a3 , unsigned long a4 ) ;

void audit_finish_fork ( struct task_struct * child ) ;

void audit_syscall_exit ( int valid , long return_code ) ;

void __audit_getname ( const char * name ) ;

void audit_putname ( const char * name ) ;

void __audit_inode ( const char * name , const struct dentry * dentry ) ;

void __audit_inode_child ( const char * dname , const struct dentry * dentry , const struct inode * parent ) ;

int auditsc_get_stamp ( struct audit_context * ctx , struct timespec * t , unsigned int * serial ) ;

int audit_set_loginuid ( struct task_struct * task , uid_t loginuid ) ;

void __audit_mq_open ( int oflag , mode_t mode , struct mq_attr * attr ) ;

void __audit_mq_sendrecv ( mqd_t mqdes , size_t msg_len , unsigned int msg_prio , const struct timespec * abs_timeout ) ;

void __audit_mq_notify ( mqd_t mqdes , const struct sigevent * notification ) ;

void __audit_mq_getsetattr ( mqd_t mqdes , struct mq_attr * mqstat ) ;

void __audit_ipc_obj ( struct kern_ipc_perm * ipcp ) ;

void __audit_ipc_set_perm ( unsigned long qbytes , uid_t uid , gid_t gid , mode_t mode ) ;

int audit_bprm ( struct linux_binprm * bprm ) ;

void audit_socketcall ( int nargs , unsigned long * args ) ;

void __audit_fd_pair ( int fd1 , int fd2 ) ;

int audit_sockaddr ( int len , void * a ) ;

void __audit_ptrace ( struct task_struct * t ) ;

int __audit_signal_info ( int sig , struct task_struct * t ) ;

int __audit_log_bprm_fcaps ( struct linux_binprm * bprm , const struct cred * new , const struct cred * old ) ;

void __audit_log_capset ( pid_t pid , const struct cred * new , const struct cred * old ) ;

void audit_core_dumps ( long signr ) ;

struct list_head * audit_killed_trees ( void ) ;

struct audit_tree { atomic_t count ; int goner ; struct audit_chunk * root ; struct list_head chunks ; struct list_head rules ; struct list_head list ; struct list_head same_root ; struct rcu_head head ; char pathname [ ] ; } ;
struct audit_chunk { struct list_head hash ; struct inotify_watch watch ; struct list_head trees ; int dead ; int count ; atomic_long_t refs ; struct rcu_head head ; struct node { struct list_head list ; struct audit_tree * owner ; unsigned index ; } owners [ ] ; } ;
const char * audit_tree_path ( struct audit_tree * tree ) ;

void audit_put_chunk ( struct audit_chunk * chunk ) ;

enum { HASH_SIZE = 128 } ;
struct audit_chunk * audit_tree_lookup ( const struct inode * inode ) ;

int audit_tree_match ( struct audit_chunk * chunk , struct audit_tree * tree ) ;

int audit_remove_tree_rule ( struct audit_krule * rule ) ;

void audit_trim_trees ( void ) ;

int audit_make_tree ( struct audit_krule * rule , char * pathname , u32 op ) ;

void audit_put_tree ( struct audit_tree * tree ) ;

int audit_add_tree_rule ( struct audit_krule * rule ) ;

int audit_tag_tree ( char * old , char * new ) ;

void audit_kill_trees ( struct list_head * list ) ;

struct kprobe_insn_page { struct list_head list ; kprobe_opcode_t * insns ; char slot_used [ ( ( ( 1UL ) << 12 ) / ( 16 * sizeof ( kprobe_opcode_t ) ) ) ] ; int nused ; int ngarbage ; } ;

enum kprobe_slot_state { SLOT_CLEAN = 0 , SLOT_DIRTY = 1 , SLOT_USED = 2 , } ;

kprobe_opcode_t __attribute__ ( ( __section__ ( ) ) ) * get_insn_slot ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) free_insn_slot ( kprobe_opcode_t * slot , int dirty ) ;

struct kprobe __attribute__ ( ( __section__ ( ) ) ) * get_kprobe ( void * addr ) ;

void __attribute__ ( ( __section__ ( ) ) ) kprobes_inc_nmissed_count ( struct kprobe * p ) ;

void __attribute__ ( ( __section__ ( ) ) ) recycle_rp_inst ( struct kretprobe_instance * ri , struct hlist_head * head ) ;

void __attribute__ ( ( __section__ ( ) ) ) kretprobe_hash_lock ( struct task_struct * tsk , struct hlist_head * * head , unsigned long * flags ) ;

void __attribute__ ( ( __section__ ( ) ) ) kretprobe_hash_unlock ( struct task_struct * tsk , unsigned long * flags ) ;

void __attribute__ ( ( __section__ ( ) ) ) kretprobe_table_unlock ( unsigned long hash , unsigned long * flags ) ;

void __attribute__ ( ( __section__ ( ) ) ) kprobe_flush_task ( struct task_struct * tk ) ;

int __attribute__ ( ( __section__ ( ) ) ) register_kprobe ( struct kprobe * p ) ;

int __attribute__ ( ( __section__ ( ) ) ) register_kprobes ( struct kprobe * * kps , int num ) ;

void __attribute__ ( ( __section__ ( ) ) ) unregister_kprobe ( struct kprobe * p ) ;

void __attribute__ ( ( __section__ ( ) ) ) unregister_kprobes ( struct kprobe * * kps , int num ) ;

unsigned long __attribute__ ( ( weak ) ) arch_deref_entry_point ( void * entry ) ;

int __attribute__ ( ( __section__ ( ) ) ) register_jprobes ( struct jprobe * * jps , int num ) ;

int __attribute__ ( ( __section__ ( ) ) ) register_jprobe ( struct jprobe * jp ) ;

void __attribute__ ( ( __section__ ( ) ) ) unregister_jprobe ( struct jprobe * jp ) ;

void __attribute__ ( ( __section__ ( ) ) ) unregister_jprobes ( struct jprobe * * jps , int num ) ;

int __attribute__ ( ( __section__ ( ) ) ) register_kretprobe ( struct kretprobe * rp ) ;

int __attribute__ ( ( __section__ ( ) ) ) register_kretprobes ( struct kretprobe * * rps , int num ) ;

void __attribute__ ( ( __section__ ( ) ) ) unregister_kretprobe ( struct kretprobe * rp ) ;

void __attribute__ ( ( __section__ ( ) ) ) unregister_kretprobes ( struct kretprobe * * rps , int num ) ;

int __attribute__ ( ( __section__ ( ) ) ) disable_kprobe ( struct kprobe * kp ) ;

int __attribute__ ( ( __section__ ( ) ) ) enable_kprobe ( struct kprobe * kp ) ;

struct kgdb_state { int ex_vector ; int signo ; int err_code ; int cpu ; int pass_exception ; unsigned long thr_query ; unsigned long threadid ; long kgdb_usethreadid ; struct pt_regs * linux_regs ; } ;


int __attribute__ ( ( weak ) ) kgdb_arch_set_breakpoint ( unsigned long addr , char * saved_instr ) ;

int __attribute__ ( ( weak ) ) kgdb_arch_remove_breakpoint ( unsigned long addr , char * bundle ) ;

int __attribute__ ( ( weak ) ) kgdb_validate_break_address ( unsigned long addr ) ;

unsigned long __attribute__ ( ( weak ) ) kgdb_arch_pc ( int exception , struct pt_regs * regs ) ;
int __attribute__ ( ( weak ) ) kgdb_arch_init ( void ) ;
int __attribute__ ( ( weak ) ) kgdb_skipexception ( int exception , struct pt_regs * regs ) ;
void __attribute__ ( ( weak ) ) kgdb_post_primary_code ( struct pt_regs * regs , int e_vector , int err_code ) ;
void __attribute__ ( ( weak ) ) kgdb_disable_hw_debug ( struct pt_regs * regs ) ;
int kgdb_mem2hex ( char * mem , char * buf , int count ) ;

int kgdb_hex2mem ( char * buf , char * mem , int count ) ;

int kgdb_hex2long ( char * * ptr , unsigned long * long_val ) ;

int kgdb_isremovedbreak ( unsigned long addr ) ;

int kgdb_handle_exception ( int evector , int signo , int ecode , struct pt_regs * regs ) ;

int kgdb_nmicallback ( int cpu , void * regs ) ;

int kgdb_register_io_module ( struct kgdb_io * new_kgdb_io_ops ) ;

void kgdb_unregister_io_module ( struct kgdb_io * old_kgdb_io_ops ) ;

void kgdb_breakpoint ( void ) ;

void touch_softlockup_watchdog ( void ) ;

void touch_all_softlockup_watchdogs ( void ) ;

int proc_dosoftlockup_thresh ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

void softlockup_tick ( void ) ;

int proc_dohung_task_timeout_secs ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

void __secure_computing ( int this_syscall ) ;

long prctl_get_seccomp ( void ) ;

long prctl_set_seccomp ( unsigned long seccomp_mode ) ;

struct rcu_dynticks { int dynticks_nesting ; int dynticks ; int dynticks_nmi ; } ;

struct rcu_node { spinlock_t lock ; long gpnum ; long completed ; unsigned long qsmask ; unsigned long qsmaskinit ; unsigned long grpmask ; int grplo ; int grphi ; u8 grpnum ; u8 level ; struct rcu_node * parent ; struct list_head blocked_tasks [ 2 ] ; } __attribute__ ( ( __aligned__ ( 1 << ( ( 6 ) ) ) ) ) ;
struct rcu_data { long completed ; long gpnum ; long passed_quiesc_completed ; bool passed_quiesc ; bool qs_pending ; bool beenonline ; bool preemptable ; struct rcu_node * mynode ; unsigned long grpmask ; struct rcu_head * nxtlist ; struct rcu_head * * nxttail [ 4 ] ; long qlen ; long qlen_last_fqs_check ; unsigned long n_force_qs_snap ; long blimit ; struct rcu_dynticks * dynticks ; int dynticks_snap ; int dynticks_nmi_snap ; unsigned long dynticks_fqs ; unsigned long offline_fqs ; unsigned long resched_ipi ; long n_rcu_pending ; long n_rp_qs_pending ; long n_rp_cb_ready ; long n_rp_cpu_needs_gp ; long n_rp_gp_completed ; long n_rp_gp_started ; long n_rp_need_fqs ; long n_rp_need_nothing ; int cpu ; } ;

struct rcu_state { struct rcu_node node [ ( ( 1 + ( 64 ) + 0 + 0 ) - 64 ) ] ; struct rcu_node * level [ 1 ] ; u32 levelcnt [ 3 + 1 ] ; u8 levelspread [ 1 ] ; struct rcu_data * rda [ 64 ] ; u8 signaled __attribute__ ( ( __aligned__ ( 1 << ( ( 6 ) ) ) ) ) ; long gpnum ; long completed ; spinlock_t onofflock ; struct rcu_head * orphan_cbs_list ; struct rcu_head * * orphan_cbs_tail ; long orphan_qlen ; spinlock_t fqslock ; unsigned long jiffies_force_qs ; unsigned long n_force_qs ; unsigned long n_force_qs_lh ; unsigned long n_force_qs_ngp ; long dynticks_completed ; } ;

void rcu_sched_qs ( int cpu ) ;

void rcu_bh_qs ( int cpu ) ;

long rcu_batches_completed_sched ( void ) ;

long rcu_batches_completed_bh ( void ) ;

void rcu_enter_nohz ( void ) ;

void rcu_exit_nohz ( void ) ;

void rcu_nmi_enter ( void ) ;

void rcu_nmi_exit ( void ) ;

void rcu_irq_enter ( void ) ;

void rcu_irq_exit ( void ) ;

void rcu_check_callbacks ( int cpu , int user ) ;

void call_rcu_sched ( struct rcu_head * head , void ( * func ) ( struct rcu_head * rcu ) ) ;

void call_rcu_bh ( struct rcu_head * head , void ( * func ) ( struct rcu_head * rcu ) ) ;

int rcu_needs_cpu ( int cpu ) ;

void rcu_barrier_bh ( void ) ;

void rcu_barrier_sched ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) rcu_cpu_notify ( struct notifier_block * self , unsigned long action , void * hcpu ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __rcu_init ( void ) ;

long rcu_batches_completed ( void ) ;

void call_rcu ( struct rcu_head * head , void ( * func ) ( struct rcu_head * rcu ) ) ;

void synchronize_rcu_expedited ( void ) ;

void rcu_barrier ( void ) ;

int relay_buf_full ( struct rchan_buf * buf ) ;

void relay_reset ( struct rchan * chan ) ;

struct rchan * relay_open ( const char * base_filename , struct dentry * parent , size_t subbuf_size , size_t n_subbufs , struct rchan_callbacks * cb , void * private_data ) ;

struct rchan_percpu_buf_dispatcher { struct rchan_buf * buf ; struct dentry * dentry ; } ;

int relay_late_setup_files ( struct rchan * chan , const char * base_filename , struct dentry * parent ) ;

size_t relay_switch_subbuf ( struct rchan_buf * buf , size_t length ) ;

void relay_subbufs_consumed ( struct rchan * chan , unsigned int cpu , size_t subbufs_consumed ) ;

void relay_close ( struct rchan * chan ) ;

void relay_flush ( struct rchan * chan ) ;

typedef int ( * subbuf_actor_t ) ( size_t read_start , struct rchan_buf * buf , size_t avail , read_descriptor_t * desc , read_actor_t actor ) ;
struct genlmsghdr { __u8 cmd ; __u8 version ; __u16 reserved ; } ;

enum { CTRL_CMD_UNSPEC , CTRL_CMD_NEWFAMILY , CTRL_CMD_DELFAMILY , CTRL_CMD_GETFAMILY , CTRL_CMD_NEWOPS , CTRL_CMD_DELOPS , CTRL_CMD_GETOPS , CTRL_CMD_NEWMCAST_GRP , CTRL_CMD_DELMCAST_GRP , CTRL_CMD_GETMCAST_GRP , __CTRL_CMD_MAX , } ;
enum { CTRL_ATTR_UNSPEC , CTRL_ATTR_FAMILY_ID , CTRL_ATTR_FAMILY_NAME , CTRL_ATTR_VERSION , CTRL_ATTR_HDRSIZE , CTRL_ATTR_MAXATTR , CTRL_ATTR_OPS , CTRL_ATTR_MCAST_GROUPS , __CTRL_ATTR_MAX , } ;
enum { CTRL_ATTR_OP_UNSPEC , CTRL_ATTR_OP_ID , CTRL_ATTR_OP_FLAGS , __CTRL_ATTR_OP_MAX , } ;
enum { CTRL_ATTR_MCAST_GRP_UNSPEC , CTRL_ATTR_MCAST_GRP_NAME , CTRL_ATTR_MCAST_GRP_ID , __CTRL_ATTR_MCAST_GRP_MAX , } ;
struct genl_multicast_group { struct genl_family * family ; struct list_head list ; char name [ 16 ] ; u32 id ; } ;

struct genl_family { unsigned int id ; unsigned int hdrsize ; char name [ 16 ] ; unsigned int version ; unsigned int maxattr ; bool netnsok ; struct nlattr * * attrbuf ; struct list_head ops_list ; struct list_head family_list ; struct list_head mcast_groups ; } ;

struct genl_info { u32 snd_seq ; u32 snd_pid ; struct nlmsghdr * nlhdr ; struct genlmsghdr * genlhdr ; void * userhdr ; struct nlattr * * attrs ; struct net * _net ; } ;

struct genl_ops { u8 cmd ; unsigned int flags ; const struct nla_policy * policy ; int ( * doit ) ( struct sk_buff * skb , struct genl_info * info ) ; int ( * dumpit ) ( struct sk_buff * skb , struct netlink_callback * cb ) ; int ( * done ) ( struct netlink_callback * cb ) ; struct list_head ops_list ; } ;

struct listener { struct list_head list ; pid_t pid ; char valid ; } ;

struct listener_list { struct rw_semaphore sem ; struct list_head list ; } ;

enum actions { REGISTER , DEREGISTER , CPU_DONT_CARE } ;

void taskstats_exit ( struct task_struct * tsk , int group_dead ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) taskstats_init_early ( void ) ;

void bacct_add_tsk ( struct taskstats * stats , struct task_struct * tsk ) ;

void xacct_add_tsk ( struct taskstats * stats , struct task_struct * p ) ;

void acct_update_integrals ( struct task_struct * tsk ) ;

void acct_clear_integrals ( struct task_struct * tsk ) ;

struct tracepoint_entry { struct hlist_node hlist ; void * * funcs ; int refcount ; char name [ 0 ] ; } ;

struct tp_probes { union { struct rcu_head rcu ; struct list_head list ; } u ; void * probes [ 0 ] ; } ;

void tracepoint_update_probe_range ( struct tracepoint * begin , struct tracepoint * end ) ;

int tracepoint_probe_register ( const char * name , void * probe ) ;

int tracepoint_probe_unregister ( const char * name , void * probe ) ;

int tracepoint_probe_register_noupdate ( const char * name , void * probe ) ;

int tracepoint_probe_unregister_noupdate ( const char * name , void * probe ) ;

void tracepoint_probe_update_all ( void ) ;

int tracepoint_get_iter_range ( struct tracepoint * * tracepoint , struct tracepoint * begin , struct tracepoint * end ) ;

void tracepoint_iter_start ( struct tracepoint_iter * iter ) ;

void tracepoint_iter_next ( struct tracepoint_iter * iter ) ;

void tracepoint_iter_stop ( struct tracepoint_iter * iter ) ;

void tracepoint_iter_reset ( struct tracepoint_iter * iter ) ;

int tracepoint_module_notify ( struct notifier_block * self , unsigned long val , void * data ) ;

void syscall_regfunc ( void ) ;

void syscall_unregfunc ( void ) ;

void clear_all_latency_tracing ( struct task_struct * p ) ;

void __attribute__ ( ( __section__ ( ) ) ) __account_scheduler_latency ( struct task_struct * tsk , int usecs , int inter ) ;

int cpupri_find ( struct cpupri * cp , struct task_struct * p , struct cpumask * lowest_mask ) ;

void cpupri_set ( struct cpupri * cp , int cpu , int newpri ) ;

int cpupri_init ( struct cpupri * cp , bool bootmem ) ;

void cpupri_cleanup ( struct cpupri * cp ) ;

__attribute__ ( ( weak ) ) const struct pmu * hw_perf_event_init ( struct perf_event * event ) ;
void __attribute__ ( ( weak ) ) hw_perf_disable ( void ) ;
void __attribute__ ( ( weak ) ) hw_perf_enable ( void ) ;
void __attribute__ ( ( weak ) ) hw_perf_event_setup ( int cpu ) ;

void __attribute__ ( ( weak ) ) hw_perf_event_setup_online ( int cpu ) ;
int __attribute__ ( ( weak ) ) hw_perf_group_sched_in ( struct perf_event * group_leader , struct perf_cpu_context * cpuctx , struct perf_event_context * ctx , int cpu ) ;

void __attribute__ ( ( weak ) ) perf_event_print_debug ( void ) ;
void __perf_disable ( void ) ;

bool __perf_enable ( void ) ;

void perf_disable ( void ) ;

void perf_enable ( void ) ;

void __perf_event_sched_out ( struct perf_event_context * ctx , struct perf_cpu_context * cpuctx ) ;

void perf_event_task_sched_out ( struct task_struct * task , struct task_struct * next , int cpu ) ;

void perf_event_task_sched_in ( struct task_struct * task , int cpu ) ;

void perf_event_task_tick ( struct task_struct * curr , int cpu ) ;

int perf_event_task_enable ( void ) ;

int perf_event_task_disable ( void ) ;

void perf_event_update_userpage ( struct perf_event * event ) ;

void perf_event_wakeup ( struct perf_event * event ) ;

void perf_event_do_pending ( void ) ;

__attribute__ ( ( weak ) ) struct perf_callchain_entry * perf_callchain ( struct pt_regs * regs ) ;
void perf_output_copy ( struct perf_output_handle * handle , const void * buf , unsigned int len ) ;

int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size , int nmi , int sample ) ;

void perf_output_end ( struct perf_output_handle * handle ) ;

void perf_output_sample ( struct perf_output_handle * handle , struct perf_event_header * header , struct perf_sample_data * data , struct perf_event * event ) ;

void perf_prepare_sample ( struct perf_event_header * header , struct perf_sample_data * data , struct perf_event * event , struct pt_regs * regs ) ;

struct perf_read_event { struct perf_event_header header ; u32 pid ; u32 tid ; } ;

struct perf_task_event { struct task_struct * task ; struct perf_event_context * task_ctx ; struct { struct perf_event_header header ; u32 pid ; u32 ppid ; u32 tid ; u32 ptid ; u64 time ; } event_id ; } ;

void perf_event_fork ( struct task_struct * task ) ;

struct perf_comm_event { struct task_struct * task ; char * comm ; int comm_size ; struct { struct perf_event_header header ; u32 pid ; u32 tid ; } event_id ; } ;

void perf_event_comm ( struct task_struct * task ) ;

struct perf_mmap_event { struct vm_area_struct * vma ; const char * file_name ; int file_size ; struct { struct perf_event_header header ; u32 pid ; u32 tid ; u64 start ; u64 len ; u64 pgoff ; } event_id ; } ;

void __perf_event_mmap ( struct vm_area_struct * vma ) ;

int perf_event_overflow ( struct perf_event * event , int nmi , struct perf_sample_data * data , struct pt_regs * regs ) ;

void __perf_sw_event ( u32 event_id , u64 nr , int nmi , struct pt_regs * regs , u64 addr ) ;

void perf_tp_event ( int event_id , u64 addr , u64 count , void * record , int entry_size ) ;

int perf_event_set_output ( struct perf_event * event , int output_fd ) ;

long sys_perf_event_open ( struct perf_event_attr * attr_uptr , pid_t pid , int cpu , int group_fd , unsigned long flags ) ;

void perf_event_exit_task ( struct task_struct * child ) ;

void perf_event_free_task ( struct task_struct * task ) ;

int perf_event_init_task ( struct task_struct * child ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) perf_event_init ( void ) ;

enum mminit_level { MMINIT_WARNING , MMINIT_VERIFY , MMINIT_TRACE } ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) bootmem_bootmap_pages ( unsigned long pages ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_bootmem_node ( pg_data_t * pgdat , unsigned long freepfn , unsigned long startpfn , unsigned long endpfn ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_bootmem ( unsigned long start , unsigned long pages ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) free_all_bootmem_node ( pg_data_t * pgdat ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) free_all_bootmem ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) free_bootmem_node ( pg_data_t * pgdat , unsigned long physaddr , unsigned long size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) free_bootmem ( unsigned long addr , unsigned long size ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_bootmem_node ( pg_data_t * pgdat , unsigned long physaddr , unsigned long size , int flags ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_bootmem ( unsigned long addr , unsigned long size , int flags ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __alloc_bootmem_nopanic ( unsigned long size , unsigned long align , unsigned long goal ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __alloc_bootmem ( unsigned long size , unsigned long align , unsigned long goal ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __alloc_bootmem_node ( pg_data_t * pgdat , unsigned long size , unsigned long align , unsigned long goal ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) alloc_bootmem_section ( unsigned long size , unsigned long section_nr ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __alloc_bootmem_node_nopanic ( pg_data_t * pgdat , unsigned long size , unsigned long align , unsigned long goal ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __alloc_bootmem_low ( unsigned long size , unsigned long align , unsigned long goal ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __alloc_bootmem_low_node ( pg_data_t * pgdat , unsigned long size , unsigned long align , unsigned long goal ) ;

struct pagevec { unsigned long nr ; unsigned long cold ; struct page * pages [ 14 ] ; } ;

void __remove_from_page_cache ( struct page * page ) ;

void remove_from_page_cache ( struct page * page ) ;

int __filemap_fdatawrite_range ( struct address_space * mapping , loff_t start , loff_t end , int sync_mode ) ;

int filemap_fdatawrite ( struct address_space * mapping ) ;

int filemap_fdatawrite_range ( struct address_space * mapping , loff_t start , loff_t end ) ;

int filemap_flush ( struct address_space * mapping ) ;

int wait_on_page_writeback_range ( struct address_space * mapping , unsigned long start , unsigned long end ) ;

int filemap_fdatawait_range ( struct address_space * mapping , loff_t start , loff_t end ) ;

int filemap_fdatawait ( struct address_space * mapping ) ;

int filemap_write_and_wait ( struct address_space * mapping ) ;

int filemap_write_and_wait_range ( struct address_space * mapping , loff_t lstart , loff_t lend ) ;

int add_to_page_cache_locked ( struct page * page , struct address_space * mapping , unsigned long offset , gfp_t gfp_mask ) ;

int add_to_page_cache_lru ( struct page * page , struct address_space * mapping , unsigned long offset , gfp_t gfp_mask ) ;

struct page * __page_cache_alloc ( gfp_t gfp ) ;

void wait_on_page_bit ( struct page * page , int bit_nr ) ;

void add_page_wait_queue ( struct page * page , wait_queue_t * waiter ) ;

void unlock_page ( struct page * page ) ;

void end_page_writeback ( struct page * page ) ;

void __lock_page ( struct page * page ) ;

int __lock_page_killable ( struct page * page ) ;

void __lock_page_nosync ( struct page * page ) ;

struct page * find_get_page ( struct address_space * mapping , unsigned long offset ) ;

struct page * find_lock_page ( struct address_space * mapping , unsigned long offset ) ;

struct page * find_or_create_page ( struct address_space * mapping , unsigned long index , gfp_t gfp_mask ) ;

unsigned find_get_pages ( struct address_space * mapping , unsigned long start , unsigned int nr_pages , struct page * * pages ) ;

unsigned find_get_pages_contig ( struct address_space * mapping , unsigned long index , unsigned int nr_pages , struct page * * pages ) ;

unsigned find_get_pages_tag ( struct address_space * mapping , unsigned long * index , int tag , unsigned int nr_pages , struct page * * pages ) ;

struct page * grab_cache_page_nowait ( struct address_space * mapping , unsigned long index ) ;

int file_read_actor ( read_descriptor_t * desc , struct page * page , unsigned long offset , unsigned long size ) ;

int generic_segment_checks ( const struct iovec * iov , unsigned long * nr_segs , size_t * count , int access_flags ) ;

ssize_t generic_file_aio_read ( struct kiocb * iocb , const struct iovec * iov , unsigned long nr_segs , loff_t pos ) ;

long sys_readahead ( int fd , loff_t offset , size_t count ) ;

int filemap_fault ( struct vm_area_struct * vma , struct vm_fault * vmf ) ;

int generic_file_mmap ( struct file * file , struct vm_area_struct * vma ) ;

int generic_file_readonly_mmap ( struct file * file , struct vm_area_struct * vma ) ;

struct page * read_cache_page_async ( struct address_space * mapping , unsigned long index , int ( * filler ) ( void * , struct page * ) , void * data ) ;

struct page * read_cache_page_gfp ( struct address_space * mapping , unsigned long index , gfp_t gfp ) ;

struct page * read_cache_page ( struct address_space * mapping , unsigned long index , int ( * filler ) ( void * , struct page * ) , void * data ) ;

int should_remove_suid ( struct dentry * dentry ) ;

int file_remove_suid ( struct file * file ) ;

size_t iov_iter_copy_from_user_atomic ( struct page * page , struct iov_iter * i , unsigned long offset , size_t bytes ) ;

size_t iov_iter_copy_from_user ( struct page * page , struct iov_iter * i , unsigned long offset , size_t bytes ) ;

void iov_iter_advance ( struct iov_iter * i , size_t bytes ) ;

int iov_iter_fault_in_readable ( struct iov_iter * i , size_t bytes ) ;

size_t iov_iter_single_seg_count ( struct iov_iter * i ) ;

int pagecache_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata ) ;

int pagecache_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) ;

ssize_t generic_file_direct_write ( struct kiocb * iocb , const struct iovec * iov , unsigned long * nr_segs , loff_t pos , loff_t * ppos , size_t count , size_t ocount ) ;

struct page * grab_cache_page_write_begin ( struct address_space * mapping , unsigned long index , unsigned flags ) ;

ssize_t generic_file_buffered_write ( struct kiocb * iocb , const struct iovec * iov , unsigned long nr_segs , loff_t pos , loff_t * ppos , size_t count , ssize_t written ) ;

ssize_t __generic_file_aio_write ( struct kiocb * iocb , const struct iovec * iov , unsigned long nr_segs , loff_t * ppos ) ;

ssize_t generic_file_aio_write ( struct kiocb * iocb , const struct iovec * iov , unsigned long nr_segs , loff_t pos ) ;

int try_to_release_page ( struct page * page , gfp_t gfp_mask ) ;

mempool_t * mempool_create ( int min_nr , mempool_alloc_t * alloc_fn , mempool_free_t * free_fn , void * pool_data ) ;

mempool_t * mempool_create_node ( int min_nr , mempool_alloc_t * alloc_fn , mempool_free_t * free_fn , void * pool_data , int node_id ) ;

int mempool_resize ( mempool_t * pool , int new_min_nr , gfp_t gfp_mask ) ;

void mempool_destroy ( mempool_t * pool ) ;

void * mempool_alloc ( mempool_t * pool , gfp_t gfp_mask ) ;

void mempool_free ( void * element , mempool_t * pool ) ;

void * mempool_alloc_slab ( gfp_t gfp_mask , void * pool_data ) ;

void mempool_free_slab ( void * element , void * pool_data ) ;

void * mempool_kmalloc ( gfp_t gfp_mask , void * pool_data ) ;

void mempool_kfree ( void * element , void * pool_data ) ;

void * mempool_alloc_pages ( gfp_t gfp_mask , void * pool_data ) ;

void mempool_free_pages ( void * element , void * pool_data ) ;

unsigned long badness ( struct task_struct * p , unsigned long uptime ) ;

void mem_cgroup_out_of_memory ( struct mem_cgroup * mem , gfp_t gfp_mask ) ;

int register_oom_notifier ( struct notifier_block * nb ) ;

int unregister_oom_notifier ( struct notifier_block * nb ) ;

int try_set_zone_oom ( struct zonelist * zonelist , gfp_t gfp_mask ) ;

void clear_zonelist_oom ( struct zonelist * zonelist , gfp_t gfp_mask ) ;

void pagefault_out_of_memory ( void ) ;

void out_of_memory ( struct zonelist * zonelist , gfp_t gfp_mask , int order ) ;

long sys_fadvise64_64 ( int fd , loff_t offset , loff_t len , int advice ) ;

long sys_fadvise64 ( int fd , loff_t offset , size_t len , int advice ) ;

long probe_kernel_read ( void * dst , void * src , size_t size ) ;

long __attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( weak ) ) probe_kernel_write ( void * dst , void * src , size_t size ) ;

void prep_compound_page ( struct page * page , unsigned long order ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __free_pages_bootmem ( struct page * page , unsigned int order ) ;

void drain_zone_pages ( struct zone * zone , struct per_cpu_pages * pcp ) ;

void drain_local_pages ( void * arg ) ;

void drain_all_pages ( void ) ;

void mark_free_pages ( struct zone * zone ) ;

void free_hot_page ( struct page * page ) ;

void split_page ( struct page * page , unsigned int order ) ;

int zone_watermark_ok ( struct zone * z , int order , unsigned long mark , int classzone_idx , int alloc_flags ) ;

struct page * __alloc_pages_nodemask ( gfp_t gfp_mask , unsigned int order , struct zonelist * zonelist , nodemask_t * nodemask ) ;

unsigned long __get_free_pages ( gfp_t gfp_mask , unsigned int order ) ;

unsigned long get_zeroed_page ( gfp_t gfp_mask ) ;

void __pagevec_free ( struct pagevec * pvec ) ;

void __free_pages ( struct page * page , unsigned int order ) ;

void free_pages ( unsigned long addr , unsigned int order ) ;

void * alloc_pages_exact ( size_t size , gfp_t gfp_mask ) ;

void free_pages_exact ( void * virt , size_t size ) ;

unsigned int nr_free_buffer_pages ( void ) ;

unsigned int nr_free_pagecache_pages ( void ) ;

void si_meminfo ( struct sysinfo * val ) ;

void si_meminfo_node ( struct sysinfo * val , int nid ) ;

void show_free_areas ( void ) ;

int numa_zonelist_order_handler ( ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

void build_all_zonelists ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) memmap_init_zone ( unsigned long size , int nid , unsigned long zone , unsigned long start_pfn , enum memmap_context context ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_per_cpu_pageset ( void ) ;

void zone_pcp_update ( struct zone * zone ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) int init_currently_empty_zone ( struct zone * zone , unsigned long zone_start_pfn , unsigned long size , enum memmap_context context ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) early_pfn_to_nid ( unsigned long pfn ) ;

bool __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) early_pfn_in_nid ( unsigned long pfn , int node ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) free_bootmem_with_active_regions ( int nid , unsigned long max_low_pfn ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) work_with_active_regions ( int nid , work_fn_t work_fn , void * data ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sparse_memory_present_with_active_regions ( int nid ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) get_pfn_range_for_nid ( unsigned int nid , unsigned long * start_pfn , unsigned long * end_pfn ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) absent_pages_in_range ( unsigned long start_pfn , unsigned long end_pfn ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) free_area_init_node ( int nid , unsigned long * zones_size , unsigned long node_start_pfn , unsigned long * zholes_size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) add_active_range ( unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) remove_active_range ( unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) remove_all_active_ranges ( void ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) find_min_pfn_with_active_regions ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) free_area_init_nodes ( unsigned long * max_zone_pfn ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) set_dma_reserve ( unsigned long new_dma_reserve ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) free_area_init ( unsigned long * zones_size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) page_alloc_init ( void ) ;

void setup_per_zone_wmarks ( void ) ;

void calculate_zone_inactive_ratio ( struct zone * zone ) ;

int min_free_kbytes_sysctl_handler ( ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

int sysctl_min_unmapped_ratio_sysctl_handler ( ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

int sysctl_min_slab_ratio_sysctl_handler ( ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

int lowmem_reserve_ratio_sysctl_handler ( ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

int percpu_pagelist_fraction_sysctl_handler ( ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) alloc_large_system_hash ( const char * tablename , unsigned long bucketsize , unsigned long numentries , int scale , int flags , unsigned int * _hash_shift , unsigned int * _hash_mask , unsigned long limit ) ;

unsigned long get_pageblock_flags_group ( struct page * page , int start_bitidx , int end_bitidx ) ;

void set_pageblock_flags_group ( struct page * page , unsigned long flags , int start_bitidx , int end_bitidx ) ;

int set_migratetype_isolate ( struct page * page ) ;

void unset_migratetype_isolate ( struct page * page ) ;

void __offline_isolated_pages ( unsigned long start_pfn , unsigned long end_pfn ) ;

int dirty_background_ratio_handler ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int dirty_background_bytes_handler ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int dirty_ratio_handler ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int dirty_bytes_handler ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

void bdi_writeout_inc ( struct backing_dev_info * bdi ) ;

void task_dirty_inc ( struct task_struct * tsk ) ;

int bdi_set_min_ratio ( struct backing_dev_info * bdi , unsigned int min_ratio ) ;

int bdi_set_max_ratio ( struct backing_dev_info * bdi , unsigned max_ratio ) ;

unsigned long determine_dirtyable_memory ( void ) ;

void get_dirty_limits ( unsigned long * pbackground , unsigned long * pdirty , unsigned long * pbdi_dirty , struct backing_dev_info * bdi ) ;

void set_page_dirty_balance ( struct page * page , int page_mkwrite ) ;

void balance_dirty_pages_ratelimited_nr ( struct address_space * mapping , unsigned long nr_pages_dirtied ) ;

void throttle_vm_writeout ( gfp_t gfp_mask ) ;

int dirty_writeback_centisecs_handler ( ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

void laptop_io_completion ( void ) ;

void laptop_sync_completion ( void ) ;

void writeback_set_ratelimit ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) page_writeback_init ( void ) ;

int write_cache_pages ( struct address_space * mapping , struct writeback_control * wbc , writepage_t writepage , void * data ) ;

int generic_writepages ( struct address_space * mapping , struct writeback_control * wbc ) ;

int do_writepages ( struct address_space * mapping , struct writeback_control * wbc ) ;

int write_one_page ( struct page * page , int wait ) ;

int __set_page_dirty_no_writeback ( struct page * page ) ;

void account_page_dirtied ( struct page * page , struct address_space * mapping ) ;

int __set_page_dirty_nobuffers ( struct page * page ) ;

int redirty_page_for_writepage ( struct writeback_control * wbc , struct page * page ) ;

int set_page_dirty ( struct page * page ) ;

int set_page_dirty_lock ( struct page * page ) ;

int clear_page_dirty_for_io ( struct page * page ) ;

int test_clear_page_writeback ( struct page * page ) ;

int test_set_page_writeback ( struct page * page ) ;

int mapping_tagged ( struct address_space * mapping , int tag ) ;

void file_ra_state_init ( struct file_ra_state * ra , struct address_space * mapping ) ;

int read_cache_pages ( struct address_space * mapping , struct list_head * pages , int ( * filler ) ( void * , struct page * ) , void * data ) ;

int force_page_cache_readahead ( struct address_space * mapping , struct file * filp , unsigned long offset , unsigned long nr_to_read ) ;

unsigned long max_sane_readahead ( unsigned long nr ) ;

unsigned long ra_submit ( struct file_ra_state * ra , struct address_space * mapping , struct file * filp ) ;

void page_cache_sync_readahead ( struct address_space * mapping , struct file_ra_state * ra , struct file * filp , unsigned long offset , unsigned long req_size ) ;

void page_cache_async_readahead ( struct address_space * mapping , struct file_ra_state * ra , struct file * filp , struct page * page , unsigned long offset , unsigned long req_size ) ;

void put_page ( struct page * page ) ;

void put_pages_list ( struct list_head * pages ) ;

void rotate_reclaimable_page ( struct page * page ) ;

void activate_page ( struct page * page ) ;

void mark_page_accessed ( struct page * page ) ;

void __lru_cache_add ( struct page * page , enum lru_list lru ) ;

void lru_cache_add_lru ( struct page * page , enum lru_list lru ) ;

void add_page_to_unevictable_list ( struct page * page ) ;

void lru_add_drain ( void ) ;

int lru_add_drain_all ( void ) ;

void release_pages ( struct page * * pages , int nr , int cold ) ;

void __pagevec_release ( struct pagevec * pvec ) ;

void ____pagevec_lru_add ( struct pagevec * pvec , enum lru_list lru ) ;

void pagevec_strip ( struct pagevec * pvec ) ;

unsigned pagevec_lookup ( struct pagevec * pvec , struct address_space * mapping , unsigned long start , unsigned nr_pages ) ;

unsigned pagevec_lookup_tag ( struct pagevec * pvec , struct address_space * mapping , unsigned long * index , int tag , unsigned nr_pages ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) swap_setup ( void ) ;

void do_invalidatepage ( struct page * page , unsigned long offset ) ;

void cancel_dirty_page ( struct page * page , unsigned int account_size ) ;

int truncate_inode_page ( struct address_space * mapping , struct page * page ) ;

int generic_error_remove_page ( struct address_space * mapping , struct page * page ) ;

int invalidate_inode_page ( struct page * page ) ;

void truncate_inode_pages_range ( struct address_space * mapping , loff_t lstart , loff_t lend ) ;

void truncate_inode_pages ( struct address_space * mapping , loff_t lstart ) ;

unsigned long invalidate_mapping_pages ( struct address_space * mapping , unsigned long start , unsigned long end ) ;

int invalidate_inode_pages2_range ( struct address_space * mapping , unsigned long start , unsigned long end ) ;

int invalidate_inode_pages2 ( struct address_space * mapping ) ;

void truncate_pagecache ( struct inode * inode , loff_t old , loff_t new ) ;

int vmtruncate ( struct inode * inode , loff_t offset ) ;

struct scan_control { unsigned long nr_scanned ; unsigned long nr_reclaimed ; gfp_t gfp_mask ; int may_writepage ; int may_unmap ; int may_swap ; int swap_cluster_max ; int swappiness ; int all_unreclaimable ; int order ; struct mem_cgroup * mem_cgroup ; nodemask_t * nodemask ; unsigned long ( * isolate_pages ) ( unsigned long nr , struct list_head * dst , unsigned long * scanned , int order , int mode , struct zone * z , struct mem_cgroup * mem_cont , int active , int file ) ; } ;

void register_shrinker ( struct shrinker * shrinker ) ;

void unregister_shrinker ( struct shrinker * shrinker ) ;

unsigned long shrink_slab ( unsigned long scanned , gfp_t gfp_mask , unsigned long lru_pages ) ;

enum pageout_io { PAGEOUT_IO_ASYNC , PAGEOUT_IO_SYNC , } ;

typedef enum { PAGE_KEEP , PAGE_ACTIVATE , PAGE_SUCCESS , PAGE_CLEAN , } pageout_t ;

int remove_mapping ( struct address_space * mapping , struct page * page ) ;

void putback_lru_page ( struct page * page ) ;

int __isolate_lru_page ( struct page * page , int mode , int file ) ;

int isolate_lru_page ( struct page * page ) ;

unsigned long try_to_free_pages ( struct zonelist * zonelist , int order , gfp_t gfp_mask , nodemask_t * nodemask ) ;

unsigned long mem_cgroup_shrink_node_zone ( struct mem_cgroup * mem , gfp_t gfp_mask , bool noswap , unsigned int swappiness , struct zone * zone , int nid ) ;

unsigned long try_to_free_mem_cgroup_pages ( struct mem_cgroup * mem_cont , gfp_t gfp_mask , bool noswap , unsigned int swappiness ) ;

void wakeup_kswapd ( struct zone * zone , int order ) ;

unsigned long global_reclaimable_pages ( void ) ;

unsigned long zone_reclaimable_pages ( struct zone * zone ) ;

unsigned long shrink_all_memory ( unsigned long nr_pages ) ;

int kswapd_run ( int nid ) ;

int zone_reclaim ( struct zone * zone , gfp_t gfp_mask , unsigned int order ) ;

int page_evictable ( struct page * page , struct vm_area_struct * vma ) ;

void scan_mapping_unevictable_pages ( struct address_space * mapping ) ;

int scan_unevictable_handler ( struct ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

int scan_unevictable_register_node ( struct node * node ) ;

void scan_unevictable_unregister_node ( struct node * node ) ;

struct xattr_handler { char * prefix ; size_t ( * list ) ( struct inode * inode , char * list , size_t list_size , const char * name , size_t name_len ) ; int ( * get ) ( struct inode * inode , const char * name , void * buffer , size_t size ) ; int ( * set ) ( struct inode * inode , const char * name , const void * buffer , size_t size , int flags ) ; } ;

enum fid_type { FILEID_ROOT = 0 , FILEID_INO32_GEN = 1 , FILEID_INO32_GEN_PARENT = 2 , FILEID_BTRFS_WITHOUT_PARENT = 0x4d , FILEID_BTRFS_WITH_PARENT = 0x4e , FILEID_BTRFS_WITH_PARENT_ROOT = 0x4f , FILEID_UDF_WITHOUT_PARENT = 0x51 , FILEID_UDF_WITH_PARENT = 0x52 , } ;

struct fid { union { struct { u32 ino ; u32 gen ; u32 parent_ino ; u32 parent_gen ; } i32 ; struct { u32 block ; u16 partref ; u16 parent_partref ; u32 generation ; u32 parent_block ; u32 parent_generation ; } udf ; __u32 raw [ 0 ] ; } ; } ;

struct export_operations { int ( * encode_fh ) ( struct dentry * de , __u32 * fh , int * max_len , int connectable ) ; struct dentry * ( * fh_to_dentry ) ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type ) ; struct dentry * ( * fh_to_parent ) ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type ) ; int ( * get_name ) ( struct dentry * parent , char * name , struct dentry * child ) ; struct dentry * ( * get_parent ) ( struct dentry * child ) ; } ;
typedef struct { __le16 e_tag ; __le16 e_perm ; __le32 e_id ; } posix_acl_xattr_entry ;

typedef struct { __le32 a_version ; posix_acl_xattr_entry a_entries [ 0 ] ; } posix_acl_xattr_header ;

struct generic_acl_operations { struct posix_acl * ( * getacl ) ( struct inode * , int ) ; void ( * setacl ) ( struct inode * , int , struct posix_acl * ) ; } ;

enum sgp_type { SGP_READ , SGP_CACHE , SGP_DIRTY , SGP_WRITE , } ;

int shmem_unuse ( swp_entry_t entry , struct page * page ) ;

int shmem_lock ( struct file * file , int lock , struct user_struct * user ) ;

int shmem_fill_super ( struct super_block * sb , void * data , int silent ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_tmpfs ( void ) ;

struct file * shmem_file_setup ( const char * name , loff_t size , unsigned long flags ) ;

int shmem_zero_setup ( struct vm_area_struct * vma ) ;

void vma_prio_tree_add ( struct vm_area_struct * vma , struct vm_area_struct * old ) ;

void vma_prio_tree_insert ( struct vm_area_struct * vma , struct prio_tree_root * root ) ;

void vma_prio_tree_remove ( struct vm_area_struct * vma , struct prio_tree_root * root ) ;

struct vm_area_struct * vma_prio_tree_next ( struct vm_area_struct * vma , struct prio_tree_iter * iter ) ;

struct ftrace_raw_kmalloc { struct trace_entry ent ; unsigned long call_site ; const void * ptr ; size_t bytes_req ; size_t bytes_alloc ; gfp_t gfp_flags ; char __data [ 0 ] ; } ;

struct ftrace_raw_kmem_cache_alloc { struct trace_entry ent ; unsigned long call_site ; const void * ptr ; size_t bytes_req ; size_t bytes_alloc ; gfp_t gfp_flags ; char __data [ 0 ] ; } ;

struct ftrace_raw_kmalloc_node { struct trace_entry ent ; unsigned long call_site ; const void * ptr ; size_t bytes_req ; size_t bytes_alloc ; gfp_t gfp_flags ; int node ; char __data [ 0 ] ; } ;

struct ftrace_raw_kmem_cache_alloc_node { struct trace_entry ent ; unsigned long call_site ; const void * ptr ; size_t bytes_req ; size_t bytes_alloc ; gfp_t gfp_flags ; int node ; char __data [ 0 ] ; } ;

struct ftrace_raw_kfree { struct trace_entry ent ; unsigned long call_site ; const void * ptr ; char __data [ 0 ] ; } ;

struct ftrace_raw_kmem_cache_free { struct trace_entry ent ; unsigned long call_site ; const void * ptr ; char __data [ 0 ] ; } ;

struct ftrace_raw_mm_page_free_direct { struct trace_entry ent ; struct page * page ; unsigned int order ; char __data [ 0 ] ; } ;

struct ftrace_raw_mm_pagevec_free { struct trace_entry ent ; struct page * page ; int cold ; char __data [ 0 ] ; } ;

struct ftrace_raw_mm_page_alloc { struct trace_entry ent ; struct page * page ; unsigned int order ; gfp_t gfp_flags ; int migratetype ; char __data [ 0 ] ; } ;

struct ftrace_raw_mm_page_alloc_zone_locked { struct trace_entry ent ; struct page * page ; unsigned int order ; int migratetype ; char __data [ 0 ] ; } ;

struct ftrace_raw_mm_page_pcpu_drain { struct trace_entry ent ; struct page * page ; int order ; int migratetype ; char __data [ 0 ] ; } ;

struct ftrace_raw_mm_page_alloc_extfrag { struct trace_entry ent ; struct page * page ; int alloc_order ; int fallback_order ; int alloc_migratetype ; int fallback_migratetype ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_kmalloc { ; } ;

struct ftrace_data_offsets_kmem_cache_alloc { ; } ;

struct ftrace_data_offsets_kmalloc_node { ; } ;

struct ftrace_data_offsets_kmem_cache_alloc_node { ; } ;

struct ftrace_data_offsets_kfree { ; } ;

struct ftrace_data_offsets_kmem_cache_free { ; } ;

struct ftrace_data_offsets_mm_page_free_direct { ; } ;

struct ftrace_data_offsets_mm_pagevec_free { ; } ;

struct ftrace_data_offsets_mm_page_alloc { ; } ;

struct ftrace_data_offsets_mm_page_alloc_zone_locked { ; } ;

struct ftrace_data_offsets_mm_page_pcpu_drain { ; } ;

struct ftrace_data_offsets_mm_page_alloc_extfrag { ; } ;

char * kstrdup ( const char * s , gfp_t gfp ) ;

char * kstrndup ( const char * s , size_t max , gfp_t gfp ) ;

void * kmemdup ( const void * src , size_t len , gfp_t gfp ) ;

void * memdup_user ( const void * src , size_t len ) ;

void * __krealloc ( const void * p , size_t new_size , gfp_t flags ) ;

void * krealloc ( const void * p , size_t new_size , gfp_t flags ) ;

void kzfree ( const void * p ) ;

char * strndup_user ( const char * s , long n ) ;

int __attribute__ ( ( weak ) ) get_user_pages_fast ( unsigned long start , int nr_pages , int write , struct page * * pages ) ;
long sys_mmap_pgoff ( unsigned long addr , unsigned long len , unsigned long prot , unsigned long flags , unsigned long fd , unsigned long pgoff ) ;

struct pglist_data * first_online_pgdat ( void ) ;

struct pglist_data * next_online_pgdat ( struct pglist_data * pgdat ) ;

struct zone * next_zone ( struct zone * zone ) ;

struct zoneref * next_zones_zonelist ( struct zoneref * z , enum zone_type highest_zoneidx , nodemask_t * nodes , struct zone * * zone ) ;

void all_vm_events ( unsigned long * ret ) ;

void vm_events_fold_cpu ( int cpu ) ;

void __mod_zone_page_state ( struct zone * zone , enum zone_stat_item item , int delta ) ;

void mod_zone_page_state ( struct zone * zone , enum zone_stat_item item , int delta ) ;

void __inc_zone_state ( struct zone * zone , enum zone_stat_item item ) ;

void __inc_zone_page_state ( struct page * page , enum zone_stat_item item ) ;

void __dec_zone_state ( struct zone * zone , enum zone_stat_item item ) ;

void __dec_zone_page_state ( struct page * page , enum zone_stat_item item ) ;

void inc_zone_state ( struct zone * zone , enum zone_stat_item item ) ;

void inc_zone_page_state ( struct page * page , enum zone_stat_item item ) ;

void dec_zone_page_state ( struct page * page , enum zone_stat_item item ) ;

void refresh_cpu_vm_stats ( int cpu ) ;

void zone_statistics ( struct zone * preferred_zone , struct zone * z ) ;

void default_unplug_io_fn ( struct backing_dev_info * bdi , struct page * page ) ;

int bdi_has_dirty_io ( struct backing_dev_info * bdi ) ;

int bdi_register ( struct backing_dev_info * bdi , struct device * parent , const char * fmt , ... ) ;

int bdi_register_dev ( struct backing_dev_info * bdi , dev_t dev ) ;

void bdi_unregister ( struct backing_dev_info * bdi ) ;

int bdi_init ( struct backing_dev_info * bdi ) ;

void bdi_destroy ( struct backing_dev_info * bdi ) ;

void clear_bdi_congested ( struct backing_dev_info * bdi , int sync ) ;

void set_bdi_congested ( struct backing_dev_info * bdi , int sync ) ;

long congestion_wait ( int sync , long timeout ) ;

int start_isolate_page_range ( unsigned long start_pfn , unsigned long end_pfn ) ;

int undo_isolate_page_range ( unsigned long start_pfn , unsigned long end_pfn ) ;

int test_pages_isolated ( unsigned long start_pfn , unsigned long end_pfn ) ;

void mminit_verify_zonelist ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mminit_verify_pageflags_layout ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) mminit_verify_page_links ( struct page * page , enum zone_type zone , unsigned long nid , unsigned long pfn ) ;

void use_mm ( struct mm_struct * mm ) ;

void unuse_mm ( struct mm_struct * mm ) ;

long sys_remap_file_pages ( unsigned long start , unsigned long size , unsigned long prot , unsigned long pgoff , unsigned long flags ) ;

long sys_madvise ( unsigned long start , size_t len_in , int behavior ) ;

void pgd_clear_bad ( pgd_t * pgd ) ;

void pud_clear_bad ( pud_t * pud ) ;

void pmd_clear_bad ( pmd_t * pmd ) ;

void free_pgd_range ( struct mmu_gather * tlb , unsigned long addr , unsigned long end , unsigned long floor , unsigned long ceiling ) ;

void free_pgtables ( struct mmu_gather * tlb , struct vm_area_struct * vma , unsigned long floor , unsigned long ceiling ) ;

int __pte_alloc ( struct mm_struct * mm , pmd_t * pmd , unsigned long address ) ;

int __pte_alloc_kernel ( pmd_t * pmd , unsigned long address ) ;

struct page * vm_normal_page ( struct vm_area_struct * vma , unsigned long addr , pte_t pte ) ;

int copy_page_range ( struct mm_struct * dst_mm , struct mm_struct * src_mm , struct vm_area_struct * vma ) ;

unsigned long unmap_vmas ( struct mmu_gather * * tlbp , struct vm_area_struct * vma , unsigned long start_addr , unsigned long end_addr , unsigned long * nr_accounted , struct zap_details * details ) ;

unsigned long zap_page_range ( struct vm_area_struct * vma , unsigned long address , unsigned long size , struct zap_details * details ) ;

int zap_vma_ptes ( struct vm_area_struct * vma , unsigned long address , unsigned long size ) ;

struct page * follow_page ( struct vm_area_struct * vma , unsigned long address , unsigned int flags ) ;

int __get_user_pages ( struct task_struct * tsk , struct mm_struct * mm , unsigned long start , int nr_pages , unsigned int gup_flags , struct page * * pages , struct vm_area_struct * * vmas ) ;

int get_user_pages ( struct task_struct * tsk , struct mm_struct * mm , unsigned long start , int nr_pages , int write , int force , struct page * * pages , struct vm_area_struct * * vmas ) ;

struct page * get_dump_page ( unsigned long addr ) ;

pte_t * get_locked_pte ( struct mm_struct * mm , unsigned long addr , spinlock_t * * ptl ) ;

int vm_insert_page ( struct vm_area_struct * vma , unsigned long addr , struct page * page ) ;

int vm_insert_pfn ( struct vm_area_struct * vma , unsigned long addr , unsigned long pfn ) ;

int vm_insert_mixed ( struct vm_area_struct * vma , unsigned long addr , unsigned long pfn ) ;

int remap_pfn_range ( struct vm_area_struct * vma , unsigned long addr , unsigned long pfn , unsigned long size , pgprot_t prot ) ;

int apply_to_page_range ( struct mm_struct * mm , unsigned long addr , unsigned long size , pte_fn_t fn , void * data ) ;

void unmap_mapping_range ( struct address_space * mapping , loff_t const holebegin , loff_t const holelen , int even_cows ) ;

int vmtruncate_range ( struct inode * inode , loff_t offset , loff_t end ) ;

int handle_mm_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , unsigned int flags ) ;

int __pud_alloc ( struct mm_struct * mm , pgd_t * pgd , unsigned long address ) ;

int __pmd_alloc ( struct mm_struct * mm , pud_t * pud , unsigned long address ) ;

int make_pages_present ( unsigned long addr , unsigned long end ) ;

int follow_pfn ( struct vm_area_struct * vma , unsigned long address , unsigned long * pfn ) ;

int follow_phys ( struct vm_area_struct * vma , unsigned long address , unsigned int flags , unsigned long * prot , resource_size_t * phys ) ;

int generic_access_phys ( struct vm_area_struct * vma , unsigned long addr , void * buf , int len , int write ) ;

int access_process_vm ( struct task_struct * tsk , unsigned long addr , void * buf , int len , int write ) ;

void print_vma_addr ( char * prefix , unsigned long ip ) ;

long sys_mincore ( unsigned long start , size_t len , unsigned char * vec ) ;

int can_do_mlock ( void ) ;

void __clear_page_mlock ( struct page * page ) ;

void mlock_vma_page ( struct page * page ) ;

void munlock_vma_page ( struct page * page ) ;

long mlock_vma_pages_range ( struct vm_area_struct * vma , unsigned long start , unsigned long end ) ;

void munlock_vma_pages_range ( struct vm_area_struct * vma , unsigned long start , unsigned long end ) ;

long sys_mlock ( unsigned long start , size_t len ) ;

long sys_munlock ( unsigned long start , size_t len ) ;

long sys_mlockall ( int flags ) ;

long sys_munlockall ( void ) ;

int user_shm_lock ( size_t size , struct user_struct * user ) ;

void user_shm_unlock ( size_t size , struct user_struct * user ) ;

int account_locked_memory ( struct mm_struct * mm , struct rlimit * rlim , size_t size ) ;

void refund_locked_memory ( struct mm_struct * mm , size_t size ) ;

pgprot_t vm_get_page_prot ( unsigned long vm_flags ) ;

int __vm_enough_memory ( struct mm_struct * mm , long pages , int cap_sys_admin ) ;

void unlink_file_vma ( struct vm_area_struct * vma ) ;

long sys_brk ( unsigned long brk ) ;

void __vma_link_rb ( struct mm_struct * mm , struct vm_area_struct * vma , struct rb_node * * rb_link , struct rb_node * rb_parent ) ;

void vma_adjust ( struct vm_area_struct * vma , unsigned long start , unsigned long end , unsigned long pgoff , struct vm_area_struct * insert ) ;

struct vm_area_struct * vma_merge ( struct mm_struct * mm , struct vm_area_struct * prev , unsigned long addr , unsigned long end , unsigned long vm_flags , struct anon_vma * anon_vma , struct file * file , unsigned long pgoff , struct mempolicy * policy ) ;

struct anon_vma * find_mergeable_anon_vma ( struct vm_area_struct * vma ) ;

void vm_stat_account ( struct mm_struct * mm , unsigned long flags , struct file * file , long pages ) ;

unsigned long do_mmap_pgoff ( struct file * file , unsigned long addr , unsigned long len , unsigned long prot , unsigned long flags , unsigned long pgoff ) ;

int vma_wants_writenotify ( struct vm_area_struct * vma ) ;

unsigned long mmap_region ( struct file * file , unsigned long addr , unsigned long len , unsigned long flags , unsigned int vm_flags , unsigned long pgoff ) ;

void arch_unmap_area ( struct mm_struct * mm , unsigned long addr ) ;

void arch_unmap_area_topdown ( struct mm_struct * mm , unsigned long addr ) ;

unsigned long get_unmapped_area_prot ( struct file * file , unsigned long addr , unsigned long len , unsigned long pgoff , unsigned long flags , int exec ) ;

unsigned long arch_get_unmapped_exec_area ( struct file * filp , unsigned long addr0 , unsigned long len0 , unsigned long pgoff , unsigned long flags ) ;

struct vm_area_struct * find_vma ( struct mm_struct * mm , unsigned long addr ) ;

struct vm_area_struct * find_vma_prev ( struct mm_struct * mm , unsigned long addr , struct vm_area_struct * * pprev ) ;

int expand_stack_downwards ( struct vm_area_struct * vma , unsigned long address ) ;

int expand_stack ( struct vm_area_struct * vma , unsigned long address ) ;

struct vm_area_struct * find_extend_vma ( struct mm_struct * mm , unsigned long addr ) ;

int split_vma ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long addr , int new_below ) ;

int do_munmap ( struct mm_struct * mm , unsigned long start , size_t len ) ;

long sys_munmap ( unsigned long addr , size_t len ) ;

unsigned long do_brk ( unsigned long addr , unsigned long len ) ;

void exit_mmap ( struct mm_struct * mm ) ;

int insert_vm_struct ( struct mm_struct * mm , struct vm_area_struct * vma ) ;

struct vm_area_struct * copy_vma ( struct vm_area_struct * * vmap , unsigned long addr , unsigned long len , unsigned long pgoff ) ;

int may_expand_vm ( struct mm_struct * mm , unsigned long npages ) ;

int install_special_mapping ( struct mm_struct * mm , unsigned long addr , unsigned long len , unsigned long vm_flags , struct page * * pages ) ;

int mm_take_all_locks ( struct mm_struct * mm ) ;

void mm_drop_all_locks ( struct mm_struct * mm ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mmap_init ( void ) ;

int mprotect_fixup ( struct vm_area_struct * vma , struct vm_area_struct * * pprev , unsigned long start , unsigned long end , unsigned long newflags ) ;

long sys_mprotect ( unsigned long start , size_t len , unsigned long prot ) ;

unsigned long move_page_tables ( struct vm_area_struct * vma , unsigned long old_addr , struct vm_area_struct * new_vma , unsigned long new_addr , unsigned long len ) ;

unsigned long do_mremap ( unsigned long addr , unsigned long old_len , unsigned long new_len , unsigned long flags , unsigned long new_addr ) ;

long sys_mremap ( unsigned long addr , unsigned long old_len , unsigned long new_len , unsigned long flags , unsigned long new_addr ) ;

long sys_msync ( unsigned long start , size_t len , int flags ) ;

int anon_vma_prepare ( struct vm_area_struct * vma ) ;

void __anon_vma_merge ( struct vm_area_struct * vma , struct vm_area_struct * next ) ;

void __anon_vma_link ( struct vm_area_struct * vma ) ;

void anon_vma_link ( struct vm_area_struct * vma ) ;

void anon_vma_unlink ( struct vm_area_struct * vma ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) anon_vma_init ( void ) ;

struct anon_vma * page_lock_anon_vma ( struct page * page ) ;

void page_unlock_anon_vma ( struct anon_vma * anon_vma ) ;

unsigned long page_address_in_vma ( struct page * page , struct vm_area_struct * vma ) ;

pte_t * page_check_address ( struct page * page , struct mm_struct * mm , unsigned long address , spinlock_t * * ptlp , int sync ) ;

int page_mapped_in_vma ( struct page * page , struct vm_area_struct * vma ) ;

int page_referenced ( struct page * page , int is_locked , struct mem_cgroup * mem_cont , unsigned long * vm_flags ) ;

int page_mkclean ( struct page * page ) ;

void page_add_anon_rmap ( struct page * page , struct vm_area_struct * vma , unsigned long address ) ;

void page_add_new_anon_rmap ( struct page * page , struct vm_area_struct * vma , unsigned long address ) ;

void page_add_file_rmap ( struct page * page ) ;

void page_remove_rmap ( struct page * page ) ;

int try_to_unmap ( struct page * page , enum ttu_flags flags ) ;

int try_to_munlock ( struct page * page ) ;

int is_vmalloc_or_module_addr ( const void * x ) ;

struct page * vmalloc_to_page ( const void * vmalloc_addr ) ;

unsigned long vmalloc_to_pfn ( const void * vmalloc_addr ) ;

struct vmap_area { unsigned long va_start ; unsigned long va_end ; unsigned long flags ; struct rb_node rb_node ; struct list_head list ; struct list_head purge_list ; void * private ; struct rcu_head rcu_head ; } ;

struct vmap_block_queue { spinlock_t lock ; struct list_head free ; } ;

struct vmap_block { spinlock_t lock ; struct vmap_area * va ; struct vmap_block_queue * vbq ; unsigned long free , dirty ; unsigned long alloc_map [ ( ( ( ( ( 1024 ) < ( ( ( ( 64 * 2 ) ) > ( ( ( 128UL * 1024 * 1024 * 1024 ) / ( ( 1UL ) << 12 ) ) / 64 / 16 ) ? ( ( 64 * 2 ) ) : ( ( ( 128UL * 1024 * 1024 * 1024 ) / ( ( 1UL ) << 12 ) ) / 64 / 16 ) ) ) ? ( 1024 ) : ( ( ( ( 64 * 2 ) ) > ( ( ( 128UL * 1024 * 1024 * 1024 ) / ( ( 1UL ) << 12 ) ) / 64 / 16 ) ? ( ( 64 * 2 ) ) : ( ( ( 128UL * 1024 * 1024 * 1024 ) / ( ( 1UL ) << 12 ) ) / 64 / 16 ) ) ) ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long dirty_map [ ( ( ( ( ( 1024 ) < ( ( ( ( 64 * 2 ) ) > ( ( ( 128UL * 1024 * 1024 * 1024 ) / ( ( 1UL ) << 12 ) ) / 64 / 16 ) ? ( ( 64 * 2 ) ) : ( ( ( 128UL * 1024 * 1024 * 1024 ) / ( ( 1UL ) << 12 ) ) / 64 / 16 ) ) ) ? ( 1024 ) : ( ( ( ( 64 * 2 ) ) > ( ( ( 128UL * 1024 * 1024 * 1024 ) / ( ( 1UL ) << 12 ) ) / 64 / 16 ) ? ( ( 64 * 2 ) ) : ( ( ( 128UL * 1024 * 1024 * 1024 ) / ( ( 1UL ) << 12 ) ) / 64 / 16 ) ) ) ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; struct list_head free_list ; struct rcu_head rcu_head ; struct list_head purge ; } ;

void vm_unmap_aliases ( void ) ;

void vm_unmap_ram ( const void * mem , unsigned int count ) ;

void * vm_map_ram ( struct page * * pages , unsigned int count , int node , pgprot_t prot ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) vm_area_register_early ( struct vm_struct * vm , size_t align ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) vmalloc_init ( void ) ;

int map_kernel_range_noflush ( unsigned long addr , unsigned long size , pgprot_t prot , struct page * * pages ) ;

void unmap_kernel_range_noflush ( unsigned long addr , unsigned long size ) ;

void unmap_kernel_range ( unsigned long addr , unsigned long size ) ;

int map_vm_area ( struct vm_struct * area , pgprot_t prot , struct page * * * pages ) ;

struct vm_struct * __get_vm_area ( unsigned long size , unsigned long flags , unsigned long start , unsigned long end ) ;

struct vm_struct * __get_vm_area_caller ( unsigned long size , unsigned long flags , unsigned long start , unsigned long end , void * caller ) ;

struct vm_struct * get_vm_area ( unsigned long size , unsigned long flags ) ;

struct vm_struct * get_vm_area_caller ( unsigned long size , unsigned long flags , void * caller ) ;

struct vm_struct * get_vm_area_node ( unsigned long size , unsigned long flags , int node , gfp_t gfp_mask ) ;

struct vm_struct * remove_vm_area ( const void * addr ) ;

void vfree ( const void * addr ) ;

void vunmap ( const void * addr ) ;

void * vmap ( struct page * * pages , unsigned int count , unsigned long flags , pgprot_t prot ) ;

void * __vmalloc_area ( struct vm_struct * area , gfp_t gfp_mask , pgprot_t prot ) ;

void * __vmalloc ( unsigned long size , gfp_t gfp_mask , pgprot_t prot ) ;

void * vmalloc ( unsigned long size ) ;

void * vmalloc_user ( unsigned long size ) ;

void * vmalloc_node ( unsigned long size , int node ) ;

void * vmalloc_exec ( unsigned long size ) ;

void * vmalloc_32 ( unsigned long size ) ;

void * vmalloc_32_user ( unsigned long size ) ;

long vread ( char * buf , char * addr , unsigned long count ) ;

long vwrite ( char * buf , char * addr , unsigned long count ) ;

int remap_vmalloc_range ( struct vm_area_struct * vma , void * addr , unsigned long pgoff ) ;

void __attribute__ ( ( weak ) ) vmalloc_sync_all ( void ) ;
struct vm_struct * alloc_vm_area ( size_t size ) ;

void free_vm_area ( struct vm_struct * area ) ;

struct vm_struct * * pcpu_get_vm_areas ( const unsigned long * offsets , const size_t * sizes , int nr_vms , size_t align , gfp_t gfp_mask ) ;

void pcpu_free_vm_areas ( struct vm_struct * * vms , int nr_vms ) ;

int walk_page_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) ;

int init_emergency_isa_pool ( void ) ;

void blk_queue_bounce ( struct request_queue * q , struct bio * * bio_orig ) ;

void end_swap_bio_read ( struct bio * bio , int err ) ;

int swap_writepage ( struct page * page , struct writeback_control * wbc ) ;

int swap_readpage ( struct page * page ) ;

void show_swap_cache_info ( void ) ;

int add_to_swap_cache ( struct page * page , swp_entry_t entry , gfp_t gfp_mask ) ;

void __delete_from_swap_cache ( struct page * page ) ;

int add_to_swap ( struct page * page ) ;

void delete_from_swap_cache ( struct page * page ) ;

void free_page_and_swap_cache ( struct page * page ) ;

void free_pages_and_swap_cache ( struct page * * pages , int nr ) ;

struct page * lookup_swap_cache ( swp_entry_t entry ) ;

struct page * read_swap_cache_async ( swp_entry_t entry , gfp_t gfp_mask , struct vm_area_struct * vma , unsigned long addr ) ;

struct page * swapin_readahead ( swp_entry_t entry , gfp_t gfp_mask , struct vm_area_struct * vma , unsigned long addr ) ;

enum { SWAP_MAP = 0 , SWAP_CACHE , } ;
void swap_unplug_io_fn ( struct backing_dev_info * unused_bdi , struct page * page ) ;

swp_entry_t get_swap_page ( void ) ;

swp_entry_t get_swap_page_of_type ( int type ) ;

void swap_free ( swp_entry_t entry ) ;

void swapcache_free ( swp_entry_t entry , struct page * page ) ;

int reuse_swap_page ( struct page * page ) ;

int try_to_free_swap ( struct page * page ) ;

int free_swap_and_cache ( swp_entry_t entry ) ;

int swap_type_of ( dev_t device , sector_t offset , struct block_device * * bdev_p ) ;

unsigned int count_swap_pages ( int type , int free ) ;

sector_t map_swap_page ( struct swap_info_struct * sis , unsigned long offset ) ;

sector_t swapdev_block ( int swap_type , unsigned long offset ) ;

long sys_swapoff ( const char * specialfile ) ;

long sys_swapon ( const char * specialfile , int swap_flags ) ;

void si_swapinfo ( struct sysinfo * val ) ;

void swap_duplicate ( swp_entry_t entry ) ;

int swapcache_prepare ( swp_entry_t entry ) ;

struct swap_info_struct * get_swap_info_struct ( unsigned type ) ;

void set_notify_swap_entry_free ( unsigned type , void ( * fn ) ( unsigned long ) ) ;

int valid_swaphandles ( swp_entry_t entry , unsigned long * offset ) ;

void grab_swap_token ( struct mm_struct * mm ) ;

void __put_swap_token ( struct mm_struct * mm ) ;

struct dma_pool { struct list_head page_list ; spinlock_t lock ; size_t size ; struct device * dev ; size_t allocation ; size_t boundary ; char name [ 32 ] ; wait_queue_head_t waitq ; struct list_head pools ; } ;

struct dma_page { struct list_head page_list ; void * vaddr ; dma_addr_t dma ; unsigned int in_use ; unsigned int offset ; } ;

struct dma_pool * dma_pool_create ( const char * name , struct device * dev , size_t size , size_t align , size_t boundary ) ;

void dma_pool_destroy ( struct dma_pool * pool ) ;

void * dma_pool_alloc ( struct dma_pool * pool , gfp_t mem_flags , dma_addr_t * handle ) ;

void dma_pool_free ( struct dma_pool * pool , void * vaddr , dma_addr_t dma ) ;

struct dma_pool * dmam_pool_create ( const char * name , struct device * dev , size_t size , size_t align , size_t allocation ) ;

void dmam_pool_destroy ( struct dma_pool * pool ) ;

struct file_region { struct list_head link ; long from ; long to ; } ;

unsigned long vma_kernel_pagesize ( struct vm_area_struct * vma ) ;

unsigned long vma_mmu_pagesize ( struct vm_area_struct * vma ) ;

struct resv_map { struct kref refs ; struct list_head regions ; } ;

void reset_vma_resv_huge_pages ( struct vm_area_struct * vma ) ;

struct hstate * size_to_hstate ( unsigned long size ) ;

int PageHuge ( struct page * page ) ;

int __attribute__ ( ( weak ) ) alloc_bootmem_huge_page ( struct hstate * h ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) hugetlb_add_hstate ( unsigned order ) ;

int hugetlb_sysctl_handler ( struct ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

int hugetlb_treat_movable_handler ( struct ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

int hugetlb_overcommit_handler ( struct ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

void hugetlb_report_meminfo ( struct seq_file * m ) ;

int hugetlb_report_node_meminfo ( int nid , char * buf ) ;

unsigned long hugetlb_total_pages ( void ) ;

int copy_hugetlb_page_range ( struct mm_struct * dst , struct mm_struct * src , struct vm_area_struct * vma ) ;

void __unmap_hugepage_range ( struct vm_area_struct * vma , unsigned long start , unsigned long end , struct page * ref_page ) ;

void unmap_hugepage_range ( struct vm_area_struct * vma , unsigned long start , unsigned long end , struct page * ref_page ) ;

int hugetlb_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , unsigned int flags ) ;

__attribute__ ( ( weak ) ) struct page * follow_huge_pud ( struct mm_struct * mm , unsigned long address , pud_t * pud , int write ) ;
int follow_hugetlb_page ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * * pages , struct vm_area_struct * * vmas , unsigned long * position , int * length , int i , unsigned int flags ) ;

void hugetlb_change_protection ( struct vm_area_struct * vma , unsigned long address , unsigned long end , pgprot_t newprot ) ;

int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , int acctflag ) ;

void hugetlb_unreserve_pages ( struct inode * inode , long offset , long freed ) ;


void __mpol_put ( struct mempolicy * p ) ;

void mpol_rebind_task ( struct task_struct * tsk , const nodemask_t * new ) ;

void mpol_rebind_mm ( struct mm_struct * mm , nodemask_t * new ) ;

void mpol_fix_fork_child_flag ( struct task_struct * p ) ;

int do_migrate_pages ( struct mm_struct * mm , const nodemask_t * from_nodes , const nodemask_t * to_nodes , int flags ) ;

long sys_mbind ( unsigned long start , unsigned long len , unsigned long mode , unsigned long * nmask , unsigned long maxnode , unsigned flags ) ;

long sys_set_mempolicy ( int mode , unsigned long * nmask , unsigned long maxnode ) ;

long sys_migrate_pages ( pid_t pid , unsigned long maxnode , const unsigned long * old_nodes , const unsigned long * new_nodes ) ;

long sys_get_mempolicy ( int * policy , unsigned long * nmask , unsigned long maxnode , unsigned long addr , unsigned long flags ) ;

long compat_sys_get_mempolicy ( int * policy , compat_ulong_t * nmask , compat_ulong_t maxnode , compat_ulong_t addr , compat_ulong_t flags ) ;

long compat_sys_set_mempolicy ( int mode , compat_ulong_t * nmask , compat_ulong_t maxnode ) ;

long compat_sys_mbind ( compat_ulong_t start , compat_ulong_t len , compat_ulong_t mode , compat_ulong_t * nmask , compat_ulong_t maxnode , compat_ulong_t flags ) ;

unsigned slab_node ( struct mempolicy * policy ) ;

struct zonelist * huge_zonelist ( struct vm_area_struct * vma , unsigned long addr , gfp_t gfp_flags , struct mempolicy * * mpol , nodemask_t * * nodemask ) ;

struct page * alloc_page_vma ( gfp_t gfp , struct vm_area_struct * vma , unsigned long addr ) ;

struct page * alloc_pages_current ( gfp_t gfp , unsigned order ) ;

struct mempolicy * __mpol_dup ( struct mempolicy * old ) ;

struct mempolicy * __mpol_cond_copy ( struct mempolicy * tompol , struct mempolicy * frompol ) ;

int __mpol_equal ( struct mempolicy * a , struct mempolicy * b ) ;

struct mempolicy * mpol_shared_policy_lookup ( struct shared_policy * sp , unsigned long idx ) ;

void mpol_shared_policy_init ( struct shared_policy * sp , struct mempolicy * mpol ) ;

int mpol_set_shared_policy ( struct shared_policy * info , struct vm_area_struct * vma , struct mempolicy * npol ) ;

void mpol_free_shared_policy ( struct shared_policy * p ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) numa_policy_init ( void ) ;

void numa_default_policy ( void ) ;

int mpol_parse_str ( char * str , struct mempolicy * * mpol , int no_context ) ;

int mpol_to_str ( char * buffer , int maxlen , struct mempolicy * pol , int no_context ) ;

struct numa_maps { unsigned long pages ; unsigned long anon ; unsigned long active ; unsigned long writeback ; unsigned long mapcount_max ; unsigned long dirty ; unsigned long swapcache ; unsigned long node [ ( 1 << 6 ) ] ; } ;

int show_numa_map ( struct seq_file * m , void * v ) ;

int __section_nr ( struct mem_section * ms ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) mminit_validate_memmodel_limits ( unsigned long * start_pfn , unsigned long * end_pfn ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) memory_present ( int nid , unsigned long start , unsigned long end ) ;

unsigned long __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) node_memmap_size_bytes ( int nid , unsigned long start_pfn , unsigned long end_pfn ) ;

struct page * sparse_decode_mem_map ( unsigned long coded_mem_map , unsigned long pnum ) ;

unsigned long usemap_size ( void ) ;

void __attribute__ ( ( weak ) ) __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_populate_print_last ( void ) ;
void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sparse_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) sparse_add_one_section ( struct zone * zone , unsigned long start_pfn , int nr_pages ) ;

void sparse_remove_one_section ( struct zone * zone , struct mem_section * ms ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_alloc_block ( unsigned long size , int node ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_verify ( pte_t * pte , int node , unsigned long start , unsigned long end ) ;

pte_t * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_pte_populate ( pmd_t * pmd , unsigned long addr , int node ) ;

pmd_t * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_pmd_populate ( pud_t * pud , unsigned long addr , int node ) ;

pud_t * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_pud_populate ( pgd_t * pgd , unsigned long addr , int node ) ;

pgd_t * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_pgd_populate ( unsigned long addr , int node ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) vmemmap_populate_basepages ( struct page * start_page , unsigned long size , int node ) ;

struct page * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) sparse_mem_map_populate ( unsigned long pnum , int nid ) ;

int shmem_acl_init ( struct inode * inode , struct inode * dir ) ;

int shmem_check_acl ( struct inode * inode , int mask ) ;

void __mmu_notifier_release ( struct mm_struct * mm ) ;

int __mmu_notifier_clear_flush_young ( struct mm_struct * mm , unsigned long address ) ;

void __mmu_notifier_change_pte ( struct mm_struct * mm , unsigned long address , pte_t pte ) ;

void __mmu_notifier_invalidate_page ( struct mm_struct * mm , unsigned long address ) ;

void __mmu_notifier_invalidate_range_start ( struct mm_struct * mm , unsigned long start , unsigned long end ) ;

void __mmu_notifier_invalidate_range_end ( struct mm_struct * mm , unsigned long start , unsigned long end ) ;

int mmu_notifier_register ( struct mmu_notifier * mn , struct mm_struct * mm ) ;

int __mmu_notifier_register ( struct mmu_notifier * mn , struct mm_struct * mm ) ;

void __mmu_notifier_mm_destroy ( struct mm_struct * mm ) ;

void mmu_notifier_unregister ( struct mmu_notifier * mn , struct mm_struct * mm ) ;

struct mm_slot { struct hlist_node link ; struct list_head mm_list ; struct list_head rmap_list ; struct mm_struct * mm ; } ;

struct ksm_scan { struct mm_slot * mm_slot ; unsigned long address ; struct rmap_item * rmap_item ; unsigned long seqnr ; } ;

struct rmap_item { struct list_head link ; struct mm_struct * mm ; unsigned long address ; union { unsigned int oldchecksum ; struct rmap_item * next ; } ; union { struct rb_node node ; struct rmap_item * prev ; } ; } ;

int ksm_madvise ( struct vm_area_struct * vma , unsigned long start , unsigned long end , int advice , unsigned long * vm_flags ) ;

int __ksm_enter ( struct mm_struct * mm ) ;

void __ksm_exit ( struct mm_struct * mm ) ;

struct track { unsigned long addr ; int cpu ; int pid ; unsigned long when ; } ;

enum track_item { TRACK_ALLOC , TRACK_FREE } ;

int slab_is_available ( void ) ;

void * kmem_cache_alloc ( struct kmem_cache * s , gfp_t gfpflags ) ;

void * kmem_cache_alloc_node ( struct kmem_cache * s , gfp_t gfpflags , int node ) ;

void kmem_cache_free ( struct kmem_cache * s , void * x ) ;

int kmem_ptr_validate ( struct kmem_cache * s , const void * object ) ;

unsigned int kmem_cache_size ( struct kmem_cache * s ) ;

const char * kmem_cache_name ( struct kmem_cache * s ) ;

void kmem_cache_destroy ( struct kmem_cache * s ) ;

void * __kmalloc ( size_t size , gfp_t flags ) ;

void * __kmalloc_node ( size_t size , gfp_t flags , int node ) ;

size_t ksize ( const void * object ) ;

void kfree ( const void * x ) ;

int kmem_cache_shrink ( struct kmem_cache * s ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) kmem_cache_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) kmem_cache_init_late ( void ) ;

struct kmem_cache * kmem_cache_create ( const char * name , size_t size , size_t align , unsigned long flags , void ( * ctor ) ( void * ) ) ;

void * __kmalloc_track_caller ( size_t size , gfp_t gfpflags , unsigned long caller ) ;

void * __kmalloc_node_track_caller ( size_t size , gfp_t gfpflags , int node , unsigned long caller ) ;

struct location { unsigned long count ; unsigned long addr ; long long sum_time ; long min_time ; long max_time ; long min_pid ; long max_pid ; unsigned long cpus [ ( ( ( 64 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; nodemask_t nodes ; } ;

struct loc_track { unsigned long max ; unsigned long count ; struct location * loc ; } ;

enum slab_stat_type { SL_ALL , SL_PARTIAL , SL_CPU , SL_OBJECTS , SL_TOTAL } ;

struct slab_attribute { struct attribute attr ; ssize_t ( * show ) ( struct kmem_cache * s , char * buf ) ; ssize_t ( * store ) ( struct kmem_cache * s , const char * x , size_t count ) ; } ;

struct saved_alias { struct kmem_cache * s ; const char * name ; struct saved_alias * next ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) __add_pages ( int nid , struct zone * zone , unsigned long phys_start_pfn , unsigned long nr_pages ) ;

int __remove_pages ( struct zone * zone , unsigned long phys_start_pfn , unsigned long nr_pages ) ;

void online_page ( struct page * page ) ;

int online_pages ( unsigned long pfn , unsigned long nr_pages ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) add_memory ( int nid , u64 start , u64 size ) ;

int is_mem_section_removable ( unsigned long start_pfn , unsigned long nr_pages ) ;

int scan_lru_pages ( unsigned long start , unsigned long end ) ;

int offline_pages ( unsigned long start_pfn , unsigned long end_pfn , unsigned long timeout ) ;

int remove_memory ( u64 start , u64 size ) ;

int migrate_prep ( void ) ;

int putback_lru_pages ( struct list_head * l ) ;

void migration_entry_wait ( struct mm_struct * mm , pmd_t * pmd , unsigned long address ) ;

int fail_migrate_page ( struct address_space * mapping , struct page * newpage , struct page * page ) ;

int migrate_page ( struct address_space * mapping , struct page * newpage , struct page * page ) ;

int buffer_migrate_page ( struct address_space * mapping , struct page * newpage , struct page * page ) ;

int migrate_pages ( struct list_head * from , new_page_t get_new_page , unsigned long private ) ;

struct page_to_node { unsigned long addr ; struct page * page ; int node ; int status ; } ;

long sys_move_pages ( pid_t pid , unsigned long nr_pages , const void * * pages , const int * nodes , int * status , int flags ) ;

int migrate_vmas ( struct mm_struct * mm , const nodemask_t * to , const nodemask_t * from , unsigned long flags ) ;

struct pcpu_chunk { struct list_head list ; int free_size ; int contig_hint ; void * base_addr ; int map_used ; int map_alloc ; int * map ; struct vm_struct * * vms ; bool immutable ; unsigned long populated [ ] ; } ;

void * __alloc_percpu ( size_t size , size_t align ) ;

void * __alloc_reserved_percpu ( size_t size , size_t align ) ;

void free_percpu ( void * ptr ) ;

struct pcpu_alloc_info * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pcpu_alloc_alloc_info ( int nr_groups , int nr_units ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pcpu_free_alloc_info ( struct pcpu_alloc_info * ai ) ;

struct pcpu_alloc_info * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pcpu_build_alloc_info ( size_t reserved_size , ssize_t dyn_size , size_t atom_size , pcpu_fc_cpu_distance_fn_t cpu_distance_fn ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pcpu_setup_first_chunk ( const struct pcpu_alloc_info * ai , void * base_addr ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pcpu_embed_first_chunk ( size_t reserved_size , ssize_t dyn_size , size_t atom_size , pcpu_fc_cpu_distance_fn_t cpu_distance_fn , pcpu_fc_alloc_fn_t alloc_fn , pcpu_fc_free_fn_t free_fn ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pcpu_page_first_chunk ( size_t reserved_size , pcpu_fc_alloc_fn_t alloc_fn , pcpu_fc_free_fn_t free_fn , pcpu_fc_populate_pte_fn_t populate_pte_fn ) ;

enum mem_cgroup_stat_index { MEM_CGROUP_STAT_CACHE , MEM_CGROUP_STAT_RSS , MEM_CGROUP_STAT_MAPPED_FILE , MEM_CGROUP_STAT_PGPGIN_COUNT , MEM_CGROUP_STAT_PGPGOUT_COUNT , MEM_CGROUP_STAT_EVENTS , MEM_CGROUP_STAT_SWAPOUT , MEM_CGROUP_STAT_NSTATS , } ;

struct mem_cgroup_stat_cpu { s64 count [ MEM_CGROUP_STAT_NSTATS ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct mem_cgroup_stat { struct mem_cgroup_stat_cpu cpustat [ 0 ] ; } ;

struct mem_cgroup_per_zone { struct list_head lists [ NR_LRU_LISTS ] ; unsigned long count [ NR_LRU_LISTS ] ; struct zone_reclaim_stat reclaim_stat ; struct rb_node tree_node ; unsigned long long usage_in_excess ; bool on_tree ; struct mem_cgroup * mem ; } ;

struct mem_cgroup_per_node { struct mem_cgroup_per_zone zoneinfo [ 4 ] ; } ;

struct mem_cgroup_lru_info { struct mem_cgroup_per_node * nodeinfo [ ( 1 << 6 ) ] ; } ;

struct mem_cgroup_tree_per_zone { struct rb_root rb_root ; spinlock_t lock ; } ;

struct mem_cgroup_tree_per_node { struct mem_cgroup_tree_per_zone rb_tree_per_zone [ 4 ] ; } ;

struct mem_cgroup_tree { struct mem_cgroup_tree_per_node * rb_tree_per_node [ ( 1 << 6 ) ] ; } ;

struct mem_cgroup { struct cgroup_subsys_state css ; struct res_counter res ; struct res_counter memsw ; struct mem_cgroup_lru_info info ; spinlock_t reclaim_param_lock ; int prev_priority ; int last_scanned_child ; bool use_hierarchy ; unsigned long last_oom_jiffies ; atomic_t refcnt ; unsigned int swappiness ; bool memsw_is_minimum ; struct mem_cgroup_stat stat ; } ;
enum charge_type { MEM_CGROUP_CHARGE_TYPE_CACHE = 0 , MEM_CGROUP_CHARGE_TYPE_MAPPED , MEM_CGROUP_CHARGE_TYPE_SHMEM , MEM_CGROUP_CHARGE_TYPE_FORCE , MEM_CGROUP_CHARGE_TYPE_SWAPOUT , MEM_CGROUP_CHARGE_TYPE_DROP , NR_CHARGE_TYPE , } ;

struct mem_cgroup * mem_cgroup_from_task ( struct task_struct * p ) ;

void mem_cgroup_del_lru_list ( struct page * page , enum lru_list lru ) ;

void mem_cgroup_del_lru ( struct page * page ) ;

void mem_cgroup_rotate_lru_list ( struct page * page , enum lru_list lru ) ;

void mem_cgroup_add_lru_list ( struct page * page , enum lru_list lru ) ;

void mem_cgroup_move_lists ( struct page * page , enum lru_list from , enum lru_list to ) ;

int task_in_mem_cgroup ( struct task_struct * task , const struct mem_cgroup * mem ) ;

int mem_cgroup_get_reclaim_priority ( struct mem_cgroup * mem ) ;

void mem_cgroup_note_reclaim_priority ( struct mem_cgroup * mem , int priority ) ;

void mem_cgroup_record_reclaim_priority ( struct mem_cgroup * mem , int priority ) ;

int mem_cgroup_inactive_anon_is_low ( struct mem_cgroup * memcg ) ;

int mem_cgroup_inactive_file_is_low ( struct mem_cgroup * memcg ) ;

unsigned long mem_cgroup_zone_nr_pages ( struct mem_cgroup * memcg , struct zone * zone , enum lru_list lru ) ;

struct zone_reclaim_stat * mem_cgroup_get_reclaim_stat ( struct mem_cgroup * memcg , struct zone * zone ) ;

struct zone_reclaim_stat * mem_cgroup_get_reclaim_stat_from_page ( struct page * page ) ;

unsigned long mem_cgroup_isolate_pages ( unsigned long nr_to_scan , struct list_head * dst , unsigned long * scanned , int order , int mode , struct zone * z , struct mem_cgroup * mem_cont , int active , int file ) ;

void mem_cgroup_print_oom_info ( struct mem_cgroup * memcg , struct task_struct * p ) ;

bool mem_cgroup_oom_called ( struct task_struct * task ) ;

void mem_cgroup_update_mapped_file_stat ( struct page * page , int val ) ;

int mem_cgroup_newpage_charge ( struct page * page , struct mm_struct * mm , gfp_t gfp_mask ) ;

int mem_cgroup_cache_charge ( struct page * page , struct mm_struct * mm , gfp_t gfp_mask ) ;

int mem_cgroup_try_charge_swapin ( struct mm_struct * mm , struct page * page , gfp_t mask , struct mem_cgroup * * ptr ) ;

void mem_cgroup_commit_charge_swapin ( struct page * page , struct mem_cgroup * ptr ) ;

void mem_cgroup_cancel_charge_swapin ( struct mem_cgroup * mem ) ;

void mem_cgroup_uncharge_page ( struct page * page ) ;

void mem_cgroup_uncharge_cache_page ( struct page * page ) ;

void mem_cgroup_uncharge_swapcache ( struct page * page , swp_entry_t ent , bool swapout ) ;

void mem_cgroup_uncharge_swap ( swp_entry_t ent ) ;

int mem_cgroup_prepare_migration ( struct page * page , struct mem_cgroup * * ptr ) ;

void mem_cgroup_end_migration ( struct mem_cgroup * mem , struct page * oldpage , struct page * newpage ) ;

int mem_cgroup_shmem_charge_fallback ( struct page * page , struct mm_struct * mm , gfp_t gfp_mask ) ;

unsigned long mem_cgroup_soft_limit_reclaim ( struct zone * zone , int order , gfp_t gfp_mask , int nid , int zid ) ;

int mem_cgroup_force_empty_write ( struct cgroup * cont , unsigned int event ) ;

struct mem_cgroup_idx_data { s64 val ; enum mem_cgroup_stat_index idx ; } ;

enum { MCS_CACHE , MCS_RSS , MCS_MAPPED_FILE , MCS_PGPGIN , MCS_PGPGOUT , MCS_SWAP , MCS_INACTIVE_ANON , MCS_ACTIVE_ANON , MCS_INACTIVE_FILE , MCS_ACTIVE_FILE , MCS_UNEVICTABLE , NR_MCS_STAT , } ;
struct mcs_total_stat { s64 stat [ NR_MCS_STAT ] ; } ;

struct page_cgroup * lookup_page_cgroup ( struct page * page ) ;

void __free_page_cgroup ( unsigned long pfn ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) online_page_cgroup ( unsigned long start_pfn , unsigned long nr_pages , int nid ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) offline_page_cgroup ( unsigned long start_pfn , unsigned long nr_pages , int nid ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) page_cgroup_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pgdat_page_cgroup_init ( struct pglist_data * pgdat ) ;

struct swap_cgroup_ctrl { struct page * * map ; unsigned long length ; } ;

struct swap_cgroup { unsigned short id ; } ;

unsigned short swap_cgroup_record ( swp_entry_t ent , unsigned short id ) ;

unsigned short lookup_swap_cgroup ( swp_entry_t ent ) ;

int swap_cgroup_swapon ( int type , unsigned long max_pages ) ;

void swap_cgroup_swapoff ( int type ) ;

struct to_kill { struct list_head nd ; struct task_struct * tsk ; unsigned long addr ; unsigned addr_valid : 1 ; } ;

enum outcome { FAILED , DELAYED , IGNORED , RECOVERED , } ;


int __memory_failure ( unsigned long pfn , int trapno , int ref ) ;

void memory_failure ( unsigned long pfn , int trapno ) ;
struct dnotify_struct { struct dnotify_struct * dn_next ; __u32 dn_mask ; int dn_fd ; struct file * dn_filp ; fl_owner_t dn_owner ; } ;

struct fsnotify_group ;

struct fsnotify_event ;

struct fsnotify_mark_entry ;

struct fsnotify_event_private_data ;

struct fsnotify_ops { bool ( * should_send_event ) ( struct fsnotify_group * group , struct inode * inode , __u32 mask ) ; int ( * handle_event ) ( struct fsnotify_group * group , struct fsnotify_event * event ) ; void ( * free_group_priv ) ( struct fsnotify_group * group ) ; void ( * freeing_mark ) ( struct fsnotify_mark_entry * entry , struct fsnotify_group * group ) ; void ( * free_event_priv ) ( struct fsnotify_event_private_data * priv ) ; } ;

struct fsnotify_group { struct list_head group_list ; __u32 mask ; atomic_t refcnt ; unsigned int group_num ; const struct fsnotify_ops * ops ; struct mutex notification_mutex ; struct list_head notification_list ; wait_queue_head_t notification_waitq ; unsigned int q_len ; unsigned int max_events ; spinlock_t mark_lock ; atomic_t num_marks ; struct list_head mark_entries ; bool on_group_list ; union { void * private ; struct inotify_group_private_data { spinlock_t idr_lock ; struct idr idr ; u32 last_wd ; struct fasync_struct * fa ; struct user_struct * user ; } inotify_data ; } ; } ;
struct fsnotify_event_holder { struct fsnotify_event * event ; struct list_head event_list ; } ;

struct fsnotify_event_private_data { struct fsnotify_group * group ; struct list_head event_list ; } ;
struct fsnotify_event { struct fsnotify_event_holder holder ; spinlock_t lock ; struct inode * to_tell ; union { struct path path ; struct inode * inode ; } ; int data_type ; atomic_t refcnt ; __u32 mask ; u32 sync_cookie ; char * file_name ; size_t name_len ; struct list_head private_data_list ; } ;
struct fsnotify_mark_entry { __u32 mask ; atomic_t refcnt ; struct inode * inode ; struct fsnotify_group * group ; struct hlist_node i_list ; struct list_head g_list ; spinlock_t lock ; struct list_head free_i_list ; struct list_head free_g_list ; void ( * free_mark ) ( struct fsnotify_mark_entry * entry ) ; } ;
struct space_resv { __s16 l_type ; __s16 l_whence ; __s64 l_start ; __s64 l_len ; __s32 l_sysid ; __u32 l_pid ; __s32 l_pad [ 4 ] ; } ;

struct ftrace_raw_do_sys_open { struct trace_entry ent ; u32 __data_loc_filename ; int flags ; int mode ; char __data [ 0 ] ; } ;

struct ftrace_raw_open_exec { struct trace_entry ent ; u32 __data_loc_filename ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_do_sys_open { u32 filename ; ; } ;

struct ftrace_data_offsets_open_exec { u32 filename ; ; } ;

int vfs_statfs ( struct dentry * dentry , struct kstatfs * buf ) ;

long sys_statfs ( const char * pathname , struct statfs * buf ) ;

long sys_statfs64 ( const char * pathname , size_t sz , struct statfs64 * buf ) ;

long sys_fstatfs ( unsigned int fd , struct statfs * buf ) ;

long sys_fstatfs64 ( unsigned int fd , size_t sz , struct statfs64 * buf ) ;

int do_truncate ( struct dentry * dentry , loff_t length , unsigned int time_attrs , struct file * filp ) ;

long sys_truncate ( const char * path , long length ) ;

long sys_ftruncate ( unsigned int fd , unsigned long length ) ;

int do_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) ;

long sys_fallocate ( int fd , int mode , loff_t offset , loff_t len ) ;

long sys_faccessat ( int dfd , const char * filename , int mode ) ;

long sys_access ( const char * filename , int mode ) ;

long sys_chdir ( const char * filename ) ;

long sys_fchdir ( unsigned int fd ) ;

long sys_chroot ( const char * filename ) ;

long sys_fchmod ( unsigned int fd , mode_t mode ) ;

long sys_fchmodat ( int dfd , const char * filename , mode_t mode ) ;

long sys_chmod ( const char * filename , mode_t mode ) ;

long sys_chown ( const char * filename , uid_t user , gid_t group ) ;

long sys_fchownat ( int dfd , const char * filename , uid_t user , gid_t group , int flag ) ;

long sys_lchown ( const char * filename , uid_t user , gid_t group ) ;

long sys_fchown ( unsigned int fd , uid_t user , gid_t group ) ;

struct file * lookup_instantiate_filp ( struct nameidata * nd , struct dentry * dentry , int ( * open ) ( struct inode * , struct file * ) ) ;

struct file * nameidata_to_filp ( struct nameidata * nd , int flags ) ;

struct file * dentry_open ( struct dentry * dentry , struct vfsmount * mnt , int flags , const struct cred * cred ) ;

void put_unused_fd ( unsigned int fd ) ;

void fd_install ( unsigned int fd , struct file * file ) ;

long do_sys_open ( int dfd , const char * filename , int flags , int mode ) ;

long sys_open ( const char * filename , int flags , int mode ) ;

long sys_openat ( int dfd , const char * filename , int flags , int mode ) ;

long sys_creat ( const char * pathname , int mode ) ;

int filp_close ( struct file * filp , fl_owner_t id ) ;

long sys_close ( unsigned int fd ) ;

long sys_vhangup ( void ) ;

int generic_file_open ( struct inode * inode , struct file * filp ) ;

int nonseekable_open ( struct inode * inode , struct file * filp ) ;

typedef ssize_t ( * io_fn_t ) ( struct file * , char * , size_t , loff_t * ) ;

typedef ssize_t ( * iov_fn_t ) ( struct kiocb * , const struct iovec * , unsigned long , loff_t ) ;
loff_t generic_file_llseek_unlocked ( struct file * file , loff_t offset , int origin ) ;

loff_t generic_file_llseek ( struct file * file , loff_t offset , int origin ) ;

loff_t no_llseek ( struct file * file , loff_t offset , int origin ) ;

loff_t default_llseek ( struct file * file , loff_t offset , int origin ) ;

loff_t vfs_llseek ( struct file * file , loff_t offset , int origin ) ;

long sys_lseek ( unsigned int fd , off_t offset , unsigned int origin ) ;

long sys_llseek ( unsigned int fd , unsigned long offset_high , unsigned long offset_low , loff_t * result , unsigned int origin ) ;

int rw_verify_area ( int read_write , struct file * file , loff_t * ppos , size_t count ) ;

ssize_t do_sync_read ( struct file * filp , char * buf , size_t len , loff_t * ppos ) ;

ssize_t vfs_read ( struct file * file , char * buf , size_t count , loff_t * pos ) ;

ssize_t do_sync_write ( struct file * filp , const char * buf , size_t len , loff_t * ppos ) ;

ssize_t vfs_write ( struct file * file , const char * buf , size_t count , loff_t * pos ) ;

long sys_read ( unsigned int fd , char * buf , size_t count ) ;

long sys_write ( unsigned int fd , const char * buf , size_t count ) ;

long sys_pread64 ( unsigned int fd , char * buf , size_t count , loff_t pos ) ;

long sys_pwrite64 ( unsigned int fd , const char * buf , size_t count , loff_t pos ) ;

unsigned long iov_shorten ( struct iovec * iov , unsigned long nr_segs , size_t to ) ;

ssize_t do_sync_readv_writev ( struct file * filp , const struct iovec * iov , unsigned long nr_segs , size_t len , loff_t * ppos , iov_fn_t fn ) ;

ssize_t do_loop_readv_writev ( struct file * filp , struct iovec * iov , unsigned long nr_segs , loff_t * ppos , io_fn_t fn ) ;

ssize_t rw_copy_check_uvector ( int type , const struct iovec * uvector , unsigned long nr_segs , unsigned long fast_segs , struct iovec * fast_pointer , struct iovec * * ret_pointer ) ;

ssize_t vfs_readv ( struct file * file , const struct iovec * vec , unsigned long vlen , loff_t * pos ) ;

ssize_t vfs_writev ( struct file * file , const struct iovec * vec , unsigned long vlen , loff_t * pos ) ;

long sys_readv ( unsigned long fd , const struct iovec * vec , unsigned long vlen ) ;

long sys_writev ( unsigned long fd , const struct iovec * vec , unsigned long vlen ) ;

long sys_preadv ( unsigned long fd , const struct iovec * vec , unsigned long vlen , unsigned long pos_l , unsigned long pos_h ) ;

long sys_pwritev ( unsigned long fd , const struct iovec * vec , unsigned long vlen , unsigned long pos_l , unsigned long pos_h ) ;

long sys_sendfile ( int out_fd , int in_fd , off_t * offset , size_t count ) ;

long sys_sendfile64 ( int out_fd , int in_fd , loff_t * offset , size_t count ) ;

struct epoll_event { __u32 events ; __u64 data ; } __attribute__ ( ( packed ) ) ;
int get_max_files ( void ) ;

int proc_nr_files ( ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

struct file * get_empty_filp ( void ) ;

struct file * alloc_file ( struct vfsmount * mnt , struct dentry * dentry , fmode_t mode , const struct file_operations * fop ) ;

int init_file ( struct file * file , struct vfsmount * mnt , struct dentry * dentry , fmode_t mode , const struct file_operations * fop ) ;

void fput ( struct file * file ) ;

void drop_file_write_access ( struct file * file ) ;

void __fput ( struct file * file ) ;

struct file * fget ( unsigned int fd ) ;

struct file * fget_light ( unsigned int fd , int * fput_needed ) ;

void put_filp ( struct file * file ) ;

void file_move ( struct file * file , struct list_head * list ) ;

void file_kill ( struct file * file ) ;

int fs_may_remount_ro ( struct super_block * sb ) ;

void mark_files_ro ( struct super_block * sb ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) files_init ( unsigned long mempages ) ;

int __put_super_and_need_restart ( struct super_block * sb ) ;

void put_super ( struct super_block * sb ) ;

void deactivate_super ( struct super_block * s ) ;

void deactivate_locked_super ( struct super_block * s ) ;

void lock_super ( struct super_block * sb ) ;

void unlock_super ( struct super_block * sb ) ;

void generic_shutdown_super ( struct super_block * sb ) ;

struct super_block * sget ( struct file_system_type * type , int ( * test ) ( struct super_block * , void * ) , int ( * set ) ( struct super_block * , void * ) , void * data ) ;

void drop_super ( struct super_block * sb ) ;

void sync_supers ( void ) ;

struct super_block * get_super ( struct block_device * bdev ) ;

struct super_block * get_active_super ( struct block_device * bdev ) ;

struct super_block * user_get_super ( dev_t dev ) ;

long sys_ustat ( unsigned dev , struct ustat * ubuf ) ;

int do_remount_sb ( struct super_block * sb , int flags , void * data , int force ) ;

void emergency_remount ( void ) ;

int set_anon_super ( struct super_block * s , void * data ) ;

void kill_anon_super ( struct super_block * sb ) ;

void kill_litter_super ( struct super_block * sb ) ;

int get_sb_ns ( struct file_system_type * fs_type , int flags , void * data , int ( * fill_super ) ( struct super_block * , void * , int ) , struct vfsmount * mnt ) ;

int get_sb_bdev ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data , int ( * fill_super ) ( struct super_block * , void * , int ) , struct vfsmount * mnt ) ;

void kill_block_super ( struct super_block * sb ) ;

int get_sb_nodev ( struct file_system_type * fs_type , int flags , void * data , int ( * fill_super ) ( struct super_block * , void * , int ) , struct vfsmount * mnt ) ;

int get_sb_single ( struct file_system_type * fs_type , int flags , void * data , int ( * fill_super ) ( struct super_block * , void * , int ) , struct vfsmount * mnt ) ;

struct vfsmount * vfs_kern_mount ( struct file_system_type * type , int flags , const char * name , void * data ) ;

struct vfsmount * do_kern_mount ( const char * fstype , int flags , const char * name , void * data ) ;

struct vfsmount * kern_mount_data ( struct file_system_type * type , void * data ) ;

typedef struct kobject * kobj_probe_t ( dev_t , int * , void * ) ;

struct kobj_map ;


void chrdev_show ( struct seq_file * f , off_t offset ) ;

int register_chrdev_region ( dev_t from , unsigned count , const char * name ) ;

int alloc_chrdev_region ( dev_t * dev , unsigned baseminor , unsigned count , const char * name ) ;

int __register_chrdev ( unsigned int major , unsigned int baseminor , unsigned int count , const char * name , const struct file_operations * fops ) ;

void unregister_chrdev_region ( dev_t from , unsigned count ) ;

void __unregister_chrdev ( unsigned int major , unsigned int baseminor , unsigned int count , const char * name ) ;

void cdev_put ( struct cdev * p ) ;

int cdev_index ( struct inode * inode ) ;

void cd_forget ( struct inode * inode ) ;

int cdev_add ( struct cdev * p , dev_t dev , unsigned count ) ;

void cdev_del ( struct cdev * p ) ;

struct cdev * cdev_alloc ( void ) ;

void cdev_init ( struct cdev * cdev , const struct file_operations * fops ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) chrdev_init ( void ) ;

void generic_fillattr ( struct inode * inode , struct kstat * stat ) ;

int vfs_getattr ( struct vfsmount * mnt , struct dentry * dentry , struct kstat * stat ) ;

int vfs_fstat ( unsigned int fd , struct kstat * stat ) ;

int vfs_fstatat ( int dfd , char * filename , struct kstat * stat , int flag ) ;

int vfs_stat ( char * name , struct kstat * stat ) ;

int vfs_lstat ( char * name , struct kstat * stat ) ;

long sys_stat ( char * filename , struct __old_kernel_stat * statbuf ) ;

long sys_lstat ( char * filename , struct __old_kernel_stat * statbuf ) ;

long sys_fstat ( unsigned int fd , struct __old_kernel_stat * statbuf ) ;

long sys_newstat ( char * filename , struct stat * statbuf ) ;

long sys_newlstat ( char * filename , struct stat * statbuf ) ;

long sys_newfstatat ( int dfd , char * filename , struct stat * statbuf , int flag ) ;

long sys_newfstat ( unsigned int fd , struct stat * statbuf ) ;

long sys_readlinkat ( int dfd , const char * pathname , char * buf , int bufsiz ) ;

long sys_readlink ( const char * path , char * buf , int bufsiz ) ;

void __inode_add_bytes ( struct inode * inode , loff_t bytes ) ;

void inode_add_bytes ( struct inode * inode , loff_t bytes ) ;

void inode_sub_bytes ( struct inode * inode , loff_t bytes ) ;

loff_t inode_get_bytes ( struct inode * inode ) ;

void inode_set_bytes ( struct inode * inode , loff_t bytes ) ;

int __register_binfmt ( struct linux_binfmt * fmt , int insert ) ;

void unregister_binfmt ( struct linux_binfmt * fmt ) ;

long sys_uselib ( const char * library ) ;

int bprm_mm_init ( struct linux_binprm * bprm ) ;

int copy_strings_kernel ( int argc , char * * argv , struct linux_binprm * bprm ) ;

int setup_arg_pages ( struct linux_binprm * bprm , unsigned long stack_top , int executable_stack ) ;

struct file * open_exec ( const char * name ) ;

int kernel_read ( struct file * file , loff_t offset , char * addr , unsigned long count ) ;

char * get_task_comm ( char * buf , struct task_struct * tsk ) ;

void set_task_comm ( struct task_struct * tsk , char * buf ) ;

int flush_old_exec ( struct linux_binprm * bprm ) ;

void setup_new_exec ( struct linux_binprm * bprm ) ;

int prepare_bprm_creds ( struct linux_binprm * bprm ) ;

void free_bprm ( struct linux_binprm * bprm ) ;

void install_exec_creds ( struct linux_binprm * bprm ) ;

int check_unsafe_exec ( struct linux_binprm * bprm ) ;

int prepare_binprm ( struct linux_binprm * bprm ) ;

int remove_arg_zero ( struct linux_binprm * bprm ) ;

int search_binary_handler ( struct linux_binprm * bprm , struct pt_regs * regs ) ;

int do_execve ( char * filename , char * * argv , char * * envp , struct pt_regs * regs ) ;

void set_binfmt ( struct linux_binfmt * new ) ;

void set_dumpable ( struct mm_struct * mm , int value ) ;

int get_dumpable ( struct mm_struct * mm ) ;

void do_coredump ( long signr , int exit_code , struct pt_regs * regs ) ;

void pipe_lock ( struct pipe_inode_info * pipe ) ;

void pipe_unlock ( struct pipe_inode_info * pipe ) ;

void pipe_double_lock ( struct pipe_inode_info * pipe1 , struct pipe_inode_info * pipe2 ) ;

void pipe_wait ( struct pipe_inode_info * pipe ) ;

void * generic_pipe_buf_map ( struct pipe_inode_info * pipe , struct pipe_buffer * buf , int atomic ) ;

void generic_pipe_buf_unmap ( struct pipe_inode_info * pipe , struct pipe_buffer * buf , void * map_data ) ;

int generic_pipe_buf_steal ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) ;

void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) ;

int generic_pipe_buf_confirm ( struct pipe_inode_info * info , struct pipe_buffer * buf ) ;

void generic_pipe_buf_release ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) ;

struct pipe_inode_info * alloc_pipe_info ( struct inode * inode ) ;

void __free_pipe_info ( struct pipe_inode_info * pipe ) ;

void free_pipe_info ( struct inode * inode ) ;

struct file * create_write_pipe ( int flags ) ;

void free_write_pipe ( struct file * f ) ;

struct file * create_read_pipe ( struct file * wrf , int flags ) ;

int do_pipe_flags ( int * fd , int flags ) ;

long sys_pipe2 ( int * fildes , int flags ) ;

long sys_pipe ( int * fildes ) ;

char * getname ( const char * filename ) ;

void putname ( const char * name ) ;

int generic_permission ( struct inode * inode , int mask , int ( * check_acl ) ( struct inode * inode , int mask ) ) ;

int inode_permission ( struct inode * inode , int mask ) ;

int file_permission ( struct file * file , int mask ) ;

int get_write_access ( struct inode * inode ) ;

int deny_write_access ( struct file * file ) ;

void path_get ( struct path * path ) ;

void path_put ( struct path * path ) ;

void release_open_intent ( struct nameidata * nd ) ;

int follow_up ( struct path * path ) ;

int follow_down ( struct path * path ) ;

int path_lookup ( const char * name , unsigned int flags , struct nameidata * nd ) ;

int kern_path ( const char * name , unsigned int flags , struct path * path ) ;

int vfs_path_lookup ( struct dentry * dentry , struct vfsmount * mnt , const char * name , unsigned int flags , struct nameidata * nd ) ;

struct dentry * lookup_hash ( struct nameidata * nd ) ;

int __lookup_one_len ( const char * name , struct qstr * this , struct dentry * base , int len ) ;

struct dentry * lookup_one_len ( const char * name , struct dentry * base , int len ) ;

struct dentry * lookup_one_noperm ( const char * name , struct dentry * base ) ;

int user_path_at ( int dfd , const char * name , unsigned flags , struct path * path ) ;

struct dentry * lock_rename ( struct dentry * p1 , struct dentry * p2 ) ;

void unlock_rename ( struct dentry * p1 , struct dentry * p2 ) ;

int vfs_create ( struct inode * dir , struct dentry * dentry , int mode , struct nameidata * nd ) ;

int may_open ( struct path * path , int acc_mode , int flag ) ;

struct file * do_filp_open ( int dfd , const char * pathname , int open_flag , int mode , int acc_mode ) ;

struct file * filp_open ( const char * filename , int flags , int mode ) ;

struct dentry * lookup_create ( struct nameidata * nd , int is_dir ) ;

int vfs_mknod ( struct inode * dir , struct dentry * dentry , int mode , dev_t dev ) ;

long sys_mknodat ( int dfd , const char * filename , int mode , unsigned dev ) ;

long sys_mknod ( const char * filename , int mode , unsigned dev ) ;

int vfs_mkdir ( struct inode * dir , struct dentry * dentry , int mode ) ;

long sys_mkdirat ( int dfd , const char * pathname , int mode ) ;

long sys_mkdir ( const char * pathname , int mode ) ;

void dentry_unhash ( struct dentry * dentry ) ;

int vfs_rmdir ( struct inode * dir , struct dentry * dentry ) ;

long sys_rmdir ( const char * pathname ) ;

int vfs_unlink ( struct inode * dir , struct dentry * dentry ) ;

long sys_unlinkat ( int dfd , const char * pathname , int flag ) ;

long sys_unlink ( const char * pathname ) ;

int vfs_symlink ( struct inode * dir , struct dentry * dentry , const char * oldname ) ;

long sys_symlinkat ( const char * oldname , int newdfd , const char * newname ) ;

long sys_symlink ( const char * oldname , const char * newname ) ;

int vfs_link ( struct dentry * old_dentry , struct inode * dir , struct dentry * new_dentry ) ;

long sys_linkat ( int olddfd , const char * oldname , int newdfd , const char * newname , int flags ) ;

long sys_link ( const char * oldname , const char * newname ) ;

int vfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) ;

long sys_renameat ( int olddfd , const char * oldname , int newdfd , const char * newname ) ;

long sys_rename ( const char * oldname , const char * newname ) ;

int vfs_readlink ( struct dentry * dentry , char * buffer , int buflen , const char * link ) ;

int generic_readlink ( struct dentry * dentry , char * buffer , int buflen ) ;

int vfs_follow_link ( struct nameidata * nd , const char * link ) ;

int page_readlink ( struct dentry * dentry , char * buffer , int buflen ) ;

void * page_follow_link_light ( struct dentry * dentry , struct nameidata * nd ) ;

void page_put_link ( struct dentry * dentry , struct nameidata * nd , void * cookie ) ;

int __page_symlink ( struct inode * inode , const char * symname , int len , int nofs ) ;

int page_symlink ( struct inode * inode , const char * symname , int len ) ;

void set_close_on_exec ( unsigned int fd , int flag ) ;

long sys_dup3 ( unsigned int oldfd , unsigned int newfd , int flags ) ;

long sys_dup2 ( unsigned int oldfd , unsigned int newfd ) ;

long sys_dup ( unsigned int fildes ) ;

int __f_setown ( struct file * filp , struct pid * pid , enum pid_type type , int force ) ;

int f_setown ( struct file * filp , unsigned long arg , int force ) ;

void f_delown ( struct file * filp ) ;

pid_t f_getown ( struct file * filp ) ;

long sys_fcntl ( unsigned int fd , unsigned int cmd , unsigned long arg ) ;

void send_sigio ( struct fown_struct * fown , int fd , int band ) ;

int send_sigurg ( struct fown_struct * fown ) ;

int fasync_helper ( int fd , struct file * filp , int on , struct fasync_struct * * fapp ) ;

void __kill_fasync ( struct fasync_struct * fa , int sig , int band ) ;

void kill_fasync ( struct fasync_struct * * fp , int sig , int band ) ;

int fiemap_fill_next_extent ( struct fiemap_extent_info * fieinfo , u64 logical , u64 phys , u64 len , u32 flags ) ;

int fiemap_check_flags ( struct fiemap_extent_info * fieinfo , u32 fs_flags ) ;

int __generic_block_fiemap ( struct inode * inode , struct fiemap_extent_info * fieinfo , u64 start , u64 len , get_block_t * get_block ) ;

int generic_block_fiemap ( struct inode * inode , struct fiemap_extent_info * fieinfo , u64 start , u64 len , get_block_t * get_block ) ;

int ioctl_preallocate ( struct file * filp , void * argp ) ;

int do_vfs_ioctl ( struct file * filp , unsigned int fd , unsigned int cmd , unsigned long arg ) ;

long sys_ioctl ( unsigned int fd , unsigned int cmd , unsigned long arg ) ;

int vfs_readdir ( struct file * file , filldir_t filler , void * buf ) ;

struct old_linux_dirent { unsigned long d_ino ; unsigned long d_offset ; unsigned short d_namlen ; char d_name [ 1 ] ; } ;
struct readdir_callback { struct old_linux_dirent * dirent ; int result ; } ;

long sys_old_readdir ( unsigned int fd , struct old_linux_dirent * dirent , unsigned int count ) ;

struct linux_dirent { unsigned long d_ino ; unsigned long d_off ; unsigned short d_reclen ; char d_name [ 1 ] ; } ;
struct getdents_callback { struct linux_dirent * current_dir ; struct linux_dirent * previous ; int count ; int error ; } ;

long sys_getdents ( unsigned int fd , struct linux_dirent * dirent , unsigned int count ) ;

struct getdents_callback64 { struct linux_dirent64 * current_dir ; struct linux_dirent64 * previous ; int count ; int error ; } ;

long sys_getdents64 ( unsigned int fd , struct linux_dirent64 * dirent , unsigned int count ) ;

struct poll_table_page { struct poll_table_page * next ; struct poll_table_entry * entry ; struct poll_table_entry entries [ 0 ] ; } ;

void poll_initwait ( struct poll_wqueues * pwq ) ;

void poll_freewait ( struct poll_wqueues * pwq ) ;

int poll_schedule_timeout ( struct poll_wqueues * pwq , int state , ktime_t * expires , unsigned long slack ) ;

int poll_select_set_timeout ( struct timespec * to , long sec , long nsec ) ;

int do_select ( int n , fd_set_bits * fds , struct timespec * end_time ) ;

int core_sys_select ( int n , fd_set * inp , fd_set * outp , fd_set * exp , struct timespec * end_time ) ;

long sys_select ( int n , fd_set * inp , fd_set * outp , fd_set * exp , struct timeval * tvp ) ;

long sys_pselect6 ( int n , fd_set * inp , fd_set * outp , fd_set * exp , struct timespec * tsp , void * sig ) ;

struct poll_list { struct poll_list * next ; int len ; struct pollfd entries [ 0 ] ; } ;

int do_sys_poll ( struct pollfd * ufds , unsigned int nfds , struct timespec * end_time ) ;

long sys_poll ( struct pollfd * ufds , unsigned int nfds , long timeout_msecs ) ;

long sys_ppoll ( struct pollfd * ufds , unsigned int nfds , struct timespec * tsp , const sigset_t * sigmask , size_t sigsetsize ) ;

void dput ( struct dentry * dentry ) ;

int d_invalidate ( struct dentry * dentry ) ;

struct dentry * dget_locked ( struct dentry * dentry ) ;

struct dentry * d_find_alias ( struct inode * inode ) ;

void d_prune_aliases ( struct inode * inode ) ;

void shrink_dcache_sb ( struct super_block * sb ) ;

void shrink_dcache_for_umount ( struct super_block * sb ) ;

int have_submounts ( struct dentry * parent ) ;

void shrink_dcache_parent ( struct dentry * parent ) ;

struct dentry * d_alloc ( struct dentry * parent , const struct qstr * name ) ;

struct dentry * d_alloc_name ( struct dentry * parent , const char * name ) ;

void d_instantiate ( struct dentry * entry , struct inode * inode ) ;

struct dentry * d_instantiate_unique ( struct dentry * entry , struct inode * inode ) ;

struct dentry * d_alloc_root ( struct inode * root_inode ) ;

struct dentry * d_obtain_alias ( struct inode * inode ) ;

struct dentry * d_splice_alias ( struct inode * inode , struct dentry * dentry ) ;

struct dentry * d_add_ci ( struct dentry * dentry , struct inode * inode , struct qstr * name ) ;

struct dentry * d_lookup ( struct dentry * parent , struct qstr * name ) ;

struct dentry * __d_lookup ( struct dentry * parent , struct qstr * name ) ;

struct dentry * d_hash_and_lookup ( struct dentry * dir , struct qstr * name ) ;

int d_validate ( struct dentry * dentry , struct dentry * dparent ) ;

void d_delete ( struct dentry * dentry ) ;

void d_rehash ( struct dentry * entry ) ;

void d_move ( struct dentry * dentry , struct dentry * target ) ;

struct dentry * d_ancestor ( struct dentry * p1 , struct dentry * p2 ) ;

struct dentry * d_materialise_unique ( struct dentry * dentry , struct inode * inode ) ;

char * __d_path ( const struct path * path , struct path * root , char * buffer , int buflen ) ;

char * d_path ( const struct path * path , char * buf , int buflen ) ;

char * dynamic_dname ( struct dentry * dentry , char * buffer , int buflen , const char * fmt , ... ) ;

char * dentry_path ( struct dentry * dentry , char * buf , int buflen ) ;

long sys_getcwd ( char * buf , unsigned long size ) ;

int is_subdir ( struct dentry * new_dentry , struct dentry * old_dentry ) ;

void d_genocide ( struct dentry * root ) ;

ino_t find_inode_number ( struct dentry * dir , struct qstr * name ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) vfs_caches_init_early ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) vfs_caches_init ( unsigned long mempages ) ;

int inode_init_always ( struct super_block * sb , struct inode * inode ) ;

void __destroy_inode ( struct inode * inode ) ;

void destroy_inode ( struct inode * inode ) ;

void inode_init_once ( struct inode * inode ) ;

void __iget ( struct inode * inode ) ;

void clear_inode ( struct inode * inode ) ;

int invalidate_inodes ( struct super_block * sb ) ;

void inode_add_to_lists ( struct super_block * sb , struct inode * inode ) ;

struct inode * new_inode ( struct super_block * sb ) ;

void unlock_new_inode ( struct inode * inode ) ;

ino_t iunique ( struct super_block * sb , ino_t max_reserved ) ;

struct inode * igrab ( struct inode * inode ) ;

struct inode * ilookup5_nowait ( struct super_block * sb , unsigned long hashval , int ( * test ) ( struct inode * , void * ) , void * data ) ;

struct inode * ilookup5 ( struct super_block * sb , unsigned long hashval , int ( * test ) ( struct inode * , void * ) , void * data ) ;

struct inode * ilookup ( struct super_block * sb , unsigned long ino ) ;

struct inode * iget5_locked ( struct super_block * sb , unsigned long hashval , int ( * test ) ( struct inode * , void * ) , int ( * set ) ( struct inode * , void * ) , void * data ) ;

struct inode * iget_locked ( struct super_block * sb , unsigned long ino ) ;

int insert_inode_locked ( struct inode * inode ) ;

int insert_inode_locked4 ( struct inode * inode , unsigned long hashval , int ( * test ) ( struct inode * , void * ) , void * data ) ;

void __insert_inode_hash ( struct inode * inode , unsigned long hashval ) ;

void remove_inode_hash ( struct inode * inode ) ;

void generic_delete_inode ( struct inode * inode ) ;

int generic_detach_inode ( struct inode * inode ) ;

void generic_drop_inode ( struct inode * inode ) ;

void iput ( struct inode * inode ) ;

sector_t bmap ( struct inode * inode , sector_t block ) ;

void touch_atime ( struct vfsmount * mnt , struct dentry * dentry ) ;

void file_update_time ( struct file * file ) ;

int inode_needs_sync ( struct inode * inode ) ;

int inode_wait ( void * word ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) inode_init_early ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) inode_init ( void ) ;

void init_special_inode ( struct inode * inode , umode_t mode , dev_t rdev ) ;

struct ftrace_raw_dirty_inode { struct trace_entry ent ; char comm [ 16 ] ; pid_t pid ; char dev [ 16 ] ; char file [ 32 ] ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_dirty_inode { ; } ;

int inode_change_ok ( const struct inode * inode , struct iattr * attr ) ;

int inode_newsize_ok ( const struct inode * inode , loff_t offset ) ;

int inode_setattr ( struct inode * inode , struct iattr * attr ) ;

int notify_change ( struct dentry * dentry , struct iattr * attr ) ;

void make_bad_inode ( struct inode * inode ) ;

int is_bad_inode ( struct inode * inode ) ;

void iget_failed ( struct inode * inode ) ;

struct fdtable_defer { spinlock_t lock ; struct work_struct wq ; struct fdtable * next ; } ;

void free_fdtable_rcu ( struct rcu_head * rcu ) ;

int expand_files ( struct files_struct * files , int nr ) ;

struct files_struct * dup_fd ( struct files_struct * oldf , int * errorp ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) files_defer_init ( void ) ;

int alloc_fd ( unsigned start , unsigned flags ) ;

int get_unused_fd ( void ) ;

void get_filesystem ( struct file_system_type * fs ) ;

void put_filesystem ( struct file_system_type * fs ) ;

int register_filesystem ( struct file_system_type * fs ) ;

int unregister_filesystem ( struct file_system_type * fs ) ;

long sys_sysfs ( int option , unsigned long arg1 , unsigned long arg2 ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) get_filesystem_list ( char * buf ) ;

struct file_system_type * get_fs_type ( const char * name ) ;

void mnt_release_group_id ( struct vfsmount * mnt ) ;

struct vfsmount * alloc_vfsmnt ( const char * name ) ;

int __mnt_is_readonly ( struct vfsmount * mnt ) ;

int mnt_want_write ( struct vfsmount * mnt ) ;

int mnt_clone_write ( struct vfsmount * mnt ) ;

int mnt_want_write_file ( struct file * file ) ;

void mnt_drop_write ( struct vfsmount * mnt ) ;

void simple_set_mnt ( struct vfsmount * mnt , struct super_block * sb ) ;

void free_vfsmnt ( struct vfsmount * mnt ) ;

struct vfsmount * __lookup_mnt ( struct vfsmount * mnt , struct dentry * dentry , int dir ) ;

struct vfsmount * lookup_mnt ( struct path * path ) ;

void mnt_set_mountpoint ( struct vfsmount * mnt , struct dentry * dentry , struct vfsmount * child_mnt ) ;

void mntput_no_expire ( struct vfsmount * mnt ) ;

void mnt_pin ( struct vfsmount * mnt ) ;

void mnt_unpin ( struct vfsmount * mnt ) ;

int generic_show_options ( struct seq_file * m , struct vfsmount * mnt ) ;

void save_mount_options ( struct super_block * sb , char * options ) ;

void replace_mount_options ( struct super_block * sb , char * options ) ;

struct proc_fs_info { int flag ; const char * str ; } ;

int may_umount_tree ( struct vfsmount * mnt ) ;

int may_umount ( struct vfsmount * mnt ) ;

void release_mounts ( struct list_head * head ) ;

void umount_tree ( struct vfsmount * mnt , int propagate , struct list_head * kill ) ;

long sys_umount ( char * name , int flags ) ;

long sys_oldumount ( char * name ) ;

struct vfsmount * copy_tree ( struct vfsmount * mnt , struct dentry * dentry , int flag ) ;

struct vfsmount * collect_mounts ( struct path * path ) ;

void drop_collected_mounts ( struct vfsmount * mnt ) ;

int do_add_mount ( struct vfsmount * newmnt , struct path * path , int mnt_flags , struct list_head * fslist ) ;

void mark_mounts_for_expiry ( struct list_head * mounts ) ;

int copy_mount_options ( const void * data , unsigned long * where ) ;

int copy_mount_string ( const void * data , char * * where ) ;

long do_mount ( char * dev_name , char * dir_name , char * type_page , unsigned long flags , void * data_page ) ;

struct mnt_namespace * copy_mnt_ns ( unsigned long flags , struct mnt_namespace * ns , struct fs_struct * new_fs ) ;

struct mnt_namespace * create_mnt_ns ( struct vfsmount * mnt ) ;

long sys_mount ( char * dev_name , char * dir_name , char * type , unsigned long flags , void * data ) ;

long sys_pivot_root ( const char * new_root , const char * put_old ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mnt_init ( void ) ;

void put_mnt_ns ( struct mnt_namespace * ns ) ;

int seq_open ( struct file * file , const struct seq_operations * op ) ;

ssize_t seq_read ( struct file * file , char * buf , size_t size , loff_t * ppos ) ;

loff_t seq_lseek ( struct file * file , loff_t offset , int origin ) ;

int seq_release ( struct inode * inode , struct file * file ) ;

int seq_escape ( struct seq_file * m , const char * s , const char * esc ) ;

int seq_printf ( struct seq_file * m , const char * f , ... ) ;

char * mangle_path ( char * s , char * p , char * esc ) ;

int seq_path ( struct seq_file * m , struct path * path , char * esc ) ;

int seq_path_root ( struct seq_file * m , struct path * path , struct path * root , char * esc ) ;

int seq_dentry ( struct seq_file * m , struct dentry * dentry , char * esc ) ;

int seq_bitmap ( struct seq_file * m , const unsigned long * bits , unsigned int nr_bits ) ;

int seq_bitmap_list ( struct seq_file * m , const unsigned long * bits , unsigned int nr_bits ) ;

int single_open ( struct file * file , int ( * show ) ( struct seq_file * , void * ) , void * data ) ;

int single_release ( struct inode * inode , struct file * file ) ;

int seq_release_private ( struct inode * inode , struct file * file ) ;

void * __seq_open_private ( struct file * f , const struct seq_operations * ops , int psize ) ;

int seq_open_private ( struct file * filp , const struct seq_operations * ops , int psize ) ;

int seq_putc ( struct seq_file * m , char c ) ;

int seq_puts ( struct seq_file * m , const char * s ) ;

int seq_write ( struct seq_file * seq , const void * data , size_t len ) ;

struct list_head * seq_list_start ( struct list_head * head , loff_t pos ) ;

struct list_head * seq_list_start_head ( struct list_head * head , loff_t pos ) ;

struct list_head * seq_list_next ( void * v , struct list_head * head , loff_t * ppos ) ;

int __vfs_setxattr_noperm ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

int vfs_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

ssize_t xattr_getsecurity ( struct inode * inode , const char * name , void * value , size_t size ) ;

ssize_t vfs_getxattr ( struct dentry * dentry , const char * name , void * value , size_t size ) ;

ssize_t vfs_listxattr ( struct dentry * d , char * list , size_t size ) ;

int vfs_removexattr ( struct dentry * dentry , const char * name ) ;

long sys_setxattr ( const char * pathname , const char * name , const void * value , size_t size , int flags ) ;

long sys_lsetxattr ( const char * pathname , const char * name , const void * value , size_t size , int flags ) ;

long sys_fsetxattr ( int fd , const char * name , const void * value , size_t size , int flags ) ;

long sys_getxattr ( const char * pathname , const char * name , void * value , size_t size ) ;

long sys_lgetxattr ( const char * pathname , const char * name , void * value , size_t size ) ;

long sys_fgetxattr ( int fd , const char * name , void * value , size_t size ) ;

long sys_listxattr ( const char * pathname , char * list , size_t size ) ;

long sys_llistxattr ( const char * pathname , char * list , size_t size ) ;

long sys_flistxattr ( int fd , char * list , size_t size ) ;

long sys_removexattr ( const char * pathname , const char * name ) ;

long sys_lremovexattr ( const char * pathname , const char * name ) ;

long sys_fremovexattr ( int fd , const char * name ) ;

ssize_t generic_getxattr ( struct dentry * dentry , const char * name , void * buffer , size_t size ) ;

ssize_t generic_listxattr ( struct dentry * dentry , char * buffer , size_t buffer_size ) ;

int generic_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

int generic_removexattr ( struct dentry * dentry , const char * name ) ;

int simple_getattr ( struct vfsmount * mnt , struct dentry * dentry , struct kstat * stat ) ;

int simple_statfs ( struct dentry * dentry , struct kstatfs * buf ) ;

struct dentry * simple_lookup ( struct inode * dir , struct dentry * dentry , struct nameidata * nd ) ;

int simple_sync_file ( struct file * file , struct dentry * dentry , int datasync ) ;

int dcache_dir_open ( struct inode * inode , struct file * file ) ;

int dcache_dir_close ( struct inode * inode , struct file * file ) ;

loff_t dcache_dir_lseek ( struct file * file , loff_t offset , int origin ) ;

int dcache_readdir ( struct file * filp , void * dirent , filldir_t filldir ) ;

ssize_t generic_read_dir ( struct file * filp , char * buf , size_t siz , loff_t * ppos ) ;

int get_sb_pseudo ( struct file_system_type * fs_type , char * name , const struct super_operations * ops , unsigned long magic , struct vfsmount * mnt ) ;

int simple_link ( struct dentry * old_dentry , struct inode * dir , struct dentry * dentry ) ;

int simple_empty ( struct dentry * dentry ) ;

int simple_unlink ( struct inode * dir , struct dentry * dentry ) ;

int simple_rmdir ( struct inode * dir , struct dentry * dentry ) ;

int simple_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) ;

int simple_readpage ( struct file * file , struct page * page ) ;

int simple_prepare_write ( struct file * file , struct page * page , unsigned from , unsigned to ) ;

int simple_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata ) ;

int simple_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) ;

int simple_fill_super ( struct super_block * s , unsigned long magic , struct tree_descr * files ) ;

int simple_pin_fs ( struct file_system_type * type , struct vfsmount * * mount , int * count ) ;

void simple_release_fs ( struct vfsmount * * mount , int * count ) ;

ssize_t simple_read_from_buffer ( void * to , size_t count , loff_t * ppos , const void * from , size_t available ) ;

ssize_t memory_read_from_buffer ( void * to , size_t count , loff_t * ppos , const void * from , size_t available ) ;

void simple_transaction_set ( struct file * file , size_t n ) ;

char * simple_transaction_get ( struct file * file , const char * buf , size_t size ) ;

ssize_t simple_transaction_read ( struct file * file , char * buf , size_t size , loff_t * pos ) ;

int simple_transaction_release ( struct inode * inode , struct file * file ) ;

struct simple_attr { int ( * get ) ( void * , u64 * ) ; int ( * set ) ( void * , u64 ) ; char get_buf [ 24 ] ; char set_buf [ 24 ] ; void * data ; const char * fmt ; struct mutex mutex ; } ;

int simple_attr_open ( struct inode * inode , struct file * file , int ( * get ) ( void * , u64 * ) , int ( * set ) ( void * , u64 ) , const char * fmt ) ;

int simple_attr_release ( struct inode * inode , struct file * file ) ;

ssize_t simple_attr_read ( struct file * file , char * buf , size_t len , loff_t * ppos ) ;

ssize_t simple_attr_write ( struct file * file , const char * buf , size_t len , loff_t * ppos ) ;

struct dentry * generic_fh_to_dentry ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type , struct inode * ( * get_inode ) ( struct super_block * sb , u64 ino , u32 gen ) ) ;

struct dentry * generic_fh_to_parent ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type , struct inode * ( * get_inode ) ( struct super_block * sb , u64 ino , u32 gen ) ) ;

int simple_fsync ( struct file * file , struct dentry * dentry , int datasync ) ;

struct wb_writeback_work { long nr_pages ; struct super_block * sb ; enum writeback_sync_modes sync_mode ; int for_kupdate : 1 ; int range_cyclic : 1 ; int for_background : 1 ; struct list_head list ; struct completion * done ; } ;

int writeback_in_progress ( struct backing_dev_info * bdi ) ;

void bdi_start_writeback ( struct backing_dev_info * bdi , long nr_pages ) ;

void bdi_start_background_writeback ( struct backing_dev_info * bdi ) ;

void writeback_inodes_wb ( struct bdi_writeback * wb , struct writeback_control * wbc ) ;

long wb_do_writeback ( struct bdi_writeback * wb , int force_wait ) ;

int bdi_writeback_task ( struct bdi_writeback * wb ) ;

void wakeup_flusher_threads ( long nr_pages ) ;

void __mark_inode_dirty ( struct inode * inode , int flags ) ;

void writeback_inodes_sb ( struct super_block * sb ) ;

int writeback_inodes_sb_if_idle ( struct super_block * sb ) ;

void sync_inodes_sb ( struct super_block * sb ) ;

int write_inode_now ( struct inode * inode , int sync ) ;

int sync_inode ( struct inode * inode , struct writeback_control * wbc ) ;

int get_dominating_id ( struct vfsmount * mnt , const struct path * root ) ;

void change_mnt_propagation ( struct vfsmount * mnt , int type ) ;

int propagate_mnt ( struct vfsmount * dest_mnt , struct dentry * dest_dentry , struct vfsmount * source_mnt , struct list_head * tree_list ) ;

int propagate_mount_busy ( struct vfsmount * mnt , int refcnt ) ;

int propagate_umount ( struct list_head * list ) ;

int drop_caches_sysctl_handler ( ctl_table * table , int write , void * buffer , size_t * length , loff_t * ppos ) ;

ssize_t splice_to_pipe ( struct pipe_inode_info * pipe , struct splice_pipe_desc * spd ) ;

ssize_t generic_file_splice_read ( struct file * in , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) ;

ssize_t default_file_splice_read ( struct file * in , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) ;

int pipe_to_file ( struct pipe_inode_info * pipe , struct pipe_buffer * buf , struct splice_desc * sd ) ;

int splice_from_pipe_feed ( struct pipe_inode_info * pipe , struct splice_desc * sd , splice_actor * actor ) ;

int splice_from_pipe_next ( struct pipe_inode_info * pipe , struct splice_desc * sd ) ;

void splice_from_pipe_begin ( struct splice_desc * sd ) ;

void splice_from_pipe_end ( struct pipe_inode_info * pipe , struct splice_desc * sd ) ;

ssize_t __splice_from_pipe ( struct pipe_inode_info * pipe , struct splice_desc * sd , splice_actor * actor ) ;

ssize_t splice_from_pipe ( struct pipe_inode_info * pipe , struct file * out , loff_t * ppos , size_t len , unsigned int flags , splice_actor * actor ) ;

ssize_t generic_file_splice_write ( struct pipe_inode_info * pipe , struct file * out , loff_t * ppos , size_t len , unsigned int flags ) ;

ssize_t generic_splice_sendpage ( struct pipe_inode_info * pipe , struct file * out , loff_t * ppos , size_t len , unsigned int flags ) ;

long do_splice_from ( struct pipe_inode_info * pipe , struct file * out , loff_t * ppos , size_t len , unsigned int flags ) ;

long do_splice_to ( struct file * in , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) ;

ssize_t splice_direct_to_actor ( struct file * in , struct splice_desc * sd , splice_direct_actor * actor ) ;

long do_splice_direct ( struct file * in , loff_t * ppos , struct file * out , size_t len , unsigned int flags ) ;

long sys_vmsplice ( int fd , const struct iovec * iov , unsigned long nr_segs , unsigned int flags ) ;

long sys_splice ( int fd_in , loff_t * off_in , int fd_out , loff_t * off_out , size_t len , unsigned int flags ) ;

long sys_tee ( int fdin , int fdout , size_t len , unsigned int flags ) ;

int sync_filesystem ( struct super_block * sb ) ;

long sys_sync ( void ) ;

void emergency_sync ( void ) ;

int file_fsync ( struct file * filp , struct dentry * dentry , int datasync ) ;

int vfs_fsync_range ( struct file * file , struct dentry * dentry , loff_t start , loff_t end , int datasync ) ;

int vfs_fsync ( struct file * file , struct dentry * dentry , int datasync ) ;

long sys_fsync ( unsigned int fd ) ;

long sys_fdatasync ( unsigned int fd ) ;

int generic_write_sync ( struct file * file , loff_t pos , loff_t count ) ;

long sys_sync_file_range ( int fd , loff_t offset , loff_t nbytes , unsigned int flags ) ;

long sys_sync_file_range2 ( int fd , unsigned int flags , loff_t offset , loff_t nbytes ) ;

int do_sync_mapping_range ( struct address_space * mapping , loff_t offset , loff_t endbyte , unsigned int flags ) ;

long sys_utime ( char * filename , struct utimbuf * times ) ;

long do_utimes ( int dfd , char * filename , struct timespec * times , int flags ) ;

long sys_utimensat ( int dfd , char * filename , struct timespec * utimes , int flags ) ;

long sys_futimesat ( int dfd , char * filename , struct timeval * utimes ) ;

long sys_utimes ( char * filename , struct timeval * utimes ) ;

void fsstack_copy_inode_size ( struct inode * dst , const struct inode * src ) ;

void fsstack_copy_attr_all ( struct inode * dest , const struct inode * src , int ( * get_nlinks ) ( struct inode * ) ) ;

void set_fs_root ( struct fs_struct * fs , struct path * path ) ;

void set_fs_pwd ( struct fs_struct * fs , struct path * path ) ;

void chroot_fs_refs ( struct path * old_root , struct path * new_root ) ;

void free_fs_struct ( struct fs_struct * fs ) ;

void exit_fs ( struct task_struct * tsk ) ;

struct fs_struct * copy_fs_struct ( struct fs_struct * old ) ;

int unshare_fs_struct ( void ) ;

int current_umask ( void ) ;

void daemonize_fs_struct ( void ) ;

void __lock_buffer ( struct buffer_head * bh ) ;

void unlock_buffer ( struct buffer_head * bh ) ;

void __wait_on_buffer ( struct buffer_head * bh ) ;

void end_buffer_read_sync ( struct buffer_head * bh , int uptodate ) ;

void end_buffer_write_sync ( struct buffer_head * bh , int uptodate ) ;

void invalidate_bdev ( struct block_device * bdev ) ;

void end_buffer_async_write ( struct buffer_head * bh , int uptodate ) ;

void mark_buffer_async_write ( struct buffer_head * bh ) ;

int inode_has_buffers ( struct inode * inode ) ;

void emergency_thaw_all ( void ) ;

int sync_mapping_buffers ( struct address_space * mapping ) ;

void write_boundary_block ( struct block_device * bdev , sector_t bblock , unsigned blocksize ) ;

void mark_buffer_dirty_inode ( struct buffer_head * bh , struct inode * inode ) ;

int __set_page_dirty_buffers ( struct page * page ) ;

void invalidate_inode_buffers ( struct inode * inode ) ;

int remove_inode_buffers ( struct inode * inode ) ;

struct buffer_head * alloc_page_buffers ( struct page * page , unsigned long size , int retry ) ;

void mark_buffer_dirty ( struct buffer_head * bh ) ;

void __brelse ( struct buffer_head * buf ) ;

void __bforget ( struct buffer_head * bh ) ;

struct bh_lru { struct buffer_head * bhs [ 8 ] ; } ;

struct buffer_head * __find_get_block ( struct block_device * bdev , sector_t block , unsigned size ) ;

struct buffer_head * __getblk ( struct block_device * bdev , sector_t block , unsigned size ) ;

void __breadahead ( struct block_device * bdev , sector_t block , unsigned size ) ;

struct buffer_head * __bread ( struct block_device * bdev , sector_t block , unsigned size ) ;

void invalidate_bh_lrus ( void ) ;

void set_bh_page ( struct buffer_head * bh , struct page * page , unsigned long offset ) ;

void block_invalidatepage ( struct page * page , unsigned long offset ) ;

void create_empty_buffers ( struct page * page , unsigned long blocksize , unsigned long b_state ) ;

void unmap_underlying_metadata ( struct block_device * bdev , sector_t block ) ;

void page_zero_new_buffers ( struct page * page , unsigned from , unsigned to ) ;

int block_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata , get_block_t * get_block ) ;

int block_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) ;

int generic_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) ;

int block_is_partially_uptodate ( struct page * page , read_descriptor_t * desc , unsigned long from ) ;

int block_read_full_page ( struct page * page , get_block_t * get_block ) ;

int generic_cont_expand_simple ( struct inode * inode , loff_t size ) ;

int cont_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata , get_block_t * get_block , loff_t * bytes ) ;

int block_prepare_write ( struct page * page , unsigned from , unsigned to , get_block_t * get_block ) ;

int block_commit_write ( struct page * page , unsigned from , unsigned to ) ;

int block_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf , get_block_t get_block ) ;

int nobh_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata , get_block_t * get_block ) ;

int nobh_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) ;

int nobh_writepage ( struct page * page , get_block_t * get_block , struct writeback_control * wbc ) ;

int nobh_truncate_page ( struct address_space * mapping , loff_t from , get_block_t * get_block ) ;

int block_truncate_page ( struct address_space * mapping , loff_t from , get_block_t * get_block ) ;

int block_write_full_page_endio ( struct page * page , get_block_t * get_block , struct writeback_control * wbc , bh_end_io_t * handler ) ;

int block_write_full_page ( struct page * page , get_block_t * get_block , struct writeback_control * wbc ) ;

sector_t generic_block_bmap ( struct address_space * mapping , sector_t block , get_block_t * get_block ) ;

int submit_bh ( int rw , struct buffer_head * bh ) ;

void ll_rw_block ( int rw , int nr , struct buffer_head * bhs [ ] ) ;

int sync_dirty_buffer ( struct buffer_head * bh ) ;

int try_to_free_buffers ( struct page * page ) ;

void block_sync_page ( struct page * page ) ;

long sys_bdflush ( int func , long data ) ;

struct bh_accounting { int nr ; int ratelimit ; } ;

struct buffer_head * alloc_buffer_head ( gfp_t gfp_flags ) ;

void free_buffer_head ( struct buffer_head * bh ) ;

int bh_uptodate_or_lock ( struct buffer_head * bh ) ;

int bh_submit_read ( struct buffer_head * bh ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) buffer_init ( void ) ;

typedef struct sg_iovec { void * iov_base ; size_t iov_len ; } sg_iovec_t ;

typedef struct sg_io_hdr { int interface_id ; int dxfer_direction ; unsigned char cmd_len ; unsigned char mx_sb_len ; unsigned short iovec_count ; unsigned int dxfer_len ; void * dxferp ; unsigned char * cmdp ; void * sbp ; unsigned int timeout ; unsigned int flags ; int pack_id ; void * usr_ptr ; unsigned char status ; unsigned char masked_status ; unsigned char msg_status ; unsigned char sb_len_wr ; unsigned short host_status ; unsigned short driver_status ; int resid ; unsigned int duration ; unsigned int info ; } sg_io_hdr_t ;


typedef struct sg_scsi_id { int host_no ; int channel ; int scsi_id ; int lun ; int scsi_type ; short h_cmd_per_lun ; short d_queue_depth ; int unused [ 2 ] ; } sg_scsi_id_t ;


typedef struct sg_req_info { char req_state ; char orphan ; char sg_io_owned ; char problem ; int pack_id ; void * usr_ptr ; unsigned int duration ; int unused ; } sg_req_info_t ;

typedef struct sg_io_hdr Sg_io_hdr ;

typedef struct sg_io_vec Sg_io_vec ;

typedef struct sg_scsi_id Sg_scsi_id ;

typedef struct sg_req_info Sg_req_info ;

struct sg_header { int pack_len ; int reply_len ; int pack_id ; int result ; unsigned int twelve_byte : 1 ; unsigned int target_status : 5 ; unsigned int host_status : 8 ; unsigned int driver_status : 8 ; unsigned int other_flags : 10 ; unsigned char sense_buffer [ 16 ] ; } ;

struct bio_slab { struct kmem_cache * slab ; unsigned int slab_ref ; unsigned int slab_size ; char name [ 8 ] ; } ;

unsigned int bvec_nr_vecs ( unsigned short idx ) ;

void bvec_free_bs ( struct bio_set * bs , struct bio_vec * bv , unsigned int idx ) ;

struct bio_vec * bvec_alloc_bs ( gfp_t gfp_mask , int nr , unsigned long * idx , struct bio_set * bs ) ;

void bio_free ( struct bio * bio , struct bio_set * bs ) ;

void bio_init ( struct bio * bio ) ;

struct bio * bio_alloc_bioset ( gfp_t gfp_mask , int nr_iovecs , struct bio_set * bs ) ;

struct bio * bio_alloc ( gfp_t gfp_mask , int nr_iovecs ) ;

struct bio * bio_kmalloc ( gfp_t gfp_mask , int nr_iovecs ) ;

void zero_fill_bio ( struct bio * bio ) ;

void bio_put ( struct bio * bio ) ;

void __bio_clone ( struct bio * bio , struct bio * bio_src ) ;

struct bio * bio_clone ( struct bio * bio , gfp_t gfp_mask ) ;

int bio_get_nr_vecs ( struct block_device * bdev ) ;

int bio_add_pc_page ( struct request_queue * q , struct bio * bio , struct page * page , unsigned int len , unsigned int offset ) ;

int bio_add_page ( struct bio * bio , struct page * page , unsigned int len , unsigned int offset ) ;

struct bio_map_data { struct bio_vec * iovecs ; struct sg_iovec * sgvecs ; int nr_sgvecs ; int is_our_pages ; } ;

int bio_uncopy_user ( struct bio * bio ) ;

struct bio * bio_copy_user_iov ( struct request_queue * q , struct rq_map_data * map_data , struct sg_iovec * iov , int iov_count , int write_to_vm , gfp_t gfp_mask ) ;

struct bio * bio_copy_user ( struct request_queue * q , struct rq_map_data * map_data , unsigned long uaddr , unsigned int len , int write_to_vm , gfp_t gfp_mask ) ;

struct bio * bio_map_user ( struct request_queue * q , struct block_device * bdev , unsigned long uaddr , unsigned int len , int write_to_vm , gfp_t gfp_mask ) ;

struct bio * bio_map_user_iov ( struct request_queue * q , struct block_device * bdev , struct sg_iovec * iov , int iov_count , int write_to_vm , gfp_t gfp_mask ) ;

void bio_unmap_user ( struct bio * bio ) ;

struct bio * bio_map_kern ( struct request_queue * q , void * data , unsigned int len , gfp_t gfp_mask ) ;

struct bio * bio_copy_kern ( struct request_queue * q , void * data , unsigned int len , gfp_t gfp_mask , int reading ) ;

void bio_set_pages_dirty ( struct bio * bio ) ;

void bio_check_pages_dirty ( struct bio * bio ) ;

void bio_endio ( struct bio * bio , int error ) ;

void bio_pair_release ( struct bio_pair * bp ) ;

struct bio_pair * bio_split ( struct bio * bi , int first_sectors ) ;

sector_t bio_sector_offset ( struct bio * bio , unsigned short index , unsigned int offset ) ;

void bioset_free ( struct bio_set * bs ) ;

struct bio_set * bioset_create ( unsigned int pool_size , unsigned int front_pad ) ;

struct blkpg_ioctl_arg { int op ; int flags ; int datalen ; void * data ; } ;

struct blkpg_partition { long long start ; long long length ; int pno ; char devname [ 64 ] ; char volname [ 64 ] ; } ;

struct bdev_inode { struct block_device bdev ; struct inode vfs_inode ; } ;

int set_blocksize ( struct block_device * bdev , int size ) ;

int sb_set_blocksize ( struct super_block * sb , int size ) ;

int sb_min_blocksize ( struct super_block * sb , int size ) ;

int __sync_blockdev ( struct block_device * bdev , int wait ) ;

int sync_blockdev ( struct block_device * bdev ) ;

int fsync_bdev ( struct block_device * bdev ) ;

struct super_block * freeze_bdev ( struct block_device * bdev ) ;

int thaw_bdev ( struct block_device * bdev , struct super_block * sb ) ;

int block_fsync ( struct file * filp , struct dentry * dentry , int datasync ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) bdev_cache_init ( void ) ;

struct block_device * bdget ( dev_t dev ) ;

struct block_device * bdgrab ( struct block_device * bdev ) ;

long nr_blockdev_pages ( void ) ;

void bdput ( struct block_device * bdev ) ;

void bd_forget ( struct inode * inode ) ;

int bd_claim ( struct block_device * bdev , void * holder ) ;

void bd_release ( struct block_device * bdev ) ;

struct bd_holder { struct list_head list ; int count ; struct kobject * sdir ; struct kobject * hdev ; struct kobject * hdir ; struct kobject * sdev ; } ;

int bd_claim_by_disk ( struct block_device * bdev , void * holder , struct gendisk * disk ) ;

void bd_release_from_disk ( struct block_device * bdev , struct gendisk * disk ) ;

struct block_device * open_by_devnum ( dev_t dev , fmode_t mode ) ;

void check_disk_size_change ( struct gendisk * disk , struct block_device * bdev ) ;

int revalidate_disk ( struct gendisk * disk ) ;

int check_disk_change ( struct block_device * bdev ) ;

void bd_set_size ( struct block_device * bdev , loff_t size ) ;

int blkdev_get ( struct block_device * bdev , fmode_t mode ) ;

int blkdev_put ( struct block_device * bdev , fmode_t mode ) ;

ssize_t blkdev_aio_write ( struct kiocb * iocb , const struct iovec * iov , unsigned long nr_segs , loff_t pos ) ;

int ioctl_by_bdev ( struct block_device * bdev , unsigned cmd , unsigned long arg ) ;

struct block_device * lookup_bdev ( const char * pathname ) ;

struct block_device * open_bdev_exclusive ( const char * path , fmode_t mode , void * holder ) ;

void close_bdev_exclusive ( struct block_device * bdev , fmode_t mode ) ;

int __invalidate_device ( struct block_device * bdev ) ;

struct dio { struct bio * bio ; struct inode * inode ; int rw ; loff_t i_size ; int lock_type ; unsigned blkbits ; unsigned blkfactor ; unsigned start_zero_done ; int pages_in_io ; size_t size ; sector_t block_in_file ; unsigned blocks_available ; sector_t final_block_in_request ; unsigned first_block_in_page ; int boundary ; int reap_counter ; get_block_t * get_block ; dio_iodone_t * end_io ; sector_t final_block_in_bio ; sector_t next_block_for_io ; struct buffer_head map_bh ; struct page * cur_page ; unsigned cur_page_offset ; unsigned cur_page_len ; sector_t cur_page_block ; int curr_page ; int total_pages ; unsigned long curr_user_address ; struct page * pages [ 64 ] ; unsigned head ; unsigned tail ; int page_errors ; spinlock_t bio_lock ; unsigned long refcount ; struct bio * bio_list ; struct task_struct * waiter ; struct kiocb * iocb ; int is_async ; int io_error ; ssize_t result ; } ;

ssize_t __blockdev_direct_IO ( int rw , struct kiocb * iocb , struct inode * inode , struct block_device * bdev , const struct iovec * iov , loff_t offset , unsigned long nr_segs , get_block_t get_block , dio_iodone_t end_io , int dio_lock_type ) ;

int mpage_readpages ( struct address_space * mapping , struct list_head * pages , unsigned nr_pages , get_block_t get_block ) ;

int mpage_readpage ( struct page * page , get_block_t get_block ) ;

struct mpage_data { struct bio * bio ; sector_t last_block_in_bio ; get_block_t * get_block ; unsigned use_writepage ; } ;

int mpage_writepages ( struct address_space * mapping , struct writeback_control * wbc , get_block_t get_block ) ;

int mpage_writepage ( struct page * page , get_block_t get_block , struct writeback_control * wbc ) ;

int set_task_ioprio ( struct task_struct * task , int ioprio ) ;

long sys_ioprio_set ( int which , int who , int ioprio ) ;

int ioprio_best ( unsigned short aprio , unsigned short bprio ) ;

long sys_ioprio_get ( int which , int who ) ;

struct integrity_slab { struct kmem_cache * slab ; unsigned short nr_vecs ; char name [ 8 ] ; } ;

struct bio_integrity_payload * bio_integrity_alloc_bioset ( struct bio * bio , gfp_t gfp_mask , unsigned int nr_vecs , struct bio_set * bs ) ;

struct bio_integrity_payload * bio_integrity_alloc ( struct bio * bio , gfp_t gfp_mask , unsigned int nr_vecs ) ;

void bio_integrity_free ( struct bio * bio , struct bio_set * bs ) ;

int bio_integrity_add_page ( struct bio * bio , struct page * page , unsigned int len , unsigned int offset ) ;

int bio_integrity_enabled ( struct bio * bio ) ;

unsigned int bio_integrity_tag_size ( struct bio * bio ) ;

int bio_integrity_tag ( struct bio * bio , void * tag_buf , unsigned int len , int set ) ;

int bio_integrity_set_tag ( struct bio * bio , void * tag_buf , unsigned int len ) ;

int bio_integrity_get_tag ( struct bio * bio , void * tag_buf , unsigned int len ) ;

int bio_integrity_prep ( struct bio * bio ) ;

void bio_integrity_endio ( struct bio * bio , int error ) ;

void bio_integrity_mark_head ( struct bio_integrity_payload * bip , unsigned int skip ) ;

void bio_integrity_mark_tail ( struct bio_integrity_payload * bip , unsigned int len ) ;

void bio_integrity_advance ( struct bio * bio , unsigned int bytes_done ) ;

void bio_integrity_trim ( struct bio * bio , unsigned int offset , unsigned int sectors ) ;

void bio_integrity_split ( struct bio * bio , struct bio_pair * bp , int sectors ) ;

int bio_integrity_clone ( struct bio * bio , struct bio * bio_src , gfp_t gfp_mask , struct bio_set * bs ) ;

int bioset_integrity_create ( struct bio_set * bs , int pool_size ) ;

void bioset_integrity_free ( struct bio_set * bs ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) bio_integrity_init ( void ) ;

struct extent_state ;

typedef int ( extent_submit_bio_hook_t ) ( struct inode * inode , int rw , struct bio * bio , int mirror_num , unsigned long bio_flags ) ;
struct extent_io_ops { int ( * fill_delalloc ) ( struct inode * inode , struct page * locked_page , u64 start , u64 end , int * page_started , unsigned long * nr_written ) ; int ( * writepage_start_hook ) ( struct page * page , u64 start , u64 end ) ; int ( * writepage_io_hook ) ( struct page * page , u64 start , u64 end ) ; extent_submit_bio_hook_t * submit_bio_hook ; int ( * merge_bio_hook ) ( struct page * page , unsigned long offset , size_t size , struct bio * bio , unsigned long bio_flags ) ; int ( * readpage_io_hook ) ( struct page * page , u64 start , u64 end ) ; int ( * readpage_io_failed_hook ) ( struct bio * bio , struct page * page , u64 start , u64 end , struct extent_state * state ) ; int ( * writepage_io_failed_hook ) ( struct bio * bio , struct page * page , u64 start , u64 end , struct extent_state * state ) ; int ( * readpage_end_io_hook ) ( struct page * page , u64 start , u64 end , struct extent_state * state ) ; int ( * writepage_end_io_hook ) ( struct page * page , u64 start , u64 end , struct extent_state * state , int uptodate ) ; int ( * set_bit_hook ) ( struct inode * inode , u64 start , u64 end , unsigned long old , unsigned long bits ) ; int ( * clear_bit_hook ) ( struct inode * inode , struct extent_state * state , unsigned long bits ) ; int ( * merge_extent_hook ) ( struct inode * inode , struct extent_state * new , struct extent_state * other ) ; int ( * split_extent_hook ) ( struct inode * inode , struct extent_state * orig , u64 split ) ; int ( * write_cache_pages_lock_hook ) ( struct page * page ) ; } ;

struct extent_io_tree { struct rb_root state ; struct rb_root buffer ; struct address_space * mapping ; u64 dirty_bytes ; spinlock_t lock ; spinlock_t buffer_lock ; struct extent_io_ops * ops ; } ;

struct extent_state { u64 start ; u64 end ; struct rb_node rb_node ; struct extent_io_tree * tree ; wait_queue_head_t wq ; atomic_t refs ; unsigned long state ; u64 split_start ; u64 split_end ; u64 private ; struct list_head leak_list ; } ;
struct extent_buffer { u64 start ; unsigned long len ; char * map_token ; char * kaddr ; unsigned long map_start ; unsigned long map_len ; struct page * first_page ; unsigned long bflags ; atomic_t refs ; struct list_head leak_list ; struct rb_node rb_node ; spinlock_t lock ; wait_queue_head_t lock_wq ; } ;

struct extent_map_tree ;

typedef struct extent_map * ( get_extent_t ) ( struct inode * inode , struct page * page , size_t page_offset , u64 start , u64 len , int create ) ;

struct extent_map { struct rb_node rb_node ; u64 start ; u64 len ; u64 orig_start ; u64 block_start ; u64 block_len ; unsigned long flags ; struct block_device * bdev ; atomic_t refs ; int in_tree ; } ;

struct extent_map_tree { struct rb_root map ; rwlock_t lock ; } ;
struct btrfs_worker_thread ;

struct btrfs_work { void ( * func ) ( struct btrfs_work * work ) ; void ( * ordered_func ) ( struct btrfs_work * work ) ; void ( * ordered_free ) ( struct btrfs_work * work ) ; unsigned long flags ; struct btrfs_worker_thread * worker ; struct list_head list ; struct list_head order_list ; } ;

struct btrfs_workers { int num_workers ; int num_workers_starting ; int max_workers ; int idle_thresh ; int ordered ; int atomic_start_pending ; struct btrfs_workers * atomic_worker_start ; struct list_head worker_list ; struct list_head idle_list ; struct list_head order_list ; struct list_head prio_order_list ; spinlock_t lock ; spinlock_t order_lock ; char * name ; } ;

struct btrfs_trans_handle ;

struct btrfs_transaction ;

struct btrfs_ordered_sum ;

struct btrfs_disk_key { __le64 objectid ; u8 type ; __le64 offset ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_key { u64 objectid ; u8 type ; u64 offset ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_mapping_tree { struct extent_map_tree map_tree ; } ;

struct btrfs_dev_item { __le64 devid ; __le64 total_bytes ; __le64 bytes_used ; __le32 io_align ; __le32 io_width ; __le32 sector_size ; __le64 type ; __le64 generation ; __le64 start_offset ; __le32 dev_group ; u8 seek_speed ; u8 bandwidth ; u8 uuid [ 16 ] ; u8 fsid [ 16 ] ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_stripe { __le64 devid ; __le64 offset ; u8 dev_uuid [ 16 ] ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_chunk { __le64 length ; __le64 owner ; __le64 stripe_len ; __le64 type ; __le32 io_align ; __le32 io_width ; __le32 sector_size ; __le16 num_stripes ; __le16 sub_stripes ; struct btrfs_stripe stripe ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_header { u8 csum [ 32 ] ; u8 fsid [ 16 ] ; __le64 bytenr ; __le64 flags ; u8 chunk_tree_uuid [ 16 ] ; __le64 generation ; __le64 owner ; __le32 nritems ; u8 level ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_super_block { u8 csum [ 32 ] ; u8 fsid [ 16 ] ; __le64 bytenr ; __le64 flags ; __le64 magic ; __le64 generation ; __le64 root ; __le64 chunk_root ; __le64 log_root ; __le64 log_root_transid ; __le64 total_bytes ; __le64 bytes_used ; __le64 root_dir_objectid ; __le64 num_devices ; __le32 sectorsize ; __le32 nodesize ; __le32 leafsize ; __le32 stripesize ; __le32 sys_chunk_array_size ; __le64 chunk_root_generation ; __le64 compat_flags ; __le64 compat_ro_flags ; __le64 incompat_flags ; __le16 csum_type ; u8 root_level ; u8 chunk_root_level ; u8 log_root_level ; struct btrfs_dev_item dev_item ; char label [ 256 ] ; __le64 reserved [ 32 ] ; u8 sys_chunk_array [ 2048 ] ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_item { struct btrfs_disk_key key ; __le32 offset ; __le32 size ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_leaf { struct btrfs_header header ; struct btrfs_item items [ ] ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_key_ptr { struct btrfs_disk_key key ; __le64 blockptr ; __le64 generation ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_node { struct btrfs_header header ; struct btrfs_key_ptr ptrs [ ] ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_path { struct extent_buffer * nodes [ 8 ] ; int slots [ 8 ] ; int locks [ 8 ] ; int reada ; int lowest_level ; unsigned int search_for_split : 1 ; unsigned int keep_locks : 1 ; unsigned int skip_locking : 1 ; unsigned int leave_spinning : 1 ; unsigned int search_commit_root : 1 ; } ;

struct btrfs_extent_item { __le64 refs ; __le64 generation ; __le64 flags ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_extent_item_v0 { __le32 refs ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_tree_block_info { struct btrfs_disk_key key ; u8 level ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_extent_data_ref { __le64 root ; __le64 objectid ; __le64 offset ; __le32 count ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_shared_data_ref { __le32 count ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_extent_inline_ref { u8 type ; __le64 offset ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_extent_ref_v0 { __le64 root ; __le64 generation ; __le64 objectid ; __le32 count ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_dev_extent { __le64 chunk_tree ; __le64 chunk_objectid ; __le64 chunk_offset ; __le64 length ; u8 chunk_tree_uuid [ 16 ] ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_inode_ref { __le64 index ; __le16 name_len ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_timespec { __le64 sec ; __le32 nsec ; } __attribute__ ( ( __packed__ ) ) ;
enum btrfs_compression_type { BTRFS_COMPRESS_NONE = 0 , BTRFS_COMPRESS_ZLIB = 1 , BTRFS_COMPRESS_LAST = 2 , } ;

struct btrfs_inode_item { __le64 generation ; __le64 transid ; __le64 size ; __le64 nbytes ; __le64 block_group ; __le32 nlink ; __le32 uid ; __le32 gid ; __le32 mode ; __le64 rdev ; __le64 flags ; __le64 sequence ; __le64 reserved [ 4 ] ; struct btrfs_timespec atime ; struct btrfs_timespec ctime ; struct btrfs_timespec mtime ; struct btrfs_timespec otime ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_dir_log_item { __le64 end ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_dir_item { struct btrfs_disk_key location ; __le64 transid ; __le16 data_len ; __le16 name_len ; u8 type ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_root_item { struct btrfs_inode_item inode ; __le64 generation ; __le64 root_dirid ; __le64 bytenr ; __le64 byte_limit ; __le64 bytes_used ; __le64 last_snapshot ; __le64 flags ; __le32 refs ; struct btrfs_disk_key drop_progress ; u8 drop_level ; u8 level ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_root_ref { __le64 dirid ; __le64 sequence ; __le16 name_len ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_file_extent_item { __le64 generation ; __le64 ram_bytes ; u8 compression ; u8 encryption ; __le16 other_encoding ; u8 type ; __le64 disk_bytenr ; __le64 disk_num_bytes ; __le64 offset ; __le64 num_bytes ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_csum_item { u8 csum ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_block_group_item { __le64 used ; __le64 chunk_objectid ; __le64 flags ; } __attribute__ ( ( __packed__ ) ) ;
struct btrfs_space_info { u64 flags ; u64 total_bytes ; u64 bytes_used ; u64 bytes_pinned ; u64 bytes_reserved ; u64 bytes_readonly ; u64 bytes_super ; u64 bytes_root ; u64 bytes_may_use ; u64 bytes_delalloc ; int full ; int force_alloc ; int force_delalloc ; struct list_head list ; wait_queue_head_t allocate_wait ; wait_queue_head_t flush_wait ; int allocating_chunk ; int flushing ; struct list_head block_groups ; spinlock_t lock ; struct rw_semaphore groups_sem ; atomic_t caching_threads ; } ;

struct btrfs_free_cluster { spinlock_t lock ; spinlock_t refill_lock ; struct rb_root root ; u64 max_size ; u64 window_start ; bool points_to_bitmap ; struct btrfs_block_group_cache * block_group ; struct list_head block_group_list ; } ;

enum btrfs_caching_type { BTRFS_CACHE_NO = 0 , BTRFS_CACHE_STARTED = 1 , BTRFS_CACHE_FINISHED = 2 , } ;

struct btrfs_caching_control { struct list_head list ; struct mutex mutex ; wait_queue_head_t wait ; struct btrfs_block_group_cache * block_group ; u64 progress ; atomic_t count ; } ;

struct btrfs_block_group_cache { struct btrfs_key key ; struct btrfs_block_group_item item ; struct btrfs_fs_info * fs_info ; spinlock_t lock ; u64 pinned ; u64 reserved ; u64 bytes_super ; u64 flags ; u64 sectorsize ; int extents_thresh ; int free_extents ; int total_bitmaps ; int ro ; int dirty ; int cached ; struct btrfs_caching_control * caching_ctl ; u64 last_byte_to_unpin ; struct btrfs_space_info * space_info ; spinlock_t tree_lock ; struct rb_root free_space_offset ; u64 free_space ; struct rb_node cache_node ; struct list_head list ; atomic_t count ; struct list_head cluster_list ; } ;

struct reloc_control ;

struct btrfs_device ;

struct btrfs_fs_devices ;

struct btrfs_fs_info { u8 fsid [ 16 ] ; u8 chunk_tree_uuid [ 16 ] ; struct btrfs_root * extent_root ; struct btrfs_root * tree_root ; struct btrfs_root * chunk_root ; struct btrfs_root * dev_root ; struct btrfs_root * fs_root ; struct btrfs_root * csum_root ; struct btrfs_root * log_root_tree ; spinlock_t fs_roots_radix_lock ; struct radix_tree_root fs_roots_radix ; spinlock_t block_group_cache_lock ; struct rb_root block_group_cache_tree ; struct extent_io_tree freed_extents [ 2 ] ; struct extent_io_tree * pinned_extents ; struct btrfs_mapping_tree mapping_tree ; u64 generation ; u64 last_trans_committed ; u64 last_trans_log_full_commit ; u64 open_ioctl_trans ; unsigned long mount_opt ; u64 max_extent ; u64 max_inline ; u64 alloc_start ; struct btrfs_transaction * running_transaction ; wait_queue_head_t transaction_throttle ; wait_queue_head_t transaction_wait ; wait_queue_head_t async_submit_wait ; struct btrfs_super_block super_copy ; struct btrfs_super_block super_for_commit ; struct block_device * __bdev ; struct super_block * sb ; struct inode * btree_inode ; struct backing_dev_info bdi ; struct mutex trans_mutex ; struct mutex tree_log_mutex ; struct mutex transaction_kthread_mutex ; struct mutex cleaner_mutex ; struct mutex chunk_mutex ; struct mutex volume_mutex ; struct mutex ordered_operations_mutex ; struct rw_semaphore extent_commit_sem ; struct rw_semaphore cleanup_work_sem ; struct rw_semaphore subvol_sem ; struct srcu_struct subvol_srcu ; struct list_head trans_list ; struct list_head hashers ; struct list_head dead_roots ; struct list_head caching_block_groups ; spinlock_t delayed_iput_lock ; struct list_head delayed_iputs ; atomic_t nr_async_submits ; atomic_t async_submit_draining ; atomic_t nr_async_bios ; atomic_t async_delalloc_pages ; spinlock_t ordered_extent_lock ; struct list_head ordered_extents ; struct list_head delalloc_inodes ; struct list_head ordered_operations ; struct btrfs_workers generic_worker ; struct btrfs_workers workers ; struct btrfs_workers delalloc_workers ; struct btrfs_workers endio_workers ; struct btrfs_workers endio_meta_workers ; struct btrfs_workers endio_meta_write_workers ; struct btrfs_workers endio_write_workers ; struct btrfs_workers submit_workers ; struct btrfs_workers enospc_workers ; struct btrfs_workers fixup_workers ; struct task_struct * transaction_kthread ; struct task_struct * cleaner_kthread ; int thread_pool_size ; struct kobject super_kobj ; struct completion kobj_unregister ; int do_barriers ; int closing ; int log_root_recovering ; u64 total_pinned ; u64 dirty_metadata_bytes ; struct list_head dirty_cowonly_roots ; struct btrfs_fs_devices * fs_devices ; struct list_head space_info ; struct reloc_control * reloc_ctl ; spinlock_t delalloc_lock ; spinlock_t new_trans_lock ; u64 delalloc_bytes ; struct btrfs_free_cluster data_alloc_cluster ; struct btrfs_free_cluster meta_alloc_cluster ; spinlock_t ref_cache_lock ; u64 total_ref_cache_size ; u64 avail_data_alloc_bits ; u64 avail_metadata_alloc_bits ; u64 avail_system_alloc_bits ; u64 data_alloc_profile ; u64 metadata_alloc_profile ; u64 system_alloc_profile ; unsigned data_chunk_allocations ; unsigned metadata_ratio ; void * bdev_holder ; } ;

struct btrfs_root { struct extent_buffer * node ; spinlock_t node_lock ; struct extent_buffer * commit_root ; struct btrfs_root * log_root ; struct btrfs_root * reloc_root ; struct btrfs_root_item root_item ; struct btrfs_key root_key ; struct btrfs_fs_info * fs_info ; struct extent_io_tree dirty_log_pages ; struct kobject root_kobj ; struct completion kobj_unregister ; struct mutex objectid_mutex ; struct mutex log_mutex ; wait_queue_head_t log_writer_wait ; wait_queue_head_t log_commit_wait [ 2 ] ; atomic_t log_writers ; atomic_t log_commit [ 2 ] ; unsigned long log_transid ; unsigned long last_log_commit ; unsigned long log_batch ; pid_t log_start_pid ; bool log_multiple_pids ; u64 objectid ; u64 last_trans ; u32 sectorsize ; u32 nodesize ; u32 leafsize ; u32 stripesize ; u32 type ; u64 highest_objectid ; int ref_cows ; int track_dirty ; int in_radix ; int clean_orphans ; u64 defrag_trans_start ; struct btrfs_key defrag_progress ; struct btrfs_key defrag_max ; int defrag_running ; char * name ; int in_sysfs ; struct list_head dirty_list ; struct list_head root_list ; spinlock_t list_lock ; struct list_head orphan_list ; spinlock_t inode_lock ; struct rb_root inode_tree ; struct super_block anon_super ; } ;

struct btrfs_ordered_inode_tree { struct mutex mutex ; struct rb_root tree ; struct rb_node * last ; } ;

struct btrfs_sector_sum { u64 bytenr ; u32 sum ; } ;

struct btrfs_ordered_sum { u64 bytenr ; unsigned long len ; struct list_head list ; struct btrfs_sector_sum sums [ ] ; } ;
struct btrfs_ordered_extent { u64 file_offset ; u64 start ; u64 len ; u64 disk_len ; u64 bytes_left ; unsigned long flags ; atomic_t refs ; struct inode * inode ; struct list_head list ; wait_queue_head_t wait ; struct rb_node rb_node ; struct list_head root_extent_list ; } ;

struct btrfs_inode { struct btrfs_root * root ; struct btrfs_key location ; struct extent_map_tree extent_tree ; struct extent_io_tree io_tree ; struct extent_io_tree io_failure_tree ; struct mutex log_mutex ; struct btrfs_ordered_inode_tree ordered_tree ; struct list_head i_orphan ; struct list_head delalloc_inodes ; struct list_head ordered_operations ; struct rb_node rb_node ; struct btrfs_space_info * space_info ; u64 generation ; u64 sequence ; u64 last_trans ; u64 last_sub_trans ; u64 logged_trans ; u64 delalloc_bytes ; u64 reserved_bytes ; u64 disk_i_size ; u32 flags ; u64 index_cnt ; u64 block_group ; u64 last_unlink_trans ; spinlock_t accounting_lock ; int reserved_extents ; int outstanding_extents ; unsigned ordered_data_close : 1 ; unsigned dummy_inode : 1 ; struct inode vfs_inode ; } ;

struct btrfs_delayed_ref_node { struct rb_node rb_node ; u64 bytenr ; u64 num_bytes ; atomic_t refs ; int ref_mod ; unsigned int action : 8 ; unsigned int type : 8 ; unsigned int is_head : 1 ; unsigned int in_tree : 1 ; } ;

struct btrfs_delayed_extent_op { struct btrfs_disk_key key ; u64 flags_to_set ; unsigned int update_key : 1 ; unsigned int update_flags : 1 ; unsigned int is_data : 1 ; } ;

struct btrfs_delayed_ref_head { struct btrfs_delayed_ref_node node ; struct mutex mutex ; struct list_head cluster ; struct btrfs_delayed_extent_op * extent_op ; unsigned int must_insert_reserved : 1 ; unsigned int is_data : 1 ; } ;

struct btrfs_delayed_tree_ref { struct btrfs_delayed_ref_node node ; union { u64 root ; u64 parent ; } ; int level ; } ;

struct btrfs_delayed_data_ref { struct btrfs_delayed_ref_node node ; union { u64 root ; u64 parent ; } ; u64 objectid ; u64 offset ; } ;

struct btrfs_delayed_ref_root { struct rb_root root ; spinlock_t lock ; unsigned long num_entries ; unsigned long num_heads ; unsigned long num_heads_ready ; int flushing ; u64 run_delayed_start ; } ;

struct btrfs_transaction { u64 transid ; unsigned long num_writers ; unsigned long num_joined ; int in_commit ; int use_count ; int commit_done ; int blocked ; struct list_head list ; struct extent_io_tree dirty_pages ; unsigned long start_time ; wait_queue_head_t writer_wait ; wait_queue_head_t commit_wait ; struct list_head pending_snapshots ; struct btrfs_delayed_ref_root delayed_refs ; } ;
struct btrfs_trans_handle { u64 transid ; unsigned long blocks_reserved ; unsigned long blocks_used ; struct btrfs_transaction * transaction ; u64 block_group ; u64 alloc_exclude_start ; u64 alloc_exclude_nr ; unsigned long delayed_ref_updates ; } ;
struct btrfs_pending_snapshot { struct dentry * dentry ; struct btrfs_root * root ; char * name ; struct btrfs_key root_key ; struct list_head list ; } ;

struct btrfs_ioctl_vol_args { __s64 fd ; char name [ 4087 + 1 ] ; } ;

struct btrfs_ioctl_clone_range_args { __s64 src_fd ; __u64 src_offset , src_length ; __u64 dest_offset ; } ;

struct btrfs_pending_bios { struct bio * head ; struct bio * tail ; } ;

struct btrfs_device { struct list_head dev_list ; struct list_head dev_alloc_list ; struct btrfs_fs_devices * fs_devices ; struct btrfs_root * dev_root ; struct btrfs_pending_bios pending_bios ; struct btrfs_pending_bios pending_sync_bios ; int running_pending ; u64 generation ; int barriers ; int writeable ; int in_fs_metadata ; spinlock_t io_lock ; struct block_device * bdev ; fmode_t mode ; char * name ; u64 devid ; u64 total_bytes ; u64 disk_total_bytes ; u64 bytes_used ; u32 io_align ; u32 io_width ; u32 sector_size ; u64 type ; u8 uuid [ 16 ] ; struct btrfs_work work ; } ;
struct btrfs_fs_devices { u8 fsid [ 16 ] ; u64 latest_devid ; u64 latest_trans ; u64 num_devices ; u64 open_devices ; u64 rw_devices ; u64 total_rw_bytes ; struct block_device * latest_bdev ; struct mutex device_list_mutex ; struct list_head devices ; struct list_head alloc_list ; struct list_head list ; struct btrfs_fs_devices * seed ; int seeding ; int opened ; int rotating ; } ;
struct btrfs_bio_stripe { struct btrfs_device * dev ; u64 physical ; } ;

struct btrfs_multi_bio { atomic_t stripes_pending ; bio_end_io_t * end_io ; struct bio * orig_bio ; void * private ; atomic_t error ; int max_errors ; int num_stripes ; struct btrfs_bio_stripe stripes [ ] ; } ;

struct btrfs_fid { u64 objectid ; u64 root_objectid ; u32 gen ; u64 parent_objectid ; u32 parent_gen ; u64 parent_root_objectid ; } __attribute__ ( ( packed ) ) ;
enum { Opt_degraded , Opt_subvol , Opt_device , Opt_nodatasum , Opt_nodatacow , Opt_max_extent , Opt_max_inline , Opt_alloc_start , Opt_nobarrier , Opt_ssd , Opt_nossd , Opt_ssd_spread , Opt_thread_pool , Opt_noacl , Opt_compress , Opt_notreelog , Opt_ratio , Opt_flushoncommit , Opt_discard , Opt_err , } ;
u64 btrfs_parse_size ( char * str ) ;

int btrfs_parse_options ( struct btrfs_root * root , char * options ) ;

int btrfs_sync_fs ( struct super_block * sb , int wait ) ;

struct btrfs_path * btrfs_alloc_path ( void ) ;

__attribute__ ( ( noinline ) ) void btrfs_set_path_blocking ( struct btrfs_path * p ) ;

__attribute__ ( ( noinline ) ) void btrfs_clear_path_blocking ( struct btrfs_path * p , struct extent_buffer * held ) ;

void btrfs_free_path ( struct btrfs_path * p ) ;

__attribute__ ( ( noinline ) ) void btrfs_release_path ( struct btrfs_root * root , struct btrfs_path * p ) ;

struct extent_buffer * btrfs_root_node ( struct btrfs_root * root ) ;

struct extent_buffer * btrfs_lock_root_node ( struct btrfs_root * root ) ;

int btrfs_copy_root ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct extent_buffer * buf , struct extent_buffer * * cow_ret , u64 new_root_objectid ) ;

int btrfs_block_can_be_shared ( struct btrfs_root * root , struct extent_buffer * buf ) ;

__attribute__ ( ( noinline ) ) int btrfs_cow_block ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct extent_buffer * buf , struct extent_buffer * parent , int parent_slot , struct extent_buffer * * cow_ret ) ;

int btrfs_comp_cpu_keys ( struct btrfs_key * k1 , struct btrfs_key * k2 ) ;

int btrfs_realloc_node ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct extent_buffer * parent , int start_slot , int cache_only , u64 * last_ret , struct btrfs_key * progress ) ;

int btrfs_bin_search ( struct extent_buffer * eb , struct btrfs_key * key , int level , int * slot ) ;

__attribute__ ( ( noinline ) ) void btrfs_unlock_up_safe ( struct btrfs_path * path , int level ) ;

int btrfs_search_slot ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_key * key , struct btrfs_path * p , int ins_len , int cow ) ;

int btrfs_set_item_key_safe ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , struct btrfs_key * new_key ) ;

__attribute__ ( ( noinline ) ) int btrfs_leaf_free_space ( struct btrfs_root * root , struct extent_buffer * leaf ) ;

int btrfs_split_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , struct btrfs_key * new_key , unsigned long split_offset ) ;

int btrfs_duplicate_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , struct btrfs_key * new_key ) ;

int btrfs_truncate_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , u32 new_size , int from_end ) ;

int btrfs_extend_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , u32 data_size ) ;

int btrfs_insert_some_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , struct btrfs_key * cpu_key , u32 * data_size , int nr ) ;

int btrfs_insert_empty_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , struct btrfs_key * cpu_key , u32 * data_size , int nr ) ;

int btrfs_insert_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_key * cpu_key , void * data , u32 data_size ) ;

int btrfs_del_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , int slot , int nr ) ;

int btrfs_prev_leaf ( struct btrfs_root * root , struct btrfs_path * path ) ;

int btrfs_search_forward ( struct btrfs_root * root , struct btrfs_key * min_key , struct btrfs_key * max_key , struct btrfs_path * path , int cache_only , u64 min_trans ) ;

int btrfs_find_next_key ( struct btrfs_root * root , struct btrfs_path * path , struct btrfs_key * key , int level , int cache_only , u64 min_trans ) ;

int btrfs_next_leaf ( struct btrfs_root * root , struct btrfs_path * path ) ;

int btrfs_previous_item ( struct btrfs_root * root , struct btrfs_path * path , u64 min_objectid , int type ) ;

struct btrfs_free_space { struct rb_node offset_index ; u64 offset ; u64 bytes ; unsigned long * bitmap ; struct list_head list ; } ;

void btrfs_get_block_group ( struct btrfs_block_group_cache * cache ) ;

void btrfs_put_block_group ( struct btrfs_block_group_cache * cache ) ;

struct btrfs_block_group_cache * btrfs_lookup_block_group ( struct btrfs_fs_info * info , u64 bytenr ) ;

void btrfs_clear_space_info_full ( struct btrfs_fs_info * info ) ;

u64 btrfs_find_block_group ( struct btrfs_root * root , u64 search_start , u64 search_hint , int owner ) ;

int btrfs_lookup_extent ( struct btrfs_root * root , u64 start , u64 len ) ;

int btrfs_inc_extent_ref ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 bytenr , u64 num_bytes , u64 parent , u64 root_objectid , u64 owner , u64 offset ) ;

int btrfs_run_delayed_refs ( struct btrfs_trans_handle * trans , struct btrfs_root * root , unsigned long count ) ;

int btrfs_set_disk_extent_flags ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 bytenr , u64 num_bytes , u64 flags , int is_data ) ;

int btrfs_cross_ref_exist ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 objectid , u64 offset , u64 bytenr ) ;

int btrfs_inc_ref ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct extent_buffer * buf , int full_backref ) ;

int btrfs_dec_ref ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct extent_buffer * buf , int full_backref ) ;

int btrfs_write_dirty_block_groups ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_extent_readonly ( struct btrfs_root * root , u64 bytenr ) ;

u64 btrfs_reduce_alloc_profile ( struct btrfs_root * root , u64 flags ) ;

void btrfs_set_inode_space_info ( struct btrfs_root * root , struct inode * inode ) ;

int btrfs_unreserve_metadata_for_delalloc ( struct btrfs_root * root , struct inode * inode , int num_items ) ;

struct async_flush { struct btrfs_root * root ; struct btrfs_space_info * info ; struct btrfs_work work ; } ;

int btrfs_reserve_metadata_for_delalloc ( struct btrfs_root * root , struct inode * inode , int num_items ) ;

int btrfs_unreserve_metadata_space ( struct btrfs_root * root , int num_items ) ;

int btrfs_reserve_metadata_space ( struct btrfs_root * root , int num_items ) ;

int btrfs_check_data_free_space ( struct btrfs_root * root , struct inode * inode , u64 bytes ) ;

void btrfs_free_reserved_data_space ( struct btrfs_root * root , struct inode * inode , u64 bytes ) ;

void btrfs_delalloc_reserve_space ( struct btrfs_root * root , struct inode * inode , u64 bytes ) ;

void btrfs_delalloc_free_space ( struct btrfs_root * root , struct inode * inode , u64 bytes ) ;

int btrfs_pin_extent ( struct btrfs_root * root , u64 bytenr , u64 num_bytes , int reserved ) ;

int btrfs_prepare_extent_commit ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_finish_extent_commit ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_free_extent ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 bytenr , u64 num_bytes , u64 parent , u64 root_objectid , u64 owner , u64 offset ) ;

int btrfs_free_tree_block ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 bytenr , u32 blocksize , u64 parent , u64 root_objectid , int level ) ;

enum btrfs_loop_type { LOOP_FIND_IDEAL = 0 , LOOP_CACHING_NOWAIT = 1 , LOOP_CACHING_WAIT = 2 , LOOP_ALLOC_CHUNK = 3 , LOOP_NO_EMPTY_SIZE = 4 , } ;

int btrfs_reserve_extent ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 num_bytes , u64 min_alloc_size , u64 empty_size , u64 hint_byte , u64 search_end , struct btrfs_key * ins , u64 data ) ;

int btrfs_free_reserved_extent ( struct btrfs_root * root , u64 start , u64 len ) ;

int btrfs_alloc_reserved_file_extent ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 root_objectid , u64 owner , u64 offset , struct btrfs_key * ins ) ;

int btrfs_alloc_logged_file_extent ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 root_objectid , u64 owner , u64 offset , struct btrfs_key * ins ) ;

struct extent_buffer * btrfs_init_new_buffer ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 bytenr , u32 blocksize , int level ) ;

struct extent_buffer * btrfs_alloc_free_block ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u32 blocksize , u64 parent , u64 root_objectid , struct btrfs_disk_key * key , int level , u64 hint , u64 empty_size ) ;

struct walk_control { u64 refs [ 8 ] ; u64 flags [ 8 ] ; struct btrfs_key update_progress ; int stage ; int level ; int shared_level ; int update_ref ; int keep_locks ; int reada_slot ; int reada_count ; } ;

int btrfs_drop_snapshot ( struct btrfs_root * root , int update_ref ) ;

int btrfs_drop_subtree ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct extent_buffer * node , struct extent_buffer * parent ) ;

int btrfs_prepare_block_group_relocation ( struct btrfs_root * root , struct btrfs_block_group_cache * group ) ;

int btrfs_can_relocate ( struct btrfs_root * root , u64 bytenr ) ;

int btrfs_free_block_groups ( struct btrfs_fs_info * info ) ;

int btrfs_read_block_groups ( struct btrfs_root * root ) ;

int btrfs_make_block_group ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 bytes_used , u64 type , u64 chunk_objectid , u64 chunk_offset , u64 size ) ;

int btrfs_remove_block_group ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 group_start ) ;

void btrfs_print_leaf ( struct btrfs_root * root , struct extent_buffer * l ) ;

void btrfs_print_tree ( struct btrfs_root * root , struct extent_buffer * c ) ;

int btrfs_search_root ( struct btrfs_root * root , u64 search_start , u64 * found_objectid ) ;

int btrfs_find_last_root ( struct btrfs_root * root , u64 objectid , struct btrfs_root_item * item , struct btrfs_key * key ) ;

int btrfs_set_root_node ( struct btrfs_root_item * item , struct extent_buffer * node ) ;

int btrfs_update_root ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_key * key , struct btrfs_root_item * item ) ;

int btrfs_insert_root ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_key * key , struct btrfs_root_item * item ) ;

int btrfs_find_dead_roots ( struct btrfs_root * root , u64 objectid ) ;

int btrfs_find_orphan_roots ( struct btrfs_root * tree_root ) ;

int btrfs_del_root ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_key * key ) ;

int btrfs_del_root_ref ( struct btrfs_trans_handle * trans , struct btrfs_root * tree_root , u64 root_id , u64 ref_id , u64 dirid , u64 * sequence , const char * name , int name_len ) ;

int btrfs_find_root_ref ( struct btrfs_root * tree_root , struct btrfs_path * path , u64 root_id , u64 ref_id ) ;

int btrfs_add_root_ref ( struct btrfs_trans_handle * trans , struct btrfs_root * tree_root , u64 root_id , u64 ref_id , u64 dirid , u64 sequence , const char * name , int name_len ) ;

int btrfs_insert_xattr_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , u64 objectid , const char * name , u16 name_len , const void * data , u16 data_len ) ;

int btrfs_insert_dir_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , const char * name , int name_len , u64 dir , struct btrfs_key * location , u8 type , u64 index ) ;

struct btrfs_dir_item * btrfs_lookup_dir_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , u64 dir , const char * name , int name_len , int mod ) ;

struct btrfs_dir_item * btrfs_lookup_dir_index_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , u64 dir , u64 objectid , const char * name , int name_len , int mod ) ;

struct btrfs_dir_item * btrfs_search_dir_index_item ( struct btrfs_root * root , struct btrfs_path * path , u64 dirid , const char * name , int name_len ) ;

struct btrfs_dir_item * btrfs_lookup_xattr ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , u64 dir , const char * name , u16 name_len , int mod ) ;

struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root , struct btrfs_path * path , const char * name , int name_len ) ;

int btrfs_delete_one_dir_name ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , struct btrfs_dir_item * di ) ;

int btrfs_insert_file_extent ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 objectid , u64 pos , u64 disk_offset , u64 disk_num_bytes , u64 num_bytes , u64 offset , u64 ram_bytes , u8 compression , u8 encryption , u16 other_encoding ) ;

struct btrfs_csum_item * btrfs_lookup_csum ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , u64 bytenr , int cow ) ;

int btrfs_lookup_file_extent ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , u64 objectid , u64 offset , int mod ) ;

int btrfs_lookup_bio_sums ( struct btrfs_root * root , struct inode * inode , struct bio * bio , u32 * dst ) ;

int btrfs_lookup_csums_range ( struct btrfs_root * root , u64 start , u64 end , struct list_head * list ) ;

int btrfs_csum_one_bio ( struct btrfs_root * root , struct inode * inode , struct bio * bio , u64 file_start , int contig ) ;

int btrfs_del_csums ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 bytenr , u64 len ) ;

int btrfs_csum_file_blocks ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_ordered_sum * sums ) ;

int btrfs_del_inode_ref ( struct btrfs_trans_handle * trans , struct btrfs_root * root , const char * name , int name_len , u64 inode_objectid , u64 ref_objectid , u64 * index ) ;

int btrfs_insert_inode_ref ( struct btrfs_trans_handle * trans , struct btrfs_root * root , const char * name , int name_len , u64 inode_objectid , u64 ref_objectid , u64 index ) ;

int btrfs_insert_empty_inode ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , u64 objectid ) ;

int btrfs_lookup_inode ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_path * path , struct btrfs_key * location , int mod ) ;

int btrfs_find_highest_inode ( struct btrfs_root * root , u64 * objectid ) ;

int btrfs_find_free_objectid ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 dirid , u64 * objectid ) ;

struct end_io_wq { struct bio * bio ; bio_end_io_t * end_io ; void * private ; struct btrfs_fs_info * info ; int error ; int metadata ; struct list_head list ; struct btrfs_work work ; } ;

struct async_submit_bio { struct inode * inode ; struct bio * bio ; struct list_head list ; extent_submit_bio_hook_t * submit_bio_start ; extent_submit_bio_hook_t * submit_bio_done ; int rw ; int mirror_num ; unsigned long bio_flags ; struct btrfs_work work ; } ;

u32 btrfs_csum_data ( struct btrfs_root * root , char * data , u32 seed , size_t len ) ;

void btrfs_csum_final ( u32 crc , char * result ) ;

int btrfs_bio_wq_end_io ( struct btrfs_fs_info * info , struct bio * bio , int metadata ) ;

unsigned long btrfs_async_submit_limit ( struct btrfs_fs_info * info ) ;

int btrfs_congested_async ( struct btrfs_fs_info * info , int iodone ) ;

int btrfs_wq_submit_bio ( struct btrfs_fs_info * fs_info , struct inode * inode , int rw , struct bio * bio , int mirror_num , unsigned long bio_flags , extent_submit_bio_hook_t * submit_bio_start , extent_submit_bio_hook_t * submit_bio_done ) ;

int readahead_tree_block ( struct btrfs_root * root , u64 bytenr , u32 blocksize , u64 parent_transid ) ;

struct extent_buffer * btrfs_find_tree_block ( struct btrfs_root * root , u64 bytenr , u32 blocksize ) ;

struct extent_buffer * btrfs_find_create_tree_block ( struct btrfs_root * root , u64 bytenr , u32 blocksize ) ;

int btrfs_write_tree_block ( struct extent_buffer * buf ) ;

int btrfs_wait_tree_block_writeback ( struct extent_buffer * buf ) ;

struct extent_buffer * read_tree_block ( struct btrfs_root * root , u64 bytenr , u32 blocksize , u64 parent_transid ) ;

int clean_tree_block ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct extent_buffer * buf ) ;

int btrfs_free_log_root_tree ( struct btrfs_trans_handle * trans , struct btrfs_fs_info * fs_info ) ;

int btrfs_init_log_root_tree ( struct btrfs_trans_handle * trans , struct btrfs_fs_info * fs_info ) ;

int btrfs_add_log_tree ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

struct btrfs_root * btrfs_read_fs_root_no_radix ( struct btrfs_root * tree_root , struct btrfs_key * location ) ;

struct btrfs_root * btrfs_lookup_fs_root ( struct btrfs_fs_info * fs_info , u64 root_objectid ) ;

struct btrfs_root * btrfs_read_fs_root_no_name ( struct btrfs_fs_info * fs_info , struct btrfs_key * location ) ;

struct btrfs_root * btrfs_read_fs_root ( struct btrfs_fs_info * fs_info , struct btrfs_key * location , const char * name , int namelen ) ;

struct btrfs_root * open_ctree ( struct super_block * sb , struct btrfs_fs_devices * fs_devices , char * options ) ;

struct buffer_head * btrfs_read_dev_super ( struct block_device * bdev ) ;

int write_all_supers ( struct btrfs_root * root , int max_mirrors ) ;

int write_ctree_super ( struct btrfs_trans_handle * trans , struct btrfs_root * root , int max_mirrors ) ;

int btrfs_free_fs_root ( struct btrfs_fs_info * fs_info , struct btrfs_root * root ) ;

int btrfs_cleanup_fs_roots ( struct btrfs_fs_info * fs_info ) ;

int btrfs_commit_super ( struct btrfs_root * root ) ;

int close_ctree ( struct btrfs_root * root ) ;

int btrfs_buffer_uptodate ( struct extent_buffer * buf , u64 parent_transid ) ;

int btrfs_set_buffer_uptodate ( struct extent_buffer * buf ) ;

void btrfs_mark_buffer_dirty ( struct extent_buffer * buf ) ;

void btrfs_btree_balance_dirty ( struct btrfs_root * root , unsigned long nr ) ;

int btrfs_read_buffer ( struct extent_buffer * buf , u64 parent_transid ) ;

int btree_lock_page_hook ( struct page * page ) ;

int btrfs_record_root_in_trans ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

enum btrfs_trans_type { TRANS_START , TRANS_JOIN , TRANS_USERSPACE , } ;

struct btrfs_trans_handle * btrfs_start_transaction ( struct btrfs_root * root , int num_blocks ) ;

struct btrfs_trans_handle * btrfs_join_transaction ( struct btrfs_root * root , int num_blocks ) ;

struct btrfs_trans_handle * btrfs_start_ioctl_transaction ( struct btrfs_root * r , int num_blocks ) ;

void btrfs_throttle ( struct btrfs_root * root ) ;

int btrfs_end_transaction ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_end_transaction_throttle ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_write_marked_extents ( struct btrfs_root * root , struct extent_io_tree * dirty_pages , int mark ) ;

int btrfs_wait_marked_extents ( struct btrfs_root * root , struct extent_io_tree * dirty_pages , int mark ) ;

int btrfs_write_and_wait_marked_extents ( struct btrfs_root * root , struct extent_io_tree * dirty_pages , int mark ) ;

int btrfs_write_and_wait_transaction ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_add_dead_root ( struct btrfs_root * root ) ;

int btrfs_defrag_root ( struct btrfs_root * root , int cacheonly ) ;

int btrfs_transaction_in_commit ( struct btrfs_fs_info * info ) ;

int btrfs_commit_transaction ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_clean_old_snapshots ( struct btrfs_root * root ) ;

struct btrfs_iget_args { u64 ino ; struct btrfs_root * root ; } ;

struct async_extent { u64 start ; u64 ram_size ; u64 compressed_size ; struct page * * pages ; unsigned long nr_pages ; struct list_head list ; } ;

struct async_cow { struct inode * inode ; struct btrfs_root * root ; struct page * locked_page ; u64 start ; u64 end ; struct list_head extents ; struct btrfs_work work ; } ;

int btrfs_merge_bio_hook ( struct page * page , unsigned long offset , size_t size , struct bio * bio , unsigned long bio_flags ) ;

int btrfs_set_extent_delalloc ( struct inode * inode , u64 start , u64 end ) ;

struct btrfs_writepage_fixup { struct page * page ; struct btrfs_work work ; } ;

struct io_failure_record { struct page * page ; u64 start ; u64 len ; u64 logical ; unsigned long bio_flags ; int last_mirror ; } ;

struct delayed_iput { struct list_head list ; struct inode * inode ; } ;

void btrfs_add_delayed_iput ( struct inode * inode ) ;

void btrfs_run_delayed_iputs ( struct btrfs_root * root ) ;

int btrfs_orphan_add ( struct btrfs_trans_handle * trans , struct inode * inode ) ;

int btrfs_orphan_del ( struct btrfs_trans_handle * trans , struct inode * inode ) ;

void btrfs_orphan_cleanup ( struct btrfs_root * root ) ;

__attribute__ ( ( noinline ) ) int btrfs_update_inode ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode ) ;

int btrfs_unlink_inode ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * dir , struct inode * inode , const char * name , int name_len ) ;

int btrfs_unlink_subvol ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * dir , u64 objectid , const char * name , int name_len ) ;

int btrfs_truncate_inode_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode , u64 new_size , u32 min_type ) ;

int btrfs_cont_expand ( struct inode * inode , loff_t size ) ;

void btrfs_delete_inode ( struct inode * inode ) ;

int btrfs_invalidate_inodes ( struct btrfs_root * root ) ;

struct inode * btrfs_iget ( struct super_block * s , struct btrfs_key * location , struct btrfs_root * root ) ;

struct inode * btrfs_lookup_dentry ( struct inode * dir , struct dentry * dentry ) ;

int btrfs_write_inode ( struct inode * inode , int wait ) ;

void btrfs_dirty_inode ( struct inode * inode ) ;

int btrfs_set_inode_index ( struct inode * dir , u64 * index ) ;

int btrfs_add_link ( struct btrfs_trans_handle * trans , struct inode * parent_inode , struct inode * inode , const char * name , int name_len , int add_backref , u64 index ) ;

struct extent_map * btrfs_get_extent ( struct inode * inode , struct page * page , size_t pg_offset , u64 start , u64 len , int create ) ;

int btrfs_readpage ( struct file * file , struct page * page ) ;

int btrfs_writepages ( struct address_space * mapping , struct writeback_control * wbc ) ;

int btrfs_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) ;

int btrfs_create_subvol_root ( struct btrfs_trans_handle * trans , struct btrfs_root * new_root , u64 new_dirid , u64 alloc_hint ) ;

unsigned long btrfs_force_ra ( struct address_space * mapping , struct file_ra_state * ra , struct file * file , unsigned long offset , unsigned long last_index ) ;

struct inode * btrfs_alloc_inode ( struct super_block * sb ) ;

void btrfs_destroy_inode ( struct inode * inode ) ;

void btrfs_drop_inode ( struct inode * inode ) ;

void btrfs_destroy_cachep ( void ) ;

int btrfs_init_cachep ( void ) ;

int btrfs_start_delalloc_inodes ( struct btrfs_root * root , int delay_iput ) ;

int btrfs_drop_extent_cache ( struct inode * inode , u64 start , u64 end , int skip_pinned ) ;

int btrfs_drop_extents ( struct btrfs_trans_handle * trans , struct inode * inode , u64 start , u64 end , u64 * hint_byte , int drop_cache ) ;

int btrfs_mark_extent_written ( struct btrfs_trans_handle * trans , struct inode * inode , u64 start , u64 end ) ;

int btrfs_release_file ( struct inode * inode , struct file * filp ) ;

int btrfs_sync_file ( struct file * file , struct dentry * dentry , int datasync ) ;

int btrfs_defrag_leaves ( struct btrfs_trans_handle * trans , struct btrfs_root * root , int cache_only ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) extent_map_init ( void ) ;

void extent_map_exit ( void ) ;

void extent_map_tree_init ( struct extent_map_tree * tree , gfp_t mask ) ;

struct extent_map * alloc_extent_map ( gfp_t mask ) ;

void free_extent_map ( struct extent_map * em ) ;

int unpin_extent_cache ( struct extent_map_tree * tree , u64 start , u64 len ) ;

int add_extent_mapping ( struct extent_map_tree * tree , struct extent_map * em ) ;

struct extent_map * lookup_extent_mapping ( struct extent_map_tree * tree , u64 start , u64 len ) ;

struct extent_map * search_extent_mapping ( struct extent_map_tree * tree , u64 start , u64 len ) ;

int remove_extent_mapping ( struct extent_map_tree * tree , struct extent_map * em ) ;

struct btrfs_root_attr { struct attribute attr ; ssize_t ( * show ) ( struct btrfs_root * , char * ) ; ssize_t ( * store ) ( struct btrfs_root * , const char * , size_t ) ; } ;

struct btrfs_super_attr { struct attribute attr ; ssize_t ( * show ) ( struct btrfs_fs_info * , char * ) ; ssize_t ( * store ) ( struct btrfs_fs_info * , const char * , size_t ) ; } ;

int btrfs_sysfs_add_super ( struct btrfs_fs_info * fs ) ;

int btrfs_sysfs_add_root ( struct btrfs_root * root ) ;

void btrfs_sysfs_del_root ( struct btrfs_root * root ) ;

void btrfs_sysfs_del_super ( struct btrfs_fs_info * fs ) ;

int btrfs_init_sysfs ( void ) ;

void btrfs_exit_sysfs ( void ) ;

u64 btrfs_device_type ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_type ( struct extent_buffer * eb , struct btrfs_dev_item * s , u64 val ) ;

u64 btrfs_device_total_bytes ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_total_bytes ( struct extent_buffer * eb , struct btrfs_dev_item * s , u64 val ) ;

u64 btrfs_device_bytes_used ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_bytes_used ( struct extent_buffer * eb , struct btrfs_dev_item * s , u64 val ) ;

u32 btrfs_device_io_align ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_io_align ( struct extent_buffer * eb , struct btrfs_dev_item * s , u32 val ) ;

u32 btrfs_device_io_width ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_io_width ( struct extent_buffer * eb , struct btrfs_dev_item * s , u32 val ) ;

u64 btrfs_device_start_offset ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_start_offset ( struct extent_buffer * eb , struct btrfs_dev_item * s , u64 val ) ;

u32 btrfs_device_sector_size ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_sector_size ( struct extent_buffer * eb , struct btrfs_dev_item * s , u32 val ) ;

u64 btrfs_device_id ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_id ( struct extent_buffer * eb , struct btrfs_dev_item * s , u64 val ) ;

u32 btrfs_device_group ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_group ( struct extent_buffer * eb , struct btrfs_dev_item * s , u32 val ) ;

u8 btrfs_device_seek_speed ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_seek_speed ( struct extent_buffer * eb , struct btrfs_dev_item * s , u8 val ) ;

u8 btrfs_device_bandwidth ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_bandwidth ( struct extent_buffer * eb , struct btrfs_dev_item * s , u8 val ) ;

u64 btrfs_device_generation ( struct extent_buffer * eb , struct btrfs_dev_item * s ) ;

void btrfs_set_device_generation ( struct extent_buffer * eb , struct btrfs_dev_item * s , u64 val ) ;

u64 btrfs_chunk_length ( struct extent_buffer * eb , struct btrfs_chunk * s ) ;

void btrfs_set_chunk_length ( struct extent_buffer * eb , struct btrfs_chunk * s , u64 val ) ;

u64 btrfs_chunk_owner ( struct extent_buffer * eb , struct btrfs_chunk * s ) ;

void btrfs_set_chunk_owner ( struct extent_buffer * eb , struct btrfs_chunk * s , u64 val ) ;

u64 btrfs_chunk_stripe_len ( struct extent_buffer * eb , struct btrfs_chunk * s ) ;

void btrfs_set_chunk_stripe_len ( struct extent_buffer * eb , struct btrfs_chunk * s , u64 val ) ;

u32 btrfs_chunk_io_align ( struct extent_buffer * eb , struct btrfs_chunk * s ) ;

void btrfs_set_chunk_io_align ( struct extent_buffer * eb , struct btrfs_chunk * s , u32 val ) ;

u32 btrfs_chunk_io_width ( struct extent_buffer * eb , struct btrfs_chunk * s ) ;

void btrfs_set_chunk_io_width ( struct extent_buffer * eb , struct btrfs_chunk * s , u32 val ) ;

u32 btrfs_chunk_sector_size ( struct extent_buffer * eb , struct btrfs_chunk * s ) ;

void btrfs_set_chunk_sector_size ( struct extent_buffer * eb , struct btrfs_chunk * s , u32 val ) ;

u64 btrfs_chunk_type ( struct extent_buffer * eb , struct btrfs_chunk * s ) ;

void btrfs_set_chunk_type ( struct extent_buffer * eb , struct btrfs_chunk * s , u64 val ) ;

u16 btrfs_chunk_num_stripes ( struct extent_buffer * eb , struct btrfs_chunk * s ) ;

void btrfs_set_chunk_num_stripes ( struct extent_buffer * eb , struct btrfs_chunk * s , u16 val ) ;

u16 btrfs_chunk_sub_stripes ( struct extent_buffer * eb , struct btrfs_chunk * s ) ;

void btrfs_set_chunk_sub_stripes ( struct extent_buffer * eb , struct btrfs_chunk * s , u16 val ) ;

u64 btrfs_stripe_devid ( struct extent_buffer * eb , struct btrfs_stripe * s ) ;

void btrfs_set_stripe_devid ( struct extent_buffer * eb , struct btrfs_stripe * s , u64 val ) ;

u64 btrfs_stripe_offset ( struct extent_buffer * eb , struct btrfs_stripe * s ) ;

void btrfs_set_stripe_offset ( struct extent_buffer * eb , struct btrfs_stripe * s , u64 val ) ;

u64 btrfs_disk_block_group_used ( struct extent_buffer * eb , struct btrfs_block_group_item * s ) ;

void btrfs_set_disk_block_group_used ( struct extent_buffer * eb , struct btrfs_block_group_item * s , u64 val ) ;

u64 btrfs_disk_block_group_chunk_objectid ( struct extent_buffer * eb , struct btrfs_block_group_item * s ) ;

void btrfs_set_disk_block_group_chunk_objectid ( struct extent_buffer * eb , struct btrfs_block_group_item * s , u64 val ) ;

u64 btrfs_disk_block_group_flags ( struct extent_buffer * eb , struct btrfs_block_group_item * s ) ;

void btrfs_set_disk_block_group_flags ( struct extent_buffer * eb , struct btrfs_block_group_item * s , u64 val ) ;

u16 btrfs_inode_ref_name_len ( struct extent_buffer * eb , struct btrfs_inode_ref * s ) ;

void btrfs_set_inode_ref_name_len ( struct extent_buffer * eb , struct btrfs_inode_ref * s , u16 val ) ;

u64 btrfs_inode_ref_index ( struct extent_buffer * eb , struct btrfs_inode_ref * s ) ;

void btrfs_set_inode_ref_index ( struct extent_buffer * eb , struct btrfs_inode_ref * s , u64 val ) ;

u64 btrfs_inode_generation ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_generation ( struct extent_buffer * eb , struct btrfs_inode_item * s , u64 val ) ;

u64 btrfs_inode_sequence ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_sequence ( struct extent_buffer * eb , struct btrfs_inode_item * s , u64 val ) ;

u64 btrfs_inode_transid ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_transid ( struct extent_buffer * eb , struct btrfs_inode_item * s , u64 val ) ;

u64 btrfs_inode_size ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_size ( struct extent_buffer * eb , struct btrfs_inode_item * s , u64 val ) ;

u64 btrfs_inode_nbytes ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_nbytes ( struct extent_buffer * eb , struct btrfs_inode_item * s , u64 val ) ;

u64 btrfs_inode_block_group ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_block_group ( struct extent_buffer * eb , struct btrfs_inode_item * s , u64 val ) ;

u32 btrfs_inode_nlink ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_nlink ( struct extent_buffer * eb , struct btrfs_inode_item * s , u32 val ) ;

u32 btrfs_inode_uid ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_uid ( struct extent_buffer * eb , struct btrfs_inode_item * s , u32 val ) ;

u32 btrfs_inode_gid ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_gid ( struct extent_buffer * eb , struct btrfs_inode_item * s , u32 val ) ;

u32 btrfs_inode_mode ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_mode ( struct extent_buffer * eb , struct btrfs_inode_item * s , u32 val ) ;

u64 btrfs_inode_rdev ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_rdev ( struct extent_buffer * eb , struct btrfs_inode_item * s , u64 val ) ;

u64 btrfs_inode_flags ( struct extent_buffer * eb , struct btrfs_inode_item * s ) ;

void btrfs_set_inode_flags ( struct extent_buffer * eb , struct btrfs_inode_item * s , u64 val ) ;

u64 btrfs_timespec_sec ( struct extent_buffer * eb , struct btrfs_timespec * s ) ;

void btrfs_set_timespec_sec ( struct extent_buffer * eb , struct btrfs_timespec * s , u64 val ) ;

u32 btrfs_timespec_nsec ( struct extent_buffer * eb , struct btrfs_timespec * s ) ;

void btrfs_set_timespec_nsec ( struct extent_buffer * eb , struct btrfs_timespec * s , u32 val ) ;

u64 btrfs_dev_extent_chunk_tree ( struct extent_buffer * eb , struct btrfs_dev_extent * s ) ;

void btrfs_set_dev_extent_chunk_tree ( struct extent_buffer * eb , struct btrfs_dev_extent * s , u64 val ) ;

u64 btrfs_dev_extent_chunk_objectid ( struct extent_buffer * eb , struct btrfs_dev_extent * s ) ;

void btrfs_set_dev_extent_chunk_objectid ( struct extent_buffer * eb , struct btrfs_dev_extent * s , u64 val ) ;

u64 btrfs_dev_extent_chunk_offset ( struct extent_buffer * eb , struct btrfs_dev_extent * s ) ;

void btrfs_set_dev_extent_chunk_offset ( struct extent_buffer * eb , struct btrfs_dev_extent * s , u64 val ) ;

u64 btrfs_dev_extent_length ( struct extent_buffer * eb , struct btrfs_dev_extent * s ) ;

void btrfs_set_dev_extent_length ( struct extent_buffer * eb , struct btrfs_dev_extent * s , u64 val ) ;

u64 btrfs_extent_refs ( struct extent_buffer * eb , struct btrfs_extent_item * s ) ;

void btrfs_set_extent_refs ( struct extent_buffer * eb , struct btrfs_extent_item * s , u64 val ) ;

u64 btrfs_extent_generation ( struct extent_buffer * eb , struct btrfs_extent_item * s ) ;

void btrfs_set_extent_generation ( struct extent_buffer * eb , struct btrfs_extent_item * s , u64 val ) ;

u64 btrfs_extent_flags ( struct extent_buffer * eb , struct btrfs_extent_item * s ) ;

void btrfs_set_extent_flags ( struct extent_buffer * eb , struct btrfs_extent_item * s , u64 val ) ;

u32 btrfs_extent_refs_v0 ( struct extent_buffer * eb , struct btrfs_extent_item_v0 * s ) ;

void btrfs_set_extent_refs_v0 ( struct extent_buffer * eb , struct btrfs_extent_item_v0 * s , u32 val ) ;

u8 btrfs_tree_block_level ( struct extent_buffer * eb , struct btrfs_tree_block_info * s ) ;

void btrfs_set_tree_block_level ( struct extent_buffer * eb , struct btrfs_tree_block_info * s , u8 val ) ;

u64 btrfs_extent_data_ref_root ( struct extent_buffer * eb , struct btrfs_extent_data_ref * s ) ;

void btrfs_set_extent_data_ref_root ( struct extent_buffer * eb , struct btrfs_extent_data_ref * s , u64 val ) ;

u64 btrfs_extent_data_ref_objectid ( struct extent_buffer * eb , struct btrfs_extent_data_ref * s ) ;

void btrfs_set_extent_data_ref_objectid ( struct extent_buffer * eb , struct btrfs_extent_data_ref * s , u64 val ) ;

u64 btrfs_extent_data_ref_offset ( struct extent_buffer * eb , struct btrfs_extent_data_ref * s ) ;

void btrfs_set_extent_data_ref_offset ( struct extent_buffer * eb , struct btrfs_extent_data_ref * s , u64 val ) ;

u32 btrfs_extent_data_ref_count ( struct extent_buffer * eb , struct btrfs_extent_data_ref * s ) ;

void btrfs_set_extent_data_ref_count ( struct extent_buffer * eb , struct btrfs_extent_data_ref * s , u32 val ) ;

u32 btrfs_shared_data_ref_count ( struct extent_buffer * eb , struct btrfs_shared_data_ref * s ) ;

void btrfs_set_shared_data_ref_count ( struct extent_buffer * eb , struct btrfs_shared_data_ref * s , u32 val ) ;

u8 btrfs_extent_inline_ref_type ( struct extent_buffer * eb , struct btrfs_extent_inline_ref * s ) ;

void btrfs_set_extent_inline_ref_type ( struct extent_buffer * eb , struct btrfs_extent_inline_ref * s , u8 val ) ;

u64 btrfs_extent_inline_ref_offset ( struct extent_buffer * eb , struct btrfs_extent_inline_ref * s ) ;

void btrfs_set_extent_inline_ref_offset ( struct extent_buffer * eb , struct btrfs_extent_inline_ref * s , u64 val ) ;

u64 btrfs_ref_root_v0 ( struct extent_buffer * eb , struct btrfs_extent_ref_v0 * s ) ;

void btrfs_set_ref_root_v0 ( struct extent_buffer * eb , struct btrfs_extent_ref_v0 * s , u64 val ) ;

u64 btrfs_ref_generation_v0 ( struct extent_buffer * eb , struct btrfs_extent_ref_v0 * s ) ;

void btrfs_set_ref_generation_v0 ( struct extent_buffer * eb , struct btrfs_extent_ref_v0 * s , u64 val ) ;

u64 btrfs_ref_objectid_v0 ( struct extent_buffer * eb , struct btrfs_extent_ref_v0 * s ) ;

void btrfs_set_ref_objectid_v0 ( struct extent_buffer * eb , struct btrfs_extent_ref_v0 * s , u64 val ) ;

u32 btrfs_ref_count_v0 ( struct extent_buffer * eb , struct btrfs_extent_ref_v0 * s ) ;

void btrfs_set_ref_count_v0 ( struct extent_buffer * eb , struct btrfs_extent_ref_v0 * s , u32 val ) ;

u64 btrfs_key_blockptr ( struct extent_buffer * eb , struct btrfs_key_ptr * s ) ;

void btrfs_set_key_blockptr ( struct extent_buffer * eb , struct btrfs_key_ptr * s , u64 val ) ;

u64 btrfs_key_generation ( struct extent_buffer * eb , struct btrfs_key_ptr * s ) ;

void btrfs_set_key_generation ( struct extent_buffer * eb , struct btrfs_key_ptr * s , u64 val ) ;

u32 btrfs_item_offset ( struct extent_buffer * eb , struct btrfs_item * s ) ;

void btrfs_set_item_offset ( struct extent_buffer * eb , struct btrfs_item * s , u32 val ) ;

u32 btrfs_item_size ( struct extent_buffer * eb , struct btrfs_item * s ) ;

void btrfs_set_item_size ( struct extent_buffer * eb , struct btrfs_item * s , u32 val ) ;

u64 btrfs_dir_log_end ( struct extent_buffer * eb , struct btrfs_dir_log_item * s ) ;

void btrfs_set_dir_log_end ( struct extent_buffer * eb , struct btrfs_dir_log_item * s , u64 val ) ;

u64 btrfs_root_ref_dirid ( struct extent_buffer * eb , struct btrfs_root_ref * s ) ;

void btrfs_set_root_ref_dirid ( struct extent_buffer * eb , struct btrfs_root_ref * s , u64 val ) ;

u64 btrfs_root_ref_sequence ( struct extent_buffer * eb , struct btrfs_root_ref * s ) ;

void btrfs_set_root_ref_sequence ( struct extent_buffer * eb , struct btrfs_root_ref * s , u64 val ) ;

u16 btrfs_root_ref_name_len ( struct extent_buffer * eb , struct btrfs_root_ref * s ) ;

void btrfs_set_root_ref_name_len ( struct extent_buffer * eb , struct btrfs_root_ref * s , u16 val ) ;

u16 btrfs_dir_data_len ( struct extent_buffer * eb , struct btrfs_dir_item * s ) ;

void btrfs_set_dir_data_len ( struct extent_buffer * eb , struct btrfs_dir_item * s , u16 val ) ;

u8 btrfs_dir_type ( struct extent_buffer * eb , struct btrfs_dir_item * s ) ;

void btrfs_set_dir_type ( struct extent_buffer * eb , struct btrfs_dir_item * s , u8 val ) ;

u16 btrfs_dir_name_len ( struct extent_buffer * eb , struct btrfs_dir_item * s ) ;

void btrfs_set_dir_name_len ( struct extent_buffer * eb , struct btrfs_dir_item * s , u16 val ) ;

u64 btrfs_dir_transid ( struct extent_buffer * eb , struct btrfs_dir_item * s ) ;

void btrfs_set_dir_transid ( struct extent_buffer * eb , struct btrfs_dir_item * s , u64 val ) ;

u64 btrfs_disk_root_generation ( struct extent_buffer * eb , struct btrfs_root_item * s ) ;

void btrfs_set_disk_root_generation ( struct extent_buffer * eb , struct btrfs_root_item * s , u64 val ) ;

u32 btrfs_disk_root_refs ( struct extent_buffer * eb , struct btrfs_root_item * s ) ;

void btrfs_set_disk_root_refs ( struct extent_buffer * eb , struct btrfs_root_item * s , u32 val ) ;

u64 btrfs_disk_root_bytenr ( struct extent_buffer * eb , struct btrfs_root_item * s ) ;

void btrfs_set_disk_root_bytenr ( struct extent_buffer * eb , struct btrfs_root_item * s , u64 val ) ;

u8 btrfs_disk_root_level ( struct extent_buffer * eb , struct btrfs_root_item * s ) ;

void btrfs_set_disk_root_level ( struct extent_buffer * eb , struct btrfs_root_item * s , u8 val ) ;

u8 btrfs_file_extent_type ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_type ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u8 val ) ;

u64 btrfs_file_extent_disk_bytenr ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_disk_bytenr ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u64 val ) ;

u64 btrfs_file_extent_generation ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_generation ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u64 val ) ;

u64 btrfs_file_extent_disk_num_bytes ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_disk_num_bytes ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u64 val ) ;

u64 btrfs_file_extent_offset ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_offset ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u64 val ) ;

u64 btrfs_file_extent_num_bytes ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_num_bytes ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u64 val ) ;

u64 btrfs_file_extent_ram_bytes ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_ram_bytes ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u64 val ) ;

u8 btrfs_file_extent_compression ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_compression ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u8 val ) ;

u8 btrfs_file_extent_encryption ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_encryption ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u8 val ) ;

u16 btrfs_file_extent_other_encoding ( struct extent_buffer * eb , struct btrfs_file_extent_item * s ) ;

void btrfs_set_file_extent_other_encoding ( struct extent_buffer * eb , struct btrfs_file_extent_item * s , u16 val ) ;

void btrfs_node_key ( struct extent_buffer * eb , struct btrfs_disk_key * disk_key , int nr ) ;

ssize_t __btrfs_getxattr ( struct inode * inode , const char * name , void * buffer , size_t size ) ;

int __btrfs_setxattr ( struct btrfs_trans_handle * trans , struct inode * inode , const char * name , const void * value , size_t size , int flags ) ;

ssize_t btrfs_listxattr ( struct dentry * dentry , char * buffer , size_t size ) ;

ssize_t btrfs_getxattr ( struct dentry * dentry , const char * name , void * buffer , size_t size ) ;

int btrfs_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

int btrfs_removexattr ( struct dentry * dentry , const char * name ) ;

int btrfs_xattr_security_init ( struct btrfs_trans_handle * trans , struct inode * inode , struct inode * dir ) ;

int btrfs_add_ordered_extent ( struct inode * inode , u64 file_offset , u64 start , u64 len , u64 disk_len , int type ) ;

int btrfs_add_ordered_sum ( struct inode * inode , struct btrfs_ordered_extent * entry , struct btrfs_ordered_sum * sum ) ;

int btrfs_dec_test_ordered_pending ( struct inode * inode , u64 file_offset , u64 io_size ) ;

int btrfs_put_ordered_extent ( struct btrfs_ordered_extent * entry ) ;

int btrfs_remove_ordered_extent ( struct inode * inode , struct btrfs_ordered_extent * entry ) ;

int btrfs_wait_ordered_extents ( struct btrfs_root * root , int nocow_only , int delay_iput ) ;

int btrfs_run_ordered_operations ( struct btrfs_root * root , int wait ) ;

void btrfs_start_ordered_extent ( struct inode * inode , struct btrfs_ordered_extent * entry , int wait ) ;

int btrfs_wait_ordered_range ( struct inode * inode , u64 start , u64 len ) ;

struct btrfs_ordered_extent * btrfs_lookup_ordered_extent ( struct inode * inode , u64 file_offset ) ;

struct btrfs_ordered_extent * btrfs_lookup_first_ordered_extent ( struct inode * inode , u64 file_offset ) ;

int btrfs_ordered_update_i_size ( struct inode * inode , u64 offset , struct btrfs_ordered_extent * ordered ) ;

int btrfs_find_ordered_sum ( struct inode * inode , u64 offset , u64 disk_bytenr , u32 * sum ) ;

int btrfs_add_ordered_operation ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode ) ;

struct tree_entry { u64 start ; u64 end ; struct rb_node rb_node ; } ;

struct extent_page_data { struct bio * bio ; struct extent_io_tree * tree ; get_extent_t * get_extent ; unsigned int extent_locked : 1 ; unsigned int sync_io : 1 ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) extent_io_init ( void ) ;

void extent_io_exit ( void ) ;

void extent_io_tree_init ( struct extent_io_tree * tree , struct address_space * mapping , gfp_t mask ) ;

int clear_extent_bit ( struct extent_io_tree * tree , u64 start , u64 end , int bits , int wake , int delete , struct extent_state * * cached_state , gfp_t mask ) ;

int wait_extent_bit ( struct extent_io_tree * tree , u64 start , u64 end , int bits ) ;

int set_extent_dirty ( struct extent_io_tree * tree , u64 start , u64 end , gfp_t mask ) ;

int set_extent_bits ( struct extent_io_tree * tree , u64 start , u64 end , int bits , gfp_t mask ) ;

int clear_extent_bits ( struct extent_io_tree * tree , u64 start , u64 end , int bits , gfp_t mask ) ;

int set_extent_delalloc ( struct extent_io_tree * tree , u64 start , u64 end , gfp_t mask ) ;

int clear_extent_dirty ( struct extent_io_tree * tree , u64 start , u64 end , gfp_t mask ) ;

int set_extent_new ( struct extent_io_tree * tree , u64 start , u64 end , gfp_t mask ) ;

int set_extent_uptodate ( struct extent_io_tree * tree , u64 start , u64 end , gfp_t mask ) ;

int wait_on_extent_writeback ( struct extent_io_tree * tree , u64 start , u64 end ) ;

int lock_extent_bits ( struct extent_io_tree * tree , u64 start , u64 end , int bits , struct extent_state * * cached_state , gfp_t mask ) ;

int lock_extent ( struct extent_io_tree * tree , u64 start , u64 end , gfp_t mask ) ;

int try_lock_extent ( struct extent_io_tree * tree , u64 start , u64 end , gfp_t mask ) ;

int unlock_extent_cached ( struct extent_io_tree * tree , u64 start , u64 end , struct extent_state * * cached , gfp_t mask ) ;

int unlock_extent ( struct extent_io_tree * tree , u64 start , u64 end , gfp_t mask ) ;

int set_range_dirty ( struct extent_io_tree * tree , u64 start , u64 end ) ;

int find_first_extent_bit ( struct extent_io_tree * tree , u64 start , u64 * start_ret , u64 * end_ret , int bits ) ;

struct extent_state * find_first_extent_bit_state ( struct extent_io_tree * tree , u64 start , int bits ) ;

int extent_clear_unlock_delalloc ( struct inode * inode , struct extent_io_tree * tree , u64 start , u64 end , struct page * locked_page , unsigned long op ) ;

u64 count_range_bits ( struct extent_io_tree * tree , u64 * start , u64 search_end , u64 max_bytes , unsigned long bits ) ;

int set_state_private ( struct extent_io_tree * tree , u64 start , u64 private ) ;

int get_state_private ( struct extent_io_tree * tree , u64 start , u64 * private ) ;

int test_range_bit ( struct extent_io_tree * tree , u64 start , u64 end , int bits , int filled , struct extent_state * cached ) ;

void set_page_extent_mapped ( struct page * page ) ;

int extent_read_full_page ( struct extent_io_tree * tree , struct page * page , get_extent_t * get_extent ) ;

int extent_write_full_page ( struct extent_io_tree * tree , struct page * page , get_extent_t * get_extent , struct writeback_control * wbc ) ;

int extent_write_locked_range ( struct extent_io_tree * tree , struct inode * inode , u64 start , u64 end , get_extent_t * get_extent , int mode ) ;

int extent_writepages ( struct extent_io_tree * tree , struct address_space * mapping , get_extent_t * get_extent , struct writeback_control * wbc ) ;

int extent_readpages ( struct extent_io_tree * tree , struct address_space * mapping , struct list_head * pages , unsigned nr_pages , get_extent_t get_extent ) ;

int extent_invalidatepage ( struct extent_io_tree * tree , struct page * page , unsigned long offset ) ;

int extent_commit_write ( struct extent_io_tree * tree , struct inode * inode , struct page * page , unsigned from , unsigned to ) ;

int extent_prepare_write ( struct extent_io_tree * tree , struct inode * inode , struct page * page , unsigned from , unsigned to , get_extent_t * get_extent ) ;

int try_release_extent_state ( struct extent_map_tree * map , struct extent_io_tree * tree , struct page * page , gfp_t mask ) ;

int try_release_extent_mapping ( struct extent_map_tree * map , struct extent_io_tree * tree , struct page * page , gfp_t mask ) ;

sector_t extent_bmap ( struct address_space * mapping , sector_t iblock , get_extent_t * get_extent ) ;

int extent_fiemap ( struct inode * inode , struct fiemap_extent_info * fieinfo , __u64 start , __u64 len , get_extent_t * get_extent ) ;

struct extent_buffer * alloc_extent_buffer ( struct extent_io_tree * tree , u64 start , unsigned long len , struct page * page0 , gfp_t mask ) ;

struct extent_buffer * find_extent_buffer ( struct extent_io_tree * tree , u64 start , unsigned long len , gfp_t mask ) ;

void free_extent_buffer ( struct extent_buffer * eb ) ;

int clear_extent_buffer_dirty ( struct extent_io_tree * tree , struct extent_buffer * eb ) ;

int wait_on_extent_buffer_writeback ( struct extent_io_tree * tree , struct extent_buffer * eb ) ;

int set_extent_buffer_dirty ( struct extent_io_tree * tree , struct extent_buffer * eb ) ;

int clear_extent_buffer_uptodate ( struct extent_io_tree * tree , struct extent_buffer * eb ) ;

int set_extent_buffer_uptodate ( struct extent_io_tree * tree , struct extent_buffer * eb ) ;

int extent_range_uptodate ( struct extent_io_tree * tree , u64 start , u64 end ) ;

int extent_buffer_uptodate ( struct extent_io_tree * tree , struct extent_buffer * eb ) ;

int read_extent_buffer_pages ( struct extent_io_tree * tree , struct extent_buffer * eb , u64 start , int wait , get_extent_t * get_extent , int mirror_num ) ;

void read_extent_buffer ( struct extent_buffer * eb , void * dstv , unsigned long start , unsigned long len ) ;

int map_private_extent_buffer ( struct extent_buffer * eb , unsigned long start , unsigned long min_len , char * * token , char * * map , unsigned long * map_start , unsigned long * map_len , int km ) ;

int map_extent_buffer ( struct extent_buffer * eb , unsigned long start , unsigned long min_len , char * * token , char * * map , unsigned long * map_start , unsigned long * map_len , int km ) ;

void unmap_extent_buffer ( struct extent_buffer * eb , char * token , int km ) ;

int memcmp_extent_buffer ( struct extent_buffer * eb , const void * ptrv , unsigned long start , unsigned long len ) ;

void write_extent_buffer ( struct extent_buffer * eb , const void * srcv , unsigned long start , unsigned long len ) ;

void memset_extent_buffer ( struct extent_buffer * eb , char c , unsigned long start , unsigned long len ) ;

void copy_extent_buffer ( struct extent_buffer * dst , struct extent_buffer * src , unsigned long dst_offset , unsigned long src_offset , unsigned long len ) ;

void memcpy_extent_buffer ( struct extent_buffer * dst , unsigned long dst_offset , unsigned long src_offset , unsigned long len ) ;

void memmove_extent_buffer ( struct extent_buffer * dst , unsigned long dst_offset , unsigned long src_offset , unsigned long len ) ;

int try_release_extent_buffer ( struct extent_io_tree * tree , struct page * page ) ;

struct map_lookup { u64 type ; int io_align ; int io_width ; int stripe_len ; int sector_size ; int num_stripes ; int sub_stripes ; struct btrfs_bio_stripe stripes [ ] ; } ;

void btrfs_lock_volumes ( void ) ;

void btrfs_unlock_volumes ( void ) ;

int btrfs_cleanup_fs_uuids ( void ) ;

int btrfs_close_extra_devices ( struct btrfs_fs_devices * fs_devices ) ;

int btrfs_close_devices ( struct btrfs_fs_devices * fs_devices ) ;

int btrfs_open_devices ( struct btrfs_fs_devices * fs_devices , fmode_t flags , void * holder ) ;

int btrfs_scan_one_device ( const char * path , fmode_t flags , void * holder , struct btrfs_fs_devices * * fs_devices_ret ) ;

int find_free_dev_extent ( struct btrfs_trans_handle * trans , struct btrfs_device * device , u64 num_bytes , u64 * start , u64 * max_avail ) ;

int btrfs_alloc_dev_extent ( struct btrfs_trans_handle * trans , struct btrfs_device * device , u64 chunk_tree , u64 chunk_objectid , u64 chunk_offset , u64 start , u64 num_bytes ) ;

int btrfs_add_device ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_device * device ) ;

int btrfs_rm_device ( struct btrfs_root * root , char * device_path ) ;

int btrfs_init_new_device ( struct btrfs_root * root , char * device_path ) ;

int btrfs_grow_device ( struct btrfs_trans_handle * trans , struct btrfs_device * device , u64 new_size ) ;

int btrfs_balance ( struct btrfs_root * dev_root ) ;

int btrfs_shrink_device ( struct btrfs_device * device , u64 new_size ) ;

int btrfs_alloc_chunk ( struct btrfs_trans_handle * trans , struct btrfs_root * extent_root , u64 type ) ;

int btrfs_chunk_readonly ( struct btrfs_root * root , u64 chunk_offset ) ;

void btrfs_mapping_init ( struct btrfs_mapping_tree * tree ) ;

void btrfs_mapping_tree_free ( struct btrfs_mapping_tree * tree ) ;

int btrfs_num_copies ( struct btrfs_mapping_tree * map_tree , u64 logical , u64 len ) ;

int btrfs_map_block ( struct btrfs_mapping_tree * map_tree , int rw , u64 logical , u64 * length , struct btrfs_multi_bio * * multi_ret , int mirror_num ) ;

int btrfs_rmap_block ( struct btrfs_mapping_tree * map_tree , u64 chunk_start , u64 physical , u64 devid , u64 * * logical , int * naddrs , int * stripe_len ) ;

int btrfs_unplug_page ( struct btrfs_mapping_tree * map_tree , u64 logical , struct page * page ) ;

struct async_sched { struct bio * bio ; int rw ; struct btrfs_fs_info * info ; struct btrfs_work work ; } ;

int btrfs_map_bio ( struct btrfs_root * root , int rw , struct bio * bio , int mirror_num , int async_submit ) ;

struct btrfs_device * btrfs_find_device ( struct btrfs_root * root , u64 devid , u8 * uuid , u8 * fsid ) ;

int btrfs_read_super_device ( struct btrfs_root * root , struct extent_buffer * buf ) ;

int btrfs_read_sys_array ( struct btrfs_root * root ) ;

int btrfs_read_chunk_tree ( struct btrfs_root * root ) ;

struct btrfs_worker_thread { struct btrfs_workers * workers ; struct list_head pending ; struct list_head prio_pending ; struct list_head worker_list ; struct task_struct * task ; atomic_t num_pending ; atomic_t refs ; unsigned long sequence ; spinlock_t lock ; int working ; int idle ; } ;
struct worker_start { struct btrfs_work work ; struct btrfs_workers * queue ; } ;

int btrfs_stop_workers ( struct btrfs_workers * workers ) ;

void btrfs_init_workers ( struct btrfs_workers * workers , char * name , int max , struct btrfs_workers * async_helper ) ;

int btrfs_start_workers ( struct btrfs_workers * workers , int num_workers ) ;

int btrfs_requeue_work ( struct btrfs_work * work ) ;

void btrfs_set_work_high_prio ( struct btrfs_work * work ) ;

int btrfs_queue_worker ( struct btrfs_workers * workers , struct btrfs_work * work ) ;

void btrfs_update_iflags ( struct inode * inode ) ;

void btrfs_inherit_iflags ( struct inode * inode , struct inode * dir ) ;

long btrfs_ioctl_trans_end ( struct file * file ) ;

long btrfs_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) ;

void btrfs_set_lock_blocking ( struct extent_buffer * eb ) ;

void btrfs_clear_lock_blocking ( struct extent_buffer * eb ) ;

int btrfs_try_spin_lock ( struct extent_buffer * eb ) ;

int btrfs_tree_lock ( struct extent_buffer * eb ) ;

int btrfs_try_tree_lock ( struct extent_buffer * eb ) ;

int btrfs_tree_unlock ( struct extent_buffer * eb ) ;

void btrfs_assert_tree_locked ( struct extent_buffer * eb ) ;

int btrfs_insert_orphan_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 offset ) ;

int btrfs_del_orphan_item ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 offset ) ;

int btrfs_find_orphan_item ( struct btrfs_root * root , u64 offset ) ;

int btrfs_pin_log_trans ( struct btrfs_root * root ) ;

int btrfs_end_log_trans ( struct btrfs_root * root ) ;

struct walk_control { int free ; int write ; int wait ; int pin ; int stage ; struct btrfs_root * replay_dest ; struct btrfs_trans_handle * trans ; int ( * process_func ) ( struct btrfs_root * log , struct extent_buffer * eb , struct walk_control * wc , u64 gen ) ; } ;
int btrfs_sync_log ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_free_log ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_del_dir_entries_in_log ( struct btrfs_trans_handle * trans , struct btrfs_root * root , const char * name , int name_len , struct inode * dir , u64 index ) ;

int btrfs_del_inode_ref_in_log ( struct btrfs_trans_handle * trans , struct btrfs_root * root , const char * name , int name_len , struct inode * inode , u64 dirid ) ;

int btrfs_log_inode_parent ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode , struct dentry * parent , int exists_only ) ;

int btrfs_log_dentry_safe ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct dentry * dentry ) ;

int btrfs_recover_log_trees ( struct btrfs_root * log_root_tree ) ;

void btrfs_record_unlink_dir ( struct btrfs_trans_handle * trans , struct inode * dir , struct inode * inode , int for_rename ) ;

int btrfs_log_new_name ( struct btrfs_trans_handle * trans , struct inode * inode , struct inode * old_dir , struct dentry * parent ) ;

int btrfs_check_acl ( struct inode * inode , int mask ) ;

int btrfs_init_acl ( struct btrfs_trans_handle * trans , struct inode * inode , struct inode * dir ) ;

int btrfs_acl_chmod ( struct inode * inode ) ;

int btrfs_add_free_space ( struct btrfs_block_group_cache * block_group , u64 offset , u64 bytes ) ;

int btrfs_remove_free_space ( struct btrfs_block_group_cache * block_group , u64 offset , u64 bytes ) ;

void btrfs_dump_free_space ( struct btrfs_block_group_cache * block_group , u64 bytes ) ;

u64 btrfs_block_group_free_space ( struct btrfs_block_group_cache * block_group ) ;

void btrfs_remove_free_space_cache ( struct btrfs_block_group_cache * block_group ) ;

u64 btrfs_find_space_for_alloc ( struct btrfs_block_group_cache * block_group , u64 offset , u64 bytes , u64 empty_size ) ;

int btrfs_return_cluster_to_free_space ( struct btrfs_block_group_cache * block_group , struct btrfs_free_cluster * cluster ) ;

u64 btrfs_alloc_from_cluster ( struct btrfs_block_group_cache * block_group , struct btrfs_free_cluster * cluster , u64 bytes , u64 min_start ) ;

int btrfs_find_space_cluster ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_block_group_cache * block_group , struct btrfs_free_cluster * cluster , u64 offset , u64 bytes , u64 empty_size ) ;

void btrfs_init_free_cluster ( struct btrfs_free_cluster * cluster ) ;

typedef unsigned char Byte ;

typedef unsigned int uInt ;

typedef unsigned long uLong ;

typedef void * voidp ;

struct internal_state ;


typedef struct z_stream_s { const Byte * next_in ; uInt avail_in ; uLong total_in ; Byte * next_out ; uInt avail_out ; uLong total_out ; char * msg ; struct internal_state * state ; void * workspace ; int data_type ; uLong adler ; uLong reserved ; } z_stream ;

typedef z_stream * z_streamp ;

struct internal_state { int dummy ; } ;
typedef unsigned char uch ;

typedef unsigned short ush ;

typedef unsigned long ulg ;

typedef uLong ( * check_func ) ( uLong check , const Byte * buf , uInt len ) ;

struct workspace { z_stream inf_strm ; z_stream def_strm ; char * buf ; struct list_head list ; } ;

int btrfs_zlib_compress_pages ( struct address_space * mapping , u64 start , unsigned long len , struct page * * pages , unsigned long nr_dest_pages , unsigned long * out_pages , unsigned long * total_in , unsigned long * total_out , unsigned long max_out ) ;

int btrfs_zlib_decompress_biovec ( struct page * * pages_in , u64 disk_start , struct bio_vec * bvec , int vcnt , size_t srclen ) ;

int btrfs_zlib_decompress ( unsigned char * data_in , struct page * dest_page , unsigned long start_byte , size_t srclen , size_t destlen ) ;

void btrfs_zlib_exit ( void ) ;

struct compressed_bio { atomic_t pending_bios ; struct page * * compressed_pages ; struct inode * inode ; u64 start ; unsigned long len ; unsigned long compressed_len ; unsigned long nr_pages ; int errors ; int mirror_num ; struct bio * orig_bio ; u32 sums ; } ;

int btrfs_submit_compressed_write ( struct inode * inode , u64 start , unsigned long len , u64 disk_start , unsigned long compressed_len , struct page * * compressed_pages , unsigned long nr_pages ) ;

int btrfs_submit_compressed_read ( struct inode * inode , struct bio * bio , int mirror_num , unsigned long bio_flags ) ;

int btrfs_delayed_ref_lock ( struct btrfs_trans_handle * trans , struct btrfs_delayed_ref_head * head ) ;

int btrfs_find_ref_cluster ( struct btrfs_trans_handle * trans , struct list_head * cluster , u64 start ) ;

int btrfs_delayed_ref_pending ( struct btrfs_trans_handle * trans , u64 bytenr ) ;

int btrfs_lookup_extent_info ( struct btrfs_trans_handle * trans , struct btrfs_root * root , u64 bytenr , u64 num_bytes , u64 * refs , u64 * flags ) ;

int btrfs_add_delayed_tree_ref ( struct btrfs_trans_handle * trans , u64 bytenr , u64 num_bytes , u64 parent , u64 ref_root , int level , int action , struct btrfs_delayed_extent_op * extent_op ) ;

int btrfs_add_delayed_data_ref ( struct btrfs_trans_handle * trans , u64 bytenr , u64 num_bytes , u64 parent , u64 ref_root , u64 owner , u64 offset , int action , struct btrfs_delayed_extent_op * extent_op ) ;

int btrfs_add_delayed_extent_op ( struct btrfs_trans_handle * trans , u64 bytenr , u64 num_bytes , struct btrfs_delayed_extent_op * extent_op ) ;

struct btrfs_delayed_ref_head * btrfs_find_delayed_ref_head ( struct btrfs_trans_handle * trans , u64 bytenr ) ;

struct tree_entry { struct rb_node rb_node ; u64 bytenr ; } ;
struct backref_node { struct rb_node rb_node ; u64 bytenr ; u64 owner ; struct list_head upper ; struct list_head lower ; struct btrfs_root * root ; struct extent_buffer * eb ; unsigned int level : 8 ; unsigned int old_root : 1 ; unsigned int lowest : 1 ; unsigned int locked : 1 ; unsigned int processed : 1 ; unsigned int checked : 1 ; } ;

struct backref_edge { struct list_head list [ 2 ] ; struct backref_node * node [ 2 ] ; u64 blockptr ; } ;

struct backref_cache { struct rb_root rb_root ; struct list_head pending [ 8 ] ; spinlock_t lock ; } ;

struct mapping_node { struct rb_node rb_node ; u64 bytenr ; void * data ; } ;

struct mapping_tree { struct rb_root rb_root ; spinlock_t lock ; } ;

struct tree_block { struct rb_node rb_node ; u64 bytenr ; struct btrfs_key key ; unsigned int level : 8 ; unsigned int key_ready : 1 ; } ;

struct inodevec { struct list_head list ; struct inode * inode [ 16 ] ; int nr ; } ;

struct file_extent_cluster { u64 start ; u64 end ; u64 boundary [ 128 ] ; unsigned int nr ; } ;

struct reloc_control { struct btrfs_block_group_cache * block_group ; struct btrfs_root * extent_root ; struct inode * data_inode ; struct btrfs_workers workers ; struct extent_io_tree processed_blocks ; struct mapping_tree reloc_root_tree ; struct list_head reloc_roots ; u64 search_start ; u64 extents_found ; u64 extents_skipped ; int stage ; int create_reloc_root ; unsigned int found_file_extent : 1 ; unsigned int found_old_snapshot : 1 ; } ;
struct async_merge { struct btrfs_work work ; struct reloc_control * rc ; struct btrfs_root * root ; struct completion * done ; atomic_t * num_pending ; } ;

int btrfs_init_reloc_root ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_update_reloc_root ( struct btrfs_trans_handle * trans , struct btrfs_root * root ) ;

int btrfs_relocate_block_group ( struct btrfs_root * extent_root , u64 group_start ) ;

int btrfs_recover_relocation ( struct btrfs_root * root ) ;

int btrfs_reloc_clone_csums ( struct inode * inode , u64 file_pos , u64 len ) ;

struct dentry * debugfs_create_file ( const char * name , mode_t mode , struct dentry * parent , void * data , const struct file_operations * fops ) ;

struct dentry * debugfs_create_dir ( const char * name , struct dentry * parent ) ;

struct dentry * debugfs_create_symlink ( const char * name , struct dentry * parent , const char * target ) ;

void debugfs_remove ( struct dentry * dentry ) ;

void debugfs_remove_recursive ( struct dentry * dentry ) ;

struct dentry * debugfs_rename ( struct dentry * old_dir , struct dentry * old_dentry , struct dentry * new_dir , const char * new_name ) ;

bool debugfs_initialized ( void ) ;

struct dentry * debugfs_create_u8 ( const char * name , mode_t mode , struct dentry * parent , u8 * value ) ;

struct dentry * debugfs_create_u16 ( const char * name , mode_t mode , struct dentry * parent , u16 * value ) ;

struct dentry * debugfs_create_u32 ( const char * name , mode_t mode , struct dentry * parent , u32 * value ) ;

struct dentry * debugfs_create_u64 ( const char * name , mode_t mode , struct dentry * parent , u64 * value ) ;

struct dentry * debugfs_create_x8 ( const char * name , mode_t mode , struct dentry * parent , u8 * value ) ;

struct dentry * debugfs_create_x16 ( const char * name , mode_t mode , struct dentry * parent , u16 * value ) ;

struct dentry * debugfs_create_x32 ( const char * name , mode_t mode , struct dentry * parent , u32 * value ) ;

struct dentry * debugfs_create_size_t ( const char * name , mode_t mode , struct dentry * parent , size_t * value ) ;

struct dentry * debugfs_create_bool ( const char * name , mode_t mode , struct dentry * parent , u32 * value ) ;

struct dentry * debugfs_create_blob ( const char * name , mode_t mode , struct dentry * parent , struct debugfs_blob_wrapper * blob ) ;

struct pts_mount_opts { int setuid ; int setgid ; uid_t uid ; gid_t gid ; umode_t mode ; umode_t ptmxmode ; int newinstance ; } ;

enum { Opt_uid , Opt_gid , Opt_mode , Opt_ptmxmode , Opt_newinstance , Opt_err } ;
struct pts_fs_info { struct ida allocated_ptys ; struct pts_mount_opts mount_opts ; struct dentry * ptmx_dentry ; } ;

int devpts_new_index ( struct inode * ptmx_inode ) ;

void devpts_kill_index ( struct inode * ptmx_inode , int idx ) ;

int devpts_pty_new ( struct inode * ptmx_inode , struct tty_struct * tty ) ;

struct tty_struct * devpts_get_tty ( struct inode * pts_inode , int number ) ;

void devpts_pty_kill ( struct tty_struct * tty ) ;

struct user_key_payload { struct rcu_head rcu ; unsigned short datalen ; char data [ 0 ] ; } ;

struct ecryptfs_session_key { u32 flags ; u32 encrypted_key_size ; u32 decrypted_key_size ; u8 encrypted_key [ 512 ] ; u8 decrypted_key [ 64 ] ; } ;

struct ecryptfs_password { u32 password_bytes ; s32 hash_algo ; u32 hash_iterations ; u32 session_key_encryption_key_bytes ; u32 flags ; u8 session_key_encryption_key [ 64 ] ; u8 signature [ ( 8 * 2 ) + 1 ] ; u8 salt [ 8 ] ; } ;

enum ecryptfs_token_types { ECRYPTFS_PASSWORD , ECRYPTFS_PRIVATE_KEY } ;

struct ecryptfs_private_key { u32 key_size ; u32 data_len ; u8 signature [ ( 8 * 2 ) + 1 ] ; char pki_type [ 16 + 1 ] ; u8 data [ ] ; } ;

struct ecryptfs_auth_tok { u16 version ; u16 token_type ; u32 flags ; struct ecryptfs_session_key session_key ; u8 reserved [ 32 ] ; union { struct ecryptfs_password password ; struct ecryptfs_private_key private_key ; } token ; } __attribute__ ( ( packed ) ) ;
struct ecryptfs_key_record { unsigned char type ; size_t enc_key_size ; unsigned char sig [ 8 ] ; unsigned char enc_key [ 512 ] ; } ;

struct ecryptfs_auth_tok_list { struct ecryptfs_auth_tok * auth_tok ; struct list_head list ; } ;

struct ecryptfs_crypt_stat ;

struct ecryptfs_mount_crypt_stat ;

struct ecryptfs_page_crypt_context { struct page * page ; unsigned int mode ; union { struct file * lower_file ; struct writeback_control * wbc ; } param ; } ;

struct ecryptfs_key_sig { struct list_head crypt_stat_list ; char keysig [ ( 8 * 2 ) ] ; } ;

struct ecryptfs_filename { struct list_head crypt_stat_list ; u32 flags ; u32 seq_no ; char * filename ; char * encrypted_filename ; size_t filename_size ; size_t encrypted_filename_size ; char fnek_sig [ ( 8 * 2 ) ] ; char dentry_name [ ( 18 + 1 + 4 + 1 + 32 ) + 1 ] ; } ;

struct ecryptfs_crypt_stat { u32 flags ; unsigned int file_version ; size_t iv_bytes ; size_t num_header_bytes_at_front ; size_t extent_size ; size_t key_size ; size_t extent_shift ; unsigned int extent_mask ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat ; struct crypto_blkcipher * tfm ; struct crypto_hash * hash_tfm ; unsigned char cipher [ 32 ] ; unsigned char key [ 64 ] ; unsigned char root_iv [ 16 ] ; struct list_head keysig_list ; struct mutex keysig_list_mutex ; struct mutex cs_tfm_mutex ; struct mutex cs_hash_tfm_mutex ; struct mutex cs_mutex ; } ;
struct ecryptfs_inode_info { struct inode vfs_inode ; struct inode * wii_inode ; struct file * lower_file ; struct mutex lower_file_mutex ; struct ecryptfs_crypt_stat crypt_stat ; } ;

struct ecryptfs_dentry_info { struct path lower_path ; struct ecryptfs_crypt_stat * crypt_stat ; } ;

struct ecryptfs_global_auth_tok { u32 flags ; struct list_head mount_crypt_stat_list ; struct key * global_auth_tok_key ; struct ecryptfs_auth_tok * global_auth_tok ; unsigned char sig [ ( 8 * 2 ) + 1 ] ; } ;

struct ecryptfs_key_tfm { struct crypto_blkcipher * key_tfm ; size_t key_size ; struct mutex key_tfm_mutex ; struct list_head key_tfm_list ; unsigned char cipher_name [ 32 + 1 ] ; } ;

struct ecryptfs_mount_crypt_stat { u32 flags ; struct list_head global_auth_tok_list ; struct mutex global_auth_tok_list_mutex ; size_t num_global_auth_toks ; size_t global_default_cipher_key_size ; size_t global_default_fn_cipher_key_bytes ; unsigned char global_default_cipher_name [ 32 + 1 ] ; unsigned char global_default_fn_cipher_name [ 32 + 1 ] ; char global_default_fnek_sig [ ( 8 * 2 ) + 1 ] ; } ;
struct ecryptfs_sb_info { struct super_block * wsi_sb ; struct ecryptfs_mount_crypt_stat mount_crypt_stat ; } ;

struct ecryptfs_file_info { struct file * wfi_file ; struct ecryptfs_crypt_stat * crypt_stat ; } ;

struct ecryptfs_auth_tok_list_item { unsigned char encrypted_session_key [ 64 ] ; struct list_head list ; struct ecryptfs_auth_tok auth_tok ; } ;

struct ecryptfs_message { u32 index ; u32 data_len ; u8 data [ ] ; } ;

struct ecryptfs_msg_ctx { u8 state ; u8 type ; u32 index ; u32 counter ; size_t msg_size ; struct ecryptfs_message * msg ; struct task_struct * task ; struct list_head node ; struct list_head daemon_out_list ; struct mutex mux ; } ;

struct ecryptfs_daemon ;

struct ecryptfs_daemon { u32 flags ; u32 num_queued_msg_ctx ; struct pid * pid ; uid_t euid ; struct user_namespace * user_ns ; struct task_struct * task ; struct mutex mux ; struct list_head msg_ctx_out_queue ; wait_queue_head_t wait ; struct hlist_node euid_chain ; } ;
struct ecryptfs_open_req { u32 flags ; struct file * * lower_file ; struct dentry * lower_dentry ; struct vfsmount * lower_mnt ; wait_queue_head_t wait ; struct mutex mux ; struct list_head kthread_ctl_list ; } ;

struct ecryptfs_getdents_callback { void * dirent ; struct dentry * dentry ; filldir_t filldir ; int filldir_called ; int entries_written ; } ;

int ecryptfs_lookup_and_interpose_lower ( struct dentry * ecryptfs_dentry , struct dentry * lower_dentry , struct inode * ecryptfs_dir_inode , struct nameidata * ecryptfs_nd ) ;

int ecryptfs_truncate ( struct dentry * dentry , loff_t new_length ) ;

int ecryptfs_getattr_link ( struct vfsmount * mnt , struct dentry * dentry , struct kstat * stat ) ;

int ecryptfs_getattr ( struct vfsmount * mnt , struct dentry * dentry , struct kstat * stat ) ;

int ecryptfs_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

ssize_t ecryptfs_getxattr_lower ( struct dentry * lower_dentry , const char * name , void * value , size_t size ) ;

int ecryptfs_inode_test ( struct inode * inode , void * candidate_lower_inode ) ;

int ecryptfs_inode_set ( struct inode * inode , void * lower_inode ) ;

void __ecryptfs_printk ( const char * fmt , ... ) ;

int ecryptfs_init_persistent_file ( struct dentry * ecryptfs_dentry ) ;

int ecryptfs_interpose ( struct dentry * lower_dentry , struct dentry * dentry , struct super_block * sb , u32 flags ) ;

enum { ecryptfs_opt_sig , ecryptfs_opt_ecryptfs_sig , ecryptfs_opt_cipher , ecryptfs_opt_ecryptfs_cipher , ecryptfs_opt_ecryptfs_key_bytes , ecryptfs_opt_passthrough , ecryptfs_opt_xattr_metadata , ecryptfs_opt_encrypted_view , ecryptfs_opt_fnek_sig , ecryptfs_opt_fn_cipher , ecryptfs_opt_fn_cipher_key_bytes , ecryptfs_opt_unlink_sigs , ecryptfs_opt_err } ;

void ecryptfs_init_inode ( struct inode * inode , struct inode * lower_inode ) ;

struct page * ecryptfs_get_locked_page ( struct file * file , loff_t index ) ;

int ecryptfs_write_inode_size_to_metadata ( struct inode * ecryptfs_inode ) ;

int ecryptfs_write_lower ( struct inode * ecryptfs_inode , char * data , loff_t offset , size_t size ) ;

int ecryptfs_write_lower_page_segment ( struct inode * ecryptfs_inode , struct page * page_for_lower , size_t offset_in_page , size_t size ) ;

int ecryptfs_write ( struct file * ecryptfs_file , char * data , loff_t offset , size_t size ) ;

int ecryptfs_read_lower ( char * data , loff_t offset , size_t size , struct inode * ecryptfs_inode ) ;

int ecryptfs_read_lower_page_segment ( struct page * page_for_ecryptfs , unsigned long page_index , size_t offset_in_page , size_t size , struct inode * ecryptfs_inode ) ;

void ecryptfs_to_hex ( char * dst , char * src , size_t src_size ) ;

void ecryptfs_from_hex ( char * dst , char * src , int dst_size ) ;

int ecryptfs_derive_iv ( char * iv , struct ecryptfs_crypt_stat * crypt_stat , loff_t offset ) ;

void ecryptfs_init_crypt_stat ( struct ecryptfs_crypt_stat * crypt_stat ) ;

void ecryptfs_destroy_crypt_stat ( struct ecryptfs_crypt_stat * crypt_stat ) ;

void ecryptfs_destroy_mount_crypt_stat ( struct ecryptfs_mount_crypt_stat * mount_crypt_stat ) ;

int virt_to_scatterlist ( const void * addr , int size , struct scatterlist * sg , int sg_size ) ;

int ecryptfs_encrypt_page ( struct page * page ) ;

int ecryptfs_decrypt_page ( struct page * page ) ;

int ecryptfs_init_crypt_ctx ( struct ecryptfs_crypt_stat * crypt_stat ) ;

void ecryptfs_set_default_sizes ( struct ecryptfs_crypt_stat * crypt_stat ) ;

int ecryptfs_compute_root_iv ( struct ecryptfs_crypt_stat * crypt_stat ) ;

int ecryptfs_new_file_context ( struct dentry * ecryptfs_dentry ) ;

struct ecryptfs_flag_map_elem { u32 file_flag ; u32 local_flag ; } ;

struct ecryptfs_cipher_code_str_map_elem { char cipher_str [ 16 ] ; u8 cipher_code ; } ;

u8 ecryptfs_code_for_cipher_string ( char * cipher_name , size_t key_bytes ) ;

int ecryptfs_cipher_code_to_string ( char * str , u8 cipher_code ) ;

int ecryptfs_read_and_validate_header_region ( char * data , struct inode * ecryptfs_inode ) ;

void ecryptfs_write_header_metadata ( char * virt , struct ecryptfs_crypt_stat * crypt_stat , size_t * written ) ;

int ecryptfs_write_metadata ( struct dentry * ecryptfs_dentry ) ;

int ecryptfs_read_xattr_region ( char * page_virt , struct inode * ecryptfs_inode ) ;

int ecryptfs_read_and_validate_xattr_region ( char * page_virt , struct dentry * ecryptfs_dentry ) ;

int ecryptfs_read_metadata ( struct dentry * ecryptfs_dentry ) ;

int ecryptfs_init_crypto ( void ) ;

int ecryptfs_destroy_crypto ( void ) ;

int ecryptfs_add_new_key_tfm ( struct ecryptfs_key_tfm * * key_tfm , char * cipher_name , size_t key_size ) ;

int ecryptfs_tfm_exists ( char * cipher_name , struct ecryptfs_key_tfm * * key_tfm ) ;

int ecryptfs_get_tfm_and_mutex_for_cipher_name ( struct crypto_blkcipher * * tfm , struct mutex * * tfm_mutex , char * cipher_name ) ;

void ecryptfs_encode_for_filename ( unsigned char * dst , size_t * dst_size , unsigned char * src , size_t src_size ) ;

int ecryptfs_encrypt_and_encode_filename ( char * * encoded_name , size_t * encoded_name_size , struct ecryptfs_crypt_stat * crypt_stat , struct ecryptfs_mount_crypt_stat * mount_crypt_stat , const char * name , size_t name_size ) ;

int ecryptfs_decode_and_decrypt_filename ( char * * plaintext_name , size_t * plaintext_name_size , struct dentry * ecryptfs_dir_dentry , const char * name , size_t name_size ) ;

int ecryptfs_parse_packet_length ( unsigned char * data , size_t * size , size_t * length_size ) ;

int ecryptfs_write_packet_length ( char * dest , size_t size , size_t * packet_size_length ) ;

struct ecryptfs_write_tag_70_packet_silly_stack { u8 cipher_code ; size_t max_packet_size ; size_t packet_size_len ; size_t block_aligned_filename_size ; size_t block_size ; size_t i ; size_t j ; size_t num_rand_bytes ; struct mutex * tfm_mutex ; char * block_aligned_filename ; struct ecryptfs_auth_tok * auth_tok ; struct scatterlist src_sg ; struct scatterlist dst_sg ; struct blkcipher_desc desc ; char iv [ 16 ] ; char hash [ 16 ] ; char tmp_hash [ 16 ] ; struct hash_desc hash_desc ; struct scatterlist hash_sg ; } ;

int ecryptfs_write_tag_70_packet ( char * dest , size_t * remaining_bytes , size_t * packet_size , struct ecryptfs_mount_crypt_stat * mount_crypt_stat , char * filename , size_t filename_size ) ;

struct ecryptfs_parse_tag_70_packet_silly_stack { u8 cipher_code ; size_t max_packet_size ; size_t packet_size_len ; size_t parsed_tag_70_packet_size ; size_t block_aligned_filename_size ; size_t block_size ; size_t i ; struct mutex * tfm_mutex ; char * decrypted_filename ; struct ecryptfs_auth_tok * auth_tok ; struct scatterlist src_sg ; struct scatterlist dst_sg ; struct blkcipher_desc desc ; char fnek_sig_hex [ ( 8 * 2 ) + 1 ] ; char iv [ 16 ] ; char cipher_string [ 32 ] ; } ;

int ecryptfs_parse_tag_70_packet ( char * * filename , size_t * filename_size , size_t * packet_size , struct ecryptfs_mount_crypt_stat * mount_crypt_stat , char * data , size_t max_packet_size ) ;

int ecryptfs_keyring_auth_tok_for_sig ( struct key * * auth_tok_key , struct ecryptfs_auth_tok * * auth_tok , char * sig ) ;

int ecryptfs_parse_packet_set ( struct ecryptfs_crypt_stat * crypt_stat , unsigned char * src , struct dentry * ecryptfs_dentry ) ;

int ecryptfs_generate_key_packet_set ( char * dest_base , struct ecryptfs_crypt_stat * crypt_stat , struct dentry * ecryptfs_dentry , size_t * len , size_t max ) ;

int ecryptfs_add_keysig ( struct ecryptfs_crypt_stat * crypt_stat , char * sig ) ;

int ecryptfs_add_global_auth_tok ( struct ecryptfs_mount_crypt_stat * mount_crypt_stat , char * sig , u32 global_auth_tok_flags ) ;

void ecryptfs_msg_ctx_alloc_to_free ( struct ecryptfs_msg_ctx * msg_ctx ) ;

int ecryptfs_find_daemon_by_euid ( struct ecryptfs_daemon * * daemon , uid_t euid , struct user_namespace * user_ns ) ;

int ecryptfs_spawn_daemon ( struct ecryptfs_daemon * * daemon , uid_t euid , struct user_namespace * user_ns , struct pid * pid ) ;

int ecryptfs_exorcise_daemon ( struct ecryptfs_daemon * daemon ) ;

int ecryptfs_process_quit ( uid_t euid , struct user_namespace * user_ns , struct pid * pid ) ;

int ecryptfs_process_response ( struct ecryptfs_message * msg , uid_t euid , struct user_namespace * user_ns , struct pid * pid , u32 seq ) ;

int ecryptfs_send_message ( char * data , int data_len , struct ecryptfs_msg_ctx * * msg_ctx ) ;

int ecryptfs_wait_for_response ( struct ecryptfs_msg_ctx * msg_ctx , struct ecryptfs_message * * msg ) ;

int ecryptfs_init_messaging ( void ) ;

void ecryptfs_release_messaging ( void ) ;

int ecryptfs_send_miscdev ( char * data , size_t data_size , struct ecryptfs_msg_ctx * msg_ctx , u8 msg_type , u16 msg_flags , struct ecryptfs_daemon * daemon ) ;

int ecryptfs_init_ecryptfs_miscdev ( void ) ;

void ecryptfs_destroy_ecryptfs_miscdev ( void ) ;


int ecryptfs_init_kthread ( void ) ;

void ecryptfs_destroy_kthread ( void ) ;

int ecryptfs_privileged_open ( struct file * * lower_file , struct dentry * lower_dentry , struct vfsmount * lower_mnt , const struct cred * cred ) ;

void ecryptfs_dump_auth_tok ( struct ecryptfs_auth_tok * auth_tok ) ;

void ecryptfs_dump_hex ( char * data , int bytes ) ;

struct getdents_callback { char * name ; unsigned long ino ; int found ; int sequence ; } ;
int exportfs_encode_fh ( struct dentry * dentry , struct fid * fid , int * max_len , int connectable ) ;

struct dentry * exportfs_decode_fh ( struct vfsmount * mnt , struct fid * fid , int fh_len , int fileid_type , int ( * acceptable ) ( void * , struct dentry * ) , void * context ) ;

struct ext2_mount_options { unsigned long s_mount_opt ; uid_t s_resuid ; gid_t s_resgid ; } ;

struct ext2_inode_info { __le32 i_data [ 15 ] ; __u32 i_flags ; __u32 i_faddr ; __u8 i_frag_no ; __u8 i_frag_size ; __u16 i_state ; __u32 i_file_acl ; __u32 i_dir_acl ; __u32 i_dtime ; __u32 i_block_group ; struct ext2_block_alloc_info * i_block_alloc_info ; __u32 i_dir_start_lookup ; struct rw_semaphore xattr_sem ; rwlock_t i_meta_lock ; struct mutex truncate_mutex ; struct inode vfs_inode ; struct list_head i_orphan ; } ;

struct ext2_group_desc * ext2_get_group_desc ( struct super_block * sb , unsigned int block_group , struct buffer_head * * bh ) ;

void ext2_rsv_window_add ( struct super_block * sb , struct ext2_reserve_window_node * rsv ) ;

void ext2_init_block_alloc_info ( struct inode * inode ) ;

void ext2_discard_reservation ( struct inode * inode ) ;

void ext2_free_blocks ( struct inode * inode , unsigned long block , unsigned long count ) ;

ext2_fsblk_t ext2_new_blocks ( struct inode * inode , ext2_fsblk_t goal , unsigned long * count , int * errp ) ;

ext2_fsblk_t ext2_new_block ( struct inode * inode , unsigned long goal , int * errp ) ;

unsigned long ext2_count_free_blocks ( struct super_block * sb ) ;

int ext2_bg_has_super ( struct super_block * sb , int group ) ;

unsigned long ext2_bg_num_gdb ( struct super_block * sb , int group ) ;

typedef struct ext2_dir_entry_2 ext2_dirent ;

struct ext2_dir_entry_2 * ext2_find_entry ( struct inode * dir , struct qstr * child , struct page * * res_page ) ;

struct ext2_dir_entry_2 * ext2_dotdot ( struct inode * dir , struct page * * p ) ;

ino_t ext2_inode_by_name ( struct inode * dir , struct qstr * child ) ;

void ext2_set_link ( struct inode * dir , struct ext2_dir_entry_2 * de , struct page * page , struct inode * inode , int update_times ) ;

int ext2_add_link ( struct dentry * dentry , struct inode * inode ) ;

int ext2_delete_entry ( struct ext2_dir_entry_2 * dir , struct page * page ) ;

int ext2_make_empty ( struct inode * inode , struct inode * parent ) ;

int ext2_empty_dir ( struct inode * inode ) ;

struct ext2_xattr_header { __le32 h_magic ; __le32 h_refcount ; __le32 h_blocks ; __le32 h_hash ; __u32 h_reserved [ 4 ] ; } ;

struct ext2_xattr_entry { __u8 e_name_len ; __u8 e_name_index ; __le16 e_value_offs ; __le32 e_value_block ; __le32 e_value_size ; __le32 e_hash ; char e_name [ 0 ] ; } ;

typedef struct { __le16 e_tag ; __le16 e_perm ; __le32 e_id ; } ext2_acl_entry ;

typedef struct { __le16 e_tag ; __le16 e_perm ; } ext2_acl_entry_short ;

typedef struct { __le32 a_version ; } ext2_acl_header ;

void ext2_free_inode ( struct inode * inode ) ;

struct inode * ext2_new_inode ( struct inode * dir , int mode ) ;

unsigned long ext2_count_free_inodes ( struct super_block * sb ) ;

unsigned long ext2_count_dirs ( struct super_block * sb ) ;

void ext2_delete_inode ( struct inode * inode ) ;

typedef struct { __le32 * p ; __le32 key ; struct buffer_head * bh ; } Indirect ;

int ext2_get_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh_result , int create ) ;

int ext2_fiemap ( struct inode * inode , struct fiemap_extent_info * fieinfo , u64 start , u64 len ) ;

int __ext2_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata ) ;

void ext2_truncate ( struct inode * inode ) ;

void ext2_set_inode_flags ( struct inode * inode ) ;

void ext2_get_inode_flags ( struct ext2_inode_info * ei ) ;

struct inode * ext2_iget ( struct super_block * sb , unsigned long ino ) ;

int ext2_write_inode ( struct inode * inode , int do_sync ) ;

int ext2_sync_inode ( struct inode * inode ) ;

int ext2_setattr ( struct dentry * dentry , struct iattr * iattr ) ;

long ext2_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

long ext2_compat_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) ;

struct dentry * ext2_get_parent ( struct dentry * child ) ;

void ext2_error ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void ext2_warning ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void ext2_update_dynamic_rev ( struct super_block * sb ) ;

enum { Opt_bsd_df , Opt_minix_df , Opt_grpid , Opt_nogrpid , Opt_resgid , Opt_resuid , Opt_sb , Opt_err_cont , Opt_err_panic , Opt_err_ro , Opt_nouid32 , Opt_nocheck , Opt_debug , Opt_oldalloc , Opt_orlov , Opt_nobh , Opt_user_xattr , Opt_nouser_xattr , Opt_acl , Opt_noacl , Opt_xip , Opt_ignore , Opt_err , Opt_quota , Opt_usrquota , Opt_grpquota , Opt_reservation , Opt_noreservation } ;
void ext2_write_super ( struct super_block * sb ) ;

struct mb_cache_entry { struct list_head e_lru_list ; struct mb_cache * e_cache ; unsigned short e_used ; unsigned short e_queued ; struct block_device * e_bdev ; sector_t e_block ; struct list_head e_block_list ; struct { struct list_head o_list ; unsigned int o_key ; } e_indexes [ 0 ] ; } ;

struct mb_cache_op { int ( * free ) ( struct mb_cache_entry * , gfp_t ) ; } ;

int ext2_xattr_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) ;

ssize_t ext2_listxattr ( struct dentry * dentry , char * buffer , size_t size ) ;

int ext2_xattr_set ( struct inode * inode , int name_index , const char * name , const void * value , size_t value_len , int flags ) ;

void ext2_xattr_delete_inode ( struct inode * inode ) ;

void ext2_xattr_put_super ( struct super_block * sb ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_ext2_xattr ( void ) ;

void exit_ext2_xattr ( void ) ;

int ext2_check_acl ( struct inode * inode , int mask ) ;

int ext2_init_acl ( struct inode * inode , struct inode * dir ) ;

int ext2_acl_chmod ( struct inode * inode ) ;

int ext2_init_security ( struct inode * inode , struct inode * dir ) ;

typedef unsigned int tid_t ;

typedef struct transaction_s transaction_t ;

struct journal_head { struct buffer_head * b_bh ; int b_jcount ; unsigned b_jlist ; unsigned b_modified ; char * b_frozen_data ; char * b_committed_data ; transaction_t * b_transaction ; transaction_t * b_next_transaction ; struct journal_head * b_tnext , * b_tprev ; transaction_t * b_cp_transaction ; struct journal_head * b_cpnext , * b_cpprev ; struct jbd2_buffer_trigger_type * b_triggers ; struct jbd2_buffer_trigger_type * b_frozen_triggers ; } ;

typedef struct handle_s handle_t ;

typedef struct journal_s journal_t ;


typedef struct journal_header_s { __be32 h_magic ; __be32 h_blocktype ; __be32 h_sequence ; } journal_header_t ;


typedef struct journal_block_tag_s { __be32 t_blocknr ; __be32 t_flags ; } journal_block_tag_t ;


typedef struct journal_revoke_header_s { journal_header_t r_header ; __be32 r_count ; } journal_revoke_header_t ;


typedef struct journal_superblock_s { journal_header_t s_header ; __be32 s_blocksize ; __be32 s_maxlen ; __be32 s_first ; __be32 s_sequence ; __be32 s_start ; __be32 s_errno ; __be32 s_feature_compat ; __be32 s_feature_incompat ; __be32 s_feature_ro_compat ; __u8 s_uuid [ 16 ] ; __be32 s_nr_users ; __be32 s_dynsuper ; __be32 s_max_transaction ; __be32 s_max_trans_data ; __u32 s_padding [ 44 ] ; __u8 s_users [ 16 * 48 ] ; } journal_superblock_t ;

enum jbd_state_bits { BH_JBD = BH_PrivateStart , BH_JWrite , BH_Freed , BH_Revoked , BH_RevokeValid , BH_JBDDirty , BH_State , BH_JournalHead , BH_Unshadow , } ;

struct jbd_revoke_table_s ;

struct handle_s { transaction_t * h_transaction ; int h_buffer_credits ; int h_ref ; int h_err ; unsigned int h_sync : 1 ; unsigned int h_jdata : 1 ; unsigned int h_aborted : 1 ; } ;

struct transaction_s { journal_t * t_journal ; tid_t t_tid ; enum { T_RUNNING , T_LOCKED , T_RUNDOWN , T_FLUSH , T_COMMIT , T_FINISHED } t_state ; unsigned int t_log_start ; int t_nr_buffers ; struct journal_head * t_reserved_list ; struct journal_head * t_locked_list ; struct journal_head * t_buffers ; struct journal_head * t_sync_datalist ; struct journal_head * t_forget ; struct journal_head * t_checkpoint_list ; struct journal_head * t_checkpoint_io_list ; struct journal_head * t_iobuf_list ; struct journal_head * t_shadow_list ; struct journal_head * t_log_list ; spinlock_t t_handle_lock ; int t_updates ; int t_outstanding_credits ; transaction_t * t_cpnext , * t_cpprev ; unsigned long t_expires ; ktime_t t_start_time ; int t_handle_count ; unsigned int t_synchronous_commit : 1 ; } ;

struct journal_s { unsigned long j_flags ; int j_errno ; struct buffer_head * j_sb_buffer ; journal_superblock_t * j_superblock ; int j_format_version ; spinlock_t j_state_lock ; int j_barrier_count ; struct mutex j_barrier ; transaction_t * j_running_transaction ; transaction_t * j_committing_transaction ; transaction_t * j_checkpoint_transactions ; wait_queue_head_t j_wait_transaction_locked ; wait_queue_head_t j_wait_logspace ; wait_queue_head_t j_wait_done_commit ; wait_queue_head_t j_wait_checkpoint ; wait_queue_head_t j_wait_commit ; wait_queue_head_t j_wait_updates ; struct mutex j_checkpoint_mutex ; unsigned int j_head ; unsigned int j_tail ; unsigned int j_free ; unsigned int j_first ; unsigned int j_last ; struct block_device * j_dev ; int j_blocksize ; unsigned int j_blk_offset ; struct block_device * j_fs_dev ; unsigned int j_maxlen ; spinlock_t j_list_lock ; struct inode * j_inode ; tid_t j_tail_sequence ; tid_t j_transaction_sequence ; tid_t j_commit_sequence ; tid_t j_commit_request ; __u8 j_uuid [ 16 ] ; struct task_struct * j_task ; int j_max_transaction_buffers ; unsigned long j_commit_interval ; struct timer_list j_commit_timer ; spinlock_t j_revoke_lock ; struct jbd_revoke_table_s * j_revoke ; struct jbd_revoke_table_s * j_revoke_table [ 2 ] ; struct buffer_head * * j_wbuf ; int j_wbufsize ; pid_t j_last_sync_writer ; u64 j_average_commit_time ; void * j_private ; } ;

struct ext3_group_desc { __le32 bg_block_bitmap ; __le32 bg_inode_bitmap ; __le32 bg_inode_table ; __le16 bg_free_blocks_count ; __le16 bg_free_inodes_count ; __le16 bg_used_dirs_count ; __u16 bg_pad ; __le32 bg_reserved [ 3 ] ; } ;

struct ext3_new_group_input { __u32 group ; __u32 block_bitmap ; __u32 inode_bitmap ; __u32 inode_table ; __u32 blocks_count ; __u16 reserved_blocks ; __u16 unused ; } ;

struct ext3_new_group_data { __u32 group ; __u32 block_bitmap ; __u32 inode_bitmap ; __u32 inode_table ; __u32 blocks_count ; __u16 reserved_blocks ; __u16 unused ; __u32 free_blocks_count ; } ;

struct ext3_mount_options { unsigned long s_mount_opt ; uid_t s_resuid ; gid_t s_resgid ; unsigned long s_commit_interval ; int s_jquota_fmt ; char * s_qf_names [ 2 ] ; } ;

struct ext3_inode { __le16 i_mode ; __le16 i_uid ; __le32 i_size ; __le32 i_atime ; __le32 i_ctime ; __le32 i_mtime ; __le32 i_dtime ; __le16 i_gid ; __le16 i_links_count ; __le32 i_blocks ; __le32 i_flags ; union { struct { __u32 l_i_reserved1 ; } linux1 ; struct { __u32 h_i_translator ; } hurd1 ; struct { __u32 m_i_reserved1 ; } masix1 ; } osd1 ; __le32 i_block [ ( ( ( 12 + 1 ) + 1 ) + 1 ) ] ; __le32 i_generation ; __le32 i_file_acl ; __le32 i_dir_acl ; __le32 i_faddr ; union { struct { __u8 l_i_frag ; __u8 l_i_fsize ; __u16 i_pad1 ; __le16 l_i_uid_high ; __le16 l_i_gid_high ; __u32 l_i_reserved2 ; } linux2 ; struct { __u8 h_i_frag ; __u8 h_i_fsize ; __u16 h_i_mode_high ; __u16 h_i_uid_high ; __u16 h_i_gid_high ; __u32 h_i_author ; } hurd2 ; struct { __u8 m_i_frag ; __u8 m_i_fsize ; __u16 m_pad1 ; __u32 m_i_reserved2 [ 2 ] ; } masix2 ; } osd2 ; __le16 i_extra_isize ; __le16 i_pad1 ; } ;

struct ext3_super_block { __le32 s_inodes_count ; __le32 s_blocks_count ; __le32 s_r_blocks_count ; __le32 s_free_blocks_count ; __le32 s_free_inodes_count ; __le32 s_first_data_block ; __le32 s_log_block_size ; __le32 s_log_frag_size ; __le32 s_blocks_per_group ; __le32 s_frags_per_group ; __le32 s_inodes_per_group ; __le32 s_mtime ; __le32 s_wtime ; __le16 s_mnt_count ; __le16 s_max_mnt_count ; __le16 s_magic ; __le16 s_state ; __le16 s_errors ; __le16 s_minor_rev_level ; __le32 s_lastcheck ; __le32 s_checkinterval ; __le32 s_creator_os ; __le32 s_rev_level ; __le16 s_def_resuid ; __le16 s_def_resgid ; __le32 s_first_ino ; __le16 s_inode_size ; __le16 s_block_group_nr ; __le32 s_feature_compat ; __le32 s_feature_incompat ; __le32 s_feature_ro_compat ; __u8 s_uuid [ 16 ] ; char s_volume_name [ 16 ] ; char s_last_mounted [ 64 ] ; __le32 s_algorithm_usage_bitmap ; __u8 s_prealloc_blocks ; __u8 s_prealloc_dir_blocks ; __le16 s_reserved_gdt_blocks ; __u8 s_journal_uuid [ 16 ] ; __le32 s_journal_inum ; __le32 s_journal_dev ; __le32 s_last_orphan ; __le32 s_hash_seed [ 4 ] ; __u8 s_def_hash_version ; __u8 s_reserved_char_pad ; __u16 s_reserved_word_pad ; __le32 s_default_mount_opts ; __le32 s_first_meta_bg ; __le32 s_mkfs_time ; __le32 s_jnl_blocks [ 17 ] ; __le32 s_blocks_count_hi ; __le32 s_r_blocks_count_hi ; __le32 s_free_blocks_count_hi ; __le16 s_min_extra_isize ; __le16 s_want_extra_isize ; __le32 s_flags ; __le16 s_raid_stride ; __le16 s_mmp_interval ; __le64 s_mmp_block ; __le32 s_raid_stripe_width ; __u8 s_log_groups_per_flex ; __u8 s_reserved_char_pad2 ; __le16 s_reserved_pad ; __u32 s_reserved [ 162 ] ; } ;

typedef int ext3_grpblk_t ;

typedef unsigned long ext3_fsblk_t ;

struct ext3_reserve_window { ext3_fsblk_t _rsv_start ; ext3_fsblk_t _rsv_end ; } ;

struct ext3_reserve_window_node { struct rb_node rsv_node ; __u32 rsv_goal_size ; __u32 rsv_alloc_hit ; struct ext3_reserve_window rsv_window ; } ;

struct ext3_block_alloc_info { struct ext3_reserve_window_node rsv_window_node ; __u32 last_alloc_logical_block ; ext3_fsblk_t last_alloc_physical_block ; } ;

struct ext3_inode_info { __le32 i_data [ 15 ] ; __u32 i_flags ; ext3_fsblk_t i_file_acl ; __u32 i_dir_acl ; __u32 i_dtime ; __u32 i_block_group ; __u32 i_state ; struct ext3_block_alloc_info * i_block_alloc_info ; __u32 i_dir_start_lookup ; struct rw_semaphore xattr_sem ; struct list_head i_orphan ; loff_t i_disksize ; __u16 i_extra_isize ; struct mutex truncate_mutex ; atomic_t i_sync_tid ; atomic_t i_datasync_tid ; struct inode vfs_inode ; } ;

struct ext3_sb_info { unsigned long s_frag_size ; unsigned long s_frags_per_block ; unsigned long s_inodes_per_block ; unsigned long s_frags_per_group ; unsigned long s_blocks_per_group ; unsigned long s_inodes_per_group ; unsigned long s_itb_per_group ; unsigned long s_gdb_count ; unsigned long s_desc_per_block ; unsigned long s_groups_count ; unsigned long s_overhead_last ; unsigned long s_blocks_last ; struct buffer_head * s_sbh ; struct ext3_super_block * s_es ; struct buffer_head * * s_group_desc ; unsigned long s_mount_opt ; ext3_fsblk_t s_sb_block ; uid_t s_resuid ; gid_t s_resgid ; unsigned short s_mount_state ; unsigned short s_pad ; int s_addr_per_block_bits ; int s_desc_per_block_bits ; int s_inode_size ; int s_first_ino ; spinlock_t s_next_gen_lock ; u32 s_next_generation ; u32 s_hash_seed [ 4 ] ; int s_def_hash_version ; int s_hash_unsigned ; struct percpu_counter s_freeblocks_counter ; struct percpu_counter s_freeinodes_counter ; struct percpu_counter s_dirs_counter ; struct blockgroup_lock * s_blockgroup_lock ; spinlock_t s_rsv_window_lock ; struct rb_root s_rsv_window_root ; struct ext3_reserve_window_node s_rsv_window_head ; struct inode * s_journal_inode ; struct journal_s * s_journal ; struct list_head s_orphan ; unsigned long s_commit_interval ; struct block_device * journal_bdev ; char * s_qf_names [ 2 ] ; int s_jquota_fmt ; } ;

struct ext3_dir_entry { __le32 inode ; __le16 rec_len ; __le16 name_len ; char name [ 255 ] ; } ;

struct ext3_dir_entry_2 { __le32 inode ; __le16 rec_len ; __u8 name_len ; __u8 file_type ; char name [ 255 ] ; } ;

struct dx_hash_info { u32 hash ; u32 minor_hash ; int hash_version ; u32 * seed ; } ;

struct ext3_iloc { struct buffer_head * bh ; unsigned long offset ; unsigned long block_group ; } ;

struct dir_private_info { struct rb_root root ; struct rb_node * curr_node ; struct fname * extra_fname ; loff_t last_pos ; __u32 curr_hash ; __u32 curr_minor_hash ; __u32 next_hash ; } ;

struct ext3_group_desc * ext3_get_group_desc ( struct super_block * sb , unsigned int block_group , struct buffer_head * * bh ) ;

void ext3_rsv_window_add ( struct super_block * sb , struct ext3_reserve_window_node * rsv ) ;

void ext3_init_block_alloc_info ( struct inode * inode ) ;

void ext3_discard_reservation ( struct inode * inode ) ;

void ext3_free_blocks_sb ( handle_t * handle , struct super_block * sb , ext3_fsblk_t block , unsigned long count , unsigned long * pdquot_freed_blocks ) ;

void ext3_free_blocks ( handle_t * handle , struct inode * inode , ext3_fsblk_t block , unsigned long count ) ;

int ext3_should_retry_alloc ( struct super_block * sb , int * retries ) ;

ext3_fsblk_t ext3_new_blocks ( handle_t * handle , struct inode * inode , ext3_fsblk_t goal , unsigned long * count , int * errp ) ;

ext3_fsblk_t ext3_new_block ( handle_t * handle , struct inode * inode , ext3_fsblk_t goal , int * errp ) ;

ext3_fsblk_t ext3_count_free_blocks ( struct super_block * sb ) ;

int ext3_bg_has_super ( struct super_block * sb , int group ) ;

unsigned long ext3_bg_num_gdb ( struct super_block * sb , int group ) ;

int ext3_check_dir_entry ( const char * function , struct inode * dir , struct ext3_dir_entry_2 * de , struct buffer_head * bh , unsigned long offset ) ;

struct fname { __u32 hash ; __u32 minor_hash ; struct rb_node rb_hash ; struct fname * next ; __u32 inode ; __u8 name_len ; __u8 file_type ; char name [ 0 ] ; } ;

void ext3_htree_free_dir_info ( struct dir_private_info * p ) ;

int ext3_htree_store_dirent ( struct file * dir_file , __u32 hash , __u32 minor_hash , struct ext3_dir_entry_2 * dirent ) ;

struct ext3_xattr_header { __le32 h_magic ; __le32 h_refcount ; __le32 h_blocks ; __le32 h_hash ; __u32 h_reserved [ 4 ] ; } ;

struct ext3_xattr_ibody_header { __le32 h_magic ; } ;

struct ext3_xattr_entry { __u8 e_name_len ; __u8 e_name_index ; __le16 e_value_offs ; __le32 e_value_block ; __le32 e_value_size ; __le32 e_hash ; char e_name [ 0 ] ; } ;

typedef struct { __le16 e_tag ; __le16 e_perm ; __le32 e_id ; } ext3_acl_entry ;

typedef struct { __le16 e_tag ; __le16 e_perm ; } ext3_acl_entry_short ;

typedef struct { __le32 a_version ; } ext3_acl_header ;

int ext3_sync_file ( struct file * file , struct dentry * dentry , int datasync ) ;

void ext3_free_inode ( handle_t * handle , struct inode * inode ) ;

struct inode * ext3_new_inode ( handle_t * handle , struct inode * dir , int mode ) ;

struct inode * ext3_orphan_get ( struct super_block * sb , unsigned long ino ) ;

unsigned long ext3_count_free_inodes ( struct super_block * sb ) ;

unsigned long ext3_count_dirs ( struct super_block * sb ) ;

int ext3_forget ( handle_t * handle , int is_metadata , struct inode * inode , struct buffer_head * bh , ext3_fsblk_t blocknr ) ;

void ext3_delete_inode ( struct inode * inode ) ;

int ext3_get_blocks_handle ( handle_t * handle , struct inode * inode , sector_t iblock , unsigned long maxblocks , struct buffer_head * bh_result , int create ) ;

int ext3_fiemap ( struct inode * inode , struct fiemap_extent_info * fieinfo , u64 start , u64 len ) ;

struct buffer_head * ext3_getblk ( handle_t * handle , struct inode * inode , long block , int create , int * errp ) ;

struct buffer_head * ext3_bread ( handle_t * handle , struct inode * inode , int block , int create , int * err ) ;

int ext3_journal_dirty_data ( handle_t * handle , struct buffer_head * bh ) ;

void ext3_set_aops ( struct inode * inode ) ;

int ext3_can_truncate ( struct inode * inode ) ;

void ext3_truncate ( struct inode * inode ) ;

int ext3_get_inode_loc ( struct inode * inode , struct ext3_iloc * iloc ) ;

void ext3_set_inode_flags ( struct inode * inode ) ;

void ext3_get_inode_flags ( struct ext3_inode_info * ei ) ;

struct inode * ext3_iget ( struct super_block * sb , unsigned long ino ) ;

int ext3_write_inode ( struct inode * inode , int wait ) ;

int ext3_setattr ( struct dentry * dentry , struct iattr * attr ) ;

int ext3_mark_iloc_dirty ( handle_t * handle , struct inode * inode , struct ext3_iloc * iloc ) ;

int ext3_reserve_inode_write ( handle_t * handle , struct inode * inode , struct ext3_iloc * iloc ) ;

int ext3_mark_inode_dirty ( handle_t * handle , struct inode * inode ) ;

void ext3_dirty_inode ( struct inode * inode ) ;

int ext3_change_inode_journal_flag ( struct inode * inode , int val ) ;

long ext3_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

long ext3_compat_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) ;

struct fake_dirent { __le32 inode ; __le16 rec_len ; u8 name_len ; u8 file_type ; } ;

struct dx_countlimit { __le16 limit ; __le16 count ; } ;

struct dx_entry { __le32 hash ; __le32 block ; } ;

struct dx_root { struct fake_dirent dot ; char dot_name [ 4 ] ; struct fake_dirent dotdot ; char dotdot_name [ 4 ] ; struct dx_root_info { __le32 reserved_zero ; u8 hash_version ; u8 info_length ; u8 indirect_levels ; u8 unused_flags ; } info ; struct dx_entry entries [ 0 ] ; } ;

struct dx_node { struct fake_dirent fake ; struct dx_entry entries [ 0 ] ; } ;

struct dx_frame { struct buffer_head * bh ; struct dx_entry * entries ; struct dx_entry * at ; } ;

struct dx_map_entry { u32 hash ; u16 offs ; u16 size ; } ;

int ext3_htree_fill_tree ( struct file * dir_file , __u32 start_hash , __u32 start_minor_hash , __u32 * next_hash ) ;

struct dentry * ext3_get_parent ( struct dentry * child ) ;

int ext3_orphan_add ( handle_t * handle , struct inode * inode ) ;

int ext3_orphan_del ( handle_t * handle , struct inode * inode ) ;

handle_t * ext3_journal_start_sb ( struct super_block * sb , int nblocks ) ;

int __ext3_journal_stop ( const char * where , handle_t * handle ) ;

void ext3_journal_abort_handle ( const char * caller , const char * err_fn , struct buffer_head * bh , handle_t * handle , int err ) ;

void ext3_error ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void __ext3_std_error ( struct super_block * sb , const char * function , int errno ) ;

void ext3_abort ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void ext3_warning ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void ext3_update_dynamic_rev ( struct super_block * sb ) ;

enum { Opt_bsd_df , Opt_minix_df , Opt_grpid , Opt_nogrpid , Opt_resgid , Opt_resuid , Opt_sb , Opt_err_cont , Opt_err_panic , Opt_err_ro , Opt_nouid32 , Opt_nocheck , Opt_debug , Opt_oldalloc , Opt_orlov , Opt_user_xattr , Opt_nouser_xattr , Opt_acl , Opt_noacl , Opt_reservation , Opt_noreservation , Opt_noload , Opt_nobh , Opt_bh , Opt_commit , Opt_journal_update , Opt_journal_inum , Opt_journal_dev , Opt_abort , Opt_data_journal , Opt_data_ordered , Opt_data_writeback , Opt_data_err_abort , Opt_data_err_ignore , Opt_usrjquota , Opt_grpjquota , Opt_offusrjquota , Opt_offgrpjquota , Opt_jqfmt_vfsold , Opt_jqfmt_vfsv0 , Opt_quota , Opt_noquota , Opt_ignore , Opt_barrier , Opt_err , Opt_resize , Opt_usrquota , Opt_grpquota } ;
int ext3_force_commit ( struct super_block * sb ) ;

int ext3fs_dirhash ( const char * name , int len , struct dx_hash_info * hinfo ) ;

int ext3_group_add ( struct super_block * sb , struct ext3_new_group_data * input ) ;

int ext3_group_extend ( struct super_block * sb , struct ext3_super_block * es , ext3_fsblk_t n_blocks_count ) ;

int __ext3_journal_get_undo_access ( const char * where , handle_t * handle , struct buffer_head * bh ) ;

int __ext3_journal_get_write_access ( const char * where , handle_t * handle , struct buffer_head * bh ) ;

int __ext3_journal_forget ( const char * where , handle_t * handle , struct buffer_head * bh ) ;

int __ext3_journal_revoke ( const char * where , handle_t * handle , unsigned long blocknr , struct buffer_head * bh ) ;

int __ext3_journal_get_create_access ( const char * where , handle_t * handle , struct buffer_head * bh ) ;

int __ext3_journal_dirty_metadata ( const char * where , handle_t * handle , struct buffer_head * bh ) ;

ssize_t ext3_listxattr ( struct dentry * dentry , char * buffer , size_t size ) ;

int ext3_xattr_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) ;

struct ext3_xattr_info { int name_index ; const char * name ; const void * value ; size_t value_len ; } ;

struct ext3_xattr_search { struct ext3_xattr_entry * first ; void * base ; void * end ; struct ext3_xattr_entry * here ; int not_found ; } ;

struct ext3_xattr_block_find { struct ext3_xattr_search s ; struct buffer_head * bh ; } ;

struct ext3_xattr_ibody_find { struct ext3_xattr_search s ; struct ext3_iloc iloc ; } ;

int ext3_xattr_set_handle ( handle_t * handle , struct inode * inode , int name_index , const char * name , const void * value , size_t value_len , int flags ) ;

int ext3_xattr_set ( struct inode * inode , int name_index , const char * name , const void * value , size_t value_len , int flags ) ;

void ext3_xattr_delete_inode ( handle_t * handle , struct inode * inode ) ;

void ext3_xattr_put_super ( struct super_block * sb ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_ext3_xattr ( void ) ;

void exit_ext3_xattr ( void ) ;

int ext3_check_acl ( struct inode * inode , int mask ) ;

int ext3_init_acl ( handle_t * handle , struct inode * inode , struct inode * dir ) ;

int ext3_acl_chmod ( struct inode * inode ) ;

int ext3_init_security ( handle_t * handle , struct inode * inode , struct inode * dir ) ;

struct commit_header { __be32 h_magic ; __be32 h_blocktype ; __be32 h_sequence ; unsigned char h_chksum_type ; unsigned char h_chksum_size ; unsigned char h_padding [ 2 ] ; __be32 h_chksum [ ( 32 / sizeof ( u32 ) ) ] ; __be64 h_commit_sec ; __be32 h_commit_nsec ; } ;

typedef struct journal_block_tag_s { __be32 t_blocknr ; __be32 t_flags ; __be32 t_blocknr_high ; } journal_block_tag_t ;

typedef struct jbd2_journal_revoke_header_s { journal_header_t r_header ; __be32 r_count ; } jbd2_journal_revoke_header_t ;

enum jbd_state_bits { BH_JBD = BH_PrivateStart , BH_JWrite , BH_Freed , BH_Revoked , BH_RevokeValid , BH_JBDDirty , BH_State , BH_JournalHead , BH_Unshadow , BH_JBDPrivateStart , } ;
struct jbd2_inode { transaction_t * i_transaction ; transaction_t * i_next_transaction ; struct list_head i_list ; struct inode * i_vfs_inode ; unsigned int i_flags ; } ;

struct jbd2_revoke_table_s ;

struct transaction_chp_stats_s { unsigned long cs_chp_time ; __u32 cs_forced_to_close ; __u32 cs_written ; __u32 cs_dropped ; } ;

struct transaction_s { journal_t * t_journal ; tid_t t_tid ; enum { T_RUNNING , T_LOCKED , T_RUNDOWN , T_FLUSH , T_COMMIT , T_FINISHED } t_state ; unsigned long t_log_start ; int t_nr_buffers ; struct journal_head * t_reserved_list ; struct journal_head * t_buffers ; struct journal_head * t_forget ; struct journal_head * t_checkpoint_list ; struct journal_head * t_checkpoint_io_list ; struct journal_head * t_iobuf_list ; struct journal_head * t_shadow_list ; struct journal_head * t_log_list ; struct list_head t_inode_list ; spinlock_t t_handle_lock ; unsigned long t_max_wait ; unsigned long t_start ; struct transaction_chp_stats_s t_chp_stats ; int t_updates ; int t_outstanding_credits ; transaction_t * t_cpnext , * t_cpprev ; unsigned long t_expires ; ktime_t t_start_time ; int t_handle_count ; unsigned int t_synchronous_commit : 1 ; unsigned int t_flushed_data_blocks : 1 ; struct list_head t_private_list ; } ;
struct transaction_run_stats_s { unsigned long rs_wait ; unsigned long rs_running ; unsigned long rs_locked ; unsigned long rs_flushing ; unsigned long rs_logging ; __u32 rs_handle_count ; __u32 rs_blocks ; __u32 rs_blocks_logged ; } ;

struct transaction_stats_s { unsigned long ts_tid ; struct transaction_run_stats_s run ; } ;

struct journal_s { unsigned long j_flags ; int j_errno ; struct buffer_head * j_sb_buffer ; journal_superblock_t * j_superblock ; int j_format_version ; spinlock_t j_state_lock ; int j_barrier_count ; struct mutex j_barrier ; transaction_t * j_running_transaction ; transaction_t * j_committing_transaction ; transaction_t * j_checkpoint_transactions ; wait_queue_head_t j_wait_transaction_locked ; wait_queue_head_t j_wait_logspace ; wait_queue_head_t j_wait_done_commit ; wait_queue_head_t j_wait_checkpoint ; wait_queue_head_t j_wait_commit ; wait_queue_head_t j_wait_updates ; struct mutex j_checkpoint_mutex ; struct buffer_head * j_chkpt_bhs [ 64 ] ; unsigned long j_head ; unsigned long j_tail ; unsigned long j_free ; unsigned long j_first ; unsigned long j_last ; struct block_device * j_dev ; int j_blocksize ; unsigned long long j_blk_offset ; char j_devname [ 32 + 24 ] ; struct block_device * j_fs_dev ; unsigned int j_maxlen ; spinlock_t j_list_lock ; struct inode * j_inode ; tid_t j_tail_sequence ; tid_t j_transaction_sequence ; tid_t j_commit_sequence ; tid_t j_commit_request ; __u8 j_uuid [ 16 ] ; struct task_struct * j_task ; int j_max_transaction_buffers ; unsigned long j_commit_interval ; struct timer_list j_commit_timer ; spinlock_t j_revoke_lock ; struct jbd2_revoke_table_s * j_revoke ; struct jbd2_revoke_table_s * j_revoke_table [ 2 ] ; struct buffer_head * * j_wbuf ; int j_wbufsize ; pid_t j_last_sync_writer ; u64 j_average_commit_time ; u32 j_min_batch_time ; u32 j_max_batch_time ; void ( * j_commit_callback ) ( journal_t * , transaction_t * ) ; spinlock_t j_history_lock ; struct proc_dir_entry * j_proc_entry ; struct transaction_stats_s j_stats ; unsigned int j_failed_commit ; void * j_private ; } ;
struct jbd2_buffer_trigger_type { void ( * t_commit ) ( struct jbd2_buffer_trigger_type * type , struct buffer_head * bh , void * mapped_data , size_t size ) ; void ( * t_abort ) ( struct jbd2_buffer_trigger_type * type , struct buffer_head * bh ) ; } ;

typedef int ext4_grpblk_t ;

typedef unsigned long long ext4_fsblk_t ;

typedef __u32 ext4_lblk_t ;

typedef unsigned int ext4_group_t ;

struct ext4_allocation_request { struct inode * inode ; unsigned int len ; ext4_lblk_t logical ; ext4_lblk_t lleft ; ext4_lblk_t lright ; ext4_fsblk_t goal ; ext4_fsblk_t pleft ; ext4_fsblk_t pright ; unsigned int flags ; } ;

struct mpage_da_data { struct inode * inode ; sector_t b_blocknr ; size_t b_size ; unsigned long b_state ; unsigned long first_page , next_page ; struct writeback_control * wbc ; int io_done ; int pages_written ; int retval ; } ;


typedef struct ext4_io_end { struct list_head list ; struct inode * inode ; unsigned int flag ; int error ; loff_t offset ; ssize_t size ; struct work_struct work ; } ext4_io_end_t ;

struct ext4_group_desc { __le32 bg_block_bitmap_lo ; __le32 bg_inode_bitmap_lo ; __le32 bg_inode_table_lo ; __le16 bg_free_blocks_count_lo ; __le16 bg_free_inodes_count_lo ; __le16 bg_used_dirs_count_lo ; __le16 bg_flags ; __u32 bg_reserved [ 2 ] ; __le16 bg_itable_unused_lo ; __le16 bg_checksum ; __le32 bg_block_bitmap_hi ; __le32 bg_inode_bitmap_hi ; __le32 bg_inode_table_hi ; __le16 bg_free_blocks_count_hi ; __le16 bg_free_inodes_count_hi ; __le16 bg_used_dirs_count_hi ; __le16 bg_itable_unused_hi ; __u32 bg_reserved2 [ 3 ] ; } ;

struct flex_groups { atomic_t free_inodes ; atomic_t free_blocks ; atomic_t used_dirs ; } ;

enum { EXT4_INODE_SECRM = 0 , EXT4_INODE_UNRM = 1 , EXT4_INODE_COMPR = 2 , EXT4_INODE_SYNC = 3 , EXT4_INODE_IMMUTABLE = 4 , EXT4_INODE_APPEND = 5 , EXT4_INODE_NODUMP = 6 , EXT4_INODE_NOATIME = 7 , EXT4_INODE_DIRTY = 8 , EXT4_INODE_COMPRBLK = 9 , EXT4_INODE_NOCOMPR = 10 , EXT4_INODE_ECOMPR = 11 , EXT4_INODE_INDEX = 12 , EXT4_INODE_IMAGIC = 13 , EXT4_INODE_JOURNAL_DATA = 14 , EXT4_INODE_NOTAIL = 15 , EXT4_INODE_DIRSYNC = 16 , EXT4_INODE_TOPDIR = 17 , EXT4_INODE_HUGE_FILE = 18 , EXT4_INODE_EXTENTS = 19 , EXT4_INODE_EA_INODE = 21 , EXT4_INODE_EOFBLOCKS = 22 , EXT4_INODE_RESERVED = 31 , } ;
struct ext4_new_group_input { __u32 group ; __u64 block_bitmap ; __u64 inode_bitmap ; __u64 inode_table ; __u32 blocks_count ; __u16 reserved_blocks ; __u16 unused ; } ;

struct compat_ext4_new_group_input { u32 group ; compat_u64 block_bitmap ; compat_u64 inode_bitmap ; compat_u64 inode_table ; u32 blocks_count ; u16 reserved_blocks ; u16 unused ; } ;

struct ext4_new_group_data { __u32 group ; __u64 block_bitmap ; __u64 inode_bitmap ; __u64 inode_table ; __u32 blocks_count ; __u16 reserved_blocks ; __u16 unused ; __u32 free_blocks_count ; } ;

struct ext4_mount_options { unsigned long s_mount_opt ; uid_t s_resuid ; gid_t s_resgid ; unsigned long s_commit_interval ; u32 s_min_batch_time , s_max_batch_time ; int s_jquota_fmt ; char * s_qf_names [ 2 ] ; } ;

struct ext4_inode { __le16 i_mode ; __le16 i_uid ; __le32 i_size_lo ; __le32 i_atime ; __le32 i_ctime ; __le32 i_mtime ; __le32 i_dtime ; __le16 i_gid ; __le16 i_links_count ; __le32 i_blocks_lo ; __le32 i_flags ; union { struct { __le32 l_i_version ; } linux1 ; struct { __u32 h_i_translator ; } hurd1 ; struct { __u32 m_i_reserved1 ; } masix1 ; } osd1 ; __le32 i_block [ ( ( ( 12 + 1 ) + 1 ) + 1 ) ] ; __le32 i_generation ; __le32 i_file_acl_lo ; __le32 i_size_high ; __le32 i_obso_faddr ; union { struct { __le16 l_i_blocks_high ; __le16 l_i_file_acl_high ; __le16 l_i_uid_high ; __le16 l_i_gid_high ; __u32 l_i_reserved2 ; } linux2 ; struct { __le16 h_i_reserved1 ; __u16 h_i_mode_high ; __u16 h_i_uid_high ; __u16 h_i_gid_high ; __u32 h_i_author ; } hurd2 ; struct { __le16 h_i_reserved1 ; __le16 m_i_file_acl_high ; __u32 m_i_reserved2 [ 2 ] ; } masix2 ; } osd2 ; __le16 i_extra_isize ; __le16 i_pad1 ; __le32 i_ctime_extra ; __le32 i_mtime_extra ; __le32 i_atime_extra ; __le32 i_crtime ; __le32 i_crtime_extra ; __le32 i_version_hi ; } ;

struct move_extent { __u32 reserved ; __u32 donor_fd ; __u64 orig_start ; __u64 donor_start ; __u64 len ; __u64 moved_len ; } ;

struct ext4_ext_cache { ext4_fsblk_t ec_start ; ext4_lblk_t ec_block ; __u32 ec_len ; __u32 ec_type ; } ;

struct ext4_inode_info { __le32 i_data [ 15 ] ; __u32 i_dtime ; ext4_fsblk_t i_file_acl ; ext4_group_t i_block_group ; unsigned long i_state_flags ; unsigned long i_flags ; ext4_lblk_t i_dir_start_lookup ; struct rw_semaphore xattr_sem ; struct list_head i_orphan ; loff_t i_disksize ; struct rw_semaphore i_data_sem ; struct inode vfs_inode ; struct jbd2_inode jinode ; struct ext4_ext_cache i_cached_extent ; struct timespec i_crtime ; struct list_head i_prealloc_list ; spinlock_t i_prealloc_lock ; ext4_group_t i_last_alloc_group ; unsigned int i_reserved_data_blocks ; unsigned int i_reserved_meta_blocks ; unsigned int i_allocated_meta_blocks ; unsigned short i_delalloc_reserved_flag ; sector_t i_da_metadata_calc_last_lblock ; int i_da_metadata_calc_len ; __u16 i_extra_isize ; spinlock_t i_block_reservation_lock ; qsize_t i_reserved_quota ; struct list_head i_aio_dio_complete_list ; ext4_io_end_t * cur_aio_dio ; tid_t i_sync_tid ; tid_t i_datasync_tid ; } ;

struct ext4_super_block { __le32 s_inodes_count ; __le32 s_blocks_count_lo ; __le32 s_r_blocks_count_lo ; __le32 s_free_blocks_count_lo ; __le32 s_free_inodes_count ; __le32 s_first_data_block ; __le32 s_log_block_size ; __le32 s_obso_log_frag_size ; __le32 s_blocks_per_group ; __le32 s_obso_frags_per_group ; __le32 s_inodes_per_group ; __le32 s_mtime ; __le32 s_wtime ; __le16 s_mnt_count ; __le16 s_max_mnt_count ; __le16 s_magic ; __le16 s_state ; __le16 s_errors ; __le16 s_minor_rev_level ; __le32 s_lastcheck ; __le32 s_checkinterval ; __le32 s_creator_os ; __le32 s_rev_level ; __le16 s_def_resuid ; __le16 s_def_resgid ; __le32 s_first_ino ; __le16 s_inode_size ; __le16 s_block_group_nr ; __le32 s_feature_compat ; __le32 s_feature_incompat ; __le32 s_feature_ro_compat ; __u8 s_uuid [ 16 ] ; char s_volume_name [ 16 ] ; char s_last_mounted [ 64 ] ; __le32 s_algorithm_usage_bitmap ; __u8 s_prealloc_blocks ; __u8 s_prealloc_dir_blocks ; __le16 s_reserved_gdt_blocks ; __u8 s_journal_uuid [ 16 ] ; __le32 s_journal_inum ; __le32 s_journal_dev ; __le32 s_last_orphan ; __le32 s_hash_seed [ 4 ] ; __u8 s_def_hash_version ; __u8 s_reserved_char_pad ; __le16 s_desc_size ; __le32 s_default_mount_opts ; __le32 s_first_meta_bg ; __le32 s_mkfs_time ; __le32 s_jnl_blocks [ 17 ] ; __le32 s_blocks_count_hi ; __le32 s_r_blocks_count_hi ; __le32 s_free_blocks_count_hi ; __le16 s_min_extra_isize ; __le16 s_want_extra_isize ; __le32 s_flags ; __le16 s_raid_stride ; __le16 s_mmp_interval ; __le64 s_mmp_block ; __le32 s_raid_stripe_width ; __u8 s_log_groups_per_flex ; __u8 s_reserved_char_pad2 ; __le16 s_reserved_pad ; __le64 s_kbytes_written ; __u32 s_reserved [ 160 ] ; } ;

struct ext4_sb_info { unsigned long s_desc_size ; unsigned long s_inodes_per_block ; unsigned long s_blocks_per_group ; unsigned long s_inodes_per_group ; unsigned long s_itb_per_group ; unsigned long s_gdb_count ; unsigned long s_desc_per_block ; ext4_group_t s_groups_count ; ext4_group_t s_blockfile_groups ; unsigned long s_overhead_last ; unsigned long s_blocks_last ; loff_t s_bitmap_maxbytes ; struct buffer_head * s_sbh ; struct ext4_super_block * s_es ; struct buffer_head * * s_group_desc ; unsigned int s_mount_opt ; unsigned int s_mount_flags ; ext4_fsblk_t s_sb_block ; uid_t s_resuid ; gid_t s_resgid ; unsigned short s_mount_state ; unsigned short s_pad ; int s_addr_per_block_bits ; int s_desc_per_block_bits ; int s_inode_size ; int s_first_ino ; unsigned int s_inode_readahead_blks ; unsigned int s_inode_goal ; spinlock_t s_next_gen_lock ; u32 s_next_generation ; u32 s_hash_seed [ 4 ] ; int s_def_hash_version ; int s_hash_unsigned ; struct percpu_counter s_freeblocks_counter ; struct percpu_counter s_freeinodes_counter ; struct percpu_counter s_dirs_counter ; struct percpu_counter s_dirtyblocks_counter ; struct blockgroup_lock * s_blockgroup_lock ; struct proc_dir_entry * s_proc ; struct kobject s_kobj ; struct completion s_kobj_unregister ; struct inode * s_journal_inode ; struct journal_s * s_journal ; struct list_head s_orphan ; struct mutex s_orphan_lock ; struct mutex s_resize_lock ; unsigned long s_commit_interval ; u32 s_max_batch_time ; u32 s_min_batch_time ; struct block_device * journal_bdev ; char * s_qf_names [ 2 ] ; int s_jquota_fmt ; unsigned int s_want_extra_isize ; struct rb_root system_blks ; struct ext4_group_info * * * s_group_info ; struct inode * s_buddy_cache ; long s_blocks_reserved ; spinlock_t s_reserve_lock ; spinlock_t s_md_lock ; tid_t s_last_transaction ; unsigned short * s_mb_offsets ; unsigned int * s_mb_maxs ; unsigned long s_stripe ; unsigned int s_mb_stream_request ; unsigned int s_mb_max_to_scan ; unsigned int s_mb_min_to_scan ; unsigned int s_mb_stats ; unsigned int s_mb_order2_reqs ; unsigned int s_mb_group_prealloc ; unsigned int s_max_writeback_mb_bump ; unsigned long s_mb_last_group ; unsigned long s_mb_last_start ; spinlock_t s_mb_pa_lock ; atomic_t s_bal_reqs ; atomic_t s_bal_success ; atomic_t s_bal_allocated ; atomic_t s_bal_ex_scanned ; atomic_t s_bal_goals ; atomic_t s_bal_breaks ; atomic_t s_bal_2orders ; spinlock_t s_bal_lock ; unsigned long s_mb_buddies_generated ; unsigned long long s_mb_generation_time ; atomic_t s_mb_lost_chunks ; atomic_t s_mb_preallocated ; atomic_t s_mb_discarded ; atomic_t s_lock_busy ; struct ext4_locality_group * s_locality_groups ; unsigned long s_sectors_written_start ; u64 s_kbytes_written ; unsigned int s_log_groups_per_flex ; struct flex_groups * s_flex_groups ; struct workqueue_struct * dio_unwritten_wq ; } ;

enum { EXT4_STATE_JDATA , EXT4_STATE_NEW , EXT4_STATE_XATTR , EXT4_STATE_NO_EXPAND , EXT4_STATE_DA_ALLOC_CLOSE , EXT4_STATE_EXT_MIGRATE , EXT4_STATE_DIO_UNWRITTEN , EXT4_STATE_NEWENTRY , } ;
struct ext4_dir_entry { __le32 inode ; __le16 rec_len ; __le16 name_len ; char name [ 255 ] ; } ;

struct ext4_dir_entry_2 { __le32 inode ; __le16 rec_len ; __u8 name_len ; __u8 file_type ; char name [ 255 ] ; } ;

struct ext4_iloc { struct buffer_head * bh ; unsigned long offset ; ext4_group_t block_group ; } ;

struct ext4_group_info { unsigned long bb_state ; struct rb_root bb_free_root ; ext4_grpblk_t bb_first_free ; ext4_grpblk_t bb_free ; ext4_grpblk_t bb_fragments ; ext4_grpblk_t bb_largest_free_order ; struct list_head bb_prealloc_list ; struct rw_semaphore alloc_sem ; ext4_grpblk_t bb_counters [ ] ; } ;

struct ext4_free_data { struct rb_node node ; struct list_head list ; ext4_group_t group ; ext4_grpblk_t start_blk ; ext4_grpblk_t count ; tid_t t_tid ; } ;

struct ext4_prealloc_space { struct list_head pa_inode_list ; struct list_head pa_group_list ; union { struct list_head pa_tmp_list ; struct rcu_head pa_rcu ; } u ; spinlock_t pa_lock ; atomic_t pa_count ; unsigned pa_deleted ; ext4_fsblk_t pa_pstart ; ext4_lblk_t pa_lstart ; ext4_grpblk_t pa_len ; ext4_grpblk_t pa_free ; unsigned short pa_type ; spinlock_t * pa_obj_lock ; struct inode * pa_inode ; } ;

enum { MB_INODE_PA = 0 , MB_GROUP_PA = 1 } ;
struct ext4_free_extent { ext4_lblk_t fe_logical ; ext4_grpblk_t fe_start ; ext4_group_t fe_group ; ext4_grpblk_t fe_len ; } ;

struct ext4_locality_group { struct mutex lg_mutex ; struct list_head lg_prealloc_list [ 10 ] ; spinlock_t lg_prealloc_lock ; } ;

struct ext4_allocation_context { struct inode * ac_inode ; struct super_block * ac_sb ; struct ext4_free_extent ac_o_ex ; struct ext4_free_extent ac_g_ex ; struct ext4_free_extent ac_b_ex ; struct ext4_free_extent ac_f_ex ; unsigned long ac_ex_scanned ; __u16 ac_groups_scanned ; __u16 ac_found ; __u16 ac_tail ; __u16 ac_buddy ; __u16 ac_flags ; __u8 ac_status ; __u8 ac_criteria ; __u8 ac_repeats ; __u8 ac_2order ; __u8 ac_op ; struct page * ac_bitmap_page ; struct page * ac_buddy_page ; struct rw_semaphore * alloc_semp ; struct ext4_prealloc_space * ac_pa ; struct ext4_locality_group * ac_lg ; } ;

struct ext4_buddy { struct page * bd_buddy_page ; void * bd_buddy ; struct page * bd_bitmap_page ; void * bd_bitmap ; struct ext4_group_info * bd_info ; struct super_block * bd_sb ; __u16 bd_blkbits ; ext4_group_t bd_group ; struct rw_semaphore * alloc_semp ; } ;

void ext4_get_group_no_and_offset ( struct super_block * sb , ext4_fsblk_t blocknr , ext4_group_t * blockgrpp , ext4_grpblk_t * offsetp ) ;

unsigned ext4_init_block_bitmap ( struct super_block * sb , struct buffer_head * bh , ext4_group_t block_group , struct ext4_group_desc * gdp ) ;

struct ext4_group_desc * ext4_get_group_desc ( struct super_block * sb , ext4_group_t block_group , struct buffer_head * * bh ) ;

struct buffer_head * ext4_read_block_bitmap ( struct super_block * sb , ext4_group_t block_group ) ;

void ext4_add_groupblocks ( handle_t * handle , struct super_block * sb , ext4_fsblk_t block , unsigned long count ) ;

void ext4_free_blocks ( handle_t * handle , struct inode * inode , ext4_fsblk_t block , unsigned long count , int metadata ) ;

int ext4_has_free_blocks ( struct ext4_sb_info * sbi , s64 nblocks ) ;

int ext4_claim_free_blocks ( struct ext4_sb_info * sbi , s64 nblocks ) ;

int ext4_should_retry_alloc ( struct super_block * sb , int * retries ) ;

ext4_fsblk_t ext4_new_meta_blocks ( handle_t * handle , struct inode * inode , ext4_fsblk_t goal , unsigned long * count , int * errp ) ;

ext4_fsblk_t ext4_count_free_blocks ( struct super_block * sb ) ;

int ext4_bg_has_super ( struct super_block * sb , ext4_group_t group ) ;

unsigned long ext4_bg_num_gdb ( struct super_block * sb , ext4_group_t group ) ;

int ext4_check_dir_entry ( const char * function , struct inode * dir , struct ext4_dir_entry_2 * de , struct buffer_head * bh , unsigned int offset ) ;

void ext4_htree_free_dir_info ( struct dir_private_info * p ) ;

int ext4_htree_store_dirent ( struct file * dir_file , __u32 hash , __u32 minor_hash , struct ext4_dir_entry_2 * dirent ) ;

struct ext4_xattr_header { __le32 h_magic ; __le32 h_refcount ; __le32 h_blocks ; __le32 h_hash ; __u32 h_reserved [ 4 ] ; } ;

struct ext4_xattr_ibody_header { __le32 h_magic ; } ;

struct ext4_xattr_entry { __u8 e_name_len ; __u8 e_name_index ; __le16 e_value_offs ; __le32 e_value_block ; __le32 e_value_size ; __le32 e_hash ; char e_name [ 0 ] ; } ;

typedef struct { __le16 e_tag ; __le16 e_perm ; __le32 e_id ; } ext4_acl_entry ;

typedef struct { __le16 e_tag ; __le16 e_perm ; } ext4_acl_entry_short ;

typedef struct { __le32 a_version ; } ext4_acl_header ;

struct ext4_allocation_context ;
struct ext4_allocation_request ;
struct ext4_prealloc_space ;
struct ext4_inode_info ;
struct mpage_da_data ;
int ext4_sync_file ( struct file * file , struct dentry * dentry , int datasync ) ;

void mark_bitmap_end ( int start_bit , int end_bit , char * bitmap ) ;

unsigned ext4_init_inode_bitmap ( struct super_block * sb , struct buffer_head * bh , ext4_group_t block_group , struct ext4_group_desc * gdp ) ;

void ext4_free_inode ( handle_t * handle , struct inode * inode ) ;

struct orlov_stats { __u32 free_inodes ; __u32 free_blocks ; __u32 used_dirs ; } ;

void get_orlov_stats ( struct super_block * sb , ext4_group_t g , int flex_size , struct orlov_stats * stats ) ;

struct inode * ext4_new_inode ( handle_t * handle , struct inode * dir , int mode , const struct qstr * qstr , __u32 goal ) ;

struct inode * ext4_orphan_get ( struct super_block * sb , unsigned long ino ) ;

unsigned long ext4_count_free_inodes ( struct super_block * sb ) ;

unsigned long ext4_count_dirs ( struct super_block * sb ) ;

struct ext4_extent { __le32 ee_block ; __le16 ee_len ; __le16 ee_start_hi ; __le32 ee_start_lo ; } ;

struct ext4_extent_idx { __le32 ei_block ; __le32 ei_leaf_lo ; __le16 ei_leaf_hi ; __u16 ei_unused ; } ;

struct ext4_extent_header { __le16 eh_magic ; __le16 eh_entries ; __le16 eh_max ; __le16 eh_depth ; __le32 eh_generation ; } ;

struct ext4_ext_path { ext4_fsblk_t p_block ; __u16 p_depth ; struct ext4_extent * p_ext ; struct ext4_extent_idx * p_idx ; struct ext4_extent_header * p_hdr ; struct buffer_head * p_bh ; } ;

typedef int ( * ext_prepare_callback ) ( struct inode * , struct ext4_ext_path * , struct ext4_ext_cache * , struct ext4_extent * , void * ) ;
int ext4_forget ( handle_t * handle , int is_metadata , struct inode * inode , struct buffer_head * bh , ext4_fsblk_t blocknr ) ;

int ext4_truncate_restart_trans ( handle_t * handle , struct inode * inode , int nblocks ) ;

void ext4_delete_inode ( struct inode * inode ) ;

qsize_t * ext4_get_reserved_space ( struct inode * inode ) ;

void ext4_da_update_reserve_space ( struct inode * inode , int used , int quota_claim ) ;

int ext4_get_blocks ( handle_t * handle , struct inode * inode , sector_t block , unsigned int max_blocks , struct buffer_head * bh , int flags ) ;

int ext4_get_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh_result , int create ) ;

struct buffer_head * ext4_getblk ( handle_t * handle , struct inode * inode , ext4_lblk_t block , int create , int * errp ) ;

struct buffer_head * ext4_bread ( handle_t * handle , struct inode * inode , ext4_lblk_t block , int create , int * err ) ;

int ext4_alloc_da_blocks ( struct inode * inode ) ;

int flush_aio_dio_completed_IO ( struct inode * inode ) ;

void ext4_set_aops ( struct inode * inode ) ;

int ext4_block_truncate_page ( handle_t * handle , struct address_space * mapping , loff_t from ) ;

int ext4_can_truncate ( struct inode * inode ) ;

void ext4_truncate ( struct inode * inode ) ;

int ext4_get_inode_loc ( struct inode * inode , struct ext4_iloc * iloc ) ;

void ext4_set_inode_flags ( struct inode * inode ) ;

void ext4_get_inode_flags ( struct ext4_inode_info * ei ) ;

struct inode * ext4_iget ( struct super_block * sb , unsigned long ino ) ;

int ext4_write_inode ( struct inode * inode , int wait ) ;

int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) ;

int ext4_getattr ( struct vfsmount * mnt , struct dentry * dentry , struct kstat * stat ) ;

int ext4_meta_trans_blocks ( struct inode * inode , int nrblocks , int chunk ) ;

int ext4_writepage_trans_blocks ( struct inode * inode ) ;

int ext4_chunk_trans_blocks ( struct inode * inode , int nrblocks ) ;

int ext4_mark_iloc_dirty ( handle_t * handle , struct inode * inode , struct ext4_iloc * iloc ) ;

int ext4_reserve_inode_write ( handle_t * handle , struct inode * inode , struct ext4_iloc * iloc ) ;

int ext4_mark_inode_dirty ( handle_t * handle , struct inode * inode ) ;

void ext4_dirty_inode ( struct inode * inode ) ;

int ext4_change_inode_journal_flag ( struct inode * inode , int val ) ;

int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) ;

long ext4_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

long ext4_compat_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) ;

unsigned int ext4_rec_len_from_disk ( __le16 dlen , unsigned blocksize ) ;

__le16 ext4_rec_len_to_disk ( unsigned len , unsigned blocksize ) ;

int ext4_htree_fill_tree ( struct file * dir_file , __u32 start_hash , __u32 start_minor_hash , __u32 * next_hash ) ;

struct dentry * ext4_get_parent ( struct dentry * child ) ;

int ext4_orphan_add ( handle_t * handle , struct inode * inode ) ;

int ext4_orphan_del ( handle_t * handle , struct inode * inode ) ;

struct ftrace_raw_ext4_free_inode { struct trace_entry ent ; dev_t dev ; ino_t ino ; umode_t mode ; uid_t uid ; gid_t gid ; blkcnt_t blocks ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_request_inode { struct trace_entry ent ; dev_t dev ; ino_t dir ; umode_t mode ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_allocate_inode { struct trace_entry ent ; dev_t dev ; ino_t ino ; ino_t dir ; umode_t mode ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_write_begin { struct trace_entry ent ; dev_t dev ; ino_t ino ; loff_t pos ; unsigned int len ; unsigned int flags ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_ordered_write_end { struct trace_entry ent ; dev_t dev ; ino_t ino ; loff_t pos ; unsigned int len ; unsigned int copied ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_writeback_write_end { struct trace_entry ent ; dev_t dev ; ino_t ino ; loff_t pos ; unsigned int len ; unsigned int copied ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_journalled_write_end { struct trace_entry ent ; dev_t dev ; ino_t ino ; loff_t pos ; unsigned int len ; unsigned int copied ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_writepage { struct trace_entry ent ; dev_t dev ; ino_t ino ; unsigned long index ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_da_writepages { struct trace_entry ent ; dev_t dev ; ino_t ino ; long nr_to_write ; long pages_skipped ; loff_t range_start ; loff_t range_end ; char nonblocking ; char for_kupdate ; char for_reclaim ; char range_cyclic ; unsigned long writeback_index ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_da_write_pages { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u64 b_blocknr ; __u32 b_size ; __u32 b_state ; unsigned long first_page ; int io_done ; int pages_written ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_da_writepages_result { struct trace_entry ent ; dev_t dev ; ino_t ino ; int ret ; int pages_written ; long pages_skipped ; char encountered_congestion ; char more_io ; char no_nrwrite_index_update ; unsigned long writeback_index ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_da_write_begin { struct trace_entry ent ; dev_t dev ; ino_t ino ; loff_t pos ; unsigned int len ; unsigned int flags ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_da_write_end { struct trace_entry ent ; dev_t dev ; ino_t ino ; loff_t pos ; unsigned int len ; unsigned int copied ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_discard_blocks { struct trace_entry ent ; dev_t dev ; __u64 blk ; __u64 count ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_mb_new_inode_pa { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u64 pa_pstart ; __u32 pa_len ; __u64 pa_lstart ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_mb_new_group_pa { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u64 pa_pstart ; __u32 pa_len ; __u64 pa_lstart ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_mb_release_inode_pa { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u64 block ; __u32 count ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_mb_release_group_pa { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u64 pa_pstart ; __u32 pa_len ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_discard_preallocations { struct trace_entry ent ; dev_t dev ; ino_t ino ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_mb_discard_preallocations { struct trace_entry ent ; dev_t dev ; int needed ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_request_blocks { struct trace_entry ent ; dev_t dev ; ino_t ino ; unsigned int flags ; unsigned int len ; __u64 logical ; __u64 goal ; __u64 lleft ; __u64 lright ; __u64 pleft ; __u64 pright ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_allocate_blocks { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u64 block ; unsigned int flags ; unsigned int len ; __u64 logical ; __u64 goal ; __u64 lleft ; __u64 lright ; __u64 pleft ; __u64 pright ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_free_blocks { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u64 block ; unsigned long count ; int metadata ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_sync_file { struct trace_entry ent ; dev_t dev ; ino_t ino ; ino_t parent ; int datasync ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_sync_fs { struct trace_entry ent ; dev_t dev ; int wait ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_alloc_da_blocks { struct trace_entry ent ; dev_t dev ; ino_t ino ; unsigned int data_blocks ; unsigned int meta_blocks ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_mballoc_alloc { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u16 found ; __u16 groups ; __u16 buddy ; __u16 flags ; __u16 tail ; __u8 cr ; __u32 orig_logical ; int orig_start ; __u32 orig_group ; int orig_len ; __u32 goal_logical ; int goal_start ; __u32 goal_group ; int goal_len ; __u32 result_logical ; int result_start ; __u32 result_group ; int result_len ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_mballoc_prealloc { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u32 orig_logical ; int orig_start ; __u32 orig_group ; int orig_len ; __u32 result_logical ; int result_start ; __u32 result_group ; int result_len ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_mballoc_discard { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u32 result_logical ; int result_start ; __u32 result_group ; int result_len ; char __data [ 0 ] ; } ;

struct ftrace_raw_ext4_mballoc_free { struct trace_entry ent ; dev_t dev ; ino_t ino ; __u32 result_logical ; int result_start ; __u32 result_group ; int result_len ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_ext4_free_inode { ; } ;

struct ftrace_data_offsets_ext4_request_inode { ; } ;

struct ftrace_data_offsets_ext4_allocate_inode { ; } ;

struct ftrace_data_offsets_ext4_write_begin { ; } ;

struct ftrace_data_offsets_ext4_ordered_write_end { ; } ;

struct ftrace_data_offsets_ext4_writeback_write_end { ; } ;

struct ftrace_data_offsets_ext4_journalled_write_end { ; } ;

struct ftrace_data_offsets_ext4_writepage { ; } ;

struct ftrace_data_offsets_ext4_da_writepages { ; } ;

struct ftrace_data_offsets_ext4_da_write_pages { ; } ;

struct ftrace_data_offsets_ext4_da_writepages_result { ; } ;

struct ftrace_data_offsets_ext4_da_write_begin { ; } ;

struct ftrace_data_offsets_ext4_da_write_end { ; } ;

struct ftrace_data_offsets_ext4_discard_blocks { ; } ;

struct ftrace_data_offsets_ext4_mb_new_inode_pa { ; } ;

struct ftrace_data_offsets_ext4_mb_new_group_pa { ; } ;

struct ftrace_data_offsets_ext4_mb_release_inode_pa { ; } ;

struct ftrace_data_offsets_ext4_mb_release_group_pa { ; } ;

struct ftrace_data_offsets_ext4_discard_preallocations { ; } ;

struct ftrace_data_offsets_ext4_mb_discard_preallocations { ; } ;

struct ftrace_data_offsets_ext4_request_blocks { ; } ;

struct ftrace_data_offsets_ext4_allocate_blocks { ; } ;

struct ftrace_data_offsets_ext4_free_blocks { ; } ;

struct ftrace_data_offsets_ext4_sync_file { ; } ;

struct ftrace_data_offsets_ext4_sync_fs { ; } ;

struct ftrace_data_offsets_ext4_alloc_da_blocks { ; } ;

struct ftrace_data_offsets_ext4_mballoc_alloc { ; } ;

struct ftrace_data_offsets_ext4_mballoc_prealloc { ; } ;

struct ftrace_data_offsets_ext4_mballoc_discard { ; } ;

struct ftrace_data_offsets_ext4_mballoc_free { ; } ;

ext4_fsblk_t ext4_block_bitmap ( struct super_block * sb , struct ext4_group_desc * bg ) ;

ext4_fsblk_t ext4_inode_bitmap ( struct super_block * sb , struct ext4_group_desc * bg ) ;

ext4_fsblk_t ext4_inode_table ( struct super_block * sb , struct ext4_group_desc * bg ) ;

__u32 ext4_free_blks_count ( struct super_block * sb , struct ext4_group_desc * bg ) ;

__u32 ext4_free_inodes_count ( struct super_block * sb , struct ext4_group_desc * bg ) ;

__u32 ext4_used_dirs_count ( struct super_block * sb , struct ext4_group_desc * bg ) ;

__u32 ext4_itable_unused_count ( struct super_block * sb , struct ext4_group_desc * bg ) ;

void ext4_block_bitmap_set ( struct super_block * sb , struct ext4_group_desc * bg , ext4_fsblk_t blk ) ;

void ext4_inode_bitmap_set ( struct super_block * sb , struct ext4_group_desc * bg , ext4_fsblk_t blk ) ;

void ext4_inode_table_set ( struct super_block * sb , struct ext4_group_desc * bg , ext4_fsblk_t blk ) ;

void ext4_free_blks_set ( struct super_block * sb , struct ext4_group_desc * bg , __u32 count ) ;

void ext4_free_inodes_set ( struct super_block * sb , struct ext4_group_desc * bg , __u32 count ) ;

void ext4_used_dirs_set ( struct super_block * sb , struct ext4_group_desc * bg , __u32 count ) ;

void ext4_itable_unused_set ( struct super_block * sb , struct ext4_group_desc * bg , __u32 count ) ;

handle_t * ext4_journal_start_sb ( struct super_block * sb , int nblocks ) ;

int __ext4_journal_stop ( const char * where , handle_t * handle ) ;

void ext4_journal_abort_handle ( const char * caller , const char * err_fn , struct buffer_head * bh , handle_t * handle , int err ) ;

void ext4_error ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void __ext4_std_error ( struct super_block * sb , const char * function , int errno ) ;

void ext4_abort ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void ext4_msg ( struct super_block * sb , const char * prefix , const char * fmt , ... ) ;

void ext4_warning ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void ext4_grp_locked_error ( struct super_block * sb , ext4_group_t grp , const char * function , const char * fmt , ... ) ;

void ext4_update_dynamic_rev ( struct super_block * sb ) ;

enum { Opt_bsd_df , Opt_minix_df , Opt_grpid , Opt_nogrpid , Opt_resgid , Opt_resuid , Opt_sb , Opt_err_cont , Opt_err_panic , Opt_err_ro , Opt_nouid32 , Opt_debug , Opt_oldalloc , Opt_orlov , Opt_user_xattr , Opt_nouser_xattr , Opt_acl , Opt_noacl , Opt_auto_da_alloc , Opt_noauto_da_alloc , Opt_noload , Opt_nobh , Opt_bh , Opt_commit , Opt_min_batch_time , Opt_max_batch_time , Opt_journal_update , Opt_journal_dev , Opt_journal_checksum , Opt_journal_async_commit , Opt_abort , Opt_data_journal , Opt_data_ordered , Opt_data_writeback , Opt_data_err_abort , Opt_data_err_ignore , Opt_usrjquota , Opt_grpjquota , Opt_offusrjquota , Opt_offgrpjquota , Opt_jqfmt_vfsold , Opt_jqfmt_vfsv0 , Opt_quota , Opt_noquota , Opt_ignore , Opt_barrier , Opt_nobarrier , Opt_err , Opt_resize , Opt_usrquota , Opt_grpquota , Opt_i_version , Opt_stripe , Opt_delalloc , Opt_nodelalloc , Opt_block_validity , Opt_noblock_validity , Opt_inode_readahead_blks , Opt_journal_ioprio , Opt_discard , Opt_nodiscard , } ;
__le16 ext4_group_desc_csum ( struct ext4_sb_info * sbi , __u32 block_group , struct ext4_group_desc * gdp ) ;

int ext4_group_desc_csum_verify ( struct ext4_sb_info * sbi , __u32 block_group , struct ext4_group_desc * gdp ) ;

struct ext4_attr { struct attribute attr ; ssize_t ( * show ) ( struct ext4_attr * , struct ext4_sb_info * , char * ) ; ssize_t ( * store ) ( struct ext4_attr * , struct ext4_sb_info * , const char * , size_t ) ; int offset ; } ;

int ext4_force_commit ( struct super_block * sb ) ;

int ext4fs_dirhash ( const char * name , int len , struct dx_hash_info * hinfo ) ;

int ext4_group_add ( struct super_block * sb , struct ext4_new_group_data * input ) ;

int ext4_group_extend ( struct super_block * sb , struct ext4_super_block * es , ext4_fsblk_t n_blocks_count ) ;

ext4_fsblk_t ext_pblock ( struct ext4_extent * ex ) ;

ext4_fsblk_t idx_pblock ( struct ext4_extent_idx * ix ) ;

void ext4_ext_store_pblock ( struct ext4_extent * ex , ext4_fsblk_t pb ) ;

int ext4_ext_calc_metadata_amount ( struct inode * inode , sector_t lblock ) ;

int ext4_ext_check_inode ( struct inode * inode ) ;

void ext4_ext_drop_refs ( struct ext4_ext_path * path ) ;

int ext4_ext_tree_init ( handle_t * handle , struct inode * inode ) ;

struct ext4_ext_path * ext4_ext_find_extent ( struct inode * inode , ext4_lblk_t block , struct ext4_ext_path * path ) ;

int ext4_ext_insert_index ( handle_t * handle , struct inode * inode , struct ext4_ext_path * curp , int logical , ext4_fsblk_t ptr ) ;

int ext4_ext_search_left ( struct inode * inode , struct ext4_ext_path * path , ext4_lblk_t * logical , ext4_fsblk_t * phys ) ;

int ext4_ext_search_right ( struct inode * inode , struct ext4_ext_path * path , ext4_lblk_t * logical , ext4_fsblk_t * phys ) ;

int ext4_can_extents_be_merged ( struct inode * inode , struct ext4_extent * ex1 , struct ext4_extent * ex2 ) ;

int ext4_ext_try_to_merge ( struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * ex ) ;

unsigned int ext4_ext_check_overlap ( struct inode * inode , struct ext4_extent * newext , struct ext4_ext_path * path ) ;

int ext4_ext_insert_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * newext , int flag ) ;

int ext4_ext_walk_space ( struct inode * inode , ext4_lblk_t block , ext4_lblk_t num , ext_prepare_callback func , void * cbdata ) ;

int ext4_ext_calc_credits_for_single_extent ( struct inode * inode , int nrblocks , struct ext4_ext_path * path ) ;

int ext4_ext_index_trans_blocks ( struct inode * inode , int nrblocks , int chunk ) ;

void ext4_ext_init ( struct super_block * sb ) ;

void ext4_ext_release ( struct super_block * sb ) ;

int ext4_ext_get_blocks ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct buffer_head * bh_result , int flags ) ;

void ext4_ext_truncate ( struct inode * inode ) ;

long ext4_fallocate ( struct inode * inode , int mode , loff_t offset , loff_t len ) ;

int ext4_convert_unwritten_extents ( struct inode * inode , loff_t offset , ssize_t len ) ;

int ext4_fiemap ( struct inode * inode , struct fiemap_extent_info * fieinfo , __u64 start , __u64 len ) ;

int __ext4_journal_get_undo_access ( const char * where , handle_t * handle , struct buffer_head * bh ) ;

int __ext4_journal_get_write_access ( const char * where , handle_t * handle , struct buffer_head * bh ) ;

int __ext4_journal_forget ( const char * where , handle_t * handle , struct buffer_head * bh ) ;

int __ext4_journal_revoke ( const char * where , handle_t * handle , ext4_fsblk_t blocknr , struct buffer_head * bh ) ;

int __ext4_journal_get_create_access ( const char * where , handle_t * handle , struct buffer_head * bh ) ;

int __ext4_handle_dirty_metadata ( const char * where , handle_t * handle , struct inode * inode , struct buffer_head * bh ) ;

struct list_blocks_struct { ext4_lblk_t first_block , last_block ; ext4_fsblk_t first_pblock , last_pblock ; } ;

int ext4_ext_migrate ( struct inode * inode ) ;

int ext4_mb_get_buddy_cache_lock ( struct super_block * sb , ext4_group_t group ) ;

void ext4_mb_put_buddy_cache_lock ( struct super_block * sb , ext4_group_t group , int locked_group ) ;

int ext4_mb_add_groupinfo ( struct super_block * sb , ext4_group_t group , struct ext4_group_desc * desc ) ;

int ext4_mb_init ( struct super_block * sb , int needs_recovery ) ;

int ext4_mb_release ( struct super_block * sb ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_ext4_mballoc ( void ) ;

void exit_ext4_mballoc ( void ) ;

void ext4_discard_preallocations ( struct inode * inode ) ;

ext4_fsblk_t ext4_mb_new_blocks ( handle_t * handle , struct ext4_allocation_request * ar , int * errp ) ;

void ext4_mb_free_blocks ( handle_t * handle , struct inode * inode , ext4_fsblk_t block , unsigned long count , int metadata , unsigned long * freed ) ;

struct ext4_system_zone { struct rb_node node ; ext4_fsblk_t start_blk ; unsigned int count ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_ext4_system_zone ( void ) ;

void exit_ext4_system_zone ( void ) ;

int ext4_setup_system_zone ( struct super_block * sb ) ;

void ext4_release_system_zone ( struct super_block * sb ) ;

int ext4_data_block_valid ( struct ext4_sb_info * sbi , ext4_fsblk_t start_blk , unsigned int count ) ;

int ext4_move_extents ( struct file * o_filp , struct file * d_filp , __u64 orig_start , __u64 donor_start , __u64 len , __u64 * moved_len ) ;

ssize_t ext4_listxattr ( struct dentry * dentry , char * buffer , size_t size ) ;

int ext4_xattr_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) ;

struct ext4_xattr_info { int name_index ; const char * name ; const void * value ; size_t value_len ; } ;

struct ext4_xattr_search { struct ext4_xattr_entry * first ; void * base ; void * end ; struct ext4_xattr_entry * here ; int not_found ; } ;

struct ext4_xattr_block_find { struct ext4_xattr_search s ; struct buffer_head * bh ; } ;

struct ext4_xattr_ibody_find { struct ext4_xattr_search s ; struct ext4_iloc iloc ; } ;

int ext4_xattr_set_handle ( handle_t * handle , struct inode * inode , int name_index , const char * name , const void * value , size_t value_len , int flags ) ;

int ext4_xattr_set ( struct inode * inode , int name_index , const char * name , const void * value , size_t value_len , int flags ) ;

int ext4_expand_extra_isize_ea ( struct inode * inode , int new_extra_isize , struct ext4_inode * raw_inode , handle_t * handle ) ;

void ext4_xattr_delete_inode ( handle_t * handle , struct inode * inode ) ;

void ext4_xattr_put_super ( struct super_block * sb ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_ext4_xattr ( void ) ;

void exit_ext4_xattr ( void ) ;

int ext4_check_acl ( struct inode * inode , int mask ) ;

int ext4_init_acl ( handle_t * handle , struct inode * inode , struct inode * dir ) ;

int ext4_acl_chmod ( struct inode * inode ) ;

int ext4_init_security ( handle_t * handle , struct inode * inode , struct inode * dir ) ;

typedef u16 wchar_t ;
typedef u32 unicode_t ;

struct nls_table { const char * charset ; const char * alias ; int ( * uni2char ) ( wchar_t uni , unsigned char * out , int boundlen ) ; int ( * char2uni ) ( const unsigned char * rawstring , int boundlen , wchar_t * uni ) ; const unsigned char * charset2lower ; const unsigned char * charset2upper ; struct module * owner ; struct nls_table * next ; } ;

enum utf16_endian { UTF16_HOST_ENDIAN , UTF16_LITTLE_ENDIAN , UTF16_BIG_ENDIAN } ;

struct __fat_dirent { long d_ino ; __kernel_off_t d_off ; unsigned short d_reclen ; char d_name [ 256 ] ; } ;

struct fat_boot_sector { __u8 ignored [ 3 ] ; __u8 system_id [ 8 ] ; __u8 sector_size [ 2 ] ; __u8 sec_per_clus ; __le16 reserved ; __u8 fats ; __u8 dir_entries [ 2 ] ; __u8 sectors [ 2 ] ; __u8 media ; __le16 fat_length ; __le16 secs_track ; __le16 heads ; __le32 hidden ; __le32 total_sect ; __le32 fat32_length ; __le16 flags ; __u8 version [ 2 ] ; __le32 root_cluster ; __le16 info_sector ; __le16 backup_boot ; __le16 reserved2 [ 6 ] ; } ;

struct fat_boot_fsinfo { __le32 signature1 ; __le32 reserved1 [ 120 ] ; __le32 signature2 ; __le32 free_clusters ; __le32 next_cluster ; __le32 reserved2 [ 4 ] ; } ;

struct msdos_dir_entry { __u8 name [ 11 ] ; __u8 attr ; __u8 lcase ; __u8 ctime_cs ; __le16 ctime ; __le16 cdate ; __le16 adate ; __le16 starthi ; __le16 time , date , start ; __le32 size ; } ;

struct msdos_dir_slot { __u8 id ; __u8 name0_4 [ 10 ] ; __u8 attr ; __u8 reserved ; __u8 alias_checksum ; __u8 name5_10 [ 12 ] ; __le16 start ; __u8 name11_12 [ 4 ] ; } ;

struct fat_mount_options { uid_t fs_uid ; gid_t fs_gid ; unsigned short fs_fmask ; unsigned short fs_dmask ; unsigned short codepage ; char * iocharset ; unsigned short shortname ; unsigned char name_check ; unsigned char errors ; unsigned short allow_utime ; unsigned quiet : 1 , showexec : 1 , sys_immutable : 1 , dotsOK : 1 , isvfat : 1 , utf8 : 1 , unicode_xlate : 1 , numtail : 1 , flush : 1 , nocase : 1 , usefree : 1 , tz_utc : 1 , rodir : 1 ; } ;

struct msdos_sb_info { unsigned short sec_per_clus ; unsigned short cluster_bits ; unsigned int cluster_size ; unsigned char fats , fat_bits ; unsigned short fat_start ; unsigned long fat_length ; unsigned long dir_start ; unsigned short dir_entries ; unsigned long data_start ; unsigned long max_cluster ; unsigned long root_cluster ; unsigned long fsinfo_sector ; struct mutex fat_lock ; unsigned int prev_free ; unsigned int free_clusters ; unsigned int free_clus_valid ; struct fat_mount_options options ; struct nls_table * nls_disk ; struct nls_table * nls_io ; const void * dir_ops ; int dir_per_block ; int dir_per_block_bits ; int fatent_shift ; struct fatent_operations * fatent_ops ; struct inode * fat_inode ; spinlock_t inode_hash_lock ; struct hlist_head inode_hashtable [ ( 1UL << 8 ) ] ; } ;

struct msdos_inode_info { spinlock_t cache_lru_lock ; struct list_head cache_lru ; int nr_caches ; unsigned int cache_valid_id ; loff_t mmu_private ; int i_start ; int i_logstart ; int i_attrs ; loff_t i_pos ; struct hlist_node i_fat_hash ; struct inode vfs_inode ; } ;

struct fat_slot_info { loff_t i_pos ; loff_t slot_off ; int nr_slots ; struct msdos_dir_entry * de ; struct buffer_head * bh ; } ;

struct fat_entry { int entry ; union { u8 * ent12_p [ 2 ] ; __le16 * ent16_p ; __le32 * ent32_p ; } u ; int nr_bhs ; struct buffer_head * bhs [ 2 ] ; struct inode * fat_inode ; } ;

typedef unsigned long long llu ;

struct fat_cache { struct list_head cache_list ; int nr_contig ; int fcluster ; int dcluster ; } ;

struct fat_cache_id { unsigned int id ; int nr_contig ; int fcluster ; int dcluster ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) fat_cache_init ( void ) ;

void fat_cache_destroy ( void ) ;

void fat_cache_inval_inode ( struct inode * inode ) ;

int fat_get_cluster ( struct inode * inode , int cluster , int * fclus , int * dclus ) ;

int fat_bmap ( struct inode * inode , sector_t sector , sector_t * phys , unsigned long * mapped_blocks , int create ) ;

enum { PARSE_INVALID = 1 , PARSE_NOT_LONGNAME , PARSE_EOF , } ;
int fat_search_long ( struct inode * inode , const unsigned char * name , int name_len , struct fat_slot_info * sinfo ) ;

struct fat_ioctl_filldir_callback { void * dirent ; int result ; const char * longname ; int long_len ; const char * shortname ; int short_len ; } ;

int fat_get_dotdot_entry ( struct inode * dir , struct buffer_head * * bh , struct msdos_dir_entry * * de , loff_t * i_pos ) ;

int fat_dir_empty ( struct inode * dir ) ;

int fat_subdirs ( struct inode * dir ) ;

int fat_scan ( struct inode * dir , const unsigned char * name , struct fat_slot_info * sinfo ) ;

int fat_remove_entries ( struct inode * dir , struct fat_slot_info * sinfo ) ;

int fat_alloc_new_dir ( struct inode * dir , struct timespec * ts ) ;

int fat_add_entries ( struct inode * dir , void * slots , int nr_slots , struct fat_slot_info * sinfo ) ;

struct fatent_operations { void ( * ent_blocknr ) ( struct super_block * , int , int * , sector_t * ) ; void ( * ent_set_ptr ) ( struct fat_entry * , int ) ; int ( * ent_bread ) ( struct super_block * , struct fat_entry * , int , sector_t ) ; int ( * ent_get ) ( struct fat_entry * ) ; void ( * ent_put ) ( struct fat_entry * , int ) ; int ( * ent_next ) ( struct fat_entry * ) ; } ;

void fat_ent_access_init ( struct super_block * sb ) ;

int fat_ent_read ( struct inode * inode , struct fat_entry * fatent , int entry ) ;

int fat_ent_write ( struct inode * inode , struct fat_entry * fatent , int new , int wait ) ;

int fat_alloc_clusters ( struct inode * inode , int * cluster , int nr_cluster ) ;

int fat_free_clusters ( struct inode * inode , int cluster ) ;

int fat_count_free_clusters ( struct super_block * sb ) ;

int fat_generic_ioctl ( struct inode * inode , struct file * filp , unsigned int cmd , unsigned long arg ) ;

int fat_file_fsync ( struct file * filp , struct dentry * dentry , int datasync ) ;

void fat_truncate ( struct inode * inode ) ;

int fat_getattr ( struct vfsmount * mnt , struct dentry * dentry , struct kstat * stat ) ;

int fat_setattr ( struct dentry * dentry , struct iattr * attr ) ;

void fat_attach ( struct inode * inode , loff_t i_pos ) ;

void fat_detach ( struct inode * inode ) ;

struct inode * fat_iget ( struct super_block * sb , loff_t i_pos ) ;

struct inode * fat_build_inode ( struct super_block * sb , struct msdos_dir_entry * de , loff_t i_pos ) ;

int fat_sync_inode ( struct inode * inode ) ;

enum { Opt_check_n , Opt_check_r , Opt_check_s , Opt_uid , Opt_gid , Opt_umask , Opt_dmask , Opt_fmask , Opt_allow_utime , Opt_codepage , Opt_usefree , Opt_nocase , Opt_quiet , Opt_showexec , Opt_debug , Opt_immutable , Opt_dots , Opt_nodots , Opt_charset , Opt_shortname_lower , Opt_shortname_win95 , Opt_shortname_winnt , Opt_shortname_mixed , Opt_utf8_no , Opt_utf8_yes , Opt_uni_xl_no , Opt_uni_xl_yes , Opt_nonumtail_no , Opt_nonumtail_yes , Opt_obsolate , Opt_flush , Opt_tz_utc , Opt_rodir , Opt_err_cont , Opt_err_panic , Opt_err_ro , Opt_err , } ;
int fat_fill_super ( struct super_block * sb , void * data , int silent , const struct inode_operations * fs_dir_inode_ops , int isvfat ) ;

int fat_flush_inodes ( struct super_block * sb , struct inode * i1 , struct inode * i2 ) ;

void fat_fs_error ( struct super_block * s , const char * fmt , ... ) ;

int fat_clusters_flush ( struct super_block * sb ) ;

int fat_chain_add ( struct inode * inode , int new_dclus , int nr_cluster ) ;

void fat_time_fat2unix ( struct msdos_sb_info * sbi , struct timespec * ts , __le16 __time , __le16 __date , u8 time_cs ) ;

void fat_time_unix2fat ( struct msdos_sb_info * sbi , struct timespec * ts , __le16 * time , __le16 * date , u8 * time_cs ) ;

int fat_sync_bhs ( struct buffer_head * * bhs , int nr_bhs ) ;

struct shortname_info { unsigned char lower : 1 , upper : 1 , valid : 1 ; } ;

struct fuse_attr { __u64 ino ; __u64 size ; __u64 blocks ; __u64 atime ; __u64 mtime ; __u64 ctime ; __u32 atimensec ; __u32 mtimensec ; __u32 ctimensec ; __u32 mode ; __u32 nlink ; __u32 uid ; __u32 gid ; __u32 rdev ; __u32 blksize ; __u32 padding ; } ;

struct fuse_kstatfs { __u64 blocks ; __u64 bfree ; __u64 bavail ; __u64 files ; __u64 ffree ; __u32 bsize ; __u32 namelen ; __u32 frsize ; __u32 padding ; __u32 spare [ 6 ] ; } ;

struct fuse_file_lock { __u64 start ; __u64 end ; __u32 type ; __u32 pid ; } ;

enum fuse_opcode { FUSE_LOOKUP = 1 , FUSE_FORGET = 2 , FUSE_GETATTR = 3 , FUSE_SETATTR = 4 , FUSE_READLINK = 5 , FUSE_SYMLINK = 6 , FUSE_MKNOD = 8 , FUSE_MKDIR = 9 , FUSE_UNLINK = 10 , FUSE_RMDIR = 11 , FUSE_RENAME = 12 , FUSE_LINK = 13 , FUSE_OPEN = 14 , FUSE_READ = 15 , FUSE_WRITE = 16 , FUSE_STATFS = 17 , FUSE_RELEASE = 18 , FUSE_FSYNC = 20 , FUSE_SETXATTR = 21 , FUSE_GETXATTR = 22 , FUSE_LISTXATTR = 23 , FUSE_REMOVEXATTR = 24 , FUSE_FLUSH = 25 , FUSE_INIT = 26 , FUSE_OPENDIR = 27 , FUSE_READDIR = 28 , FUSE_RELEASEDIR = 29 , FUSE_FSYNCDIR = 30 , FUSE_GETLK = 31 , FUSE_SETLK = 32 , FUSE_SETLKW = 33 , FUSE_ACCESS = 34 , FUSE_CREATE = 35 , FUSE_INTERRUPT = 36 , FUSE_BMAP = 37 , FUSE_DESTROY = 38 , FUSE_IOCTL = 39 , FUSE_POLL = 40 , CUSE_INIT = 4096 , } ;

enum fuse_notify_code { FUSE_NOTIFY_POLL = 1 , FUSE_NOTIFY_INVAL_INODE = 2 , FUSE_NOTIFY_INVAL_ENTRY = 3 , FUSE_NOTIFY_CODE_MAX , } ;

struct fuse_entry_out { __u64 nodeid ; __u64 generation ; __u64 entry_valid ; __u64 attr_valid ; __u32 entry_valid_nsec ; __u32 attr_valid_nsec ; struct fuse_attr attr ; } ;

struct fuse_forget_in { __u64 nlookup ; } ;

struct fuse_getattr_in { __u32 getattr_flags ; __u32 dummy ; __u64 fh ; } ;

struct fuse_attr_out { __u64 attr_valid ; __u32 attr_valid_nsec ; __u32 dummy ; struct fuse_attr attr ; } ;

struct fuse_mknod_in { __u32 mode ; __u32 rdev ; __u32 umask ; __u32 padding ; } ;

struct fuse_mkdir_in { __u32 mode ; __u32 umask ; } ;

struct fuse_rename_in { __u64 newdir ; } ;

struct fuse_link_in { __u64 oldnodeid ; } ;

struct fuse_setattr_in { __u32 valid ; __u32 padding ; __u64 fh ; __u64 size ; __u64 lock_owner ; __u64 atime ; __u64 mtime ; __u64 unused2 ; __u32 atimensec ; __u32 mtimensec ; __u32 unused3 ; __u32 mode ; __u32 unused4 ; __u32 uid ; __u32 gid ; __u32 unused5 ; } ;

struct fuse_open_in { __u32 flags ; __u32 unused ; } ;

struct fuse_create_in { __u32 flags ; __u32 mode ; __u32 umask ; __u32 padding ; } ;

struct fuse_open_out { __u64 fh ; __u32 open_flags ; __u32 padding ; } ;

struct fuse_release_in { __u64 fh ; __u32 flags ; __u32 release_flags ; __u64 lock_owner ; } ;

struct fuse_flush_in { __u64 fh ; __u32 unused ; __u32 padding ; __u64 lock_owner ; } ;

struct fuse_read_in { __u64 fh ; __u64 offset ; __u32 size ; __u32 read_flags ; __u64 lock_owner ; __u32 flags ; __u32 padding ; } ;

struct fuse_write_in { __u64 fh ; __u64 offset ; __u32 size ; __u32 write_flags ; __u64 lock_owner ; __u32 flags ; __u32 padding ; } ;

struct fuse_write_out { __u32 size ; __u32 padding ; } ;

struct fuse_statfs_out { struct fuse_kstatfs st ; } ;

struct fuse_fsync_in { __u64 fh ; __u32 fsync_flags ; __u32 padding ; } ;

struct fuse_setxattr_in { __u32 size ; __u32 flags ; } ;

struct fuse_getxattr_in { __u32 size ; __u32 padding ; } ;

struct fuse_getxattr_out { __u32 size ; __u32 padding ; } ;

struct fuse_lk_in { __u64 fh ; __u64 owner ; struct fuse_file_lock lk ; __u32 lk_flags ; __u32 padding ; } ;

struct fuse_lk_out { struct fuse_file_lock lk ; } ;

struct fuse_access_in { __u32 mask ; __u32 padding ; } ;

struct fuse_init_in { __u32 major ; __u32 minor ; __u32 max_readahead ; __u32 flags ; } ;

struct fuse_init_out { __u32 major ; __u32 minor ; __u32 max_readahead ; __u32 flags ; __u16 max_background ; __u16 congestion_threshold ; __u32 max_write ; } ;

struct cuse_init_in { __u32 major ; __u32 minor ; __u32 unused ; __u32 flags ; } ;

struct cuse_init_out { __u32 major ; __u32 minor ; __u32 unused ; __u32 flags ; __u32 max_read ; __u32 max_write ; __u32 dev_major ; __u32 dev_minor ; __u32 spare [ 10 ] ; } ;

struct fuse_interrupt_in { __u64 unique ; } ;

struct fuse_bmap_in { __u64 block ; __u32 blocksize ; __u32 padding ; } ;

struct fuse_bmap_out { __u64 block ; } ;

struct fuse_ioctl_in { __u64 fh ; __u32 flags ; __u32 cmd ; __u64 arg ; __u32 in_size ; __u32 out_size ; } ;

struct fuse_ioctl_out { __s32 result ; __u32 flags ; __u32 in_iovs ; __u32 out_iovs ; } ;

struct fuse_poll_in { __u64 fh ; __u64 kh ; __u32 flags ; __u32 padding ; } ;

struct fuse_poll_out { __u32 revents ; __u32 padding ; } ;

struct fuse_notify_poll_wakeup_out { __u64 kh ; } ;

struct fuse_in_header { __u32 len ; __u32 opcode ; __u64 unique ; __u64 nodeid ; __u32 uid ; __u32 gid ; __u32 pid ; __u32 padding ; } ;

struct fuse_out_header { __u32 len ; __s32 error ; __u64 unique ; } ;

struct fuse_dirent { __u64 ino ; __u64 off ; __u32 namelen ; __u32 type ; char name [ 0 ] ; } ;

struct fuse_notify_inval_inode_out { __u64 ino ; __s64 off ; __s64 len ; } ;

struct fuse_notify_inval_entry_out { __u64 parent ; __u32 namelen ; __u32 padding ; } ;

struct fuse_inode { struct inode inode ; u64 nodeid ; u64 nlookup ; struct fuse_req * forget_req ; u64 i_time ; mode_t orig_i_mode ; u64 attr_version ; struct list_head write_files ; struct list_head queued_writes ; int writectr ; wait_queue_head_t page_waitq ; struct list_head writepages ; } ;

struct fuse_conn ;

struct fuse_file { struct fuse_conn * fc ; struct fuse_req * reserved_req ; u64 kh ; u64 fh ; u64 nodeid ; atomic_t count ; u32 open_flags ; struct list_head write_entry ; struct rb_node polled_node ; wait_queue_head_t poll_wait ; } ;

struct fuse_in_arg { unsigned size ; const void * value ; } ;

struct fuse_in { struct fuse_in_header h ; unsigned argpages : 1 ; unsigned numargs ; struct fuse_in_arg args [ 3 ] ; } ;

struct fuse_arg { unsigned size ; void * value ; } ;

struct fuse_out { struct fuse_out_header h ; unsigned argvar : 1 ; unsigned argpages : 1 ; unsigned page_zeroing : 1 ; unsigned numargs ; struct fuse_arg args [ 3 ] ; } ;

enum fuse_req_state { FUSE_REQ_INIT = 0 , FUSE_REQ_PENDING , FUSE_REQ_READING , FUSE_REQ_SENT , FUSE_REQ_WRITING , FUSE_REQ_FINISHED } ;

struct fuse_req { struct list_head list ; struct list_head intr_entry ; atomic_t count ; u64 intr_unique ; unsigned isreply : 1 ; unsigned force : 1 ; unsigned aborted : 1 ; unsigned background : 1 ; unsigned interrupted : 1 ; unsigned locked : 1 ; unsigned waiting : 1 ; enum fuse_req_state state ; struct fuse_in in ; struct fuse_out out ; wait_queue_head_t waitq ; union { struct fuse_forget_in forget_in ; struct { struct fuse_release_in in ; struct path path ; } release ; struct fuse_init_in init_in ; struct fuse_init_out init_out ; struct cuse_init_in cuse_init_in ; struct cuse_init_out cuse_init_out ; struct { struct fuse_read_in in ; u64 attr_ver ; } read ; struct { struct fuse_write_in in ; struct fuse_write_out out ; } write ; struct fuse_lk_in lk_in ; } misc ; struct page * pages [ 32 ] ; unsigned num_pages ; unsigned page_offset ; struct fuse_file * ff ; struct inode * inode ; struct list_head writepages_entry ; void ( * end ) ( struct fuse_conn * , struct fuse_req * ) ; struct file * stolen_file ; } ;

struct fuse_conn { spinlock_t lock ; struct mutex inst_mutex ; atomic_t count ; uid_t user_id ; gid_t group_id ; unsigned flags ; unsigned max_read ; unsigned max_write ; wait_queue_head_t waitq ; struct list_head pending ; struct list_head processing ; struct list_head io ; u64 khctr ; struct rb_root polled_files ; unsigned max_background ; unsigned congestion_threshold ; unsigned num_background ; unsigned active_background ; struct list_head bg_queue ; struct list_head interrupts ; int blocked ; wait_queue_head_t blocked_waitq ; wait_queue_head_t reserved_req_waitq ; u64 reqctr ; unsigned connected ; unsigned conn_error : 1 ; unsigned conn_init : 1 ; unsigned async_read : 1 ; unsigned atomic_o_trunc : 1 ; unsigned export_support : 1 ; unsigned bdi_initialized : 1 ; unsigned no_fsync : 1 ; unsigned no_fsyncdir : 1 ; unsigned no_flush : 1 ; unsigned no_setxattr : 1 ; unsigned no_getxattr : 1 ; unsigned no_listxattr : 1 ; unsigned no_removexattr : 1 ; unsigned no_lock : 1 ; unsigned no_access : 1 ; unsigned no_create : 1 ; unsigned no_interrupt : 1 ; unsigned no_bmap : 1 ; unsigned no_poll : 1 ; unsigned big_writes : 1 ; unsigned dont_mask : 1 ; atomic_t num_waiting ; unsigned minor ; struct backing_dev_info bdi ; struct list_head entry ; dev_t dev ; struct dentry * ctl_dentry [ 5 ] ; int ctl_ndents ; struct fasync_struct * fasync ; u32 scramble_key [ 4 ] ; struct fuse_req * destroy_req ; u64 attr_version ; void ( * release ) ( struct fuse_conn * ) ; struct super_block * sb ; struct rw_semaphore killsb ; } ;
struct fuse_req * fuse_request_alloc ( void ) ;

struct fuse_req * fuse_request_alloc_nofs ( void ) ;

void fuse_request_free ( struct fuse_req * req ) ;

struct fuse_req * fuse_get_req ( struct fuse_conn * fc ) ;

struct fuse_req * fuse_get_req_nofail ( struct fuse_conn * fc , struct file * file ) ;

void fuse_put_request ( struct fuse_conn * fc , struct fuse_req * req ) ;

void fuse_request_send ( struct fuse_conn * fc , struct fuse_req * req ) ;

void fuse_request_send_noreply ( struct fuse_conn * fc , struct fuse_req * req ) ;

void fuse_request_send_background ( struct fuse_conn * fc , struct fuse_req * req ) ;

void fuse_request_send_background_locked ( struct fuse_conn * fc , struct fuse_req * req ) ;

struct fuse_copy_state { struct fuse_conn * fc ; int write ; struct fuse_req * req ; const struct iovec * iov ; unsigned long nr_segs ; unsigned long seglen ; unsigned long addr ; struct page * pg ; void * mapaddr ; void * buf ; unsigned len ; } ;

void fuse_abort_conn ( struct fuse_conn * fc ) ;

int fuse_dev_release ( struct inode * inode , struct file * file ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) fuse_dev_init ( void ) ;

void fuse_dev_cleanup ( void ) ;

void fuse_invalidate_attr ( struct inode * inode ) ;

void fuse_invalidate_entry_cache ( struct dentry * entry ) ;

u64 fuse_get_attr_version ( struct fuse_conn * fc ) ;

int fuse_valid_type ( int m ) ;

int fuse_lookup_name ( struct super_block * sb , u64 nodeid , struct qstr * name , struct fuse_entry_out * outarg , struct inode * * inode ) ;

int fuse_update_attributes ( struct inode * inode , struct kstat * stat , struct file * file , bool * refreshed ) ;

int fuse_reverse_inval_entry ( struct super_block * sb , u64 parent_nodeid , struct qstr * name ) ;

int fuse_allow_task ( struct fuse_conn * fc , struct task_struct * task ) ;

void fuse_set_nowrite ( struct inode * inode ) ;

void fuse_release_nowrite ( struct inode * inode ) ;

void fuse_init_common ( struct inode * inode ) ;

void fuse_init_dir ( struct inode * inode ) ;

void fuse_init_symlink ( struct inode * inode ) ;

struct fuse_file * fuse_file_alloc ( struct fuse_conn * fc ) ;

void fuse_file_free ( struct fuse_file * ff ) ;

struct fuse_file * fuse_file_get ( struct fuse_file * ff ) ;

int fuse_do_open ( struct fuse_conn * fc , u64 nodeid , struct file * file , bool isdir ) ;

void fuse_finish_open ( struct inode * inode , struct file * file ) ;

int fuse_open_common ( struct inode * inode , struct file * file , bool isdir ) ;

void fuse_release_common ( struct file * file , int opcode ) ;

void fuse_sync_release ( struct fuse_file * ff , int flags ) ;

u64 fuse_lock_owner_id ( struct fuse_conn * fc , fl_owner_t id ) ;

int fuse_fsync_common ( struct file * file , struct dentry * de , int datasync , int isdir ) ;

void fuse_read_fill ( struct fuse_req * req , struct file * file , loff_t pos , size_t count , int opcode ) ;

struct fuse_fill_data { struct fuse_req * req ; struct file * file ; struct inode * inode ; } ;

ssize_t fuse_direct_io ( struct file * file , const char * buf , size_t count , loff_t * ppos , int write ) ;

void fuse_flush_writepages ( struct inode * inode ) ;

long fuse_do_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , unsigned int flags ) ;

unsigned fuse_file_poll ( struct file * file , poll_table * wait ) ;

int fuse_notify_poll_wakeup ( struct fuse_conn * fc , struct fuse_notify_poll_wakeup_out * outarg ) ;

void fuse_init_file_inode ( struct inode * inode ) ;

struct fuse_mount_data { int fd ; unsigned rootmode ; unsigned user_id ; unsigned group_id ; unsigned fd_present : 1 ; unsigned rootmode_present : 1 ; unsigned user_id_present : 1 ; unsigned group_id_present : 1 ; unsigned flags ; unsigned max_read ; unsigned blksize ; } ;

void fuse_send_forget ( struct fuse_conn * fc , struct fuse_req * req , u64 nodeid , u64 nlookup ) ;

void fuse_change_attributes_common ( struct inode * inode , struct fuse_attr * attr , u64 attr_valid ) ;

void fuse_change_attributes ( struct inode * inode , struct fuse_attr * attr , u64 attr_valid , u64 attr_version ) ;

int fuse_inode_eq ( struct inode * inode , void * _nodeidp ) ;

struct inode * fuse_iget ( struct super_block * sb , u64 nodeid , int generation , struct fuse_attr * attr , u64 attr_valid , u64 attr_version ) ;

int fuse_reverse_inval_inode ( struct super_block * sb , u64 nodeid , loff_t offset , loff_t len ) ;

void fuse_conn_kill ( struct fuse_conn * fc ) ;

enum { OPT_FD , OPT_ROOTMODE , OPT_USER_ID , OPT_GROUP_ID , OPT_DEFAULT_PERMISSIONS , OPT_ALLOW_OTHER , OPT_MAX_READ , OPT_BLKSIZE , OPT_ERR } ;
void fuse_conn_init ( struct fuse_conn * fc ) ;

void fuse_conn_put ( struct fuse_conn * fc ) ;

struct fuse_conn * fuse_conn_get ( struct fuse_conn * fc ) ;

struct fuse_inode_handle { u64 nodeid ; u32 generation ; } ;

int fuse_ctl_add_conn ( struct fuse_conn * fc ) ;

void fuse_ctl_remove_conn ( struct fuse_conn * fc ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) fuse_ctl_init ( void ) ;

void fuse_ctl_cleanup ( void ) ;

struct hfs_name { u8 len ; u8 name [ 31 ] ; } __attribute__ ( ( packed ) ) ;
struct hfs_point { __be16 v ; __be16 h ; } __attribute__ ( ( packed ) ) ;
struct hfs_rect { __be16 top ; __be16 left ; __be16 bottom ; __be16 right ; } __attribute__ ( ( packed ) ) ;
struct hfs_finfo { __be32 fdType ; __be32 fdCreator ; __be16 fdFlags ; struct hfs_point fdLocation ; __be16 fdFldr ; } __attribute__ ( ( packed ) ) ;
struct hfs_fxinfo { __be16 fdIconID ; u8 fdUnused [ 8 ] ; __be16 fdComment ; __be32 fdPutAway ; } __attribute__ ( ( packed ) ) ;
struct hfs_dinfo { struct hfs_rect frRect ; __be16 frFlags ; struct hfs_point frLocation ; __be16 frView ; } __attribute__ ( ( packed ) ) ;
struct hfs_dxinfo { struct hfs_point frScroll ; __be32 frOpenChain ; __be16 frUnused ; __be16 frComment ; __be32 frPutAway ; } __attribute__ ( ( packed ) ) ;
union hfs_finder_info { struct { struct hfs_finfo finfo ; struct hfs_fxinfo fxinfo ; } file ; struct { struct hfs_dinfo dinfo ; struct hfs_dxinfo dxinfo ; } dir ; } __attribute__ ( ( packed ) ) ;
struct hfs_cat_key { u8 key_len ; u8 reserved ; __be32 ParID ; struct hfs_name CName ; } __attribute__ ( ( packed ) ) ;
struct hfs_ext_key { u8 key_len ; u8 FkType ; __be32 FNum ; __be16 FABN ; } __attribute__ ( ( packed ) ) ;

typedef union hfs_btree_key { u8 key_len ; struct hfs_cat_key cat ; struct hfs_ext_key ext ; } hfs_btree_key ;

typedef union hfs_btree_key btree_key ;

struct hfs_extent { __be16 block ; __be16 count ; } ;

typedef struct hfs_extent hfs_extent_rec [ 3 ] ;
struct hfs_cat_file { s8 type ; u8 reserved ; u8 Flags ; s8 Typ ; struct hfs_finfo UsrWds ; __be32 FlNum ; __be16 StBlk ; __be32 LgLen ; __be32 PyLen ; __be16 RStBlk ; __be32 RLgLen ; __be32 RPyLen ; __be32 CrDat ; __be32 MdDat ; __be32 BkDat ; struct hfs_fxinfo FndrInfo ; __be16 ClpSize ; hfs_extent_rec ExtRec ; hfs_extent_rec RExtRec ; u32 Resrv ; } __attribute__ ( ( packed ) ) ;
struct hfs_cat_dir { s8 type ; u8 reserved ; __be16 Flags ; __be16 Val ; __be32 DirID ; __be32 CrDat ; __be32 MdDat ; __be32 BkDat ; struct hfs_dinfo UsrInfo ; struct hfs_dxinfo FndrInfo ; u8 Resrv [ 16 ] ; } __attribute__ ( ( packed ) ) ;
struct hfs_cat_thread { s8 type ; u8 reserved [ 9 ] ; __be32 ParID ; struct hfs_name CName ; } __attribute__ ( ( packed ) ) ;

typedef union hfs_cat_rec { s8 type ; struct hfs_cat_file file ; struct hfs_cat_dir dir ; struct hfs_cat_thread thread ; } hfs_cat_rec ;

struct hfs_mdb { __be16 drSigWord ; __be32 drCrDate ; __be32 drLsMod ; __be16 drAtrb ; __be16 drNmFls ; __be16 drVBMSt ; __be16 drAllocPtr ; __be16 drNmAlBlks ; __be32 drAlBlkSiz ; __be32 drClpSiz ; __be16 drAlBlSt ; __be32 drNxtCNID ; __be16 drFreeBks ; u8 drVN [ 28 ] ; __be32 drVolBkUp ; __be16 drVSeqNum ; __be32 drWrCnt ; __be32 drXTClpSiz ; __be32 drCTClpSiz ; __be16 drNmRtDirs ; __be32 drFilCnt ; __be32 drDirCnt ; u8 drFndrInfo [ 32 ] ; __be16 drEmbedSigWord ; __be32 drEmbedExtent ; __be32 drXTFlSize ; hfs_extent_rec drXTExtRec ; __be32 drCTFlSize ; hfs_extent_rec drCTExtRec ; } __attribute__ ( ( packed ) ) ;
struct hfs_readdir_data { struct list_head list ; struct file * file ; struct hfs_cat_key key ; } ;

struct hfs_inode_info { atomic_t opencnt ; unsigned int flags ; int tz_secondswest ; struct hfs_cat_key cat_key ; struct list_head open_dir_list ; struct inode * rsrc_inode ; struct mutex extents_lock ; u16 alloc_blocks , clump_blocks ; sector_t fs_blocks ; hfs_extent_rec first_extents ; u16 first_blocks ; hfs_extent_rec cached_extents ; u16 cached_start , cached_blocks ; loff_t phys_size ; struct inode vfs_inode ; } ;

struct hfs_sb_info { struct buffer_head * mdb_bh ; struct hfs_mdb * mdb ; struct buffer_head * alt_mdb_bh ; struct hfs_mdb * alt_mdb ; __be32 * bitmap ; struct hfs_btree * ext_tree ; struct hfs_btree * cat_tree ; u32 file_count ; u32 folder_count ; u32 next_id ; u32 clumpablks ; u32 fs_start ; u32 part_start ; u16 root_files ; u16 root_dirs ; u16 fs_ablocks ; u16 free_ablocks ; u32 alloc_blksz ; int s_quiet ; __be32 s_type ; __be32 s_creator ; umode_t s_file_umask ; umode_t s_dir_umask ; uid_t s_uid ; gid_t s_gid ; int session , part ; struct nls_table * nls_io , * nls_disk ; struct mutex bitmap_lock ; unsigned long flags ; u16 blockoffset ; int fs_div ; struct hlist_head rsrc_inodes ; } ;

struct hfs_find_data ;

u32 hfs_vbm_search_free ( struct super_block * sb , u32 goal , u32 * num_bits ) ;

int hfs_clear_vbm_bits ( struct super_block * sb , u16 start , u16 count ) ;

typedef int ( * btree_keycmp ) ( const btree_key * , const btree_key * ) ;
struct hfs_btree { struct super_block * sb ; struct inode * inode ; btree_keycmp keycmp ; u32 cnid ; u32 root ; u32 leaf_count ; u32 leaf_head ; u32 leaf_tail ; u32 node_count ; u32 free_nodes ; u32 attributes ; unsigned int node_size ; unsigned int node_size_shift ; unsigned int max_key_len ; unsigned int depth ; struct semaphore tree_lock ; unsigned int pages_per_bnode ; spinlock_t hash_lock ; struct hfs_bnode * node_hash [ 256 ] ; int node_hash_cnt ; } ;

struct hfs_bnode { struct hfs_btree * tree ; u32 prev ; u32 this ; u32 next ; u32 parent ; u16 num_recs ; u8 type ; u8 height ; struct hfs_bnode * next_hash ; unsigned long flags ; wait_queue_head_t lock_wq ; atomic_t refcnt ; unsigned int page_offset ; struct page * page [ 0 ] ; } ;

struct hfs_find_data { btree_key * key ; btree_key * search_key ; struct hfs_btree * tree ; struct hfs_bnode * bnode ; int record ; int keyoffset , keylength ; int entryoffset , entrylength ; } ;
struct hfs_bnode_desc { __be32 next ; __be32 prev ; u8 type ; u8 height ; __be16 num_recs ; u16 reserved ; } __attribute__ ( ( packed ) ) ;
struct hfs_btree_header_rec { __be16 depth ; __be32 root ; __be32 leaf_count ; __be32 leaf_head ; __be32 leaf_tail ; __be16 node_size ; __be16 max_key_len ; __be32 node_count ; __be32 free_nodes ; u16 reserved1 ; __be32 clump_size ; u8 btree_type ; u8 reserved2 ; __be32 attributes ; u32 reserved3 [ 16 ] ; } __attribute__ ( ( packed ) ) ;
int hfs_find_init ( struct hfs_btree * tree , struct hfs_find_data * fd ) ;

void hfs_find_exit ( struct hfs_find_data * fd ) ;

int __hfs_brec_find ( struct hfs_bnode * bnode , struct hfs_find_data * fd ) ;

int hfs_brec_find ( struct hfs_find_data * fd ) ;

int hfs_brec_read ( struct hfs_find_data * fd , void * rec , int rec_len ) ;

int hfs_brec_goto ( struct hfs_find_data * fd , int cnt ) ;

void hfs_bnode_read ( struct hfs_bnode * node , void * buf , int off , int len ) ;

u16 hfs_bnode_read_u16 ( struct hfs_bnode * node , int off ) ;

u8 hfs_bnode_read_u8 ( struct hfs_bnode * node , int off ) ;

void hfs_bnode_read_key ( struct hfs_bnode * node , void * key , int off ) ;

void hfs_bnode_write ( struct hfs_bnode * node , void * buf , int off , int len ) ;

void hfs_bnode_write_u16 ( struct hfs_bnode * node , int off , u16 data ) ;

void hfs_bnode_write_u8 ( struct hfs_bnode * node , int off , u8 data ) ;

void hfs_bnode_clear ( struct hfs_bnode * node , int off , int len ) ;

void hfs_bnode_copy ( struct hfs_bnode * dst_node , int dst , struct hfs_bnode * src_node , int src , int len ) ;

void hfs_bnode_move ( struct hfs_bnode * node , int dst , int src , int len ) ;

void hfs_bnode_dump ( struct hfs_bnode * node ) ;

void hfs_bnode_unlink ( struct hfs_bnode * node ) ;

struct hfs_bnode * hfs_bnode_findhash ( struct hfs_btree * tree , u32 cnid ) ;

void hfs_bnode_unhash ( struct hfs_bnode * node ) ;

struct hfs_bnode * hfs_bnode_find ( struct hfs_btree * tree , u32 num ) ;

void hfs_bnode_free ( struct hfs_bnode * node ) ;

struct hfs_bnode * hfs_bnode_create ( struct hfs_btree * tree , u32 num ) ;

void hfs_bnode_get ( struct hfs_bnode * node ) ;

void hfs_bnode_put ( struct hfs_bnode * node ) ;

u16 hfs_brec_lenoff ( struct hfs_bnode * node , u16 rec , u16 * off ) ;

u16 hfs_brec_keylen ( struct hfs_bnode * node , u16 rec ) ;

int hfs_brec_insert ( struct hfs_find_data * fd , void * entry , int entry_len ) ;

int hfs_brec_remove ( struct hfs_find_data * fd ) ;

struct hfs_btree * hfs_btree_open ( struct super_block * sb , u32 id , btree_keycmp keycmp ) ;

void hfs_btree_close ( struct hfs_btree * tree ) ;

void hfs_btree_write ( struct hfs_btree * tree ) ;

struct hfs_bnode * hfs_bmap_alloc ( struct hfs_btree * tree ) ;

void hfs_bmap_free ( struct hfs_bnode * node ) ;

void hfs_cat_build_key ( struct super_block * sb , btree_key * key , u32 parent , struct qstr * name ) ;

int hfs_cat_create ( u32 cnid , struct inode * dir , struct qstr * str , struct inode * inode ) ;

int hfs_cat_keycmp ( const btree_key * key1 , const btree_key * key2 ) ;

int hfs_cat_find_brec ( struct super_block * sb , u32 cnid , struct hfs_find_data * fd ) ;

int hfs_cat_delete ( u32 cnid , struct inode * dir , struct qstr * str ) ;

int hfs_cat_move ( u32 cnid , struct inode * src_dir , struct qstr * src_name , struct inode * dst_dir , struct qstr * dst_name ) ;

int hfs_ext_keycmp ( const btree_key * key1 , const btree_key * key2 ) ;

void hfs_ext_write_extent ( struct inode * inode ) ;

int hfs_free_fork ( struct super_block * sb , struct hfs_cat_file * file , int type ) ;

int hfs_get_block ( struct inode * inode , sector_t block , struct buffer_head * bh_result , int create ) ;

int hfs_extend_file ( struct inode * inode ) ;

void hfs_file_truncate ( struct inode * inode ) ;

struct inode * hfs_new_inode ( struct inode * dir , struct qstr * name , int mode ) ;

void hfs_delete_inode ( struct inode * inode ) ;

void hfs_inode_read_fork ( struct inode * inode , struct hfs_extent * ext , __be32 __log_size , __be32 phys_size , u32 clump_size ) ;

struct hfs_iget_data { struct hfs_cat_key * key ; hfs_cat_rec * rec ; } ;

struct inode * hfs_iget ( struct super_block * sb , struct hfs_cat_key * key , hfs_cat_rec * rec ) ;

void hfs_inode_write_fork ( struct inode * inode , struct hfs_extent * ext , __be32 * log_size , __be32 * phys_size ) ;

int hfs_write_inode ( struct inode * inode , int unused ) ;

void hfs_clear_inode ( struct inode * inode ) ;

int hfs_inode_setattr ( struct dentry * dentry , struct iattr * attr ) ;

int hfs_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

ssize_t hfs_getxattr ( struct dentry * dentry , const char * name , void * value , size_t size ) ;

ssize_t hfs_listxattr ( struct dentry * dentry , char * buffer , size_t size ) ;

struct cdrom_msf0 { __u8 minute ; __u8 second ; __u8 frame ; } ;

union cdrom_addr { struct cdrom_msf0 msf ; int lba ; } ;

struct cdrom_msf { __u8 cdmsf_min0 ; __u8 cdmsf_sec0 ; __u8 cdmsf_frame0 ; __u8 cdmsf_min1 ; __u8 cdmsf_sec1 ; __u8 cdmsf_frame1 ; } ;

struct cdrom_ti { __u8 cdti_trk0 ; __u8 cdti_ind0 ; __u8 cdti_trk1 ; __u8 cdti_ind1 ; } ;

struct cdrom_tochdr { __u8 cdth_trk0 ; __u8 cdth_trk1 ; } ;

struct cdrom_volctrl { __u8 channel0 ; __u8 channel1 ; __u8 channel2 ; __u8 channel3 ; } ;

struct cdrom_subchnl { __u8 cdsc_format ; __u8 cdsc_audiostatus ; __u8 cdsc_adr : 4 ; __u8 cdsc_ctrl : 4 ; __u8 cdsc_trk ; __u8 cdsc_ind ; union cdrom_addr cdsc_absaddr ; union cdrom_addr cdsc_reladdr ; } ;

struct cdrom_tocentry { __u8 cdte_track ; __u8 cdte_adr : 4 ; __u8 cdte_ctrl : 4 ; __u8 cdte_format ; union cdrom_addr cdte_addr ; __u8 cdte_datamode ; } ;

struct cdrom_read { int cdread_lba ; char * cdread_bufaddr ; int cdread_buflen ; } ;

struct cdrom_read_audio { union cdrom_addr addr ; __u8 addr_format ; int nframes ; __u8 * buf ; } ;

struct cdrom_multisession { union cdrom_addr addr ; __u8 xa_flag ; __u8 addr_format ; } ;

struct cdrom_mcn { __u8 medium_catalog_number [ 14 ] ; } ;

struct cdrom_blk { unsigned from ; unsigned short len ; } ;

struct cdrom_generic_command { unsigned char cmd [ 12 ] ; unsigned char * buffer ; unsigned int buflen ; int stat ; struct request_sense * sense ; unsigned char data_direction ; int quiet ; int timeout ; void * reserved [ 1 ] ; } ;

struct dvd_layer { __u8 book_version : 4 ; __u8 book_type : 4 ; __u8 min_rate : 4 ; __u8 disc_size : 4 ; __u8 layer_type : 4 ; __u8 track_path : 1 ; __u8 nlayers : 2 ; __u8 track_density : 4 ; __u8 linear_density : 4 ; __u8 bca : 1 ; __u32 start_sector ; __u32 end_sector ; __u32 end_sector_l0 ; } ;

struct dvd_physical { __u8 type ; __u8 layer_num ; struct dvd_layer layer [ 4 ] ; } ;

struct dvd_copyright { __u8 type ; __u8 layer_num ; __u8 cpst ; __u8 rmi ; } ;

struct dvd_disckey { __u8 type ; unsigned agid : 2 ; __u8 value [ 2048 ] ; } ;

struct dvd_bca { __u8 type ; int len ; __u8 value [ 188 ] ; } ;

struct dvd_manufact { __u8 type ; __u8 layer_num ; int len ; __u8 value [ 2048 ] ; } ;

typedef union { __u8 type ; struct dvd_physical physical ; struct dvd_copyright copyright ; struct dvd_disckey disckey ; struct dvd_bca bca ; struct dvd_manufact manufact ; } dvd_struct ;

typedef __u8 dvd_key [ 5 ] ;
typedef __u8 dvd_challenge [ 10 ] ;
struct dvd_lu_send_agid { __u8 type ; unsigned agid : 2 ; } ;

struct dvd_host_send_challenge { __u8 type ; unsigned agid : 2 ; dvd_challenge chal ; } ;

struct dvd_send_key { __u8 type ; unsigned agid : 2 ; dvd_key key ; } ;

struct dvd_lu_send_challenge { __u8 type ; unsigned agid : 2 ; dvd_challenge chal ; } ;

struct dvd_lu_send_title_key { __u8 type ; unsigned agid : 2 ; dvd_key title_key ; int lba ; unsigned cpm : 1 ; unsigned cp_sec : 1 ; unsigned cgms : 2 ; } ;

struct dvd_lu_send_asf { __u8 type ; unsigned agid : 2 ; unsigned asf : 1 ; } ;

struct dvd_host_send_rpcstate { __u8 type ; __u8 pdrc ; } ;

struct dvd_lu_send_rpcstate { __u8 type : 2 ; __u8 vra : 3 ; __u8 ucca : 3 ; __u8 region_mask ; __u8 rpc_scheme ; } ;

typedef union { __u8 type ; struct dvd_lu_send_agid lsa ; struct dvd_host_send_challenge hsc ; struct dvd_send_key lsk ; struct dvd_lu_send_challenge lsc ; struct dvd_send_key hsk ; struct dvd_lu_send_title_key lstk ; struct dvd_lu_send_asf lsasf ; struct dvd_host_send_rpcstate hrpcs ; struct dvd_lu_send_rpcstate lrpcs ; } dvd_authinfo ;

struct request_sense { __u8 error_code : 7 ; __u8 valid : 1 ; __u8 segment_number ; __u8 sense_key : 4 ; __u8 reserved2 : 1 ; __u8 ili : 1 ; __u8 reserved1 : 2 ; __u8 information [ 4 ] ; __u8 add_sense_len ; __u8 command_info [ 4 ] ; __u8 asc ; __u8 ascq ; __u8 fruc ; __u8 sks [ 3 ] ; __u8 asb [ 46 ] ; } ;

struct mrw_feature_desc { __be16 feature_code ; __u8 curr : 1 ; __u8 persistent : 1 ; __u8 feature_version : 4 ; __u8 reserved1 : 2 ; __u8 add_len ; __u8 write : 1 ; __u8 reserved2 : 7 ; __u8 reserved3 ; __u8 reserved4 ; __u8 reserved5 ; } ;

struct rwrt_feature_desc { __be16 feature_code ; __u8 curr : 1 ; __u8 persistent : 1 ; __u8 feature_version : 4 ; __u8 reserved1 : 2 ; __u8 add_len ; __u32 last_lba ; __u32 block_size ; __u16 blocking ; __u8 page_present : 1 ; __u8 reserved2 : 7 ; __u8 reserved3 ; } ;

typedef struct { __be16 disc_information_length ; __u8 disc_status : 2 ; __u8 border_status : 2 ; __u8 erasable : 1 ; __u8 reserved1 : 3 ; __u8 n_first_track ; __u8 n_sessions_lsb ; __u8 first_track_lsb ; __u8 last_track_lsb ; __u8 mrw_status : 2 ; __u8 dbit : 1 ; __u8 reserved2 : 2 ; __u8 uru : 1 ; __u8 dbc_v : 1 ; __u8 did_v : 1 ; __u8 disc_type ; __u8 n_sessions_msb ; __u8 first_track_msb ; __u8 last_track_msb ; __u32 disc_id ; __u32 lead_in ; __u32 lead_out ; __u8 disc_bar_code [ 8 ] ; __u8 reserved3 ; __u8 n_opc ; } disc_information ;

typedef struct { __be16 track_information_length ; __u8 track_lsb ; __u8 session_lsb ; __u8 reserved1 ; __u8 track_mode : 4 ; __u8 copy : 1 ; __u8 damage : 1 ; __u8 reserved2 : 2 ; __u8 data_mode : 4 ; __u8 fp : 1 ; __u8 packet : 1 ; __u8 blank : 1 ; __u8 rt : 1 ; __u8 nwa_v : 1 ; __u8 lra_v : 1 ; __u8 reserved3 : 6 ; __be32 track_start ; __be32 next_writable ; __be32 free_blocks ; __be32 fixed_packet_size ; __be32 track_size ; __be32 last_rec_address ; } track_information ;

struct feature_header { __u32 data_len ; __u8 reserved1 ; __u8 reserved2 ; __u16 curr_profile ; } ;

struct mode_page_header { __be16 mode_data_length ; __u8 medium_type ; __u8 reserved1 ; __u8 reserved2 ; __u8 reserved3 ; __be16 desc_length ; } ;

struct packet_command { unsigned char cmd [ 12 ] ; unsigned char * buffer ; unsigned int buflen ; int stat ; struct request_sense * sense ; unsigned char data_direction ; int quiet ; int timeout ; void * reserved [ 1 ] ; } ;

struct cdrom_device_info { struct cdrom_device_ops * ops ; struct list_head list ; struct gendisk * disk ; void * handle ; int mask ; int speed ; int capacity ; unsigned int options : 30 ; unsigned mc_flags : 2 ; int use_count ; char name [ 20 ] ; __u8 sanyo_slot : 2 ; __u8 reserved : 6 ; int cdda_method ; __u8 last_sense ; __u8 media_written ; unsigned short mmc3_profile ; int for_data ; int ( * exit ) ( struct cdrom_device_info * ) ; int mrw_mode_page ; } ;

struct cdrom_device_ops { int ( * open ) ( struct cdrom_device_info * , int ) ; void ( * release ) ( struct cdrom_device_info * ) ; int ( * drive_status ) ( struct cdrom_device_info * , int ) ; int ( * media_changed ) ( struct cdrom_device_info * , int ) ; int ( * tray_move ) ( struct cdrom_device_info * , int ) ; int ( * lock_door ) ( struct cdrom_device_info * , int ) ; int ( * select_speed ) ( struct cdrom_device_info * , int ) ; int ( * select_disc ) ( struct cdrom_device_info * , int ) ; int ( * get_last_session ) ( struct cdrom_device_info * , struct cdrom_multisession * ) ; int ( * get_mcn ) ( struct cdrom_device_info * , struct cdrom_mcn * ) ; int ( * reset ) ( struct cdrom_device_info * ) ; int ( * audio_ioctl ) ( struct cdrom_device_info * , unsigned int , void * ) ; const int capability ; int n_minors ; int ( * generic_packet ) ( struct cdrom_device_info * , struct packet_command * ) ; } ;

typedef struct { int data ; int audio ; int cdi ; int xa ; long error ; } tracktype ;

struct cdrom_mechstat_header { __u8 curslot : 5 ; __u8 changer_state : 2 ; __u8 fault : 1 ; __u8 reserved1 : 4 ; __u8 door_open : 1 ; __u8 mech_state : 3 ; __u8 curlba [ 3 ] ; __u8 nslots ; __u16 slot_tablelen ; } ;

struct cdrom_slot { __u8 change : 1 ; __u8 reserved1 : 6 ; __u8 disc_present : 1 ; __u8 reserved2 [ 3 ] ; } ;

struct cdrom_changer_info { struct cdrom_mechstat_header hdr ; struct cdrom_slot slots [ 256 ] ; } ;

typedef enum { mechtype_caddy = 0 , mechtype_tray = 1 , mechtype_popup = 2 , mechtype_individual_changer = 4 , mechtype_cartridge_changer = 5 } mechtype_t ;

typedef struct { __u8 page_code : 6 ; __u8 reserved1 : 1 ; __u8 ps : 1 ; __u8 page_length ; __u8 write_type : 4 ; __u8 test_write : 1 ; __u8 ls_v : 1 ; __u8 bufe : 1 ; __u8 reserved2 : 1 ; __u8 track_mode : 4 ; __u8 copy : 1 ; __u8 fp : 1 ; __u8 multi_session : 2 ; __u8 data_block_type : 4 ; __u8 reserved3 : 4 ; __u8 link_size ; __u8 reserved4 ; __u8 app_code : 6 ; __u8 reserved5 : 2 ; __u8 session_format ; __u8 reserved6 ; __be32 packet_size ; __u16 audio_pause ; __u8 mcn [ 16 ] ; __u8 isrc [ 16 ] ; __u8 subhdr0 ; __u8 subhdr1 ; __u8 subhdr2 ; __u8 subhdr3 ; } __attribute__ ( ( packed ) ) write_param_page ;

struct modesel_head { __u8 reserved1 ; __u8 medium ; __u8 reserved2 ; __u8 block_desc_length ; __u8 density ; __u8 number_of_blocks_hi ; __u8 number_of_blocks_med ; __u8 number_of_blocks_lo ; __u8 reserved3 ; __u8 block_length_hi ; __u8 block_length_med ; __u8 block_length_lo ; } ;

typedef struct { __u16 report_key_length ; __u8 reserved1 ; __u8 reserved2 ; __u8 ucca : 3 ; __u8 vra : 3 ; __u8 type_code : 2 ; __u8 region_mask ; __u8 rpc_scheme ; __u8 reserved3 ; } rpc_state_t ;

struct event_header { __be16 data_len ; __u8 notification_class : 3 ; __u8 reserved1 : 4 ; __u8 nea : 1 ; __u8 supp_event_class ; } ;

struct media_event_desc { __u8 media_event_code : 4 ; __u8 reserved1 : 4 ; __u8 door_open : 1 ; __u8 media_present : 1 ; __u8 reserved2 : 6 ; __u8 start_slot ; __u8 end_slot ; } ;

int hfs_mdb_get ( struct super_block * sb ) ;

void hfs_mdb_commit ( struct super_block * sb ) ;

void hfs_mdb_close ( struct super_block * sb ) ;

void hfs_mdb_put ( struct super_block * sb ) ;

struct new_pmap { __be16 pmSig ; __be16 reSigPad ; __be32 pmMapBlkCnt ; __be32 pmPyPartStart ; __be32 pmPartBlkCnt ; u8 pmPartName [ 32 ] ; u8 pmPartType [ 32 ] ; } __attribute__ ( ( packed ) ) ;
struct old_pmap { __be16 pdSig ; struct old_pmap_entry { __be32 pdStart ; __be32 pdSize ; __be32 pdFSID ; } pdEntry [ 42 ] ; } __attribute__ ( ( packed ) ) ;
int hfs_part_find ( struct super_block * sb , sector_t * part_start , sector_t * part_size ) ;

int hfs_hash_dentry ( struct dentry * dentry , struct qstr * this ) ;

int hfs_strcmp ( const unsigned char * s1 , unsigned int len1 , const unsigned char * s2 , unsigned int len2 ) ;

int hfs_compare_dentry ( struct dentry * dentry , struct qstr * s1 , struct qstr * s2 ) ;

enum { opt_uid , opt_gid , opt_umask , opt_file_umask , opt_dir_umask , opt_part , opt_session , opt_type , opt_creator , opt_quiet , opt_codepage , opt_iocharset , opt_err } ;
int hfs_mac2asc ( struct super_block * sb , char * out , const struct hfs_name * in ) ;

void hfs_asc2mac ( struct super_block * sb , struct hfs_name * out , struct qstr * in ) ;

typedef __be32 hfsplus_cnid ;

typedef __be16 hfsplus_unichr ;

struct hfsplus_unistr { __be16 length ; hfsplus_unichr unicode [ 255 ] ; } __attribute__ ( ( packed ) ) ;
struct hfsplus_perm { __be32 owner ; __be32 group ; u8 rootflags ; u8 userflags ; __be16 mode ; __be32 dev ; } __attribute__ ( ( packed ) ) ;
struct hfsplus_extent { __be32 start_block ; __be32 block_count ; } __attribute__ ( ( packed ) ) ;
typedef struct hfsplus_extent hfsplus_extent_rec [ 8 ] ;
struct hfsplus_fork_raw { __be64 total_size ; __be32 clump_size ; __be32 total_blocks ; hfsplus_extent_rec extents ; } __attribute__ ( ( packed ) ) ;
struct hfsplus_vh { __be16 signature ; __be16 version ; __be32 attributes ; __be32 last_mount_vers ; u32 reserved ; __be32 create_date ; __be32 modify_date ; __be32 backup_date ; __be32 checked_date ; __be32 file_count ; __be32 folder_count ; __be32 blocksize ; __be32 total_blocks ; __be32 free_blocks ; __be32 next_alloc ; __be32 rsrc_clump_sz ; __be32 data_clump_sz ; hfsplus_cnid next_cnid ; __be32 write_count ; __be64 encodings_bmp ; u8 finder_info [ 32 ] ; struct hfsplus_fork_raw alloc_file ; struct hfsplus_fork_raw ext_file ; struct hfsplus_fork_raw cat_file ; struct hfsplus_fork_raw attr_file ; struct hfsplus_fork_raw start_file ; } __attribute__ ( ( packed ) ) ;
struct hfs_bnode_desc { __be32 next ; __be32 prev ; s8 type ; u8 height ; __be16 num_recs ; u16 reserved ; } __attribute__ ( ( packed ) ) ;
struct hfs_btree_header_rec { __be16 depth ; __be32 root ; __be32 leaf_count ; __be32 leaf_head ; __be32 leaf_tail ; __be16 node_size ; __be16 max_key_len ; __be32 node_count ; __be32 free_nodes ; u16 reserved1 ; __be32 clump_size ; u8 btree_type ; u8 key_type ; __be32 attributes ; u32 reserved3 [ 16 ] ; } __attribute__ ( ( packed ) ) ;
struct hfsplus_cat_key { __be16 key_len ; hfsplus_cnid parent ; struct hfsplus_unistr name ; } __attribute__ ( ( packed ) ) ;
struct hfsp_point { __be16 v ; __be16 h ; } __attribute__ ( ( packed ) ) ;
struct hfsp_rect { __be16 top ; __be16 left ; __be16 bottom ; __be16 right ; } __attribute__ ( ( packed ) ) ;
struct DInfo { struct hfsp_rect frRect ; __be16 frFlags ; struct hfsp_point frLocation ; __be16 frView ; } __attribute__ ( ( packed ) ) ;
struct DXInfo { struct hfsp_point frScroll ; __be32 frOpenChain ; __be16 frUnused ; __be16 frComment ; __be32 frPutAway ; } __attribute__ ( ( packed ) ) ;
struct hfsplus_cat_folder { __be16 type ; __be16 flags ; __be32 valence ; hfsplus_cnid id ; __be32 create_date ; __be32 content_mod_date ; __be32 attribute_mod_date ; __be32 access_date ; __be32 backup_date ; struct hfsplus_perm permissions ; struct DInfo user_info ; struct DXInfo finder_info ; __be32 text_encoding ; u32 reserved ; } __attribute__ ( ( packed ) ) ;
struct FInfo { __be32 fdType ; __be32 fdCreator ; __be16 fdFlags ; struct hfsp_point fdLocation ; __be16 fdFldr ; } __attribute__ ( ( packed ) ) ;
struct FXInfo { __be16 fdIconID ; u8 fdUnused [ 8 ] ; __be16 fdComment ; __be32 fdPutAway ; } __attribute__ ( ( packed ) ) ;
struct hfsplus_cat_file { __be16 type ; __be16 flags ; u32 reserved1 ; hfsplus_cnid id ; __be32 create_date ; __be32 content_mod_date ; __be32 attribute_mod_date ; __be32 access_date ; __be32 backup_date ; struct hfsplus_perm permissions ; struct FInfo user_info ; struct FXInfo finder_info ; __be32 text_encoding ; u32 reserved2 ; struct hfsplus_fork_raw data_fork ; struct hfsplus_fork_raw rsrc_fork ; } __attribute__ ( ( packed ) ) ;
struct hfsplus_cat_thread { __be16 type ; s16 reserved ; hfsplus_cnid parentID ; struct hfsplus_unistr nodeName ; } __attribute__ ( ( packed ) ) ;
typedef union { __be16 type ; struct hfsplus_cat_folder folder ; struct hfsplus_cat_file file ; struct hfsplus_cat_thread thread ; } __attribute__ ( ( packed ) ) hfsplus_cat_entry ;

struct hfsplus_ext_key { __be16 key_len ; u8 fork_type ; u8 pad ; hfsplus_cnid cnid ; __be32 start_block ; } __attribute__ ( ( packed ) ) ;
typedef union { __be16 key_len ; struct hfsplus_cat_key cat ; struct hfsplus_ext_key ext ; } __attribute__ ( ( packed ) ) hfsplus_btree_key ;

typedef int ( * btree_keycmp ) ( const hfsplus_btree_key * , const hfsplus_btree_key * ) ;
struct hfsplus_vh ;

struct hfs_btree ;
struct hfsplus_sb_info { struct buffer_head * s_vhbh ; struct hfsplus_vh * s_vhdr ; struct hfs_btree * ext_tree ; struct hfs_btree * cat_tree ; struct hfs_btree * attr_tree ; struct inode * alloc_file ; struct inode * hidden_dir ; struct nls_table * nls ; u32 blockoffset ; u32 sect_count ; int fs_shift ; u32 alloc_blksz ; int alloc_blksz_shift ; u32 total_blocks ; u32 free_blocks ; u32 next_alloc ; u32 next_cnid ; u32 file_count ; u32 folder_count ; u32 data_clump_blocks , rsrc_clump_blocks ; u32 creator ; u32 type ; umode_t umask ; uid_t uid ; gid_t gid ; int part , session ; unsigned long flags ; struct hlist_head rsrc_inodes ; } ;

struct hfsplus_inode_info { struct mutex extents_lock ; u32 clump_blocks , alloc_blocks ; sector_t fs_blocks ; hfsplus_extent_rec first_extents ; u32 first_blocks ; hfsplus_extent_rec cached_extents ; u32 cached_start , cached_blocks ; atomic_t opencnt ; struct inode * rsrc_inode ; unsigned long flags ; __be32 create_date ; u32 dev ; u8 rootflags ; u8 userflags ; struct list_head open_dir_list ; loff_t phys_size ; struct inode vfs_inode ; } ;

struct hfs_find_data { hfsplus_btree_key * search_key ; hfsplus_btree_key * key ; struct hfs_btree * tree ; struct hfs_bnode * bnode ; int record ; int keyoffset , keylength ; int entryoffset , entrylength ; } ;
struct hfsplus_readdir_data { struct list_head list ; struct file * file ; struct hfsplus_cat_key key ; } ;

struct inode * hfsplus_iget ( struct super_block * sb , unsigned long ino ) ;

enum { opt_creator , opt_type , opt_umask , opt_uid , opt_gid , opt_part , opt_session , opt_nls , opt_nodecompose , opt_decompose , opt_force , opt_err } ;
void hfsplus_fill_defaults ( struct hfsplus_sb_info * opts ) ;

int hfsplus_parse_options ( char * input , struct hfsplus_sb_info * sbi ) ;

int hfsplus_show_options ( struct seq_file * seq , struct vfsmount * mnt ) ;

struct inode * hfsplus_new_inode ( struct super_block * sb , int mode ) ;

void hfsplus_delete_inode ( struct inode * inode ) ;

void hfsplus_inode_read_fork ( struct inode * inode , struct hfsplus_fork_raw * fork ) ;

void hfsplus_inode_write_fork ( struct inode * inode , struct hfsplus_fork_raw * fork ) ;

int hfsplus_cat_read_inode ( struct inode * inode , struct hfs_find_data * fd ) ;

int hfsplus_cat_write_inode ( struct inode * inode ) ;

int hfsplus_ioctl ( struct inode * inode , struct file * filp , unsigned int cmd , unsigned long arg ) ;

int hfsplus_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

ssize_t hfsplus_getxattr ( struct dentry * dentry , const char * name , void * value , size_t size ) ;

ssize_t hfsplus_listxattr ( struct dentry * dentry , char * buffer , size_t size ) ;

int hfsplus_ext_cmp_key ( const hfsplus_btree_key * k1 , const hfsplus_btree_key * k2 ) ;

void hfsplus_ext_write_extent ( struct inode * inode ) ;

int hfsplus_get_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh_result , int create ) ;

int hfsplus_free_fork ( struct super_block * sb , u32 cnid , struct hfsplus_fork_raw * fork , int type ) ;

int hfsplus_file_extend ( struct inode * inode ) ;

void hfsplus_file_truncate ( struct inode * inode ) ;

int hfsplus_cat_case_cmp_key ( const hfsplus_btree_key * k1 , const hfsplus_btree_key * k2 ) ;

int hfsplus_cat_bin_cmp_key ( const hfsplus_btree_key * k1 , const hfsplus_btree_key * k2 ) ;

void hfsplus_cat_build_key ( struct super_block * sb , hfsplus_btree_key * key , u32 parent , struct qstr * str ) ;

int hfsplus_find_cat ( struct super_block * sb , u32 cnid , struct hfs_find_data * fd ) ;

int hfsplus_create_cat ( u32 cnid , struct inode * dir , struct qstr * str , struct inode * inode ) ;

int hfsplus_delete_cat ( u32 cnid , struct inode * dir , struct qstr * str ) ;

int hfsplus_rename_cat ( u32 cnid , struct inode * src_dir , struct qstr * src_name , struct inode * dst_dir , struct qstr * dst_name ) ;

struct hfs_btree * hfsplus_btree_open ( struct super_block * sb , u32 id ) ;

void hfsplus_btree_close ( struct hfs_btree * tree ) ;

void hfsplus_btree_write ( struct hfs_btree * tree ) ;

struct hfs_bnode * hfsplus_bmap_alloc ( struct hfs_btree * tree ) ;

void hfsplus_bmap_free ( struct hfs_bnode * node ) ;

void hfsplus_bnode_read ( struct hfs_bnode * node , void * buf , int off , int len ) ;

u16 hfsplus_bnode_read_u16 ( struct hfs_bnode * node , int off ) ;

u8 hfsplus_bnode_read_u8 ( struct hfs_bnode * node , int off ) ;

void hfsplus_bnode_read_key ( struct hfs_bnode * node , void * key , int off ) ;

void hfsplus_bnode_write ( struct hfs_bnode * node , void * buf , int off , int len ) ;

void hfsplus_bnode_write_u16 ( struct hfs_bnode * node , int off , u16 data ) ;

void hfsplus_bnode_clear ( struct hfs_bnode * node , int off , int len ) ;

void hfsplus_bnode_copy ( struct hfs_bnode * dst_node , int dst , struct hfs_bnode * src_node , int src , int len ) ;

void hfsplus_bnode_move ( struct hfs_bnode * node , int dst , int src , int len ) ;

void hfsplus_bnode_dump ( struct hfs_bnode * node ) ;

void hfsplus_bnode_unlink ( struct hfs_bnode * node ) ;

struct hfs_bnode * hfsplus_bnode_findhash ( struct hfs_btree * tree , u32 cnid ) ;

void hfsplus_bnode_unhash ( struct hfs_bnode * node ) ;

struct hfs_bnode * hfsplus_bnode_find ( struct hfs_btree * tree , u32 num ) ;

void hfsplus_bnode_free ( struct hfs_bnode * node ) ;

struct hfs_bnode * hfsplus_bnode_create ( struct hfs_btree * tree , u32 num ) ;

void hfsplus_bnode_get ( struct hfs_bnode * node ) ;

void hfsplus_bnode_put ( struct hfs_bnode * node ) ;

u16 hfsplus_brec_lenoff ( struct hfs_bnode * node , u16 rec , u16 * off ) ;

u16 hfsplus_brec_keylen ( struct hfs_bnode * node , u16 rec ) ;

int hfsplus_brec_insert ( struct hfs_find_data * fd , void * entry , int entry_len ) ;

int hfsplus_brec_remove ( struct hfs_find_data * fd ) ;

int hfsplus_find_init ( struct hfs_btree * tree , struct hfs_find_data * fd ) ;

void hfsplus_find_exit ( struct hfs_find_data * fd ) ;

int __hplusfs_brec_find ( struct hfs_bnode * bnode , struct hfs_find_data * fd ) ;

int hfsplus_brec_find ( struct hfs_find_data * fd ) ;

int hfsplus_brec_read ( struct hfs_find_data * fd , void * rec , int rec_len ) ;

int hfsplus_brec_goto ( struct hfs_find_data * fd , int cnt ) ;

int hfsplus_strcasecmp ( const struct hfsplus_unistr * s1 , const struct hfsplus_unistr * s2 ) ;

int hfsplus_strcmp ( const struct hfsplus_unistr * s1 , const struct hfsplus_unistr * s2 ) ;

int hfsplus_uni2asc ( struct super_block * sb , const struct hfsplus_unistr * ustr , char * astr , int * len_p ) ;

int hfsplus_asc2uni ( struct super_block * sb , struct hfsplus_unistr * ustr , const char * astr , int len ) ;

int hfsplus_hash_dentry ( struct dentry * dentry , struct qstr * str ) ;

int hfsplus_compare_dentry ( struct dentry * dentry , struct qstr * s1 , struct qstr * s2 ) ;

struct hfsplus_wd { u32 ablk_size ; u16 ablk_start ; u16 embed_start ; u16 embed_count ; } ;

int hfsplus_read_wrapper ( struct super_block * sb ) ;

int hfsplus_block_allocate ( struct super_block * sb , u32 size , u32 offset , u32 * max ) ;

int hfsplus_block_free ( struct super_block * sb , u32 offset , u32 count ) ;

int hfsplus_part_find ( struct super_block * sb , sector_t * part_start , sector_t * part_size ) ;

enum { Opt_size , Opt_nr_inodes , Opt_mode , Opt_uid , Opt_gid , Opt_pagesize , Opt_err , } ;
int hugetlb_get_quota ( struct address_space * mapping , long delta ) ;

void hugetlb_put_quota ( struct address_space * mapping , long delta ) ;

struct file * hugetlb_file_setup ( const char * name , size_t size , int acctflag , struct user_struct * * user , int creat_flags ) ;

handle_t * journal_start ( journal_t * journal , int nblocks ) ;

int journal_extend ( handle_t * handle , int nblocks ) ;

int journal_restart ( handle_t * handle , int nblocks ) ;

void journal_lock_updates ( journal_t * journal ) ;

void journal_unlock_updates ( journal_t * journal ) ;

int journal_get_write_access ( handle_t * handle , struct buffer_head * bh ) ;

int journal_get_create_access ( handle_t * handle , struct buffer_head * bh ) ;

int journal_get_undo_access ( handle_t * handle , struct buffer_head * bh ) ;

int journal_dirty_data ( handle_t * handle , struct buffer_head * bh ) ;

int journal_dirty_metadata ( handle_t * handle , struct buffer_head * bh ) ;

void journal_release_buffer ( handle_t * handle , struct buffer_head * bh ) ;

int journal_forget ( handle_t * handle , struct buffer_head * bh ) ;

int journal_stop ( handle_t * handle ) ;

int journal_force_commit ( journal_t * journal ) ;

void __journal_unfile_buffer ( struct journal_head * jh ) ;

void journal_unfile_buffer ( journal_t * journal , struct journal_head * jh ) ;

int journal_try_to_free_buffers ( journal_t * journal , struct page * page , gfp_t gfp_mask ) ;

void journal_invalidatepage ( journal_t * journal , struct page * page , unsigned long offset ) ;

void __journal_file_buffer ( struct journal_head * jh , transaction_t * transaction , int jlist ) ;

void journal_file_buffer ( struct journal_head * jh , transaction_t * transaction , int jlist ) ;

void __journal_refile_buffer ( struct journal_head * jh ) ;

void journal_refile_buffer ( journal_t * journal , struct journal_head * jh ) ;

void journal_commit_transaction ( journal_t * journal ) ;

struct recovery_info { tid_t start_transaction ; tid_t end_transaction ; int nr_replays ; int nr_revokes ; int nr_revoke_hits ; } ;

enum passtype { PASS_SCAN , PASS_REVOKE , PASS_REPLAY } ;

int journal_recover ( journal_t * journal ) ;

int journal_skip_recovery ( journal_t * journal ) ;

void __log_wait_for_space ( journal_t * journal ) ;

int log_do_checkpoint ( journal_t * journal ) ;

int cleanup_journal_tail ( journal_t * journal ) ;

int __journal_clean_checkpoint_list ( journal_t * journal ) ;

int __journal_remove_checkpoint ( struct journal_head * jh ) ;

void __journal_insert_checkpoint ( struct journal_head * jh , transaction_t * transaction ) ;

void __journal_drop_transaction ( journal_t * journal , transaction_t * transaction ) ;

struct jbd_revoke_record_s { struct list_head hash ; tid_t sequence ; unsigned int blocknr ; } ;

struct jbd_revoke_table_s { int hash_size ; int hash_shift ; struct list_head * hash_table ; } ;
void journal_destroy_revoke_caches ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) journal_init_revoke_caches ( void ) ;

int journal_init_revoke ( journal_t * journal , int hash_size ) ;

void journal_destroy_revoke ( journal_t * journal ) ;

int journal_revoke ( handle_t * handle , unsigned int blocknr , struct buffer_head * bh_in ) ;

int journal_cancel_revoke ( handle_t * handle , struct journal_head * jh ) ;

void journal_switch_revoke_table ( journal_t * journal ) ;

void journal_write_revoke_records ( journal_t * journal , transaction_t * transaction , int write_op ) ;

int journal_set_revoke ( journal_t * journal , unsigned int blocknr , tid_t sequence ) ;

int journal_test_revoke ( journal_t * journal , unsigned int blocknr , tid_t sequence ) ;

void journal_clear_revoke ( journal_t * journal ) ;

int journal_write_metadata_buffer ( transaction_t * transaction , struct journal_head * jh_in , struct journal_head * * jh_out , unsigned int blocknr ) ;

int __log_space_left ( journal_t * journal ) ;

int __log_start_commit ( journal_t * journal , tid_t target ) ;

int log_start_commit ( journal_t * journal , tid_t tid ) ;

int journal_force_commit_nested ( journal_t * journal ) ;

int journal_start_commit ( journal_t * journal , tid_t * ptid ) ;

int log_wait_commit ( journal_t * journal , tid_t tid ) ;

int journal_next_log_block ( journal_t * journal , unsigned int * retp ) ;

int journal_bmap ( journal_t * journal , unsigned int blocknr , unsigned int * retp ) ;

struct journal_head * journal_get_descriptor_buffer ( journal_t * journal ) ;

journal_t * journal_init_dev ( struct block_device * bdev , struct block_device * fs_dev , int start , int len , int blocksize ) ;

journal_t * journal_init_inode ( struct inode * inode ) ;

int journal_create ( journal_t * journal ) ;

void journal_update_superblock ( journal_t * journal , int wait ) ;

int journal_load ( journal_t * journal ) ;

int journal_destroy ( journal_t * journal ) ;

int journal_check_used_features ( journal_t * journal , unsigned long compat , unsigned long ro , unsigned long incompat ) ;

int journal_check_available_features ( journal_t * journal , unsigned long compat , unsigned long ro , unsigned long incompat ) ;

int journal_set_features ( journal_t * journal , unsigned long compat , unsigned long ro , unsigned long incompat ) ;

int journal_update_format ( journal_t * journal ) ;

int journal_flush ( journal_t * journal ) ;

int journal_wipe ( journal_t * journal , int write ) ;

void journal_abort ( journal_t * journal , int errno ) ;

int journal_errno ( journal_t * journal ) ;

int journal_clear_err ( journal_t * journal ) ;

void journal_ack_err ( journal_t * journal ) ;

int journal_blocks_per_page ( struct inode * inode ) ;

struct journal_head * journal_add_journal_head ( struct buffer_head * bh ) ;

struct journal_head * journal_grab_journal_head ( struct buffer_head * bh ) ;

void journal_remove_journal_head ( struct buffer_head * bh ) ;

void journal_put_journal_head ( struct journal_head * jh ) ;

handle_t * jbd2_journal_start ( journal_t * journal , int nblocks ) ;

int jbd2_journal_extend ( handle_t * handle , int nblocks ) ;

int jbd2_journal_restart ( handle_t * handle , int nblocks ) ;

void jbd2_journal_lock_updates ( journal_t * journal ) ;

void jbd2_journal_unlock_updates ( journal_t * journal ) ;

int jbd2_journal_get_write_access ( handle_t * handle , struct buffer_head * bh ) ;

int jbd2_journal_get_create_access ( handle_t * handle , struct buffer_head * bh ) ;

int jbd2_journal_get_undo_access ( handle_t * handle , struct buffer_head * bh ) ;

void jbd2_journal_set_triggers ( struct buffer_head * bh , struct jbd2_buffer_trigger_type * type ) ;

void jbd2_buffer_commit_trigger ( struct journal_head * jh , void * mapped_data , struct jbd2_buffer_trigger_type * triggers ) ;

void jbd2_buffer_abort_trigger ( struct journal_head * jh , struct jbd2_buffer_trigger_type * triggers ) ;

int jbd2_journal_dirty_metadata ( handle_t * handle , struct buffer_head * bh ) ;

void jbd2_journal_release_buffer ( handle_t * handle , struct buffer_head * bh ) ;

int jbd2_journal_forget ( handle_t * handle , struct buffer_head * bh ) ;

int jbd2_journal_stop ( handle_t * handle ) ;

int jbd2_journal_force_commit ( journal_t * journal ) ;

void __jbd2_journal_temp_unlink_buffer ( struct journal_head * jh ) ;

void __jbd2_journal_unfile_buffer ( struct journal_head * jh ) ;

void jbd2_journal_unfile_buffer ( journal_t * journal , struct journal_head * jh ) ;

int jbd2_journal_try_to_free_buffers ( journal_t * journal , struct page * page , gfp_t gfp_mask ) ;

void jbd2_journal_invalidatepage ( journal_t * journal , struct page * page , unsigned long offset ) ;

void __jbd2_journal_file_buffer ( struct journal_head * jh , transaction_t * transaction , int jlist ) ;

void jbd2_journal_file_buffer ( struct journal_head * jh , transaction_t * transaction , int jlist ) ;

void __jbd2_journal_refile_buffer ( struct journal_head * jh ) ;

void jbd2_journal_refile_buffer ( journal_t * journal , struct journal_head * jh ) ;

int jbd2_journal_file_inode ( handle_t * handle , struct jbd2_inode * jinode ) ;

int jbd2_journal_begin_ordered_truncate ( journal_t * journal , struct jbd2_inode * jinode , loff_t new_size ) ;

struct transaction_chp_stats_s ;
struct transaction_run_stats_s ;
void jbd2_journal_commit_transaction ( journal_t * journal ) ;

int jbd2_journal_recover ( journal_t * journal ) ;

int jbd2_journal_skip_recovery ( journal_t * journal ) ;

void __jbd2_log_wait_for_space ( journal_t * journal ) ;

int jbd2_log_do_checkpoint ( journal_t * journal ) ;

int jbd2_cleanup_journal_tail ( journal_t * journal ) ;

int __jbd2_journal_clean_checkpoint_list ( journal_t * journal ) ;

int __jbd2_journal_remove_checkpoint ( struct journal_head * jh ) ;

void __jbd2_journal_insert_checkpoint ( struct journal_head * jh , transaction_t * transaction ) ;

void __jbd2_journal_drop_transaction ( journal_t * journal , transaction_t * transaction ) ;

struct jbd2_revoke_record_s { struct list_head hash ; tid_t sequence ; unsigned long long blocknr ; } ;

struct jbd2_revoke_table_s { int hash_size ; int hash_shift ; struct list_head * hash_table ; } ;
void jbd2_journal_destroy_revoke_caches ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) jbd2_journal_init_revoke_caches ( void ) ;

int jbd2_journal_init_revoke ( journal_t * journal , int hash_size ) ;

void jbd2_journal_destroy_revoke ( journal_t * journal ) ;

int jbd2_journal_revoke ( handle_t * handle , unsigned long long blocknr , struct buffer_head * bh_in ) ;

int jbd2_journal_cancel_revoke ( handle_t * handle , struct journal_head * jh ) ;

void jbd2_journal_switch_revoke_table ( journal_t * journal ) ;

void jbd2_journal_write_revoke_records ( journal_t * journal , transaction_t * transaction , int write_op ) ;

int jbd2_journal_set_revoke ( journal_t * journal , unsigned long long blocknr , tid_t sequence ) ;

int jbd2_journal_test_revoke ( journal_t * journal , unsigned long long blocknr , tid_t sequence ) ;

void jbd2_journal_clear_revoke ( journal_t * journal ) ;

struct ftrace_raw_jbd2_checkpoint { struct trace_entry ent ; dev_t dev ; int result ; char __data [ 0 ] ; } ;

struct ftrace_raw_jbd2_start_commit { struct trace_entry ent ; dev_t dev ; char sync_commit ; int transaction ; char __data [ 0 ] ; } ;

struct ftrace_raw_jbd2_commit_locking { struct trace_entry ent ; dev_t dev ; char sync_commit ; int transaction ; char __data [ 0 ] ; } ;

struct ftrace_raw_jbd2_commit_flushing { struct trace_entry ent ; dev_t dev ; char sync_commit ; int transaction ; char __data [ 0 ] ; } ;

struct ftrace_raw_jbd2_commit_logging { struct trace_entry ent ; dev_t dev ; char sync_commit ; int transaction ; char __data [ 0 ] ; } ;

struct ftrace_raw_jbd2_end_commit { struct trace_entry ent ; dev_t dev ; char sync_commit ; int transaction ; int head ; char __data [ 0 ] ; } ;

struct ftrace_raw_jbd2_submit_inode_data { struct trace_entry ent ; dev_t dev ; ino_t ino ; char __data [ 0 ] ; } ;

struct ftrace_raw_jbd2_run_stats { struct trace_entry ent ; dev_t dev ; unsigned long tid ; unsigned long wait ; unsigned long running ; unsigned long locked ; unsigned long flushing ; unsigned long logging ; __u32 handle_count ; __u32 blocks ; __u32 blocks_logged ; char __data [ 0 ] ; } ;

struct ftrace_raw_jbd2_checkpoint_stats { struct trace_entry ent ; dev_t dev ; unsigned long tid ; unsigned long chp_time ; __u32 forced_to_close ; __u32 written ; __u32 dropped ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_jbd2_checkpoint { ; } ;

struct ftrace_data_offsets_jbd2_start_commit { ; } ;

struct ftrace_data_offsets_jbd2_commit_locking { ; } ;

struct ftrace_data_offsets_jbd2_commit_flushing { ; } ;

struct ftrace_data_offsets_jbd2_commit_logging { ; } ;

struct ftrace_data_offsets_jbd2_end_commit { ; } ;

struct ftrace_data_offsets_jbd2_submit_inode_data { ; } ;

struct ftrace_data_offsets_jbd2_run_stats { ; } ;

struct ftrace_data_offsets_jbd2_checkpoint_stats { ; } ;

int jbd2_journal_write_metadata_buffer ( transaction_t * transaction , struct journal_head * jh_in , struct journal_head * * jh_out , unsigned long long blocknr ) ;

int __jbd2_log_space_left ( journal_t * journal ) ;

int __jbd2_log_start_commit ( journal_t * journal , tid_t target ) ;

int jbd2_log_start_commit ( journal_t * journal , tid_t tid ) ;

int jbd2_journal_force_commit_nested ( journal_t * journal ) ;

int jbd2_journal_start_commit ( journal_t * journal , tid_t * ptid ) ;

int jbd2_log_wait_commit ( journal_t * journal , tid_t tid ) ;

int jbd2_journal_next_log_block ( journal_t * journal , unsigned long long * retp ) ;

int jbd2_journal_bmap ( journal_t * journal , unsigned long blocknr , unsigned long long * retp ) ;

struct journal_head * jbd2_journal_get_descriptor_buffer ( journal_t * journal ) ;

struct jbd2_stats_proc_session { journal_t * journal ; struct transaction_stats_s * stats ; int start ; int max ; } ;

journal_t * jbd2_journal_init_dev ( struct block_device * bdev , struct block_device * fs_dev , unsigned long long start , int len , int blocksize ) ;

journal_t * jbd2_journal_init_inode ( struct inode * inode ) ;

void jbd2_journal_update_superblock ( journal_t * journal , int wait ) ;

int jbd2_journal_load ( journal_t * journal ) ;

int jbd2_journal_destroy ( journal_t * journal ) ;

int jbd2_journal_check_used_features ( journal_t * journal , unsigned long compat , unsigned long ro , unsigned long incompat ) ;

int jbd2_journal_check_available_features ( journal_t * journal , unsigned long compat , unsigned long ro , unsigned long incompat ) ;

int jbd2_journal_set_features ( journal_t * journal , unsigned long compat , unsigned long ro , unsigned long incompat ) ;

void jbd2_journal_clear_features ( journal_t * journal , unsigned long compat , unsigned long ro , unsigned long incompat ) ;

int jbd2_journal_update_format ( journal_t * journal ) ;

int jbd2_journal_flush ( journal_t * journal ) ;

int jbd2_journal_wipe ( journal_t * journal , int write ) ;

void __jbd2_journal_abort_hard ( journal_t * journal ) ;

void jbd2_journal_abort ( journal_t * journal , int errno ) ;

int jbd2_journal_errno ( journal_t * journal ) ;

int jbd2_journal_clear_err ( journal_t * journal ) ;

void jbd2_journal_ack_err ( journal_t * journal ) ;

int jbd2_journal_blocks_per_page ( struct inode * inode ) ;

size_t journal_tag_bytes ( journal_t * journal ) ;

struct journal_head * jbd2_journal_add_journal_head ( struct buffer_head * bh ) ;

struct journal_head * jbd2_journal_grab_journal_head ( struct buffer_head * bh ) ;

void jbd2_journal_remove_journal_head ( struct buffer_head * bh ) ;

void jbd2_journal_put_journal_head ( struct journal_head * jh ) ;

void jbd2_journal_init_jbd_inode ( struct jbd2_inode * jinode , struct inode * inode ) ;

void jbd2_journal_release_jbd_inode ( journal_t * journal , struct jbd2_inode * jinode ) ;

struct devname_cache { struct rcu_head rcu ; dev_t device ; char devname [ 32 ] ; } ;

const char * jbd2_dev_to_name ( dev_t device ) ;

typedef struct { __u32 v32 ; } __attribute__ ( ( packed ) ) jint32_t ;

typedef struct { __u32 m ; } __attribute__ ( ( packed ) ) jmode_t ;

typedef struct { __u16 v16 ; } __attribute__ ( ( packed ) ) jint16_t ;

struct jffs2_unknown_node { jint16_t magic ; jint16_t nodetype ; jint32_t totlen ; jint32_t hdr_crc ; } ;

struct jffs2_raw_dirent { jint16_t magic ; jint16_t nodetype ; jint32_t totlen ; jint32_t hdr_crc ; jint32_t pino ; jint32_t version ; jint32_t ino ; jint32_t mctime ; __u8 nsize ; __u8 type ; __u8 unused [ 2 ] ; jint32_t node_crc ; jint32_t name_crc ; __u8 name [ 0 ] ; } ;

struct jffs2_raw_inode { jint16_t magic ; jint16_t nodetype ; jint32_t totlen ; jint32_t hdr_crc ; jint32_t ino ; jint32_t version ; jmode_t mode ; jint16_t uid ; jint16_t gid ; jint32_t isize ; jint32_t atime ; jint32_t mtime ; jint32_t ctime ; jint32_t offset ; jint32_t csize ; jint32_t dsize ; __u8 compr ; __u8 usercompr ; jint16_t flags ; jint32_t data_crc ; jint32_t node_crc ; __u8 data [ 0 ] ; } ;

struct jffs2_raw_xattr { jint16_t magic ; jint16_t nodetype ; jint32_t totlen ; jint32_t hdr_crc ; jint32_t xid ; jint32_t version ; __u8 xprefix ; __u8 name_len ; jint16_t value_len ; jint32_t data_crc ; jint32_t node_crc ; __u8 data [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct jffs2_raw_xref { jint16_t magic ; jint16_t nodetype ; jint32_t totlen ; jint32_t hdr_crc ; jint32_t ino ; jint32_t xid ; jint32_t xseqno ; jint32_t node_crc ; } __attribute__ ( ( packed ) ) ;
struct jffs2_raw_summary { jint16_t magic ; jint16_t nodetype ; jint32_t totlen ; jint32_t hdr_crc ; jint32_t sum_num ; jint32_t cln_mkr ; jint32_t padded ; jint32_t sum_crc ; jint32_t node_crc ; jint32_t sum [ 0 ] ; } ;

union jffs2_node_union { struct jffs2_raw_inode i ; struct jffs2_raw_dirent d ; struct jffs2_raw_xattr x ; struct jffs2_raw_xref r ; struct jffs2_raw_summary s ; struct jffs2_unknown_node u ; } ;

union jffs2_device_node { jint16_t old ; jint32_t new ; } ;

struct jffs2_inode_info { struct mutex sem ; uint32_t highest_version ; struct rb_root fragtree ; struct jffs2_full_dnode * metadata ; struct jffs2_full_dirent * dents ; unsigned char * target ; struct jffs2_inode_cache * inocache ; uint16_t flags ; uint8_t usercompr ; struct inode vfs_inode ; } ;

struct jffs2_inodirty ;

struct jffs2_sb_info { struct mtd_info * mtd ; uint32_t highest_ino ; uint32_t checked_ino ; unsigned int flags ; struct task_struct * gc_task ; struct completion gc_thread_start ; struct completion gc_thread_exit ; struct mutex alloc_sem ; uint32_t cleanmarker_size ; uint32_t flash_size ; uint32_t used_size ; uint32_t dirty_size ; uint32_t wasted_size ; uint32_t free_size ; uint32_t erasing_size ; uint32_t bad_size ; uint32_t sector_size ; uint32_t unchecked_size ; uint32_t nr_free_blocks ; uint32_t nr_erasing_blocks ; uint8_t resv_blocks_write ; uint8_t resv_blocks_deletion ; uint8_t resv_blocks_gctrigger ; uint8_t resv_blocks_gcbad ; uint8_t resv_blocks_gcmerge ; uint8_t vdirty_blocks_gctrigger ; uint32_t nospc_dirty_size ; uint32_t nr_blocks ; struct jffs2_eraseblock * blocks ; struct jffs2_eraseblock * nextblock ; struct jffs2_eraseblock * gcblock ; struct list_head clean_list ; struct list_head very_dirty_list ; struct list_head dirty_list ; struct list_head erasable_list ; struct list_head erasable_pending_wbuf_list ; struct list_head erasing_list ; struct list_head erase_checking_list ; struct list_head erase_pending_list ; struct list_head erase_complete_list ; struct list_head free_list ; struct list_head bad_list ; struct list_head bad_used_list ; spinlock_t erase_completion_lock ; wait_queue_head_t erase_wait ; wait_queue_head_t inocache_wq ; struct jffs2_inode_cache * * inocache_list ; spinlock_t inocache_lock ; struct mutex erase_free_sem ; uint32_t wbuf_pagesize ; unsigned char * wbuf ; uint32_t wbuf_ofs ; uint32_t wbuf_len ; struct jffs2_inodirty * wbuf_inodes ; struct rw_semaphore wbuf_sem ; unsigned char * oobbuf ; int oobavail ; struct jffs2_summary * summary ; void * os_priv ; } ;

struct jffs2_xattr_datum { void * always_null ; struct jffs2_raw_node_ref * node ; uint8_t class ; uint8_t flags ; uint16_t xprefix ; struct list_head xindex ; atomic_t refcnt ; uint32_t xid ; uint32_t version ; uint32_t data_crc ; uint32_t hashkey ; char * xname ; uint32_t name_len ; char * xvalue ; uint32_t value_len ; } ;

struct jffs2_inode_cache ;

struct jffs2_xattr_ref { void * always_null ; struct jffs2_raw_node_ref * node ; uint8_t class ; uint8_t flags ; u16 unused ; uint32_t xseqno ; union { struct jffs2_inode_cache * ic ; uint32_t ino ; } ; union { struct jffs2_xattr_datum * xd ; uint32_t xid ; } ; struct jffs2_xattr_ref * next ; } ;

struct jffs2_acl_entry { jint16_t e_tag ; jint16_t e_perm ; jint32_t e_id ; } ;

struct jffs2_acl_entry_short { jint16_t e_tag ; jint16_t e_perm ; } ;

struct jffs2_acl_header { jint32_t a_version ; } ;

struct jffs2_sum_unknown_flash { jint16_t nodetype ; } ;

struct jffs2_sum_inode_flash { jint16_t nodetype ; jint32_t inode ; jint32_t version ; jint32_t offset ; jint32_t totlen ; } __attribute__ ( ( packed ) ) ;
struct jffs2_sum_dirent_flash { jint16_t nodetype ; jint32_t totlen ; jint32_t offset ; jint32_t pino ; jint32_t version ; jint32_t ino ; uint8_t nsize ; uint8_t type ; uint8_t name [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct jffs2_sum_xattr_flash { jint16_t nodetype ; jint32_t xid ; jint32_t version ; jint32_t offset ; jint32_t totlen ; } __attribute__ ( ( packed ) ) ;
struct jffs2_sum_xref_flash { jint16_t nodetype ; jint32_t offset ; } __attribute__ ( ( packed ) ) ;
union jffs2_sum_flash { struct jffs2_sum_unknown_flash u ; struct jffs2_sum_inode_flash i ; struct jffs2_sum_dirent_flash d ; struct jffs2_sum_xattr_flash x ; struct jffs2_sum_xref_flash r ; } ;

struct jffs2_sum_unknown_mem { union jffs2_sum_mem * next ; jint16_t nodetype ; } ;

struct jffs2_sum_inode_mem { union jffs2_sum_mem * next ; jint16_t nodetype ; jint32_t inode ; jint32_t version ; jint32_t offset ; jint32_t totlen ; } __attribute__ ( ( packed ) ) ;
struct jffs2_sum_dirent_mem { union jffs2_sum_mem * next ; jint16_t nodetype ; jint32_t totlen ; jint32_t offset ; jint32_t pino ; jint32_t version ; jint32_t ino ; uint8_t nsize ; uint8_t type ; uint8_t name [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct jffs2_sum_xattr_mem { union jffs2_sum_mem * next ; jint16_t nodetype ; jint32_t xid ; jint32_t version ; jint32_t offset ; jint32_t totlen ; } __attribute__ ( ( packed ) ) ;
struct jffs2_sum_xref_mem { union jffs2_sum_mem * next ; jint16_t nodetype ; jint32_t offset ; } __attribute__ ( ( packed ) ) ;
union jffs2_sum_mem { struct jffs2_sum_unknown_mem u ; struct jffs2_sum_inode_mem i ; struct jffs2_sum_dirent_mem d ; struct jffs2_sum_xattr_mem x ; struct jffs2_sum_xref_mem r ; } ;

struct jffs2_summary { uint32_t sum_size ; uint32_t sum_num ; uint32_t sum_padded ; union jffs2_sum_mem * sum_list_head ; union jffs2_sum_mem * sum_list_tail ; jint32_t * sum_buf ; } ;

struct jffs2_sum_marker { jint32_t offset ; jint32_t magic ; } ;

struct jffs2_raw_node_ref { struct jffs2_raw_node_ref * next_in_ino ; uint32_t flash_offset ; } ;

struct jffs2_inode_cache { struct jffs2_full_dirent * scan_dents ; struct jffs2_raw_node_ref * nodes ; uint8_t class ; uint8_t flags ; uint16_t state ; uint32_t ino ; struct jffs2_inode_cache * next ; uint32_t pino_nlink ; } ;
struct jffs2_full_dnode { struct jffs2_raw_node_ref * raw ; uint32_t ofs ; uint32_t size ; uint32_t frags ; } ;

struct jffs2_tmp_dnode_info { struct rb_node rb ; struct jffs2_full_dnode * fn ; uint32_t version ; uint32_t data_crc ; uint32_t partial_crc ; uint16_t csize ; uint16_t overlapped ; } ;

struct jffs2_readinode_info { struct rb_root tn_root ; struct jffs2_tmp_dnode_info * mdata_tn ; uint32_t highest_version ; uint32_t latest_mctime ; uint32_t mctime_ver ; struct jffs2_full_dirent * fds ; struct jffs2_raw_node_ref * latest_ref ; } ;

struct jffs2_full_dirent { struct jffs2_raw_node_ref * raw ; struct jffs2_full_dirent * next ; uint32_t version ; uint32_t ino ; unsigned int nhash ; unsigned char type ; unsigned char name [ 0 ] ; } ;

struct jffs2_node_frag { struct rb_node rb ; struct jffs2_full_dnode * node ; uint32_t size ; uint32_t ofs ; } ;

struct jffs2_eraseblock { struct list_head list ; int bad_count ; uint32_t offset ; uint32_t unchecked_size ; uint32_t used_size ; uint32_t dirty_size ; uint32_t wasted_size ; uint32_t free_size ; uint32_t allocated_refs ; struct jffs2_raw_node_ref * first_node ; struct jffs2_raw_node_ref * last_node ; struct jffs2_raw_node_ref * gc_node ; } ;

struct jffs2_compressor { struct list_head list ; int priority ; char * name ; char compr ; int ( * compress ) ( unsigned char * data_in , unsigned char * cpage_out , uint32_t * srclen , uint32_t * destlen , void * model ) ; int ( * decompress ) ( unsigned char * cdata_in , unsigned char * data_out , uint32_t cdatalen , uint32_t datalen , void * model ) ; int usecount ; int disabled ; unsigned char * compr_buf ; uint32_t compr_buf_size ; uint32_t stat_compr_orig_size ; uint32_t stat_compr_new_size ; uint32_t stat_compr_blocks ; uint32_t stat_decompr_blocks ; } ;

uint16_t jffs2_compress ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , unsigned char * data_in , unsigned char * * cpage_out , uint32_t * datalen , uint32_t * cdatalen ) ;

int jffs2_decompress ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , uint16_t comprtype , unsigned char * cdata_in , unsigned char * data_out , uint32_t cdatalen , uint32_t datalen ) ;

int jffs2_register_compressor ( struct jffs2_compressor * comp ) ;

int jffs2_unregister_compressor ( struct jffs2_compressor * comp ) ;

void jffs2_free_comprbuf ( unsigned char * comprbuf , unsigned char * orig ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) jffs2_compressors_init ( void ) ;

int jffs2_compressors_exit ( void ) ;

int jffs2_fsync ( struct file * filp , struct dentry * dentry , int datasync ) ;

int jffs2_do_readpage_unlock ( struct inode * inode , struct page * pg ) ;

long jffs2_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

struct erase_info_user { __u32 start ; __u32 length ; } ;

struct erase_info_user64 { __u64 start ; __u64 length ; } ;

struct mtd_oob_buf { __u32 start ; __u32 length ; unsigned char * ptr ; } ;

struct mtd_oob_buf64 { __u64 start ; __u32 pad ; __u32 length ; __u64 usr_ptr ; } ;

struct mtd_info_user { __u8 type ; __u32 flags ; __u32 size ; __u32 erasesize ; __u32 writesize ; __u32 oobsize ; __u32 ecctype ; __u32 eccsize ; } ;

struct region_info_user { __u32 offset ; __u32 erasesize ; __u32 numblocks ; __u32 regionindex ; } ;

struct otp_info { __u32 start ; __u32 length ; __u32 locked ; } ;

struct nand_oobinfo { __u32 useecc ; __u32 eccbytes ; __u32 oobfree [ 8 ] [ 2 ] ; __u32 eccpos [ 32 ] ; } ;

struct nand_oobfree { __u32 offset ; __u32 length ; } ;

struct nand_ecclayout { __u32 eccbytes ; __u32 eccpos [ 64 ] ; __u32 oobavail ; struct nand_oobfree oobfree [ 8 ] ; } ;

struct mtd_ecc_stats { __u32 corrected ; __u32 failed ; __u32 badblocks ; __u32 bbtblocks ; } ;

enum mtd_file_modes { MTD_MODE_NORMAL = 0 , MTD_MODE_OTP_FACTORY = 1 , MTD_MODE_OTP_USER = 2 , MTD_MODE_RAW , } ;

struct erase_info { struct mtd_info * mtd ; uint64_t addr ; uint64_t len ; uint64_t fail_addr ; u_long time ; u_long retries ; unsigned dev ; unsigned cell ; void ( * callback ) ( struct erase_info * self ) ; u_long priv ; u_char state ; struct erase_info * next ; } ;

struct mtd_erase_region_info { uint64_t offset ; uint32_t erasesize ; uint32_t numblocks ; unsigned long * lockmap ; } ;

typedef enum { MTD_OOB_PLACE , MTD_OOB_AUTO , MTD_OOB_RAW , } mtd_oob_mode_t ;

struct mtd_oob_ops { mtd_oob_mode_t mode ; size_t len ; size_t retlen ; size_t ooblen ; size_t oobretlen ; uint32_t ooboffs ; uint8_t * datbuf ; uint8_t * oobbuf ; } ;

struct mtd_info { u_char type ; uint32_t flags ; uint64_t size ; uint32_t erasesize ; uint32_t writesize ; uint32_t oobsize ; uint32_t oobavail ; unsigned int erasesize_shift ; unsigned int writesize_shift ; unsigned int erasesize_mask ; unsigned int writesize_mask ; const char * name ; int index ; struct nand_ecclayout * ecclayout ; int numeraseregions ; struct mtd_erase_region_info * eraseregions ; int ( * erase ) ( struct mtd_info * mtd , struct erase_info * instr ) ; int ( * point ) ( struct mtd_info * mtd , loff_t from , size_t len , size_t * retlen , void * * virt , resource_size_t * phys ) ; void ( * unpoint ) ( struct mtd_info * mtd , loff_t from , size_t len ) ; unsigned long ( * get_unmapped_area ) ( struct mtd_info * mtd , unsigned long len , unsigned long offset , unsigned long flags ) ; struct backing_dev_info * backing_dev_info ; int ( * read ) ( struct mtd_info * mtd , loff_t from , size_t len , size_t * retlen , u_char * buf ) ; int ( * write ) ( struct mtd_info * mtd , loff_t to , size_t len , size_t * retlen , const u_char * buf ) ; int ( * panic_write ) ( struct mtd_info * mtd , loff_t to , size_t len , size_t * retlen , const u_char * buf ) ; int ( * read_oob ) ( struct mtd_info * mtd , loff_t from , struct mtd_oob_ops * ops ) ; int ( * write_oob ) ( struct mtd_info * mtd , loff_t to , struct mtd_oob_ops * ops ) ; int ( * get_fact_prot_info ) ( struct mtd_info * mtd , struct otp_info * buf , size_t len ) ; int ( * read_fact_prot_reg ) ( struct mtd_info * mtd , loff_t from , size_t len , size_t * retlen , u_char * buf ) ; int ( * get_user_prot_info ) ( struct mtd_info * mtd , struct otp_info * buf , size_t len ) ; int ( * read_user_prot_reg ) ( struct mtd_info * mtd , loff_t from , size_t len , size_t * retlen , u_char * buf ) ; int ( * write_user_prot_reg ) ( struct mtd_info * mtd , loff_t from , size_t len , size_t * retlen , u_char * buf ) ; int ( * lock_user_prot_reg ) ( struct mtd_info * mtd , loff_t from , size_t len ) ; int ( * writev ) ( struct mtd_info * mtd , const struct kvec * vecs , unsigned long count , loff_t to , size_t * retlen ) ; void ( * sync ) ( struct mtd_info * mtd ) ; int ( * lock ) ( struct mtd_info * mtd , loff_t ofs , uint64_t len ) ; int ( * unlock ) ( struct mtd_info * mtd , loff_t ofs , uint64_t len ) ; int ( * suspend ) ( struct mtd_info * mtd ) ; void ( * resume ) ( struct mtd_info * mtd ) ; int ( * block_isbad ) ( struct mtd_info * mtd , loff_t ofs ) ; int ( * block_markbad ) ( struct mtd_info * mtd , loff_t ofs ) ; struct notifier_block reboot_notifier ; struct mtd_ecc_stats ecc_stats ; int subpage_sft ; void * priv ; struct module * owner ; struct device dev ; int usecount ; int ( * get_device ) ( struct mtd_info * mtd ) ; void ( * put_device ) ( struct mtd_info * mtd ) ; } ;

struct mtd_notifier { void ( * add ) ( struct mtd_info * mtd ) ; void ( * remove ) ( struct mtd_info * mtd ) ; struct list_head list ; } ;

void jffs2_add_fd_to_list ( struct jffs2_sb_info * c , struct jffs2_full_dirent * new , struct jffs2_full_dirent * * list ) ;

uint32_t jffs2_truncate_fragtree ( struct jffs2_sb_info * c , struct rb_root * list , uint32_t size ) ;

int jffs2_add_full_dnode_to_inode ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , struct jffs2_full_dnode * fn ) ;

void jffs2_set_inocache_state ( struct jffs2_sb_info * c , struct jffs2_inode_cache * ic , int state ) ;

struct jffs2_inode_cache * jffs2_get_ino_cache ( struct jffs2_sb_info * c , uint32_t ino ) ;

void jffs2_add_ino_cache ( struct jffs2_sb_info * c , struct jffs2_inode_cache * new ) ;

void jffs2_del_ino_cache ( struct jffs2_sb_info * c , struct jffs2_inode_cache * old ) ;

void jffs2_free_ino_caches ( struct jffs2_sb_info * c ) ;

void jffs2_free_raw_node_refs ( struct jffs2_sb_info * c ) ;

struct jffs2_node_frag * jffs2_lookup_node_frag ( struct rb_root * fragtree , uint32_t offset ) ;

void jffs2_kill_fragtree ( struct rb_root * root , struct jffs2_sb_info * c ) ;

struct jffs2_raw_node_ref * jffs2_link_node_ref ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb , uint32_t ofs , uint32_t len , struct jffs2_inode_cache * ic ) ;

int jffs2_scan_dirty_space ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb , uint32_t size ) ;

uint32_t __jffs2_ref_totlen ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb , struct jffs2_raw_node_ref * ref ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) jffs2_create_slab_caches ( void ) ;

void jffs2_destroy_slab_caches ( void ) ;

struct jffs2_full_dirent * jffs2_alloc_full_dirent ( int namesize ) ;

void jffs2_free_full_dirent ( struct jffs2_full_dirent * x ) ;

struct jffs2_full_dnode * jffs2_alloc_full_dnode ( void ) ;

void jffs2_free_full_dnode ( struct jffs2_full_dnode * x ) ;

struct jffs2_raw_dirent * jffs2_alloc_raw_dirent ( void ) ;

void jffs2_free_raw_dirent ( struct jffs2_raw_dirent * x ) ;

struct jffs2_raw_inode * jffs2_alloc_raw_inode ( void ) ;

void jffs2_free_raw_inode ( struct jffs2_raw_inode * x ) ;

struct jffs2_tmp_dnode_info * jffs2_alloc_tmp_dnode_info ( void ) ;

void jffs2_free_tmp_dnode_info ( struct jffs2_tmp_dnode_info * x ) ;

int jffs2_prealloc_raw_node_refs ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb , int nr ) ;

void jffs2_free_refblock ( struct jffs2_raw_node_ref * x ) ;

struct jffs2_node_frag * jffs2_alloc_node_frag ( void ) ;

void jffs2_free_node_frag ( struct jffs2_node_frag * x ) ;

struct jffs2_inode_cache * jffs2_alloc_inode_cache ( void ) ;

void jffs2_free_inode_cache ( struct jffs2_inode_cache * x ) ;

int jffs2_read_dnode ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , struct jffs2_full_dnode * fd , unsigned char * buf , int ofs , int len ) ;

int jffs2_read_inode_range ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , unsigned char * buf , uint32_t offset , uint32_t len ) ;

int jffs2_reserve_space ( struct jffs2_sb_info * c , uint32_t minsize , uint32_t * len , int prio , uint32_t sumsize ) ;

int jffs2_reserve_space_gc ( struct jffs2_sb_info * c , uint32_t minsize , uint32_t * len , uint32_t sumsize ) ;

struct jffs2_raw_node_ref * jffs2_add_physical_node_ref ( struct jffs2_sb_info * c , uint32_t ofs , uint32_t len , struct jffs2_inode_cache * ic ) ;

void jffs2_complete_reservation ( struct jffs2_sb_info * c ) ;

void jffs2_mark_node_obsolete ( struct jffs2_sb_info * c , struct jffs2_raw_node_ref * ref ) ;

int jffs2_thread_should_wake ( struct jffs2_sb_info * c ) ;

int jffs2_do_read_inode ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , uint32_t ino , struct jffs2_raw_inode * latest_node ) ;

int jffs2_do_crccheck_inode ( struct jffs2_sb_info * c , struct jffs2_inode_cache * ic ) ;

void jffs2_do_clear_inode ( struct jffs2_sb_info * c , struct jffs2_inode_info * f ) ;

int jffs2_do_new_inode ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , uint32_t mode , struct jffs2_raw_inode * ri ) ;

struct jffs2_full_dnode * jffs2_write_dnode ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , struct jffs2_raw_inode * ri , const unsigned char * data , uint32_t datalen , int alloc_mode ) ;

struct jffs2_full_dirent * jffs2_write_dirent ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , struct jffs2_raw_dirent * rd , const unsigned char * name , uint32_t namelen , int alloc_mode ) ;

int jffs2_write_inode_range ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , struct jffs2_raw_inode * ri , unsigned char * buf , uint32_t offset , uint32_t writelen , uint32_t * retlen ) ;

int jffs2_do_create ( struct jffs2_sb_info * c , struct jffs2_inode_info * dir_f , struct jffs2_inode_info * f , struct jffs2_raw_inode * ri , const char * name , int namelen ) ;

int jffs2_do_unlink ( struct jffs2_sb_info * c , struct jffs2_inode_info * dir_f , const char * name , int namelen , struct jffs2_inode_info * dead_f , uint32_t time ) ;

int jffs2_do_link ( struct jffs2_sb_info * c , struct jffs2_inode_info * dir_f , uint32_t ino , uint8_t type , const char * name , int namelen , uint32_t time ) ;

int jffs2_scan_medium ( struct jffs2_sb_info * c ) ;

int jffs2_scan_classify_jeb ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb ) ;

struct jffs2_inode_cache * jffs2_scan_make_ino_cache ( struct jffs2_sb_info * c , uint32_t ino ) ;

void jffs2_rotate_lists ( struct jffs2_sb_info * c ) ;

int jffs2_garbage_collect_pass ( struct jffs2_sb_info * c ) ;

int jffs2_do_mount_fs ( struct jffs2_sb_info * c ) ;

struct erase_priv_struct { struct jffs2_eraseblock * jeb ; struct jffs2_sb_info * c ; } ;

void jffs2_erase_pending_blocks ( struct jffs2_sb_info * c , int count ) ;

void jffs2_free_jeb_node_refs ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb ) ;

void jffs2_garbage_collect_trigger ( struct jffs2_sb_info * c ) ;

int jffs2_start_garbage_collect_thread ( struct jffs2_sb_info * c ) ;

void jffs2_stop_garbage_collect_thread ( struct jffs2_sb_info * c ) ;

int jffs2_do_setattr ( struct inode * inode , struct iattr * iattr ) ;

int jffs2_setattr ( struct dentry * dentry , struct iattr * iattr ) ;

int jffs2_statfs ( struct dentry * dentry , struct kstatfs * buf ) ;

void jffs2_clear_inode ( struct inode * inode ) ;

struct inode * jffs2_iget ( struct super_block * sb , unsigned long ino ) ;

void jffs2_dirty_inode ( struct inode * inode ) ;

int jffs2_remount_fs ( struct super_block * sb , int * flags , char * data ) ;

struct inode * jffs2_new_inode ( struct inode * dir_i , int mode , struct jffs2_raw_inode * ri ) ;

int jffs2_do_fill_super ( struct super_block * sb , void * data , int silent ) ;

void jffs2_gc_release_inode ( struct jffs2_sb_info * c , struct jffs2_inode_info * f ) ;

struct jffs2_inode_info * jffs2_gc_fetch_inode ( struct jffs2_sb_info * c , int inum , int unlinked ) ;

unsigned char * jffs2_gc_fetch_page ( struct jffs2_sb_info * c , struct jffs2_inode_info * f , unsigned long offset , unsigned long * priv ) ;

void jffs2_gc_release_page ( struct jffs2_sb_info * c , unsigned char * ptr , unsigned long * priv ) ;

void jffs2_flash_cleanup ( struct jffs2_sb_info * c ) ;

int jffs2_flash_direct_writev ( struct jffs2_sb_info * c , const struct kvec * vecs , unsigned long count , loff_t to , size_t * retlen ) ;

int jffs2_flash_direct_write ( struct jffs2_sb_info * c , loff_t ofs , size_t len , size_t * retlen , const u_char * buf ) ;

void __jffs2_dbg_acct_sanity_check_nolock ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb ) ;

void __jffs2_dbg_acct_sanity_check ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb ) ;

struct mtd_info ;
typedef enum { NAND_ECC_NONE , NAND_ECC_SOFT , NAND_ECC_HW , NAND_ECC_HW_SYNDROME , NAND_ECC_HW_OOB_FIRST , } nand_ecc_modes_t ;

typedef enum { FL_READY , FL_READING , FL_WRITING , FL_ERASING , FL_SYNCING , FL_CACHEDPRG , FL_PM_SUSPENDED , } nand_state_t ;

struct nand_chip ;

struct nand_hw_control { spinlock_t lock ; struct nand_chip * active ; wait_queue_head_t wq ; } ;

struct nand_ecc_ctrl { nand_ecc_modes_t mode ; int steps ; int size ; int bytes ; int total ; int prepad ; int postpad ; struct nand_ecclayout * layout ; void ( * hwctl ) ( struct mtd_info * mtd , int mode ) ; int ( * calculate ) ( struct mtd_info * mtd , const uint8_t * dat , uint8_t * ecc_code ) ; int ( * correct ) ( struct mtd_info * mtd , uint8_t * dat , uint8_t * read_ecc , uint8_t * calc_ecc ) ; int ( * read_page_raw ) ( struct mtd_info * mtd , struct nand_chip * chip , uint8_t * buf , int page ) ; void ( * write_page_raw ) ( struct mtd_info * mtd , struct nand_chip * chip , const uint8_t * buf ) ; int ( * read_page ) ( struct mtd_info * mtd , struct nand_chip * chip , uint8_t * buf , int page ) ; int ( * read_subpage ) ( struct mtd_info * mtd , struct nand_chip * chip , uint32_t offs , uint32_t len , uint8_t * buf ) ; void ( * write_page ) ( struct mtd_info * mtd , struct nand_chip * chip , const uint8_t * buf ) ; int ( * read_oob ) ( struct mtd_info * mtd , struct nand_chip * chip , int page , int sndcmd ) ; int ( * write_oob ) ( struct mtd_info * mtd , struct nand_chip * chip , int page ) ; } ;

struct nand_buffers { uint8_t ecccalc [ 128 ] ; uint8_t ecccode [ 128 ] ; uint8_t databuf [ 4096 + 128 ] ; } ;

struct nand_chip { void * IO_ADDR_R ; void * IO_ADDR_W ; uint8_t ( * read_byte ) ( struct mtd_info * mtd ) ; u16 ( * read_word ) ( struct mtd_info * mtd ) ; void ( * write_buf ) ( struct mtd_info * mtd , const uint8_t * buf , int len ) ; void ( * read_buf ) ( struct mtd_info * mtd , uint8_t * buf , int len ) ; int ( * verify_buf ) ( struct mtd_info * mtd , const uint8_t * buf , int len ) ; void ( * select_chip ) ( struct mtd_info * mtd , int chip ) ; int ( * block_bad ) ( struct mtd_info * mtd , loff_t ofs , int getchip ) ; int ( * block_markbad ) ( struct mtd_info * mtd , loff_t ofs ) ; void ( * cmd_ctrl ) ( struct mtd_info * mtd , int dat , unsigned int ctrl ) ; int ( * dev_ready ) ( struct mtd_info * mtd ) ; void ( * cmdfunc ) ( struct mtd_info * mtd , unsigned command , int column , int page_addr ) ; int ( * waitfunc ) ( struct mtd_info * mtd , struct nand_chip * this ) ; void ( * erase_cmd ) ( struct mtd_info * mtd , int page ) ; int ( * scan_bbt ) ( struct mtd_info * mtd ) ; int ( * errstat ) ( struct mtd_info * mtd , struct nand_chip * this , int state , int status , int page ) ; int ( * write_page ) ( struct mtd_info * mtd , struct nand_chip * chip , const uint8_t * buf , int page , int cached , int raw ) ; int chip_delay ; unsigned int options ; int page_shift ; int phys_erase_shift ; int bbt_erase_shift ; int chip_shift ; int numchips ; uint64_t chipsize ; int pagemask ; int pagebuf ; int subpagesize ; uint8_t cellinfo ; int badblockpos ; nand_state_t state ; uint8_t * oob_poi ; struct nand_hw_control * controller ; struct nand_ecclayout * ecclayout ; struct nand_ecc_ctrl ecc ; struct nand_buffers * buffers ; struct nand_hw_control hwcontrol ; struct mtd_oob_ops ops ; uint8_t * bbt ; struct nand_bbt_descr * bbt_td ; struct nand_bbt_descr * bbt_md ; struct nand_bbt_descr * badblock_pattern ; void * priv ; } ;
struct nand_flash_dev { char * name ; int id ; unsigned long pagesize ; unsigned long chipsize ; unsigned long erasesize ; unsigned long options ; } ;

struct nand_manufacturers { int id ; char * name ; } ;

struct nand_bbt_descr { int options ; int pages [ 8 ] ; int offs ; int veroffs ; uint8_t version [ 8 ] ; int len ; int maxblocks ; int reserved_block_code ; uint8_t * pattern ; } ;

struct platform_nand_chip { int nr_chips ; int chip_offset ; int nr_partitions ; struct mtd_partition * partitions ; struct nand_ecclayout * ecclayout ; int chip_delay ; unsigned int options ; const char * * part_probe_types ; void ( * set_parts ) ( uint64_t size , struct platform_nand_chip * chip ) ; void * priv ; } ;

struct platform_device ;
struct platform_nand_ctrl { int ( * probe ) ( struct platform_device * pdev ) ; void ( * remove ) ( struct platform_device * pdev ) ; void ( * hwcontrol ) ( struct mtd_info * mtd , int cmd ) ; int ( * dev_ready ) ( struct mtd_info * mtd ) ; void ( * select_chip ) ( struct mtd_info * mtd , int chip ) ; void ( * cmd_ctrl ) ( struct mtd_info * mtd , int dat , unsigned int ctrl ) ; void ( * write_buf ) ( struct mtd_info * mtd , const uint8_t * buf , int len ) ; void ( * read_buf ) ( struct mtd_info * mtd , uint8_t * buf , int len ) ; void * priv ; } ;

struct platform_nand_data { struct platform_nand_chip chip ; struct platform_nand_ctrl ctrl ; } ;

struct jffs2_inodirty { uint32_t ino ; struct jffs2_inodirty * next ; } ;
int jffs2_flush_wbuf_gc ( struct jffs2_sb_info * c , uint32_t ino ) ;

int jffs2_flush_wbuf_pad ( struct jffs2_sb_info * c ) ;

int jffs2_flash_writev ( struct jffs2_sb_info * c , const struct kvec * invecs , unsigned long count , loff_t to , size_t * retlen , uint32_t ino ) ;

int jffs2_flash_write ( struct jffs2_sb_info * c , loff_t ofs , size_t len , size_t * retlen , const u_char * buf ) ;

int jffs2_flash_read ( struct jffs2_sb_info * c , loff_t ofs , size_t len , size_t * retlen , u_char * buf ) ;

int jffs2_check_oob_empty ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb , int mode ) ;

int jffs2_check_nand_cleanmarker ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb ) ;

int jffs2_write_nand_cleanmarker ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb ) ;

int jffs2_write_nand_badblock ( struct jffs2_sb_info * c , struct jffs2_eraseblock * jeb , uint32_t bad_offset ) ;

int jffs2_nand_flash_setup ( struct jffs2_sb_info * c ) ;

void jffs2_nand_flash_cleanup ( struct jffs2_sb_info * c ) ;

int jffs2_dataflash_setup ( struct jffs2_sb_info * c ) ;

void jffs2_dataflash_cleanup ( struct jffs2_sb_info * c ) ;

int jffs2_nor_wbuf_flash_setup ( struct jffs2_sb_info * c ) ;

void jffs2_nor_wbuf_flash_cleanup ( struct jffs2_sb_info * c ) ;

int jffs2_ubivol_setup ( struct jffs2_sb_info * c ) ;

void jffs2_ubivol_cleanup ( struct jffs2_sb_info * c ) ;

int jffs2_rtime_init ( void ) ;

void jffs2_rtime_exit ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) jffs2_zlib_init ( void ) ;

void jffs2_zlib_exit ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) jffs2_lzo_init ( void ) ;

void jffs2_lzo_exit ( void ) ;

typedef u16 tid_t ;
typedef u16 lid_t ;

struct timestruc_t { __le32 tv_sec ; __le32 tv_nsec ; } ;

typedef struct { unsigned len : 24 ; unsigned addr1 : 8 ; __le32 addr2 ; } pxd_t ;

struct pxdlist { s16 maxnpxd ; s16 npxd ; pxd_t pxd [ 8 ] ; } ;

typedef struct { unsigned flag : 8 ; unsigned rsrvd : 24 ; __le32 size ; unsigned len : 24 ; unsigned addr1 : 8 ; __le32 addr2 ; } dxd_t ;

struct component_name { int namlen ; wchar_t * name ; } ;

struct dasd { u8 thresh ; u8 delta ; u8 rsrvd1 ; u8 limit_hi ; __le32 limit_lo ; u8 rsrvd2 [ 3 ] ; u8 used_hi ; __le32 used_lo ; } ;

struct btframe { s64 bn ; s16 index ; s16 lastindex ; struct metapage * mp ; } ;

struct btstack { struct btframe * top ; int nsplit ; struct btframe stack [ 8 ] ; } ;


typedef struct xad { unsigned flag : 8 ; unsigned rsvrd : 16 ; unsigned off1 : 8 ; __le32 off2 ; unsigned len : 24 ; unsigned addr1 : 8 ; __le32 addr2 ; } xad_t ;

struct xadlist { s16 maxnxad ; s16 nxad ; xad_t * xad ; } ;

typedef union { struct xtheader { __le64 next ; __le64 prev ; u8 flag ; u8 rsrvd1 ; __le16 nextindex ; __le16 maxentry ; __le16 rsrvd2 ; pxd_t self ; } header ; xad_t xad [ 18 ] ; } xtpage_t ;

typedef union { struct { tid_t tid ; struct inode * ip ; u32 ino ; } leaf ; pxd_t xd ; } ddata_t ;

struct dtslot { s8 next ; s8 cnt ; __le16 name [ 15 ] ; } ;

struct idtentry { pxd_t xd ; s8 next ; u8 namlen ; __le16 name [ 11 ] ; } ;

struct ldtentry { __le32 inumber ; s8 next ; u8 namlen ; __le16 name [ 11 ] ; __le32 index ; } ;

struct dir_table_slot { u8 rsrvd ; u8 flag ; u8 slot ; u8 addr1 ; __le32 addr2 ; } ;

typedef union { struct { struct dasd DASD ; u8 flag ; u8 nextindex ; s8 freecnt ; s8 freelist ; __le32 idotdot ; s8 stbl [ 8 ] ; } header ; struct dtslot slot [ 9 ] ; } dtroot_t ;

typedef union { struct { __le64 next ; __le64 prev ; u8 flag ; u8 nextindex ; s8 freecnt ; s8 freelist ; u8 maxslot ; u8 stblindex ; u8 rsrvd [ 2 ] ; pxd_t self ; } header ; struct dtslot slot [ 128 ] ; } dtpage_t ;

struct jfs_inode_info { int fileset ; uint mode2 ; uint saved_uid ; uint saved_gid ; pxd_t ixpxd ; dxd_t acl ; dxd_t ea ; time_t otime ; uint next_index ; int acltype ; short btorder ; short btindex ; struct inode * ipimap ; unsigned long cflag ; u16 bxflag ; unchar agno ; signed char active_ag ; lid_t blid ; lid_t atlhead ; lid_t atltail ; spinlock_t ag_lock ; struct list_head anon_inode_list ; struct rw_semaphore rdwrlock ; struct mutex commit_mutex ; struct rw_semaphore xattr_sem ; lid_t xtlid ; union { struct { xtpage_t _xtroot ; struct inomap * _imap ; } file ; struct { struct dir_table_slot _table [ 12 ] ; dtroot_t _dtroot ; } dir ; struct { unchar _unused [ 16 ] ; dxd_t _dxd ; unchar _inline [ 128 ] ; unchar _inline_ea [ 128 ] ; } link ; } u ; u32 dev ; struct inode vfs_inode ; } ;

enum cflags { COMMIT_Nolink , COMMIT_Inlineea , COMMIT_Freewmap , COMMIT_Dirty , COMMIT_Dirtable , COMMIT_Stale , COMMIT_Synclist , } ;

enum commit_mutex_class { COMMIT_MUTEX_PARENT , COMMIT_MUTEX_CHILD , COMMIT_MUTEX_SECOND_PARENT , COMMIT_MUTEX_VICTIM } ;

enum rdwrlock_class { RDWRLOCK_NORMAL , RDWRLOCK_IMAP , RDWRLOCK_DMAP } ;

struct jfs_sb_info { struct super_block * sb ; unsigned long mntflag ; struct inode * ipbmap ; struct inode * ipaimap ; struct inode * ipaimap2 ; struct inode * ipimap ; struct jfs_log * log ; struct list_head log_list ; short bsize ; short l2bsize ; short nbperpage ; short l2nbperpage ; short l2niperblk ; dev_t logdev ; uint aggregate ; pxd_t logpxd ; pxd_t fsckpxd ; pxd_t ait2 ; char uuid [ 16 ] ; char loguuid [ 16 ] ; int commit_state ; uint gengen ; uint inostamp ; struct bmap * bmap ; struct nls_table * nls_tab ; struct inode * direct_inode ; uint state ; unsigned long flag ; uint p_state ; uint uid ; uint gid ; uint umask ; } ;

struct fid ;
struct metapage { u16 xflag ; u16 unused ; lid_t lid ; int lsn ; struct list_head synclist ; unsigned long flag ; unsigned long count ; void * data ; sector_t index ; wait_queue_head_t wait ; struct page * page ; unsigned int logical_size ; int clsn ; int nohomeok ; struct jfs_log * log ; } ;

struct jfs_superblock { char s_magic [ 4 ] ; __le32 s_version ; __le64 s_size ; __le32 s_bsize ; __le16 s_l2bsize ; __le16 s_l2bfactor ; __le32 s_pbsize ; __le16 s_l2pbsize ; __le16 pad ; __le32 s_agsize ; __le32 s_flag ; __le32 s_state ; __le32 s_compress ; pxd_t s_ait2 ; pxd_t s_aim2 ; __le32 s_logdev ; __le32 s_logserial ; pxd_t s_logpxd ; pxd_t s_fsckpxd ; struct timestruc_t s_time ; __le32 s_fsckloglen ; s8 s_fscklog ; char s_fpack [ 11 ] ; __le64 s_xsize ; pxd_t s_xfsckpxd ; pxd_t s_xlogpxd ; char s_uuid [ 16 ] ; char s_label [ 16 ] ; char s_loguuid [ 16 ] ; } ;

struct logsuper { __le32 magic ; __le32 version ; __le32 serial ; __le32 size ; __le32 bsize ; __le32 l2bsize ; __le32 flag ; __le32 state ; __le32 end ; char uuid [ 16 ] ; char label [ 16 ] ; struct { char uuid [ 16 ] ; } active [ 128 ] ; } ;

struct logpage { struct { __le32 page ; __le16 rsrvd ; __le16 eor ; } h ; __le32 data [ 4096 / 4 - 4 ] ; struct { __le32 page ; __le16 rsrvd ; __le16 eor ; } t ; } ;

struct lrd { __le32 logtid ; __le32 backchain ; __le16 type ; __le16 length ; __le32 aggregate ; union { struct { __le32 fileset ; __le32 inode ; __le16 type ; __le16 l2linesize ; pxd_t pxd ; } redopage ; struct { __le32 fileset ; __le32 inode ; __le16 type ; __le16 rsrvd ; pxd_t pxd ; } noredopage ; struct { __le32 fileset ; __le32 inode ; __le16 type ; __le16 nxd ; pxd_t pxd ; } updatemap ; struct { __le32 fileset ; __le32 iagnum ; __le32 inoext_idx ; pxd_t pxd ; } noredoinoext ; struct { __le32 sync ; } syncpt ; struct { __le32 type ; __le32 nextent ; } freextent ; struct { __le32 fileset ; __le32 inode ; } noredofile ; struct { __le32 fileset ; __le32 inode ; __le32 type ; pxd_t pxd ; } newpage ; } log ; } ;

struct lvd { __le16 offset ; __le16 length ; } ;

struct jfs_log { struct list_head sb_list ; struct list_head journal_list ; struct block_device * bdev ; int serial ; s64 base ; int size ; int l2bsize ; unsigned long flag ; struct lbuf * lbuf_free ; wait_queue_head_t free_wait ; int logtid ; int page ; int eor ; struct lbuf * bp ; struct mutex loglock ; int nextsync ; int active ; wait_queue_head_t syncwait ; uint cflag ; struct list_head cqueue ; struct tblock * flush_tblk ; int gcrtc ; struct tblock * gclrt ; spinlock_t gclock ; int logsize ; int lsn ; int clsn ; int syncpt ; int sync ; struct list_head synclist ; spinlock_t synclock ; struct lbuf * wqueue ; int count ; char uuid [ 16 ] ; int no_integrity ; } ;

struct lbuf { struct jfs_log * l_log ; uint l_flag ; struct lbuf * l_wqnext ; struct lbuf * l_freelist ; int l_pn ; int l_eor ; int l_ceor ; s64 l_blkno ; caddr_t l_ldata ; struct page * l_page ; uint l_offset ; wait_queue_head_t l_ioevent ; } ;

struct logsyncblk { u16 xflag ; u16 flag ; lid_t lid ; s32 lsn ; struct list_head synclist ; } ;

struct tblock { u16 xflag ; u16 flag ; lid_t dummy ; s32 lsn ; struct list_head synclist ; struct super_block * sb ; lid_t next ; lid_t last ; wait_queue_head_t waitor ; u32 logtid ; struct list_head cqueue ; s32 clsn ; struct lbuf * bp ; s32 pn ; s32 eor ; wait_queue_head_t gcwait ; union { struct inode * ip ; pxd_t ixpxd ; } u ; u32 ino ; } ;

struct tlock { lid_t next ; tid_t tid ; u16 flag ; u16 type ; struct metapage * mp ; struct inode * ip ; s16 lock [ 24 ] ; } ;

struct lv { u8 offset ; u8 length ; } ;

struct linelock { lid_t next ; s8 maxcnt ; s8 index ; u16 flag ; u8 type ; u8 l2linesize ; struct lv lv [ 20 ] ; } ;

struct xtlock { lid_t next ; s8 maxcnt ; s8 index ; u16 flag ; u8 type ; u8 l2linesize ; struct lv header ; struct lv lwm ; struct lv hwm ; struct lv twm ; s32 pxdlock [ 8 ] ; } ;

struct maplock { lid_t next ; u8 maxcnt ; u8 index ; u16 flag ; u8 type ; u8 count ; pxd_t pxd ; } ;

struct xdlistlock { lid_t next ; u8 maxcnt ; u8 index ; u16 flag ; u8 type ; u8 count ; union { void * _xdlist ; s64 pad ; } union64 ; } ;

struct commit { tid_t tid ; int flag ; struct jfs_log * log ; struct super_block * sb ; int nip ; struct inode * * iplist ; struct lrd lrd ; } ;

struct dmaptree { __le32 nleafs ; __le32 l2nleafs ; __le32 leafidx ; __le32 height ; s8 budmin ; s8 stree [ ( 256 + 64 + 16 + 4 + 1 ) ] ; u8 pad [ 2 ] ; } ;

struct dmap { __le32 nblocks ; __le32 nfree ; __le64 start ; struct dmaptree tree ; u8 pad [ 1672 ] ; __le32 wmap [ 256 ] ; __le32 pmap [ 256 ] ; } ;

struct dmapctl { __le32 nleafs ; __le32 l2nleafs ; __le32 leafidx ; __le32 height ; s8 budmin ; s8 stree [ ( 1024 + 256 + 64 + 16 + 4 + 1 ) ] ; u8 pad [ 2714 ] ; } ;


typedef union dmtree { struct dmaptree t1 ; struct dmapctl t2 ; } dmtree_t ;

struct dbmap_disk { __le64 dn_mapsize ; __le64 dn_nfree ; __le32 dn_l2nbperpage ; __le32 dn_numag ; __le32 dn_maxlevel ; __le32 dn_maxag ; __le32 dn_agpref ; __le32 dn_aglevel ; __le32 dn_agheigth ; __le32 dn_agwidth ; __le32 dn_agstart ; __le32 dn_agl2size ; __le64 dn_agfree [ 128 ] ; __le64 dn_agsize ; s8 dn_maxfreebud ; u8 pad [ 3007 ] ; } ;

struct dbmap { s64 dn_mapsize ; s64 dn_nfree ; int dn_l2nbperpage ; int dn_numag ; int dn_maxlevel ; int dn_maxag ; int dn_agpref ; int dn_aglevel ; int dn_agheigth ; int dn_agwidth ; int dn_agstart ; int dn_agl2size ; s64 dn_agfree [ 128 ] ; s64 dn_agsize ; signed char dn_maxfreebud ; } ;

struct bmap { struct dbmap db_bmap ; struct inode * db_ipbmap ; struct mutex db_bmaplock ; atomic_t db_active [ 128 ] ; u32 * db_DBmap ; } ;
struct iag { __le64 agstart ; __le32 iagnum ; __le32 inofreefwd ; __le32 inofreeback ; __le32 extfreefwd ; __le32 extfreeback ; __le32 iagfree ; __le32 inosmap [ 4 ] ; __le32 extsmap [ 4 ] ; __le32 nfreeinos ; __le32 nfreeexts ; u8 pad [ 1976 ] ; __le32 wmap [ 128 ] ; __le32 pmap [ 128 ] ; pxd_t inoext [ 128 ] ; } ;

struct iagctl_disk { __le32 inofree ; __le32 extfree ; __le32 numinos ; __le32 numfree ; } ;

struct iagctl { int inofree ; int extfree ; int numinos ; int numfree ; } ;

struct dinomap_disk { __le32 in_freeiag ; __le32 in_nextiag ; __le32 in_numinos ; __le32 in_numfree ; __le32 in_nbperiext ; __le32 in_l2nbperiext ; __le32 in_diskblock ; __le32 in_maxag ; u8 pad [ 2016 ] ; struct iagctl_disk in_agctl [ 128 ] ; } ;

struct dinomap { int in_freeiag ; int in_nextiag ; int in_numinos ; int in_numfree ; int in_nbperiext ; int in_l2nbperiext ; int in_diskblock ; int in_maxag ; struct iagctl in_agctl [ 128 ] ; } ;

struct inomap { struct dinomap im_imap ; struct inode * im_ipimap ; struct mutex im_freelock ; struct mutex im_aglock [ 128 ] ; u32 * im_DBGdimap ; atomic_t im_numinos ; atomic_t im_numfree ; } ;

void jfs_error ( struct super_block * sb , const char * function , ... ) ;

enum { Opt_integrity , Opt_nointegrity , Opt_iocharset , Opt_resize , Opt_resize_nosize , Opt_errors , Opt_ignore , Opt_err , Opt_quota , Opt_usrquota , Opt_grpquota , Opt_uid , Opt_gid , Opt_umask } ;
struct jfs_ea { u8 flag ; u8 namelen ; __le16 valuelen ; char name [ 0 ] ; } ;

struct jfs_ea_list { __le32 size ; struct jfs_ea ea [ 0 ] ; } ;

int jfs_fsync ( struct file * file , struct dentry * dentry , int datasync ) ;

typedef struct { wchar_t start ; wchar_t end ; signed char * table ; } UNICASERANGE ;

struct inode * jfs_iget ( struct super_block * sb , unsigned long ino ) ;

int jfs_commit_inode ( struct inode * inode , int wait ) ;

int jfs_write_inode ( struct inode * inode , int wait ) ;

void jfs_delete_inode ( struct inode * inode ) ;

void jfs_dirty_inode ( struct inode * inode ) ;

int jfs_get_block ( struct inode * ip , sector_t lblock , struct buffer_head * bh_result , int create ) ;

void jfs_truncate_nolock ( struct inode * ip , loff_t length ) ;

void jfs_truncate ( struct inode * ip ) ;

struct dinode { __le32 di_inostamp ; __le32 di_fileset ; __le32 di_number ; __le32 di_gen ; pxd_t di_ixpxd ; __le64 di_size ; __le64 di_nblocks ; __le32 di_nlink ; __le32 di_uid ; __le32 di_gid ; __le32 di_mode ; struct timestruc_t di_atime ; struct timestruc_t di_ctime ; struct timestruc_t di_mtime ; struct timestruc_t di_otime ; dxd_t di_acl ; dxd_t di_ea ; __le32 di_next_index ; __le32 di_acltype ; union { struct { struct dir_table_slot _table [ 12 ] ; dtroot_t _dtroot ; } _dir ; struct { union { u8 _data [ 96 ] ; struct { void * _imap ; __le32 _gengen ; } _imap ; } _u1 ; union { xtpage_t _xtroot ; struct { u8 unused [ 16 ] ; dxd_t _dxd ; union { __le32 _rdev ; u8 _fastsymlink [ 128 ] ; } _u ; u8 _inlineea [ 128 ] ; } _special ; } _u2 ; } _file ; } u ; } ;

void jfs_free_zero_link ( struct inode * ip ) ;

struct dentry * jfs_fh_to_dentry ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type ) ;

struct dentry * jfs_fh_to_parent ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type ) ;

struct dentry * jfs_get_parent ( struct dentry * dentry ) ;

int jfs_mount ( struct super_block * sb ) ;

int jfs_mount_rw ( struct super_block * sb , int remount ) ;

int updateSuper ( struct super_block * sb , uint state ) ;

int readSuper ( struct super_block * sb , struct buffer_head * * bpp ) ;

int jfs_umount ( struct super_block * sb ) ;

int jfs_umount_rw ( struct super_block * sb ) ;

struct xtsplit { struct metapage * mp ; s16 index ; u8 flag ; s64 off ; s64 addr ; int len ; struct pxdlist * pxdlist ; } ;

int xtLookup ( struct inode * ip , s64 lstart , s64 llen , int * pflag , s64 * paddr , s32 * plen , int no_check ) ;

int xtInsert ( tid_t tid , struct inode * ip , int xflag , s64 xoff , s32 xlen , s64 * xaddrp , int flag ) ;

int xtExtend ( tid_t tid , struct inode * ip , s64 xoff , s32 xlen , int flag ) ;

int xtUpdate ( tid_t tid , struct inode * ip , xad_t * nxad ) ;

int xtAppend ( tid_t tid , struct inode * ip , int xflag , s64 xoff , s32 maxblocks , s32 * xlenp , s64 * xaddrp , int flag ) ;

void xtInitRoot ( tid_t tid , struct inode * ip ) ;

s64 xtTruncate ( tid_t tid , struct inode * ip , s64 newsize , int flag ) ;

s64 xtTruncate_pmap ( tid_t tid , struct inode * ip , s64 committed_size ) ;

int diMount ( struct inode * ipimap ) ;

int diUnmount ( struct inode * ipimap , int mounterror ) ;

int diSync ( struct inode * ipimap ) ;

int diRead ( struct inode * ip ) ;

struct inode * diReadSpecial ( struct super_block * sb , ino_t inum , int secondary ) ;

void diWriteSpecial ( struct inode * ip , int secondary ) ;

void diFreeSpecial ( struct inode * ip ) ;

int diWrite ( tid_t tid , struct inode * ip ) ;

int diFree ( struct inode * ip ) ;

int diAlloc ( struct inode * pip , bool dir , struct inode * ip ) ;

int diUpdatePMap ( struct inode * ipimap , unsigned long inum , bool is_free , struct tblock * tblk ) ;

int diExtendFS ( struct inode * ipimap , struct inode * ipbmap ) ;

void jfs_proc_init ( void ) ;

void jfs_proc_clean ( void ) ;

int dbMount ( struct inode * ipbmap ) ;

int dbUnmount ( struct inode * ipbmap , int mounterror ) ;

int dbSync ( struct inode * ipbmap ) ;

int dbFree ( struct inode * ip , s64 blkno , s64 nblocks ) ;

int dbUpdatePMap ( struct inode * ipbmap , int free , s64 blkno , s64 nblocks , struct tblock * tblk ) ;

int dbNextAG ( struct inode * ipbmap ) ;

int dbAlloc ( struct inode * ip , s64 hint , s64 nblocks , s64 * results ) ;

int dbReAlloc ( struct inode * ip , s64 blkno , s64 nblocks , s64 addnblocks , s64 * results ) ;

int dbAllocBottomUp ( struct inode * ip , s64 blkno , s64 nblocks ) ;

int dbExtendFS ( struct inode * ipbmap , s64 blkno , s64 nblocks ) ;

void dbFinalizeBmap ( struct inode * ipbmap ) ;

s64 dbMapFileSizeToMapSize ( struct inode * ipbmap ) ;

int jfs_strfromUCS_le ( char * to , const __le16 * from , int len , struct nls_table * codepage ) ;

int get_UCSname ( struct component_name * uniName , struct dentry * dentry ) ;

struct dtsplit { struct metapage * mp ; s16 index ; s16 nslot ; struct component_name * key ; ddata_t * data ; struct pxdlist * pxdlist ; } ;

int dtSearch ( struct inode * ip , struct component_name * key , ino_t * data , struct btstack * btstack , int flag ) ;

int dtInsert ( tid_t tid , struct inode * ip , struct component_name * name , ino_t * fsn , struct btstack * btstack ) ;

int dtDelete ( tid_t tid , struct inode * ip , struct component_name * key , ino_t * ino , int flag ) ;

void dtInitRoot ( tid_t tid , struct inode * ip , u32 idotdot ) ;

struct jfs_dirent { loff_t position ; int ino ; u16 name_len ; char name [ 0 ] ; } ;

int jfs_readdir ( struct file * filp , void * dirent , filldir_t filldir ) ;

int dtModify ( tid_t tid , struct inode * ip , struct component_name * key , ino_t * orig_ino , ino_t new_ino , int flag ) ;

void jfs_set_inode_flags ( struct inode * inode ) ;

void jfs_get_inode_flags ( struct jfs_inode_info * jfs_ip ) ;

struct inode * ialloc ( struct inode * parent , umode_t mode ) ;

int extAlloc ( struct inode * ip , s64 xlen , s64 pno , xad_t * xp , bool abnr ) ;

int extHint ( struct inode * ip , s64 offset , xad_t * xp ) ;

int extRecord ( struct inode * ip , xad_t * xp ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) metapage_init ( void ) ;

void metapage_exit ( void ) ;

struct metapage * __get_metapage ( struct inode * inode , unsigned long lblock , unsigned int size , int absolute , unsigned long new ) ;

void grab_metapage ( struct metapage * mp ) ;

void force_metapage ( struct metapage * mp ) ;

void hold_metapage ( struct metapage * mp ) ;

void put_metapage ( struct metapage * mp ) ;

void release_metapage ( struct metapage * mp ) ;

void __invalidate_metapages ( struct inode * ip , s64 addr , int len ) ;


int lmLog ( struct jfs_log * log , struct tblock * tblk , struct lrd * lrd , struct tlock * tlck ) ;

int lmGroupCommit ( struct jfs_log * log , struct tblock * tblk ) ;

void jfs_syncpt ( struct jfs_log * log , int hard_sync ) ;

int lmLogOpen ( struct super_block * sb ) ;

int lmLogInit ( struct jfs_log * log ) ;

int lmLogClose ( struct super_block * sb ) ;

void jfs_flush_journal ( struct jfs_log * log , int wait ) ;

int lmLogShutdown ( struct jfs_log * log ) ;

int jfsIOWait ( void * arg ) ;

int lmLogFormat ( struct jfs_log * log , s64 logAddress , int logSize ) ;

int txInit ( void ) ;

void txExit ( void ) ;

tid_t txBegin ( struct super_block * sb , int flag ) ;

void txBeginAnon ( struct super_block * sb ) ;

void txEnd ( tid_t tid ) ;

struct tlock * txLock ( tid_t tid , struct inode * ip , struct metapage * mp , int type ) ;

struct tlock * txMaplock ( tid_t tid , struct inode * ip , int type ) ;

struct linelock * txLinelock ( struct linelock * tlock ) ;

int txCommit ( tid_t tid , int nip , struct inode * * iplist , int flag ) ;

void txEA ( tid_t tid , struct inode * ip , dxd_t * oldea , dxd_t * newea ) ;

void txFreeMap ( struct inode * ip , struct maplock * maplock , struct tblock * tblk , int maptype ) ;

void txFreelock ( struct inode * ip ) ;

void txAbort ( tid_t tid , int dirty ) ;

int jfs_lazycommit ( void * arg ) ;

void txLazyUnlock ( struct tblock * tblk ) ;

void txQuiesce ( struct super_block * sb ) ;

void txResume ( struct super_block * sb ) ;

int jfs_sync ( void * arg ) ;

int jfs_extendfs ( struct super_block * sb , s64 newLVSize , int newLogSize ) ;

struct ea_buffer { int flag ; int max_size ; dxd_t new_ea ; struct metapage * mp ; struct jfs_ea_list * xattr ; } ;

int __jfs_setxattr ( tid_t tid , struct inode * inode , const char * name , const void * value , size_t value_len , int flags ) ;

int jfs_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t value_len , int flags ) ;

ssize_t __jfs_getxattr ( struct inode * inode , const char * name , void * data , size_t buf_size ) ;

ssize_t jfs_getxattr ( struct dentry * dentry , const char * name , void * data , size_t buf_size ) ;

ssize_t jfs_listxattr ( struct dentry * dentry , char * data , size_t buf_size ) ;

int jfs_removexattr ( struct dentry * dentry , const char * name ) ;

int jfs_init_security ( tid_t tid , struct inode * inode , struct inode * dir ) ;

long jfs_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

long jfs_compat_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

int jfs_check_acl ( struct inode * inode , int mask ) ;

int jfs_init_acl ( tid_t tid , struct inode * inode , struct inode * dir ) ;

int jfs_setattr ( struct dentry * dentry , struct iattr * iattr ) ;

struct cache_head { struct cache_head * next ; time_t expiry_time ; time_t last_refresh ; struct kref ref ; unsigned long flags ; } ;

struct cache_detail_procfs { struct proc_dir_entry * proc_ent ; struct proc_dir_entry * flush_ent , * channel_ent , * content_ent ; } ;

struct cache_detail_pipefs { struct dentry * dir ; } ;

struct cache_detail { struct module * owner ; int hash_size ; struct cache_head * * hash_table ; rwlock_t hash_lock ; atomic_t inuse ; char * name ; void ( * cache_put ) ( struct kref * ) ; int ( * cache_upcall ) ( struct cache_detail * , struct cache_head * ) ; int ( * cache_parse ) ( struct cache_detail * , char * buf , int len ) ; int ( * cache_show ) ( struct seq_file * m , struct cache_detail * cd , struct cache_head * h ) ; void ( * warn_no_listener ) ( struct cache_detail * cd , int has_died ) ; struct cache_head * ( * alloc ) ( void ) ; int ( * match ) ( struct cache_head * orig , struct cache_head * new ) ; void ( * init ) ( struct cache_head * orig , struct cache_head * new ) ; void ( * update ) ( struct cache_head * orig , struct cache_head * new ) ; time_t flush_time ; struct list_head others ; time_t nextcheck ; int entries ; struct list_head queue ; atomic_t readers ; time_t last_close ; time_t last_warn ; union { struct cache_detail_procfs procfs ; struct cache_detail_pipefs pipefs ; } u ; } ;

struct cache_req { struct cache_deferred_req * ( * defer ) ( struct cache_req * req ) ; } ;

struct cache_deferred_req { struct list_head hash ; struct list_head recent ; struct cache_head * item ; void * owner ; void ( * revisit ) ( struct cache_deferred_req * req , int too_many ) ; } ;

struct svc_cred { uid_t cr_uid ; gid_t cr_gid ; struct group_info * cr_group_info ; } ;

struct svc_rqst ;

struct auth_domain { struct kref ref ; struct hlist_node hash ; char * name ; struct auth_ops * flavour ; } ;

struct auth_ops { char * name ; struct module * owner ; int flavour ; int ( * accept ) ( struct svc_rqst * rq , __be32 * authp ) ; int ( * release ) ( struct svc_rqst * rq ) ; void ( * domain_release ) ( struct auth_domain * ) ; int ( * set_client ) ( struct svc_rqst * rq ) ; } ;

typedef int ( * svc_thread_fn ) ( void * ) ;
struct svc_pool_stats { unsigned long packets ; unsigned long sockets_queued ; unsigned long threads_woken ; unsigned long overloads_avoided ; unsigned long threads_timedout ; } ;

struct svc_pool { unsigned int sp_id ; spinlock_t sp_lock ; struct list_head sp_threads ; struct list_head sp_sockets ; unsigned int sp_nrthreads ; struct list_head sp_all_threads ; int sp_nwaking ; struct svc_pool_stats sp_stats ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct svc_serv { struct svc_program * sv_program ; struct svc_stat * sv_stats ; spinlock_t sv_lock ; unsigned int sv_nrthreads ; unsigned int sv_maxconn ; unsigned int sv_max_payload ; unsigned int sv_max_mesg ; unsigned int sv_xdrsize ; struct list_head sv_permsocks ; struct list_head sv_tempsocks ; int sv_tmpcnt ; struct timer_list sv_temptimer ; char * sv_name ; unsigned int sv_nrpools ; struct svc_pool * sv_pools ; void ( * sv_shutdown ) ( struct svc_serv * serv ) ; struct module * sv_module ; svc_thread_fn sv_function ; } ;

union svc_addr_u { struct in_addr addr ; struct in6_addr addr6 ; } ;

struct svc_rqst { struct list_head rq_list ; struct list_head rq_all ; struct svc_xprt * rq_xprt ; struct __kernel_sockaddr_storage rq_addr ; size_t rq_addrlen ; struct svc_serv * rq_server ; struct svc_pool * rq_pool ; struct svc_procedure * rq_procinfo ; struct auth_ops * rq_authop ; u32 rq_flavor ; struct svc_cred rq_cred ; void * rq_xprt_ctxt ; struct svc_deferred_req * rq_deferred ; int rq_usedeferral ; size_t rq_xprt_hlen ; struct xdr_buf rq_arg ; struct xdr_buf rq_res ; struct page * rq_pages [ ( ( ( 1 * 1024 * 1024u ) + ( ( 1UL ) << 12 ) - 1 ) / ( ( 1UL ) << 12 ) + 2 + 1 ) ] ; struct page * * rq_respages ; int rq_resused ; struct kvec rq_vec [ ( ( ( 1 * 1024 * 1024u ) + ( ( 1UL ) << 12 ) - 1 ) / ( ( 1UL ) << 12 ) + 2 + 1 ) ] ; __be32 rq_xid ; u32 rq_prog ; u32 rq_vers ; u32 rq_proc ; u32 rq_prot ; unsigned short rq_secure : 1 ; union svc_addr_u rq_daddr ; void * rq_argp ; void * rq_resp ; void * rq_auth_data ; int rq_reserved ; struct cache_req rq_chandle ; struct auth_domain * rq_client ; struct auth_domain * rq_gssclient ; struct svc_cacherep * rq_cacherep ; struct knfsd_fh * rq_reffh ; int rq_splice_ok ; wait_queue_head_t rq_wait ; struct task_struct * rq_task ; int rq_waking ; } ;
struct svc_deferred_req { u32 prot ; struct svc_xprt * xprt ; struct __kernel_sockaddr_storage addr ; size_t addrlen ; union svc_addr_u daddr ; struct cache_deferred_req handle ; size_t xprt_hlen ; int argslen ; __be32 args [ 0 ] ; } ;

struct svc_program { struct svc_program * pg_next ; u32 pg_prog ; unsigned int pg_lovers ; unsigned int pg_hivers ; unsigned int pg_nvers ; struct svc_version * * pg_vers ; char * pg_name ; char * pg_class ; struct svc_stat * pg_stats ; int ( * pg_authenticate ) ( struct svc_rqst * ) ; } ;

struct svc_version { u32 vs_vers ; u32 vs_nproc ; struct svc_procedure * vs_proc ; u32 vs_xdrsize ; unsigned int vs_hidden : 1 ; int ( * vs_dispatch ) ( struct svc_rqst * , __be32 * ) ; } ;

typedef __be32 ( * svc_procfunc ) ( struct svc_rqst * , void * argp , void * resp ) ;

struct svc_procedure { svc_procfunc pc_func ; kxdrproc_t pc_decode ; kxdrproc_t pc_encode ; kxdrproc_t pc_release ; unsigned int pc_argsize ; unsigned int pc_ressize ; unsigned int pc_count ; unsigned int pc_cachetype ; unsigned int pc_xdrressize ; } ;

struct nfs_fhbase_old { __u32 fb_dcookie ; __u32 fb_ino ; __u32 fb_dirino ; __u32 fb_dev ; __u32 fb_xdev ; __u32 fb_xino ; __u32 fb_generation ; } ;

struct nfs_fhbase_new { __u8 fb_version ; __u8 fb_auth_type ; __u8 fb_fsid_type ; __u8 fb_fileid_type ; __u32 fb_auth [ 1 ] ; } ;

struct knfsd_fh { unsigned int fh_size ; union { struct nfs_fhbase_old fh_old ; __u32 fh_pad [ 128 / 4 ] ; struct nfs_fhbase_new fh_new ; } fh_base ; } ;


typedef struct svc_fh { struct knfsd_fh fh_handle ; struct dentry * fh_dentry ; struct svc_export * fh_export ; int fh_maxsize ; unsigned char fh_locked ; unsigned char fh_post_saved ; unsigned char fh_pre_saved ; __u64 fh_pre_size ; struct timespec fh_pre_mtime ; struct timespec fh_pre_ctime ; u64 fh_pre_change ; struct kstat fh_post_attr ; u64 fh_post_change ; } svc_fh ;

enum nfsd_fsid { FSID_DEV = 0 , FSID_NUM , FSID_MAJOR_MINOR , FSID_ENCODE_DEV , FSID_UUID4_INUM , FSID_UUID8 , FSID_UUID16 , FSID_UUID16_INUM , } ;

enum fsid_source { FSIDSOURCE_DEV , FSIDSOURCE_FSID , FSIDSOURCE_UUID , } ;

enum { NLM_LCK_GRANTED = 0 , NLM_LCK_DENIED = 1 , NLM_LCK_DENIED_NOLOCKS = 2 , NLM_LCK_BLOCKED = 3 , NLM_LCK_DENIED_GRACE_PERIOD = 4 , NLM_DEADLCK = 5 , NLM_ROFS = 6 , NLM_STALE_FH = 7 , NLM_FBIG = 8 , NLM_FAILED = 9 , } ;
struct nsm_private { unsigned char data [ 16 ] ; } ;

struct nlm_lock { char * caller ; unsigned int len ; struct nfs_fh fh ; struct xdr_netobj oh ; u32 svid ; struct file_lock fl ; } ;

struct nlm_cookie { unsigned char data [ 32 ] ; unsigned int len ; } ;

struct nlm_args { struct nlm_cookie cookie ; struct nlm_lock lock ; u32 block ; u32 reclaim ; u32 state ; u32 monitor ; u32 fsm_access ; u32 fsm_mode ; } ;

typedef struct nlm_args nlm_args ;

struct nlm_res { struct nlm_cookie cookie ; __be32 status ; struct nlm_lock lock ; } ;

struct nlm_reboot { char * mon ; unsigned int len ; u32 state ; struct nsm_private priv ; } ;

struct nlmsvc_binding { __be32 ( * fopen ) ( struct svc_rqst * , struct nfs_fh * , struct file * * ) ; void ( * fclose ) ( struct file * ) ; } ;

struct nlmclnt_initdata { const char * hostname ; const struct sockaddr * address ; size_t addrlen ; unsigned short protocol ; u32 nfs_version ; int noresvport ; } ;

struct nlm_cookie ;
struct nlm_host { struct hlist_node h_hash ; struct __kernel_sockaddr_storage h_addr ; size_t h_addrlen ; struct __kernel_sockaddr_storage h_srcaddr ; struct rpc_clnt * h_rpcclnt ; char * h_name ; u32 h_version ; unsigned short h_proto ; unsigned short h_reclaiming : 1 , h_server : 1 , h_noresvport : 1 , h_inuse : 1 ; wait_queue_head_t h_gracewait ; struct rw_semaphore h_rwsem ; u32 h_state ; u32 h_nsmstate ; u32 h_pidcount ; atomic_t h_count ; struct mutex h_mutex ; unsigned long h_nextrebind ; unsigned long h_expires ; struct list_head h_lockowners ; spinlock_t h_lock ; struct list_head h_granted ; struct list_head h_reclaim ; struct nsm_handle * h_nsmhandle ; char * h_addrbuf ; } ;
struct nsm_handle { struct list_head sm_link ; atomic_t sm_count ; char * sm_mon_name ; char * sm_name ; struct __kernel_sockaddr_storage sm_addr ; size_t sm_addrlen ; unsigned int sm_monitored : 1 , sm_sticky : 1 ; struct nsm_private sm_priv ; char sm_addrbuf [ ( ( 8 * 4 + 7 ) + ( 1 + 10 ) + 1 ) ] ; } ;

struct nlm_lockowner { struct list_head list ; atomic_t count ; struct nlm_host * host ; fl_owner_t owner ; uint32_t pid ; } ;
struct nlm_wait ;

struct nlm_rqst { atomic_t a_count ; unsigned int a_flags ; struct nlm_host * a_host ; struct nlm_args a_args ; struct nlm_res a_res ; struct nlm_block * a_block ; unsigned int a_retries ; u8 a_owner [ ( ( 64 ) + 10u ) ] ; } ;

struct nlm_file { struct hlist_node f_list ; struct nfs_fh f_handle ; struct file * f_file ; struct nlm_share * f_shares ; struct list_head f_blocks ; unsigned int f_locks ; unsigned int f_count ; struct mutex f_mutex ; } ;

struct nlm_block { struct kref b_count ; struct list_head b_list ; struct list_head b_flist ; struct nlm_rqst * b_call ; struct svc_serv * b_daemon ; struct nlm_host * b_host ; unsigned long b_when ; unsigned int b_id ; unsigned char b_granted ; struct nlm_file * b_file ; struct cache_req * b_cache_req ; struct file_lock * b_fl ; struct cache_deferred_req * b_deferred_req ; unsigned int b_flags ; } ;

typedef int ( * nlm_host_match_fn_t ) ( void * cur , struct nlm_host * ref ) ;
struct nlm_wait { struct list_head b_list ; wait_queue_head_t b_wait ; struct nlm_host * b_host ; struct file_lock * b_lock ; unsigned short b_reclaim ; __be32 b_status ; } ;
struct nlm_host * nlmclnt_init ( const struct nlmclnt_initdata * nlm_init ) ;

void nlmclnt_done ( struct nlm_host * host ) ;

struct nlm_wait * nlmclnt_prepare_block ( struct nlm_host * host , struct file_lock * fl ) ;

void nlmclnt_finish_block ( struct nlm_wait * block ) ;

int nlmclnt_block ( struct nlm_wait * block , struct nlm_rqst * req , long timeout ) ;

__be32 nlmclnt_grant ( const struct sockaddr * addr , const struct nlm_lock * lock ) ;

void nlmclnt_recovery ( struct nlm_host * host ) ;

void nlmclnt_next_cookie ( struct nlm_cookie * c ) ;

int nlmclnt_proc ( struct nlm_host * host , int cmd , struct file_lock * fl ) ;

struct nlm_rqst * nlm_alloc_call ( struct nlm_host * host ) ;

void nlm_release_call ( struct nlm_rqst * call ) ;

int nlm_async_call ( struct nlm_rqst * req , u32 proc , const struct rpc_call_ops * tk_ops ) ;

int nlm_async_reply ( struct nlm_rqst * req , u32 proc , const struct rpc_call_ops * tk_ops ) ;

int nlmclnt_reclaim ( struct nlm_host * host , struct file_lock * fl ) ;

struct nlm_lookup_host_info { const int server ; const struct sockaddr * sap ; const size_t salen ; const unsigned short protocol ; const u32 version ; const char * hostname ; const size_t hostname_len ; const struct sockaddr * src_sap ; const size_t src_len ; const int noresvport ; } ;

struct nlm_host * nlmclnt_lookup_host ( const struct sockaddr * sap , const size_t salen , const unsigned short protocol , const u32 version , const char * hostname , int noresvport ) ;

struct nlm_host * nlmsvc_lookup_host ( const struct svc_rqst * rqstp , const char * hostname , const size_t hostname_len ) ;

struct rpc_clnt * nlm_bind_host ( struct nlm_host * host ) ;

void nlm_rebind_host ( struct nlm_host * host ) ;

struct nlm_host * nlm_get_host ( struct nlm_host * host ) ;

void nlm_release_host ( struct nlm_host * host ) ;

void nlm_host_rebooted ( const struct nlm_reboot * info ) ;

void nlm_shutdown_hosts ( void ) ;

struct svc_xprt_ops { struct svc_xprt * ( * xpo_create ) ( struct svc_serv * , struct sockaddr * , int , int ) ; struct svc_xprt * ( * xpo_accept ) ( struct svc_xprt * ) ; int ( * xpo_has_wspace ) ( struct svc_xprt * ) ; int ( * xpo_recvfrom ) ( struct svc_rqst * ) ; void ( * xpo_prep_reply_hdr ) ( struct svc_rqst * ) ; int ( * xpo_sendto ) ( struct svc_rqst * ) ; void ( * xpo_release_rqst ) ( struct svc_rqst * ) ; void ( * xpo_detach ) ( struct svc_xprt * ) ; void ( * xpo_free ) ( struct svc_xprt * ) ; } ;

struct svc_xprt_class { const char * xcl_name ; struct module * xcl_owner ; struct svc_xprt_ops * xcl_ops ; struct list_head xcl_list ; u32 xcl_max_payload ; } ;

struct svc_xprt { struct svc_xprt_class * xpt_class ; struct svc_xprt_ops * xpt_ops ; struct kref xpt_ref ; struct list_head xpt_list ; struct list_head xpt_ready ; unsigned long xpt_flags ; struct svc_pool * xpt_pool ; struct svc_serv * xpt_server ; atomic_t xpt_reserved ; struct mutex xpt_mutex ; spinlock_t xpt_lock ; void * xpt_auth_cache ; struct list_head xpt_deferred ; struct __kernel_sockaddr_storage xpt_local ; size_t xpt_locallen ; struct __kernel_sockaddr_storage xpt_remote ; size_t xpt_remotelen ; struct rpc_wait_queue xpt_bc_pending ; } ;

struct svc_sock { struct svc_xprt sk_xprt ; struct socket * sk_sock ; struct sock * sk_sk ; void ( * sk_ostate ) ( struct sock * ) ; void ( * sk_odata ) ( struct sock * , int bytes ) ; void ( * sk_owspace ) ( struct sock * ) ; u32 sk_reclen ; u32 sk_tcplen ; struct rpc_xprt * sk_bc_xprt ; } ;

struct inet_skb_parm { struct ip_options opt ; unsigned char flags ; } ;

struct ipcm_cookie { __be32 addr ; int oif ; struct ip_options * opt ; union skb_shared_tx shtx ; } ;

struct ip_ra_chain { struct ip_ra_chain * next ; struct sock * sk ; void ( * destructor ) ( struct sock * ) ; } ;

struct packet_type ;
struct ip_reply_arg { struct kvec iov [ 1 ] ; int flags ; __wsum csum ; int csumoffset ; int bound_dev_if ; } ;

struct ipv4_config { int log_martians ; int no_pmtu_disc ; } ;


enum ip_defrag_users { IP_DEFRAG_LOCAL_DELIVER , IP_DEFRAG_CALL_RA_CHAIN , IP_DEFRAG_CONNTRACK_IN , IP_DEFRAG_CONNTRACK_OUT , IP_DEFRAG_CONNTRACK_BRIDGE_IN , IP_DEFRAG_VS_IN , IP_DEFRAG_VS_OUT , IP_DEFRAG_VS_FWD } ;

int lockd_up ( void ) ;

void lockd_down ( void ) ;

void nlmsvc_traverse_blocks ( struct nlm_host * host , struct nlm_file * file , nlm_host_match_fn_t match ) ;

__be32 nlmsvc_lock ( struct svc_rqst * rqstp , struct nlm_file * file , struct nlm_host * host , struct nlm_lock * lock , int wait , struct nlm_cookie * cookie , int reclaim ) ;

__be32 nlmsvc_testlock ( struct svc_rqst * rqstp , struct nlm_file * file , struct nlm_host * host , struct nlm_lock * lock , struct nlm_lock * conflock , struct nlm_cookie * cookie ) ;

__be32 nlmsvc_unlock ( struct nlm_file * file , struct nlm_lock * lock ) ;

__be32 nlmsvc_cancel_blocked ( struct nlm_file * file , struct nlm_lock * lock ) ;

void nlmsvc_grant_reply ( struct nlm_cookie * cookie , __be32 status ) ;

unsigned long nlmsvc_retry_blocked ( void ) ;

struct nlm_share { struct nlm_share * s_next ; struct nlm_host * s_host ; struct nlm_file * s_file ; struct xdr_netobj s_owner ; u32 s_access ; u32 s_mode ; } ;

__be32 nlmsvc_share_file ( struct nlm_host * host , struct nlm_file * file , struct nlm_args * argp ) ;

__be32 nlmsvc_unshare_file ( struct nlm_host * host , struct nlm_file * file , struct nlm_args * argp ) ;

void nlmsvc_traverse_shares ( struct nlm_host * host , struct nlm_file * file , nlm_host_match_fn_t match ) ;

struct nfsd4_fs_location { char * hosts ; char * path ; } ;

struct nfsd4_fs_locations { uint32_t locations_count ; struct nfsd4_fs_location * locations ; int migrated ; } ;

struct exp_flavor_info { u32 pseudoflavor ; u32 flags ; } ;

struct svc_export { struct cache_head h ; struct auth_domain * ex_client ; int ex_flags ; struct path ex_path ; char * ex_pathname ; uid_t ex_anon_uid ; gid_t ex_anon_gid ; int ex_fsid ; unsigned char * ex_uuid ; struct nfsd4_fs_locations ex_fslocs ; int ex_nflavors ; struct exp_flavor_info ex_flavors [ 8 ] ; } ;

struct svc_expkey { struct cache_head h ; struct auth_domain * ek_client ; int ek_fsidtype ; u32 ek_fsid [ 6 ] ; struct path ek_path ; } ;

struct nfsd_stats { unsigned int rchits ; unsigned int rcmisses ; unsigned int rcnocache ; unsigned int fh_stale ; unsigned int fh_lookup ; unsigned int fh_anon ; unsigned int fh_nocache_dir ; unsigned int fh_nocache_nondir ; unsigned int io_read ; unsigned int io_write ; unsigned int th_cnt ; unsigned int th_usage [ 10 ] ; unsigned int th_fullcnt ; unsigned int ra_size ; unsigned int ra_depth [ 11 ] ; unsigned int nfs4_opcount [ OP_RECLAIM_COMPLETE + 1 ] ; } ;

struct readdir_cd { __be32 err ; } ;

typedef int ( * nfsd_dirop_t ) ( struct inode * , struct dentry * , int , int ) ;
enum vers_op { NFSD_SET , NFSD_CLEAR , NFSD_TEST , NFSD_AVAIL } ;

struct nlm_void { int dummy ; } ;

__be32 nlm_lookup_file ( struct svc_rqst * rqstp , struct nlm_file * * result , struct nfs_fh * f ) ;

void nlm_release_file ( struct nlm_file * file ) ;

void nlmsvc_mark_resources ( void ) ;

void nlmsvc_free_host_resources ( struct nlm_host * host ) ;

void nlmsvc_invalidate_all ( void ) ;

int nlmsvc_unlock_all_by_sb ( struct super_block * sb ) ;

int nlmsvc_unlock_all_by_ip ( struct sockaddr * server_addr ) ;

enum { NSMPROC_NULL , NSMPROC_STAT , NSMPROC_MON , NSMPROC_UNMON , NSMPROC_UNMON_ALL , NSMPROC_SIMU_CRASH , NSMPROC_NOTIFY , } ;
struct nsm_args { struct nsm_private * priv ; u32 prog ; u32 vers ; u32 proc ; char * mon_name ; } ;

struct nsm_res { u32 status ; u32 state ; } ;

int nsm_monitor ( const struct nlm_host * host ) ;

void nsm_unmonitor ( const struct nlm_host * host ) ;

struct nsm_handle * nsm_get_handle ( const struct sockaddr * sap , const size_t salen , const char * hostname , const size_t hostname_len ) ;

struct nsm_handle * nsm_reboot_lookup ( const struct nlm_reboot * info ) ;

void nsm_release ( struct nsm_handle * nsm ) ;

int nlmsvc_decode_testargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlmsvc_encode_testres ( struct svc_rqst * rqstp , __be32 * p , struct nlm_res * resp ) ;

int nlmsvc_decode_lockargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlmsvc_decode_cancargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlmsvc_decode_unlockargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlmsvc_decode_shareargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlmsvc_encode_shareres ( struct svc_rqst * rqstp , __be32 * p , struct nlm_res * resp ) ;

int nlmsvc_encode_res ( struct svc_rqst * rqstp , __be32 * p , struct nlm_res * resp ) ;

int nlmsvc_decode_notify ( struct svc_rqst * rqstp , __be32 * p , struct nlm_args * argp ) ;

int nlmsvc_decode_reboot ( struct svc_rqst * rqstp , __be32 * p , struct nlm_reboot * argp ) ;

int nlmsvc_decode_res ( struct svc_rqst * rqstp , __be32 * p , struct nlm_res * resp ) ;

int nlmsvc_decode_void ( struct svc_rqst * rqstp , __be32 * p , void * dummy ) ;

int nlmsvc_encode_void ( struct svc_rqst * rqstp , __be32 * p , void * dummy ) ;

const char * nlmdbg_cookie2a ( const struct nlm_cookie * cookie ) ;

void locks_start_grace ( struct lock_manager * lm ) ;

void locks_end_grace ( struct lock_manager * lm ) ;

int locks_in_grace ( void ) ;

int nlm4svc_decode_testargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlm4svc_encode_testres ( struct svc_rqst * rqstp , __be32 * p , struct nlm_res * resp ) ;

int nlm4svc_decode_lockargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlm4svc_decode_cancargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlm4svc_decode_unlockargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlm4svc_decode_shareargs ( struct svc_rqst * rqstp , __be32 * p , nlm_args * argp ) ;

int nlm4svc_encode_shareres ( struct svc_rqst * rqstp , __be32 * p , struct nlm_res * resp ) ;

int nlm4svc_encode_res ( struct svc_rqst * rqstp , __be32 * p , struct nlm_res * resp ) ;

int nlm4svc_decode_notify ( struct svc_rqst * rqstp , __be32 * p , struct nlm_args * argp ) ;

int nlm4svc_decode_reboot ( struct svc_rqst * rqstp , __be32 * p , struct nlm_reboot * argp ) ;

int nlm4svc_decode_res ( struct svc_rqst * rqstp , __be32 * p , struct nlm_res * resp ) ;

int nlm4svc_decode_void ( struct svc_rqst * rqstp , __be32 * p , void * dummy ) ;

int nlm4svc_encode_void ( struct svc_rqst * rqstp , __be32 * p , void * dummy ) ;

struct minix_inode_info { union { __u16 i1_data [ 16 ] ; __u32 i2_data [ 16 ] ; } u ; struct inode vfs_inode ; } ;

struct minix_sb_info { unsigned long s_ninodes ; unsigned long s_nzones ; unsigned long s_imap_blocks ; unsigned long s_zmap_blocks ; unsigned long s_firstdatazone ; unsigned long s_log_zone_size ; unsigned long s_max_size ; int s_dirsize ; int s_namelen ; int s_link_max ; struct buffer_head * * s_imap ; struct buffer_head * * s_zmap ; struct buffer_head * s_sbh ; struct minix_super_block * s_ms ; unsigned short s_mount_state ; unsigned short s_version ; } ;

void minix_free_block ( struct inode * inode , unsigned long block ) ;

int minix_new_block ( struct inode * inode ) ;

unsigned long minix_count_free_blocks ( struct minix_sb_info * sbi ) ;

struct minix_inode * minix_V1_raw_inode ( struct super_block * sb , ino_t ino , struct buffer_head * * bh ) ;

struct minix2_inode * minix_V2_raw_inode ( struct super_block * sb , ino_t ino , struct buffer_head * * bh ) ;

void minix_free_inode ( struct inode * inode ) ;

struct inode * minix_new_inode ( const struct inode * dir , int * error ) ;

unsigned long minix_count_free_inodes ( struct minix_sb_info * sbi ) ;

enum { DEPTH = 3 , DIRECT = 7 } ;
typedef u16 block_t ;

typedef struct { block_t * p ; block_t key ; struct buffer_head * bh ; } Indirect ;
int V1_minix_get_block ( struct inode * inode , long block , struct buffer_head * bh_result , int create ) ;

void V1_minix_truncate ( struct inode * inode ) ;

unsigned V1_minix_blocks ( loff_t size , struct super_block * sb ) ;

enum { DIRECT = 7 , DEPTH = 4 } ;
typedef u32 block_t ;
int V2_minix_get_block ( struct inode * inode , long block , struct buffer_head * bh_result , int create ) ;

void V2_minix_truncate ( struct inode * inode ) ;

unsigned V2_minix_blocks ( loff_t size , struct super_block * sb ) ;

int __minix_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata ) ;

void minix_set_inode ( struct inode * inode , dev_t rdev ) ;

struct inode * minix_iget ( struct super_block * sb , unsigned long ino ) ;

int minix_getattr ( struct vfsmount * mnt , struct dentry * dentry , struct kstat * stat ) ;

void minix_truncate ( struct inode * inode ) ;

typedef struct minix_dir_entry minix_dirent ;

typedef struct minix3_dir_entry minix3_dirent ;

minix_dirent * minix_find_entry ( struct dentry * dentry , struct page * * res_page ) ;

int minix_add_link ( struct dentry * dentry , struct inode * inode ) ;

int minix_delete_entry ( struct minix_dir_entry * de , struct page * page ) ;

int minix_make_empty ( struct inode * inode , struct inode * dir ) ;

int minix_empty_dir ( struct inode * inode ) ;

void minix_set_link ( struct minix_dir_entry * de , struct page * page , struct inode * inode ) ;

struct minix_dir_entry * minix_dotdot ( struct inode * dir , struct page * * p ) ;

ino_t minix_inode_by_name ( struct dentry * dentry ) ;

struct nfsacl_encode_desc { struct xdr_array2_desc desc ; unsigned int count ; struct posix_acl * acl ; int typeflag ; uid_t uid ; gid_t gid ; } ;

unsigned int nfsacl_encode ( struct xdr_buf * buf , unsigned int base , struct inode * inode , struct posix_acl * acl , int encode_entries , int typeflag ) ;

struct nfsacl_decode_desc { struct xdr_array2_desc desc ; unsigned int count ; struct posix_acl * acl ; } ;

unsigned int nfsacl_decode ( struct xdr_buf * buf , unsigned int base , unsigned int * aclcnt , struct posix_acl * * pacl ) ;

struct svc_cacherep { struct hlist_node c_hash ; struct list_head c_lru ; unsigned char c_state , c_type , c_secure : 1 ; struct sockaddr_in c_addr ; __be32 c_xid ; u32 c_prot ; u32 c_proc ; u32 c_vers ; unsigned long c_timestamp ; union { struct kvec u_vec ; __be32 u_status ; } c_u ; } ;

enum { RC_UNUSED , RC_INPROG , RC_DONE } ;
enum { RC_DROPIT , RC_REPLY , RC_DOIT , RC_INTR } ;
enum { RC_NOCACHE , RC_REPLSTAT , RC_REPLBUFF , } ;
struct nfsctl_svc { unsigned short svc_port ; int svc_nthreads ; } ;

struct nfsctl_client { char cl_ident [ 1024 + 1 ] ; int cl_naddr ; struct in_addr cl_addrlist [ 16 ] ; int cl_fhkeytype ; int cl_fhkeylen ; unsigned char cl_fhkey [ 32 ] ; } ;

struct nfsctl_export { char ex_client [ 1024 + 1 ] ; char ex_path [ 1024 + 1 ] ; __kernel_old_dev_t ex_dev ; __kernel_ino_t ex_ino ; int ex_flags ; __kernel_uid_t ex_anon_uid ; __kernel_gid_t ex_anon_gid ; } ;

struct nfsctl_fdparm { struct sockaddr gd_addr ; char gd_path [ 1024 + 1 ] ; int gd_version ; } ;

struct nfsctl_fsparm { struct sockaddr gd_addr ; char gd_path [ 1024 + 1 ] ; int gd_maxlen ; } ;

struct nfsctl_arg { int ca_version ; union { struct nfsctl_svc u_svc ; struct nfsctl_client u_client ; struct nfsctl_export u_export ; struct nfsctl_fdparm u_getfd ; struct nfsctl_fsparm u_getfs ; void * u_ptr ; } u ; } ;
union nfsctl_res { __u8 cr_getfh [ 32 ] ; struct knfsd_fh cr_getfs ; } ;

int nfsd_vers ( int vers , enum vers_op change ) ;

int nfsd_minorversion ( u32 minorversion , enum vers_op change ) ;

int nfsd_nrthreads ( void ) ;

void nfsd_reset_versions ( void ) ;

int nfsd_create_serv ( void ) ;

int nfsd_nrpools ( void ) ;

int nfsd_get_nrthreads ( int n , int * nthreads ) ;

int nfsd_set_nrthreads ( int n , int * nthreads ) ;

int nfsd_svc ( unsigned short port , int nrservs ) ;

int nfsd_dispatch ( struct svc_rqst * rqstp , __be32 * statp ) ;

int nfsd_pool_stats_open ( struct inode * inode , struct file * file ) ;

int nfsd_pool_stats_release ( struct inode * inode , struct file * file ) ;

struct nfsd_fhandle { struct svc_fh fh ; } ;

struct nfsd_sattrargs { struct svc_fh fh ; struct iattr attrs ; } ;

struct nfsd_diropargs { struct svc_fh fh ; char * name ; unsigned int len ; } ;

struct nfsd_readargs { struct svc_fh fh ; __u32 offset ; __u32 count ; int vlen ; } ;

struct nfsd_writeargs { svc_fh fh ; __u32 offset ; int len ; int vlen ; } ;

struct nfsd_createargs { struct svc_fh fh ; char * name ; unsigned int len ; struct iattr attrs ; } ;

struct nfsd_renameargs { struct svc_fh ffh ; char * fname ; unsigned int flen ; struct svc_fh tfh ; char * tname ; unsigned int tlen ; } ;

struct nfsd_readlinkargs { struct svc_fh fh ; char * buffer ; } ;

struct nfsd_linkargs { struct svc_fh ffh ; struct svc_fh tfh ; char * tname ; unsigned int tlen ; } ;

struct nfsd_symlinkargs { struct svc_fh ffh ; char * fname ; unsigned int flen ; char * tname ; unsigned int tlen ; struct iattr attrs ; } ;

struct nfsd_readdirargs { struct svc_fh fh ; __u32 cookie ; __u32 count ; __be32 * buffer ; } ;

struct nfsd_attrstat { struct svc_fh fh ; struct kstat stat ; } ;

struct nfsd_diropres { struct svc_fh fh ; struct kstat stat ; } ;

struct nfsd_readlinkres { int len ; } ;

struct nfsd_readres { struct svc_fh fh ; unsigned long count ; struct kstat stat ; } ;

struct nfsd_readdirres { int count ; struct readdir_cd common ; __be32 * buffer ; int buflen ; __be32 * offset ; } ;

struct nfsd_statfsres { struct kstatfs stats ; } ;

union nfsd_xdrstore { struct nfsd_sattrargs sattr ; struct nfsd_diropargs dirop ; struct nfsd_readargs read ; struct nfsd_writeargs write ; struct nfsd_createargs create ; struct nfsd_renameargs rename ; struct nfsd_linkargs link ; struct nfsd_symlinkargs symlink ; struct nfsd_readdirargs readdir ; } ;

enum { NFSD_Root = 1 , NFSD_Svc , NFSD_Add , NFSD_Del , NFSD_Export , NFSD_Unexport , NFSD_Getfd , NFSD_Getfs , NFSD_List , NFSD_Fh , NFSD_FO_UnlockIP , NFSD_FO_UnlockFS , NFSD_Threads , NFSD_Pool_Threads , NFSD_Pool_Stats , NFSD_Versions , NFSD_Ports , NFSD_MaxBlkSize , NFSD_Leasetime , NFSD_RecoveryDir , } ;
typedef struct svc_rqst svc_rqst ;

typedef struct svc_buf svc_buf ;

struct nfsd_void { int dummy ; } ;

__be32 nfserrno ( int errno ) ;

struct gss_ctx { struct gss_api_mech * mech_type ; void * internal_ctx_id ; } ;

struct pf_desc { u32 pseudoflavor ; u32 service ; char * name ; char * auth_domain_name ; } ;

struct gss_api_mech { struct list_head gm_list ; struct module * gm_owner ; struct xdr_netobj gm_oid ; char * gm_name ; const struct gss_api_ops * gm_ops ; int gm_pf_num ; struct pf_desc * gm_pfs ; } ;

struct gss_api_ops { int ( * gss_import_sec_context ) ( const void * input_token , size_t bufsize , struct gss_ctx * ctx_id ) ; u32 ( * gss_get_mic ) ( struct gss_ctx * ctx_id , struct xdr_buf * message , struct xdr_netobj * mic_token ) ; u32 ( * gss_verify_mic ) ( struct gss_ctx * ctx_id , struct xdr_buf * message , struct xdr_netobj * mic_token ) ; u32 ( * gss_wrap ) ( struct gss_ctx * ctx_id , int offset , struct xdr_buf * outbuf , struct page * * inpages ) ; u32 ( * gss_unwrap ) ( struct gss_ctx * ctx_id , int offset , struct xdr_buf * buf ) ; void ( * gss_delete_sec_context ) ( void * internal_ctx_id ) ; } ;

enum rpc_gss_proc { RPC_GSS_PROC_DATA = 0 , RPC_GSS_PROC_INIT = 1 , RPC_GSS_PROC_CONTINUE_INIT = 2 , RPC_GSS_PROC_DESTROY = 3 } ;

enum rpc_gss_svc { RPC_GSS_SVC_NONE = 1 , RPC_GSS_SVC_INTEGRITY = 2 , RPC_GSS_SVC_PRIVACY = 3 } ;

struct rpc_gss_wire_cred { u32 gc_v ; u32 gc_proc ; u32 gc_seq ; u32 gc_svc ; struct xdr_netobj gc_ctx ; } ;

struct rpc_gss_wire_verf { u32 gv_flavor ; struct xdr_netobj gv_verf ; } ;

struct rpc_gss_init_res { struct xdr_netobj gr_ctx ; u32 gr_major ; u32 gr_minor ; u32 gr_win ; struct xdr_netobj gr_token ; } ;

struct gss_cl_ctx { atomic_t count ; enum rpc_gss_proc gc_proc ; u32 gc_seq ; spinlock_t gc_seq_lock ; struct gss_ctx * gc_gss_ctx ; struct xdr_netobj gc_wire_ctx ; u32 gc_win ; unsigned long gc_expiry ; struct rcu_head gc_rcu ; } ;

struct gss_upcall_msg ;

struct gss_cred { struct rpc_cred gc_base ; enum rpc_gss_svc gc_service ; struct gss_cl_ctx * gc_ctx ; struct gss_upcall_msg * gc_upcall ; unsigned char gc_machine_cred : 1 ; } ;

__be32 fh_verify ( struct svc_rqst * rqstp , struct svc_fh * fhp , int type , int access ) ;

__be32 fh_compose ( struct svc_fh * fhp , struct svc_export * exp , struct dentry * dentry , struct svc_fh * ref_fh ) ;

__be32 fh_update ( struct svc_fh * fhp ) ;

void fh_put ( struct svc_fh * fhp ) ;

char * SVCFH_fmt ( struct svc_fh * fhp ) ;

enum fsid_source fsid_source ( struct svc_fh * fhp ) ;
struct nfsd3_sattrargs { struct svc_fh fh ; struct iattr attrs ; int check_guard ; time_t guardtime ; } ;

struct nfsd3_diropargs { struct svc_fh fh ; char * name ; unsigned int len ; } ;

struct nfsd3_accessargs { struct svc_fh fh ; unsigned int access ; } ;

struct nfsd3_readargs { struct svc_fh fh ; __u64 offset ; __u32 count ; int vlen ; } ;

struct nfsd3_writeargs { svc_fh fh ; __u64 offset ; __u32 count ; int stable ; __u32 len ; int vlen ; } ;

struct nfsd3_createargs { struct svc_fh fh ; char * name ; unsigned int len ; int createmode ; struct iattr attrs ; __be32 * verf ; } ;

struct nfsd3_mknodargs { struct svc_fh fh ; char * name ; unsigned int len ; __u32 ftype ; __u32 major , minor ; struct iattr attrs ; } ;

struct nfsd3_renameargs { struct svc_fh ffh ; char * fname ; unsigned int flen ; struct svc_fh tfh ; char * tname ; unsigned int tlen ; } ;

struct nfsd3_readlinkargs { struct svc_fh fh ; char * buffer ; } ;

struct nfsd3_linkargs { struct svc_fh ffh ; struct svc_fh tfh ; char * tname ; unsigned int tlen ; } ;

struct nfsd3_symlinkargs { struct svc_fh ffh ; char * fname ; unsigned int flen ; char * tname ; unsigned int tlen ; struct iattr attrs ; } ;

struct nfsd3_readdirargs { struct svc_fh fh ; __u64 cookie ; __u32 dircount ; __u32 count ; __be32 * verf ; __be32 * buffer ; } ;

struct nfsd3_commitargs { struct svc_fh fh ; __u64 offset ; __u32 count ; } ;

struct nfsd3_getaclargs { struct svc_fh fh ; int mask ; } ;

struct nfsd3_setaclargs { struct svc_fh fh ; int mask ; struct posix_acl * acl_access ; struct posix_acl * acl_default ; } ;

struct nfsd3_attrstat { __be32 status ; struct svc_fh fh ; struct kstat stat ; } ;

struct nfsd3_diropres { __be32 status ; struct svc_fh dirfh ; struct svc_fh fh ; } ;

struct nfsd3_accessres { __be32 status ; struct svc_fh fh ; __u32 access ; } ;

struct nfsd3_readlinkres { __be32 status ; struct svc_fh fh ; __u32 len ; } ;

struct nfsd3_readres { __be32 status ; struct svc_fh fh ; unsigned long count ; int eof ; } ;

struct nfsd3_writeres { __be32 status ; struct svc_fh fh ; unsigned long count ; int committed ; } ;

struct nfsd3_renameres { __be32 status ; struct svc_fh ffh ; struct svc_fh tfh ; } ;

struct nfsd3_linkres { __be32 status ; struct svc_fh tfh ; struct svc_fh fh ; } ;

struct nfsd3_readdirres { __be32 status ; struct svc_fh fh ; int count ; __be32 verf [ 2 ] ; struct readdir_cd common ; __be32 * buffer ; int buflen ; __be32 * offset ; __be32 * offset1 ; struct svc_rqst * rqstp ; } ;

struct nfsd3_fsstatres { __be32 status ; struct kstatfs stats ; __u32 invarsec ; } ;

struct nfsd3_fsinfores { __be32 status ; __u32 f_rtmax ; __u32 f_rtpref ; __u32 f_rtmult ; __u32 f_wtmax ; __u32 f_wtpref ; __u32 f_wtmult ; __u32 f_dtpref ; __u64 f_maxfilesize ; __u32 f_properties ; } ;

struct nfsd3_pathconfres { __be32 status ; __u32 p_link_max ; __u32 p_name_max ; __u32 p_no_trunc ; __u32 p_chown_restricted ; __u32 p_case_insensitive ; __u32 p_case_preserving ; } ;

struct nfsd3_commitres { __be32 status ; struct svc_fh fh ; } ;

struct nfsd3_getaclres { __be32 status ; struct svc_fh fh ; int mask ; struct posix_acl * acl_access ; struct posix_acl * acl_default ; } ;

struct nfsd3_fhandle_pair { __u32 dummy ; struct svc_fh fh1 ; struct svc_fh fh2 ; } ;

union nfsd3_xdrstore { struct nfsd3_sattrargs sattrargs ; struct nfsd3_diropargs diropargs ; struct nfsd3_readargs readargs ; struct nfsd3_writeargs writeargs ; struct nfsd3_createargs createargs ; struct nfsd3_renameargs renameargs ; struct nfsd3_linkargs linkargs ; struct nfsd3_symlinkargs symlinkargs ; struct nfsd3_readdirargs readdirargs ; struct nfsd3_diropres diropres ; struct nfsd3_accessres accessres ; struct nfsd3_readlinkres readlinkres ; struct nfsd3_readres readres ; struct nfsd3_writeres writeres ; struct nfsd3_renameres renameres ; struct nfsd3_linkres linkres ; struct nfsd3_readdirres readdirres ; struct nfsd3_fsstatres fsstatres ; struct nfsd3_fsinfores fsinfores ; struct nfsd3_pathconfres pathconfres ; struct nfsd3_commitres commitres ; struct nfsd3_getaclres getaclres ; } ;

struct raparms { struct raparms * p_next ; unsigned int p_count ; ino_t p_ino ; dev_t p_dev ; int p_set ; struct file_ra_state p_ra ; unsigned int p_hindex ; } ;

struct raparm_hbucket { struct raparms * pb_head ; spinlock_t pb_lock ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
int nfsd_cross_mnt ( struct svc_rqst * rqstp , struct dentry * * dpp , struct svc_export * * expp ) ;

__be32 nfsd_lookup_dentry ( struct svc_rqst * rqstp , struct svc_fh * fhp , const char * name , unsigned int len , struct svc_export * * exp_ret , struct dentry * * dentry_ret ) ;

__be32 nfsd_lookup ( struct svc_rqst * rqstp , struct svc_fh * fhp , const char * name , unsigned int len , struct svc_fh * resfh ) ;

__be32 nfsd_setattr ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct iattr * iap , int check_guard , time_t guardtime ) ;

__be32 nfsd4_set_nfs4_acl ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct nfs4_acl * acl ) ;

int nfsd4_get_nfs4_acl ( struct svc_rqst * rqstp , struct dentry * dentry , struct nfs4_acl * * acl ) ;

struct accessmap { u32 access ; int how ; } ;

__be32 nfsd_access ( struct svc_rqst * rqstp , struct svc_fh * fhp , u32 * access , u32 * supported ) ;

__be32 nfsd_open ( struct svc_rqst * rqstp , struct svc_fh * fhp , int type , int access , struct file * * filp ) ;

void nfsd_close ( struct file * filp ) ;

int nfsd_sync_dir ( struct dentry * dp ) ;

__be32 nfsd_read ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct file * file , loff_t offset , struct kvec * vec , int vlen , unsigned long * count ) ;

__be32 nfsd_write ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct file * file , loff_t offset , struct kvec * vec , int vlen , unsigned long * cnt , int * stablep ) ;

__be32 nfsd_commit ( struct svc_rqst * rqstp , struct svc_fh * fhp , loff_t offset , unsigned long count ) ;

__be32 nfsd_create ( struct svc_rqst * rqstp , struct svc_fh * fhp , char * fname , int flen , struct iattr * iap , int type , dev_t rdev , struct svc_fh * resfhp ) ;

__be32 nfsd_create_v3 ( struct svc_rqst * rqstp , struct svc_fh * fhp , char * fname , int flen , struct iattr * iap , struct svc_fh * resfhp , int createmode , u32 * verifier , int * truncp , int * created ) ;

__be32 nfsd_readlink ( struct svc_rqst * rqstp , struct svc_fh * fhp , char * buf , int * lenp ) ;

__be32 nfsd_symlink ( struct svc_rqst * rqstp , struct svc_fh * fhp , char * fname , int flen , char * path , int plen , struct svc_fh * resfhp , struct iattr * iap ) ;

__be32 nfsd_link ( struct svc_rqst * rqstp , struct svc_fh * ffhp , char * name , int len , struct svc_fh * tfhp ) ;

__be32 nfsd_rename ( struct svc_rqst * rqstp , struct svc_fh * ffhp , char * fname , int flen , struct svc_fh * tfhp , char * tname , int tlen ) ;

__be32 nfsd_unlink ( struct svc_rqst * rqstp , struct svc_fh * fhp , int type , char * fname , int flen ) ;

struct buffered_dirent { u64 ino ; loff_t offset ; int namlen ; unsigned int d_type ; char name [ ] ; } ;

struct readdir_data { char * dirent ; size_t used ; int full ; } ;

__be32 nfsd_readdir ( struct svc_rqst * rqstp , struct svc_fh * fhp , loff_t * offsetp , struct readdir_cd * cdp , filldir_t func ) ;

__be32 nfsd_statfs ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct kstatfs * stat , int access ) ;

__be32 nfsd_permission ( struct svc_rqst * rqstp , struct svc_export * exp , struct dentry * dentry , int acc ) ;

void nfsd_racache_shutdown ( void ) ;

int nfsd_racache_init ( int cache_size ) ;

struct posix_acl * nfsd_get_posix_acl ( struct svc_fh * fhp , int type ) ;

int nfsd_set_posix_acl ( struct svc_fh * fhp , int type , struct posix_acl * acl ) ;

typedef struct auth_domain svc_client ;

typedef struct svc_export svc_export ;

void exp_readlock ( void ) ;

void exp_readunlock ( void ) ;

int exp_export ( struct nfsctl_export * nxp ) ;

int exp_unexport ( struct nfsctl_export * nxp ) ;

int exp_rootfh ( svc_client * clp , char * name , struct knfsd_fh * f , int maxsize ) ;

__be32 check_nfsd_access ( struct svc_export * exp , struct svc_rqst * rqstp ) ;

struct svc_export * rqst_exp_get_by_name ( struct svc_rqst * rqstp , struct path * path ) ;

struct svc_export * rqst_exp_find ( struct svc_rqst * rqstp , int fsid_type , u32 * fsidv ) ;

struct svc_export * rqst_exp_parent ( struct svc_rqst * rqstp , struct path * path ) ;

__be32 exp_pseudoroot ( struct svc_rqst * rqstp , struct svc_fh * fhp ) ;


int exp_addclient ( struct nfsctl_client * ncp ) ;

int exp_delclient ( struct nfsctl_client * ncp ) ;

int nfsd_export_init ( void ) ;

void nfsd_export_flush ( void ) ;

void nfsd_export_shutdown ( void ) ;

int nfsexp_flags ( struct svc_rqst * rqstp , struct svc_export * exp ) ;

int nfsd_setuser ( struct svc_rqst * rqstp , struct svc_export * exp ) ;

void nfsd_lockd_init ( void ) ;

void nfsd_lockd_shutdown ( void ) ;

int nfsd_reply_cache_init ( void ) ;

void nfsd_reply_cache_shutdown ( void ) ;

int nfsd_cache_lookup ( struct svc_rqst * rqstp , int type ) ;

void nfsd_cache_update ( struct svc_rqst * rqstp , int cachetype , __be32 * statp ) ;

__be32 * nfs2svc_decode_fh ( __be32 * p , struct svc_fh * fhp ) ;

__be32 * nfs2svc_encode_fattr ( struct svc_rqst * rqstp , __be32 * p , struct svc_fh * fhp ) ;

int nfssvc_decode_void ( struct svc_rqst * rqstp , __be32 * p , void * dummy ) ;

int nfssvc_decode_fhandle ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_fhandle * args ) ;

int nfssvc_decode_sattrargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_sattrargs * args ) ;

int nfssvc_decode_diropargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_diropargs * args ) ;

int nfssvc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readargs * args ) ;

int nfssvc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_writeargs * args ) ;

int nfssvc_decode_createargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_createargs * args ) ;

int nfssvc_decode_renameargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_renameargs * args ) ;

int nfssvc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readlinkargs * args ) ;

int nfssvc_decode_linkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_linkargs * args ) ;

int nfssvc_decode_symlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_symlinkargs * args ) ;

int nfssvc_decode_readdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readdirargs * args ) ;

int nfssvc_encode_void ( struct svc_rqst * rqstp , __be32 * p , void * dummy ) ;

int nfssvc_encode_attrstat ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_attrstat * resp ) ;

int nfssvc_encode_diropres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_diropres * resp ) ;

int nfssvc_encode_readlinkres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readlinkres * resp ) ;

int nfssvc_encode_readres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readres * resp ) ;

int nfssvc_encode_readdirres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readdirres * resp ) ;

int nfssvc_encode_statfsres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_statfsres * resp ) ;

int nfssvc_encode_entry ( void * ccdv , const char * name , int namlen , loff_t offset , u64 ino , unsigned int d_type ) ;

int nfssvc_release_fhandle ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_fhandle * resp ) ;

void nfsd_stat_init ( void ) ;

void nfsd_stat_shutdown ( void ) ;

struct nfsd3_voidargs { int dummy ; } ;

__be32 * nfs3svc_decode_fh ( __be32 * p , struct svc_fh * fhp ) ;

__be32 * nfs3svc_encode_post_op_attr ( struct svc_rqst * rqstp , __be32 * p , struct svc_fh * fhp ) ;

void fill_post_wcc ( struct svc_fh * fhp ) ;

int nfs3svc_decode_fhandle ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_fhandle * args ) ;

int nfs3svc_decode_sattrargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_sattrargs * args ) ;

int nfs3svc_decode_diropargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_diropargs * args ) ;

int nfs3svc_decode_accessargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_accessargs * args ) ;

int nfs3svc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readargs * args ) ;

int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) ;

int nfs3svc_decode_createargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_createargs * args ) ;

int nfs3svc_decode_mkdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_createargs * args ) ;

int nfs3svc_decode_symlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_symlinkargs * args ) ;

int nfs3svc_decode_mknodargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_mknodargs * args ) ;

int nfs3svc_decode_renameargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_renameargs * args ) ;

int nfs3svc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readlinkargs * args ) ;

int nfs3svc_decode_linkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_linkargs * args ) ;

int nfs3svc_decode_readdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) ;

int nfs3svc_decode_readdirplusargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) ;

int nfs3svc_decode_commitargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_commitargs * args ) ;

int nfs3svc_encode_voidres ( struct svc_rqst * rqstp , __be32 * p , void * dummy ) ;

int nfs3svc_encode_attrstat ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_attrstat * resp ) ;

int nfs3svc_encode_wccstat ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_attrstat * resp ) ;

int nfs3svc_encode_diropres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_diropres * resp ) ;

int nfs3svc_encode_accessres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_accessres * resp ) ;

int nfs3svc_encode_readlinkres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readlinkres * resp ) ;

int nfs3svc_encode_readres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readres * resp ) ;

int nfs3svc_encode_writeres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeres * resp ) ;

int nfs3svc_encode_createres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_diropres * resp ) ;

int nfs3svc_encode_renameres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_renameres * resp ) ;

int nfs3svc_encode_linkres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_linkres * resp ) ;

int nfs3svc_encode_readdirres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirres * resp ) ;

__be32 * encode_entryplus_baggage ( struct nfsd3_readdirres * cd , __be32 * p , const char * name , int namlen ) ;

int nfs3svc_encode_entry ( void * cd , const char * name , int namlen , loff_t offset , u64 ino , unsigned int d_type ) ;

int nfs3svc_encode_entry_plus ( void * cd , const char * name , int namlen , loff_t offset , u64 ino , unsigned int d_type ) ;

int nfs3svc_encode_fsstatres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_fsstatres * resp ) ;

int nfs3svc_encode_fsinfores ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_fsinfores * resp ) ;

int nfs3svc_encode_pathconfres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_pathconfres * resp ) ;

int nfs3svc_encode_commitres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_commitres * resp ) ;

int nfs3svc_release_fhandle ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_attrstat * resp ) ;

int nfs3svc_release_fhandle2 ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_fhandle_pair * resp ) ;

typedef struct { u32 cl_boot ; u32 cl_id ; } clientid_t ;

typedef struct { u32 so_boot ; u32 so_stateownerid ; u32 so_fileid ; } stateid_opaque_t ;

typedef struct { u32 si_generation ; stateid_opaque_t si_opaque ; } stateid_t ;

struct nfsd4_cb_sequence { u32 cbs_minorversion ; struct nfs4_client * cbs_clp ; } ;

struct nfs4_delegation { struct list_head dl_perfile ; struct list_head dl_perclnt ; struct list_head dl_recall_lru ; atomic_t dl_count ; struct nfs4_client * dl_client ; struct nfs4_file * dl_file ; struct file_lock * dl_flock ; struct file * dl_vfs_file ; u32 dl_type ; time_t dl_time ; u32 dl_ident ; stateid_t dl_stateid ; struct knfsd_fh dl_fh ; int dl_retries ; } ;

struct nfs4_cb_conn { struct __kernel_sockaddr_storage cb_addr ; size_t cb_addrlen ; u32 cb_prog ; u32 cb_minorversion ; u32 cb_ident ; atomic_t cb_set ; struct rpc_clnt * cb_client ; } ;

struct nfsd4_slot { bool sl_inuse ; bool sl_cachethis ; u16 sl_opcnt ; u32 sl_seqid ; __be32 sl_status ; u32 sl_datalen ; char sl_data [ ] ; } ;

struct nfsd4_channel_attrs { u32 headerpadsz ; u32 maxreq_sz ; u32 maxresp_sz ; u32 maxresp_cached ; u32 maxops ; u32 maxreqs ; u32 nr_rdma_attrs ; u32 rdma_attrs ; } ;

struct nfsd4_create_session { clientid_t clientid ; struct nfs4_sessionid sessionid ; u32 seqid ; u32 flags ; struct nfsd4_channel_attrs fore_channel ; struct nfsd4_channel_attrs back_channel ; u32 callback_prog ; u32 uid ; u32 gid ; } ;

struct nfsd4_clid_slot { u32 sl_seqid ; __be32 sl_status ; struct nfsd4_create_session sl_cr_ses ; } ;

struct nfsd4_session { struct kref se_ref ; struct list_head se_hash ; struct list_head se_perclnt ; u32 se_flags ; struct nfs4_client * se_client ; struct nfs4_sessionid se_sessionid ; struct nfsd4_channel_attrs se_fchannel ; struct nfsd4_channel_attrs se_bchannel ; struct nfsd4_slot * se_slots [ ] ; } ;

struct nfsd4_sessionid { clientid_t clientid ; u32 sequence ; u32 reserved ; } ;

struct nfs4_client { struct list_head cl_idhash ; struct list_head cl_strhash ; struct list_head cl_openowners ; struct list_head cl_delegations ; struct list_head cl_lru ; struct xdr_netobj cl_name ; char cl_recdir [ 33 ] ; nfs4_verifier cl_verifier ; time_t cl_time ; struct __kernel_sockaddr_storage cl_addr ; u32 cl_flavor ; char * cl_principal ; struct svc_cred cl_cred ; clientid_t cl_clientid ; nfs4_verifier cl_confirm ; struct nfs4_cb_conn cl_cb_conn ; atomic_t cl_count ; u32 cl_firststate ; struct list_head cl_sessions ; struct nfsd4_clid_slot cl_cs_slot ; u32 cl_exchange_flags ; struct nfs4_sessionid cl_sessionid ; unsigned long cl_cb_slot_busy ; u32 cl_cb_seq_nr ; struct svc_xprt * cl_cb_xprt ; struct rpc_wait_queue cl_cb_waitq ; } ;

struct nfs4_client_reclaim { struct list_head cr_strhash ; char cr_recdir [ 33 ] ; } ;

struct nfs4_replay { __be32 rp_status ; unsigned int rp_buflen ; char * rp_buf ; unsigned intrp_allocated ; struct knfsd_fh rp_openfh ; char rp_ibuf [ 112 ] ; } ;

struct nfs4_stateowner { struct kref so_ref ; struct list_head so_idhash ; struct list_head so_strhash ; struct list_head so_perclient ; struct list_head so_stateids ; struct list_head so_perstateid ; struct list_head so_close_lru ; time_t so_time ; int so_is_open_owner ; u32 so_id ; struct nfs4_client * so_client ; u32 so_seqid ; struct xdr_netobj so_owner ; int so_confirmed ; struct nfs4_replay so_replay ; } ;

struct nfs4_file { atomic_t fi_ref ; struct list_head fi_hash ; struct list_head fi_stateids ; struct list_head fi_delegations ; struct inode * fi_inode ; u32 fi_id ; bool fi_had_conflict ; } ;

struct nfs4_stateid { struct list_head st_hash ; struct list_head st_perfile ; struct list_head st_perstateowner ; struct list_head st_lockowners ; struct nfs4_stateowner * st_stateowner ; struct nfs4_file * st_file ; stateid_t st_stateid ; struct file * st_vfs_file ; unsigned long st_access_bmap ; unsigned long st_deny_bmap ; struct nfs4_stateid * st_openstp ; } ;

struct nfsd4_compound_state ;

struct nfsd4_compound_state { struct svc_fh current_fh ; struct svc_fh save_fh ; struct nfs4_stateowner * replay_owner ; struct nfsd4_session * session ; struct nfsd4_slot * slot ; __be32 * datap ; size_t iovlen ; u32 minorversion ; u32 status ; } ;
struct nfsd4_change_info { u32 atomic ; bool change_supported ; u32 before_ctime_sec ; u32 before_ctime_nsec ; u64 before_change ; u32 after_ctime_sec ; u32 after_ctime_nsec ; u64 after_change ; } ;

struct nfsd4_access { u32 ac_req_access ; u32 ac_supported ; u32 ac_resp_access ; } ;

struct nfsd4_close { u32 cl_seqid ; stateid_t cl_stateid ; struct nfs4_stateowner * cl_stateowner ; } ;

struct nfsd4_commit { u64 co_offset ; u32 co_count ; nfs4_verifier co_verf ; } ;

struct nfsd4_create { u32 cr_namelen ; char * cr_name ; u32 cr_type ; union { struct { u32 namelen ; char * name ; } link ; struct { u32 specdata1 ; u32 specdata2 ; } dev ; } u ; u32 cr_bmval [ 3 ] ; struct iattr cr_iattr ; struct nfsd4_change_info cr_cinfo ; struct nfs4_acl * cr_acl ; } ;

struct nfsd4_delegreturn { stateid_t dr_stateid ; } ;

struct nfsd4_getattr { u32 ga_bmval [ 3 ] ; struct svc_fh * ga_fhp ; } ;

struct nfsd4_link { u32 li_namelen ; char * li_name ; struct nfsd4_change_info li_cinfo ; } ;

struct nfsd4_lock_denied { clientid_t ld_clientid ; struct nfs4_stateowner * ld_sop ; u64 ld_start ; u64 ld_length ; u32 ld_type ; } ;

struct nfsd4_lock { u32 lk_type ; u32 lk_reclaim ; u64 lk_offset ; u64 lk_length ; u32 lk_is_new ; union { struct { u32 open_seqid ; stateid_t open_stateid ; u32 lock_seqid ; clientid_t clientid ; struct xdr_netobj owner ; } new ; struct { stateid_t lock_stateid ; u32 lock_seqid ; } old ; } v ; union { struct { stateid_t stateid ; } ok ; struct nfsd4_lock_denied denied ; } u ; struct nfs4_stateowner * lk_replay_owner ; } ;

struct nfsd4_lockt { u32 lt_type ; clientid_t lt_clientid ; struct xdr_netobj lt_owner ; u64 lt_offset ; u64 lt_length ; struct nfs4_stateowner * lt_stateowner ; struct nfsd4_lock_denied lt_denied ; } ;

struct nfsd4_locku { u32 lu_type ; u32 lu_seqid ; stateid_t lu_stateid ; u64 lu_offset ; u64 lu_length ; struct nfs4_stateowner * lu_stateowner ; } ;

struct nfsd4_lookup { u32 lo_len ; char * lo_name ; } ;

struct nfsd4_putfh { u32 pf_fhlen ; char * pf_fhval ; } ;

struct nfsd4_open { u32 op_claim_type ; struct xdr_netobj op_fname ; u32 op_delegate_type ; stateid_t op_delegate_stateid ; u32 op_create ; u32 op_createmode ; u32 op_bmval [ 3 ] ; struct iattr iattr ; nfs4_verifier verf ; clientid_t op_clientid ; struct xdr_netobj op_owner ; u32 op_seqid ; u32 op_share_access ; u32 op_share_deny ; stateid_t op_stateid ; u32 op_recall ; struct nfsd4_change_info op_cinfo ; u32 op_rflags ; int op_truncate ; struct nfs4_stateowner * op_stateowner ; struct nfs4_acl * op_acl ; } ;

struct nfsd4_open_confirm { stateid_t oc_req_stateid ; u32 oc_seqid ; stateid_t oc_resp_stateid ; struct nfs4_stateowner * oc_stateowner ; } ;

struct nfsd4_open_downgrade { stateid_t od_stateid ; u32 od_seqid ; u32 od_share_access ; u32 od_share_deny ; struct nfs4_stateowner * od_stateowner ; } ;

struct nfsd4_read { stateid_t rd_stateid ; u64 rd_offset ; u32 rd_length ; int rd_vlen ; struct file * rd_filp ; struct svc_rqst * rd_rqstp ; struct svc_fh * rd_fhp ; } ;

struct nfsd4_readdir { u64 rd_cookie ; nfs4_verifier rd_verf ; u32 rd_dircount ; u32 rd_maxcount ; u32 rd_bmval [ 3 ] ; struct svc_rqst * rd_rqstp ; struct svc_fh * rd_fhp ; struct readdir_cd common ; __be32 * buffer ; int buflen ; __be32 * offset ; } ;

struct nfsd4_release_lockowner { clientid_t rl_clientid ; struct xdr_netobj rl_owner ; } ;

struct nfsd4_readlink { struct svc_rqst * rl_rqstp ; struct svc_fh * rl_fhp ; } ;

struct nfsd4_remove { u32 rm_namelen ; char * rm_name ; struct nfsd4_change_info rm_cinfo ; } ;

struct nfsd4_rename { u32 rn_snamelen ; char * rn_sname ; u32 rn_tnamelen ; char * rn_tname ; struct nfsd4_change_info rn_sinfo ; struct nfsd4_change_info rn_tinfo ; } ;

struct nfsd4_secinfo { u32 si_namelen ; char * si_name ; struct svc_export * si_exp ; } ;

struct nfsd4_setattr { stateid_t sa_stateid ; u32 sa_bmval [ 3 ] ; struct iattr sa_iattr ; struct nfs4_acl * sa_acl ; } ;

struct nfsd4_setclientid { nfs4_verifier se_verf ; u32 se_namelen ; char * se_name ; u32 se_callback_prog ; u32 se_callback_netid_len ; char * se_callback_netid_val ; u32 se_callback_addr_len ; char * se_callback_addr_val ; u32 se_callback_ident ; clientid_t se_clientid ; nfs4_verifier se_confirm ; } ;

struct nfsd4_setclientid_confirm { clientid_t sc_clientid ; nfs4_verifier sc_confirm ; } ;

struct nfsd4_verify { u32 ve_bmval [ 3 ] ; u32 ve_attrlen ; char * ve_attrval ; } ;

struct nfsd4_write { stateid_t wr_stateid ; u64 wr_offset ; u32 wr_stable_how ; u32 wr_buflen ; int wr_vlen ; u32 wr_bytes_written ; u32 wr_how_written ; nfs4_verifier wr_verifier ; } ;

struct nfsd4_exchange_id { nfs4_verifier verifier ; struct xdr_netobj clname ; u32 flags ; clientid_t clientid ; u32 seqid ; int spa_how ; } ;

struct nfsd4_sequence { struct nfs4_sessionid sessionid ; u32 seqid ; u32 slotid ; u32 maxslots ; u32 cachethis ; } ;

struct nfsd4_destroy_session { struct nfs4_sessionid sessionid ; } ;

struct nfsd4_op { int opnum ; __be32 status ; union { struct nfsd4_access access ; struct nfsd4_close close ; struct nfsd4_commit commit ; struct nfsd4_create create ; struct nfsd4_delegreturn delegreturn ; struct nfsd4_getattr getattr ; struct svc_fh * getfh ; struct nfsd4_link link ; struct nfsd4_lock lock ; struct nfsd4_lockt lockt ; struct nfsd4_locku locku ; struct nfsd4_lookup lookup ; struct nfsd4_verify nverify ; struct nfsd4_open open ; struct nfsd4_open_confirm open_confirm ; struct nfsd4_open_downgrade open_downgrade ; struct nfsd4_putfh putfh ; struct nfsd4_read read ; struct nfsd4_readdir readdir ; struct nfsd4_readlink readlink ; struct nfsd4_remove remove ; struct nfsd4_rename rename ; clientid_t renew ; struct nfsd4_secinfo secinfo ; struct nfsd4_setattr setattr ; struct nfsd4_setclientid setclientid ; struct nfsd4_setclientid_confirm setclientid_confirm ; struct nfsd4_verify verify ; struct nfsd4_write write ; struct nfsd4_release_lockowner release_lockowner ; struct nfsd4_exchange_id exchange_id ; struct nfsd4_create_session create_session ; struct nfsd4_destroy_session destroy_session ; struct nfsd4_sequence sequence ; } u ; struct nfs4_replay * replay ; } ;

struct nfsd4_compoundargs { __be32 * p ; __be32 * end ; struct page * * pagelist ; int pagelen ; __be32 tmp [ 8 ] ; __be32 * tmpp ; struct tmpbuf { struct tmpbuf * next ; void ( * release ) ( const void * ) ; void * buf ; } * to_free ; struct svc_rqst * rqstp ; u32 taglen ; char * tag ; u32 minorversion ; u32 opcnt ; struct nfsd4_op * ops ; struct nfsd4_op iops [ 8 ] ; } ;

struct nfsd4_compoundres { __be32 * p ; __be32 * end ; struct xdr_buf * xbuf ; struct svc_rqst * rqstp ; u32 taglen ; char * tag ; u32 opcnt ; __be32 * tagp ; struct nfsd4_compound_state cstate ; } ;

typedef __be32 ( * nfsd4op_func ) ( struct svc_rqst * , struct nfsd4_compound_state * , void * ) ;
enum nfsd4_op_flags { ALLOWED_WITHOUT_FH = 1 << 0 , ALLOWED_ON_ABSENT_FS = 2 << 0 , ALLOWED_AS_FIRST_OP = 3 << 0 , } ;

struct nfsd4_operation { nfsd4op_func op_func ; u32 op_flags ; char * op_name ; } ;

struct nfsd4_voidargs { int dummy ; } ;

typedef __be32 ( * nfsd4_dec ) ( struct nfsd4_compoundargs * argp , void * ) ;
struct nfsd4_minorversion_ops { nfsd4_dec * decoders ; int nops ; } ;

__be32 nfsd4_encode_fattr ( struct svc_fh * fhp , struct svc_export * exp , struct dentry * dentry , __be32 * buffer , int * countp , u32 * bmval , struct svc_rqst * rqstp , int ignore_crossmnt ) ;

__be32 nfsd4_encode_sequence ( struct nfsd4_compoundres * resp , int nfserr , struct nfsd4_sequence * seq ) ;

typedef __be32 ( * nfsd4_enc ) ( struct nfsd4_compoundres * , __be32 , void * ) ;
void nfsd4_encode_operation ( struct nfsd4_compoundres * resp , struct nfsd4_op * op ) ;

void nfsd4_encode_replay ( struct nfsd4_compoundres * resp , struct nfsd4_op * op ) ;

int nfs4svc_encode_voidres ( struct svc_rqst * rqstp , __be32 * p , void * dummy ) ;

void nfsd4_release_compoundargs ( struct nfsd4_compoundargs * args ) ;

int nfs4svc_decode_compoundargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd4_compoundargs * args ) ;

int nfs4svc_encode_compoundres ( struct svc_rqst * rqstp , __be32 * p , struct nfsd4_compoundres * resp ) ;

void nfs4_lock_state ( void ) ;
void nfs4_unlock_state ( void ) ;

void nfs4_put_delegation ( struct nfs4_delegation * dp ) ;

void free_session ( struct kref * kref ) ;

void put_nfs4_client ( struct nfs4_client * clp ) ;

void nfsd4_store_cache_entry ( struct nfsd4_compoundres * resp ) ;

__be32 nfsd4_replay_cache_entry ( struct nfsd4_compoundres * resp , struct nfsd4_sequence * seq ) ;

__be32 nfsd4_exchange_id ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_exchange_id * exid ) ;
__be32 nfsd4_create_session ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_create_session * cr_ses ) ;
__be32 nfsd4_destroy_session ( struct svc_rqst * r , struct nfsd4_compound_state * cstate , struct nfsd4_destroy_session * sessionid ) ;
__be32 nfsd4_sequence ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_sequence * seq ) ;
__be32 nfsd4_setclientid ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_setclientid * setclid ) ;
__be32 nfsd4_setclientid_confirm ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_setclientid_confirm * setclientid_confirm ) ;
void nfsd4_free_slabs ( void ) ;

void nfs4_free_stateowner ( struct kref * kref ) ;

__be32 nfsd4_process_open1 ( struct nfsd4_compound_state * cstate , struct nfsd4_open * open ) ;

__be32 nfsd4_process_open2 ( struct svc_rqst * rqstp , struct svc_fh * current_fh , struct nfsd4_open * open ) ;

__be32 nfsd4_renew ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , clientid_t * clid ) ;

__be32 nfs4_preprocess_stateid_op ( struct nfsd4_compound_state * cstate , stateid_t * stateid , int flags , struct file * * filpp ) ;

__be32 nfsd4_open_confirm ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_open_confirm * oc ) ;
__be32 nfsd4_open_downgrade ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_open_downgrade * od ) ;
__be32 nfsd4_close ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_close * close ) ;
__be32 nfsd4_delegreturn ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_delegreturn * dr ) ;
__be32 nfsd4_lock ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_lock * lock ) ;
__be32 nfsd4_lockt ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_lockt * lockt ) ;
__be32 nfsd4_locku ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_locku * locku ) ;
__be32 nfsd4_release_lockowner ( struct svc_rqst * rqstp , struct nfsd4_compound_state * cstate , struct nfsd4_release_lockowner * rlockowner ) ;
int nfs4_has_reclaimed_state ( const char * name , bool use_exchange_id ) ;

int nfs4_client_to_reclaim ( const char * name ) ;

__be32 nfs4_check_open_reclaim ( clientid_t * clid ) ;

int nfs4_state_init ( void ) ;

unsigned long get_nfs4_grace_period ( void ) ;

int nfs4_state_start ( void ) ;

time_t nfs4_lease_time ( void ) ;

void nfs4_state_shutdown ( void ) ;

int nfs4_reset_recoverydir ( char * recdir ) ;

char * nfs4_recoverydir ( void ) ;

void nfs4_reset_lease ( time_t leasetime ) ;

enum { PG_BUSY = 0 , PG_CLEAN , PG_NEED_COMMIT , PG_NEED_RESCHED , } ;
struct nfs_inode ;
struct nfs_page { struct list_head wb_list ; struct page * wb_page ; struct nfs_open_context * wb_context ; atomic_t wb_complete ; unsigned long wb_index ; unsigned int wb_offset , wb_pgbase , wb_bytes ; struct kref wb_kref ; unsigned long wb_flags ; struct nfs_writeverf wb_verf ; } ;
struct nfs_pageio_descriptor { struct list_head pg_list ; unsigned long pg_bytes_written ; size_t pg_count ; size_t pg_bsize ; unsigned int pg_base ; struct inode * pg_inode ; int ( * pg_doio ) ( struct inode * , struct list_head * , unsigned int , size_t , int ) ; int pg_ioflags ; int pg_error ; } ;

struct ent { struct cache_head h ; int type ; uid_t id ; char name [ 128 ] ; char authname [ 128 ] ; } ;

int nfsd_idmap_init ( void ) ;

void nfsd_idmap_shutdown ( void ) ;

struct idmap_defer_req { struct cache_req req ; struct cache_deferred_req deferred_req ; wait_queue_head_t waitq ; atomic_t count ; } ;

int nfsd_map_name_to_uid ( struct svc_rqst * rqstp , const char * name , size_t namelen , __u32 * id ) ;

int nfsd_map_name_to_gid ( struct svc_rqst * rqstp , const char * name , size_t namelen , __u32 * id ) ;

int nfsd_map_uid_to_name ( struct svc_rqst * rqstp , __u32 id , char * name ) ;

int nfsd_map_gid_to_name ( struct svc_rqst * rqstp , __u32 id , char * name ) ;

struct ace_container { struct nfs4_ace * ace ; struct list_head ace_l ; } ;

struct nfs4_acl * nfs4_acl_posix_to_nfsv4 ( struct posix_acl * pacl , struct posix_acl * dpacl , unsigned int flags ) ;

struct posix_acl_summary { unsigned short owner ; unsigned short users ; unsigned short group ; unsigned short groups ; unsigned short other ; unsigned short mask ; } ;

struct posix_ace_state { u32 allow ; u32 deny ; } ;

struct posix_user_ace_state { uid_t uid ; struct posix_ace_state perms ; } ;

struct posix_ace_state_array { int n ; struct posix_user_ace_state aces [ ] ; } ;

struct posix_acl_state { int empty ; struct posix_ace_state owner ; struct posix_ace_state group ; struct posix_ace_state other ; struct posix_ace_state everyone ; struct posix_ace_state mask ; struct posix_ace_state_array * users ; struct posix_ace_state_array * groups ; } ;

int nfs4_acl_nfsv4_to_posix ( struct nfs4_acl * acl , struct posix_acl * * pacl , struct posix_acl * * dpacl , unsigned int flags ) ;

struct nfs4_acl * nfs4_acl_new ( int n ) ;

int nfs4_acl_get_whotype ( char * p , u32 len ) ;

int nfs4_acl_write_who ( int who , char * p ) ;

enum { NFSPROC4_CLNT_CB_NULL = 0 , NFSPROC4_CLNT_CB_RECALL , NFSPROC4_CLNT_CB_SEQUENCE , } ;
enum nfs_cb_opnum4 { OP_CB_RECALL = 4 , OP_CB_SEQUENCE = 11 , } ;

struct nfs4_rpc_args { void * args_op ; struct nfsd4_cb_sequence args_seq ; } ;

struct nfs4_cb_compound_hdr { u32 ident ; u32 nops ; __be32 * nops_p ; u32 minorversion ; int status ; u32 taglen ; char * tag ; } ;

int setup_callback_client ( struct nfs4_client * clp ) ;

int set_callback_cred ( void ) ;

void do_probe_callback ( struct nfs4_client * clp ) ;

void nfsd4_probe_callback ( struct nfs4_client * clp ) ;

void nfsd4_cb_recall ( struct nfs4_delegation * dp ) ;

__be32 nfs4_make_rec_clidname ( char * dname , struct xdr_netobj * clname ) ;

int nfsd4_create_clid_dir ( struct nfs4_client * clp ) ;

typedef int ( recdir_func ) ( struct dentry * , struct dentry * ) ;
struct name_list { char name [ 33 ] ; struct list_head list ; } ;

void nfsd4_remove_clid_dir ( struct nfs4_client * clp ) ;

void nfsd4_recdir_purge_old ( void ) ;

int nfsd4_recdir_load ( void ) ;

void nfsd4_init_recdir ( char * rec_dirname ) ;

void nfsd4_shutdown_recdir ( void ) ;

struct utf8_table { int cmask ; int cval ; int shift ; long lmask ; long lval ; } ;

int utf8_to_utf32 ( const u8 * s , int len , unicode_t * pu ) ;

int utf32_to_utf8 ( unicode_t u , u8 * s , int maxlen ) ;

int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) ;

int utf16s_to_utf8s ( const wchar_t * pwcs , int len , enum utf16_endian endian , u8 * s , int maxlen ) ;

int register_nls ( struct nls_table * nls ) ;

int unregister_nls ( struct nls_table * nls ) ;

struct nls_table * load_nls ( char * charset ) ;

void unload_nls ( struct nls_table * nls ) ;

struct nls_table * load_nls_default ( void ) ;

void __fsnotify_inode_delete ( struct inode * inode ) ;

void __fsnotify_update_child_dentry_flags ( struct inode * inode ) ;

void __fsnotify_parent ( struct dentry * dentry , __u32 mask ) ;

void fsnotify ( struct inode * to_tell , __u32 mask , void * data , int data_is , const char * file_name , u32 cookie ) ;

u32 fsnotify_get_cookie ( void ) ;

bool fsnotify_notify_queue_is_empty ( struct fsnotify_group * group ) ;

void fsnotify_get_event ( struct fsnotify_event * event ) ;

void fsnotify_put_event ( struct fsnotify_event * event ) ;

struct fsnotify_event_holder * fsnotify_alloc_event_holder ( void ) ;

void fsnotify_destroy_event_holder ( struct fsnotify_event_holder * holder ) ;

struct fsnotify_event_private_data * fsnotify_remove_priv_from_event ( struct fsnotify_group * group , struct fsnotify_event * event ) ;

int fsnotify_add_notify_event ( struct fsnotify_group * group , struct fsnotify_event * event , struct fsnotify_event_private_data * priv ) ;

struct fsnotify_event * fsnotify_remove_notify_event ( struct fsnotify_group * group ) ;

struct fsnotify_event * fsnotify_peek_notify_event ( struct fsnotify_group * group ) ;

void fsnotify_flush_notify ( struct fsnotify_group * group ) ;

struct fsnotify_event * fsnotify_create_event ( struct inode * to_tell , __u32 mask , void * data , int data_type , const char * name , u32 cookie , gfp_t gfp ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) int fsnotify_notification_init ( void ) ;

void fsnotify_recalc_global_mask ( void ) ;

void fsnotify_recalc_group_mask ( struct fsnotify_group * group ) ;

void fsnotify_final_destroy_group ( struct fsnotify_group * group ) ;

void fsnotify_evict_group ( struct fsnotify_group * group ) ;

void fsnotify_put_group ( struct fsnotify_group * group ) ;

struct fsnotify_group * fsnotify_obtain_group ( unsigned int group_num , __u32 mask , const struct fsnotify_ops * ops ) ;

void fsnotify_get_mark ( struct fsnotify_mark_entry * entry ) ;

void fsnotify_put_mark ( struct fsnotify_mark_entry * entry ) ;

void fsnotify_recalc_inode_mask ( struct inode * inode ) ;

void fsnotify_destroy_mark_by_entry ( struct fsnotify_mark_entry * entry ) ;

void fsnotify_clear_marks_by_group ( struct fsnotify_group * group ) ;

void fsnotify_clear_marks_by_inode ( struct inode * inode ) ;

struct fsnotify_mark_entry * fsnotify_find_mark_entry ( struct fsnotify_group * group , struct inode * inode ) ;

void fsnotify_init_mark ( struct fsnotify_mark_entry * entry , void ( * free_mark ) ( struct fsnotify_mark_entry * entry ) ) ;

int fsnotify_add_mark ( struct fsnotify_mark_entry * entry , struct fsnotify_group * group , struct inode * inode ) ;

void fsnotify_unmount_inodes ( struct list_head * list ) ;

struct dnotify_mark_entry { struct fsnotify_mark_entry fsn_entry ; struct dnotify_struct * dn ; } ;

void dnotify_flush ( struct file * filp , fl_owner_t id ) ;

int fcntl_dirnotify ( int fd , struct file * filp , unsigned long arg ) ;

struct inotify_handle { struct idr idr ; struct mutex mutex ; struct list_head watches ; atomic_t count ; u32 last_wd ; const struct inotify_operations * in_ops ; } ;

void get_inotify_watch ( struct inotify_watch * watch ) ;

int pin_inotify_watch ( struct inotify_watch * watch ) ;

void put_inotify_watch ( struct inotify_watch * watch ) ;

void unpin_inotify_watch ( struct inotify_watch * watch ) ;

void inotify_remove_watch_locked ( struct inotify_handle * ih , struct inotify_watch * watch ) ;

void inotify_d_instantiate ( struct dentry * entry , struct inode * inode ) ;

void inotify_d_move ( struct dentry * entry ) ;

void inotify_inode_queue_event ( struct inode * inode , u32 mask , u32 cookie , const char * name , struct inode * n_inode ) ;

void inotify_dentry_parent_queue_event ( struct dentry * dentry , u32 mask , u32 cookie , const char * name ) ;

u32 inotify_get_cookie ( void ) ;

void inotify_unmount_inodes ( struct list_head * list ) ;

void inotify_inode_is_dead ( struct inode * inode ) ;

struct inotify_handle * inotify_init ( const struct inotify_operations * ops ) ;

void inotify_init_watch ( struct inotify_watch * watch ) ;

void inotify_destroy ( struct inotify_handle * ih ) ;

s32 inotify_find_watch ( struct inotify_handle * ih , struct inode * inode , struct inotify_watch * * watchp ) ;

s32 inotify_find_update_watch ( struct inotify_handle * ih , struct inode * inode , u32 mask ) ;

s32 inotify_add_watch ( struct inotify_handle * ih , struct inotify_watch * watch , struct inode * inode , u32 mask ) ;

s32 inotify_clone_watch ( struct inotify_watch * old , struct inotify_watch * new ) ;

void inotify_evict_watch ( struct inotify_watch * watch ) ;

int inotify_rm_wd ( struct inotify_handle * ih , u32 wd ) ;

int inotify_rm_watch ( struct inotify_handle * ih , struct inotify_watch * watch ) ;

struct inotify_event_private_data { struct fsnotify_event_private_data fsnotify_event_priv_data ; int wd ; } ;

struct inotify_inode_mark_entry { struct fsnotify_mark_entry fsn_entry ; int wd ; } ;

void inotify_free_event_priv ( struct fsnotify_event_private_data * fsn_event_priv ) ;

void inotify_ignored_and_remove_idr ( struct fsnotify_mark_entry * entry , struct fsnotify_group * group ) ;

long sys_inotify_init1 ( int flags ) ;

long sys_inotify_init ( void ) ;

long sys_inotify_add_watch ( int fd , const char * pathname , u32 mask ) ;

long sys_inotify_rm_watch ( int fd , __s32 wd ) ;

typedef __le16 le16 ;

typedef __le32 le32 ;

typedef __le64 le64 ;

typedef __u16 sle16 ;

typedef __u32 sle32 ;

typedef __u64 sle64 ;

typedef le16 ntfschar ;

typedef s64 VCN ;

typedef sle64 leVCN ;

typedef s64 LCN ;

typedef sle64 leLCN ;

typedef s64 LSN ;

typedef sle64 leLSN ;

typedef s64 USN ;

typedef sle64 leUSN ;

typedef enum { CASE_SENSITIVE = 0 , IGNORE_CASE = 1 , } IGNORE_CASE_BOOL ;

typedef struct { le16 bytes_per_sector ; u8 sectors_per_cluster ; le16 reserved_sectors ; u8 fats ; le16 root_entries ; le16 sectors ; u8 media_type ; le16 sectors_per_fat ; le16 sectors_per_track ; le16 heads ; le32 hidden_sectors ; le32 large_sectors ; } __attribute__ ( ( __packed__ ) ) BIOS_PARAMETER_BLOCK ;

typedef struct { u8 jump [ 3 ] ; le64 oem_id ; BIOS_PARAMETER_BLOCK bpb ; u8 unused [ 4 ] ; sle64 number_of_sectors ; sle64 mft_lcn ; sle64 mftmirr_lcn ; s8 clusters_per_mft_record ; u8 reserved0 [ 3 ] ; s8 clusters_per_index_record ; u8 reserved1 [ 3 ] ; le64 volume_serial_number ; le32 checksum ; u8 bootstrap [ 426 ] ; le16 end_of_sector_marker ; } __attribute__ ( ( __packed__ ) ) NTFS_BOOT_SECTOR ;

enum { magic_FILE = ( ( __le32 ) ( __u32 ) ( 0x454c4946 ) ) , magic_INDX = ( ( __le32 ) ( __u32 ) ( 0x58444e49 ) ) , magic_HOLE = ( ( __le32 ) ( __u32 ) ( 0x454c4f48 ) ) , magic_RSTR = ( ( __le32 ) ( __u32 ) ( 0x52545352 ) ) , magic_RCRD = ( ( __le32 ) ( __u32 ) ( 0x44524352 ) ) , magic_CHKD = ( ( __le32 ) ( __u32 ) ( 0x444b4843 ) ) , magic_BAAD = ( ( __le32 ) ( __u32 ) ( 0x44414142 ) ) , magic_empty = ( ( __le32 ) ( __u32 ) ( 0xffffffff ) ) } ;
typedef le32 NTFS_RECORD_TYPE ;

typedef struct { NTFS_RECORD_TYPE magic ; le16 usa_ofs ; le16 usa_count ; } __attribute__ ( ( __packed__ ) ) NTFS_RECORD ;

typedef enum { FILE_MFT = 0 , FILE_MFTMirr = 1 , FILE_LogFile = 2 , FILE_Volume = 3 , FILE_AttrDef = 4 , FILE_root = 5 , FILE_Bitmap = 6 , FILE_Boot = 7 , FILE_BadClus = 8 , FILE_Secure = 9 , FILE_UpCase = 10 , FILE_Extend = 11 , FILE_reserved12 = 12 , FILE_reserved13 = 13 , FILE_reserved14 = 14 , FILE_reserved15 = 15 , FILE_first_user = 16 , } NTFS_SYSTEM_FILES ;

enum { MFT_RECORD_IN_USE = ( ( __le16 ) ( __u16 ) ( 0x0001 ) ) , MFT_RECORD_IS_DIRECTORY = ( ( __le16 ) ( __u16 ) ( 0x0002 ) ) , } __attribute__ ( ( __packed__ ) ) ;
typedef le16 MFT_RECORD_FLAGS ;

typedef u64 MFT_REF ;

typedef le64 leMFT_REF ;

typedef struct { NTFS_RECORD_TYPE magic ; le16 usa_ofs ; le16 usa_count ; le64 lsn ; le16 sequence_number ; le16 link_count ; le16 attrs_offset ; MFT_RECORD_FLAGS flags ; le32 bytes_in_use ; le32 bytes_allocated ; leMFT_REF base_mft_record ; le16 next_attr_instance ; le16 reserved ; le32 mft_record_number ; } __attribute__ ( ( __packed__ ) ) MFT_RECORD ;

typedef struct { NTFS_RECORD_TYPE magic ; le16 usa_ofs ; le16 usa_count ; le64 lsn ; le16 sequence_number ; le16 link_count ; le16 attrs_offset ; MFT_RECORD_FLAGS flags ; le32 bytes_in_use ; le32 bytes_allocated ; leMFT_REF base_mft_record ; le16 next_attr_instance ; } __attribute__ ( ( __packed__ ) ) MFT_RECORD_OLD ;

enum { AT_UNUSED = ( ( __le32 ) ( __u32 ) ( 0 ) ) , AT_STANDARD_INFORMATION = ( ( __le32 ) ( __u32 ) ( 0x10 ) ) , AT_ATTRIBUTE_LIST = ( ( __le32 ) ( __u32 ) ( 0x20 ) ) , AT_FILE_NAME = ( ( __le32 ) ( __u32 ) ( 0x30 ) ) , AT_OBJECT_ID = ( ( __le32 ) ( __u32 ) ( 0x40 ) ) , AT_SECURITY_DESCRIPTOR = ( ( __le32 ) ( __u32 ) ( 0x50 ) ) , AT_VOLUME_NAME = ( ( __le32 ) ( __u32 ) ( 0x60 ) ) , AT_VOLUME_INFORMATION = ( ( __le32 ) ( __u32 ) ( 0x70 ) ) , AT_DATA = ( ( __le32 ) ( __u32 ) ( 0x80 ) ) , AT_INDEX_ROOT = ( ( __le32 ) ( __u32 ) ( 0x90 ) ) , AT_INDEX_ALLOCATION = ( ( __le32 ) ( __u32 ) ( 0xa0 ) ) , AT_BITMAP = ( ( __le32 ) ( __u32 ) ( 0xb0 ) ) , AT_REPARSE_POINT = ( ( __le32 ) ( __u32 ) ( 0xc0 ) ) , AT_EA_INFORMATION = ( ( __le32 ) ( __u32 ) ( 0xd0 ) ) , AT_EA = ( ( __le32 ) ( __u32 ) ( 0xe0 ) ) , AT_PROPERTY_SET = ( ( __le32 ) ( __u32 ) ( 0xf0 ) ) , AT_LOGGED_UTILITY_STREAM = ( ( __le32 ) ( __u32 ) ( 0x100 ) ) , AT_FIRST_USER_DEFINED_ATTRIBUTE = ( ( __le32 ) ( __u32 ) ( 0x1000 ) ) , AT_END = ( ( __le32 ) ( __u32 ) ( 0xffffffff ) ) } ;
typedef le32 ATTR_TYPE ;

enum { COLLATION_BINARY = ( ( __le32 ) ( __u32 ) ( 0x00 ) ) , COLLATION_FILE_NAME = ( ( __le32 ) ( __u32 ) ( 0x01 ) ) , COLLATION_UNICODE_STRING = ( ( __le32 ) ( __u32 ) ( 0x02 ) ) , COLLATION_NTOFS_ULONG = ( ( __le32 ) ( __u32 ) ( 0x10 ) ) , COLLATION_NTOFS_SID = ( ( __le32 ) ( __u32 ) ( 0x11 ) ) , COLLATION_NTOFS_SECURITY_HASH = ( ( __le32 ) ( __u32 ) ( 0x12 ) ) , COLLATION_NTOFS_ULONGS = ( ( __le32 ) ( __u32 ) ( 0x13 ) ) , } ;
typedef le32 COLLATION_RULE ;

enum { ATTR_DEF_INDEXABLE = ( ( __le32 ) ( __u32 ) ( 0x02 ) ) , ATTR_DEF_MULTIPLE = ( ( __le32 ) ( __u32 ) ( 0x04 ) ) , ATTR_DEF_NOT_ZERO = ( ( __le32 ) ( __u32 ) ( 0x08 ) ) , ATTR_DEF_INDEXED_UNIQUE = ( ( __le32 ) ( __u32 ) ( 0x10 ) ) , ATTR_DEF_NAMED_UNIQUE = ( ( __le32 ) ( __u32 ) ( 0x20 ) ) , ATTR_DEF_RESIDENT = ( ( __le32 ) ( __u32 ) ( 0x40 ) ) , ATTR_DEF_ALWAYS_LOG = ( ( __le32 ) ( __u32 ) ( 0x80 ) ) , } ;
typedef le32 ATTR_DEF_FLAGS ;

typedef struct { ntfschar name [ 0x40 ] ; ATTR_TYPE type ; le32 display_rule ; COLLATION_RULE collation_rule ; ATTR_DEF_FLAGS flags ; sle64 min_size ; sle64 max_size ; } __attribute__ ( ( __packed__ ) ) ATTR_DEF ;

enum { ATTR_IS_COMPRESSED = ( ( __le16 ) ( __u16 ) ( 0x0001 ) ) , ATTR_COMPRESSION_MASK = ( ( __le16 ) ( __u16 ) ( 0x00ff ) ) , ATTR_IS_ENCRYPTED = ( ( __le16 ) ( __u16 ) ( 0x4000 ) ) , ATTR_IS_SPARSE = ( ( __le16 ) ( __u16 ) ( 0x8000 ) ) , } __attribute__ ( ( __packed__ ) ) ;
typedef le16 ATTR_FLAGS ;

enum { RESIDENT_ATTR_IS_INDEXED = 0x01 , } __attribute__ ( ( __packed__ ) ) ;
typedef u8 RESIDENT_ATTR_FLAGS ;

typedef struct { ATTR_TYPE type ; le32 length ; u8 non_resident ; u8 name_length ; le16 name_offset ; ATTR_FLAGS flags ; le16 instance ; union { struct { le32 value_length ; le16 value_offset ; RESIDENT_ATTR_FLAGS flags ; s8 reserved ; } __attribute__ ( ( __packed__ ) ) resident ; struct { leVCN lowest_vcn ; leVCN highest_vcn ; le16 mapping_pairs_offset ; u8 compression_unit ; u8 reserved [ 5 ] ; sle64 allocated_size ; sle64 data_size ; sle64 initialized_size ; sle64 compressed_size ; } __attribute__ ( ( __packed__ ) ) non_resident ; } __attribute__ ( ( __packed__ ) ) data ; } __attribute__ ( ( __packed__ ) ) ATTR_RECORD ;

typedef ATTR_RECORD ATTR_REC ;

enum { FILE_ATTR_READONLY = ( ( __le32 ) ( __u32 ) ( 0x00000001 ) ) , FILE_ATTR_HIDDEN = ( ( __le32 ) ( __u32 ) ( 0x00000002 ) ) , FILE_ATTR_SYSTEM = ( ( __le32 ) ( __u32 ) ( 0x00000004 ) ) , FILE_ATTR_DIRECTORY = ( ( __le32 ) ( __u32 ) ( 0x00000010 ) ) , FILE_ATTR_ARCHIVE = ( ( __le32 ) ( __u32 ) ( 0x00000020 ) ) , FILE_ATTR_DEVICE = ( ( __le32 ) ( __u32 ) ( 0x00000040 ) ) , FILE_ATTR_NORMAL = ( ( __le32 ) ( __u32 ) ( 0x00000080 ) ) , FILE_ATTR_TEMPORARY = ( ( __le32 ) ( __u32 ) ( 0x00000100 ) ) , FILE_ATTR_SPARSE_FILE = ( ( __le32 ) ( __u32 ) ( 0x00000200 ) ) , FILE_ATTR_REPARSE_POINT = ( ( __le32 ) ( __u32 ) ( 0x00000400 ) ) , FILE_ATTR_COMPRESSED = ( ( __le32 ) ( __u32 ) ( 0x00000800 ) ) , FILE_ATTR_OFFLINE = ( ( __le32 ) ( __u32 ) ( 0x00001000 ) ) , FILE_ATTR_NOT_CONTENT_INDEXED = ( ( __le32 ) ( __u32 ) ( 0x00002000 ) ) , FILE_ATTR_ENCRYPTED = ( ( __le32 ) ( __u32 ) ( 0x00004000 ) ) , FILE_ATTR_VALID_FLAGS = ( ( __le32 ) ( __u32 ) ( 0x00007fb7 ) ) , FILE_ATTR_VALID_SET_FLAGS = ( ( __le32 ) ( __u32 ) ( 0x000031a7 ) ) , FILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT = ( ( __le32 ) ( __u32 ) ( 0x10000000 ) ) , FILE_ATTR_DUP_VIEW_INDEX_PRESENT = ( ( __le32 ) ( __u32 ) ( 0x20000000 ) ) , } ;
typedef le32 FILE_ATTR_FLAGS ;

typedef struct { sle64 creation_time ; sle64 last_data_change_time ; sle64 last_mft_change_time ; sle64 last_access_time ; FILE_ATTR_FLAGS file_attributes ; union { struct { u8 reserved12 [ 12 ] ; } __attribute__ ( ( __packed__ ) ) v1 ; struct { le32 maximum_versions ; le32 version_number ; le32 class_id ; le32 owner_id ; le32 security_id ; le64 quota_charged ; leUSN usn ; } __attribute__ ( ( __packed__ ) ) v3 ; } __attribute__ ( ( __packed__ ) ) ver ; } __attribute__ ( ( __packed__ ) ) STANDARD_INFORMATION ;

typedef struct { ATTR_TYPE type ; le16 length ; u8 name_length ; u8 name_offset ; leVCN lowest_vcn ; leMFT_REF mft_reference ; le16 instance ; ntfschar name [ 0 ] ; } __attribute__ ( ( __packed__ ) ) ATTR_LIST_ENTRY ;

enum { FILE_NAME_POSIX = 0x00 , FILE_NAME_WIN32 = 0x01 , FILE_NAME_DOS = 0x02 , FILE_NAME_WIN32_AND_DOS = 0x03 , } __attribute__ ( ( __packed__ ) ) ;
typedef u8 FILE_NAME_TYPE_FLAGS ;

typedef struct { leMFT_REF parent_directory ; sle64 creation_time ; sle64 last_data_change_time ; sle64 last_mft_change_time ; sle64 last_access_time ; sle64 allocated_size ; sle64 data_size ; FILE_ATTR_FLAGS file_attributes ; union { struct { le16 packed_ea_size ; le16 reserved ; } __attribute__ ( ( __packed__ ) ) ea ; struct { le32 reparse_point_tag ; } __attribute__ ( ( __packed__ ) ) rp ; } __attribute__ ( ( __packed__ ) ) type ; u8 file_name_length ; FILE_NAME_TYPE_FLAGS file_name_type ; ntfschar file_name [ 0 ] ; } __attribute__ ( ( __packed__ ) ) FILE_NAME_ATTR ;

typedef struct { le32 data1 ; le16 data2 ; le16 data3 ; u8 data4 [ 8 ] ; } __attribute__ ( ( __packed__ ) ) GUID ;

typedef struct { leMFT_REF mft_reference ; union { struct { GUID birth_volume_id ; GUID birth_object_id ; GUID domain_id ; } __attribute__ ( ( __packed__ ) ) origin ; u8 extended_info [ 48 ] ; } __attribute__ ( ( __packed__ ) ) opt ; } __attribute__ ( ( __packed__ ) ) OBJ_ID_INDEX_DATA ;

typedef struct { GUID object_id ; union { struct { GUID birth_volume_id ; GUID birth_object_id ; GUID domain_id ; } __attribute__ ( ( __packed__ ) ) origin ; u8 extended_info [ 48 ] ; } __attribute__ ( ( __packed__ ) ) opt ; } __attribute__ ( ( __packed__ ) ) OBJECT_ID_ATTR ;

typedef enum { SECURITY_NULL_RID = 0 , SECURITY_WORLD_RID = 0 , SECURITY_LOCAL_RID = 0 , SECURITY_CREATOR_OWNER_RID = 0 , SECURITY_CREATOR_GROUP_RID = 1 , SECURITY_CREATOR_OWNER_SERVER_RID = 2 , SECURITY_CREATOR_GROUP_SERVER_RID = 3 , SECURITY_DIALUP_RID = 1 , SECURITY_NETWORK_RID = 2 , SECURITY_BATCH_RID = 3 , SECURITY_INTERACTIVE_RID = 4 , SECURITY_SERVICE_RID = 6 , SECURITY_ANONYMOUS_LOGON_RID = 7 , SECURITY_PROXY_RID = 8 , SECURITY_ENTERPRISE_CONTROLLERS_RID = 9 , SECURITY_SERVER_LOGON_RID = 9 , SECURITY_PRINCIPAL_SELF_RID = 0xa , SECURITY_AUTHENTICATED_USER_RID = 0xb , SECURITY_RESTRICTED_CODE_RID = 0xc , SECURITY_TERMINAL_SERVER_RID = 0xd , SECURITY_LOGON_IDS_RID = 5 , SECURITY_LOGON_IDS_RID_COUNT = 3 , SECURITY_LOCAL_SYSTEM_RID = 0x12 , SECURITY_NT_NON_UNIQUE = 0x15 , SECURITY_BUILTIN_DOMAIN_RID = 0x20 , DOMAIN_USER_RID_ADMIN = 0x1f4 , DOMAIN_USER_RID_GUEST = 0x1f5 , DOMAIN_USER_RID_KRBTGT = 0x1f6 , DOMAIN_GROUP_RID_ADMINS = 0x200 , DOMAIN_GROUP_RID_USERS = 0x201 , DOMAIN_GROUP_RID_GUESTS = 0x202 , DOMAIN_GROUP_RID_COMPUTERS = 0x203 , DOMAIN_GROUP_RID_CONTROLLERS = 0x204 , DOMAIN_GROUP_RID_CERT_ADMINS = 0x205 , DOMAIN_GROUP_RID_SCHEMA_ADMINS = 0x206 , DOMAIN_GROUP_RID_ENTERPRISE_ADMINS = 0x207 , DOMAIN_GROUP_RID_POLICY_ADMINS = 0x208 , DOMAIN_ALIAS_RID_ADMINS = 0x220 , DOMAIN_ALIAS_RID_USERS = 0x221 , DOMAIN_ALIAS_RID_GUESTS = 0x222 , DOMAIN_ALIAS_RID_POWER_USERS = 0x223 , DOMAIN_ALIAS_RID_ACCOUNT_OPS = 0x224 , DOMAIN_ALIAS_RID_SYSTEM_OPS = 0x225 , DOMAIN_ALIAS_RID_PRINT_OPS = 0x226 , DOMAIN_ALIAS_RID_BACKUP_OPS = 0x227 , DOMAIN_ALIAS_RID_REPLICATOR = 0x228 , DOMAIN_ALIAS_RID_RAS_SERVERS = 0x229 , DOMAIN_ALIAS_RID_PREW2KCOMPACCESS = 0x22a , } RELATIVE_IDENTIFIERS ;

typedef union { struct { u16 high_part ; u32 low_part ; } __attribute__ ( ( __packed__ ) ) parts ; u8 value [ 6 ] ; } __attribute__ ( ( __packed__ ) ) SID_IDENTIFIER_AUTHORITY ;

typedef struct { u8 revision ; u8 sub_authority_count ; SID_IDENTIFIER_AUTHORITY identifier_authority ; le32 sub_authority [ 1 ] ; } __attribute__ ( ( __packed__ ) ) SID ;

typedef enum { SID_REVISION = 1 , SID_MAX_SUB_AUTHORITIES = 15 , SID_RECOMMENDED_SUB_AUTHORITIES = 1 , } SID_CONSTANTS ;

enum { ACCESS_MIN_MS_ACE_TYPE = 0 , ACCESS_ALLOWED_ACE_TYPE = 0 , ACCESS_DENIED_ACE_TYPE = 1 , SYSTEM_AUDIT_ACE_TYPE = 2 , SYSTEM_ALARM_ACE_TYPE = 3 , ACCESS_MAX_MS_V2_ACE_TYPE = 3 , ACCESS_ALLOWED_COMPOUND_ACE_TYPE = 4 , ACCESS_MAX_MS_V3_ACE_TYPE = 4 , ACCESS_MIN_MS_OBJECT_ACE_TYPE = 5 , ACCESS_ALLOWED_OBJECT_ACE_TYPE = 5 , ACCESS_DENIED_OBJECT_ACE_TYPE = 6 , SYSTEM_AUDIT_OBJECT_ACE_TYPE = 7 , SYSTEM_ALARM_OBJECT_ACE_TYPE = 8 , ACCESS_MAX_MS_OBJECT_ACE_TYPE = 8 , ACCESS_MAX_MS_V4_ACE_TYPE = 8 , ACCESS_MAX_MS_ACE_TYPE = 8 , } __attribute__ ( ( __packed__ ) ) ;
typedef u8 ACE_TYPES ;

enum { OBJECT_INHERIT_ACE = 0x01 , CONTAINER_INHERIT_ACE = 0x02 , NO_PROPAGATE_INHERIT_ACE = 0x04 , INHERIT_ONLY_ACE = 0x08 , INHERITED_ACE = 0x10 , VALID_INHERIT_FLAGS = 0x1f , SUCCESSFUL_ACCESS_ACE_FLAG = 0x40 , FAILED_ACCESS_ACE_FLAG = 0x80 , } __attribute__ ( ( __packed__ ) ) ;
typedef u8 ACE_FLAGS ;

typedef struct { ACE_TYPES type ; ACE_FLAGS flags ; le16 size ; } __attribute__ ( ( __packed__ ) ) ACE_HEADER ;

enum { FILE_READ_DATA = ( ( __le32 ) ( __u32 ) ( 0x00000001 ) ) , FILE_LIST_DIRECTORY = ( ( __le32 ) ( __u32 ) ( 0x00000001 ) ) , FILE_WRITE_DATA = ( ( __le32 ) ( __u32 ) ( 0x00000002 ) ) , FILE_ADD_FILE = ( ( __le32 ) ( __u32 ) ( 0x00000002 ) ) , FILE_APPEND_DATA = ( ( __le32 ) ( __u32 ) ( 0x00000004 ) ) , FILE_ADD_SUBDIRECTORY = ( ( __le32 ) ( __u32 ) ( 0x00000004 ) ) , FILE_READ_EA = ( ( __le32 ) ( __u32 ) ( 0x00000008 ) ) , FILE_WRITE_EA = ( ( __le32 ) ( __u32 ) ( 0x00000010 ) ) , FILE_EXECUTE = ( ( __le32 ) ( __u32 ) ( 0x00000020 ) ) , FILE_TRAVERSE = ( ( __le32 ) ( __u32 ) ( 0x00000020 ) ) , FILE_DELETE_CHILD = ( ( __le32 ) ( __u32 ) ( 0x00000040 ) ) , FILE_READ_ATTRIBUTES = ( ( __le32 ) ( __u32 ) ( 0x00000080 ) ) , FILE_WRITE_ATTRIBUTES = ( ( __le32 ) ( __u32 ) ( 0x00000100 ) ) , DELETE = ( ( __le32 ) ( __u32 ) ( 0x00010000 ) ) , READ_CONTROL = ( ( __le32 ) ( __u32 ) ( 0x00020000 ) ) , WRITE_DAC = ( ( __le32 ) ( __u32 ) ( 0x00040000 ) ) , WRITE_OWNER = ( ( __le32 ) ( __u32 ) ( 0x00080000 ) ) , SYNCHRONIZE = ( ( __le32 ) ( __u32 ) ( 0x00100000 ) ) , STANDARD_RIGHTS_READ = ( ( __le32 ) ( __u32 ) ( 0x00020000 ) ) , STANDARD_RIGHTS_WRITE = ( ( __le32 ) ( __u32 ) ( 0x00020000 ) ) , STANDARD_RIGHTS_EXECUTE = ( ( __le32 ) ( __u32 ) ( 0x00020000 ) ) , STANDARD_RIGHTS_REQUIRED = ( ( __le32 ) ( __u32 ) ( 0x000f0000 ) ) , STANDARD_RIGHTS_ALL = ( ( __le32 ) ( __u32 ) ( 0x001f0000 ) ) , ACCESS_SYSTEM_SECURITY = ( ( __le32 ) ( __u32 ) ( 0x01000000 ) ) , MAXIMUM_ALLOWED = ( ( __le32 ) ( __u32 ) ( 0x02000000 ) ) , GENERIC_ALL = ( ( __le32 ) ( __u32 ) ( 0x10000000 ) ) , GENERIC_EXECUTE = ( ( __le32 ) ( __u32 ) ( 0x20000000 ) ) , GENERIC_WRITE = ( ( __le32 ) ( __u32 ) ( 0x40000000 ) ) , GENERIC_READ = ( ( __le32 ) ( __u32 ) ( 0x80000000 ) ) , } ;
typedef le32 ACCESS_MASK ;

typedef struct { ACCESS_MASK generic_read ; ACCESS_MASK generic_write ; ACCESS_MASK generic_execute ; ACCESS_MASK generic_all ; } __attribute__ ( ( __packed__ ) ) GENERIC_MAPPING ;

typedef struct { ACE_TYPES type ; ACE_FLAGS flags ; le16 size ; ACCESS_MASK mask ; SID sid ; } __attribute__ ( ( __packed__ ) ) ACCESS_ALLOWED_ACE , ACCESS_DENIED_ACE , SYSTEM_AUDIT_ACE , SYSTEM_ALARM_ACE ;

enum { ACE_OBJECT_TYPE_PRESENT = ( ( __le32 ) ( __u32 ) ( 1 ) ) , ACE_INHERITED_OBJECT_TYPE_PRESENT = ( ( __le32 ) ( __u32 ) ( 2 ) ) , } ;
typedef le32 OBJECT_ACE_FLAGS ;

typedef struct { ACE_TYPES type ; ACE_FLAGS flags ; le16 size ; ACCESS_MASK mask ; OBJECT_ACE_FLAGS object_flags ; GUID object_type ; GUID inherited_object_type ; SID sid ; } __attribute__ ( ( __packed__ ) ) ACCESS_ALLOWED_OBJECT_ACE , ACCESS_DENIED_OBJECT_ACE , SYSTEM_AUDIT_OBJECT_ACE , SYSTEM_ALARM_OBJECT_ACE ;

typedef struct { u8 revision ; u8 alignment1 ; le16 size ; le16 ace_count ; le16 alignment2 ; } __attribute__ ( ( __packed__ ) ) ACL ;

typedef enum { ACL_REVISION = 2 , ACL_REVISION_DS = 4 , ACL_REVISION1 = 1 , MIN_ACL_REVISION = 2 , ACL_REVISION2 = 2 , ACL_REVISION3 = 3 , ACL_REVISION4 = 4 , MAX_ACL_REVISION = 4 , } ACL_CONSTANTS ;

enum { SE_OWNER_DEFAULTED = ( ( __le16 ) ( __u16 ) ( 0x0001 ) ) , SE_GROUP_DEFAULTED = ( ( __le16 ) ( __u16 ) ( 0x0002 ) ) , SE_DACL_PRESENT = ( ( __le16 ) ( __u16 ) ( 0x0004 ) ) , SE_DACL_DEFAULTED = ( ( __le16 ) ( __u16 ) ( 0x0008 ) ) , SE_SACL_PRESENT = ( ( __le16 ) ( __u16 ) ( 0x0010 ) ) , SE_SACL_DEFAULTED = ( ( __le16 ) ( __u16 ) ( 0x0020 ) ) , SE_DACL_AUTO_INHERIT_REQ = ( ( __le16 ) ( __u16 ) ( 0x0100 ) ) , SE_SACL_AUTO_INHERIT_REQ = ( ( __le16 ) ( __u16 ) ( 0x0200 ) ) , SE_DACL_AUTO_INHERITED = ( ( __le16 ) ( __u16 ) ( 0x0400 ) ) , SE_SACL_AUTO_INHERITED = ( ( __le16 ) ( __u16 ) ( 0x0800 ) ) , SE_DACL_PROTECTED = ( ( __le16 ) ( __u16 ) ( 0x1000 ) ) , SE_SACL_PROTECTED = ( ( __le16 ) ( __u16 ) ( 0x2000 ) ) , SE_RM_CONTROL_VALID = ( ( __le16 ) ( __u16 ) ( 0x4000 ) ) , SE_SELF_RELATIVE = ( ( __le16 ) ( __u16 ) ( 0x8000 ) ) } __attribute__ ( ( __packed__ ) ) ;
typedef le16 SECURITY_DESCRIPTOR_CONTROL ;

typedef struct { u8 revision ; u8 alignment ; SECURITY_DESCRIPTOR_CONTROL control ; le32 owner ; le32 group ; le32 sacl ; le32 dacl ; } __attribute__ ( ( __packed__ ) ) SECURITY_DESCRIPTOR_RELATIVE ;

typedef struct { u8 revision ; u8 alignment ; SECURITY_DESCRIPTOR_CONTROL control ; SID * owner ; SID * group ; ACL * sacl ; ACL * dacl ; } __attribute__ ( ( __packed__ ) ) SECURITY_DESCRIPTOR ;

typedef enum { SECURITY_DESCRIPTOR_REVISION = 1 , SECURITY_DESCRIPTOR_REVISION1 = 1 , SECURITY_DESCRIPTOR_MIN_LENGTH = sizeof ( SECURITY_DESCRIPTOR ) , } SECURITY_DESCRIPTOR_CONSTANTS ;

typedef SECURITY_DESCRIPTOR_RELATIVE SECURITY_DESCRIPTOR_ATTR ;

typedef struct { le32 hash ; le32 security_id ; le64 offset ; le32 length ; } __attribute__ ( ( __packed__ ) ) SECURITY_DESCRIPTOR_HEADER ;

typedef struct { le32 hash ; le32 security_id ; le64 offset ; le32 length ; SECURITY_DESCRIPTOR_RELATIVE sid ; } __attribute__ ( ( __packed__ ) ) SDS_ENTRY ;

typedef struct { le32 security_id ; } __attribute__ ( ( __packed__ ) ) SII_INDEX_KEY ;

typedef struct { le32 hash ; le32 security_id ; } __attribute__ ( ( __packed__ ) ) SDH_INDEX_KEY ;

typedef struct { ntfschar name [ 0 ] ; } __attribute__ ( ( __packed__ ) ) VOLUME_NAME ;

enum { VOLUME_IS_DIRTY = ( ( __le16 ) ( __u16 ) ( 0x0001 ) ) , VOLUME_RESIZE_LOG_FILE = ( ( __le16 ) ( __u16 ) ( 0x0002 ) ) , VOLUME_UPGRADE_ON_MOUNT = ( ( __le16 ) ( __u16 ) ( 0x0004 ) ) , VOLUME_MOUNTED_ON_NT4 = ( ( __le16 ) ( __u16 ) ( 0x0008 ) ) , VOLUME_DELETE_USN_UNDERWAY = ( ( __le16 ) ( __u16 ) ( 0x0010 ) ) , VOLUME_REPAIR_OBJECT_ID = ( ( __le16 ) ( __u16 ) ( 0x0020 ) ) , VOLUME_CHKDSK_UNDERWAY = ( ( __le16 ) ( __u16 ) ( 0x4000 ) ) , VOLUME_MODIFIED_BY_CHKDSK = ( ( __le16 ) ( __u16 ) ( 0x8000 ) ) , VOLUME_FLAGS_MASK = ( ( __le16 ) ( __u16 ) ( 0xc03f ) ) , VOLUME_MUST_MOUNT_RO_MASK = ( ( __le16 ) ( __u16 ) ( 0xc027 ) ) , } __attribute__ ( ( __packed__ ) ) ;
typedef le16 VOLUME_FLAGS ;

typedef struct { le64 reserved ; u8 major_ver ; u8 minor_ver ; VOLUME_FLAGS flags ; } __attribute__ ( ( __packed__ ) ) VOLUME_INFORMATION ;

typedef struct { u8 data [ 0 ] ; } __attribute__ ( ( __packed__ ) ) DATA_ATTR ;

enum { SMALL_INDEX = 0 , LARGE_INDEX = 1 , LEAF_NODE = 0 , INDEX_NODE = 1 , NODE_MASK = 1 , } __attribute__ ( ( __packed__ ) ) ;
typedef u8 INDEX_HEADER_FLAGS ;

typedef struct { le32 entries_offset ; le32 index_length ; le32 allocated_size ; INDEX_HEADER_FLAGS flags ; u8 reserved [ 3 ] ; } __attribute__ ( ( __packed__ ) ) INDEX_HEADER ;

typedef struct { ATTR_TYPE type ; COLLATION_RULE collation_rule ; le32 index_block_size ; u8 clusters_per_index_block ; u8 reserved [ 3 ] ; INDEX_HEADER index ; } __attribute__ ( ( __packed__ ) ) INDEX_ROOT ;

typedef struct { NTFS_RECORD_TYPE magic ; le16 usa_ofs ; le16 usa_count ; sle64 lsn ; leVCN index_block_vcn ; INDEX_HEADER index ; } __attribute__ ( ( __packed__ ) ) INDEX_BLOCK ;

typedef INDEX_BLOCK INDEX_ALLOCATION ;

typedef struct { le32 reparse_tag ; leMFT_REF file_id ; } __attribute__ ( ( __packed__ ) ) REPARSE_INDEX_KEY ;

enum { QUOTA_FLAG_DEFAULT_LIMITS = ( ( __le32 ) ( __u32 ) ( 0x00000001 ) ) , QUOTA_FLAG_LIMIT_REACHED = ( ( __le32 ) ( __u32 ) ( 0x00000002 ) ) , QUOTA_FLAG_ID_DELETED = ( ( __le32 ) ( __u32 ) ( 0x00000004 ) ) , QUOTA_FLAG_USER_MASK = ( ( __le32 ) ( __u32 ) ( 0x00000007 ) ) , QUOTA_FLAG_TRACKING_ENABLED = ( ( __le32 ) ( __u32 ) ( 0x00000010 ) ) , QUOTA_FLAG_ENFORCEMENT_ENABLED = ( ( __le32 ) ( __u32 ) ( 0x00000020 ) ) , QUOTA_FLAG_TRACKING_REQUESTED = ( ( __le32 ) ( __u32 ) ( 0x00000040 ) ) , QUOTA_FLAG_LOG_THRESHOLD = ( ( __le32 ) ( __u32 ) ( 0x00000080 ) ) , QUOTA_FLAG_LOG_LIMIT = ( ( __le32 ) ( __u32 ) ( 0x00000100 ) ) , QUOTA_FLAG_OUT_OF_DATE = ( ( __le32 ) ( __u32 ) ( 0x00000200 ) ) , QUOTA_FLAG_CORRUPT = ( ( __le32 ) ( __u32 ) ( 0x00000400 ) ) , QUOTA_FLAG_PENDING_DELETES = ( ( __le32 ) ( __u32 ) ( 0x00000800 ) ) , } ;
typedef le32 QUOTA_FLAGS ;

typedef struct { le32 version ; QUOTA_FLAGS flags ; le64 bytes_used ; sle64 change_time ; sle64 threshold ; sle64 limit ; sle64 exceeded_time ; SID sid ; } __attribute__ ( ( __packed__ ) ) QUOTA_CONTROL_ENTRY ;

enum { QUOTA_INVALID_ID = ( ( __le32 ) ( __u32 ) ( 0x00000000 ) ) , QUOTA_DEFAULTS_ID = ( ( __le32 ) ( __u32 ) ( 0x00000001 ) ) , QUOTA_FIRST_USER_ID = ( ( __le32 ) ( __u32 ) ( 0x00000100 ) ) , } ;
typedef enum { QUOTA_VERSION = 2 , } QUOTA_CONTROL_ENTRY_CONSTANTS ;

enum { INDEX_ENTRY_NODE = ( ( __le16 ) ( __u16 ) ( 1 ) ) , INDEX_ENTRY_END = ( ( __le16 ) ( __u16 ) ( 2 ) ) , INDEX_ENTRY_SPACE_FILLER = ( ( __le16 ) ( __u16 ) ( 0xffff ) ) , } __attribute__ ( ( __packed__ ) ) ;
typedef le16 INDEX_ENTRY_FLAGS ;

typedef struct { union { struct { leMFT_REF indexed_file ; } __attribute__ ( ( __packed__ ) ) dir ; struct { le16 data_offset ; le16 data_length ; le32 reservedV ; } __attribute__ ( ( __packed__ ) ) vi ; } __attribute__ ( ( __packed__ ) ) data ; le16 length ; le16 key_length ; INDEX_ENTRY_FLAGS flags ; le16 reserved ; } __attribute__ ( ( __packed__ ) ) INDEX_ENTRY_HEADER ;

typedef struct { union { struct { leMFT_REF indexed_file ; } __attribute__ ( ( __packed__ ) ) dir ; struct { le16 data_offset ; le16 data_length ; le32 reservedV ; } __attribute__ ( ( __packed__ ) ) vi ; } __attribute__ ( ( __packed__ ) ) data ; le16 length ; le16 key_length ; INDEX_ENTRY_FLAGS flags ; le16 reserved ; union { FILE_NAME_ATTR file_name ; SII_INDEX_KEY sii ; SDH_INDEX_KEY sdh ; GUID object_id ; REPARSE_INDEX_KEY reparse ; SID sid ; le32 owner_id ; } __attribute__ ( ( __packed__ ) ) key ; } __attribute__ ( ( __packed__ ) ) INDEX_ENTRY ;

typedef struct { u8 bitmap [ 0 ] ; } __attribute__ ( ( __packed__ ) ) BITMAP_ATTR ;

enum { IO_REPARSE_TAG_IS_ALIAS = ( ( __le32 ) ( __u32 ) ( 0x20000000 ) ) , IO_REPARSE_TAG_IS_HIGH_LATENCY = ( ( __le32 ) ( __u32 ) ( 0x40000000 ) ) , IO_REPARSE_TAG_IS_MICROSOFT = ( ( __le32 ) ( __u32 ) ( 0x80000000 ) ) , IO_REPARSE_TAG_RESERVED_ZERO = ( ( __le32 ) ( __u32 ) ( 0x00000000 ) ) , IO_REPARSE_TAG_RESERVED_ONE = ( ( __le32 ) ( __u32 ) ( 0x00000001 ) ) , IO_REPARSE_TAG_RESERVED_RANGE = ( ( __le32 ) ( __u32 ) ( 0x00000001 ) ) , IO_REPARSE_TAG_NSS = ( ( __le32 ) ( __u32 ) ( 0x68000005 ) ) , IO_REPARSE_TAG_NSS_RECOVER = ( ( __le32 ) ( __u32 ) ( 0x68000006 ) ) , IO_REPARSE_TAG_SIS = ( ( __le32 ) ( __u32 ) ( 0x68000007 ) ) , IO_REPARSE_TAG_DFS = ( ( __le32 ) ( __u32 ) ( 0x68000008 ) ) , IO_REPARSE_TAG_MOUNT_POINT = ( ( __le32 ) ( __u32 ) ( 0x88000003 ) ) , IO_REPARSE_TAG_HSM = ( ( __le32 ) ( __u32 ) ( 0xa8000004 ) ) , IO_REPARSE_TAG_SYMBOLIC_LINK = ( ( __le32 ) ( __u32 ) ( 0xe8000000 ) ) , IO_REPARSE_TAG_VALID_VALUES = ( ( __le32 ) ( __u32 ) ( 0xe000ffff ) ) , } ;
typedef struct { le32 reparse_tag ; le16 reparse_data_length ; le16 reserved ; u8 reparse_data [ 0 ] ; } __attribute__ ( ( __packed__ ) ) REPARSE_POINT ;

typedef struct { le16 ea_length ; le16 need_ea_count ; le32 ea_query_length ; } __attribute__ ( ( __packed__ ) ) EA_INFORMATION ;

enum { NEED_EA = 0x80 } __attribute__ ( ( __packed__ ) ) ;
typedef u8 EA_FLAGS ;

typedef struct { le32 next_entry_offset ; EA_FLAGS flags ; u8 ea_name_length ; le16 ea_value_length ; u8 ea_name [ 0 ] ; u8 ea_value [ 0 ] ; } __attribute__ ( ( __packed__ ) ) EA_ATTR ;

typedef struct { } __attribute__ ( ( __packed__ ) ) PROPERTY_SET ;

typedef struct { } __attribute__ ( ( __packed__ ) ) LOGGED_UTILITY_STREAM , EFS_ATTR ;

typedef struct { struct super_block * sb ; LCN nr_blocks ; unsigned long flags ; uid_t uid ; gid_t gid ; mode_t fmask ; mode_t dmask ; u8 mft_zone_multiplier ; u8 on_errors ; u16 sector_size ; u8 sector_size_bits ; u32 cluster_size ; u32 cluster_size_mask ; u8 cluster_size_bits ; u32 mft_record_size ; u32 mft_record_size_mask ; u8 mft_record_size_bits ; u32 index_record_size ; u32 index_record_size_mask ; u8 index_record_size_bits ; LCN nr_clusters ; LCN mft_lcn ; LCN mftmirr_lcn ; u64 serial_no ; u32 upcase_len ; ntfschar * upcase ; s32 attrdef_size ; ATTR_DEF * attrdef ; struct inode * mft_ino ; struct inode * mftbmp_ino ; struct rw_semaphore mftbmp_lock ; struct inode * lcnbmp_ino ; struct rw_semaphore lcnbmp_lock ; struct inode * vol_ino ; VOLUME_FLAGS vol_flags ; u8 major_ver ; u8 minor_ver ; struct inode * root_ino ; struct inode * secure_ino ; struct inode * extend_ino ; struct nls_table * nls_map ; } ntfs_volume ;

typedef enum { NV_Errors , NV_ShowSystemFiles , NV_CaseSensitive , NV_LogFileEmpty , NV_QuotaOutOfDate , NV_UsnJrnlStamped , NV_SparseEnabled , } ntfs_volume_flags ;

typedef struct { VCN vcn ; LCN lcn ; s64 length ; } runlist_element ;

typedef struct { runlist_element * rl ; struct rw_semaphore lock ; } runlist ;

typedef enum { LCN_HOLE = - 1 , LCN_RL_NOT_MAPPED = - 2 , LCN_ENOENT = - 3 , LCN_ENOMEM = - 4 , LCN_EIO = - 5 , } LCN_SPECIAL_VALUES ;

typedef struct _ntfs_inode ntfs_inode ;

struct _ntfs_inode { rwlock_t size_lock ; s64 initialized_size ; s64 allocated_size ; unsigned long state ; unsigned long mft_no ; u16 seq_no ; atomic_t count ; ntfs_volume * vol ; ATTR_TYPE type ; ntfschar * name ; u32 name_len ; runlist runlist ; struct mutex mrec_lock ; struct page * page ; int page_ofs ; u32 attr_list_size ; u8 * attr_list ; runlist attr_list_rl ; union { struct { u32 block_size ; u32 vcn_size ; COLLATION_RULE collation_rule ; u8 block_size_bits ; u8 vcn_size_bits ; } index ; struct { s64 size ; u32 block_size ; u8 block_size_bits ; u8 block_clusters ; } compressed ; } itype ; struct mutex extent_lock ; s32 nr_extents ; union { ntfs_inode * * extent_ntfs_inos ; ntfs_inode * base_ntfs_ino ; } ext ; } ;

typedef enum { NI_Dirty , NI_AttrList , NI_AttrListNonResident , NI_Attr , NI_MstProtected , NI_NonResident , NI_IndexAllocPresent = NI_NonResident , NI_Compressed , NI_Encrypted , NI_Sparse , NI_SparseDisabled , NI_TruncateFailed , } ntfs_inode_state_bits ;

typedef struct { ntfs_inode ntfs_inode ; struct inode vfs_inode ; } big_ntfs_inode ;

typedef struct { unsigned long mft_no ; ntfschar * name ; u32 name_len ; ATTR_TYPE type ; } ntfs_attr ;

typedef int ( * test_t ) ( struct inode * , void * ) ;
typedef struct { MFT_RECORD * mrec ; ATTR_RECORD * attr ; bool is_first ; ntfs_inode * ntfs_ino ; ATTR_LIST_ENTRY * al_entry ; ntfs_inode * base_ntfs_ino ; MFT_RECORD * base_mrec ; ATTR_RECORD * base_attr ; } ntfs_attr_search_ctx ;

typedef enum { NTFS_BLOCK_SIZE = 512 , NTFS_BLOCK_SIZE_BITS = 9 , NTFS_SB_MAGIC = 0x5346544e , NTFS_MAX_NAME_LEN = 255 , NTFS_MAX_ATTR_NAME_LEN = 255 , NTFS_MAX_CLUSTER_SIZE = 64 * 1024 , NTFS_MAX_PAGES_PER_CLUSTER = NTFS_MAX_CLUSTER_SIZE / ( ( 1UL ) << 12 ) , } NTFS_CONSTANTS ;

typedef struct { int val ; char * str ; } option_t ;

int ntfs_map_runlist_nolock ( ntfs_inode * ni , VCN vcn , ntfs_attr_search_ctx * ctx ) ;

int ntfs_map_runlist ( ntfs_inode * ni , VCN vcn ) ;

LCN ntfs_attr_vcn_to_lcn_nolock ( ntfs_inode * ni , const VCN vcn , const bool write_locked ) ;

runlist_element * ntfs_attr_find_vcn_nolock ( ntfs_inode * ni , const VCN vcn , ntfs_attr_search_ctx * ctx ) ;

int load_attribute_list ( ntfs_volume * vol , runlist * runlist , u8 * al_start , const s64 size , const s64 initialized_size ) ;

int ntfs_attr_lookup ( const ATTR_TYPE type , const ntfschar * name , const u32 name_len , const IGNORE_CASE_BOOL ic , const VCN lowest_vcn , const u8 * val , const u32 val_len , ntfs_attr_search_ctx * ctx ) ;

void ntfs_attr_reinit_search_ctx ( ntfs_attr_search_ctx * ctx ) ;

ntfs_attr_search_ctx * ntfs_attr_get_search_ctx ( ntfs_inode * ni , MFT_RECORD * mrec ) ;

void ntfs_attr_put_search_ctx ( ntfs_attr_search_ctx * ctx ) ;

typedef int ( * ntfs_collate_func_t ) ( ntfs_volume * , const void * , const int , const void * , const int ) ;
int ntfs_collate ( ntfs_volume * vol , COLLATION_RULE cr , const void * data1 , const int data1_len , const void * data2 , const int data2_len ) ;

typedef enum { NTFS_SYMBOL_TOKEN = 0 , NTFS_PHRASE_TOKEN = 1 , NTFS_TOKEN_MASK = 1 , NTFS_SB_SIZE_MASK = 0x0fff , NTFS_SB_SIZE = 0x1000 , NTFS_SB_IS_COMPRESSED = 0x8000 , NTFS_MAX_CB_SIZE = 64 * 1024 , } ntfs_compression_constants ;

int allocate_compression_buffers ( void ) ;

void free_compression_buffers ( void ) ;

int ntfs_read_compressed_block ( struct page * page ) ;

void __ntfs_warning ( const char * function , const struct super_block * sb , const char * fmt , ... ) ;

void __ntfs_error ( const char * function , const struct super_block * sb , const char * fmt , ... ) ;

typedef struct { MFT_REF mref ; FILE_NAME_TYPE_FLAGS type ; u8 len ; ntfschar name [ 0 ] ; } __attribute__ ( ( __packed__ ) ) ntfs_name ;

MFT_REF ntfs_lookup_inode_by_name ( ntfs_inode * dir_ni , const ntfschar * uname , const int uname_len , ntfs_name * * res ) ;

typedef struct { ntfs_inode * idx_ni ; INDEX_ENTRY * entry ; void * data ; u16 data_len ; bool is_in_root ; INDEX_ROOT * ir ; ntfs_attr_search_ctx * actx ; ntfs_inode * base_ni ; INDEX_ALLOCATION * ia ; struct page * page ; } ntfs_index_context ;

ntfs_index_context * ntfs_index_ctx_get ( ntfs_inode * idx_ni ) ;

void ntfs_index_ctx_put ( ntfs_index_context * ictx ) ;

int ntfs_index_lookup ( const void * key , const int key_len , ntfs_index_context * ictx ) ;

int ntfs_test_inode ( struct inode * vi , ntfs_attr * na ) ;

typedef int ( * set_t ) ( struct inode * , void * ) ;
struct inode * ntfs_iget ( struct super_block * sb , unsigned long mft_no ) ;

struct inode * ntfs_attr_iget ( struct inode * base_vi , ATTR_TYPE type , ntfschar * name , u32 name_len ) ;

struct inode * ntfs_index_iget ( struct inode * base_vi , ntfschar * name , u32 name_len ) ;

struct inode * ntfs_alloc_big_inode ( struct super_block * sb ) ;

void ntfs_destroy_big_inode ( struct inode * inode ) ;

void __ntfs_init_inode ( struct super_block * sb , ntfs_inode * ni ) ;

int ntfs_read_inode_mount ( struct inode * vi ) ;

void ntfs_clear_extent_inode ( ntfs_inode * ni ) ;

void ntfs_clear_big_inode ( struct inode * vi ) ;

int ntfs_show_options ( struct seq_file * sf , struct vfsmount * mnt ) ;

MFT_RECORD * map_mft_record ( ntfs_inode * ni ) ;

void unmap_mft_record ( ntfs_inode * ni ) ;

MFT_RECORD * map_extent_mft_record ( ntfs_inode * base_ni , MFT_REF mref , ntfs_inode * * ntfs_ino ) ;

int post_read_mst_fixup ( NTFS_RECORD * b , const u32 size ) ;

int pre_write_mst_fixup ( NTFS_RECORD * b , const u32 size ) ;

void post_write_mst_fixup ( NTFS_RECORD * b ) ;

runlist_element * ntfs_runlists_merge ( runlist_element * drl , runlist_element * srl ) ;

runlist_element * ntfs_mapping_pairs_decompress ( const ntfs_volume * vol , const ATTR_RECORD * attr , runlist_element * old_rl ) ;

LCN ntfs_rl_vcn_to_lcn ( const runlist_element * rl , const VCN vcn ) ;

typedef enum { ON_ERRORS_PANIC = 0x01 , ON_ERRORS_REMOUNT_RO = 0x02 , ON_ERRORS_CONTINUE = 0x04 , ON_ERRORS_RECOVER = 0x10 , } ON_ERRORS_ACTIONS ;

bool ntfs_are_names_equal ( const ntfschar * s1 , size_t s1_len , const ntfschar * s2 , size_t s2_len , const IGNORE_CASE_BOOL ic , const ntfschar * upcase , const u32 upcase_size ) ;

int ntfs_collate_names ( const ntfschar * name1 , const u32 name1_len , const ntfschar * name2 , const u32 name2_len , const int err_val , const IGNORE_CASE_BOOL ic , const ntfschar * upcase , const u32 upcase_len ) ;

int ntfs_ucsncmp ( const ntfschar * s1 , const ntfschar * s2 , size_t n ) ;

int ntfs_ucsncasecmp ( const ntfschar * s1 , const ntfschar * s2 , size_t n , const ntfschar * upcase , const u32 upcase_size ) ;

void ntfs_upcase_name ( ntfschar * name , u32 name_len , const ntfschar * upcase , const u32 upcase_len ) ;

void ntfs_file_upcase_value ( FILE_NAME_ATTR * file_name_attr , const ntfschar * upcase , const u32 upcase_len ) ;

int ntfs_file_compare_values ( FILE_NAME_ATTR * file_name_attr1 , FILE_NAME_ATTR * file_name_attr2 , const int err_val , const IGNORE_CASE_BOOL ic , const ntfschar * upcase , const u32 upcase_len ) ;

int ntfs_nlstoucs ( const ntfs_volume * vol , const char * ins , const int ins_len , ntfschar * * outs ) ;

int ntfs_ucstonls ( const ntfs_volume * vol , const ntfschar * ins , const int ins_len , unsigned char * * outs , int outs_len ) ;

ntfschar * generate_default_upcase ( void ) ;

struct parsed_partitions { char name [ 32 ] ; struct { sector_t from ; sector_t size ; int flags ; } parts [ 256 ] ; int next ; int limit ; } ;

struct partition_info { u8 flg ; char id [ 3 ] ; __be32 st ; __be32 siz ; } ;

struct rootsector { char unused [ 0x156 ] ; struct partition_info icdpart [ 8 ] ; char unused2 [ 0xc ] ; u32 hd_siz ; struct partition_info part [ 4 ] ; u32 bsl_st ; u32 bsl_cnt ; u16 checksum ; } __attribute__ ( ( __packed__ ) ) ;
struct parsed_partitions ;
struct frag { struct list_head list ; u32 group ; u8 num ; u8 rec ; u8 map ; u8 data [ 0 ] ; } ;

struct privhead { u16 ver_major ; u16 ver_minor ; u64 logical_disk_start ; u64 logical_disk_size ; u64 config_start ; u64 config_size ; u8 disk_id [ 16 ] ; } ;

struct tocblock { u8 bitmap1_name [ 16 ] ; u64 bitmap1_start ; u64 bitmap1_size ; u8 bitmap2_name [ 16 ] ; u64 bitmap2_start ; u64 bitmap2_size ; } ;

struct vmdb { u16 ver_major ; u16 ver_minor ; u32 vblk_size ; u32 vblk_offset ; u32 last_vblk_seq ; } ;

struct vblk_comp { u8 state [ 16 ] ; u64 parent_id ; u8 type ; u8 children ; u16 chunksize ; } ;

struct vblk_dgrp { u8 disk_id [ 64 ] ; } ;

struct vblk_disk { u8 disk_id [ 16 ] ; u8 alt_name [ 128 ] ; } ;

struct vblk_part { u64 start ; u64 size ; u64 volume_offset ; u64 parent_id ; u64 disk_id ; u8 partnum ; } ;

struct vblk_volu { u8 volume_type [ 16 ] ; u8 volume_state [ 16 ] ; u8 guid [ 16 ] ; u8 drive_hint [ 4 ] ; u64 size ; u8 partition_type ; } ;

struct vblk_head { u32 group ; u16 rec ; u16 nrec ; } ;

struct vblk { u8 name [ 64 ] ; u64 obj_id ; u32 sequence ; u8 flags ; u8 type ; union { struct vblk_comp comp ; struct vblk_dgrp dgrp ; struct vblk_disk disk ; struct vblk_part part ; struct vblk_volu volu ; } vblk ; struct list_head list ; } ;

struct ldmdb { struct privhead ph ; struct tocblock toc ; struct vmdb vm ; struct list_head v_dgrp ; struct list_head v_disk ; struct list_head v_volu ; struct list_head v_comp ; struct list_head v_part ; } ;

struct mac_partition { __be16 signature ; __be16 res1 ; __be32 map_count ; __be32 start_block ; __be32 block_count ; char name [ 32 ] ; char type [ 32 ] ; __be32 data_start ; __be32 data_count ; __be32 status ; __be32 boot_start ; __be32 boot_size ; __be32 boot_load ; __be32 boot_load2 ; __be32 boot_entry ; __be32 boot_entry2 ; __be32 boot_cksum ; char processor [ 16 ] ; } ;

struct mac_driver_desc { __be16 signature ; __be16 block_size ; __be32 block_count ; } ;


typedef struct _gpt_header { __le64 signature ; __le32 revision ; __le32 header_size ; __le32 header_crc32 ; __le32 reserved1 ; __le64 my_lba ; __le64 alternate_lba ; __le64 first_usable_lba ; __le64 last_usable_lba ; efi_guid_t disk_guid ; __le64 partition_entry_lba ; __le32 num_partition_entries ; __le32 sizeof_partition_entry ; __le32 partition_entry_array_crc32 ; } __attribute__ ( ( packed ) ) gpt_header ;


typedef struct _gpt_entry_attributes { u64 required_to_function : 1 ; u64 reserved : 47 ; u64 type_guid_specific : 16 ; } __attribute__ ( ( packed ) ) gpt_entry_attributes ;


typedef struct _gpt_entry { efi_guid_t partition_type_guid ; efi_guid_t unique_partition_guid ; __le64 starting_lba ; __le64 ending_lba ; gpt_entry_attributes attributes ; efi_char16_t partition_name [ 72 / sizeof ( efi_char16_t ) ] ; } __attribute__ ( ( packed ) ) gpt_entry ;


typedef struct _legacy_mbr { u8 boot_code [ 440 ] ; __le32 unique_mbr_signature ; __le16 unknown ; struct partition partition_record [ 4 ] ; __le16 signature ; } __attribute__ ( ( packed ) ) legacy_mbr ;

char * disk_name ( struct gendisk * hd , int partno , char * buf ) ;

const char * bdevname ( struct block_device * bdev , char * buf ) ;

const char * __bdevname ( dev_t dev , char * buffer ) ;

ssize_t part_size_show ( struct device * dev , struct device_attribute * attr , char * buf ) ;

ssize_t part_alignment_offset_show ( struct device * dev , struct device_attribute * attr , char * buf ) ;

ssize_t part_stat_show ( struct device * dev , struct device_attribute * attr , char * buf ) ;

ssize_t part_inflight_show ( struct device * dev , struct device_attribute * attr , char * buf ) ;

void delete_partition ( struct gendisk * disk , int partno ) ;

struct hd_struct * add_partition ( struct gendisk * disk , int partno , sector_t start , sector_t len , int flags ) ;

void register_disk ( struct gendisk * disk ) ;

int rescan_partitions ( struct gendisk * disk , struct block_device * bdev ) ;

unsigned char * read_dev_sector ( struct block_device * bdev , sector_t n , Sector * p ) ;

void del_gendisk ( struct gendisk * disk ) ;

struct adfs_discrecord { __u8 log2secsize ; __u8 secspertrack ; __u8 heads ; __u8 density ; __u8 idlen ; __u8 log2bpmb ; __u8 skew ; __u8 bootoption ; __u8 lowsector ; __u8 nzones ; __le16 zone_spare ; __le32 root ; __le32 disc_size ; __le16 disc_id ; __u8 disc_name [ 10 ] ; __le32 disc_type ; __le32 disc_size_high ; __u8 log2sharesize : 4 ; __u8 unused40 : 4 ; __u8 big_flag : 1 ; __u8 unused41 : 1 ; __u8 nzones_high ; __le32 format_version ; __le32 root_size ; __u8 unused52 [ 60 - 52 ] ; } ;

struct riscix_part { __le32 start ; __le32 length ; __le32 one ; char name [ 16 ] ; } ;

struct riscix_record { __le32 magic ; __le32 date ; struct riscix_part part [ 8 ] ; } ;

struct linux_part { __le32 magic ; __le32 start_sect ; __le32 nr_sects ; } ;

struct ics_part { __le32 start ; __le32 size ; } ;

int adfspart_check_ICS ( struct parsed_partitions * state , struct block_device * bdev ) ;

struct RigidDiskBlock { __u32 rdb_ID ; __be32 rdb_SummedLongs ; __s32 rdb_ChkSum ; __u32 rdb_HostID ; __be32 rdb_BlockBytes ; __u32 rdb_Flags ; __u32 rdb_BadBlockList ; __be32 rdb_PartitionList ; __u32 rdb_FileSysHeaderList ; __u32 rdb_DriveInit ; __u32 rdb_Reserved1 [ 6 ] ; __u32 rdb_Cylinders ; __u32 rdb_Sectors ; __u32 rdb_Heads ; __u32 rdb_Interleave ; __u32 rdb_Park ; __u32 rdb_Reserved2 [ 3 ] ; __u32 rdb_WritePreComp ; __u32 rdb_ReducedWrite ; __u32 rdb_StepRate ; __u32 rdb_Reserved3 [ 5 ] ; __u32 rdb_RDBBlocksLo ; __u32 rdb_RDBBlocksHi ; __u32 rdb_LoCylinder ; __u32 rdb_HiCylinder ; __u32 rdb_CylBlocks ; __u32 rdb_AutoParkSeconds ; __u32 rdb_HighRDSKBlock ; __u32 rdb_Reserved4 ; char rdb_DiskVendor [ 8 ] ; char rdb_DiskProduct [ 16 ] ; char rdb_DiskRevision [ 4 ] ; char rdb_ControllerVendor [ 8 ] ; char rdb_ControllerProduct [ 16 ] ; char rdb_ControllerRevision [ 4 ] ; __u32 rdb_Reserved5 [ 10 ] ; } ;

struct PartitionBlock { __be32 pb_ID ; __be32 pb_SummedLongs ; __s32 pb_ChkSum ; __u32 pb_HostID ; __be32 pb_Next ; __u32 pb_Flags ; __u32 pb_Reserved1 [ 2 ] ; __u32 pb_DevFlags ; __u8 pb_DriveName [ 32 ] ; __u32 pb_Reserved2 [ 15 ] ; __be32 pb_Environment [ 17 ] ; __u32 pb_EReserved [ 15 ] ; } ;

int amiga_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

int atari_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

int mac_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;
int ldm_partition ( struct parsed_partitions * pp , struct block_device * bdev ) ;

int msdos_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

int osf_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

struct sgi_disklabel { __be32 magic_mushroom ; __be16 root_part_num ; __be16 swap_part_num ; s8 boot_file [ 16 ] ; u8 _unused0 [ 48 ] ; struct sgi_volume { s8 name [ 8 ] ; __be32 block_num ; __be32 num_bytes ; } volume [ 15 ] ; struct sgi_partition { __be32 num_blocks ; __be32 first_block ; __be32 type ; } partitions [ 16 ] ; __be32 csum ; __be32 _unused1 ; } ;

int sgi_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

int sun_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

int ultrix_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

int efi_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

int karma_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

struct volumeid { u8 vid_unused [ 248 ] ; u8 vid_mac [ 8 ] ; } ;

struct dkconfig { u8 ios_unused0 [ 128 ] ; __be32 ios_slcblk ; __be16 ios_slccnt ; u8 ios_unused1 [ 122 ] ; } ;

struct dkblk0 { struct volumeid dk_vid ; struct dkconfig dk_ios ; } ;

struct slice { __be32 nblocks ; __be32 blkoff ; } ;

int sysv68_partition ( struct parsed_partitions * state , struct block_device * bdev ) ;

struct vmalloc_info { unsigned long used ; unsigned long largest_chunk ; } ;

struct pde_opener { struct inode * inode ; struct file * file ; int ( * release ) ( struct inode * , struct file * ) ; struct list_head lh ; } ;

void get_vmalloc_info ( struct vmalloc_info * vmi ) ;

void task_mem ( struct seq_file * m , struct mm_struct * mm ) ;

unsigned long task_vsize ( struct mm_struct * mm ) ;

int task_statm ( struct mm_struct * mm , int * shared , int * text , int * data , int * resident ) ;

struct mem_size_stats { struct vm_area_struct * vma ; unsigned long resident ; unsigned long shared_clean ; unsigned long shared_dirty ; unsigned long private_clean ; unsigned long private_dirty ; unsigned long referenced ; unsigned long swap ; u64 pss ; } ;

struct pagemapread { u64 * out , * end ; } ;

struct proc_dir_entry * de_get ( struct proc_dir_entry * de ) ;

void de_put ( struct proc_dir_entry * de ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) proc_init_inodecache ( void ) ;

void pde_users_dec ( struct proc_dir_entry * pde ) ;

struct inode * proc_get_inode ( struct super_block * sb , unsigned int ino , struct proc_dir_entry * de ) ;

int proc_fill_super ( struct super_block * s ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) proc_root_init ( void ) ;

int pid_ns_prepare_proc ( struct pid_namespace * ns ) ;

void pid_ns_release_proc ( struct pid_namespace * ns ) ;

struct pid_entry { char * name ; int len ; mode_t mode ; const struct inode_operations * iop ; const struct file_operations * fop ; union proc_op op ; } ;

struct mm_struct * mm_for_maps ( struct task_struct * task ) ;

struct limit_names { char * name ; char * unit ; } ;

loff_t mem_lseek ( struct file * file , loff_t offset , int orig ) ;

void added_exe_file_vma ( struct mm_struct * mm ) ;

void removed_exe_file_vma ( struct mm_struct * mm ) ;

void set_mm_exe_file ( struct mm_struct * mm , struct file * new_exe_file ) ;

struct file * get_mm_exe_file ( struct mm_struct * mm ) ;

void dup_mm_exe_file ( struct mm_struct * oldmm , struct mm_struct * newmm ) ;

typedef struct dentry * instantiate_t ( struct inode * , struct dentry * , struct task_struct * , const void * ) ;

void proc_flush_task ( struct task_struct * task ) ;

struct dentry * proc_pid_lookup ( struct inode * dir , struct dentry * dentry , struct nameidata * nd ) ;

struct tgid_iter { unsigned int tgid ; struct task_struct * task ; } ;

int proc_pid_readdir ( struct file * filp , void * dirent , filldir_t filldir ) ;

struct dentry * proc_lookup_de ( struct proc_dir_entry * de , struct inode * dir , struct dentry * dentry ) ;

struct dentry * proc_lookup ( struct inode * dir , struct dentry * dentry , struct nameidata * nd ) ;

int proc_readdir_de ( struct proc_dir_entry * de , struct file * filp , void * dirent , filldir_t filldir ) ;

int proc_readdir ( struct file * filp , void * dirent , filldir_t filldir ) ;

struct proc_dir_entry * proc_symlink ( const char * name , struct proc_dir_entry * parent , const char * dest ) ;

struct proc_dir_entry * proc_mkdir_mode ( const char * name , mode_t mode , struct proc_dir_entry * parent ) ;

struct proc_dir_entry * proc_net_mkdir ( struct net * net , const char * name , struct proc_dir_entry * parent ) ;

struct proc_dir_entry * proc_mkdir ( const char * name , struct proc_dir_entry * parent ) ;

struct proc_dir_entry * create_proc_entry ( const char * name , mode_t mode , struct proc_dir_entry * parent ) ;

struct proc_dir_entry * proc_create_data ( const char * name , mode_t mode , struct proc_dir_entry * parent , const struct file_operations * proc_fops , void * data ) ;

void free_proc_entry ( struct proc_dir_entry * de ) ;

void remove_proc_entry ( const char * name , struct proc_dir_entry * parent ) ;

int proc_pid_status ( struct seq_file * m , struct pid_namespace * ns , struct pid * pid , struct task_struct * task ) ;

int proc_tid_stat ( struct seq_file * m , struct pid_namespace * ns , struct pid * pid , struct task_struct * task ) ;

int proc_tgid_stat ( struct seq_file * m , struct pid_namespace * ns , struct pid * pid , struct task_struct * task ) ;

int proc_pid_statm ( struct seq_file * m , struct pid_namespace * ns , struct pid * pid , struct task_struct * task ) ;

void proc_tty_register_driver ( struct tty_driver * driver ) ;

void proc_tty_unregister_driver ( struct tty_driver * driver ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) proc_tty_init ( void ) ;

void __attribute__ ( ( weak ) ) arch_report_meminfo ( struct seq_file * m ) ;
int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) proc_sys_init ( void ) ;

int seq_open_net ( struct inode * ino , struct file * f , const struct seq_operations * ops , int size ) ;

int single_open_net ( struct inode * inode , struct file * file , int ( * show ) ( struct seq_file * , void * ) ) ;

int seq_release_net ( struct inode * ino , struct file * f ) ;

int single_release_net ( struct inode * ino , struct file * f ) ;

struct proc_dir_entry * proc_net_fops_create ( struct net * net , const char * name , mode_t mode , const struct file_operations * fops ) ;

void proc_net_remove ( struct net * net , const char * name ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) proc_net_init ( void ) ;

struct memelfnote { const char * name ; int type ; unsigned int datasz ; void * data ; } ;

void kclist_add ( struct kcore_list * new , void * addr , size_t size , int type ) ;

int get_sparsemem_vmemmap_info ( struct kcore_list * ent , struct list_head * head ) ;

typedef __le16 qnx4_nxtnt_t ;

typedef __u8 qnx4_ftype_t ;

typedef struct { __le32 xtnt_blk ; __le32 xtnt_size ; } qnx4_xtnt_t ;

typedef __le16 qnx4_mode_t ;

typedef __le16 qnx4_muid_t ;

typedef __le16 qnx4_mgid_t ;

typedef __le32 qnx4_off_t ;

typedef __le16 qnx4_nlink_t ;

struct qnx4_inode_entry { char di_fname [ 16 ] ; qnx4_off_t di_size ; qnx4_xtnt_t di_first_xtnt ; __le32 di_xblk ; __le32 di_ftime ; __le32 di_mtime ; __le32 di_atime ; __le32 di_ctime ; qnx4_nxtnt_t di_num_xtnts ; qnx4_mode_t di_mode ; qnx4_muid_t di_uid ; qnx4_mgid_t di_gid ; qnx4_nlink_t di_nlink ; __u8 di_zero [ 4 ] ; qnx4_ftype_t di_type ; __u8 di_status ; } ;

struct qnx4_link_info { char dl_fname [ 48 ] ; __le32 dl_inode_blk ; __u8 dl_inode_ndx ; __u8 dl_spare [ 10 ] ; __u8 dl_status ; } ;

struct qnx4_xblk { __le32 xblk_next_xblk ; __le32 xblk_prev_xblk ; __u8 xblk_num_xtnts ; __u8 xblk_spare [ 3 ] ; __le32 xblk_num_blocks ; qnx4_xtnt_t xblk_xtnts [ 60 ] ; char xblk_signature [ 8 ] ; qnx4_xtnt_t xblk_first_xtnt ; } ;

struct qnx4_super_block { struct qnx4_inode_entry RootDir ; struct qnx4_inode_entry Inode ; struct qnx4_inode_entry Boot ; struct qnx4_inode_entry AltBoot ; } ;

struct qnx4_sb_info { struct buffer_head * sb_buf ; struct qnx4_super_block * sb ; unsigned int Version ; struct qnx4_inode_entry * BitMap ; } ;

struct qnx4_inode_info { struct qnx4_inode_entry raw ; loff_t mmu_private ; struct inode vfs_inode ; } ;

struct buffer_head * qnx4_bread ( struct inode * inode , int block , int create ) ;

unsigned long qnx4_block_map ( struct inode * inode , long iblock ) ;

struct inode * qnx4_iget ( struct super_block * sb , unsigned long ino ) ;

struct dentry * qnx4_lookup ( struct inode * dir , struct dentry * dentry , struct nameidata * nd ) ;

unsigned long qnx4_count_free_blocks ( struct super_block * sb ) ;

int register_quota_format ( struct quota_format_type * fmt ) ;

void unregister_quota_format ( struct quota_format_type * fmt ) ;

int dquot_mark_dquot_dirty ( struct dquot * dquot ) ;

void mark_info_dirty ( struct super_block * sb , int type ) ;

int dquot_acquire ( struct dquot * dquot ) ;

int dquot_commit ( struct dquot * dquot ) ;

int dquot_release ( struct dquot * dquot ) ;

void dquot_destroy ( struct dquot * dquot ) ;

int dquot_scan_active ( struct super_block * sb , int ( * fn ) ( struct dquot * dquot , unsigned long priv ) , unsigned long priv ) ;

int vfs_quota_sync ( struct super_block * sb , int type ) ;

void dqput ( struct dquot * dquot ) ;

struct dquot * dquot_alloc ( struct super_block * sb , int type ) ;

struct dquot * dqget ( struct super_block * sb , unsigned int id , int type ) ;

int dquot_initialize ( struct inode * inode , int type ) ;

int dquot_drop ( struct inode * inode ) ;

void vfs_dq_drop ( struct inode * inode ) ;

void inode_add_rsv_space ( struct inode * inode , qsize_t number ) ;

void inode_claim_rsv_space ( struct inode * inode , qsize_t number ) ;

void inode_sub_rsv_space ( struct inode * inode , qsize_t number ) ;

int __dquot_alloc_space ( struct inode * inode , qsize_t number , int warn , int reserve ) ;

int dquot_alloc_space ( struct inode * inode , qsize_t number , int warn ) ;

int dquot_reserve_space ( struct inode * inode , qsize_t number , int warn ) ;

int dquot_alloc_inode ( const struct inode * inode , qsize_t number ) ;

int dquot_claim_space ( struct inode * inode , qsize_t number ) ;

int __dquot_free_space ( struct inode * inode , qsize_t number , int reserve ) ;

int dquot_free_space ( struct inode * inode , qsize_t number ) ;

void dquot_release_reserved_space ( struct inode * inode , qsize_t number ) ;

int dquot_free_inode ( const struct inode * inode , qsize_t number ) ;

int dquot_transfer ( struct inode * inode , struct iattr * iattr ) ;

int vfs_dq_transfer ( struct inode * inode , struct iattr * iattr ) ;

int dquot_commit_info ( struct super_block * sb , int type ) ;

int vfs_quota_disable ( struct super_block * sb , int type , unsigned int flags ) ;

int vfs_quota_off ( struct super_block * sb , int type , int remount ) ;

int vfs_quota_on_path ( struct super_block * sb , int type , int format_id , struct path * path ) ;

int vfs_quota_on ( struct super_block * sb , int type , int format_id , char * name , int remount ) ;

int vfs_quota_enable ( struct inode * inode , int type , int format_id , unsigned int flags ) ;

int vfs_quota_on_mount ( struct super_block * sb , char * qf_name , int format_id , int type ) ;

int vfs_dq_quota_on_remount ( struct super_block * sb ) ;

int vfs_get_dqblk ( struct super_block * sb , int type , qid_t id , struct if_dqblk * di ) ;

int vfs_set_dqblk ( struct super_block * sb , int type , qid_t id , struct if_dqblk * di ) ;

int vfs_get_dqinfo ( struct super_block * sb , int type , struct if_dqinfo * ii ) ;

int vfs_set_dqinfo ( struct super_block * sb , int type , struct if_dqinfo * ii ) ;

void sync_quota_sb ( struct super_block * sb , int type ) ;

long sys_quotactl ( unsigned int cmd , const char * special , qid_t id , void * addr ) ;

struct compat_if_dqblk { compat_u64 dqb_bhardlimit ; compat_u64 dqb_bsoftlimit ; compat_u64 dqb_curspace ; compat_u64 dqb_ihardlimit ; compat_u64 dqb_isoftlimit ; compat_u64 dqb_curinodes ; compat_u64 dqb_btime ; compat_u64 dqb_itime ; compat_uint_t dqb_valid ; } ;

struct compat_fs_qfilestat { compat_u64 dqb_bhardlimit ; compat_u64 qfs_nblks ; compat_uint_t qfs_nextents ; } ;

struct compat_fs_quota_stat { __s8 qs_version ; __u16 qs_flags ; __s8 qs_pad ; struct compat_fs_qfilestat qs_uquota ; struct compat_fs_qfilestat qs_gquota ; compat_uint_t qs_incoredqs ; compat_int_t qs_btimelimit ; compat_int_t qs_itimelimit ; compat_int_t qs_rtbtimelimit ; __u16 qs_bwarnlimit ; __u16 qs_iwarnlimit ; } ;

long sys32_quotactl ( unsigned int cmd , const char * special , qid_t id , void * addr ) ;

struct inode * ramfs_get_inode ( struct super_block * sb , int mode , dev_t dev ) ;

struct ramfs_mount_opts { umode_t mode ; } ;

enum { Opt_mode , Opt_err } ;
struct ramfs_fs_info { struct ramfs_mount_opts mount_opts ; } ;

int ramfs_get_sb ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data , struct vfsmount * mnt ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_rootfs ( void ) ;

struct reiserfs_journal_list ;

typedef enum { i_item_key_version_mask = 0x0001 , i_stat_data_version_mask = 0x0002 , i_pack_on_close_mask = 0x0004 , i_nopack_mask = 0x0008 , i_link_saved_unlink_mask = 0x0010 , i_link_saved_truncate_mask = 0x0020 , i_has_xattr_dir = 0x0040 , i_data_log = 0x0080 , i_ever_mapped = 0x0100 } reiserfs_inode_flags ;

struct reiserfs_inode_info { __u32 i_key [ 4 ] ; __u32 i_flags ; __u32 i_first_direct_byte ; __u32 i_attrs ; int i_prealloc_block ; int i_prealloc_count ; struct list_head i_prealloc_list ; unsigned new_packing_locality : 1 ; unsigned int i_trans_id ; struct reiserfs_journal_list * i_jl ; struct mutex i_mmap ; struct rw_semaphore i_xattr_sem ; struct inode vfs_inode ; } ;

typedef enum { reiserfs_attrs_cleared = 0x00000001 , } reiserfs_super_block_flags ;

struct reiserfs_journal_cnode { struct buffer_head * bh ; struct super_block * sb ; __u32 blocknr ; unsigned long state ; struct reiserfs_journal_list * jlist ; struct reiserfs_journal_cnode * next ; struct reiserfs_journal_cnode * prev ; struct reiserfs_journal_cnode * hprev ; struct reiserfs_journal_cnode * hnext ; } ;

struct reiserfs_bitmap_node { int id ; char * data ; struct list_head list ; } ;

struct reiserfs_list_bitmap { struct reiserfs_journal_list * journal_list ; struct reiserfs_bitmap_node * * bitmaps ; } ;

struct reiserfs_journal_list { unsigned long j_start ; unsigned long j_state ; unsigned long j_len ; atomic_t j_nonzerolen ; atomic_t j_commit_left ; atomic_t j_older_commits_done ; struct mutex j_commit_mutex ; unsigned int j_trans_id ; time_t j_timestamp ; struct reiserfs_list_bitmap * j_list_bitmap ; struct buffer_head * j_commit_bh ; struct reiserfs_journal_cnode * j_realblock ; struct reiserfs_journal_cnode * j_freedlist ; struct list_head j_list ; struct list_head j_working_list ; struct list_head j_tail_bh_list ; struct list_head j_bh_list ; int j_refcount ; } ;
struct reiserfs_journal { struct buffer_head * * j_ap_blocks ; struct reiserfs_journal_cnode * j_last ; struct reiserfs_journal_cnode * j_first ; struct block_device * j_dev_bd ; fmode_t j_dev_mode ; int j_1st_reserved_block ; unsigned long j_state ; unsigned int j_trans_id ; unsigned long j_mount_id ; unsigned long j_start ; unsigned long j_len ; unsigned long j_len_alloc ; atomic_t j_wcount ; unsigned long j_bcount ; unsigned long j_first_unflushed_offset ; unsigned j_last_flush_trans_id ; struct buffer_head * j_header_bh ; time_t j_trans_start_time ; struct mutex j_mutex ; struct mutex j_flush_mutex ; wait_queue_head_t j_join_wait ; atomic_t j_jlock ; int j_list_bitmap_index ; int j_must_wait ; int j_next_full_flush ; int j_next_async_flush ; int j_cnode_used ; int j_cnode_free ; unsigned int j_trans_max ; unsigned int j_max_batch ; unsigned int j_max_commit_age ; unsigned int j_max_trans_age ; unsigned int j_default_max_commit_age ; struct reiserfs_journal_cnode * j_cnode_free_list ; struct reiserfs_journal_cnode * j_cnode_free_orig ; struct reiserfs_journal_list * j_current_jl ; int j_free_bitmap_nodes ; int j_used_bitmap_nodes ; int j_num_lists ; int j_num_work_lists ; unsigned int j_last_flush_id ; unsigned int j_last_commit_id ; struct list_head j_bitmap_nodes ; struct list_head j_dirty_buffers ; spinlock_t j_dirty_buffers_lock ; struct list_head j_journal_list ; struct list_head j_working_list ; struct reiserfs_list_bitmap j_list_bitmap [ 5 ] ; struct reiserfs_journal_cnode * j_hash_table [ 8192 ] ; struct reiserfs_journal_cnode * j_list_hash_table [ 8192 ] ; struct list_head j_prealloc_list ; int j_persistent_trans ; unsigned long j_max_trans_size ; unsigned long j_max_batch_size ; int j_errno ; struct delayed_work j_work ; struct super_block * j_work_sb ; atomic_t j_async_throttle ; } ;

enum journal_state_bits { J_WRITERS_BLOCKED = 1 , J_WRITERS_QUEUED , J_ABORTED , } ;

typedef __u32 ( * hashf_t ) ( const signed char * , int ) ;

struct reiserfs_bitmap_info { __u32 free_count ; } ;


typedef struct reiserfs_proc_info_data { } reiserfs_proc_info_data_t ;

struct reiserfs_sb_info { struct buffer_head * s_sbh ; struct reiserfs_super_block * s_rs ; struct reiserfs_bitmap_info * s_ap_bitmap ; struct reiserfs_journal * s_journal ; unsigned short s_mount_state ; void ( * end_io_handler ) ( struct buffer_head * , int ) ; hashf_t s_hash_function ; unsigned long s_mount_opt ; struct { unsigned long bits ; unsigned long large_file_size ; int border ; int preallocmin ; int preallocsize ; } s_alloc_options ; wait_queue_head_t s_wait ; atomic_t s_generation_counter ; unsigned long s_properties ; int s_disk_reads ; int s_disk_writes ; int s_fix_nodes ; int s_do_balance ; int s_unneeded_left_neighbor ; int s_good_search_by_key_reada ; int s_bmaps ; int s_bmaps_without_search ; int s_direct2indirect ; int s_indirect2direct ; int s_is_unlinked_ok ; reiserfs_proc_info_data_t s_proc_info_data ; struct proc_dir_entry * procdir ; int reserved_blocks ; spinlock_t bitmap_lock ; struct dentry * priv_root ; struct dentry * xattr_root ; int j_errno ; char * s_qf_names [ 2 ] ; int s_jquota_fmt ; } ;

enum reiserfs_mount_options { REISERFS_LARGETAIL , REISERFS_SMALLTAIL , REPLAYONLY , REISERFS_CONVERT , FORCE_TEA_HASH , FORCE_RUPASOV_HASH , FORCE_R5_HASH , FORCE_HASH_DETECT , REISERFS_DATA_LOG , REISERFS_DATA_ORDERED , REISERFS_DATA_WRITEBACK , REISERFS_NO_BORDER , REISERFS_NO_UNHASHED_RELOCATION , REISERFS_HASHED_RELOCATION , REISERFS_ATTRS , REISERFS_XATTRS_USER , REISERFS_POSIXACL , REISERFS_EXPOSE_PRIVROOT , REISERFS_BARRIER_NONE , REISERFS_BARRIER_FLUSH , REISERFS_ERROR_PANIC , REISERFS_ERROR_RO , REISERFS_ERROR_CONTINUE , REISERFS_QUOTA , REISERFS_TEST1 , REISERFS_TEST2 , REISERFS_TEST3 , REISERFS_TEST4 , REISERFS_UNSUPPORTED_OPT , } ;

struct journal_params { __le32 jp_journal_1st_block ; __le32 jp_journal_dev ; __le32 jp_journal_size ; __le32 jp_journal_trans_max ; __le32 jp_journal_magic ; __le32 jp_journal_max_batch ; __le32 jp_journal_max_commit_age ; __le32 jp_journal_max_trans_age ; } ;

struct reiserfs_super_block_v1 { __le32 s_block_count ; __le32 s_free_blocks ; __le32 s_root_block ; struct journal_params s_journal ; __le16 s_blocksize ; __le16 s_oid_maxsize ; __le16 s_oid_cursize ; __le16 s_umount_state ; char s_magic [ 10 ] ; __le16 s_fs_state ; __le32 s_hash_function_code ; __le16 s_tree_height ; __le16 s_bmap_nr ; __le16 s_version ; __le16 s_reserved_for_journal ; } __attribute__ ( ( __packed__ ) ) ;
struct reiserfs_super_block { struct reiserfs_super_block_v1 s_v1 ; __le32 s_inode_generation ; __le32 s_flags ; unsigned char s_uuid [ 16 ] ; unsigned char s_label [ 16 ] ; __le16 s_mnt_count ; __le16 s_max_mnt_count ; __le32 s_lastcheck ; __le32 s_check_interval ; char s_unused [ 76 ] ; } __attribute__ ( ( __packed__ ) ) ;
typedef __u32 b_blocknr_t ;

typedef __le32 unp_t ;

struct unfm_nodeinfo { unp_t unfm_nodenum ; unsigned short unfm_freespace ; } ;

struct offset_v1 { __le32 k_offset ; __le32 k_uniqueness ; } __attribute__ ( ( __packed__ ) ) ;
struct offset_v2 { __le64 v ; } __attribute__ ( ( __packed__ ) ) ;
struct reiserfs_key { __le32 k_dir_id ; __le32 k_objectid ; union { struct offset_v1 k_offset_v1 ; struct offset_v2 k_offset_v2 ; } __attribute__ ( ( __packed__ ) ) u ; } __attribute__ ( ( __packed__ ) ) ;
struct in_core_key { __u32 k_dir_id ; __u32 k_objectid ; __u64 k_offset ; __u8 k_type ; } ;

struct cpu_key { struct in_core_key on_disk_key ; int version ; int key_length ; } ;

struct item_head { struct reiserfs_key ih_key ; union { __le16 ih_free_space_reserved ; __le16 ih_entry_count ; } __attribute__ ( ( __packed__ ) ) u ; __le16 ih_item_len ; __le16 ih_item_location ; __le16 ih_version ; } __attribute__ ( ( __packed__ ) ) ;
struct block_head { __le16 blk_level ; __le16 blk_nr_item ; __le16 blk_free_space ; __le16 blk_reserved ; struct reiserfs_key blk_right_delim_key ; } ;

struct stat_data_v1 { __le16 sd_mode ; __le16 sd_nlink ; __le16 sd_uid ; __le16 sd_gid ; __le32 sd_size ; __le32 sd_atime ; __le32 sd_mtime ; __le32 sd_ctime ; union { __le32 sd_rdev ; __le32 sd_blocks ; } __attribute__ ( ( __packed__ ) ) u ; __le32 sd_first_direct_byte ; } __attribute__ ( ( __packed__ ) ) ;
struct stat_data { __le16 sd_mode ; __le16 sd_attrs ; __le32 sd_nlink ; __le64 sd_size ; __le32 sd_uid ; __le32 sd_gid ; __le32 sd_atime ; __le32 sd_mtime ; __le32 sd_ctime ; __le32 sd_blocks ; union { __le32 sd_rdev ; __le32 sd_generation ; } __attribute__ ( ( __packed__ ) ) u ; } __attribute__ ( ( __packed__ ) ) ;
struct reiserfs_de_head { __le32 deh_offset ; __le32 deh_dir_id ; __le32 deh_objectid ; __le16 deh_location ; __le16 deh_state ; } __attribute__ ( ( __packed__ ) ) ;
struct reiserfs_dir_entry { struct buffer_head * de_bh ; int de_item_num ; struct item_head * de_ih ; int de_entry_num ; struct reiserfs_de_head * de_deh ; int de_entrylen ; int de_namelen ; char * de_name ; unsigned long * de_gen_number_bit_string ; __u32 de_dir_id ; __u32 de_objectid ; struct cpu_key de_entry_key ; } ;

struct disk_child { __le32 dc_block_number ; __le16 dc_size ; __le16 dc_reserved ; } ;

struct path_element { struct buffer_head * pe_buffer ; int pe_position ; } ;

struct treepath { int path_length ; int reada ; struct path_element path_elements [ 7 ] ; int pos_in_item ; } ;

struct virtual_item { int vi_index ; unsigned short vi_type ; unsigned short vi_item_len ; struct item_head * vi_ih ; const char * vi_item ; const void * vi_new_data ; void * vi_uarea ; } ;

struct virtual_node { char * vn_free_ptr ; unsigned short vn_nr_item ; short vn_size ; short vn_mode ; short vn_affected_item_num ; short vn_pos_in_item ; struct item_head * vn_ins_ih ; const void * vn_data ; struct virtual_item * vn_vi ; } ;

struct direntry_uarea { int flags ; __u16 entry_count ; __u16 entry_sizes [ 1 ] ; } __attribute__ ( ( __packed__ ) ) ;
struct tree_balance { int tb_mode ; int need_balance_dirty ; struct super_block * tb_sb ; struct reiserfs_transaction_handle * transaction_handle ; struct treepath * tb_path ; struct buffer_head * L [ 5 ] ; struct buffer_head * R [ 5 ] ; struct buffer_head * FL [ 5 ] ; struct buffer_head * FR [ 5 ] ; struct buffer_head * CFL [ 5 ] ; struct buffer_head * CFR [ 5 ] ; struct buffer_head * FEB [ 6 ] ; struct buffer_head * used [ 6 ] ; struct buffer_head * thrown [ 6 ] ; int lnum [ 5 ] ; int rnum [ 5 ] ; int lkey [ 5 ] ; int rkey [ 5 ] ; int insert_size [ 5 ] ; int blknum [ 5 ] ; int cur_blknum ; int s0num ; int s1num ; int s2num ; int lbytes ; int rbytes ; int s1bytes ; int s2bytes ; struct buffer_head * buf_to_free [ 7 ] ; char * vn_buf ; int vn_buf_size ; struct virtual_node * tb_vn ; int fs_gen ; struct in_core_key key ; } ;

struct buffer_info { struct tree_balance * tb ; struct buffer_head * bi_bh ; struct buffer_head * bi_parent ; int bi_position ; } ;

struct item_operations { int ( * bytes_number ) ( struct item_head * ih , int block_size ) ; void ( * decrement_key ) ( struct cpu_key * ) ; int ( * is_left_mergeable ) ( struct reiserfs_key * ih , unsigned long bsize ) ; void ( * print_item ) ( struct item_head * , char * item ) ; void ( * check_item ) ( struct item_head * , char * item ) ; int ( * create_vi ) ( struct virtual_node * vn , struct virtual_item * vi , int is_affected , int insert_size ) ; int ( * check_left ) ( struct virtual_item * vi , int free , int start_skip , int end_skip ) ; int ( * check_right ) ( struct virtual_item * vi , int free ) ; int ( * part_size ) ( struct virtual_item * vi , int from , int to ) ; int ( * unit_num ) ( struct virtual_item * vi ) ; void ( * print_vi ) ( struct virtual_item * vi ) ; } ;

struct reiserfs_iget_args { __u32 objectid ; __u32 dirid ; } ;

struct reiserfs_journal_desc { __le32 j_trans_id ; __le32 j_len ; __le32 j_mount_id ; __le32 j_realblock [ 1 ] ; } ;

struct reiserfs_journal_commit { __le32 j_trans_id ; __le32 j_len ; __le32 j_realblock [ 1 ] ; } ;

struct reiserfs_journal_header { __le32 j_last_flush_trans_id ; __le32 j_first_unflushed_offset ; __le32 j_mount_id ; struct journal_params jh_journal ; } ;

enum reiserfs_bh_state_bits { BH_JDirty = BH_PrivateStart , BH_JDirty_wait , BH_JNew , BH_JPrepared , BH_JRestore_dirty , BH_JTest , } ;

struct reiserfs_transaction_handle { struct super_block * t_super ; int t_refcount ; int t_blocks_logged ; int t_blocks_allocated ; unsigned int t_trans_id ; void * t_handle_save ; unsigned displace_new_blocks : 1 ; struct list_head t_list ; } ;

struct reiserfs_jh { struct reiserfs_journal_list * jl ; struct buffer_head * bh ; struct list_head list ; } ;

struct reiserfs_security_handle ;

struct __reiserfs_blocknr_hint { struct inode * inode ; sector_t block ; struct in_core_key key ; struct treepath * path ; struct reiserfs_transaction_handle * th ; b_blocknr_t beg , end ; b_blocknr_t search_start ; int prealloc_size ; unsigned formatted_node : 1 ; unsigned preallocate : 1 ; } ;

typedef struct __reiserfs_blocknr_hint reiserfs_blocknr_hint_t ;

int is_reusable ( struct super_block * s , b_blocknr_t block , int bit_value ) ;

__le32 reiserfs_choose_packing ( struct inode * dir ) ;

void reiserfs_free_block ( struct reiserfs_transaction_handle * th , struct inode * inode , b_blocknr_t block , int for_unformatted ) ;

void reiserfs_discard_prealloc ( struct reiserfs_transaction_handle * th , struct inode * inode ) ;

void reiserfs_discard_all_prealloc ( struct reiserfs_transaction_handle * th ) ;

void reiserfs_init_alloc_options ( struct super_block * s ) ;

int reiserfs_parse_alloc_options ( struct super_block * s , char * options ) ;

int reiserfs_allocate_blocknrs ( reiserfs_blocknr_hint_t * hint , b_blocknr_t * new_blocknrs , int amount_needed , int reserved_by_us ) ;

void reiserfs_cache_bitmap_metadata ( struct super_block * sb , struct buffer_head * bh , struct reiserfs_bitmap_info * info ) ;

struct buffer_head * reiserfs_read_bitmap_block ( struct super_block * sb , unsigned int bitmap ) ;

int reiserfs_init_bitmap_cache ( struct super_block * sb ) ;

void reiserfs_free_bitmap_cache ( struct super_block * sb ) ;

void make_empty_node ( struct buffer_info * bi ) ;

struct buffer_head * get_FEB ( struct tree_balance * tb ) ;

void reiserfs_invalidate_buffer ( struct tree_balance * tb , struct buffer_head * bh ) ;

void replace_key ( struct tree_balance * tb , struct buffer_head * dest , int n_dest , struct buffer_head * src , int n_src ) ;

int get_left_neighbor_position ( struct tree_balance * tb , int h ) ;

int get_right_neighbor_position ( struct tree_balance * tb , int h ) ;

void do_balance ( struct tree_balance * tb , struct item_head * ih , const char * body , int flag ) ;

typedef struct { __le16 e_tag ; __le16 e_perm ; __le32 e_id ; } reiserfs_acl_entry ;

typedef struct { __le16 e_tag ; __le16 e_perm ; } reiserfs_acl_entry_short ;

typedef struct { __le32 a_version ; } reiserfs_acl_header ;

struct reiserfs_xattr_header { __le32 h_magic ; __le32 h_hash ; } ;

struct reiserfs_security_handle { char * name ; void * value ; size_t length ; } ;
int search_by_entry_key ( struct super_block * sb , const struct cpu_key * key , struct treepath * path , struct reiserfs_dir_entry * de ) ;

struct dentry * reiserfs_get_parent ( struct dentry * child ) ;

void reiserfs_delete_inode ( struct inode * inode ) ;

void make_cpu_key ( struct cpu_key * key , struct inode * inode , loff_t offset , int type , int length ) ;

int reiserfs_get_block ( struct inode * inode , sector_t block , struct buffer_head * bh_result , int create ) ;

void reiserfs_update_sd_size ( struct reiserfs_transaction_handle * th , struct inode * inode , loff_t size ) ;

int reiserfs_init_locked_inode ( struct inode * inode , void * p ) ;

void reiserfs_read_locked_inode ( struct inode * inode , struct reiserfs_iget_args * args ) ;

int reiserfs_find_actor ( struct inode * inode , void * opaque ) ;

struct inode * reiserfs_iget ( struct super_block * s , const struct cpu_key * key ) ;

struct dentry * reiserfs_fh_to_dentry ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type ) ;

struct dentry * reiserfs_fh_to_parent ( struct super_block * sb , struct fid * fid , int fh_len , int fh_type ) ;

int reiserfs_encode_fh ( struct dentry * dentry , __u32 * data , int * lenp , int need_parent ) ;

int reiserfs_write_inode ( struct inode * inode , int do_sync ) ;

int reiserfs_new_inode ( struct reiserfs_transaction_handle * th , struct inode * dir , int mode , const char * symname , loff_t i_size , struct dentry * dentry , struct inode * inode , struct reiserfs_security_handle * security ) ;

int reiserfs_truncate_file ( struct inode * inode , int update_timestamps ) ;

int reiserfs_prepare_write ( struct file * f , struct page * page , unsigned from , unsigned to ) ;

int reiserfs_commit_write ( struct file * f , struct page * page , unsigned from , unsigned to ) ;

void sd_attrs_to_i_attrs ( __u16 sd_attrs , struct inode * inode ) ;

void i_attrs_to_sd_attrs ( struct inode * inode , __u16 * sd_attrs ) ;

int reiserfs_setattr ( struct dentry * dentry , struct iattr * attr ) ;

int reiserfs_commit_page ( struct inode * inode , struct page * page , unsigned from , unsigned to ) ;

int reiserfs_readdir_dentry ( struct dentry * dentry , void * dirent , filldir_t filldir , loff_t * pos ) ;

void make_empty_dir_item_v1 ( char * body , __le32 dirid , __le32 objid , __le32 par_dirid , __le32 par_objid ) ;

void make_empty_dir_item ( char * body , __le32 dirid , __le32 objid , __le32 par_dirid , __le32 par_objid ) ;

int fix_nodes ( int op_mode , struct tree_balance * tb , struct item_head * ins_ih , const void * data ) ;

void unfix_nodes ( struct tree_balance * tb ) ;

int is_reiserfs_3_5 ( struct reiserfs_super_block * rs ) ;

int is_reiserfs_3_6 ( struct reiserfs_super_block * rs ) ;

int is_reiserfs_jr ( struct reiserfs_super_block * rs ) ;

void add_save_link ( struct reiserfs_transaction_handle * th , struct inode * inode , int truncate ) ;

int remove_save_link ( struct inode * inode , int truncate ) ;

typedef struct { char * value ; int setmask ; int clrmask ; } arg_desc_t ;

typedef struct { char * option_name ; int arg_required ; const arg_desc_t * values ; int setmask ; int clrmask ; } opt_desc_t ;

void __reiserfs_warning ( struct super_block * sb , const char * id , const char * function , const char * fmt , ... ) ;

void reiserfs_info ( struct super_block * sb , const char * fmt , ... ) ;

void reiserfs_debug ( struct super_block * s , int level , const char * fmt , ... ) ;

void __reiserfs_panic ( struct super_block * sb , const char * id , const char * function , const char * fmt , ... ) ;

void __reiserfs_error ( struct super_block * sb , const char * id , const char * function , const char * fmt , ... ) ;

void reiserfs_abort ( struct super_block * sb , int errno , const char * fmt , ... ) ;

char * reiserfs_hashname ( int code ) ;

void print_block ( struct buffer_head * bh , ... ) ;

void store_print_tb ( struct tree_balance * tb ) ;

void print_cur_tb ( char * mes ) ;

void check_leaf ( struct buffer_head * bh ) ;

void check_internal ( struct buffer_head * bh ) ;

void print_statistics ( struct super_block * s ) ;

__u32 reiserfs_get_unused_objectid ( struct reiserfs_transaction_handle * th ) ;

void reiserfs_release_objectid ( struct reiserfs_transaction_handle * th , __u32 objectid_to_release ) ;

int reiserfs_convert_objectid_map_v1 ( struct super_block * s ) ;

int leaf_move_items ( int shift_mode , struct tree_balance * tb , int mov_num , int mov_bytes , struct buffer_head * Snew ) ;

int leaf_shift_left ( struct tree_balance * tb , int shift_num , int shift_bytes ) ;

int leaf_shift_right ( struct tree_balance * tb , int shift_num , int shift_bytes ) ;

void leaf_delete_items ( struct buffer_info * cur_bi , int last_first , int first , int del_num , int del_bytes ) ;

void leaf_insert_into_buf ( struct buffer_info * bi , int before , struct item_head * inserted_item_ih , const char * inserted_item_body , int zeros_number ) ;

void leaf_paste_in_buffer ( struct buffer_info * bi , int affected_item_num , int pos_in_item , int paste_size , const char * body , int zeros_number ) ;

void leaf_cut_from_buffer ( struct buffer_info * bi , int cut_item_num , int pos_in_item , int cut_size ) ;

void leaf_paste_entries ( struct buffer_info * bi , int item_num , int before , int new_entry_count , struct reiserfs_de_head * new_dehs , const char * records , int paste_size ) ;

int balance_internal ( struct tree_balance * tb , int h , int child_pos , struct item_head * insert_key , struct buffer_head * * insert_ptr ) ;

int reiserfs_check_path ( struct treepath * p ) ;

void pathrelse_and_restore ( struct super_block * sb , struct treepath * search_path ) ;

void pathrelse ( struct treepath * search_path ) ;

int search_by_key ( struct super_block * sb , const struct cpu_key * key , struct treepath * search_path , int stop_level ) ;

int search_for_position_by_key ( struct super_block * sb , const struct cpu_key * p_cpu_key , struct treepath * search_path ) ;

int comp_items ( const struct item_head * stored_ih , const struct treepath * path ) ;

void padd_item ( char * item , int total_length , int length ) ;

int reiserfs_delete_item ( struct reiserfs_transaction_handle * th , struct treepath * path , const struct cpu_key * item_key , struct inode * inode , struct buffer_head * un_bh ) ;

void reiserfs_delete_solid_item ( struct reiserfs_transaction_handle * th , struct inode * inode , struct reiserfs_key * key ) ;

int reiserfs_delete_object ( struct reiserfs_transaction_handle * th , struct inode * inode ) ;

int reiserfs_cut_from_item ( struct reiserfs_transaction_handle * th , struct treepath * path , struct cpu_key * item_key , struct inode * inode , struct page * page , loff_t new_file_size ) ;

int reiserfs_do_truncate ( struct reiserfs_transaction_handle * th , struct inode * inode , struct page * page , int update_timestamps ) ;

int reiserfs_paste_into_item ( struct reiserfs_transaction_handle * th , struct treepath * search_path , const struct cpu_key * key , struct inode * inode , const char * body , int pasted_size ) ;

int reiserfs_insert_item ( struct reiserfs_transaction_handle * th , struct treepath * path , const struct cpu_key * key , struct item_head * ih , struct inode * inode , const char * body ) ;

u32 keyed_hash ( const signed char * msg , int len ) ;

u32 yura_hash ( const signed char * msg , int len ) ;

u32 r5_hash ( const signed char * msg , int len ) ;

int direct2indirect ( struct reiserfs_transaction_handle * th , struct inode * inode , struct treepath * path , struct buffer_head * unbh , loff_t tail_offset ) ;

void reiserfs_unmap_buffer ( struct buffer_head * bh ) ;

int indirect2direct ( struct reiserfs_transaction_handle * th , struct inode * inode , struct page * page , struct treepath * path , const struct cpu_key * item_key , loff_t n_new_file_size , char * mode ) ;

enum { JBEGIN_REG = 0 , JBEGIN_JOIN = 1 , JBEGIN_ABORT = 2 , } ;
int reiserfs_allocate_list_bitmaps ( struct super_block * sb , struct reiserfs_list_bitmap * jb_array , unsigned int bmap_nr ) ;

void reiserfs_check_lock_depth ( struct super_block * sb , char * caller ) ;

int reiserfs_in_journal ( struct super_block * sb , unsigned int bmap_nr , int bit_nr , int search_all , b_blocknr_t * next_zero_bit ) ;

struct buffer_chunk { struct buffer_head * bh [ 32 ] ; int nr ; } ;

void reiserfs_free_jh ( struct buffer_head * bh ) ;

int reiserfs_add_tail_list ( struct inode * inode , struct buffer_head * bh ) ;

int reiserfs_add_ordered_list ( struct inode * inode , struct buffer_head * bh ) ;

void remove_journal_hash ( struct super_block * sb , struct reiserfs_journal_cnode * * table , struct reiserfs_journal_list * jl , unsigned long block , int remove_freed ) ;

int journal_release ( struct reiserfs_transaction_handle * th , struct super_block * sb ) ;

int journal_release_error ( struct reiserfs_transaction_handle * th , struct super_block * sb ) ;

int journal_init ( struct super_block * sb , const char * j_dev_name , int old_format , unsigned int commit_max_age ) ;

int journal_transaction_should_end ( struct reiserfs_transaction_handle * th , int new_alloc ) ;

void reiserfs_block_writes ( struct reiserfs_transaction_handle * th ) ;

void reiserfs_allow_writes ( struct super_block * s ) ;

void reiserfs_wait_on_write_block ( struct super_block * s ) ;

struct reiserfs_transaction_handle * reiserfs_persistent_transaction ( struct super_block * s , int nblocks ) ;

int reiserfs_end_persistent_transaction ( struct reiserfs_transaction_handle * th ) ;

int journal_join_abort ( struct reiserfs_transaction_handle * th , struct super_block * sb , unsigned long nblocks ) ;

int journal_begin ( struct reiserfs_transaction_handle * th , struct super_block * sb , unsigned long nblocks ) ;

int journal_mark_dirty ( struct reiserfs_transaction_handle * th , struct super_block * sb , struct buffer_head * bh ) ;

int journal_end ( struct reiserfs_transaction_handle * th , struct super_block * sb , unsigned long nblocks ) ;

int journal_end_sync ( struct reiserfs_transaction_handle * th , struct super_block * sb , unsigned long nblocks ) ;

int reiserfs_flush_old_commits ( struct super_block * sb ) ;

int journal_mark_freed ( struct reiserfs_transaction_handle * th , struct super_block * sb , b_blocknr_t blocknr ) ;

void reiserfs_update_inode_transaction ( struct inode * inode ) ;

int reiserfs_commit_for_inode ( struct inode * inode ) ;

void reiserfs_restore_prepared_buffer ( struct super_block * sb , struct buffer_head * bh ) ;

int reiserfs_prepare_for_journal ( struct super_block * sb , struct buffer_head * bh , int wait ) ;

void reiserfs_abort_journal ( struct super_block * sb , int errno ) ;

int reiserfs_resize ( struct super_block * s , unsigned long block_count_new ) ;

int reiserfs_ioctl ( struct inode * inode , struct file * filp , unsigned int cmd , unsigned long arg ) ;

long reiserfs_compat_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) ;

int reiserfs_unpack ( struct inode * inode , struct file * filp ) ;

int reiserfs_proc_info_init ( struct super_block * sb ) ;

int reiserfs_proc_info_done ( struct super_block * sb ) ;

struct proc_dir_entry * reiserfs_proc_register_global ( char * name , read_proc_t * func ) ;

void reiserfs_proc_unregister_global ( const char * name ) ;

int reiserfs_proc_info_global_init ( void ) ;

int reiserfs_proc_info_global_done ( void ) ;

int reiserfs_global_version_in_proc ( char * buffer , char * * start , off_t offset , int count , int * eof , void * data ) ;

struct reiserfs_dentry_buf { struct dentry * xadir ; int count ; struct dentry * dentries [ 8 ] ; } ;

int reiserfs_delete_xattrs ( struct inode * inode ) ;

int reiserfs_chown_xattrs ( struct inode * inode , struct iattr * attrs ) ;

int reiserfs_xattr_set_handle ( struct reiserfs_transaction_handle * th , struct inode * inode , const char * name , const void * buffer , size_t buffer_size , int flags ) ;

int reiserfs_xattr_set ( struct inode * inode , const char * name , const void * buffer , size_t buffer_size , int flags ) ;

int reiserfs_xattr_get ( struct inode * inode , const char * name , void * buffer , size_t buffer_size ) ;

ssize_t reiserfs_getxattr ( struct dentry * dentry , const char * name , void * buffer , size_t size ) ;

int reiserfs_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

int reiserfs_removexattr ( struct dentry * dentry , const char * name ) ;

struct listxattr_buf { size_t size ; size_t pos ; char * buf ; struct inode * inode ; } ;

ssize_t reiserfs_listxattr ( struct dentry * dentry , char * buffer , size_t size ) ;

int reiserfs_permission ( struct inode * inode , int mask ) ;

int reiserfs_lookup_privroot ( struct super_block * s ) ;

int reiserfs_xattr_init ( struct super_block * s , int mount_flags ) ;

int reiserfs_security_init ( struct inode * dir , struct inode * inode , struct reiserfs_security_handle * sec ) ;

int reiserfs_security_write ( struct reiserfs_transaction_handle * th , struct inode * inode , struct reiserfs_security_handle * sec ) ;

void reiserfs_security_free ( struct reiserfs_security_handle * sec ) ;

struct posix_acl * reiserfs_get_acl ( struct inode * inode , int type ) ;

int reiserfs_inherit_default_acl ( struct reiserfs_transaction_handle * th , struct inode * dir , struct dentry * dentry , struct inode * inode ) ;

int reiserfs_cache_default_acl ( struct inode * inode ) ;

int reiserfs_acl_chmod ( struct inode * inode ) ;

struct sysfs_open_dirent ;

struct sysfs_elem_dir { struct kobject * kobj ; struct sysfs_dirent * children ; } ;

struct sysfs_elem_symlink { struct sysfs_dirent * target_sd ; } ;

struct sysfs_elem_attr { struct attribute * attr ; struct sysfs_open_dirent * open ; } ;

struct sysfs_elem_bin_attr { struct bin_attribute * bin_attr ; struct hlist_head buffers ; } ;

struct sysfs_inode_attrs { struct iattr ia_iattr ; void * ia_secdata ; u32 ia_secdata_len ; } ;

struct sysfs_dirent { atomic_t s_count ; atomic_t s_active ; struct sysfs_dirent * s_parent ; struct sysfs_dirent * s_sibling ; const char * s_name ; union { struct sysfs_elem_dir s_dir ; struct sysfs_elem_symlink s_symlink ; struct sysfs_elem_attr s_attr ; struct sysfs_elem_bin_attr s_bin_attr ; } ; unsigned int s_flags ; ino_t s_ino ; umode_t s_mode ; struct sysfs_inode_attrs * s_iattr ; } ;
struct sysfs_addrm_cxt { struct sysfs_dirent * parent_sd ; struct inode * parent_inode ; struct sysfs_dirent * removed ; int cnt ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sysfs_inode_init ( void ) ;

struct sysfs_inode_attrs * sysfs_init_inode_attrs ( struct sysfs_dirent * sd ) ;

int sysfs_setattr ( struct dentry * dentry , struct iattr * iattr ) ;

int sysfs_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

struct inode * sysfs_get_inode ( struct sysfs_dirent * sd ) ;

void sysfs_delete_inode ( struct inode * inode ) ;

int sysfs_hash_and_remove ( struct sysfs_dirent * dir_sd , const char * name ) ;

void sysfs_printk_last_file ( void ) ;

struct sysfs_open_dirent { atomic_t refcnt ; atomic_t event ; wait_queue_head_t poll ; struct list_head buffers ; } ;
struct sysfs_buffer { size_t count ; loff_t pos ; char * page ; struct sysfs_ops * ops ; struct mutex mutex ; int needs_read_fill ; int event ; struct list_head list ; } ;

void sysfs_notify_dirent ( struct sysfs_dirent * sd ) ;

void sysfs_notify ( struct kobject * k , const char * dir , const char * attr ) ;

int sysfs_add_file_mode ( struct sysfs_dirent * dir_sd , const struct attribute * attr , int type , mode_t amode ) ;

int sysfs_add_file ( struct sysfs_dirent * dir_sd , const struct attribute * attr , int type ) ;

int sysfs_create_file ( struct kobject * kobj , const struct attribute * attr ) ;

int sysfs_add_file_to_group ( struct kobject * kobj , const struct attribute * attr , const char * group ) ;

int sysfs_chmod_file ( struct kobject * kobj , struct attribute * attr , mode_t mode ) ;

void sysfs_remove_file ( struct kobject * kobj , const struct attribute * attr ) ;

void sysfs_remove_file_from_group ( struct kobject * kobj , const struct attribute * attr , const char * group ) ;

struct sysfs_schedule_callback_struct { struct list_head workq_list ; struct kobject * kobj ; void ( * func ) ( void * ) ; void * data ; struct module * owner ; struct work_struct work ; } ;

int sysfs_schedule_callback ( struct kobject * kobj , void ( * func ) ( void * ) , void * data , struct module * owner ) ;

struct dentry * sysfs_get_dentry ( struct sysfs_dirent * sd ) ;

struct sysfs_dirent * sysfs_get_active_two ( struct sysfs_dirent * sd ) ;

void sysfs_put_active_two ( struct sysfs_dirent * sd ) ;

void release_sysfs_dirent ( struct sysfs_dirent * sd ) ;

struct sysfs_dirent * sysfs_new_dirent ( const char * name , umode_t mode , int type ) ;

void sysfs_addrm_start ( struct sysfs_addrm_cxt * acxt , struct sysfs_dirent * parent_sd ) ;

int __sysfs_add_one ( struct sysfs_addrm_cxt * acxt , struct sysfs_dirent * sd ) ;

int sysfs_add_one ( struct sysfs_addrm_cxt * acxt , struct sysfs_dirent * sd ) ;

void sysfs_remove_one ( struct sysfs_addrm_cxt * acxt , struct sysfs_dirent * sd ) ;

void sysfs_addrm_finish ( struct sysfs_addrm_cxt * acxt ) ;

struct sysfs_dirent * sysfs_find_dirent ( struct sysfs_dirent * parent_sd , const unsigned char * name ) ;

struct sysfs_dirent * sysfs_get_dirent ( struct sysfs_dirent * parent_sd , const unsigned char * name ) ;

int sysfs_create_subdir ( struct kobject * kobj , const char * name , struct sysfs_dirent * * p_sd ) ;

int sysfs_create_dir ( struct kobject * kobj ) ;

void sysfs_remove_subdir ( struct sysfs_dirent * sd ) ;

void sysfs_remove_dir ( struct kobject * kobj ) ;

int sysfs_rename_dir ( struct kobject * kobj , const char * new_name ) ;

int sysfs_move_dir ( struct kobject * kobj , struct kobject * new_parent_kobj ) ;

int sysfs_create_link ( struct kobject * kobj , struct kobject * target , const char * name ) ;

int sysfs_create_link_nowarn ( struct kobject * kobj , struct kobject * target , const char * name ) ;

void sysfs_remove_link ( struct kobject * kobj , const char * name ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sysfs_init ( void ) ;

struct sysfs_dirent * sysfs_get ( struct sysfs_dirent * sd ) ;

void sysfs_put ( struct sysfs_dirent * sd ) ;

struct bin_buffer { struct mutex mutex ; void * buffer ; int mmapped ; const struct vm_operations_struct * vm_ops ; struct file * file ; struct hlist_node list ; } ;

void unmap_bin_file ( struct sysfs_dirent * attr_sd ) ;

int sysfs_create_bin_file ( struct kobject * kobj , struct bin_attribute * attr ) ;

void sysfs_remove_bin_file ( struct kobject * kobj , struct bin_attribute * attr ) ;

int sysfs_create_group ( struct kobject * kobj , const struct attribute_group * grp ) ;

int sysfs_update_group ( struct kobject * kobj , const struct attribute_group * grp ) ;

void sysfs_remove_group ( struct kobject * kobj , const struct attribute_group * grp ) ;

typedef __u64 __fs64 ;

typedef __u32 __fs32 ;

typedef __u16 __fs16 ;

struct ufs_timeval { __fs32 tv_sec ; __fs32 tv_usec ; } ;

struct ufs_dir_entry { __fs32 d_ino ; __fs16 d_reclen ; union { __fs16 d_namlen ; struct { __u8 d_type ; __u8 d_namlen ; } d_44 ; } d_u ; __u8 d_name [ 255 + 1 ] ; } ;

struct ufs_csum { __fs32 cs_ndir ; __fs32 cs_nbfree ; __fs32 cs_nifree ; __fs32 cs_nffree ; } ;

struct ufs2_csum_total { __fs64 cs_ndir ; __fs64 cs_nbfree ; __fs64 cs_nifree ; __fs64 cs_nffree ; __fs64 cs_numclusters ; __fs64 cs_spare [ 3 ] ; } ;

struct ufs_csum_core { __u64 cs_ndir ; __u64 cs_nbfree ; __u64 cs_nifree ; __u64 cs_nffree ; __u64 cs_numclusters ; } ;

struct ufs_cylinder_group { __fs32 cg_link ; __fs32 cg_magic ; __fs32 cg_time ; __fs32 cg_cgx ; __fs16 cg_ncyl ; __fs16 cg_niblk ; __fs32 cg_ndblk ; struct ufs_csum cg_cs ; __fs32 cg_rotor ; __fs32 cg_frotor ; __fs32 cg_irotor ; __fs32 cg_frsum [ ( 8192 / 1024 ) ] ; __fs32 cg_btotoff ; __fs32 cg_boff ; __fs32 cg_iusedoff ; __fs32 cg_freeoff ; __fs32 cg_nextfreeoff ; union { struct { __fs32 cg_clustersumoff ; __fs32 cg_clusteroff ; __fs32 cg_nclusterblks ; __fs32 cg_sparecon [ 13 ] ; } cg_44 ; struct { __fs32 cg_clustersumoff ; __fs32 cg_clusteroff ; __fs32 cg_nclusterblks ; __fs32 cg_niblk ; __fs32 cg_initediblk ; __fs32 cg_sparecon32 [ 3 ] ; __fs64 cg_time ; __fs64 cg_sparecon [ 3 ] ; } cg_u2 ; __fs32 cg_sparecon [ 16 ] ; } cg_u ; __u8 cg_space [ 1 ] ; } ;

struct ufs_old_cylinder_group { __fs32 cg_link ; __fs32 cg_rlink ; __fs32 cg_time ; __fs32 cg_cgx ; __fs16 cg_ncyl ; __fs16 cg_niblk ; __fs32 cg_ndblk ; struct ufs_csum cg_cs ; __fs32 cg_rotor ; __fs32 cg_frotor ; __fs32 cg_irotor ; __fs32 cg_frsum [ 8 ] ; __fs32 cg_btot [ 32 ] ; __fs16 cg_b [ 32 ] [ 8 ] ; __u8 cg_iused [ 256 ] ; __fs32 cg_magic ; __u8 cg_free [ 1 ] ; } ;

struct ufs_inode { __fs16 ui_mode ; __fs16 ui_nlink ; union { struct { __fs16 ui_suid ; __fs16 ui_sgid ; } oldids ; __fs32 ui_inumber ; __fs32 ui_author ; } ui_u1 ; __fs64 ui_size ; struct ufs_timeval ui_atime ; struct ufs_timeval ui_mtime ; struct ufs_timeval ui_ctime ; union { struct { __fs32 ui_db [ 12 ] ; __fs32 ui_ib [ 3 ] ; } ui_addr ; __u8 ui_symlink [ 4 * ( 12 + 3 ) ] ; } ui_u2 ; __fs32 ui_flags ; __fs32 ui_blocks ; __fs32 ui_gen ; union { struct { __fs32 ui_shadow ; __fs32 ui_uid ; __fs32 ui_gid ; __fs32 ui_oeftflag ; } ui_sun ; struct { __fs32 ui_uid ; __fs32 ui_gid ; __fs32 ui_spare [ 2 ] ; } ui_44 ; struct { __fs32 ui_uid ; __fs32 ui_gid ; __fs16 ui_modeh ; __fs16 ui_spare ; __fs32 ui_trans ; } ui_hurd ; } ui_u3 ; } ;

struct ufs2_inode { __fs16 ui_mode ; __fs16 ui_nlink ; __fs32 ui_uid ; __fs32 ui_gid ; __fs32 ui_blksize ; __fs64 ui_size ; __fs64 ui_blocks ; __fs64 ui_atime ; __fs64 ui_mtime ; __fs64 ui_ctime ; __fs64 ui_birthtime ; __fs32 ui_mtimensec ; __fs32 ui_atimensec ; __fs32 ui_ctimensec ; __fs32 ui_birthnsec ; __fs32 ui_gen ; __fs32 ui_kernflags ; __fs32 ui_flags ; __fs32 ui_extsize ; __fs64 ui_extb [ 2 ] ; union { struct { __fs64 ui_db [ 12 ] ; __fs64 ui_ib [ 3 ] ; } ui_addr ; __u8 ui_symlink [ 2 * 4 * ( 12 + 3 ) ] ; } ui_u2 ; __fs64 ui_spare [ 3 ] ; } ;

struct ufs_buffer_head { __u64 fragment ; __u64 count ; struct buffer_head * bh [ ( 8192 / 1024 ) ] ; } ;

struct ufs_cg_private_info { struct ufs_buffer_head c_ubh ; __u32 c_cgx ; __u16 c_ncyl ; __u16 c_niblk ; __u32 c_ndblk ; __u32 c_rotor ; __u32 c_frotor ; __u32 c_irotor ; __u32 c_btotoff ; __u32 c_boff ; __u32 c_iusedoff ; __u32 c_freeoff ; __u32 c_nextfreeoff ; __u32 c_clustersumoff ; __u32 c_clusteroff ; __u32 c_nclusterblks ; } ;

struct ufs_sb_private_info { struct ufs_buffer_head s_ubh ; struct ufs_csum_core cs_total ; __u32 s_sblkno ; __u32 s_cblkno ; __u32 s_iblkno ; __u32 s_dblkno ; __u32 s_cgoffset ; __u32 s_cgmask ; __u32 s_size ; __u32 s_dsize ; __u64 s_u2_size ; __u64 s_u2_dsize ; __u32 s_ncg ; __u32 s_bsize ; __u32 s_fsize ; __u32 s_fpb ; __u32 s_minfree ; __u32 s_bmask ; __u32 s_fmask ; __u32 s_bshift ; __u32 s_fshift ; __u32 s_fpbshift ; __u32 s_fsbtodb ; __u32 s_sbsize ; __u32 s_csmask ; __u32 s_csshift ; __u32 s_nindir ; __u32 s_inopb ; __u32 s_nspf ; __u32 s_npsect ; __u32 s_interleave ; __u32 s_trackskew ; __u64 s_csaddr ; __u32 s_cssize ; __u32 s_cgsize ; __u32 s_ntrak ; __u32 s_nsect ; __u32 s_spc ; __u32 s_ipg ; __u32 s_fpg ; __u32 s_cpc ; __s32 s_contigsumsize ; __s64 s_qbmask ; __s64 s_qfmask ; __s32 s_postblformat ; __s32 s_nrpos ; __s32 s_postbloff ; __s32 s_rotbloff ; __u32 s_fpbmask ; __u32 s_apb ; __u32 s_2apb ; __u32 s_3apb ; __u32 s_apbmask ; __u32 s_apbshift ; __u32 s_2apbshift ; __u32 s_3apbshift ; __u32 s_nspfshift ; __u32 s_nspb ; __u32 s_inopf ; __u32 s_sbbase ; __u32 s_bpf ; __u32 s_bpfshift ; __u32 s_bpfmask ; __u32 s_maxsymlinklen ; __s32 fs_magic ; unsigned int s_dirblksize ; } ;

struct ufs_super_block_first { union { struct { __fs32 fs_link ; } fs_42 ; struct { __fs32 fs_state ; } fs_sun ; } fs_u0 ; __fs32 fs_rlink ; __fs32 fs_sblkno ; __fs32 fs_cblkno ; __fs32 fs_iblkno ; __fs32 fs_dblkno ; __fs32 fs_cgoffset ; __fs32 fs_cgmask ; __fs32 fs_time ; __fs32 fs_size ; __fs32 fs_dsize ; __fs32 fs_ncg ; __fs32 fs_bsize ; __fs32 fs_fsize ; __fs32 fs_frag ; __fs32 fs_minfree ; __fs32 fs_rotdelay ; __fs32 fs_rps ; __fs32 fs_bmask ; __fs32 fs_fmask ; __fs32 fs_bshift ; __fs32 fs_fshift ; __fs32 fs_maxcontig ; __fs32 fs_maxbpg ; __fs32 fs_fragshift ; __fs32 fs_fsbtodb ; __fs32 fs_sbsize ; __fs32 fs_csmask ; __fs32 fs_csshift ; __fs32 fs_nindir ; __fs32 fs_inopb ; __fs32 fs_nspf ; __fs32 fs_optim ; union { struct { __fs32 fs_npsect ; } fs_sun ; struct { __fs32 fs_state ; } fs_sunx86 ; } fs_u1 ; __fs32 fs_interleave ; __fs32 fs_trackskew ; __fs32 fs_id [ 2 ] ; __fs32 fs_csaddr ; __fs32 fs_cssize ; __fs32 fs_cgsize ; __fs32 fs_ntrak ; __fs32 fs_nsect ; __fs32 fs_spc ; __fs32 fs_ncyl ; __fs32 fs_cpg ; __fs32 fs_ipg ; __fs32 fs_fpg ; struct ufs_csum fs_cstotal ; __s8 fs_fmod ; __s8 fs_clean ; __s8 fs_ronly ; __s8 fs_flags ; __s8 fs_fsmnt [ 512 - 212 ] ; } ;

struct ufs_super_block_second { union { struct { __s8 fs_fsmnt [ 212 ] ; __fs32 fs_cgrotor ; __fs32 fs_csp [ 31 ] ; __fs32 fs_maxcluster ; __fs32 fs_cpc ; __fs16 fs_opostbl [ 82 ] ; } fs_u1 ; struct { __s8 fs_fsmnt [ 468 - 512 + 212 ] ; __u8 fs_volname [ 32 ] ; __fs64 fs_swuid ; __fs32 fs_pad ; __fs32 fs_cgrotor ; __fs32 fs_ocsp [ 28 ] ; __fs32 fs_contigdirs ; __fs32 fs_csp ; __fs32 fs_maxcluster ; __fs32 fs_active ; __fs32 fs_old_cpc ; __fs32 fs_maxbsize ; __fs64 fs_sparecon64 [ 17 ] ; __fs64 fs_sblockloc ; __fs64 cs_ndir ; __fs64 cs_nbfree ; } fs_u2 ; } fs_un ; } ;

struct ufs_super_block_third { union { struct { __fs16 fs_opostbl [ 46 ] ; } fs_u1 ; struct { __fs64 cs_nifree ; __fs64 cs_nffree ; __fs64 cs_numclusters ; __fs64 cs_spare [ 3 ] ; struct ufs_timeval fs_time ; __fs64 fs_size ; __fs64 fs_dsize ; __fs64 fs_csaddr ; __fs64 fs_pendingblocks ; __fs32 fs_pendinginodes ; } __attribute__ ( ( packed ) ) fs_u2 ; } fs_un1 ; union { struct { __fs32 fs_sparecon [ 53 ] ; __fs32 fs_reclaim ; __fs32 fs_sparecon2 [ 1 ] ; __fs32 fs_state ; __fs32 fs_qbmask [ 2 ] ; __fs32 fs_qfmask [ 2 ] ; } fs_sun ; struct { __fs32 fs_sparecon [ 53 ] ; __fs32 fs_reclaim ; __fs32 fs_sparecon2 [ 1 ] ; __fs32 fs_npsect ; __fs32 fs_qbmask [ 2 ] ; __fs32 fs_qfmask [ 2 ] ; } fs_sunx86 ; struct { __fs32 fs_sparecon [ 50 ] ; __fs32 fs_contigsumsize ; __fs32 fs_maxsymlinklen ; __fs32 fs_inodefmt ; __fs32 fs_maxfilesize [ 2 ] ; __fs32 fs_qbmask [ 2 ] ; __fs32 fs_qfmask [ 2 ] ; __fs32 fs_state ; } fs_44 ; } fs_un2 ; __fs32 fs_postblformat ; __fs32 fs_nrpos ; __fs32 fs_postbloff ; __fs32 fs_rotbloff ; __fs32 fs_magic ; __u8 fs_space [ 1 ] ; } ;

struct ufs_sb_private_info ;
struct ufs_cg_private_info ;
struct ufs_csum ;
struct ufs_sb_info { struct ufs_sb_private_info * s_uspi ; struct ufs_csum * s_csp ; unsigned s_bytesex ; unsigned s_flags ; struct buffer_head * * s_ucg ; struct ufs_cg_private_info * s_ucpi [ 8 ] ; unsigned s_cgno [ 8 ] ; unsigned short s_cg_loaded ; unsigned s_mount_opt ; } ;

struct ufs_inode_info { union { __fs32 i_data [ 15 ] ; __u8 i_symlink [ 2 * 4 * 15 ] ; __fs64 u2_i_data [ 15 ] ; } i_u1 ; __u32 i_flags ; __u32 i_shadow ; __u32 i_unused1 ; __u32 i_unused2 ; __u32 i_oeftflag ; __u16 i_osync ; __u64 i_lastfrag ; __u32 i_dir_start_lookup ; struct inode vfs_inode ; } ;

enum { BYTESEX_LE , BYTESEX_BE } ;
void ufs_free_fragments ( struct inode * inode , u64 fragment , unsigned count ) ;

void ufs_free_blocks ( struct inode * inode , u64 fragment , unsigned count ) ;

u64 ufs_new_fragments ( struct inode * inode , void * p , u64 fragment , u64 goal , unsigned count , int * err , struct page * locked_page ) ;

void ufs_put_cylinder ( struct super_block * sb , unsigned bitmap_nr ) ;

struct ufs_cg_private_info * ufs_load_cylinder ( struct super_block * sb , unsigned cgno ) ;

ino_t ufs_inode_by_name ( struct inode * dir , struct dentry * dentry ) ;

void ufs_set_link ( struct inode * dir , struct ufs_dir_entry * de , struct page * page , struct inode * inode ) ;

struct ufs_dir_entry * ufs_dotdot ( struct inode * dir , struct page * * p ) ;

struct ufs_dir_entry * ufs_find_entry ( struct inode * dir , struct dentry * dentry , struct page * * res_page ) ;

int ufs_add_link ( struct dentry * dentry , struct inode * inode ) ;

int ufs_delete_entry ( struct inode * inode , struct ufs_dir_entry * dir , struct page * page ) ;

int ufs_make_empty ( struct inode * inode , struct inode * dir ) ;

int ufs_empty_dir ( struct inode * inode ) ;

void ufs_free_inode ( struct inode * inode ) ;

struct inode * ufs_new_inode ( struct inode * dir , int mode ) ;

int ufs_getfrag_block ( struct inode * inode , sector_t fragment , struct buffer_head * bh_result , int create ) ;

struct buffer_head * ufs_bread ( struct inode * inode , unsigned fragment , int create , int * err ) ;

int __ufs_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata ) ;

struct inode * ufs_iget ( struct super_block * sb , unsigned long ino ) ;

int ufs_write_inode ( struct inode * inode , int wait ) ;

int ufs_sync_inode ( struct inode * inode ) ;

void ufs_delete_inode ( struct inode * inode ) ;

void ufs_error ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void ufs_panic ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

void ufs_warning ( struct super_block * sb , const char * function , const char * fmt , ... ) ;

enum { Opt_type_old = 0x00000010 , Opt_type_sunx86 = 0x00000400 , Opt_type_sun = 0x00000040 , Opt_type_sunos = 0x00002000 , Opt_type_44bsd = 0x00000020 , Opt_type_ufs2 = 0x00001000 , Opt_type_hp = 0x00000800 , Opt_type_nextstepcd = 0x00000100 , Opt_type_nextstep = 0x00000080 , Opt_type_openstep = 0x00000200 , Opt_onerror_panic = 0x00000001 , Opt_onerror_lock = 0x00000002 , Opt_onerror_umount = 0x00000004 , Opt_onerror_repair = 0x00000008 , Opt_err } ;
int ufs_truncate ( struct inode * inode , loff_t old_i_size ) ;

struct ufs_buffer_head * _ubh_bread_ ( struct ufs_sb_private_info * uspi , struct super_block * sb , u64 fragment , u64 size ) ;

struct ufs_buffer_head * ubh_bread_uspi ( struct ufs_sb_private_info * uspi , struct super_block * sb , u64 fragment , u64 size ) ;

void ubh_brelse ( struct ufs_buffer_head * ubh ) ;

void ubh_brelse_uspi ( struct ufs_sb_private_info * uspi ) ;

void ubh_mark_buffer_dirty ( struct ufs_buffer_head * ubh ) ;

void ubh_mark_buffer_uptodate ( struct ufs_buffer_head * ubh , int flag ) ;

void ubh_ll_rw_block ( int rw , struct ufs_buffer_head * ubh ) ;

void ubh_wait_on_buffer ( struct ufs_buffer_head * ubh ) ;

void ubh_bforget ( struct ufs_buffer_head * ubh ) ;

int ubh_buffer_dirty ( struct ufs_buffer_head * ubh ) ;

void _ubh_ubhcpymem_ ( struct ufs_sb_private_info * uspi , unsigned char * mem , struct ufs_buffer_head * ubh , unsigned size ) ;

void _ubh_memcpyubh_ ( struct ufs_sb_private_info * uspi , struct ufs_buffer_head * ubh , unsigned char * mem , unsigned size ) ;

dev_t ufs_get_inode_dev ( struct super_block * sb , struct ufs_inode_info * ufsi ) ;

void ufs_set_inode_dev ( struct super_block * sb , struct ufs_inode_info * ufsi , dev_t dev ) ;

struct page * ufs_get_locked_page ( struct address_space * mapping , unsigned long index ) ;

typedef signed long long int __int64_t ;
typedef unsigned long long int __uint64_t ;
typedef enum { B_FALSE , B_TRUE } boolean_t ;

typedef __uint32_t prid_t ;

typedef __uint32_t inst_t ;

typedef __s64 xfs_off_t ;

typedef unsigned long long xfs_ino_t ;

typedef __s64 xfs_daddr_t ;

typedef char * xfs_caddr_t ;

typedef __u32 xfs_dev_t ;

typedef __u32 xfs_nlink_t ;

typedef __int64_t __psint_t ;

typedef __uint64_t __psunsigned_t ;

typedef __uint32_t xfs_agblock_t ;

typedef __uint32_t xfs_extlen_t ;

typedef __uint32_t xfs_agnumber_t ;

typedef __int32_t xfs_extnum_t ;

typedef __int16_t xfs_aextnum_t ;

typedef __int64_t xfs_fsize_t ;

typedef __uint64_t xfs_ufsize_t ;

typedef __int32_t xfs_suminfo_t ;

typedef __int32_t xfs_rtword_t ;

typedef __int64_t xfs_lsn_t ;

typedef __int32_t xfs_tid_t ;

typedef __uint32_t xfs_dablk_t ;

typedef __uint32_t xfs_dahash_t ;

typedef __uint16_t xfs_prid_t ;

typedef __uint64_t xfs_dfsbno_t ;

typedef __uint64_t xfs_drfsbno_t ;

typedef __uint64_t xfs_drtbno_t ;

typedef __uint64_t xfs_dfiloff_t ;

typedef __uint64_t xfs_dfilblks_t ;

typedef __uint64_t xfs_fsblock_t ;

typedef __uint64_t xfs_rfsblock_t ;

typedef __uint64_t xfs_rtblock_t ;

typedef __int64_t xfs_srtblock_t ;

typedef __uint64_t xfs_fileoff_t ;

typedef __int64_t xfs_sfiloff_t ;

typedef __uint64_t xfs_filblks_t ;

typedef enum { XFS_LOOKUP_EQi , XFS_LOOKUP_LEi , XFS_LOOKUP_GEi } xfs_lookup_t ;

typedef enum { XFS_BTNUM_BNOi , XFS_BTNUM_CNTi , XFS_BTNUM_BMAPi , XFS_BTNUM_INOi , XFS_BTNUM_MAX } xfs_btnum_t ;

struct xfs_name { const char * name ; int len ; } ;

typedef struct { struct rw_semaphore mr_lock ; } mrlock_t ;


typedef struct sv_s { wait_queue_head_t waiters ; } sv_t ;

typedef struct timespec timespec_t ;


typedef struct ktrace_entry { void * val [ 16 ] ; } ktrace_entry_t ;


typedef struct ktrace { int kt_nentries ; atomic_t kt_index ; unsigned int kt_index_mask ; int kt_rollover ; ktrace_entry_t * kt_entries ; } ktrace_t ;


typedef struct ktrace_snap { int ks_start ; int ks_index ; } ktrace_snap_t ;

typedef struct { unsigned char __u_bits [ 16 ] ; } uuid_t ;

typedef const struct cred cred_t ;

struct dioattr { __u32 d_mem ; __u32 d_miniosz ; __u32 d_maxiosz ; } ;

struct fsxattr { __u32 fsx_xflags ; __u32 fsx_extsize ; __u32 fsx_nextents ; __u32 fsx_projid ; unsigned char fsx_pad [ 12 ] ; } ;

struct getbmap { __s64 bmv_offset ; __s64 bmv_block ; __s64 bmv_length ; __s32 bmv_count ; __s32 bmv_entries ; } ;

struct getbmapx { __s64 bmv_offset ; __s64 bmv_block ; __s64 bmv_length ; __s32 bmv_count ; __s32 bmv_entries ; __s32 bmv_iflags ; __s32 bmv_oflags ; __s32 bmv_unused1 ; __s32 bmv_unused2 ; } ;

struct fsdmidata { __u32 fsd_dmevmask ; __u16 fsd_padding ; __u16 fsd_dmstate ; } ;


typedef struct xfs_flock64 { __s16 l_type ; __s16 l_whence ; __s64 l_start ; __s64 l_len ; __s32 l_sysid ; __u32 l_pid ; __s32 l_pad [ 4 ] ; } xfs_flock64_t ;


typedef struct xfs_fsop_geom_v1 { __u32 blocksize ; __u32 rtextsize ; __u32 agblocks ; __u32 agcount ; __u32 logblocks ; __u32 sectsize ; __u32 inodesize ; __u32 imaxpct ; __u64 datablocks ; __u64 rtblocks ; __u64 rtextents ; __u64 logstart ; unsigned char uuid [ 16 ] ; __u32 sunit ; __u32 swidth ; __s32 version ; __u32 flags ; __u32 logsectsize ; __u32 rtsectsize ; __u32 dirblocksize ; } xfs_fsop_geom_v1_t ;


typedef struct xfs_fsop_geom { __u32 blocksize ; __u32 rtextsize ; __u32 agblocks ; __u32 agcount ; __u32 logblocks ; __u32 sectsize ; __u32 inodesize ; __u32 imaxpct ; __u64 datablocks ; __u64 rtblocks ; __u64 rtextents ; __u64 logstart ; unsigned char uuid [ 16 ] ; __u32 sunit ; __u32 swidth ; __s32 version ; __u32 flags ; __u32 logsectsize ; __u32 rtsectsize ; __u32 dirblocksize ; __u32 logsunit ; } xfs_fsop_geom_t ;


typedef struct xfs_fsop_counts { __u64 freedata ; __u64 freertx ; __u64 freeino ; __u64 allocino ; } xfs_fsop_counts_t ;


typedef struct xfs_fsop_resblks { __u64 resblks ; __u64 resblks_avail ; } xfs_fsop_resblks_t ;


typedef struct xfs_growfs_data { __u64 newblocks ; __u32 imaxpct ; } xfs_growfs_data_t ;


typedef struct xfs_growfs_log { __u32 newblocks ; __u32 isint ; } xfs_growfs_log_t ;


typedef struct xfs_growfs_rt { __u64 newblocks ; __u32 extsize ; } xfs_growfs_rt_t ;


typedef struct xfs_bstime { time_t tv_sec ; __s32 tv_nsec ; } xfs_bstime_t ;


typedef struct xfs_bstat { __u64 bs_ino ; __u16 bs_mode ; __u16 bs_nlink ; __u32 bs_uid ; __u32 bs_gid ; __u32 bs_rdev ; __s32 bs_blksize ; __s64 bs_size ; xfs_bstime_t bs_atime ; xfs_bstime_t bs_mtime ; xfs_bstime_t bs_ctime ; int64_t bs_blocks ; __u32 bs_xflags ; __s32 bs_extsize ; __s32 bs_extents ; __u32 bs_gen ; __u16 bs_projid ; unsigned char bs_pad [ 14 ] ; __u32 bs_dmevmask ; __u16 bs_dmstate ; __u16 bs_aextents ; } xfs_bstat_t ;


typedef struct xfs_fsop_bulkreq { __u64 * lastip ; __s32 icount ; void * ubuffer ; __s32 * ocount ; } xfs_fsop_bulkreq_t ;


typedef struct xfs_inogrp { __u64 xi_startino ; __s32 xi_alloccount ; __u64 xi_allocmask ; } xfs_inogrp_t ;


typedef struct xfs_error_injection { __s32 fd ; __s32 errtag ; } xfs_error_injection_t ;


typedef struct xfs_fsop_handlereq { __u32 fd ; void * path ; __u32 oflags ; void * ihandle ; __u32 ihandlen ; void * ohandle ; __u32 * ohandlen ; } xfs_fsop_handlereq_t ;


typedef struct xfs_fsop_setdm_handlereq { struct xfs_fsop_handlereq hreq ; struct fsdmidata * data ; } xfs_fsop_setdm_handlereq_t ;


typedef struct xfs_attrlist_cursor { __u32 opaque [ 4 ] ; } xfs_attrlist_cursor_t ;


typedef struct xfs_fsop_attrlist_handlereq { struct xfs_fsop_handlereq hreq ; struct xfs_attrlist_cursor pos ; __u32 flags ; __u32 buflen ; void * buffer ; } xfs_fsop_attrlist_handlereq_t ;


typedef struct xfs_attr_multiop { __u32 am_opcode ; __s32 am_error ; void * am_attrname ; void * am_attrvalue ; __u32 am_length ; __u32 am_flags ; } xfs_attr_multiop_t ;


typedef struct xfs_fsop_attrmulti_handlereq { struct xfs_fsop_handlereq hreq ; __u32 opcount ; struct xfs_attr_multiop * ops ; } xfs_fsop_attrmulti_handlereq_t ;

typedef struct { __u32 val [ 2 ] ; } xfs_fsid_t ;


typedef struct xfs_fid { __u16 fid_len ; __u16 fid_pad ; __u32 fid_gen ; __u64 fid_ino ; } xfs_fid_t ;


typedef struct xfs_handle { union { __s64 align ; xfs_fsid_t _ha_fsid ; } ha_u ; xfs_fid_t ha_fid ; } xfs_handle_t ;

struct xfs_inode ;

struct xfs_iomap ;

struct attrlist_cursor_kern ;

struct xfsstats { __uint32_t xs_allocx ; __uint32_t xs_allocb ; __uint32_t xs_freex ; __uint32_t xs_freeb ; __uint32_t xs_abt_lookup ; __uint32_t xs_abt_compare ; __uint32_t xs_abt_insrec ; __uint32_t xs_abt_delrec ; __uint32_t xs_blk_mapr ; __uint32_t xs_blk_mapw ; __uint32_t xs_blk_unmap ; __uint32_t xs_add_exlist ; __uint32_t xs_del_exlist ; __uint32_t xs_look_exlist ; __uint32_t xs_cmp_exlist ; __uint32_t xs_bmbt_lookup ; __uint32_t xs_bmbt_compare ; __uint32_t xs_bmbt_insrec ; __uint32_t xs_bmbt_delrec ; __uint32_t xs_dir_lookup ; __uint32_t xs_dir_create ; __uint32_t xs_dir_remove ; __uint32_t xs_dir_getdents ; __uint32_t xs_trans_sync ; __uint32_t xs_trans_async ; __uint32_t xs_trans_empty ; __uint32_t xs_ig_attempts ; __uint32_t xs_ig_found ; __uint32_t xs_ig_frecycle ; __uint32_t xs_ig_missed ; __uint32_t xs_ig_dup ; __uint32_t xs_ig_reclaims ; __uint32_t xs_ig_attrchg ; __uint32_t xs_log_writes ; __uint32_t xs_log_blocks ; __uint32_t xs_log_noiclogs ; __uint32_t xs_log_force ; __uint32_t xs_log_force_sleep ; __uint32_t xs_try_logspace ; __uint32_t xs_sleep_logspace ; __uint32_t xs_push_ail ; __uint32_t xs_push_ail_success ; __uint32_t xs_push_ail_pushbuf ; __uint32_t xs_push_ail_pinned ; __uint32_t xs_push_ail_locked ; __uint32_t xs_push_ail_flushing ; __uint32_t xs_push_ail_restarts ; __uint32_t xs_push_ail_flush ; __uint32_t xs_xstrat_quick ; __uint32_t xs_xstrat_split ; __uint32_t xs_write_calls ; __uint32_t xs_read_calls ; __uint32_t xs_attr_get ; __uint32_t xs_attr_set ; __uint32_t xs_attr_remove ; __uint32_t xs_attr_list ; __uint32_t xs_iflush_count ; __uint32_t xs_icluster_flushcnt ; __uint32_t xs_icluster_flushinode ; __uint32_t vn_active ; __uint32_t vn_alloc ; __uint32_t vn_get ; __uint32_t vn_hold ; __uint32_t vn_rele ; __uint32_t vn_reclaim ; __uint32_t vn_remove ; __uint32_t vn_free ; __uint32_t xb_get ; __uint32_t xb_create ; __uint32_t xb_get_locked ; __uint32_t xb_get_locked_waited ; __uint32_t xb_busy_locked ; __uint32_t xb_miss_locked ; __uint32_t xb_page_retries ; __uint32_t xb_page_found ; __uint32_t xb_get_read ; __uint32_t xs_abtb_2_lookup ; __uint32_t xs_abtb_2_compare ; __uint32_t xs_abtb_2_insrec ; __uint32_t xs_abtb_2_delrec ; __uint32_t xs_abtb_2_newroot ; __uint32_t xs_abtb_2_killroot ; __uint32_t xs_abtb_2_increment ; __uint32_t xs_abtb_2_decrement ; __uint32_t xs_abtb_2_lshift ; __uint32_t xs_abtb_2_rshift ; __uint32_t xs_abtb_2_split ; __uint32_t xs_abtb_2_join ; __uint32_t xs_abtb_2_alloc ; __uint32_t xs_abtb_2_free ; __uint32_t xs_abtb_2_moves ; __uint32_t xs_abtc_2_lookup ; __uint32_t xs_abtc_2_compare ; __uint32_t xs_abtc_2_insrec ; __uint32_t xs_abtc_2_delrec ; __uint32_t xs_abtc_2_newroot ; __uint32_t xs_abtc_2_killroot ; __uint32_t xs_abtc_2_increment ; __uint32_t xs_abtc_2_decrement ; __uint32_t xs_abtc_2_lshift ; __uint32_t xs_abtc_2_rshift ; __uint32_t xs_abtc_2_split ; __uint32_t xs_abtc_2_join ; __uint32_t xs_abtc_2_alloc ; __uint32_t xs_abtc_2_free ; __uint32_t xs_abtc_2_moves ; __uint32_t xs_bmbt_2_lookup ; __uint32_t xs_bmbt_2_compare ; __uint32_t xs_bmbt_2_insrec ; __uint32_t xs_bmbt_2_delrec ; __uint32_t xs_bmbt_2_newroot ; __uint32_t xs_bmbt_2_killroot ; __uint32_t xs_bmbt_2_increment ; __uint32_t xs_bmbt_2_decrement ; __uint32_t xs_bmbt_2_lshift ; __uint32_t xs_bmbt_2_rshift ; __uint32_t xs_bmbt_2_split ; __uint32_t xs_bmbt_2_join ; __uint32_t xs_bmbt_2_alloc ; __uint32_t xs_bmbt_2_free ; __uint32_t xs_bmbt_2_moves ; __uint32_t xs_ibt_2_lookup ; __uint32_t xs_ibt_2_compare ; __uint32_t xs_ibt_2_insrec ; __uint32_t xs_ibt_2_delrec ; __uint32_t xs_ibt_2_newroot ; __uint32_t xs_ibt_2_killroot ; __uint32_t xs_ibt_2_increment ; __uint32_t xs_ibt_2_decrement ; __uint32_t xs_ibt_2_lshift ; __uint32_t xs_ibt_2_rshift ; __uint32_t xs_ibt_2_split ; __uint32_t xs_ibt_2_join ; __uint32_t xs_ibt_2_alloc ; __uint32_t xs_ibt_2_free ; __uint32_t xs_ibt_2_moves ; __uint64_t xs_xstrat_bytes ; __uint64_t xs_write_bytes ; __uint64_t xs_read_bytes ; } ;


typedef struct xfs_ioend { struct xfs_ioend * io_list ; unsigned int io_type ; int io_error ; atomic_t io_remaining ; struct inode * io_inode ; struct buffer_head * io_buffer_head ; struct buffer_head * io_buffer_tail ; size_t io_size ; xfs_off_t io_offset ; struct work_struct io_work ; } xfs_ioend_t ;

struct xfs_mount ;

struct xfs_buftarg ;

struct block_device ;
struct xfs_bmbt_irec ;

struct xfs_buf ;

typedef enum { XBRW_READ = 1 , XBRW_WRITE = 2 , XBRW_ZERO = 3 , } xfs_buf_rw_t ;

typedef enum { XBF_READ = ( 1 << 0 ) , XBF_WRITE = ( 1 << 1 ) , XBF_MAPPED = ( 1 << 2 ) , XBF_ASYNC = ( 1 << 4 ) , XBF_DONE = ( 1 << 5 ) , XBF_DELWRI = ( 1 << 6 ) , XBF_STALE = ( 1 << 7 ) , XBF_FS_MANAGED = ( 1 << 8 ) , XBF_ORDERED = ( 1 << 11 ) , XBF_READ_AHEAD = ( 1 << 12 ) , XBF_LOCK = ( 1 << 14 ) , XBF_TRYLOCK = ( 1 << 15 ) , XBF_DONT_BLOCK = ( 1 << 16 ) , _XBF_PAGE_CACHE = ( 1 << 17 ) , _XBF_PAGES = ( 1 << 18 ) , _XBF_RUN_QUEUES = ( 1 << 19 ) , _XBF_DELWRI_Q = ( 1 << 21 ) , _XBF_PAGE_LOCKED = ( 1 << 22 ) , _XFS_BARRIER_FAILED = ( 1 << 23 ) , } xfs_buf_flags_t ;

typedef enum { XBT_FORCE_SLEEP = 0 , XBT_FORCE_FLUSH = 1 , } xfs_buftarg_flags_t ;


typedef struct xfs_bufhash { struct list_head bh_list ; spinlock_t bh_lock ; } xfs_bufhash_t ;

typedef struct xfs_buftarg { dev_t bt_dev ; struct block_device * bt_bdev ; struct address_space * bt_mapping ; unsigned int bt_bsize ; unsigned int bt_sshift ; size_t bt_smask ; uint bt_hashmask ; uint bt_hashshift ; xfs_bufhash_t * bt_hash ; struct task_struct * bt_task ; struct list_head bt_list ; struct list_head bt_delwrite_queue ; spinlock_t bt_delwrite_lock ; unsigned long bt_flags ; } xfs_buftarg_t ;

typedef void ( * xfs_buf_iodone_t ) ( struct xfs_buf * ) ;
typedef void ( * xfs_buf_relse_t ) ( struct xfs_buf * ) ;
typedef int ( * xfs_buf_bdstrat_t ) ( struct xfs_buf * ) ;

typedef struct xfs_buf { struct semaphore b_sema ; unsigned long b_queuetime ; atomic_t b_pin_count ; wait_queue_head_t b_waiters ; struct list_head b_list ; xfs_buf_flags_t b_flags ; struct list_head b_hash_list ; xfs_bufhash_t * b_hash ; xfs_buftarg_t * b_target ; atomic_t b_hold ; xfs_daddr_t b_bn ; xfs_off_t b_file_offset ; size_t b_buffer_length ; size_t b_count_desired ; void * b_addr ; struct work_struct b_iodone_work ; atomic_t b_io_remaining ; xfs_buf_iodone_t b_iodone ; xfs_buf_relse_t b_relse ; xfs_buf_bdstrat_t b_strat ; struct completion b_iowait ; void * b_fspriv ; void * b_fspriv2 ; struct xfs_mount * b_mount ; unsigned short b_error ; unsigned int b_page_count ; unsigned int b_offset ; struct page * * b_pages ; struct page * b_page_array [ 2 ] ; } xfs_buf_t ;


typedef struct xfs_log_iovec { xfs_caddr_t i_addr ; int i_len ; uint i_type ; } xfs_log_iovec_t ;

typedef void * xfs_log_ticket_t ;


typedef struct xfs_log_callback { struct xfs_log_callback * cb_next ; void ( * cb_func ) ( void * , int ) ; void * cb_arg ; } xfs_log_callback_t ;

struct xlog_ticket ;

typedef __uint32_t xfs_agino_t ;

typedef xfs_ino_t xfs_intino_t ;

struct xfs_log_item ;


typedef struct xfs_trans_header { uint th_magic ; uint th_type ; __int32_t th_tid ; uint th_num_items ; } xfs_trans_header_t ;


typedef struct xfs_log_item_desc { struct xfs_log_item * lid_item ; ushort lid_size ; unsigned char lid_flags ; unsigned char lid_index ; } xfs_log_item_desc_t ;


typedef struct xfs_log_item_chunk { struct xfs_log_item_chunk * lic_next ; ushort lic_free ; ushort lic_unused ; xfs_log_item_desc_t lic_descs [ 15 ] ; } xfs_log_item_chunk_t ;

struct xfs_efd_log_item ;

struct xfs_efi_log_item ;

struct xfs_item_ops ;

struct xfs_log_iovec ;
struct xfs_log_item_desc ;
struct xfs_trans ;

struct xfs_dquot_acct ;

typedef struct xfs_log_item { struct list_head li_ail ; xfs_lsn_t li_lsn ; struct xfs_log_item_desc * li_desc ; struct xfs_mount * li_mountp ; struct xfs_ail * li_ailp ; uint li_type ; uint li_flags ; struct xfs_log_item * li_bio_list ; void ( * li_cb ) ( struct xfs_buf * , struct xfs_log_item * ) ; struct xfs_item_ops * li_ops ; } xfs_log_item_t ;

typedef struct xfs_item_ops { uint ( * iop_size ) ( xfs_log_item_t * ) ; void ( * iop_format ) ( xfs_log_item_t * , struct xfs_log_iovec * ) ; void ( * iop_pin ) ( xfs_log_item_t * ) ; void ( * iop_unpin ) ( xfs_log_item_t * , int ) ; void ( * iop_unpin_remove ) ( xfs_log_item_t * , struct xfs_trans * ) ; uint ( * iop_trylock ) ( xfs_log_item_t * ) ; void ( * iop_unlock ) ( xfs_log_item_t * ) ; xfs_lsn_t ( * iop_committed ) ( xfs_log_item_t * , xfs_lsn_t ) ; void ( * iop_push ) ( xfs_log_item_t * ) ; void ( * iop_pushbuf ) ( xfs_log_item_t * ) ; void ( * iop_committing ) ( xfs_log_item_t * , xfs_lsn_t ) ; } xfs_item_ops_t ;


typedef struct xfs_log_busy_slot { xfs_agnumber_t lbc_ag ; ushort lbc_idx ; } xfs_log_busy_slot_t ;


typedef struct xfs_log_busy_chunk { struct xfs_log_busy_chunk * lbc_next ; uint lbc_free ; ushort lbc_unused ; xfs_log_busy_slot_t lbc_busy [ 31 ] ; } xfs_log_busy_chunk_t ;

typedef void ( * xfs_trans_callback_t ) ( struct xfs_trans * , void * ) ;

typedef struct xfs_trans { unsigned int t_magic ; xfs_log_callback_t t_logcb ; unsigned int t_type ; unsigned int t_log_res ; unsigned int t_log_count ; unsigned int t_blk_res ; unsigned int t_blk_res_used ; unsigned int t_rtx_res ; unsigned int t_rtx_res_used ; xfs_log_ticket_t t_ticket ; xfs_lsn_t t_lsn ; xfs_lsn_t t_commit_lsn ; struct xfs_mount * t_mountp ; struct xfs_dquot_acct * t_dqinfo ; xfs_trans_callback_t t_callback ; void * t_callarg ; unsigned int t_flags ; int64_t t_icount_delta ; int64_t t_ifree_delta ; int64_t t_fdblocks_delta ; int64_t t_res_fdblocks_delta ; int64_t t_frextents_delta ; int64_t t_res_frextents_delta ; int64_t t_dblocks_delta ; int64_t t_agcount_delta ; int64_t t_imaxpct_delta ; int64_t t_rextsize_delta ; int64_t t_rbmblocks_delta ; int64_t t_rblocks_delta ; int64_t t_rextents_delta ; int64_t t_rextslog_delta ; unsigned int t_items_free ; xfs_log_item_chunk_t t_items ; xfs_trans_header_t t_header ; unsigned int t_busy_free ; xfs_log_busy_chunk_t t_busy ; unsigned long t_pflags ; } xfs_trans_t ;


typedef struct xfs_sb { __uint32_t sb_magicnum ; __uint32_t sb_blocksize ; xfs_drfsbno_t sb_dblocks ; xfs_drfsbno_t sb_rblocks ; xfs_drtbno_t sb_rextents ; uuid_t sb_uuid ; xfs_dfsbno_t sb_logstart ; xfs_ino_t sb_rootino ; xfs_ino_t sb_rbmino ; xfs_ino_t sb_rsumino ; xfs_agblock_t sb_rextsize ; xfs_agblock_t sb_agblocks ; xfs_agnumber_t sb_agcount ; xfs_extlen_t sb_rbmblocks ; xfs_extlen_t sb_logblocks ; __uint16_t sb_versionnum ; __uint16_t sb_sectsize ; __uint16_t sb_inodesize ; __uint16_t sb_inopblock ; char sb_fname [ 12 ] ; __uint8_t sb_blocklog ; __uint8_t sb_sectlog ; __uint8_t sb_inodelog ; __uint8_t sb_inopblog ; __uint8_t sb_agblklog ; __uint8_t sb_rextslog ; __uint8_t sb_inprogress ; __uint8_t sb_imax_pct ; __uint64_t sb_icount ; __uint64_t sb_ifree ; __uint64_t sb_fdblocks ; __uint64_t sb_frextents ; xfs_ino_t sb_uquotino ; xfs_ino_t sb_gquotino ; __uint16_t sb_qflags ; __uint8_t sb_flags ; __uint8_t sb_shared_vn ; xfs_extlen_t sb_inoalignmt ; __uint32_t sb_unit ; __uint32_t sb_width ; __uint8_t sb_dirblklog ; __uint8_t sb_logsectlog ; __uint16_t sb_logsectsize ; __uint32_t sb_logsunit ; __uint32_t sb_features2 ; __uint32_t sb_bad_features2 ; } xfs_sb_t ;


typedef struct xfs_dsb { __be32 sb_magicnum ; __be32 sb_blocksize ; __be64 sb_dblocks ; __be64 sb_rblocks ; __be64 sb_rextents ; uuid_t sb_uuid ; __be64 sb_logstart ; __be64 sb_rootino ; __be64 sb_rbmino ; __be64 sb_rsumino ; __be32 sb_rextsize ; __be32 sb_agblocks ; __be32 sb_agcount ; __be32 sb_rbmblocks ; __be32 sb_logblocks ; __be16 sb_versionnum ; __be16 sb_sectsize ; __be16 sb_inodesize ; __be16 sb_inopblock ; char sb_fname [ 12 ] ; __u8 sb_blocklog ; __u8 sb_sectlog ; __u8 sb_inodelog ; __u8 sb_inopblog ; __u8 sb_agblklog ; __u8 sb_rextslog ; __u8 sb_inprogress ; __u8 sb_imax_pct ; __be64 sb_icount ; __be64 sb_ifree ; __be64 sb_fdblocks ; __be64 sb_frextents ; __be64 sb_uquotino ; __be64 sb_gquotino ; __be16 sb_qflags ; __u8 sb_flags ; __u8 sb_shared_vn ; __be32 sb_inoalignmt ; __be32 sb_unit ; __be32 sb_width ; __u8 sb_dirblklog ; __u8 sb_logsectlog ; __be16 sb_logsectsize ; __be32 sb_logsunit ; __be32 sb_features2 ; __be32 sb_bad_features2 ; } xfs_dsb_t ;

typedef enum { XFS_SBS_MAGICNUM , XFS_SBS_BLOCKSIZE , XFS_SBS_DBLOCKS , XFS_SBS_RBLOCKS , XFS_SBS_REXTENTS , XFS_SBS_UUID , XFS_SBS_LOGSTART , XFS_SBS_ROOTINO , XFS_SBS_RBMINO , XFS_SBS_RSUMINO , XFS_SBS_REXTSIZE , XFS_SBS_AGBLOCKS , XFS_SBS_AGCOUNT , XFS_SBS_RBMBLOCKS , XFS_SBS_LOGBLOCKS , XFS_SBS_VERSIONNUM , XFS_SBS_SECTSIZE , XFS_SBS_INODESIZE , XFS_SBS_INOPBLOCK , XFS_SBS_FNAME , XFS_SBS_BLOCKLOG , XFS_SBS_SECTLOG , XFS_SBS_INODELOG , XFS_SBS_INOPBLOG , XFS_SBS_AGBLKLOG , XFS_SBS_REXTSLOG , XFS_SBS_INPROGRESS , XFS_SBS_IMAX_PCT , XFS_SBS_ICOUNT , XFS_SBS_IFREE , XFS_SBS_FDBLOCKS , XFS_SBS_FREXTENTS , XFS_SBS_UQUOTINO , XFS_SBS_GQUOTINO , XFS_SBS_QFLAGS , XFS_SBS_FLAGS , XFS_SBS_SHARED_VN , XFS_SBS_INOALIGNMT , XFS_SBS_UNIT , XFS_SBS_WIDTH , XFS_SBS_DIRBLKLOG , XFS_SBS_LOGSECTLOG , XFS_SBS_LOGSECTSIZE , XFS_SBS_LOGSUNIT , XFS_SBS_FEATURES2 , XFS_SBS_BAD_FEATURES2 , XFS_SBS_FIELDCOUNT } xfs_sb_field_t ;


typedef struct xfs_agf { __be32 agf_magicnum ; __be32 agf_versionnum ; __be32 agf_seqno ; __be32 agf_length ; __be32 agf_roots [ ( ( int ) XFS_BTNUM_CNTi + 1 ) ] ; __be32 agf_spare0 ; __be32 agf_levels [ ( ( int ) XFS_BTNUM_CNTi + 1 ) ] ; __be32 agf_spare1 ; __be32 agf_flfirst ; __be32 agf_fllast ; __be32 agf_flcount ; __be32 agf_freeblks ; __be32 agf_longest ; __be32 agf_btreeblks ; } xfs_agf_t ;


typedef struct xfs_agi { __be32 agi_magicnum ; __be32 agi_versionnum ; __be32 agi_seqno ; __be32 agi_length ; __be32 agi_count ; __be32 agi_root ; __be32 agi_level ; __be32 agi_freecount ; __be32 agi_newino ; __be32 agi_dirino ; __be32 agi_unlinked [ 64 ] ; } xfs_agi_t ;


typedef struct xfs_agfl { __be32 agfl_bno [ 1 ] ; } xfs_agfl_t ;


typedef struct xfs_perag_busy { xfs_agblock_t busy_start ; xfs_extlen_t busy_length ; struct xfs_trans * busy_tp ; } xfs_perag_busy_t ;


typedef struct xfs_perag { char pagf_init ; char pagi_init ; char pagf_metadata ; char pagi_inodeok ; __uint8_t pagf_levels [ ( ( int ) XFS_BTNUM_CNTi + 1 ) ] ; __uint32_t pagf_flcount ; xfs_extlen_t pagf_freeblks ; xfs_extlen_t pagf_longest ; __uint32_t pagf_btreeblks ; xfs_agino_t pagi_freecount ; xfs_agino_t pagi_count ; int pagb_count ; xfs_perag_busy_t * pagb_list ; xfs_agino_t pagl_pagino ; xfs_agino_t pagl_leftrec ; xfs_agino_t pagl_rightrec ; spinlock_t pagb_lock ; atomic_t pagf_fstrms ; int pag_ici_init ; rwlock_t pag_ici_lock ; struct radix_tree_root pag_ici_root ; int pag_ici_reclaimable ; } xfs_perag_t ;

struct uio ;

struct xfs_dabuf ;

struct xfs_da_args ;

struct xfs_dir2_put_args ;

struct xfs_bmap_free ;

typedef __uint16_t xfs_dir2_data_off_t ;

typedef uint xfs_dir2_data_aoff_t ;

typedef __uint32_t xfs_dir2_db_t ;

typedef xfs_off_t xfs_dir2_off_t ;

struct xfs_perag ;

typedef enum xfs_alloctype { XFS_ALLOCTYPE_ANY_AG , XFS_ALLOCTYPE_FIRST_AG , XFS_ALLOCTYPE_START_AG , XFS_ALLOCTYPE_THIS_AG , XFS_ALLOCTYPE_START_BNO , XFS_ALLOCTYPE_NEAR_BNO , XFS_ALLOCTYPE_THIS_BNO } xfs_alloctype_t ;


typedef struct xfs_alloc_arg { struct xfs_trans * tp ; struct xfs_mount * mp ; struct xfs_buf * agbp ; struct xfs_perag * pag ; xfs_fsblock_t fsbno ; xfs_agnumber_t agno ; xfs_agblock_t agbno ; xfs_extlen_t minlen ; xfs_extlen_t maxlen ; xfs_extlen_t mod ; xfs_extlen_t prod ; xfs_extlen_t minleft ; xfs_extlen_t total ; xfs_extlen_t alignment ; xfs_extlen_t minalignslop ; xfs_extlen_t len ; xfs_alloctype_t type ; xfs_alloctype_t otype ; char wasdel ; char wasfromfl ; char isfl ; char userdata ; xfs_fsblock_t firstblock ; } xfs_alloc_arg_t ;

typedef enum { DM_EVENT_INVALID = - 1 , DM_EVENT_CANCEL = 0 , DM_EVENT_MOUNT = 1 , DM_EVENT_PREUNMOUNT = 2 , DM_EVENT_UNMOUNT = 3 , DM_EVENT_DEBUT = 4 , DM_EVENT_CREATE = 5 , DM_EVENT_CLOSE = 6 , DM_EVENT_POSTCREATE = 7 , DM_EVENT_REMOVE = 8 , DM_EVENT_POSTREMOVE = 9 , DM_EVENT_RENAME = 10 , DM_EVENT_POSTRENAME = 11 , DM_EVENT_LINK = 12 , DM_EVENT_POSTLINK = 13 , DM_EVENT_SYMLINK = 14 , DM_EVENT_POSTSYMLINK = 15 , DM_EVENT_READ = 16 , DM_EVENT_WRITE = 17 , DM_EVENT_TRUNCATE = 18 , DM_EVENT_ATTRIBUTE = 19 , DM_EVENT_DESTROY = 20 , DM_EVENT_NOSPACE = 21 , DM_EVENT_USER = 22 , DM_EVENT_MAX = 23 } dm_eventtype_t ;

typedef enum { DM_RIGHT_NULL , DM_RIGHT_SHARED , DM_RIGHT_EXCL } dm_right_t ;

typedef __uint32_t xfs_dqid_t ;

typedef __uint64_t xfs_qcnt_t ;

typedef __uint16_t xfs_qwarncnt_t ;


typedef struct xfs_disk_dquot { __be16 d_magic ; __u8 d_version ; __u8 d_flags ; __be32 d_id ; __be64 d_blk_hardlimit ; __be64 d_blk_softlimit ; __be64 d_ino_hardlimit ; __be64 d_ino_softlimit ; __be64 d_bcount ; __be64 d_icount ; __be32 d_itimer ; __be32 d_btimer ; __be16 d_iwarns ; __be16 d_bwarns ; __be32 d_pad0 ; __be64 d_rtb_hardlimit ; __be64 d_rtb_softlimit ; __be64 d_rtbcount ; __be32 d_rtbtimer ; __be16 d_rtbwarns ; __be16 d_pad ; } xfs_disk_dquot_t ;


typedef struct xfs_dqblk { xfs_disk_dquot_t dd_diskdq ; char dd_fill [ 32 ] ; } xfs_dqblk_t ;


typedef struct xfs_dq_logformat { __uint16_t qlf_type ; __uint16_t qlf_size ; xfs_dqid_t qlf_id ; __int64_t qlf_blkno ; __int32_t qlf_len ; __uint32_t qlf_boffset ; } xfs_dq_logformat_t ;


typedef struct xfs_qoff_logformat { unsigned short qf_type ; unsigned short qf_size ; unsigned int qf_flags ; char qf_pad [ 12 ] ; } xfs_qoff_logformat_t ;


typedef struct xfs_dqtrx { struct xfs_dquot * qt_dquot ; ulong qt_blk_res ; ulong qt_blk_res_used ; ulong qt_ino_res ; ulong qt_ino_res_used ; long qt_bcount_delta ; long qt_delbcnt_delta ; long qt_icount_delta ; ulong qt_rtblk_res ; ulong qt_rtblk_res_used ; long qt_rtbcount_delta ; long qt_delrtb_delta ; } xfs_dqtrx_t ;


typedef struct xfs_trans_reservations { uint tr_write ; uint tr_itruncate ; uint tr_rename ; uint tr_link ; uint tr_remove ; uint tr_symlink ; uint tr_create ; uint tr_mkdir ; uint tr_ifree ; uint tr_ichange ; uint tr_growdata ; uint tr_swrite ; uint tr_addafork ; uint tr_writeid ; uint tr_attrinval ; uint tr_attrset ; uint tr_attrrm ; uint tr_clearagi ; uint tr_growrtalloc ; uint tr_growrtzero ; uint tr_growrtfree ; } xfs_trans_reservations_t ;


typedef struct xfs_sync_work { struct list_head w_list ; struct xfs_mount * w_mount ; void * w_data ; void ( * w_syncer ) ( struct xfs_mount * , void * ) ; struct completion * w_completion ; } xfs_sync_work_t ;

struct log ;

struct xfs_mount_args ;

struct xfs_extdelta ;

struct xfs_swapext ;

struct xfs_mru_cache ;

struct xfs_nameops ;

struct xfs_ail ;

struct xfs_quotainfo ;

typedef int ( * xfs_send_data_t ) ( int , struct xfs_inode * , xfs_off_t , size_t , int , int * ) ;
typedef int ( * xfs_send_mmap_t ) ( struct vm_area_struct * , uint ) ;
typedef int ( * xfs_send_destroy_t ) ( struct xfs_inode * , dm_right_t ) ;
typedef int ( * xfs_send_namesp_t ) ( dm_eventtype_t , struct xfs_mount * , struct xfs_inode * , dm_right_t , struct xfs_inode * , dm_right_t , const char * , const char * , mode_t , int , int ) ;
typedef int ( * xfs_send_mount_t ) ( struct xfs_mount * , dm_right_t , char * , char * ) ;
typedef void ( * xfs_send_unmount_t ) ( struct xfs_mount * , struct xfs_inode * , dm_right_t , mode_t , int , int ) ;

typedef struct xfs_dmops { xfs_send_data_t xfs_send_data ; xfs_send_mmap_t xfs_send_mmap ; xfs_send_destroy_t xfs_send_destroy ; xfs_send_namesp_t xfs_send_namesp ; xfs_send_mount_t xfs_send_mount ; xfs_send_unmount_t xfs_send_unmount ; } xfs_dmops_t ;


typedef struct xfs_icsb_cnts { uint64_t icsb_fdblocks ; uint64_t icsb_ifree ; uint64_t icsb_icount ; unsigned long icsb_flags ; } xfs_icsb_cnts_t ;

typedef struct xfs_mount { struct super_block * m_super ; xfs_tid_t m_tid ; struct xfs_ail * m_ail ; xfs_sb_t m_sb ; spinlock_t m_sb_lock ; struct xfs_buf * m_sb_bp ; char * m_fsname ; int m_fsname_len ; char * m_rtname ; char * m_logname ; int m_bsize ; xfs_agnumber_t m_agfrotor ; xfs_agnumber_t m_agirotor ; spinlock_t m_agirotor_lock ; xfs_agnumber_t m_maxagi ; uint m_readio_log ; uint m_readio_blocks ; uint m_writeio_log ; uint m_writeio_blocks ; struct log * m_log ; int m_logbufs ; int m_logbsize ; uint m_rsumlevels ; uint m_rsumsize ; struct xfs_inode * m_rbmip ; struct xfs_inode * m_rsumip ; struct xfs_inode * m_rootip ; struct xfs_quotainfo * m_quotainfo ; xfs_buftarg_t * m_ddev_targp ; xfs_buftarg_t * m_logdev_targp ; xfs_buftarg_t * m_rtdev_targp ; __uint8_t m_blkbit_log ; __uint8_t m_blkbb_log ; __uint8_t m_agno_log ; __uint8_t m_agino_log ; __uint16_t m_inode_cluster_size ; uint m_blockmask ; uint m_blockwsize ; uint m_blockwmask ; uint m_alloc_mxr [ 2 ] ; uint m_alloc_mnr [ 2 ] ; uint m_bmap_dmxr [ 2 ] ; uint m_bmap_dmnr [ 2 ] ; uint m_inobt_mxr [ 2 ] ; uint m_inobt_mnr [ 2 ] ; uint m_ag_maxlevels ; uint m_bm_maxlevels [ 2 ] ; uint m_in_maxlevels ; struct xfs_perag * m_perag ; struct rw_semaphore m_peraglock ; struct mutex m_growlock ; int m_fixedfsid [ 2 ] ; uint m_dmevmask ; __uint64_t m_flags ; uint m_dir_node_ents ; uint m_attr_node_ents ; int m_ialloc_inos ; int m_ialloc_blks ; int m_inoalign_mask ; uint m_qflags ; xfs_trans_reservations_t m_reservations ; __uint64_t m_maxicount ; __uint64_t m_maxioffset ; __uint64_t m_resblks ; __uint64_t m_resblks_avail ; __uint64_t m_resblks_save ; int m_dalign ; int m_swidth ; int m_sinoalign ; int m_attr_magicpct ; int m_dir_magicpct ; __uint8_t m_sectbb_log ; const struct xfs_nameops * m_dirnameops ; int m_dirblksize ; int m_dirblkfsbs ; xfs_dablk_t m_dirdatablk ; xfs_dablk_t m_dirleafblk ; xfs_dablk_t m_dirfreeblk ; uint m_chsize ; struct xfs_chash * m_chash ; struct xfs_dmops * m_dm_ops ; struct xfs_qmops * m_qm_ops ; atomic_t m_active_trans ; xfs_icsb_cnts_t * m_sb_cnts ; unsigned long m_icsb_counters ; struct notifier_block m_icsb_notifier ; struct mutex m_icsb_mutex ; struct xfs_mru_cache * m_filestream ; struct task_struct * m_sync_task ; xfs_sync_work_t m_sync_work ; struct list_head m_sync_list ; spinlock_t m_sync_lock ; int m_sync_seq ; wait_queue_head_t m_wait_single_sync_task ; __int64_t m_update_flags ; struct list_head m_mplist ; } xfs_mount_t ;


typedef struct xfs_mod_sb { xfs_sb_field_t msb_field ; int64_t msb_delta ; } xfs_mod_sb_t ;

struct xfs_btree_cur ;

struct xfs_btree_block ;


typedef struct xfs_bmdr_block { __be16 bb_level ; __be16 bb_numrecs ; } xfs_bmdr_block_t ;


typedef struct xfs_bmbt_rec_32 { __uint32_t l0 , l1 , l2 , l3 ; } xfs_bmbt_rec_32_t ;


typedef struct xfs_bmbt_rec_64 { __be64 l0 , l1 ; } xfs_bmbt_rec_64_t ;

typedef __uint64_t xfs_bmbt_rec_base_t ;

typedef xfs_bmbt_rec_64_t xfs_bmbt_rec_t , xfs_bmdr_rec_t ;


typedef struct xfs_bmbt_rec_host { __uint64_t l0 , l1 ; } xfs_bmbt_rec_host_t ;

typedef enum { XFS_EXTFMT_NOSTATE = 0 , XFS_EXTFMT_HASSTATE } xfs_exntfmt_t ;

typedef enum { XFS_EXT_NORM , XFS_EXT_UNWRITTEN , XFS_EXT_DMAPI_OFFLINE , XFS_EXT_INVALID } xfs_exntst_t ;

typedef struct xfs_bmbt_irec { xfs_fileoff_t br_startoff ; xfs_fsblock_t br_startblock ; xfs_filblks_t br_blockcount ; xfs_exntst_t br_state ; } xfs_bmbt_irec_t ;


typedef struct xfs_bmbt_key { __be64 br_startoff ; } xfs_bmbt_key_t , xfs_bmdr_key_t ;

typedef __be64 xfs_bmbt_ptr_t , xfs_bmdr_ptr_t ;


typedef struct xfs_alloc_rec { __be32 ar_startblock ; __be32 ar_blockcount ; } xfs_alloc_rec_t , xfs_alloc_key_t ;


typedef struct xfs_alloc_rec_incore { xfs_agblock_t ar_startblock ; xfs_extlen_t ar_blockcount ; } xfs_alloc_rec_incore_t ;

typedef __be32 xfs_alloc_ptr_t ;

typedef __uint64_t xfs_inofree_t ;


typedef struct xfs_inobt_rec { __be32 ir_startino ; __be32 ir_freecount ; __be64 ir_free ; } xfs_inobt_rec_t ;


typedef struct xfs_inobt_rec_incore { xfs_agino_t ir_startino ; __int32_t ir_freecount ; xfs_inofree_t ir_free ; } xfs_inobt_rec_incore_t ;


typedef struct xfs_inobt_key { __be32 ir_startino ; } xfs_inobt_key_t ;

typedef __be32 xfs_inobt_ptr_t ;

struct xfs_dir2_block ;

typedef struct { __uint8_t i [ 8 ] ; } xfs_dir2_ino8_t ;

typedef struct { __uint8_t i [ 4 ] ; } xfs_dir2_ino4_t ;

typedef union { xfs_dir2_ino8_t i8 ; xfs_dir2_ino4_t i4 ; } xfs_dir2_inou_t ;

typedef struct { __uint8_t i [ 2 ] ; } xfs_dir2_sf_off_t ;


typedef struct xfs_dir2_sf_hdr { __uint8_t count ; __uint8_t i8count ; xfs_dir2_inou_t parent ; } xfs_dir2_sf_hdr_t ;


typedef struct xfs_dir2_sf_entry { __uint8_t namelen ; xfs_dir2_sf_off_t offset ; __uint8_t name [ 1 ] ; xfs_dir2_inou_t inumber ; } xfs_dir2_sf_entry_t ;


typedef struct xfs_dir2_sf { xfs_dir2_sf_hdr_t hdr ; xfs_dir2_sf_entry_t list [ 1 ] ; } xfs_dir2_sf_t ;


typedef struct xfs_attr_shortform { struct xfs_attr_sf_hdr { __be16 totsize ; __u8 count ; } hdr ; struct xfs_attr_sf_entry { __uint8_t namelen ; __uint8_t valuelen ; __uint8_t flags ; __uint8_t nameval [ 1 ] ; } list [ 1 ] ; } xfs_attr_shortform_t ;

typedef struct xfs_attr_sf_hdr xfs_attr_sf_hdr_t ;

typedef struct xfs_attr_sf_entry xfs_attr_sf_entry_t ;


typedef struct xfs_attr_sf_sort { __uint8_t entno ; __uint8_t namelen ; __uint8_t valuelen ; __uint8_t flags ; xfs_dahash_t hash ; char * name ; } xfs_attr_sf_sort_t ;


typedef struct xfs_timestamp { __be32 t_sec ; __be32 t_nsec ; } xfs_timestamp_t ;


typedef struct xfs_dinode { __be16 di_magic ; __be16 di_mode ; __u8 di_version ; __u8 di_format ; __be16 di_onlink ; __be32 di_uid ; __be32 di_gid ; __be32 di_nlink ; __be16 di_projid ; __u8 di_pad [ 8 ] ; __be16 di_flushiter ; xfs_timestamp_t di_atime ; xfs_timestamp_t di_mtime ; xfs_timestamp_t di_ctime ; __be64 di_size ; __be64 di_nblocks ; __be32 di_extsize ; __be32 di_nextents ; __be16 di_anextents ; __u8 di_forkoff ; __s8 di_aformat ; __be32 di_dmevmask ; __be16 di_dmstate ; __be16 di_flags ; __be32 di_gen ; __be32 di_next_unlinked ; } __attribute__ ( ( packed ) ) xfs_dinode_t ;


typedef enum xfs_dinode_fmt { XFS_DINODE_FMT_DEV , XFS_DINODE_FMT_LOCAL , XFS_DINODE_FMT_EXTENTS , XFS_DINODE_FMT_BTREE , XFS_DINODE_FMT_UUID } xfs_dinode_fmt_t ;

struct xfs_dinode ;

typedef struct xfs_ext_irec { xfs_bmbt_rec_host_t * er_extbuf ; xfs_extnum_t er_extoff ; xfs_extnum_t er_extcount ; } xfs_ext_irec_t ;


typedef struct xfs_ifork { int if_bytes ; int if_real_bytes ; struct xfs_btree_block * if_broot ; short if_broot_bytes ; unsigned char if_flags ; unsigned char if_ext_max ; xfs_extnum_t if_lastex ; union { xfs_bmbt_rec_host_t * if_extents ; xfs_ext_irec_t * if_ext_irec ; char * if_data ; } if_u1 ; union { xfs_bmbt_rec_host_t if_inline_ext [ 2 ] ; char if_inline_data [ 32 ] ; xfs_dev_t if_rdev ; uuid_t if_uuid ; } if_u2 ; } xfs_ifork_t ;

struct xfs_imap { xfs_daddr_t im_blkno ; ushort im_len ; ushort im_boffset ; } ;


typedef struct xfs_ictimestamp { __int32_t t_sec ; __int32_t t_nsec ; } xfs_ictimestamp_t ;


typedef struct xfs_icdinode { __uint16_t di_magic ; __uint16_t di_mode ; __int8_t di_version ; __int8_t di_format ; __uint16_t di_onlink ; __uint32_t di_uid ; __uint32_t di_gid ; __uint32_t di_nlink ; __uint16_t di_projid ; __uint8_t di_pad [ 8 ] ; __uint16_t di_flushiter ; xfs_ictimestamp_t di_atime ; xfs_ictimestamp_t di_mtime ; xfs_ictimestamp_t di_ctime ; xfs_fsize_t di_size ; xfs_drfsbno_t di_nblocks ; xfs_extlen_t di_extsize ; xfs_extnum_t di_nextents ; xfs_aextnum_t di_anextents ; __uint8_t di_forkoff ; __int8_t di_aformat ; __uint32_t di_dmevmask ; __uint16_t di_dmstate ; __uint16_t di_flags ; __uint32_t di_gen ; } xfs_icdinode_t ;

struct bhv_desc ;

struct ktrace ;
struct xfs_inode_log_item ;

struct xfs_dquot ;


typedef struct dm_attrs_s { __uint32_t da_dmevmask ; __uint16_t da_dmstate ; __uint16_t da_pad ; } dm_attrs_t ;

typedef struct xfs_inode { struct xfs_mount * i_mount ; struct xfs_dquot * i_udquot ; struct xfs_dquot * i_gdquot ; xfs_ino_t i_ino ; struct xfs_imap i_imap ; xfs_ifork_t * i_afp ; xfs_ifork_t i_df ; struct xfs_trans * i_transp ; struct xfs_inode_log_item * i_itemp ; mrlock_t i_lock ; mrlock_t i_iolock ; struct completion i_flush ; atomic_t i_pincount ; wait_queue_head_t i_ipin_wait ; spinlock_t i_flags_lock ; unsigned short i_flags ; unsigned char i_update_core ; unsigned int i_delayed_blks ; xfs_icdinode_t i_d ; xfs_fsize_t i_size ; xfs_fsize_t i_new_size ; atomic_t i_iocount ; struct inode i_vnode ; } xfs_inode_t ;

struct xfs_btree_block { __be32 bb_magic ; __be16 bb_level ; __be16 bb_numrecs ; union { struct { __be32 bb_leftsib ; __be32 bb_rightsib ; } s ; struct { __be64 bb_leftsib ; __be64 bb_rightsib ; } l ; } bb_u ; } ;
union xfs_btree_ptr { __be32 s ; __be64 l ; } ;

union xfs_btree_key { xfs_bmbt_key_t bmbt ; xfs_bmdr_key_t bmbr ; xfs_alloc_key_t alloc ; xfs_inobt_key_t inobt ; } ;

union xfs_btree_rec { xfs_bmbt_rec_t bmbt ; xfs_bmdr_rec_t bmbr ; xfs_alloc_rec_t alloc ; xfs_inobt_rec_t inobt ; } ;

struct xfs_btree_ops { size_t key_len ; size_t rec_len ; struct xfs_btree_cur * ( * dup_cursor ) ( struct xfs_btree_cur * ) ; void ( * update_cursor ) ( struct xfs_btree_cur * src , struct xfs_btree_cur * dst ) ; void ( * set_root ) ( struct xfs_btree_cur * cur , union xfs_btree_ptr * nptr , int level_change ) ; int ( * kill_root ) ( struct xfs_btree_cur * cur , struct xfs_buf * bp , int level , union xfs_btree_ptr * newroot ) ; int ( * alloc_block ) ( struct xfs_btree_cur * cur , union xfs_btree_ptr * start_bno , union xfs_btree_ptr * new_bno , int length , int * stat ) ; int ( * free_block ) ( struct xfs_btree_cur * cur , struct xfs_buf * bp ) ; void ( * update_lastrec ) ( struct xfs_btree_cur * cur , struct xfs_btree_block * block , union xfs_btree_rec * rec , int ptr , int reason ) ; int ( * get_minrecs ) ( struct xfs_btree_cur * cur , int level ) ; int ( * get_maxrecs ) ( struct xfs_btree_cur * cur , int level ) ; int ( * get_dmaxrecs ) ( struct xfs_btree_cur * cur , int level ) ; void ( * init_key_from_rec ) ( union xfs_btree_key * key , union xfs_btree_rec * rec ) ; void ( * init_rec_from_key ) ( union xfs_btree_key * key , union xfs_btree_rec * rec ) ; void ( * init_rec_from_cur ) ( struct xfs_btree_cur * cur , union xfs_btree_rec * rec ) ; void ( * init_ptr_from_cur ) ( struct xfs_btree_cur * cur , union xfs_btree_ptr * ptr ) ; __int64_t ( * key_diff ) ( struct xfs_btree_cur * cur , union xfs_btree_key * key ) ; } ;

typedef struct xfs_btree_cur { struct xfs_trans * bc_tp ; struct xfs_mount * bc_mp ; const struct xfs_btree_ops * bc_ops ; uint bc_flags ; union { xfs_alloc_rec_incore_t a ; xfs_bmbt_irec_t b ; xfs_inobt_rec_incore_t i ; } bc_rec ; struct xfs_buf * bc_bufs [ 8 ] ; int bc_ptrs [ 8 ] ; __uint8_t bc_ra [ 8 ] ; __uint8_t bc_nlevels ; __uint8_t bc_blocklog ; xfs_btnum_t bc_btnum ; union { struct { struct xfs_buf * agbp ; xfs_agnumber_t agno ; } a ; struct { struct xfs_inode * ip ; struct xfs_bmap_free * flist ; xfs_fsblock_t firstblock ; int allocated ; short forksize ; char whichfork ; char flags ; } b ; } bc_private ; } xfs_btree_cur_t ;

struct xfs_imap ;
struct getbmap ;
struct xfs_ifork ;
typedef struct xfs_extdelta { xfs_fileoff_t xed_startoff ; xfs_filblks_t xed_blockcount ; } xfs_extdelta_t ;


typedef struct xfs_bmap_free_item { xfs_fsblock_t xbfi_startblock ; xfs_extlen_t xbfi_blockcount ; struct xfs_bmap_free_item * xbfi_next ; } xfs_bmap_free_item_t ;

typedef struct xfs_bmap_free { xfs_bmap_free_item_t * xbf_first ; int xbf_count ; int xbf_low ; } xfs_bmap_free_t ;


typedef struct xfs_bmalloca { xfs_fsblock_t firstblock ; xfs_fsblock_t rval ; xfs_fileoff_t off ; struct xfs_trans * tp ; struct xfs_inode * ip ; struct xfs_bmbt_irec * prevp ; struct xfs_bmbt_irec * gotp ; xfs_extlen_t alen ; xfs_extlen_t total ; xfs_extlen_t minlen ; xfs_extlen_t minleft ; char eof ; char wasdel ; char userdata ; char low ; char aeof ; char conv ; } xfs_bmalloca_t ;

typedef int ( * xfs_bmap_format_t ) ( void * * , struct getbmapx * , int * ) ;
typedef int ( * bulkstat_one_pf ) ( struct xfs_mount * mp , xfs_ino_t ino , void * buffer , int ubsize , void * private_data , xfs_daddr_t bno , int * ubused , void * dip , int * stat ) ;
typedef int ( * bulkstat_one_fmt_pf ) ( void * ubuffer , int ubsize , int * ubused , const xfs_bstat_t * buffer ) ;
typedef int ( * inumbers_fmt_pf ) ( void * ubuffer , const xfs_inogrp_t * buffer , long count , long * written ) ;
struct xfs_attr_list_context ;


typedef struct attrlist { __s32 al_count ; __s32 al_more ; __s32 al_offset [ 1 ] ; } attrlist_t ;


typedef struct attrlist_ent { __u32 a_valuelen ; char a_name [ 1 ] ; } attrlist_ent_t ;

typedef struct attrlist_cursor_kern { __u32 hashval ; __u32 blkno ; __u32 offset ; __u16 pad1 ; __u8 pad2 ; __u8 initted ; } attrlist_cursor_kern_t ;

typedef int ( * put_listent_func_t ) ( struct xfs_attr_list_context * , int , char * , int , int , char * ) ;

typedef struct xfs_attr_list_context { struct xfs_inode * dp ; struct attrlist_cursor_kern * cursor ; char * alist ; int seen_enough ; ssize_t count ; int dupcnt ; int bufsize ; int firstu ; int flags ; int resynch ; int put_value ; put_listent_func_t put_listent ; int index ; } xfs_attr_list_context_t ;


typedef struct xfs_buf_log_format_t { unsigned short blf_type ; unsigned short blf_size ; ushort blf_flags ; ushort blf_len ; __int64_t blf_blkno ; unsigned int blf_map_size ; unsigned int blf_data_map [ 1 ] ; } xfs_buf_log_format_t ;

struct xfs_buf_log_item ;

typedef struct xfs_buf_log_item { xfs_log_item_t bli_item ; struct xfs_buf * bli_buf ; unsigned int bli_flags ; unsigned int bli_recur ; atomic_t bli_refcount ; xfs_buf_log_format_t bli_format ; } xfs_buf_log_item_t ;


typedef struct xfs_buf_cancel { xfs_daddr_t bc_blkno ; uint bc_len ; int bc_refcount ; struct xfs_buf_cancel * bc_next ; } xfs_buf_cancel_t ;

struct xfs_ail_cursor { struct xfs_ail_cursor * next ; struct xfs_log_item * item ; } ;

struct xfs_ail { struct xfs_mount * xa_mount ; struct list_head xa_ail ; uint xa_gen ; struct task_struct * xa_task ; xfs_lsn_t xa_target ; struct xfs_ail_cursor xa_cursors ; spinlock_t xa_lock ; } ;
struct xfs_qoff_logitem ;


typedef struct xfs_dq_logitem { xfs_log_item_t qli_item ; struct xfs_dquot * qli_dquot ; xfs_lsn_t qli_flush_lsn ; unsigned short qli_pushbuf_flag ; xfs_dq_logformat_t qli_format ; } xfs_dq_logitem_t ;

typedef struct xfs_qoff_logitem { xfs_log_item_t qql_item ; struct xfs_qoff_logitem * qql_start_lip ; xfs_qoff_logformat_t qql_format ; } xfs_qoff_logitem_t ;


typedef struct xfs_dqhash { struct xfs_dquot * qh_next ; struct mutex qh_lock ; uint qh_version ; uint qh_nelems ; } xfs_dqhash_t ;


typedef struct xfs_dqlink { struct xfs_dquot * ql_next ; struct xfs_dquot * * ql_prevp ; } xfs_dqlink_t ;


typedef struct xfs_dqmarker { struct xfs_dquot * dqm_flnext ; struct xfs_dquot * dqm_flprev ; xfs_dqlink_t dqm_mplist ; xfs_dqlink_t dqm_hashlist ; uint dqm_flags ; } xfs_dqmarker_t ;

typedef struct xfs_dquot { xfs_dqmarker_t q_lists ; xfs_dqhash_t * q_hash ; struct xfs_mount * q_mount ; struct xfs_trans * q_transp ; uint q_nrefs ; xfs_daddr_t q_blkno ; int q_bufoffset ; xfs_fileoff_t q_fileoffset ; struct xfs_dquot * q_gdquot ; xfs_disk_dquot_t q_core ; xfs_dq_logitem_t q_logitem ; xfs_qcnt_t q_res_bcount ; xfs_qcnt_t q_res_icount ; xfs_qcnt_t q_res_rtbcount ; struct mutex q_qlock ; struct completion q_flush ; atomic_t q_pincount ; wait_queue_head_t q_pinwait ; } xfs_dquot_t ;

enum { XFS_QLOCK_NORMAL = 0 , XFS_QLOCK_NESTED , } ;
struct xqmstats { __uint32_t xs_qm_dqreclaims ; __uint32_t xs_qm_dqreclaim_misses ; __uint32_t xs_qm_dquot_dups ; __uint32_t xs_qm_dqcachemisses ; __uint32_t xs_qm_dqcachehits ; __uint32_t xs_qm_dqwants ; __uint32_t xs_qm_dqshake_reclaims ; __uint32_t xs_qm_dqinact_reclaims ; } ;

struct xfs_qm ;

typedef xfs_dqhash_t xfs_dqlist_t ;


typedef struct xfs_frlist { struct xfs_dquot * qh_next ; struct xfs_dquot * qh_prev ; struct mutex qh_lock ; uint qh_version ; uint qh_nelems ; } xfs_frlist_t ;

typedef struct xfs_qm { xfs_dqlist_t * qm_usr_dqhtable ; xfs_dqlist_t * qm_grp_dqhtable ; uint qm_dqhashmask ; xfs_frlist_t qm_dqfreelist ; atomic_t qm_totaldquots ; uint qm_nrefs ; int qm_dqfree_ratio ; struct kmem_cache * qm_dqzone ; struct kmem_cache * qm_dqtrxzone ; } xfs_qm_t ;

typedef struct xfs_quotainfo { xfs_inode_t * qi_uquotaip ; xfs_inode_t * qi_gquotaip ; xfs_dqlist_t qi_dqlist ; int qi_dqreclaims ; time_t qi_btimelimit ; time_t qi_itimelimit ; time_t qi_rtbtimelimit ; xfs_qwarncnt_t qi_bwarnlimit ; xfs_qwarncnt_t qi_iwarnlimit ; xfs_qwarncnt_t qi_rtbwarnlimit ; struct mutex qi_quotaofflock ; xfs_filblks_t qi_dqchunklen ; uint qi_dqperchunk ; xfs_qcnt_t qi_bhardlimit ; xfs_qcnt_t qi_bsoftlimit ; xfs_qcnt_t qi_ihardlimit ; xfs_qcnt_t qi_isoftlimit ; xfs_qcnt_t qi_rtbhardlimit ; xfs_qcnt_t qi_rtbsoftlimit ; } xfs_quotainfo_t ;

typedef struct xfs_dquot_acct { xfs_dqtrx_t dqa_usrdquots [ 2 ] ; xfs_dqtrx_t dqa_grpdquots [ 2 ] ; } xfs_dquot_acct_t ;

void xfs_qm_dqdestroy ( xfs_dquot_t * dqp ) ;

void xfs_qm_adjust_dqlimits ( xfs_mount_t * mp , xfs_disk_dquot_t * d ) ;

void xfs_qm_adjust_dqtimers ( xfs_mount_t * mp , xfs_disk_dquot_t * d ) ;

int xfs_qm_dqget ( xfs_mount_t * mp , xfs_inode_t * ip , xfs_dqid_t id , uint type , uint flags , xfs_dquot_t * * O_dqpp ) ;

void xfs_qm_dqput ( xfs_dquot_t * dqp ) ;

void xfs_qm_dqrele ( xfs_dquot_t * dqp ) ;

int xfs_qm_dqflush ( xfs_dquot_t * dqp , uint flags ) ;

int xfs_qm_dqlock_nowait ( xfs_dquot_t * dqp ) ;

void xfs_dqlock ( xfs_dquot_t * dqp ) ;

void xfs_dqunlock ( xfs_dquot_t * dqp ) ;

void xfs_dqunlock_nonotify ( xfs_dquot_t * dqp ) ;

void xfs_dqlock2 ( xfs_dquot_t * d1 , xfs_dquot_t * d2 ) ;

int xfs_qm_dqpurge ( xfs_dquot_t * dqp ) ;

void xfs_qm_dqflock_pushbuf_wait ( xfs_dquot_t * dqp ) ;

void xfs_qm_dqunpin_wait ( xfs_dquot_t * dqp ) ;

void xfs_qm_dquot_logitem_init ( struct xfs_dquot * dqp ) ;

xfs_qoff_logitem_t * xfs_qm_qoff_logitem_init ( struct xfs_mount * mp , xfs_qoff_logitem_t * start , uint flags ) ;

void xfs_trans_dqjoin ( xfs_trans_t * tp , xfs_dquot_t * dqp ) ;

void xfs_trans_log_dquot ( xfs_trans_t * tp , xfs_dquot_t * dqp ) ;

void xfs_trans_dup_dqinfo ( xfs_trans_t * otp , xfs_trans_t * ntp ) ;

void xfs_trans_mod_dquot_byino ( xfs_trans_t * tp , xfs_inode_t * ip , uint field , long delta ) ;

void xfs_trans_mod_dquot ( xfs_trans_t * tp , xfs_dquot_t * dqp , uint field , long delta ) ;

void xfs_trans_apply_dquot_deltas ( xfs_trans_t * tp ) ;

void xfs_trans_unreserve_and_mod_dquots ( xfs_trans_t * tp ) ;

int xfs_trans_reserve_quota_bydquots ( xfs_trans_t * tp , xfs_mount_t * mp , xfs_dquot_t * udqp , xfs_dquot_t * gdqp , long nblks , long ninos , uint flags ) ;

int xfs_trans_reserve_quota_nblks ( struct xfs_trans * tp , struct xfs_inode * ip , long nblks , long ninos , uint flags ) ;

xfs_qoff_logitem_t * xfs_trans_get_qoff_item ( xfs_trans_t * tp , xfs_qoff_logitem_t * startqoff , uint flags ) ;

void xfs_trans_log_quotaoff_item ( xfs_trans_t * tp , xfs_qoff_logitem_t * qlp ) ;

void xfs_trans_free_dqinfo ( xfs_trans_t * tp ) ;

int xfs_qm_scall_quotaoff ( xfs_mount_t * mp , uint flags ) ;

int xfs_qm_scall_trunc_qfiles ( xfs_mount_t * mp , uint flags ) ;

int xfs_qm_scall_quotaon ( xfs_mount_t * mp , uint flags ) ;

int xfs_qm_scall_getqstat ( xfs_mount_t * mp , fs_quota_stat_t * out ) ;

int xfs_qm_scall_setqlim ( xfs_mount_t * mp , xfs_dqid_t id , uint type , fs_disk_quota_t * newlim ) ;

int xfs_qm_scall_getquota ( xfs_mount_t * mp , xfs_dqid_t id , uint type , fs_disk_quota_t * out ) ;

void xfs_qm_dqrele_all_inodes ( struct xfs_mount * mp , uint flags ) ;

void xfs_qm_statvfs ( xfs_inode_t * ip , struct kstatfs * statp ) ;

int xfs_qm_newmount ( xfs_mount_t * mp , uint * needquotamount , uint * quotaflags ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xfs_qm_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) xfs_qm_exit ( void ) ;

void xfs_qm_unmount ( struct xfs_mount * mp ) ;

void xfs_qm_mount_quotas ( xfs_mount_t * mp ) ;

void xfs_qm_unmount_quotas ( xfs_mount_t * mp ) ;

int xfs_qm_dqpurge_all ( xfs_mount_t * mp , uint flags ) ;

int xfs_qm_dqattach_locked ( xfs_inode_t * ip , uint flags ) ;

int xfs_qm_dqattach ( struct xfs_inode * ip , uint flags ) ;

void xfs_qm_dqdetach ( xfs_inode_t * ip ) ;

int xfs_qm_sync ( xfs_mount_t * mp , int flags ) ;

void xfs_qm_destroy_quotainfo ( xfs_mount_t * mp ) ;

int xfs_qm_quotacheck ( xfs_mount_t * mp ) ;

boolean_t xfs_qm_dqalloc_incore ( xfs_dquot_t * * O_dqpp ) ;

int xfs_qm_write_sb_changes ( xfs_mount_t * mp , __int64_t flags ) ;

int xfs_qm_vop_dqalloc ( struct xfs_inode * ip , uid_t uid , gid_t gid , prid_t prid , uint flags , struct xfs_dquot * * O_udqpp , struct xfs_dquot * * O_gdqpp ) ;

xfs_dquot_t * xfs_qm_vop_chown ( xfs_trans_t * tp , xfs_inode_t * ip , xfs_dquot_t * * IO_olddq , xfs_dquot_t * newdq ) ;

int xfs_qm_vop_chown_reserve ( xfs_trans_t * tp , xfs_inode_t * ip , xfs_dquot_t * udqp , xfs_dquot_t * gdqp , uint flags ) ;

int xfs_qm_vop_rename_dqattach ( struct xfs_inode * * i_tab ) ;

void xfs_qm_vop_create_dqattach ( struct xfs_trans * tp , struct xfs_inode * ip , struct xfs_dquot * udqp , struct xfs_dquot * gdqp ) ;

void xfs_qm_freelist_unlink ( xfs_dquot_t * dq ) ;

void xfs_qm_freelist_append ( xfs_frlist_t * ql , xfs_dquot_t * dq ) ;

void xfs_qm_init_procfs ( void ) ;

void xfs_qm_cleanup_procfs ( void ) ;


typedef struct xfs_inode_log_format { __uint16_t ilf_type ; __uint16_t ilf_size ; __uint32_t ilf_fields ; __uint16_t ilf_asize ; __uint16_t ilf_dsize ; __uint64_t ilf_ino ; union { __uint32_t ilfu_rdev ; uuid_t ilfu_uuid ; } ilf_u ; __int64_t ilf_blkno ; __int32_t ilf_len ; __int32_t ilf_boffset ; } xfs_inode_log_format_t ;


typedef struct xfs_inode_log_format_32 { __uint16_t ilf_type ; __uint16_t ilf_size ; __uint32_t ilf_fields ; __uint16_t ilf_asize ; __uint16_t ilf_dsize ; __uint64_t ilf_ino ; union { __uint32_t ilfu_rdev ; uuid_t ilfu_uuid ; } ilf_u ; __int64_t ilf_blkno ; __int32_t ilf_len ; __int32_t ilf_boffset ; } __attribute__ ( ( packed ) ) xfs_inode_log_format_32_t ;


typedef struct xfs_inode_log_format_64 { __uint16_t ilf_type ; __uint16_t ilf_size ; __uint32_t ilf_fields ; __uint16_t ilf_asize ; __uint16_t ilf_dsize ; __uint32_t ilf_pad ; __uint64_t ilf_ino ; union { __uint32_t ilfu_rdev ; uuid_t ilfu_uuid ; } ilf_u ; __int64_t ilf_blkno ; __int32_t ilf_len ; __int32_t ilf_boffset ; } xfs_inode_log_format_64_t ;

struct xfs_bmbt_rec_64 ;
typedef struct xfs_inode_log_item { xfs_log_item_t ili_item ; struct xfs_inode * ili_inode ; xfs_lsn_t ili_flush_lsn ; xfs_lsn_t ili_last_lsn ; unsigned short ili_flags ; unsigned short ili_logged ; unsigned int ili_last_fields ; struct xfs_bmbt_rec_64 * ili_extents_buf ; struct xfs_bmbt_rec_64 * ili_aextents_buf ; unsigned int ili_pushbuf_flag ; xfs_inode_log_format_t ili_format ; } xfs_inode_log_item_t ;

int xfs_growfs_rt ( xfs_mount_t * mp , xfs_growfs_rt_t * in ) ;
int xfs_rtallocate_extent ( xfs_trans_t * tp , xfs_rtblock_t bno , xfs_extlen_t minlen , xfs_extlen_t maxlen , xfs_extlen_t * len , xfs_alloctype_t type , int wasdel , xfs_extlen_t prod , xfs_rtblock_t * rtblock ) ;

int xfs_rtfree_extent ( xfs_trans_t * tp , xfs_rtblock_t bno , xfs_extlen_t len ) ;

int xfs_rtmount_init ( xfs_mount_t * mp ) ;

int xfs_rtmount_inodes ( xfs_mount_t * mp ) ;

void xfs_rtunmount_inodes ( struct xfs_mount * mp ) ;

int xfs_rtpick_extent ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_extlen_t len , xfs_rtblock_t * pick ) ;

struct xfs_acl { __be32 acl_cnt ; struct xfs_acl_entry { __be32 ae_tag ; __be32 ae_id ; __be16 ae_perm ; } acl_entry [ 25 ] ; } ;

struct posix_acl * xfs_get_acl ( struct inode * inode , int type ) ;

int xfs_check_acl ( struct inode * inode , int mask ) ;

int posix_acl_access_exists ( struct inode * inode ) ;

int posix_acl_default_exists ( struct inode * inode ) ;

int xfs_inherit_acl ( struct inode * inode , struct posix_acl * default_acl ) ;

int xfs_acl_chmod ( struct inode * inode ) ;

int xfs_init_procfs ( void ) ;

void xfs_cleanup_procfs ( void ) ;

int xfs_sysctl_register ( void ) ;

void xfs_sysctl_unregister ( void ) ;

typedef struct xfs_swapext { __int64_t sx_version ; __int64_t sx_fdtarget ; __int64_t sx_fdtmp ; xfs_off_t sx_offset ; xfs_off_t sx_length ; char sx_pad [ 16 ] ; xfs_bstat_t sx_stat ; } xfs_swapext_t ;


typedef struct compat_xfs_bstime { compat_time_t tv_sec ; __s32 tv_nsec ; } compat_xfs_bstime_t ;


typedef struct compat_xfs_bstat { __u64 bs_ino ; __u16 bs_mode ; __u16 bs_nlink ; __u32 bs_uid ; __u32 bs_gid ; __u32 bs_rdev ; __s32 bs_blksize ; __s64 bs_size ; compat_xfs_bstime_t bs_atime ; compat_xfs_bstime_t bs_mtime ; compat_xfs_bstime_t bs_ctime ; int64_t bs_blocks ; __u32 bs_xflags ; __s32 bs_extsize ; __s32 bs_extents ; __u32 bs_gen ; __u16 bs_projid ; unsigned char bs_pad [ 14 ] ; __u32 bs_dmevmask ; __u16 bs_dmstate ; __u16 bs_aextents ; } __attribute__ ( ( packed ) ) compat_xfs_bstat_t ;


typedef struct compat_xfs_fsop_bulkreq { compat_uptr_t lastip ; __s32 icount ; compat_uptr_t ubuffer ; compat_uptr_t ocount ; } compat_xfs_fsop_bulkreq_t ;


typedef struct compat_xfs_fsop_handlereq { __u32 fd ; compat_uptr_t path ; __u32 oflags ; compat_uptr_t ihandle ; __u32 ihandlen ; compat_uptr_t ohandle ; compat_uptr_t ohandlen ; } compat_xfs_fsop_handlereq_t ;


typedef struct compat_xfs_swapext { __int64_t sx_version ; __int64_t sx_fdtarget ; __int64_t sx_fdtmp ; xfs_off_t sx_offset ; xfs_off_t sx_length ; char sx_pad [ 16 ] ; compat_xfs_bstat_t sx_stat ; } __attribute__ ( ( packed ) ) compat_xfs_swapext_t ;


typedef struct compat_xfs_fsop_attrlist_handlereq { struct compat_xfs_fsop_handlereq hreq ; struct xfs_attrlist_cursor pos ; __u32 flags ; __u32 buflen ; compat_uptr_t buffer ; } __attribute__ ( ( packed ) ) compat_xfs_fsop_attrlist_handlereq_t ;


typedef struct compat_xfs_attr_multiop { __u32 am_opcode ; __s32 am_error ; compat_uptr_t am_attrname ; compat_uptr_t am_attrvalue ; __u32 am_length ; __u32 am_flags ; } compat_xfs_attr_multiop_t ;


typedef struct compat_xfs_fsop_attrmulti_handlereq { struct compat_xfs_fsop_handlereq hreq ; __u32 opcount ; compat_uptr_t ops ; } compat_xfs_fsop_attrmulti_handlereq_t ;


typedef struct compat_xfs_fsop_setdm_handlereq { struct compat_xfs_fsop_handlereq hreq ; compat_uptr_t data ; } compat_xfs_fsop_setdm_handlereq_t ;


typedef struct compat_xfs_flock64 { __s16 l_type ; __s16 l_whence ; __s64 l_start __attribute__ ( ( packed ) ) ; __s64 l_len __attribute__ ( ( packed ) ) ; __s32 l_sysid ; __u32 l_pid ; __s32 l_pad [ 4 ] ; } compat_xfs_flock64_t ;


typedef struct compat_xfs_fsop_geom_v1 { __u32 blocksize ; __u32 rtextsize ; __u32 agblocks ; __u32 agcount ; __u32 logblocks ; __u32 sectsize ; __u32 inodesize ; __u32 imaxpct ; __u64 datablocks ; __u64 rtblocks ; __u64 rtextents ; __u64 logstart ; unsigned char uuid [ 16 ] ; __u32 sunit ; __u32 swidth ; __s32 version ; __u32 flags ; __u32 logsectsize ; __u32 rtsectsize ; __u32 dirblocksize ; } __attribute__ ( ( packed ) ) compat_xfs_fsop_geom_v1_t ;


typedef struct compat_xfs_inogrp { __u64 xi_startino ; __s32 xi_alloccount ; __u64 xi_allocmask ; } __attribute__ ( ( packed ) ) compat_xfs_inogrp_t ;


typedef struct compat_xfs_growfs_data { __u64 newblocks ; __u32 imaxpct ; } __attribute__ ( ( packed ) ) compat_xfs_growfs_data_t ;


typedef struct compat_xfs_growfs_rt { __u64 newblocks ; __u32 extsize ; } __attribute__ ( ( packed ) ) compat_xfs_growfs_rt_t ;

long xfs_file_compat_ioctl ( struct file * filp , unsigned cmd , unsigned long p ) ;

void xfs_alloc_compute_maxlevels ( xfs_mount_t * mp ) ;

xfs_extlen_t xfs_alloc_longest_free_extent ( struct xfs_mount * mp , struct xfs_perag * pag ) ;

int xfs_alloc_get_freelist ( xfs_trans_t * tp , xfs_buf_t * agbp , xfs_agblock_t * bnop , int btreeblk ) ;

void xfs_alloc_log_agf ( xfs_trans_t * tp , xfs_buf_t * bp , int fields ) ;

int xfs_alloc_pagf_init ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_agnumber_t agno , int flags ) ;

int xfs_alloc_put_freelist ( xfs_trans_t * tp , xfs_buf_t * agbp , xfs_buf_t * agflbp , xfs_agblock_t bno , int btreeblk ) ;

int xfs_read_agf ( struct xfs_mount * mp , struct xfs_trans * tp , xfs_agnumber_t agno , int flags , struct xfs_buf * * bpp ) ;

int xfs_alloc_read_agf ( struct xfs_mount * mp , struct xfs_trans * tp , xfs_agnumber_t agno , int flags , struct xfs_buf * * bpp ) ;

int xfs_alloc_vextent ( xfs_alloc_arg_t * args ) ;

int xfs_free_extent ( xfs_trans_t * tp , xfs_fsblock_t bno , xfs_extlen_t len ) ;

void xfs_alloc_mark_busy ( xfs_trans_t * tp , xfs_agnumber_t agno , xfs_agblock_t bno , xfs_extlen_t len ) ;

void xfs_alloc_clear_busy ( xfs_trans_t * tp , xfs_agnumber_t agno , int idx ) ;

struct xfs_btree_cur * xfs_allocbt_init_cursor ( struct xfs_mount * mp , struct xfs_trans * tp , struct xfs_buf * agbp , xfs_agnumber_t agno , xfs_btnum_t btnum ) ;

int xfs_allocbt_maxrecs ( struct xfs_mount * mp , int blocklen , int leaf ) ;


typedef struct xfs_da_blkinfo { __be32 forw ; __be32 back ; __be16 magic ; __be16 pad ; } xfs_da_blkinfo_t ;


typedef struct xfs_da_intnode { struct xfs_da_node_hdr { xfs_da_blkinfo_t info ; __be16 count ; __be16 level ; } hdr ; struct xfs_da_node_entry { __be32 hashval ; __be32 before ; } btree [ 1 ] ; } xfs_da_intnode_t ;

typedef struct xfs_da_node_hdr xfs_da_node_hdr_t ;

typedef struct xfs_da_node_entry xfs_da_node_entry_t ;

enum xfs_dacmp { XFS_CMP_DIFFERENT , XFS_CMP_EXACT , XFS_CMP_CASE } ;

typedef struct xfs_da_args { const __uint8_t * name ; int namelen ; __uint8_t * value ; int valuelen ; int flags ; xfs_dahash_t hashval ; xfs_ino_t inumber ; struct xfs_inode * dp ; xfs_fsblock_t * firstblock ; struct xfs_bmap_free * flist ; struct xfs_trans * trans ; xfs_extlen_t total ; int whichfork ; xfs_dablk_t blkno ; int index ; xfs_dablk_t rmtblkno ; int rmtblkcnt ; xfs_dablk_t blkno2 ; int index2 ; xfs_dablk_t rmtblkno2 ; int rmtblkcnt2 ; int op_flags ; enum xfs_dacmp cmpresult ; } xfs_da_args_t ;

typedef struct xfs_dabuf { int nbuf ; short dirty ; short bbcount ; void * data ; struct xfs_buf * bps [ 1 ] ; } xfs_dabuf_t ;


typedef struct xfs_da_state_blk { xfs_dabuf_t * bp ; xfs_dablk_t blkno ; xfs_daddr_t disk_blkno ; int index ; xfs_dahash_t hashval ; int magic ; } xfs_da_state_blk_t ;


typedef struct xfs_da_state_path { int active ; xfs_da_state_blk_t blk [ 5 ] ; } xfs_da_state_path_t ;


typedef struct xfs_da_state { xfs_da_args_t * args ; struct xfs_mount * mp ; unsigned int blocksize ; unsigned int node_ents ; xfs_da_state_path_t path ; xfs_da_state_path_t altpath ; unsigned char inleaf ; unsigned char extravalid ; unsigned char extraafter ; xfs_da_state_blk_t extrablk ; } xfs_da_state_t ;

struct xfs_nameops { xfs_dahash_t ( * hashname ) ( struct xfs_name * ) ; enum xfs_dacmp ( * compname ) ( struct xfs_da_args * , const char * , int ) ; } ;
struct attrlist ;
struct xfs_da_state ;
struct xfs_da_state_blk ;

typedef struct xfs_attr_leaf_map { __be16 base ; __be16 size ; } xfs_attr_leaf_map_t ;


typedef struct xfs_attr_leaf_hdr { xfs_da_blkinfo_t info ; __be16 count ; __be16 usedbytes ; __be16 firstused ; __u8 holes ; __u8 pad1 ; xfs_attr_leaf_map_t freemap [ 3 ] ; } xfs_attr_leaf_hdr_t ;


typedef struct xfs_attr_leaf_entry { __be32 hashval ; __be16 nameidx ; __u8 flags ; __u8 pad2 ; } xfs_attr_leaf_entry_t ;


typedef struct xfs_attr_leaf_name_local { __be16 valuelen ; __u8 namelen ; __u8 nameval [ 1 ] ; } xfs_attr_leaf_name_local_t ;


typedef struct xfs_attr_leaf_name_remote { __be32 valueblk ; __be32 valuelen ; __u8 namelen ; __u8 name [ 1 ] ; } xfs_attr_leaf_name_remote_t ;


typedef struct xfs_attr_leafblock { xfs_attr_leaf_hdr_t hdr ; xfs_attr_leaf_entry_t entries [ 1 ] ; xfs_attr_leaf_name_local_t namelist ; xfs_attr_leaf_name_remote_t valuelist ; } xfs_attr_leafblock_t ;


typedef struct xfs_attr_inactive_list { xfs_dablk_t valueblk ; int valuelen ; } xfs_attr_inactive_list_t ;

int xfs_attr_fetch ( xfs_inode_t * ip , struct xfs_name * name , char * value , int * valuelenp , int flags ) ;

int xfs_attr_get ( xfs_inode_t * ip , const char * name , char * value , int * valuelenp , int flags ) ;

int xfs_attr_calc_size ( struct xfs_inode * ip , int namelen , int valuelen , int * local ) ;

int xfs_attr_set ( xfs_inode_t * dp , const char * name , char * value , int valuelen , int flags ) ;

int xfs_attr_remove ( xfs_inode_t * dp , const char * name , int flags ) ;

int xfs_attr_list_int ( xfs_attr_list_context_t * context ) ;

int xfs_attr_list ( xfs_inode_t * dp , char * buffer , int bufsize , int flags , attrlist_cursor_kern_t * cursor ) ;

int xfs_attr_inactive ( xfs_inode_t * dp ) ;

int xfs_attr_rmtval_get ( xfs_da_args_t * args ) ;

int xfs_attr_shortform_bytesfit ( xfs_inode_t * dp , int bytes ) ;

void xfs_attr_shortform_create ( xfs_da_args_t * args ) ;

void xfs_attr_shortform_add ( xfs_da_args_t * args , int forkoff ) ;

int xfs_attr_shortform_remove ( xfs_da_args_t * args ) ;

int xfs_attr_shortform_lookup ( xfs_da_args_t * args ) ;

int xfs_attr_shortform_getvalue ( xfs_da_args_t * args ) ;

int xfs_attr_shortform_to_leaf ( xfs_da_args_t * args ) ;

int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) ;

int xfs_attr_shortform_allfit ( xfs_dabuf_t * bp , xfs_inode_t * dp ) ;

int xfs_attr_leaf_to_shortform ( xfs_dabuf_t * bp , xfs_da_args_t * args , int forkoff ) ;

int xfs_attr_leaf_to_node ( xfs_da_args_t * args ) ;

int xfs_attr_leaf_split ( xfs_da_state_t * state , xfs_da_state_blk_t * oldblk , xfs_da_state_blk_t * newblk ) ;

int xfs_attr_leaf_add ( xfs_dabuf_t * bp , xfs_da_args_t * args ) ;

int xfs_attr_leaf_toosmall ( xfs_da_state_t * state , int * action ) ;

int xfs_attr_leaf_remove ( xfs_dabuf_t * bp , xfs_da_args_t * args ) ;

void xfs_attr_leaf_unbalance ( xfs_da_state_t * state , xfs_da_state_blk_t * drop_blk , xfs_da_state_blk_t * save_blk ) ;

int xfs_attr_leaf_lookup_int ( xfs_dabuf_t * bp , xfs_da_args_t * args ) ;

int xfs_attr_leaf_getvalue ( xfs_dabuf_t * bp , xfs_da_args_t * args ) ;

int xfs_attr_leaf_order ( xfs_dabuf_t * leaf1_bp , xfs_dabuf_t * leaf2_bp ) ;

xfs_dahash_t xfs_attr_leaf_lasthash ( xfs_dabuf_t * bp , int * count ) ;

int xfs_attr_leaf_newentsize ( int namelen , int valuelen , int blocksize , int * local ) ;

int xfs_attr_leaf_list_int ( xfs_dabuf_t * bp , xfs_attr_list_context_t * context ) ;

int xfs_attr_leaf_clearflag ( xfs_da_args_t * args ) ;

int xfs_attr_leaf_setflag ( xfs_da_args_t * args ) ;

int xfs_attr_leaf_flipflags ( xfs_da_args_t * args ) ;

int xfs_attr_root_inactive ( xfs_trans_t * * trans , xfs_inode_t * dp ) ;

int xfs_bitmap_empty ( uint * map , uint size ) ;

int xfs_contig_bits ( uint * map , uint size , uint start_bit ) ;

int xfs_next_bit ( uint * map , uint size , uint start_bit ) ;


typedef struct xfs_dir2_data_free { __be16 offset ; __be16 length ; } xfs_dir2_data_free_t ;


typedef struct xfs_dir2_data_hdr { __be32 magic ; xfs_dir2_data_free_t bestfree [ 3 ] ; } xfs_dir2_data_hdr_t ;


typedef struct xfs_dir2_data_entry { __be64 inumber ; __u8 namelen ; __u8 name [ 1 ] ; __be16 tag ; } xfs_dir2_data_entry_t ;


typedef struct xfs_dir2_data_unused { __be16 freetag ; __be16 length ; __be16 tag ; } xfs_dir2_data_unused_t ;

typedef union { xfs_dir2_data_entry_t entry ; xfs_dir2_data_unused_t unused ; } xfs_dir2_data_union_t ;


typedef struct xfs_dir2_data { xfs_dir2_data_hdr_t hdr ; xfs_dir2_data_union_t u [ 1 ] ; } xfs_dir2_data_t ;

typedef __uint32_t xfs_dir2_dataptr_t ;


typedef struct xfs_dir2_leaf_hdr { xfs_da_blkinfo_t info ; __be16 count ; __be16 stale ; } xfs_dir2_leaf_hdr_t ;


typedef struct xfs_dir2_leaf_entry { __be32 hashval ; __be32 address ; } xfs_dir2_leaf_entry_t ;


typedef struct xfs_dir2_leaf_tail { __be32 bestcount ; } xfs_dir2_leaf_tail_t ;


typedef struct xfs_dir2_leaf { xfs_dir2_leaf_hdr_t hdr ; xfs_dir2_leaf_entry_t ents [ 1 ] ; xfs_dir2_data_off_t bests [ 1 ] ; xfs_dir2_leaf_tail_t tail ; } xfs_dir2_leaf_t ;

struct xfs_dir2_data_hdr ;
struct xfs_dir2_leaf_entry ;

typedef struct xfs_dir2_block_tail { __be32 count ; __be32 stale ; } xfs_dir2_block_tail_t ;

typedef struct xfs_dir2_block { xfs_dir2_data_hdr_t hdr ; xfs_dir2_data_union_t u [ 1 ] ; xfs_dir2_leaf_entry_t leaf [ 1 ] ; xfs_dir2_block_tail_t tail ; } xfs_dir2_block_t ;


typedef struct xfs_extent { xfs_dfsbno_t ext_start ; xfs_extlen_t ext_len ; } xfs_extent_t ;


typedef struct xfs_extent_32 { __uint64_t ext_start ; __uint32_t ext_len ; } __attribute__ ( ( packed ) ) xfs_extent_32_t ;


typedef struct xfs_extent_64 { __uint64_t ext_start ; __uint32_t ext_len ; __uint32_t ext_pad ; } xfs_extent_64_t ;


typedef struct xfs_efi_log_format { __uint16_t efi_type ; __uint16_t efi_size ; __uint32_t efi_nextents ; __uint64_t efi_id ; xfs_extent_t efi_extents [ 1 ] ; } xfs_efi_log_format_t ;


typedef struct xfs_efi_log_format_32 { __uint16_t efi_type ; __uint16_t efi_size ; __uint32_t efi_nextents ; __uint64_t efi_id ; xfs_extent_32_t efi_extents [ 1 ] ; } __attribute__ ( ( packed ) ) xfs_efi_log_format_32_t ;


typedef struct xfs_efi_log_format_64 { __uint16_t efi_type ; __uint16_t efi_size ; __uint32_t efi_nextents ; __uint64_t efi_id ; xfs_extent_64_t efi_extents [ 1 ] ; } xfs_efi_log_format_64_t ;


typedef struct xfs_efd_log_format { __uint16_t efd_type ; __uint16_t efd_size ; __uint32_t efd_nextents ; __uint64_t efd_efi_id ; xfs_extent_t efd_extents [ 1 ] ; } xfs_efd_log_format_t ;


typedef struct xfs_efd_log_format_32 { __uint16_t efd_type ; __uint16_t efd_size ; __uint32_t efd_nextents ; __uint64_t efd_efi_id ; xfs_extent_32_t efd_extents [ 1 ] ; } __attribute__ ( ( packed ) ) xfs_efd_log_format_32_t ;


typedef struct xfs_efd_log_format_64 { __uint16_t efd_type ; __uint16_t efd_size ; __uint32_t efd_nextents ; __uint64_t efd_efi_id ; xfs_extent_64_t efd_extents [ 1 ] ; } xfs_efd_log_format_64_t ;

typedef struct xfs_efi_log_item { xfs_log_item_t efi_item ; uint efi_flags ; uint efi_next_extent ; xfs_efi_log_format_t efi_format ; } xfs_efi_log_item_t ;

typedef struct xfs_efd_log_item { xfs_log_item_t efd_item ; xfs_efi_log_item_t * efd_efip ; uint efd_next_extent ; xfs_efd_log_format_t efd_format ; } xfs_efd_log_item_t ;

struct xfs_bmalloca ;

typedef enum xfs_fstrm_alloc { XFS_PICK_USERDATA = 1 , XFS_PICK_LOWSPACE = 2 , } xfs_fstrm_alloc_t ;

uint xfs_default_attroffset ( struct xfs_inode * ip ) ;

int xfs_bmap_add_attrfork ( xfs_inode_t * ip , int size , int rsvd ) ;

void xfs_bmap_add_free ( xfs_fsblock_t bno , xfs_filblks_t len , xfs_bmap_free_t * flist , xfs_mount_t * mp ) ;

void xfs_bmap_compute_maxlevels ( xfs_mount_t * mp , int whichfork ) ;

int xfs_bmap_finish ( xfs_trans_t * * tp , xfs_bmap_free_t * flist , int * committed ) ;

void xfs_bmap_cancel ( xfs_bmap_free_t * flist ) ;

int xfs_bmap_first_unused ( xfs_trans_t * tp , xfs_inode_t * ip , xfs_extlen_t len , xfs_fileoff_t * first_unused , int whichfork ) ;

int xfs_bmap_last_before ( xfs_trans_t * tp , xfs_inode_t * ip , xfs_fileoff_t * last_block , int whichfork ) ;

int xfs_bmap_last_offset ( xfs_trans_t * tp , xfs_inode_t * ip , xfs_fileoff_t * last_block , int whichfork ) ;

int xfs_bmap_one_block ( xfs_inode_t * ip , int whichfork ) ;

int xfs_bmap_read_extents ( xfs_trans_t * tp , xfs_inode_t * ip , int whichfork ) ;

int xfs_bmapi ( xfs_trans_t * tp , xfs_inode_t * ip , xfs_fileoff_t bno , xfs_filblks_t len , int flags , xfs_fsblock_t * firstblock , xfs_extlen_t total , xfs_bmbt_irec_t * mval , int * nmap , xfs_bmap_free_t * flist , xfs_extdelta_t * delta ) ;

int xfs_bmapi_single ( xfs_trans_t * tp , xfs_inode_t * ip , int whichfork , xfs_fsblock_t * fsb , xfs_fileoff_t bno ) ;

int xfs_bunmapi ( xfs_trans_t * tp , struct xfs_inode * ip , xfs_fileoff_t bno , xfs_filblks_t len , int flags , xfs_extnum_t nexts , xfs_fsblock_t * firstblock , xfs_bmap_free_t * flist , xfs_extdelta_t * delta , int * done ) ;

int xfs_getbmap ( xfs_inode_t * ip , struct getbmapx * bmv , xfs_bmap_format_t formatter , void * arg ) ;

int xfs_bmap_eof ( xfs_inode_t * ip , xfs_fileoff_t endoff , int whichfork , int * eof ) ;

int xfs_bmap_count_blocks ( xfs_trans_t * tp , xfs_inode_t * ip , int whichfork , int * count ) ;

void xfs_bmdr_to_bmbt ( struct xfs_mount * mp , xfs_bmdr_block_t * dblock , int dblocklen , struct xfs_btree_block * rblock , int rblocklen ) ;

void xfs_bmbt_get_all ( xfs_bmbt_rec_host_t * r , xfs_bmbt_irec_t * s ) ;

xfs_filblks_t xfs_bmbt_get_blockcount ( xfs_bmbt_rec_host_t * r ) ;

xfs_fsblock_t xfs_bmbt_get_startblock ( xfs_bmbt_rec_host_t * r ) ;

xfs_fileoff_t xfs_bmbt_get_startoff ( xfs_bmbt_rec_host_t * r ) ;

xfs_exntst_t xfs_bmbt_get_state ( xfs_bmbt_rec_host_t * r ) ;

xfs_filblks_t xfs_bmbt_disk_get_blockcount ( xfs_bmbt_rec_t * r ) ;

xfs_fileoff_t xfs_bmbt_disk_get_startoff ( xfs_bmbt_rec_t * r ) ;

void xfs_bmbt_set_allf ( xfs_bmbt_rec_host_t * r , xfs_fileoff_t startoff , xfs_fsblock_t startblock , xfs_filblks_t blockcount , xfs_exntst_t state ) ;

void xfs_bmbt_set_all ( xfs_bmbt_rec_host_t * r , xfs_bmbt_irec_t * s ) ;

void xfs_bmbt_disk_set_allf ( xfs_bmbt_rec_t * r , xfs_fileoff_t startoff , xfs_fsblock_t startblock , xfs_filblks_t blockcount , xfs_exntst_t state ) ;

void xfs_bmbt_disk_set_all ( xfs_bmbt_rec_t * r , xfs_bmbt_irec_t * s ) ;

void xfs_bmbt_set_blockcount ( xfs_bmbt_rec_host_t * r , xfs_filblks_t v ) ;

void xfs_bmbt_set_startblock ( xfs_bmbt_rec_host_t * r , xfs_fsblock_t v ) ;

void xfs_bmbt_set_startoff ( xfs_bmbt_rec_host_t * r , xfs_fileoff_t v ) ;

void xfs_bmbt_set_state ( xfs_bmbt_rec_host_t * r , xfs_exntst_t v ) ;

void xfs_bmbt_to_bmdr ( struct xfs_mount * mp , struct xfs_btree_block * rblock , int rblocklen , xfs_bmdr_block_t * dblock , int dblocklen ) ;

int xfs_check_nostate_extents ( xfs_ifork_t * ifp , xfs_extnum_t idx , xfs_extnum_t num ) ;

int xfs_bmbt_get_maxrecs ( struct xfs_btree_cur * cur , int level ) ;

struct xfs_btree_cur * xfs_bmbt_init_cursor ( struct xfs_mount * mp , struct xfs_trans * tp , struct xfs_inode * ip , int whichfork ) ;

int xfs_bmbt_maxrecs ( struct xfs_mount * mp , int blocklen , int leaf ) ;

int xfs_bmdr_maxrecs ( struct xfs_mount * mp , int blocklen , int leaf ) ;

int xfs_btree_check_block ( struct xfs_btree_cur * cur , struct xfs_btree_block * block , int level , struct xfs_buf * bp ) ;

int xfs_btree_check_lptr ( struct xfs_btree_cur * cur , xfs_dfsbno_t bno , int level ) ;

void xfs_btree_del_cursor ( xfs_btree_cur_t * cur , int error ) ;

int xfs_btree_dup_cursor ( xfs_btree_cur_t * cur , xfs_btree_cur_t * * ncur ) ;

xfs_buf_t * xfs_btree_get_bufl ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_fsblock_t fsbno , uint lock ) ;

xfs_buf_t * xfs_btree_get_bufs ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_agnumber_t agno , xfs_agblock_t agbno , uint lock ) ;

int xfs_btree_islastblock ( xfs_btree_cur_t * cur , int level ) ;

void xfs_btree_offsets ( __int64_t fields , const short * offsets , int nbits , int * first , int * last ) ;

int xfs_btree_read_bufl ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_fsblock_t fsbno , uint lock , xfs_buf_t * * bpp , int refval ) ;

void xfs_btree_reada_bufl ( xfs_mount_t * mp , xfs_fsblock_t fsbno , xfs_extlen_t count ) ;

void xfs_btree_reada_bufs ( xfs_mount_t * mp , xfs_agnumber_t agno , xfs_agblock_t agbno , xfs_extlen_t count ) ;

void xfs_btree_setbuf ( xfs_btree_cur_t * cur , int lev , xfs_buf_t * bp ) ;

void xfs_btree_log_recs ( struct xfs_btree_cur * cur , struct xfs_buf * bp , int first , int last ) ;

void xfs_btree_log_block ( struct xfs_btree_cur * cur , struct xfs_buf * bp , int fields ) ;

int xfs_btree_increment ( struct xfs_btree_cur * cur , int level , int * stat ) ;

int xfs_btree_decrement ( struct xfs_btree_cur * cur , int level , int * stat ) ;

int xfs_btree_lookup ( struct xfs_btree_cur * cur , xfs_lookup_t dir , int * stat ) ;

int xfs_btree_update ( struct xfs_btree_cur * cur , union xfs_btree_rec * rec ) ;

int xfs_btree_new_iroot ( struct xfs_btree_cur * cur , int * logflags , int * stat ) ;

int xfs_btree_insert ( struct xfs_btree_cur * cur , int * stat ) ;

int xfs_btree_delete ( struct xfs_btree_cur * cur , int * stat ) ;

int xfs_btree_get_rec ( struct xfs_btree_cur * cur , union xfs_btree_rec * * recp , int * stat ) ;

void xfs_buf_item_init ( xfs_buf_t * bp , xfs_mount_t * mp ) ;

void xfs_buf_item_log ( xfs_buf_log_item_t * bip , uint first , uint last ) ;

uint xfs_buf_item_dirty ( xfs_buf_log_item_t * bip ) ;

void xfs_buf_item_relse ( xfs_buf_t * bp ) ;

void xfs_buf_attach_iodone ( xfs_buf_t * bp , void ( * cb ) ( xfs_buf_t * , xfs_log_item_t * ) , xfs_log_item_t * lip ) ;

void xfs_buf_iodone_callbacks ( xfs_buf_t * bp ) ;

void xfs_buf_iodone ( xfs_buf_t * bp , xfs_buf_log_item_t * bip ) ;


typedef struct xfs_dir2_free_hdr { __be32 magic ; __be32 firstdb ; __be32 nvalid ; __be32 nused ; } xfs_dir2_free_hdr_t ;


typedef struct xfs_dir2_free { xfs_dir2_free_hdr_t hdr ; __be16 bests [ 1 ] ; } xfs_dir2_free_t ;

int xfs_da_node_create ( xfs_da_args_t * args , xfs_dablk_t blkno , int level , xfs_dabuf_t * * bpp , int whichfork ) ;

int xfs_da_split ( xfs_da_state_t * state ) ;

int xfs_da_join ( xfs_da_state_t * state ) ;

void xfs_da_fixhashpath ( xfs_da_state_t * state , xfs_da_state_path_t * path ) ;

int xfs_da_node_lookup_int ( xfs_da_state_t * state , int * result ) ;

int xfs_da_blk_link ( xfs_da_state_t * state , xfs_da_state_blk_t * old_blk , xfs_da_state_blk_t * new_blk ) ;

int xfs_da_path_shift ( xfs_da_state_t * state , xfs_da_state_path_t * path , int forward , int release , int * result ) ;

xfs_dahash_t xfs_da_hashname ( const __uint8_t * name , int namelen ) ;

enum xfs_dacmp xfs_da_compname ( struct xfs_da_args * args , const char * name , int len ) ;

int xfs_da_grow_inode ( xfs_da_args_t * args , xfs_dablk_t * new_blkno ) ;

int xfs_da_shrink_inode ( xfs_da_args_t * args , xfs_dablk_t dead_blkno , xfs_dabuf_t * dead_buf ) ;

int xfs_da_get_buf ( xfs_trans_t * trans , xfs_inode_t * dp , xfs_dablk_t bno , xfs_daddr_t mappedbno , xfs_dabuf_t * * bpp , int whichfork ) ;

int xfs_da_read_buf ( xfs_trans_t * trans , xfs_inode_t * dp , xfs_dablk_t bno , xfs_daddr_t mappedbno , xfs_dabuf_t * * bpp , int whichfork ) ;

xfs_daddr_t xfs_da_reada_buf ( xfs_trans_t * trans , xfs_inode_t * dp , xfs_dablk_t bno , int whichfork ) ;

xfs_da_state_t * xfs_da_state_alloc ( void ) ;

void xfs_da_state_free ( xfs_da_state_t * state ) ;

void xfs_da_buf_done ( xfs_dabuf_t * dabuf ) ;

void xfs_da_log_buf ( xfs_trans_t * tp , xfs_dabuf_t * dabuf , uint first , uint last ) ;

void xfs_da_brelse ( xfs_trans_t * tp , xfs_dabuf_t * dabuf ) ;

void xfs_da_binval ( xfs_trans_t * tp , xfs_dabuf_t * dabuf ) ;

xfs_daddr_t xfs_da_blkno ( xfs_dabuf_t * dabuf ) ;

void xfs_dir_mount ( xfs_mount_t * mp ) ;

int xfs_dir_isempty ( xfs_inode_t * dp ) ;

int xfs_dir_ino_validate ( xfs_mount_t * mp , xfs_ino_t ino ) ;

int xfs_dir_init ( xfs_trans_t * tp , xfs_inode_t * dp , xfs_inode_t * pdp ) ;

int xfs_dir_createname ( xfs_trans_t * tp , xfs_inode_t * dp , struct xfs_name * name , xfs_ino_t inum , xfs_fsblock_t * first , xfs_bmap_free_t * flist , xfs_extlen_t total ) ;

int xfs_dir_cilookup_result ( struct xfs_da_args * args , const char * name , int len ) ;

int xfs_dir_lookup ( xfs_trans_t * tp , xfs_inode_t * dp , struct xfs_name * name , xfs_ino_t * inum , struct xfs_name * ci_name ) ;

int xfs_dir_removename ( xfs_trans_t * tp , xfs_inode_t * dp , struct xfs_name * name , xfs_ino_t ino , xfs_fsblock_t * first , xfs_bmap_free_t * flist , xfs_extlen_t total ) ;

int xfs_readdir ( xfs_inode_t * dp , void * dirent , size_t bufsize , xfs_off_t * offset , filldir_t filldir ) ;

int xfs_dir_replace ( xfs_trans_t * tp , xfs_inode_t * dp , struct xfs_name * name , xfs_ino_t inum , xfs_fsblock_t * first , xfs_bmap_free_t * flist , xfs_extlen_t total ) ;

int xfs_dir_canenter ( xfs_trans_t * tp , xfs_inode_t * dp , struct xfs_name * name , uint resblks ) ;

int xfs_dir2_grow_inode ( xfs_da_args_t * args , int space , xfs_dir2_db_t * dbp ) ;

int xfs_dir2_isblock ( xfs_trans_t * tp , xfs_inode_t * dp , int * vp ) ;

int xfs_dir2_isleaf ( xfs_trans_t * tp , xfs_inode_t * dp , int * vp ) ;

int xfs_dir2_shrink_inode ( xfs_da_args_t * args , xfs_dir2_db_t db , xfs_dabuf_t * bp ) ;

void xfs_dir_startup ( void ) ;

int xfs_dir2_block_addname ( xfs_da_args_t * args ) ;

int xfs_dir2_block_getdents ( xfs_inode_t * dp , void * dirent , xfs_off_t * offset , filldir_t filldir ) ;

int xfs_dir2_block_lookup ( xfs_da_args_t * args ) ;

int xfs_dir2_block_removename ( xfs_da_args_t * args ) ;

int xfs_dir2_block_replace ( xfs_da_args_t * args ) ;

int xfs_dir2_leaf_to_block ( xfs_da_args_t * args , xfs_dabuf_t * lbp , xfs_dabuf_t * dbp ) ;

int xfs_dir2_sf_to_block ( xfs_da_args_t * args ) ;

xfs_dir2_data_free_t * xfs_dir2_data_freefind ( xfs_dir2_data_t * d , xfs_dir2_data_unused_t * dup ) ;

xfs_dir2_data_free_t * xfs_dir2_data_freeinsert ( xfs_dir2_data_t * d , xfs_dir2_data_unused_t * dup , int * loghead ) ;

void xfs_dir2_data_freescan ( xfs_mount_t * mp , xfs_dir2_data_t * d , int * loghead ) ;

int xfs_dir2_data_init ( xfs_da_args_t * args , xfs_dir2_db_t blkno , xfs_dabuf_t * * bpp ) ;

void xfs_dir2_data_log_entry ( xfs_trans_t * tp , xfs_dabuf_t * bp , xfs_dir2_data_entry_t * dep ) ;

void xfs_dir2_data_log_header ( xfs_trans_t * tp , xfs_dabuf_t * bp ) ;

void xfs_dir2_data_log_unused ( xfs_trans_t * tp , xfs_dabuf_t * bp , xfs_dir2_data_unused_t * dup ) ;

void xfs_dir2_data_make_free ( xfs_trans_t * tp , xfs_dabuf_t * bp , xfs_dir2_data_aoff_t offset , xfs_dir2_data_aoff_t len , int * needlogp , int * needscanp ) ;

void xfs_dir2_data_use_free ( xfs_trans_t * tp , xfs_dabuf_t * bp , xfs_dir2_data_unused_t * dup , xfs_dir2_data_aoff_t offset , xfs_dir2_data_aoff_t len , int * needlogp , int * needscanp ) ;

int xfs_dir2_block_to_leaf ( xfs_da_args_t * args , xfs_dabuf_t * dbp ) ;

int xfs_dir2_leaf_addname ( xfs_da_args_t * args ) ;

void xfs_dir2_leaf_compact ( xfs_da_args_t * args , xfs_dabuf_t * bp ) ;

void xfs_dir2_leaf_compact_x1 ( xfs_dabuf_t * bp , int * indexp , int * lowstalep , int * highstalep , int * lowlogp , int * highlogp ) ;

int xfs_dir2_leaf_getdents ( xfs_inode_t * dp , void * dirent , size_t bufsize , xfs_off_t * offset , filldir_t filldir ) ;

int xfs_dir2_leaf_init ( xfs_da_args_t * args , xfs_dir2_db_t bno , xfs_dabuf_t * * bpp , int magic ) ;

void xfs_dir2_leaf_log_ents ( xfs_trans_t * tp , xfs_dabuf_t * bp , int first , int last ) ;

void xfs_dir2_leaf_log_header ( xfs_trans_t * tp , xfs_dabuf_t * bp ) ;

int xfs_dir2_leaf_lookup ( xfs_da_args_t * args ) ;

int xfs_dir2_leaf_removename ( xfs_da_args_t * args ) ;

int xfs_dir2_leaf_replace ( xfs_da_args_t * args ) ;

int xfs_dir2_leaf_search_hash ( xfs_da_args_t * args , xfs_dabuf_t * lbp ) ;

int xfs_dir2_leaf_trim_data ( xfs_da_args_t * args , xfs_dabuf_t * lbp , xfs_dir2_db_t db ) ;

int xfs_dir2_node_to_leaf ( xfs_da_state_t * state ) ;

void xfs_dir2_free_log_bests ( xfs_trans_t * tp , xfs_dabuf_t * bp , int first , int last ) ;

int xfs_dir2_leaf_to_node ( xfs_da_args_t * args , xfs_dabuf_t * lbp ) ;

xfs_dahash_t xfs_dir2_leafn_lasthash ( xfs_dabuf_t * bp , int * count ) ;

int xfs_dir2_leafn_lookup_int ( xfs_dabuf_t * bp , xfs_da_args_t * args , int * indexp , xfs_da_state_t * state ) ;

int xfs_dir2_leafn_order ( xfs_dabuf_t * leaf1_bp , xfs_dabuf_t * leaf2_bp ) ;

int xfs_dir2_leafn_split ( xfs_da_state_t * state , xfs_da_state_blk_t * oldblk , xfs_da_state_blk_t * newblk ) ;

int xfs_dir2_leafn_toosmall ( xfs_da_state_t * state , int * action ) ;

void xfs_dir2_leafn_unbalance ( xfs_da_state_t * state , xfs_da_state_blk_t * drop_blk , xfs_da_state_blk_t * save_blk ) ;

int xfs_dir2_node_addname ( xfs_da_args_t * args ) ;

int xfs_dir2_node_lookup ( xfs_da_args_t * args ) ;

int xfs_dir2_node_removename ( xfs_da_args_t * args ) ;

int xfs_dir2_node_replace ( xfs_da_args_t * args ) ;

int xfs_dir2_node_trim_free ( xfs_da_args_t * args , xfs_fileoff_t fo , int * rvalp ) ;

int xfs_dir2_block_sfsize ( xfs_inode_t * dp , xfs_dir2_block_t * block , xfs_dir2_sf_hdr_t * sfhp ) ;

int xfs_dir2_block_to_sf ( xfs_da_args_t * args , xfs_dabuf_t * bp , int size , xfs_dir2_sf_hdr_t * sfhp ) ;

int xfs_dir2_sf_addname ( xfs_da_args_t * args ) ;

int xfs_dir2_sf_create ( xfs_da_args_t * args , xfs_ino_t pino ) ;

int xfs_dir2_sf_getdents ( xfs_inode_t * dp , void * dirent , xfs_off_t * offset , filldir_t filldir ) ;

int xfs_dir2_sf_lookup ( xfs_da_args_t * args ) ;

int xfs_dir2_sf_removename ( xfs_da_args_t * args ) ;

int xfs_dir2_sf_replace ( xfs_da_args_t * args ) ;

void xfs_fs_cmn_err ( int level , xfs_mount_t * mp , char * fmt , ... ) ;

void xfs_cmn_err ( int panic_tag , int level , xfs_mount_t * mp , char * fmt , ... ) ;

void xfs_error_report ( char * tag , int level , xfs_mount_t * mp , char * fname , int linenum , inst_t * ra ) ;

void xfs_corruption_error ( char * tag , int level , xfs_mount_t * mp , void * p , char * fname , int linenum , inst_t * ra ) ;

void xfs_efi_item_free ( xfs_efi_log_item_t * efip ) ;

xfs_efi_log_item_t * xfs_efi_init ( xfs_mount_t * mp , uint nextents ) ;

int xfs_efi_copy_format ( xfs_log_iovec_t * buf , xfs_efi_log_format_t * dst_efi_fmt ) ;

void xfs_efi_release ( xfs_efi_log_item_t * efip , uint nextents ) ;

xfs_efd_log_item_t * xfs_efd_init ( xfs_mount_t * mp , xfs_efi_log_item_t * efip , uint nextents ) ;

typedef void ( * xfs_mru_cache_free_func_t ) ( unsigned long , void * ) ;

typedef struct xfs_mru_cache { struct radix_tree_root store ; struct list_head * lists ; struct list_head reap_list ; spinlock_t lock ; unsigned int grp_count ; unsigned int grp_time ; unsigned int lru_grp ; unsigned long time_zero ; xfs_mru_cache_free_func_t free_func ; struct delayed_work work ; unsigned int queued ; } xfs_mru_cache_t ;


typedef struct fstrm_item { xfs_agnumber_t ag ; xfs_inode_t * ip ; xfs_inode_t * pip ; } fstrm_item_t ;

int xfs_filestream_init ( void ) ;

void xfs_filestream_uninit ( void ) ;

int xfs_filestream_mount ( xfs_mount_t * mp ) ;

void xfs_filestream_unmount ( xfs_mount_t * mp ) ;

void xfs_filestream_flush ( xfs_mount_t * mp ) ;

xfs_agnumber_t xfs_filestream_lookup_ag ( xfs_inode_t * ip ) ;

int xfs_filestream_associate ( xfs_inode_t * pip , xfs_inode_t * ip ) ;

int xfs_filestream_new_ag ( xfs_bmalloca_t * ap , xfs_agnumber_t * agp ) ;

void xfs_filestream_deassociate ( xfs_inode_t * ip ) ;

int xfs_fs_geometry ( xfs_mount_t * mp , xfs_fsop_geom_t * geo , int new_version ) ;

int xfs_growfs_data ( xfs_mount_t * mp , xfs_growfs_data_t * in ) ;
int xfs_growfs_log ( xfs_mount_t * mp , xfs_growfs_log_t * in ) ;
int xfs_fs_counts ( xfs_mount_t * mp , xfs_fsop_counts_t * cnt ) ;

int xfs_reserve_blocks ( xfs_mount_t * mp , __uint64_t * inval , xfs_fsop_resblks_t * outval ) ;

int xfs_fs_log_dummy ( xfs_mount_t * mp ) ;

int xfs_fs_goingdown ( xfs_mount_t * mp , __uint32_t inflags ) ;

int xfs_inobt_lookup ( struct xfs_btree_cur * cur , xfs_agino_t ino , xfs_lookup_t dir , int * stat ) ;

int xfs_inobt_get_rec ( struct xfs_btree_cur * cur , xfs_inobt_rec_incore_t * irec , int * stat ) ;

int xfs_dialloc ( xfs_trans_t * tp , xfs_ino_t parent , mode_t mode , int okalloc , xfs_buf_t * * IO_agbp , boolean_t * alloc_done , xfs_ino_t * inop ) ;

int xfs_difree ( xfs_trans_t * tp , xfs_ino_t inode , xfs_bmap_free_t * flist , int * delete , xfs_ino_t * first_ino ) ;

int xfs_imap ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_ino_t ino , struct xfs_imap * imap , uint flags ) ;
void xfs_ialloc_compute_maxlevels ( xfs_mount_t * mp ) ;

void xfs_ialloc_log_agi ( xfs_trans_t * tp , xfs_buf_t * bp , int fields ) ;

int xfs_read_agi ( struct xfs_mount * mp , struct xfs_trans * tp , xfs_agnumber_t agno , struct xfs_buf * * bpp ) ;

int xfs_ialloc_read_agi ( struct xfs_mount * mp , struct xfs_trans * tp , xfs_agnumber_t agno , struct xfs_buf * * bpp ) ;

int xfs_ialloc_pagi_init ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_agnumber_t agno ) ;

struct xfs_btree_cur * xfs_inobt_init_cursor ( struct xfs_mount * mp , struct xfs_trans * tp , struct xfs_buf * agbp , xfs_agnumber_t agno ) ;

int xfs_inobt_maxrecs ( struct xfs_mount * mp , int blocklen , int leaf ) ;

int xfs_iget ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_ino_t ino , uint flags , uint lock_flags , xfs_inode_t * * ipp , xfs_daddr_t bno ) ;

void xfs_iput ( xfs_inode_t * ip , uint lock_flags ) ;

void xfs_iput_new ( xfs_inode_t * ip , uint lock_flags ) ;

void xfs_ireclaim ( struct xfs_inode * ip ) ;

uint xfs_ilock_map_shared ( xfs_inode_t * ip ) ;

void xfs_iunlock_map_shared ( xfs_inode_t * ip , unsigned int lock_mode ) ;

void xfs_ilock ( xfs_inode_t * ip , uint lock_flags ) ;

int xfs_ilock_nowait ( xfs_inode_t * ip , uint lock_flags ) ;

void xfs_iunlock ( xfs_inode_t * ip , uint lock_flags ) ;

void xfs_ilock_demote ( xfs_inode_t * ip , uint lock_flags ) ;

int xfs_inotobp ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_ino_t ino , xfs_dinode_t * * dipp , xfs_buf_t * * bpp , int * offset , uint imap_flags ) ;

int xfs_itobp ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_inode_t * ip , xfs_dinode_t * * dipp , xfs_buf_t * * bpp , uint buf_flags ) ;

void xfs_dinode_to_disk ( xfs_dinode_t * to , xfs_icdinode_t * from ) ;

uint xfs_ip2xflags ( xfs_inode_t * ip ) ;

uint xfs_dic2xflags ( xfs_dinode_t * dip ) ;

int xfs_iread ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_inode_t * ip , xfs_daddr_t bno , uint iget_flags ) ;

int xfs_iread_extents ( xfs_trans_t * tp , xfs_inode_t * ip , int whichfork ) ;

int xfs_ialloc ( xfs_trans_t * tp , xfs_inode_t * pip , mode_t mode , xfs_nlink_t nlink , xfs_dev_t rdev , cred_t * cr , xfs_prid_t prid , int okalloc , xfs_buf_t * * ialloc_context , boolean_t * call_again , xfs_inode_t * * ipp ) ;

int xfs_itruncate_start ( xfs_inode_t * ip , uint flags , xfs_fsize_t new_size ) ;

int xfs_itruncate_finish ( xfs_trans_t * * tp , xfs_inode_t * ip , xfs_fsize_t new_size , int fork , int sync ) ;

int xfs_iunlink ( xfs_trans_t * tp , xfs_inode_t * ip ) ;

int xfs_ifree ( xfs_trans_t * tp , xfs_inode_t * ip , xfs_bmap_free_t * flist ) ;

void xfs_iroot_realloc ( xfs_inode_t * ip , int rec_diff , int whichfork ) ;

void xfs_idata_realloc ( xfs_inode_t * ip , int byte_diff , int whichfork ) ;

void xfs_idestroy_fork ( xfs_inode_t * ip , int whichfork ) ;

void xfs_ipin ( xfs_inode_t * ip ) ;

void xfs_iunpin ( xfs_inode_t * ip ) ;

int xfs_iextents_copy ( xfs_inode_t * ip , xfs_bmbt_rec_t * dp , int whichfork ) ;

int xfs_iflush ( xfs_inode_t * ip , uint flags ) ;

xfs_bmbt_rec_host_t * xfs_iext_get_ext ( xfs_ifork_t * ifp , xfs_extnum_t idx ) ;

void xfs_iext_insert ( xfs_ifork_t * ifp , xfs_extnum_t idx , xfs_extnum_t count , xfs_bmbt_irec_t * new ) ;

void xfs_iext_add ( xfs_ifork_t * ifp , xfs_extnum_t idx , int ext_diff ) ;

void xfs_iext_add_indirect_multi ( xfs_ifork_t * ifp , int erp_idx , xfs_extnum_t idx , int count ) ;

void xfs_iext_remove ( xfs_ifork_t * ifp , xfs_extnum_t idx , int ext_diff ) ;

void xfs_iext_remove_inline ( xfs_ifork_t * ifp , xfs_extnum_t idx , int ext_diff ) ;

void xfs_iext_remove_direct ( xfs_ifork_t * ifp , xfs_extnum_t idx , int ext_diff ) ;

void xfs_iext_remove_indirect ( xfs_ifork_t * ifp , xfs_extnum_t idx , int count ) ;

void xfs_iext_realloc_direct ( xfs_ifork_t * ifp , int new_size ) ;

void xfs_iext_direct_to_inline ( xfs_ifork_t * ifp , xfs_extnum_t nextents ) ;

void xfs_iext_inline_to_direct ( xfs_ifork_t * ifp , int new_size ) ;

void xfs_iext_destroy ( xfs_ifork_t * ifp ) ;

xfs_bmbt_rec_host_t * xfs_iext_bno_to_ext ( xfs_ifork_t * ifp , xfs_fileoff_t bno , xfs_extnum_t * idxp ) ;

xfs_ext_irec_t * xfs_iext_bno_to_irec ( xfs_ifork_t * ifp , xfs_fileoff_t bno , int * erp_idxp ) ;

xfs_ext_irec_t * xfs_iext_idx_to_irec ( xfs_ifork_t * ifp , xfs_extnum_t * idxp , int * erp_idxp , int realloc ) ;

void xfs_iext_irec_init ( xfs_ifork_t * ifp ) ;

xfs_ext_irec_t * xfs_iext_irec_new ( xfs_ifork_t * ifp , int erp_idx ) ;

void xfs_iext_irec_remove ( xfs_ifork_t * ifp , int erp_idx ) ;

void xfs_iext_irec_compact ( xfs_ifork_t * ifp ) ;

void xfs_iext_irec_compact_pages ( xfs_ifork_t * ifp ) ;

void xfs_iext_irec_update_extoffs ( xfs_ifork_t * ifp , int erp_idx , int ext_diff ) ;

void xfs_inode_item_init ( xfs_inode_t * ip , xfs_mount_t * mp ) ;

void xfs_inode_item_destroy ( xfs_inode_t * ip ) ;

void xfs_iflush_done ( xfs_buf_t * bp , xfs_inode_log_item_t * iip ) ;

void xfs_iflush_abort ( xfs_inode_t * ip ) ;

void xfs_istale_done ( xfs_buf_t * bp , xfs_inode_log_item_t * iip ) ;

int xfs_inode_item_format_convert ( xfs_log_iovec_t * buf , xfs_inode_log_format_t * in_f ) ;

typedef enum { IOMAP_READ = 0 , IOMAP_HOLE = 0x02 , IOMAP_DELAY = 0x04 , IOMAP_REALTIME = 0x10 , IOMAP_UNWRITTEN = 0x20 , IOMAP_NEW = 0x40 } iomap_flags_t ;

typedef enum { BMAPI_READ = ( 1 << 0 ) , BMAPI_WRITE = ( 1 << 1 ) , BMAPI_ALLOCATE = ( 1 << 2 ) , BMAPI_IGNSTATE = ( 1 << 4 ) , BMAPI_DIRECT = ( 1 << 5 ) , BMAPI_MMAP = ( 1 << 6 ) , BMAPI_TRYLOCK = ( 1 << 7 ) , } bmapi_flags_t ;

typedef struct xfs_iomap { xfs_daddr_t iomap_bn ; xfs_buftarg_t * iomap_target ; xfs_off_t iomap_offset ; xfs_off_t iomap_bsize ; xfs_off_t iomap_delta ; iomap_flags_t iomap_flags ; } xfs_iomap_t ;

int xfs_iomap ( xfs_inode_t * ip , xfs_off_t offset , ssize_t count , int flags , xfs_iomap_t * iomapp , int * niomaps ) ;
int xfs_iomap_write_direct ( xfs_inode_t * ip , xfs_off_t offset , size_t count , int flags , xfs_bmbt_irec_t * ret_imap , int * nmaps , int found ) ;

int xfs_iomap_write_delay ( xfs_inode_t * ip , xfs_off_t offset , size_t count , int ioflag , xfs_bmbt_irec_t * ret_imap , int * nmaps ) ;

int xfs_iomap_write_allocate ( xfs_inode_t * ip , xfs_off_t offset , size_t count , xfs_bmbt_irec_t * map , int * retmap ) ;

int xfs_iomap_write_unwritten ( xfs_inode_t * ip , xfs_off_t offset , size_t count ) ;

int xfs_bulkstat_one_int ( xfs_mount_t * mp , xfs_ino_t ino , void * buffer , int ubsize , bulkstat_one_fmt_pf formatter , xfs_daddr_t bno , int * ubused , void * dibuff , int * stat ) ;

int xfs_bulkstat_one ( xfs_mount_t * mp , xfs_ino_t ino , void * buffer , int ubsize , void * private_data , xfs_daddr_t bno , int * ubused , void * dibuff , int * stat ) ;

int xfs_bulkstat ( xfs_mount_t * mp , xfs_ino_t * lastinop , int * ubcountp , bulkstat_one_pf formatter , void * private_data , size_t statstruct_size , char * ubuffer , int flags , int * done ) ;

int xfs_bulkstat_single ( xfs_mount_t * mp , xfs_ino_t * lastinop , char * buffer , int * done ) ;

int xfs_inumbers_fmt ( void * ubuffer , const xfs_inogrp_t * buffer , long count , long * written ) ;

int xfs_inumbers ( xfs_mount_t * mp , xfs_ino_t * lastino , int * count , void * ubuffer , inumbers_fmt_pf formatter ) ;


int xfs_swapext ( xfs_swapext_t * sxp ) ;
int xfs_swap_extents ( xfs_inode_t * ip , xfs_inode_t * tip , xfs_swapext_t * sxp ) ;

struct xfs_buf_cancel ;
typedef __uint32_t xlog_tid_t ;


typedef struct xlog_res { uint r_len ; uint r_type ; } xlog_res_t ;

typedef struct xlog_ticket { sv_t t_wait ; struct xlog_ticket * t_next ; struct xlog_ticket * t_prev ; xlog_tid_t t_tid ; atomic_t t_ref ; int t_curr_res ; int t_unit_res ; char t_ocnt ; char t_cnt ; char t_clientid ; char t_flags ; uint t_trans_type ; uint t_res_num ; uint t_res_num_ophdrs ; uint t_res_arr_sum ; uint t_res_o_flow ; xlog_res_t t_res_arr [ 15 ] ; } xlog_ticket_t ;


typedef struct xlog_op_header { __be32 oh_tid ; __be32 oh_len ; __u8 oh_clientid ; __u8 oh_flags ; __u16 oh_res2 ; } xlog_op_header_t ;


typedef struct xlog_rec_header { __be32 h_magicno ; __be32 h_cycle ; __be32 h_version ; __be32 h_len ; __be64 h_lsn ; __be64 h_tail_lsn ; __be32 h_chksum ; __be32 h_prev_block ; __be32 h_num_logops ; __be32 h_cycle_data [ ( 32 * 1024 ) / ( 1 << 9 ) ] ; __be32 h_fmt ; uuid_t h_fs_uuid ; __be32 h_size ; } xlog_rec_header_t ;


typedef struct xlog_rec_ext_header { __be32 xh_cycle ; __be32 xh_cycle_data [ ( 32 * 1024 ) / ( 1 << 9 ) ] ; } xlog_rec_ext_header_t ;


typedef union xlog_in_core2 { xlog_rec_header_t hic_header ; xlog_rec_ext_header_t hic_xheader ; char hic_sector [ 512 ] ; } xlog_in_core_2_t ;


typedef struct xlog_in_core { sv_t ic_force_wait ; sv_t ic_write_wait ; struct xlog_in_core * ic_next ; struct xlog_in_core * ic_prev ; struct xfs_buf * ic_bp ; struct log * ic_log ; int ic_size ; int ic_offset ; int ic_bwritecnt ; unsigned short ic_state ; char * ic_datap ; spinlock_t ic_callback_lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; xfs_log_callback_t * ic_callback ; xfs_log_callback_t * * ic_callback_tail ; atomic_t ic_refcnt __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; xlog_in_core_2_t * ic_data ; } xlog_in_core_t ;

typedef struct log { struct xfs_mount * l_mp ; struct xfs_ail * l_ailp ; struct xfs_buf * l_xbuf ; struct xfs_buftarg * l_targ ; uint l_flags ; uint l_quotaoffs_flag ; struct xfs_buf_cancel * * l_buf_cancel_table ; int l_iclog_hsize ; int l_iclog_heads ; uint l_sectbb_log ; uint l_sectbb_mask ; int l_iclog_size ; int l_iclog_size_log ; int l_iclog_bufs ; xfs_daddr_t l_logBBstart ; int l_logsize ; int l_logBBsize ; sv_t l_flush_wait __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; int l_covered_state ; xlog_in_core_t * l_iclog ; spinlock_t l_icloglock ; xfs_lsn_t l_tail_lsn ; xfs_lsn_t l_last_sync_lsn ; int l_curr_cycle ; int l_prev_cycle ; int l_curr_block ; int l_prev_block ; spinlock_t l_grant_lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; xlog_ticket_t * l_reserve_headq ; xlog_ticket_t * l_write_headq ; int l_grant_reserve_cycle ; int l_grant_reserve_bytes ; int l_grant_write_cycle ; int l_grant_write_bytes ; } xlog_t ;


typedef struct xlog_recover_item { struct xlog_recover_item * ri_next ; struct xlog_recover_item * ri_prev ; int ri_type ; int ri_cnt ; int ri_total ; xfs_log_iovec_t * ri_buf ; } xlog_recover_item_t ;

struct xlog_tid ;


typedef struct xlog_recover { struct xlog_recover * r_next ; xlog_tid_t r_log_tid ; xfs_trans_header_t r_theader ; int r_state ; xfs_lsn_t r_lsn ; xlog_recover_item_t * r_itemq ; } xlog_recover_t ;

xfs_lsn_t xfs_log_done ( xfs_mount_t * mp , xfs_log_ticket_t xtic , void * * iclog , uint flags ) ;

int _xfs_log_force ( xfs_mount_t * mp , xfs_lsn_t lsn , uint flags , int * log_flushed ) ;

void xfs_log_force ( xfs_mount_t * mp , xfs_lsn_t lsn , uint flags ) ;

int xfs_log_notify ( xfs_mount_t * mp , void * iclog_hndl , xfs_log_callback_t * cb ) ;

int xfs_log_release_iclog ( xfs_mount_t * mp , void * iclog_hndl ) ;

int xfs_log_reserve ( xfs_mount_t * mp , int unit_bytes , int cnt , xfs_log_ticket_t * ticket , __uint8_t client , uint flags , uint t_type ) ;

int xfs_log_mount ( xfs_mount_t * mp , xfs_buftarg_t * log_target , xfs_daddr_t blk_offset , int num_bblks ) ;

int xfs_log_mount_finish ( xfs_mount_t * mp ) ;

int xfs_log_unmount_write ( xfs_mount_t * mp ) ;

void xfs_log_unmount ( xfs_mount_t * mp ) ;

int xfs_log_write ( xfs_mount_t * mp , xfs_log_iovec_t reg [ ] , int nentries , xfs_log_ticket_t tic , xfs_lsn_t * start_lsn ) ;

void xfs_log_move_tail ( xfs_mount_t * mp , xfs_lsn_t tail_lsn ) ;

int xfs_log_need_covered ( xfs_mount_t * mp ) ;

xfs_lsn_t xlog_assign_tail_lsn ( xfs_mount_t * mp ) ;

void xlog_iodone ( xfs_buf_t * bp ) ;

void xfs_log_ticket_put ( xlog_ticket_t * ticket ) ;

xlog_ticket_t * xfs_log_ticket_get ( xlog_ticket_t * ticket ) ;

int xfs_log_force_umount ( struct xfs_mount * mp , int logerror ) ;

xfs_buf_t * xlog_get_bp ( xlog_t * log , int nbblks ) ;

void xlog_put_bp ( xfs_buf_t * bp ) ;

int xlog_find_tail ( xlog_t * log , xfs_daddr_t * head_blk , xfs_daddr_t * tail_blk ) ;

int xfs_qm_dqcheck ( xfs_disk_dquot_t * ddq , xfs_dqid_t id , uint type , uint flags , char * str ) ;

void xlog_pack_data ( xlog_t * log , xlog_in_core_t * iclog , int roundoff ) ;

int xlog_recover ( xlog_t * log ) ;
int xlog_recover_finish ( xlog_t * log ) ;

int xfs_sb_validate_fsb_count ( xfs_sb_t * sbp , __uint64_t nblocks ) ;

xfs_agnumber_t xfs_initialize_perag ( xfs_mount_t * mp , xfs_agnumber_t agcount ) ;

void xfs_sb_from_disk ( xfs_sb_t * to , xfs_dsb_t * from ) ;

void xfs_sb_to_disk ( xfs_dsb_t * to , xfs_sb_t * from , __int64_t fields ) ;

int xfs_readsb ( xfs_mount_t * mp , int flags ) ;

int xfs_mount_reset_sbqflags ( struct xfs_mount * mp ) ;

int xfs_mountfs ( xfs_mount_t * mp ) ;

void xfs_unmountfs ( struct xfs_mount * mp ) ;

int xfs_fs_writable ( xfs_mount_t * mp ) ;

int xfs_log_sbcount ( xfs_mount_t * mp , uint sync ) ;

int xfs_unmountfs_writesb ( xfs_mount_t * mp ) ;

void xfs_mod_sb ( xfs_trans_t * tp , __int64_t fields ) ;
int xfs_mod_incore_sb ( xfs_mount_t * mp , xfs_sb_field_t field , int64_t delta , int rsvd ) ;

int xfs_mod_incore_sb_batch ( xfs_mount_t * mp , xfs_mod_sb_t * msb , uint nmsb , int rsvd ) ;

xfs_buf_t * xfs_getsb ( xfs_mount_t * mp , int flags ) ;

void xfs_freesb ( xfs_mount_t * mp ) ;

int xfs_mount_log_sb ( xfs_mount_t * mp , __int64_t fields ) ;

int xfs_icsb_init_counters ( xfs_mount_t * mp ) ;

void xfs_icsb_reinit_counters ( xfs_mount_t * mp ) ;

void xfs_icsb_destroy_counters ( xfs_mount_t * mp ) ;

void xfs_icsb_sync_counters_locked ( xfs_mount_t * mp , int flags ) ;

void xfs_icsb_sync_counters ( xfs_mount_t * mp , int flags ) ;


typedef struct xfs_mru_cache_elem { struct list_head list_node ; unsigned long key ; void * value ; } xfs_mru_cache_elem_t ;

int xfs_mru_cache_init ( void ) ;

void xfs_mru_cache_uninit ( void ) ;

int xfs_mru_cache_create ( xfs_mru_cache_t * * mrup , unsigned int lifetime_ms , unsigned int grp_count , xfs_mru_cache_free_func_t free_func ) ;

void xfs_mru_cache_flush ( xfs_mru_cache_t * mru ) ;

void xfs_mru_cache_destroy ( xfs_mru_cache_t * mru ) ;

int xfs_mru_cache_insert ( xfs_mru_cache_t * mru , unsigned long key , void * value ) ;

void * xfs_mru_cache_remove ( xfs_mru_cache_t * mru , unsigned long key ) ;

void xfs_mru_cache_delete ( xfs_mru_cache_t * mru , unsigned long key ) ;

void * xfs_mru_cache_lookup ( xfs_mru_cache_t * mru , unsigned long key ) ;

void xfs_mru_cache_done ( xfs_mru_cache_t * mru ) ;

int xfs_rename ( xfs_inode_t * src_dp , struct xfs_name * src_name , xfs_inode_t * src_ip , xfs_inode_t * target_dp , struct xfs_name * target_name , xfs_inode_t * target_ip ) ;

void xfs_trans_init ( xfs_mount_t * mp ) ;

xfs_trans_t * xfs_trans_alloc ( xfs_mount_t * mp , uint type ) ;

xfs_trans_t * _xfs_trans_alloc ( xfs_mount_t * mp , uint type , uint memflags ) ;

xfs_trans_t * xfs_trans_dup ( xfs_trans_t * tp ) ;

int xfs_trans_reserve ( xfs_trans_t * tp , uint blocks , uint logspace , uint rtextents , uint flags , uint logcount ) ;

void xfs_trans_mod_sb ( xfs_trans_t * tp , uint field , int64_t delta ) ;

int _xfs_trans_commit ( xfs_trans_t * tp , uint flags , int * log_flushed ) ;

void xfs_trans_cancel ( xfs_trans_t * tp , int flags ) ;

int xfs_trans_roll ( struct xfs_trans * * tpp , struct xfs_inode * dp ) ;

xfs_lsn_t xfs_trans_ail_tail ( struct xfs_ail * ailp ) ;

void xfs_trans_ail_push ( struct xfs_ail * ailp , xfs_lsn_t threshold_lsn ) ;

struct xfs_log_item * xfs_trans_ail_cursor_next ( struct xfs_ail * ailp , struct xfs_ail_cursor * cur ) ;

void xfs_trans_ail_cursor_done ( struct xfs_ail * ailp , struct xfs_ail_cursor * done ) ;

xfs_log_item_t * xfs_trans_ail_cursor_first ( struct xfs_ail * ailp , struct xfs_ail_cursor * cur , xfs_lsn_t lsn ) ;

long xfsaild_push ( struct xfs_ail * ailp , xfs_lsn_t * last_lsn ) ;

void xfs_trans_unlocked_item ( struct xfs_ail * ailp , xfs_log_item_t * lip ) ;

void xfs_trans_ail_update ( struct xfs_ail * ailp , xfs_log_item_t * lip , xfs_lsn_t lsn ) ;

void xfs_trans_ail_delete ( struct xfs_ail * ailp , xfs_log_item_t * lip ) ;

int xfs_trans_ail_init ( xfs_mount_t * mp ) ;

void xfs_trans_ail_destroy ( xfs_mount_t * mp ) ;

xfs_buf_t * xfs_trans_get_buf ( xfs_trans_t * tp , xfs_buftarg_t * target_dev , xfs_daddr_t blkno , int len , uint flags ) ;

xfs_buf_t * xfs_trans_getsb ( xfs_trans_t * tp , struct xfs_mount * mp , int flags ) ;

int xfs_trans_read_buf ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_buftarg_t * target , xfs_daddr_t blkno , int len , uint flags , xfs_buf_t * * bpp ) ;

void xfs_trans_brelse ( xfs_trans_t * tp , xfs_buf_t * bp ) ;

void xfs_trans_bjoin ( xfs_trans_t * tp , xfs_buf_t * bp ) ;

void xfs_trans_bhold ( xfs_trans_t * tp , xfs_buf_t * bp ) ;

void xfs_trans_bhold_release ( xfs_trans_t * tp , xfs_buf_t * bp ) ;

void xfs_trans_log_buf ( xfs_trans_t * tp , xfs_buf_t * bp , uint first , uint last ) ;

void xfs_trans_binval ( xfs_trans_t * tp , xfs_buf_t * bp ) ;

void xfs_trans_inode_buf ( xfs_trans_t * tp , xfs_buf_t * bp ) ;

void xfs_trans_stale_inode_buf ( xfs_trans_t * tp , xfs_buf_t * bp ) ;

void xfs_trans_inode_alloc_buf ( xfs_trans_t * tp , xfs_buf_t * bp ) ;

void xfs_trans_dquot_buf ( xfs_trans_t * tp , xfs_buf_t * bp , uint type ) ;

xfs_efi_log_item_t * xfs_trans_get_efi ( xfs_trans_t * tp , uint nextents ) ;

void xfs_trans_log_efi_extent ( xfs_trans_t * tp , xfs_efi_log_item_t * efip , xfs_fsblock_t start_block , xfs_extlen_t ext_len ) ;

xfs_efd_log_item_t * xfs_trans_get_efd ( xfs_trans_t * tp , xfs_efi_log_item_t * efip , uint nextents ) ;

void xfs_trans_log_efd_extent ( xfs_trans_t * tp , xfs_efd_log_item_t * efdp , xfs_fsblock_t start_block , xfs_extlen_t ext_len ) ;

int xfs_trans_iget ( xfs_mount_t * mp , xfs_trans_t * tp , xfs_ino_t ino , uint flags , uint lock_flags , xfs_inode_t * * ipp ) ;

void xfs_trans_ijoin ( xfs_trans_t * tp , xfs_inode_t * ip , uint lock_flags ) ;

void xfs_trans_ihold ( xfs_trans_t * tp , xfs_inode_t * ip ) ;

void xfs_trans_log_inode ( xfs_trans_t * tp , xfs_inode_t * ip , uint flags ) ;

xfs_log_item_desc_t * xfs_trans_add_item ( xfs_trans_t * tp , xfs_log_item_t * lip ) ;

void xfs_trans_free_item ( xfs_trans_t * tp , xfs_log_item_desc_t * lidp ) ;

xfs_log_item_desc_t * xfs_trans_find_item ( xfs_trans_t * tp , xfs_log_item_t * lip ) ;

xfs_log_item_desc_t * xfs_trans_first_item ( xfs_trans_t * tp ) ;

xfs_log_item_desc_t * xfs_trans_next_item ( xfs_trans_t * tp , xfs_log_item_desc_t * lidp ) ;

void xfs_trans_free_items ( xfs_trans_t * tp , int flags ) ;

void xfs_trans_unlock_items ( xfs_trans_t * tp , xfs_lsn_t commit_lsn ) ;

xfs_log_busy_slot_t * xfs_trans_add_busy ( xfs_trans_t * tp , xfs_agnumber_t ag , xfs_extlen_t idx ) ;

void xfs_trans_free_busy ( xfs_trans_t * tp ) ;

int xfs_dir_ialloc ( xfs_trans_t * * tpp , xfs_inode_t * dp , mode_t mode , xfs_nlink_t nlink , xfs_dev_t rdev , cred_t * credp , prid_t prid , int okalloc , xfs_inode_t * * ipp , int * committed ) ;

int xfs_droplink ( xfs_trans_t * tp , xfs_inode_t * ip ) ;

void xfs_bump_ino_vers2 ( xfs_trans_t * tp , xfs_inode_t * ip ) ;

int xfs_bumplink ( xfs_trans_t * tp , xfs_inode_t * ip ) ;

int xfs_truncate_file ( xfs_mount_t * mp , xfs_inode_t * ip ) ;

int xfs_setattr ( struct xfs_inode * ip , struct iattr * iattr , int flags ) ;

int xfs_readlink ( xfs_inode_t * ip , char * link ) ;

int xfs_fsync ( xfs_inode_t * ip ) ;

int xfs_release ( xfs_inode_t * ip ) ;

int xfs_inactive ( xfs_inode_t * ip ) ;

int xfs_lookup ( xfs_inode_t * dp , struct xfs_name * name , xfs_inode_t * * ipp , struct xfs_name * ci_name ) ;

int xfs_create ( xfs_inode_t * dp , struct xfs_name * name , mode_t mode , xfs_dev_t rdev , xfs_inode_t * * ipp , cred_t * credp ) ;

void xfs_lock_inodes ( xfs_inode_t * * ips , int inodes , uint lock_mode ) ;

void xfs_lock_two_inodes ( xfs_inode_t * ip0 , xfs_inode_t * ip1 , uint lock_mode ) ;

int xfs_remove ( xfs_inode_t * dp , struct xfs_name * name , xfs_inode_t * ip ) ;

int xfs_link ( xfs_inode_t * tdp , xfs_inode_t * sip , struct xfs_name * target_name ) ;

int xfs_symlink ( xfs_inode_t * dp , struct xfs_name * link_name , const char * target_path , mode_t mode , xfs_inode_t * * ipp , cred_t * credp ) ;

int xfs_set_dmattrs ( xfs_inode_t * ip , u_int evmask , u_int16_t state ) ;

int xfs_change_file_space ( xfs_inode_t * ip , int cmd , xfs_flock64_t * bf , xfs_off_t offset , int attr_flags ) ;

int xfs_write_clear_setuid ( xfs_inode_t * ip ) ;

void xfs_do_force_shutdown ( xfs_mount_t * mp , int flags , char * fname , int lnnum ) ;

int xfs_bioerror ( xfs_buf_t * bp ) ;

int xfs_bioerror_relse ( xfs_buf_t * bp ) ;

void xfs_ioerror_alert ( char * func , struct xfs_mount * mp , xfs_buf_t * bp , xfs_daddr_t blkno ) ;

int xfs_read_buf ( struct xfs_mount * mp , xfs_buftarg_t * target , xfs_daddr_t blkno , int len , uint flags , xfs_buf_t * * bpp ) ;

int xfs_bwrite ( struct xfs_mount * mp , struct xfs_buf * bp ) ;

int xfs_dmops_get ( struct xfs_mount * mp ) ;

void xfs_dmops_put ( struct xfs_mount * mp ) ;

void * kmem_alloc ( size_t size , unsigned int flags ) ;

void * kmem_zalloc ( size_t size , unsigned int flags ) ;

void * kmem_zalloc_greedy ( size_t * size , size_t minsize , size_t maxsize , unsigned int flags ) ;

void kmem_free ( const void * ptr ) ;

void * kmem_realloc ( const void * ptr , size_t newsize , size_t oldsize , unsigned int flags ) ;

void * kmem_zone_alloc ( struct kmem_cache * zone , unsigned int flags ) ;

void * kmem_zone_zalloc ( struct kmem_cache * zone , unsigned int flags ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xfs_ioend_init ( void ) ;

void xfs_ioend_wait ( xfs_inode_t * ip ) ;

int xfs_get_blocks ( struct inode * inode , sector_t iblock , struct buffer_head * bh_result , int create ) ;


typedef struct a_list { void * vm_addr ; struct a_list * next ; } a_list_t ;

void xfs_buf_free ( xfs_buf_t * bp ) ;

xfs_buf_t * _xfs_buf_find ( xfs_buftarg_t * btp , xfs_off_t ioff , size_t isize , xfs_buf_flags_t flags , xfs_buf_t * new_bp ) ;

xfs_buf_t * xfs_buf_get_flags ( xfs_buftarg_t * target , xfs_off_t ioff , size_t isize , xfs_buf_flags_t flags ) ;

xfs_buf_t * xfs_buf_read_flags ( xfs_buftarg_t * target , xfs_off_t ioff , size_t isize , xfs_buf_flags_t flags ) ;

void xfs_buf_readahead ( xfs_buftarg_t * target , xfs_off_t ioff , size_t isize , xfs_buf_flags_t flags ) ;

xfs_buf_t * xfs_buf_get_empty ( size_t len , xfs_buftarg_t * target ) ;

int xfs_buf_associate_memory ( xfs_buf_t * bp , void * mem , size_t len ) ;

xfs_buf_t * xfs_buf_get_noaddr ( size_t len , xfs_buftarg_t * target ) ;

void xfs_buf_hold ( xfs_buf_t * bp ) ;

void xfs_buf_rele ( xfs_buf_t * bp ) ;

int xfs_buf_cond_lock ( xfs_buf_t * bp ) ;

void xfs_buf_lock ( xfs_buf_t * bp ) ;

void xfs_buf_unlock ( xfs_buf_t * bp ) ;

void xfs_buf_pin ( xfs_buf_t * bp ) ;

void xfs_buf_unpin ( xfs_buf_t * bp ) ;

int xfs_buf_ispin ( xfs_buf_t * bp ) ;

void xfs_buf_ioend ( xfs_buf_t * bp , int schedule ) ;

void xfs_buf_ioerror ( xfs_buf_t * bp , int error ) ;

int xfs_bawrite ( void * mp , struct xfs_buf * bp ) ;

void xfs_bdwrite ( void * mp , struct xfs_buf * bp ) ;

int xfs_buf_iorequest ( xfs_buf_t * bp ) ;

int xfs_buf_iowait ( xfs_buf_t * bp ) ;

xfs_caddr_t xfs_buf_offset ( xfs_buf_t * bp , size_t offset ) ;

void xfs_buf_iomove ( xfs_buf_t * bp , size_t boff , size_t bsize , caddr_t data , xfs_buf_rw_t mode ) ;

void xfs_wait_buftarg ( xfs_buftarg_t * btp ) ;

void xfs_free_buftarg ( struct xfs_mount * mp , struct xfs_buftarg * btp ) ;

int xfs_setsize_buftarg ( xfs_buftarg_t * btp , unsigned int blocksize , unsigned int sectorsize ) ;

xfs_buftarg_t * xfs_alloc_buftarg ( struct block_device * bdev , int external ) ;

void xfs_buf_delwri_dequeue ( xfs_buf_t * bp ) ;

int xfs_flush_buftarg ( xfs_buftarg_t * target , int wait ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xfs_buf_init ( void ) ;

void xfs_buf_terminate ( void ) ;

struct xfs_fid64 { u64 ino ; u32 gen ; u64 parent_ino ; u32 parent_gen ; } __attribute__ ( ( packed ) ) ;
int fs_noerr ( void ) ;

int fs_nosys ( void ) ;

void fs_noval ( void ) ;

void xfs_tosspages ( xfs_inode_t * ip , xfs_off_t first , xfs_off_t last , int fiopt ) ;

int xfs_flushinval_pages ( xfs_inode_t * ip , xfs_off_t first , xfs_off_t last , int fiopt ) ;

int xfs_flush_pages ( xfs_inode_t * ip , xfs_off_t first , xfs_off_t last , uint64_t flags , int fiopt ) ;

int xfs_wait_on_pages ( xfs_inode_t * ip , xfs_off_t first , xfs_off_t last ) ;


int xfs_find_handle ( unsigned int cmd , xfs_fsop_handlereq_t * hreq ) ;

struct dentry * xfs_handle_to_dentry ( struct file * parfilp , void * uhandle , u32 hlen ) ;

int xfs_open_by_handle ( struct file * parfilp , xfs_fsop_handlereq_t * hreq ) ;

int xfs_readlink_by_handle ( struct file * parfilp , xfs_fsop_handlereq_t * hreq ) ;

int xfs_attrmulti_attr_get ( struct inode * inode , char * name , char * ubuf , __uint32_t * len , __uint32_t flags ) ;

int xfs_attrmulti_attr_set ( struct inode * inode , char * name , const char * ubuf , __uint32_t len , __uint32_t flags ) ;

int xfs_attrmulti_attr_remove ( struct inode * inode , char * name , __uint32_t flags ) ;

int xfs_ioc_space ( struct xfs_inode * ip , struct inode * inode , struct file * filp , int ioflags , unsigned int cmd , xfs_flock64_t * bf ) ;

long xfs_file_ioctl ( struct file * filp , unsigned int cmd , unsigned long p ) ;

void xfs_synchronize_times ( xfs_inode_t * ip ) ;

void xfs_mark_inode_dirty_sync ( xfs_inode_t * ip ) ;

void xfs_ichgtime ( xfs_inode_t * ip , int flags ) ;

void xfs_setup_inode ( struct xfs_inode * ip ) ;

ssize_t xfs_read ( xfs_inode_t * ip , struct kiocb * iocb , const struct iovec * iovp , unsigned int segs , loff_t * offset , int ioflags ) ;

ssize_t xfs_splice_read ( xfs_inode_t * ip , struct file * infilp , loff_t * ppos , struct pipe_inode_info * pipe , size_t count , int flags , int ioflags ) ;

ssize_t xfs_splice_write ( xfs_inode_t * ip , struct pipe_inode_info * pipe , struct file * outfilp , loff_t * ppos , size_t count , int flags , int ioflags ) ;

int xfs_zero_eof ( xfs_inode_t * ip , xfs_off_t offset , xfs_fsize_t isize ) ;

ssize_t xfs_write ( struct xfs_inode * xip , struct kiocb * iocb , const struct iovec * iovp , unsigned int nsegs , loff_t * offset , int ioflags ) ;

int xfs_bdstrat_cb ( struct xfs_buf * bp ) ;

void xfsbdstrat ( struct xfs_mount * mp , struct xfs_buf * bp ) ;

int xfs_dev_is_read_only ( xfs_mount_t * mp , char * message ) ;

enum { Opt_barrier , Opt_nobarrier , Opt_err } ;
struct proc_xfs_info { int flag ; char * str ; } ;

__uint64_t xfs_max_file_offset ( unsigned int blockshift ) ;

void xfs_blkdev_issue_flush ( xfs_buftarg_t * buftarg ) ;

void xfsaild_wakeup ( struct xfs_ail * ailp , xfs_lsn_t threshold_lsn ) ;

int xfsaild_start ( struct xfs_ail * ailp ) ;

void xfsaild_stop ( struct xfs_ail * ailp ) ;

int xfs_inode_ag_iterator ( struct xfs_mount * mp , int ( * execute ) ( struct xfs_inode * ip , struct xfs_perag * pag , int flags ) , int flags , int tag , int exclusive , int * nr_to_scan ) ;

int xfs_sync_inode_valid ( struct xfs_inode * ip , struct xfs_perag * pag ) ;

int xfs_sync_data ( struct xfs_mount * mp , int flags ) ;

int xfs_sync_attr ( struct xfs_mount * mp , int flags ) ;

int xfs_sync_fsdata ( struct xfs_mount * mp , int flags ) ;

int xfs_quiesce_data ( struct xfs_mount * mp ) ;

void xfs_quiesce_attr ( struct xfs_mount * mp ) ;

void xfs_flush_inodes ( xfs_inode_t * ip ) ;

int xfs_syncd_init ( struct xfs_mount * mp ) ;

void xfs_syncd_stop ( struct xfs_mount * mp ) ;

void __xfs_inode_set_reclaim_tag ( struct xfs_perag * pag , struct xfs_inode * ip ) ;

void xfs_inode_set_reclaim_tag ( xfs_inode_t * ip ) ;

void __xfs_inode_clear_reclaim_tag ( xfs_mount_t * mp , xfs_perag_t * pag , xfs_inode_t * ip ) ;

int xfs_reclaim_inodes ( xfs_mount_t * mp , int mode ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xfs_inode_shrinker_init ( void ) ;

void xfs_inode_shrinker_destroy ( void ) ;

void xfs_inode_shrinker_register ( struct xfs_mount * mp ) ;

void xfs_inode_shrinker_unregister ( struct xfs_mount * mp ) ;

ssize_t xfs_vn_listxattr ( struct dentry * dentry , char * data , size_t size ) ;

void cmn_err ( register int level , char * fmt , ... ) ;

void xfs_fs_vcmn_err ( int level , struct xfs_mount * mp , char * fmt , va_list ap ) ;

void assfail ( char * expr , char * file , int line ) ;

void xfs_hex_dump ( void * p , int length ) ;

typedef struct { __be32 uu_timelow ; __be16 uu_timemid ; __be16 uu_timehi ; __be16 uu_clockseq ; __be16 uu_node [ 3 ] ; } xfs_uu_t ;

void uuid_getnodeuniq ( uuid_t * uuid , int fsid [ 2 ] ) ;

int uuid_is_nil ( uuid_t * uuid ) ;

int uuid_equal ( uuid_t * uuid1 , uuid_t * uuid2 ) ;

struct epoll_filefd { struct file * file ; int fd ; } ;

struct nested_call_node { struct list_head llink ; void * cookie ; void * ctx ; } ;

struct nested_calls { struct list_head tasks_call_list ; spinlock_t lock ; } ;

struct epitem { struct rb_node rbn ; struct list_head rdllink ; struct epitem * next ; struct epoll_filefd ffd ; int nwait ; struct list_head pwqlist ; struct eventpoll * ep ; struct list_head fllink ; struct epoll_event event ; } ;

struct eventpoll { spinlock_t lock ; struct mutex mtx ; wait_queue_head_t wq ; wait_queue_head_t poll_wait ; struct list_head rdllist ; struct rb_root rbr ; struct epitem * ovflist ; struct user_struct * user ; } ;

struct eppoll_entry { struct list_head llink ; struct epitem * base ; wait_queue_t wait ; wait_queue_head_t * whead ; } ;

struct ep_pqueue { poll_table pt ; struct epitem * epi ; } ;

struct ep_send_events_data { int maxevents ; struct epoll_event * events ; } ;

void eventpoll_release_file ( struct file * file ) ;

long sys_epoll_create1 ( int flags ) ;

long sys_epoll_create ( int size ) ;

long sys_epoll_ctl ( int epfd , int op , int fd , struct epoll_event * event ) ;

long sys_epoll_wait ( int epfd , struct epoll_event * events , int maxevents , int timeout ) ;

long sys_epoll_pwait ( int epfd , struct epoll_event * events , int maxevents , int timeout , const sigset_t * sigmask , size_t sigsetsize ) ;

struct file * anon_inode_getfile ( const char * name , const struct file_operations * fops , void * priv , int flags ) ;

int anon_inode_getfd ( const char * name , const struct file_operations * fops , void * priv , int flags ) ;

struct signalfd_ctx { sigset_t sigmask ; } ;

long sys_signalfd4 ( int ufd , sigset_t * user_mask , size_t sizemask , int flags ) ;

long sys_signalfd ( int ufd , sigset_t * user_mask , size_t sizemask ) ;

struct timerfd_ctx { struct hrtimer tmr ; ktime_t tintv ; wait_queue_head_t wqh ; u64 ticks ; int expired ; int clockid ; } ;

long sys_timerfd_create ( int clockid , int flags ) ;

long sys_timerfd_settime ( int ufd , int flags , const struct itimerspec * utmr , struct itimerspec * otmr ) ;

long sys_timerfd_gettime ( int ufd , struct itimerspec * otmr ) ;

struct eventfd_ctx { struct kref kref ; wait_queue_head_t wqh ; __u64 count ; unsigned int flags ; } ;

int eventfd_signal ( struct eventfd_ctx * ctx , int n ) ;

struct eventfd_ctx * eventfd_ctx_get ( struct eventfd_ctx * ctx ) ;

void eventfd_ctx_put ( struct eventfd_ctx * ctx ) ;

struct file * eventfd_fget ( int fd ) ;

struct eventfd_ctx * eventfd_ctx_fdget ( int fd ) ;

struct eventfd_ctx * eventfd_ctx_fileget ( struct file * file ) ;

struct file * eventfd_file_create ( unsigned int count , int flags ) ;

long sys_eventfd2 ( unsigned int count , int flags ) ;

long sys_eventfd ( unsigned int count ) ;

ssize_t wait_on_sync_kiocb ( struct kiocb * iocb ) ;

void exit_aio ( struct mm_struct * mm ) ;

int aio_put_req ( struct kiocb * req ) ;

void kick_iocb ( struct kiocb * iocb ) ;

int aio_complete ( struct kiocb * iocb , long res , long res2 ) ;

struct aio_timeout { struct timer_list timer ; int timed_out ; struct task_struct * p ; } ;

long sys_io_setup ( unsigned nr_events , aio_context_t * ctxp ) ;

long sys_io_destroy ( aio_context_t ctx ) ;

long sys_io_submit ( aio_context_t ctx_id , long nr , struct iocb * * iocbpp ) ;

long sys_io_cancel ( aio_context_t ctx_id , struct iocb * iocb , struct io_event * result ) ;

long sys_io_getevents ( aio_context_t ctx_id , long min_nr , long nr , struct io_event * events , struct timespec * timeout ) ;

void locks_release_private ( struct file_lock * fl ) ;

void locks_init_lock ( struct file_lock * fl ) ;

void __locks_copy_lock ( struct file_lock * new , const struct file_lock * fl ) ;

void locks_copy_lock ( struct file_lock * new , struct file_lock * fl ) ;

void posix_test_lock ( struct file * filp , struct file_lock * fl ) ;

int posix_lock_file ( struct file * filp , struct file_lock * fl , struct file_lock * conflock ) ;

int posix_lock_file_wait ( struct file * filp , struct file_lock * fl ) ;

int locks_mandatory_locked ( struct inode * inode ) ;

int locks_mandatory_area ( int read_write , struct inode * inode , struct file * filp , loff_t offset , size_t count ) ;

int lease_modify ( struct file_lock * * before , int arg ) ;

int __break_lease ( struct inode * inode , unsigned int mode ) ;

void lease_get_mtime ( struct inode * inode , struct timespec * time ) ;

int fcntl_getlease ( struct file * filp ) ;

int generic_setlease ( struct file * filp , long arg , struct file_lock * * flp ) ;

int vfs_setlease ( struct file * filp , long arg , struct file_lock * * lease ) ;

int fcntl_setlease ( unsigned int fd , struct file * filp , long arg ) ;

int flock_lock_file_wait ( struct file * filp , struct file_lock * fl ) ;

long sys_flock ( unsigned int fd , unsigned int cmd ) ;

int vfs_test_lock ( struct file * filp , struct file_lock * fl ) ;

int fcntl_getlk ( struct file * filp , struct flock * l ) ;

int vfs_lock_file ( struct file * filp , unsigned int cmd , struct file_lock * fl , struct file_lock * conf ) ;

int fcntl_setlk ( unsigned int fd , struct file * filp , unsigned int cmd , struct flock * l ) ;

void locks_remove_posix ( struct file * filp , fl_owner_t owner ) ;

void locks_remove_flock ( struct file * filp ) ;

int posix_unblock_lock ( struct file * filp , struct file_lock * waiter ) ;

int vfs_cancel_lock ( struct file * filp , struct file_lock * fl ) ;

int lock_may_read ( struct inode * inode , loff_t start , unsigned long len ) ;

int lock_may_write ( struct inode * inode , loff_t start , unsigned long len ) ;

enum smb_protocol { SMB_PROTOCOL_NONE , SMB_PROTOCOL_CORE , SMB_PROTOCOL_COREPLUS , SMB_PROTOCOL_LANMAN1 , SMB_PROTOCOL_LANMAN2 , SMB_PROTOCOL_NT1 } ;

enum smb_case_hndl { SMB_CASE_DEFAULT , SMB_CASE_LOWER , SMB_CASE_UPPER } ;

struct smb_dskattr { __u16 total ; __u16 allocblocks ; __u16 blocksize ; __u16 free ; } ;

struct smb_conn_opt { unsigned int fd ; enum smb_protocol protocol ; enum smb_case_hndl case_handling ; __u32 max_xmit ; __u16 server_uid ; __u16 tid ; __u16 secmode ; __u16 maxmux ; __u16 maxvcs ; __u16 rawmode ; __u32 sesskey ; __u32 maxraw ; __u32 capabilities ; __s16 serverzone ; } ;

struct smb_nls_codepage { char local_name [ 20 ] ; char remote_name [ 20 ] ; } ;

struct smb_fattr { __u16 attr ; unsigned long f_ino ; umode_t f_mode ; nlink_t f_nlink ; uid_t f_uid ; gid_t f_gid ; dev_t f_rdev ; loff_t f_size ; struct timespec f_atime ; struct timespec f_mtime ; struct timespec f_ctime ; unsigned long f_blocks ; int f_unix ; } ;

enum smb_conn_state { CONN_VALID , CONN_INVALID , CONN_RETRIED , CONN_RETRYING } ;

struct smb_mount_data { int version ; __kernel_uid_t mounted_uid ; __kernel_uid_t uid ; __kernel_gid_t gid ; __kernel_mode_t file_mode ; __kernel_mode_t dir_mode ; } ;

struct smb_mount_data_kernel { int version ; uid_t mounted_uid ; uid_t uid ; gid_t gid ; mode_t file_mode ; mode_t dir_mode ; u32 flags ; int ttl ; struct smb_nls_codepage codepage ; } ;

struct ncp_request_header { __u16 type ; __u8 sequence ; __u8 conn_low ; __u8 task ; __u8 conn_high ; __u8 function ; __u8 data [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct ncp_reply_header { __u16 type ; __u8 sequence ; __u8 conn_low ; __u8 task ; __u8 conn_high ; __u8 completion_code ; __u8 connection_state ; __u8 data [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct ncp_volume_info { __u32 total_blocks ; __u32 free_blocks ; __u32 purgeable_blocks ; __u32 not_yet_purgeable_blocks ; __u32 total_dir_entries ; __u32 available_dir_entries ; __u8 sectors_per_block ; char volume_name [ ( 16 ) + 1 ] ; } ;

struct nw_nfs_info { __u32 mode ; __u32 rdev ; } ;

struct nw_info_struct { __u32 spaceAlloc ; __le32 attributes ; __u16 flags ; __le32 dataStreamSize ; __le32 totalStreamSize ; __u16 numberOfStreams ; __le16 creationTime ; __le16 creationDate ; __u32 creatorID ; __le16 modifyTime ; __le16 modifyDate ; __u32 modifierID ; __le16 lastAccessDate ; __u16 archiveTime ; __u16 archiveDate ; __u32 archiverID ; __u16 inheritedRightsMask ; __le32 dirEntNum ; __le32 DosDirNum ; __u32 volNumber ; __u32 EADataSize ; __u32 EAKeyCount ; __u32 EAKeySize ; __u32 NSCreator ; __u8 nameLen ; __u8 entryName [ 256 ] ; struct nw_nfs_info nfs ; } __attribute__ ( ( packed ) ) ;
struct nw_modify_dos_info { __le32 attributes ; __le16 creationDate ; __le16 creationTime ; __u32 creatorID ; __le16 modifyDate ; __le16 modifyTime ; __u32 modifierID ; __u16 archiveDate ; __u16 archiveTime ; __u32 archiverID ; __le16 lastAccessDate ; __u16 inheritanceGrantMask ; __u16 inheritanceRevokeMask ; __u32 maximumSpace ; } __attribute__ ( ( packed ) ) ;
struct nw_search_sequence { __u8 volNumber ; __u32 dirBase ; __u32 sequence ; } __attribute__ ( ( packed ) ) ;
struct ncp_mount_data { int version ; unsigned int ncp_fd ; __kernel_uid_t mounted_uid ; __kernel_pid_t wdog_pid ; unsigned char mounted_vol [ ( 16 ) + 1 ] ; unsigned int time_out ; unsigned int retry_count ; unsigned int flags ; __kernel_uid_t uid ; __kernel_gid_t gid ; __kernel_mode_t file_mode ; __kernel_mode_t dir_mode ; } ;

struct ncp_mount_data_v4 { int version ; unsigned long flags ; unsigned long mounted_uid ; long wdog_pid ; unsigned int ncp_fd ; unsigned int time_out ; unsigned int retry_count ; unsigned long uid ; unsigned long gid ; unsigned long file_mode ; unsigned long dir_mode ; } ;

struct ncp_mount_data_kernel { unsigned long flags ; unsigned int int_flags ; __kernel_uid32_t mounted_uid ; struct pid * wdog_pid ; unsigned int ncp_fd ; unsigned int time_out ; unsigned int retry_count ; unsigned char mounted_vol [ ( 16 ) + 1 ] ; __kernel_uid32_t uid ; __kernel_gid32_t gid ; __kernel_mode_t file_mode ; __kernel_mode_t dir_mode ; int info_fd ; } ;

struct nfs_string { unsigned int len ; const char * data ; } ;

struct nfs4_mount_data { int version ; int flags ; int rsize ; int wsize ; int timeo ; int retrans ; int acregmin ; int acregmax ; int acdirmin ; int acdirmax ; struct nfs_string client_addr ; struct nfs_string mnt_path ; struct nfs_string hostname ; unsigned int host_addrlen ; struct sockaddr * host_addr ; int proto ; int auth_flavourlen ; int * auth_flavours ; } ;

int compat_printk ( const char * fmt , ... ) ;

long compat_sys_utime ( char * filename , struct compat_utimbuf * t ) ;

long compat_sys_utimensat ( unsigned int dfd , char * filename , struct compat_timespec * t , int flags ) ;

long compat_sys_futimesat ( unsigned int dfd , char * filename , struct compat_timeval * t ) ;

long compat_sys_utimes ( char * filename , struct compat_timeval * t ) ;

long compat_sys_newstat ( char * filename , struct compat_stat * statbuf ) ;

long compat_sys_newlstat ( char * filename , struct compat_stat * statbuf ) ;

long compat_sys_newfstatat ( unsigned int dfd , char * filename , struct compat_stat * statbuf , int flag ) ;

long compat_sys_newfstat ( unsigned int fd , struct compat_stat * statbuf ) ;

long compat_sys_statfs ( const char * pathname , struct compat_statfs * buf ) ;

long compat_sys_fstatfs ( unsigned int fd , struct compat_statfs * buf ) ;

long compat_sys_statfs64 ( const char * pathname , compat_size_t sz , struct compat_statfs64 * buf ) ;

long compat_sys_fstatfs64 ( unsigned int fd , compat_size_t sz , struct compat_statfs64 * buf ) ;

long compat_sys_ustat ( unsigned dev , struct compat_ustat * u ) ;

long compat_sys_fcntl64 ( unsigned int fd , unsigned int cmd , unsigned long arg ) ;

long compat_sys_fcntl ( unsigned int fd , unsigned int cmd , unsigned long arg ) ;

long compat_sys_io_setup ( unsigned nr_reqs , u32 * ctx32p ) ;

long compat_sys_io_getevents ( aio_context_t ctx_id , unsigned long min_nr , unsigned long nr , struct io_event * events , struct compat_timespec * timeout ) ;

long compat_sys_io_submit ( aio_context_t ctx_id , int nr , u32 * iocb ) ;

struct compat_ncp_mount_data { compat_int_t version ; compat_uint_t ncp_fd ; __compat_uid_t mounted_uid ; compat_pid_t wdog_pid ; unsigned char mounted_vol [ ( 16 ) + 1 ] ; compat_uint_t time_out ; compat_uint_t retry_count ; compat_uint_t flags ; __compat_uid_t uid ; __compat_gid_t gid ; compat_mode_t file_mode ; compat_mode_t dir_mode ; } ;

struct compat_ncp_mount_data_v4 { compat_int_t version ; compat_ulong_t flags ; compat_ulong_t mounted_uid ; compat_long_t wdog_pid ; compat_uint_t ncp_fd ; compat_uint_t time_out ; compat_uint_t retry_count ; compat_ulong_t uid ; compat_ulong_t gid ; compat_ulong_t file_mode ; compat_ulong_t dir_mode ; } ;

struct compat_smb_mount_data { compat_int_t version ; __compat_uid_t mounted_uid ; __compat_uid_t uid ; __compat_gid_t gid ; compat_mode_t file_mode ; compat_mode_t dir_mode ; } ;

struct compat_nfs_string { compat_uint_t len ; compat_uptr_t data ; } ;

struct compat_nfs4_mount_data_v1 { compat_int_t version ; compat_int_t flags ; compat_int_t rsize ; compat_int_t wsize ; compat_int_t timeo ; compat_int_t retrans ; compat_int_t acregmin ; compat_int_t acregmax ; compat_int_t acdirmin ; compat_int_t acdirmax ; struct compat_nfs_string client_addr ; struct compat_nfs_string mnt_path ; struct compat_nfs_string hostname ; compat_uint_t host_addrlen ; compat_uptr_t host_addr ; compat_int_t proto ; compat_int_t auth_flavourlen ; compat_uptr_t auth_flavours ; } ;

long compat_sys_mount ( char * dev_name , char * dir_name , char * type , unsigned long flags , void * data ) ;

struct compat_old_linux_dirent { compat_ulong_t d_ino ; compat_ulong_t d_offset ; unsigned short d_namlen ; char d_name [ 1 ] ; } ;

struct compat_readdir_callback { struct compat_old_linux_dirent * dirent ; int result ; } ;

long compat_sys_old_readdir ( unsigned int fd , struct compat_old_linux_dirent * dirent , unsigned int count ) ;

struct compat_linux_dirent { compat_ulong_t d_ino ; compat_ulong_t d_off ; unsigned short d_reclen ; char d_name [ 1 ] ; } ;

struct compat_getdents_callback { struct compat_linux_dirent * current_dir ; struct compat_linux_dirent * previous ; int count ; int error ; } ;

long compat_sys_getdents ( unsigned int fd , struct compat_linux_dirent * dirent , unsigned int count ) ;

struct compat_getdents_callback64 { struct linux_dirent64 * current_dir ; struct linux_dirent64 * previous ; int count ; int error ; } ;

long compat_sys_getdents64 ( unsigned int fd , struct linux_dirent64 * dirent , unsigned int count ) ;

ssize_t compat_sys_readv ( unsigned long fd , const struct compat_iovec * vec , unsigned long vlen ) ;

ssize_t compat_sys_preadv ( unsigned long fd , const struct compat_iovec * vec , unsigned long vlen , u32 pos_low , u32 pos_high ) ;

ssize_t compat_sys_writev ( unsigned long fd , const struct compat_iovec * vec , unsigned long vlen ) ;

ssize_t compat_sys_pwritev ( unsigned long fd , const struct compat_iovec * vec , unsigned long vlen , u32 pos_low , u32 pos_high ) ;

long compat_sys_vmsplice ( int fd , const struct compat_iovec * iov32 , unsigned int nr_segs , unsigned int flags ) ;

long compat_sys_open ( const char * filename , int flags , int mode ) ;

long compat_sys_openat ( unsigned int dfd , const char * filename , int flags , int mode ) ;

int compat_do_execve ( char * filename , compat_uptr_t * argv , compat_uptr_t * envp , struct pt_regs * regs ) ;

int compat_core_sys_select ( int n , compat_ulong_t * inp , compat_ulong_t * outp , compat_ulong_t * exp , struct timespec * end_time ) ;

long compat_sys_select ( int n , compat_ulong_t * inp , compat_ulong_t * outp , compat_ulong_t * exp , struct compat_timeval * tvp ) ;

long compat_sys_pselect6 ( int n , compat_ulong_t * inp , compat_ulong_t * outp , compat_ulong_t * exp , struct compat_timespec * tsp , void * sig ) ;

long compat_sys_ppoll ( struct pollfd * ufds , unsigned int nfds , struct compat_timespec * tsp , const compat_sigset_t * sigmask , compat_size_t sigsetsize ) ;

struct compat_nfsctl_svc { u16 svc32_port ; s32 svc32_nthreads ; } ;

struct compat_nfsctl_client { s8 cl32_ident [ 1024 + 1 ] ; s32 cl32_naddr ; struct in_addr cl32_addrlist [ 16 ] ; s32 cl32_fhkeytype ; s32 cl32_fhkeylen ; u8 cl32_fhkey [ 32 ] ; } ;

struct compat_nfsctl_export { char ex32_client [ 1024 + 1 ] ; char ex32_path [ 1024 + 1 ] ; compat_dev_t ex32_dev ; compat_ino_t ex32_ino ; compat_int_t ex32_flags ; __compat_uid_t ex32_anon_uid ; __compat_gid_t ex32_anon_gid ; } ;

struct compat_nfsctl_fdparm { struct sockaddr gd32_addr ; s8 gd32_path [ 1024 + 1 ] ; compat_int_t gd32_version ; } ;

struct compat_nfsctl_fsparm { struct sockaddr gd32_addr ; s8 gd32_path [ 1024 + 1 ] ; compat_int_t gd32_maxlen ; } ;

struct compat_nfsctl_arg { compat_int_t ca32_version ; union { struct compat_nfsctl_svc u32_svc ; struct compat_nfsctl_client u32_client ; struct compat_nfsctl_export u32_export ; struct compat_nfsctl_fdparm u32_getfd ; struct compat_nfsctl_fsparm u32_getfs ; } u ; } ;

union compat_nfsctl_res { __u8 cr32_getfh [ 32 ] ; struct knfsd_fh cr32_getfs ; } ;

long compat_sys_nfsservctl ( int cmd , struct compat_nfsctl_arg * arg , union compat_nfsctl_res * res ) ;

long compat_sys_epoll_pwait ( int epfd , struct epoll_event * events , int maxevents , int timeout , const compat_sigset_t * sigmask , compat_size_t sigsetsize ) ;

long compat_sys_signalfd4 ( int ufd , const compat_sigset_t * sigmask , compat_size_t sigsetsize , int flags ) ;

long compat_sys_signalfd ( int ufd , const compat_sigset_t * sigmask , compat_size_t sigsetsize ) ;

long compat_sys_timerfd_settime ( int ufd , int flags , const struct compat_itimerspec * utmr , struct compat_itimerspec * otmr ) ;

long compat_sys_timerfd_gettime ( int ufd , struct compat_itimerspec * otmr ) ;

struct input_event { struct timeval time ; __u16 type ; __u16 code ; __s32 value ; } ;

struct input_id { __u16 bustype ; __u16 vendor ; __u16 product ; __u16 version ; } ;

struct input_absinfo { __s32 value ; __s32 minimum ; __s32 maximum ; __s32 fuzz ; __s32 flat ; __s32 resolution ; } ;

struct ff_replay { __u16 length ; __u16 delay ; } ;

struct ff_trigger { __u16 button ; __u16 interval ; } ;

struct ff_envelope { __u16 attack_length ; __u16 attack_level ; __u16 fade_length ; __u16 fade_level ; } ;

struct ff_constant_effect { __s16 level ; struct ff_envelope envelope ; } ;

struct ff_ramp_effect { __s16 start_level ; __s16 end_level ; struct ff_envelope envelope ; } ;

struct ff_condition_effect { __u16 right_saturation ; __u16 left_saturation ; __s16 right_coeff ; __s16 left_coeff ; __u16 deadband ; __s16 center ; } ;

struct ff_periodic_effect { __u16 waveform ; __u16 period ; __s16 magnitude ; __s16 offset ; __u16 phase ; struct ff_envelope envelope ; __u32 custom_len ; __s16 * custom_data ; } ;

struct ff_rumble_effect { __u16 strong_magnitude ; __u16 weak_magnitude ; } ;

struct ff_effect { __u16 type ; __s16 id ; __u16 direction ; struct ff_trigger trigger ; struct ff_replay replay ; union { struct ff_constant_effect constant ; struct ff_ramp_effect ramp ; struct ff_periodic_effect periodic ; struct ff_condition_effect condition [ 2 ] ; struct ff_rumble_effect rumble ; } u ; } ;

struct input_dev { const char * name ; const char * phys ; const char * uniq ; struct input_id id ; unsigned long evbit [ ( ( ( ( 0x1f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long keybit [ ( ( ( ( 0x2ff + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long relbit [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long absbit [ ( ( ( ( 0x3f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long mscbit [ ( ( ( ( 0x07 + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long ledbit [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long sndbit [ ( ( ( ( 0x07 + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long ffbit [ ( ( ( ( 0x7f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long swbit [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned int keycodemax ; unsigned int keycodesize ; void * keycode ; int ( * setkeycode ) ( struct input_dev * dev , int scancode , int keycode ) ; int ( * getkeycode ) ( struct input_dev * dev , int scancode , int * keycode ) ; struct ff_device * ff ; unsigned int repeat_key ; struct timer_list timer ; int sync ; int abs [ 0x3f + 1 ] ; int rep [ 0x01 + 1 ] ; unsigned long key [ ( ( ( ( 0x2ff + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long led [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long snd [ ( ( ( ( 0x07 + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned long sw [ ( ( ( ( 0x0f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; int absmax [ 0x3f + 1 ] ; int absmin [ 0x3f + 1 ] ; int absfuzz [ 0x3f + 1 ] ; int absflat [ 0x3f + 1 ] ; int absres [ 0x3f + 1 ] ; int ( * open ) ( struct input_dev * dev ) ; void ( * close ) ( struct input_dev * dev ) ; int ( * flush ) ( struct input_dev * dev , struct file * file ) ; int ( * event ) ( struct input_dev * dev , unsigned int type , unsigned int code , int value ) ; struct input_handle * grab ; struct input_handle * filter ; spinlock_t event_lock ; struct mutex mutex ; unsigned int users ; bool going_away ; struct device dev ; struct list_head h_list ; struct list_head node ; } ;

struct input_handle ;

struct input_handler { void * private ; void ( * event ) ( struct input_handle * handle , unsigned int type , unsigned int code , int value ) ; bool ( * filter ) ( struct input_handle * handle , unsigned int type , unsigned int code , int value ) ; int ( * connect ) ( struct input_handler * handler , struct input_dev * dev , const struct input_device_id * id ) ; void ( * disconnect ) ( struct input_handle * handle ) ; void ( * start ) ( struct input_handle * handle ) ; const struct file_operations * fops ; int minor ; const char * name ; const struct input_device_id * id_table ; const struct input_device_id * blacklist ; struct list_head h_list ; struct list_head node ; } ;

struct input_handle { void * private ; int open ; const char * name ; struct input_dev * dev ; struct input_handler * handler ; struct list_head d_node ; struct list_head h_node ; } ;
struct ff_device { int ( * upload ) ( struct input_dev * dev , struct ff_effect * effect , struct ff_effect * old ) ; int ( * erase ) ( struct input_dev * dev , int effect_id ) ; int ( * playback ) ( struct input_dev * dev , int effect_id , int value ) ; void ( * set_gain ) ( struct input_dev * dev , u16 gain ) ; void ( * set_autocenter ) ( struct input_dev * dev , u16 magnitude ) ; void ( * destroy ) ( struct ff_device * ) ; void * private ; unsigned long ffbit [ ( ( ( ( 0x7f + 1 ) ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; struct mutex mutex ; int max_effects ; struct ff_effect * effects ; struct file * effect_owners [ ] ; } ;

struct js_event { __u32 time ; __s16 value ; __u8 type ; __u8 number ; } ;

struct js_corr { __s32 coef [ 8 ] ; __s16 prec ; __u16 type ; } ;

struct JS_DATA_TYPE { __s32 buttons ; __s32 x ; __s32 y ; } ;

struct JS_DATA_SAVE_TYPE_32 { __s32 JS_TIMEOUT ; __s32 BUSY ; __s32 JS_EXPIRETIME ; __s32 JS_TIMELIMIT ; struct JS_DATA_TYPE JS_SAVE ; struct JS_DATA_TYPE JS_CORR ; } ;

struct JS_DATA_SAVE_TYPE_64 { __s32 JS_TIMEOUT ; __s32 BUSY ; __s64 JS_EXPIRETIME ; __s64 JS_TIMELIMIT ; struct JS_DATA_TYPE JS_SAVE ; struct JS_DATA_TYPE JS_CORR ; } ;

struct __bridge_info { __u64 designated_root ; __u64 bridge_id ; __u32 root_path_cost ; __u32 max_age ; __u32 hello_time ; __u32 forward_delay ; __u32 bridge_max_age ; __u32 bridge_hello_time ; __u32 bridge_forward_delay ; __u8 topology_change ; __u8 topology_change_detected ; __u8 root_port ; __u8 stp_enabled ; __u32 ageing_time ; __u32 gc_interval ; __u32 hello_timer_value ; __u32 tcn_timer_value ; __u32 topology_change_timer_value ; __u32 gc_timer_value ; } ;

struct __port_info { __u64 designated_root ; __u64 designated_bridge ; __u16 port_id ; __u16 designated_port ; __u32 path_cost ; __u32 designated_cost ; __u8 state ; __u8 top_change_ack ; __u8 config_pending ; __u8 unused0 ; __u32 message_age_timer_value ; __u32 forward_delay_timer_value ; __u32 hold_timer_value ; } ;

struct __fdb_entry { __u8 mac_addr [ 6 ] ; __u8 port_no ; __u8 is_local ; __u32 ageing_timer_value ; __u8 port_hi ; __u8 pad0 ; __u16 unused ; } ;

struct rtentry { unsigned long rt_pad1 ; struct sockaddr rt_dst ; struct sockaddr rt_gateway ; struct sockaddr rt_genmask ; unsigned short rt_flags ; short rt_pad2 ; unsigned long rt_pad3 ; void * rt_pad4 ; short rt_metric ; char * rt_dev ; unsigned long rt_mtu ; unsigned long rt_window ; unsigned short rt_irtt ; } ;

struct in6_rtmsg { struct in6_addr rtmsg_dst ; struct in6_addr rtmsg_src ; struct in6_addr rtmsg_gateway ; __u32 rtmsg_type ; __u16 rtmsg_dst_len ; __u16 rtmsg_src_len ; __u32 rtmsg_metric ; unsigned long rtmsg_info ; __u32 rtmsg_flags ; int rtmsg_ifindex ; } ;

typedef __u32 ext_accm [ 8 ] ;
enum NPmode { NPMODE_PASS , NPMODE_DROP , NPMODE_ERROR , NPMODE_QUEUE } ;

struct pppstat { __u32 ppp_discards ; __u32 ppp_ibytes ; __u32 ppp_ioctects ; __u32 ppp_ipackets ; __u32 ppp_ierrors ; __u32 ppp_ilqrs ; __u32 ppp_obytes ; __u32 ppp_ooctects ; __u32 ppp_opackets ; __u32 ppp_oerrors ; __u32 ppp_olqrs ; } ;

struct vjstat { __u32 vjs_packets ; __u32 vjs_compressed ; __u32 vjs_searches ; __u32 vjs_misses ; __u32 vjs_uncompressedin ; __u32 vjs_compressedin ; __u32 vjs_errorin ; __u32 vjs_tossed ; } ;

struct compstat { __u32 unc_bytes ; __u32 unc_packets ; __u32 comp_bytes ; __u32 comp_packets ; __u32 inc_bytes ; __u32 inc_packets ; __u32 in_count ; __u32 bytes_out ; double ratio ; } ;

struct ppp_stats { struct pppstat p ; struct vjstat vj ; } ;

struct ppp_comp_stats { struct compstat c ; struct compstat d ; } ;

struct ppp_idle { __kernel_time_t xmit_idle ; __kernel_time_t recv_idle ; } ;

struct npioctl { int protocol ; enum NPmode mode ; } ;

struct ppp_option_data { __u8 * ptr ; __u32 length ; int transmit ; } ;

struct ifpppstatsreq { struct ifreq b ; struct ppp_stats stats ; } ;

struct ifpppcstatsreq { struct ifreq b ; struct ppp_comp_stats stats ; } ;

struct pppol2tp_ioc_stats { __u16 tunnel_id ; __u16 session_id ; __u32 using_ipsec : 1 ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) tx_packets ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) tx_bytes ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) tx_errors ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) rx_packets ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) rx_bytes ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) rx_seq_discards ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) rx_oos_packets ; __u64 __attribute__ ( ( aligned ( 8 ) ) ) rx_errors ; } ;

struct ppp_channel ;

struct ppp_channel_ops { int ( * start_xmit ) ( struct ppp_channel * , struct sk_buff * ) ; int ( * ioctl ) ( struct ppp_channel * , unsigned int , unsigned long ) ; } ;

struct ppp_channel { void * private ; struct ppp_channel_ops * ops ; int mtu ; int hdrlen ; void * ppp ; int speed ; int latency ; } ;
struct pppol2tp_addr { __kernel_pid_t pid ; int fd ; struct sockaddr_in addr ; __u16 s_tunnel , s_session ; __u16 d_tunnel , d_session ; } ;

enum { PPPOL2TP_SO_DEBUG = 1 , PPPOL2TP_SO_RECVSEQ = 2 , PPPOL2TP_SO_SENDSEQ = 3 , PPPOL2TP_SO_LNSMODE = 4 , PPPOL2TP_SO_REORDERTO = 5 , } ;
enum { PPPOL2TP_MSG_DEBUG = ( 1 << 0 ) , PPPOL2TP_MSG_CONTROL = ( 1 << 1 ) , PPPOL2TP_MSG_SEQ = ( 1 << 2 ) , PPPOL2TP_MSG_DATA = ( 1 << 3 ) , } ;
typedef __be16 sid_t ;

struct pppoe_addr { sid_t sid ; unsigned char remote [ 6 ] ; char dev [ 16 ] ; } ;

struct sockaddr_pppox { sa_family_t sa_family ; unsigned int sa_protocol ; union { struct pppoe_addr pppoe ; } sa_addr ; } __attribute__ ( ( packed ) ) ;
struct sockaddr_pppol2tp { sa_family_t sa_family ; unsigned int sa_protocol ; struct pppol2tp_addr pppol2tp ; } __attribute__ ( ( packed ) ) ;
struct pppoe_tag { __be16 tag_type ; __be16 tag_len ; char tag_data [ 0 ] ; } __attribute ( ( packed ) ) ;
struct pppoe_hdr { __u8 ver : 4 ; __u8 type : 4 ; __u8 code ; __be16 sid ; __be16 length ; struct pppoe_tag tag [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct pppoe_opt { struct net_device * dev ; int ifindex ; struct pppoe_addr pa ; struct sockaddr_pppox relay ; } ;

struct pppox_sock { struct sock sk ; struct ppp_channel chan ; struct pppox_sock * next ; union { struct pppoe_opt pppoe ; } proto ; __be16 num ; } ;

struct pppox_proto { int ( * create ) ( struct net * net , struct socket * sock ) ; int ( * ioctl ) ( struct socket * sock , unsigned int cmd , unsigned long arg ) ; struct module * owner ; } ;

enum { PPPOX_NONE = 0 , PPPOX_CONNECTED = 1 , PPPOX_BOUND = 2 , PPPOX_RELAY = 4 , PPPOX_ZOMBIE = 8 , PPPOX_DEAD = 16 } ;
struct mtop { short mt_op ; int mt_count ; } ;

struct mtget { long mt_type ; long mt_resid ; long mt_dsreg ; long mt_gstat ; long mt_erreg ; __kernel_daddr_t mt_fileno ; __kernel_daddr_t mt_blkno ; } ;

struct mtpos { long mt_blkno ; } ;

typedef unsigned int autofs_wqt_t ;

struct autofs_packet_hdr { int proto_version ; int type ; } ;

struct autofs_packet_missing { struct autofs_packet_hdr hdr ; autofs_wqt_t wait_queue_token ; int len ; char name [ 255 + 1 ] ; } ;

struct autofs_packet_expire { struct autofs_packet_hdr hdr ; int len ; char name [ 255 + 1 ] ; } ;

enum autofs_notify { NFY_NONE , NFY_MOUNT , NFY_EXPIRE } ;

struct autofs_packet_expire_multi { struct autofs_packet_hdr hdr ; autofs_wqt_t wait_queue_token ; int len ; char name [ 255 + 1 ] ; } ;

union autofs_packet_union { struct autofs_packet_hdr hdr ; struct autofs_packet_missing missing ; struct autofs_packet_expire expire ; struct autofs_packet_expire_multi expire_multi ; } ;

struct autofs_v5_packet { struct autofs_packet_hdr hdr ; autofs_wqt_t wait_queue_token ; __u32 dev ; __u64 ino ; __u32 uid ; __u32 gid ; __u32 pid ; __u32 tgid ; __u32 len ; char name [ 255 + 1 ] ; } ;

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t ;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t ;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t ;

typedef struct autofs_v5_packet autofs_packet_expire_direct_t ;

union autofs_v5_packet_union { struct autofs_packet_hdr hdr ; struct autofs_v5_packet v5_packet ; autofs_packet_missing_indirect_t missing_indirect ; autofs_packet_expire_indirect_t expire_indirect ; autofs_packet_missing_direct_t missing_direct ; autofs_packet_expire_direct_t expire_direct ; } ;

struct i2c_msg ;

struct i2c_algorithm ;

struct i2c_adapter ;

struct i2c_client ;

struct i2c_driver ;

union i2c_smbus_data ;

struct i2c_board_info ;

struct i2c_driver { unsigned int class ; int ( * attach_adapter ) ( struct i2c_adapter * ) ; int ( * detach_adapter ) ( struct i2c_adapter * ) ; int ( * probe ) ( struct i2c_client * , const struct i2c_device_id * ) ; int ( * remove ) ( struct i2c_client * ) ; void ( * shutdown ) ( struct i2c_client * ) ; int ( * suspend ) ( struct i2c_client * , pm_message_t mesg ) ; int ( * resume ) ( struct i2c_client * ) ; int ( * command ) ( struct i2c_client * client , unsigned int cmd , void * arg ) ; struct device_driver driver ; const struct i2c_device_id * id_table ; int ( * detect ) ( struct i2c_client * , int kind , struct i2c_board_info * ) ; const struct i2c_client_address_data * address_data ; struct list_head clients ; } ;
struct i2c_client { unsigned short flags ; unsigned short addr ; char name [ 20 ] ; struct i2c_adapter * adapter ; struct i2c_driver * driver ; struct device dev ; int irq ; struct list_head detected ; } ;
struct i2c_board_info { char type [ 20 ] ; unsigned short flags ; unsigned short addr ; void * platform_data ; struct dev_archdata * archdata ; int irq ; } ;
struct i2c_algorithm { int ( * master_xfer ) ( struct i2c_adapter * adap , struct i2c_msg * msgs , int num ) ; int ( * smbus_xfer ) ( struct i2c_adapter * adap , u16 addr , unsigned short flags , char read_write , u8 command , int size , union i2c_smbus_data * data ) ; u32 ( * functionality ) ( struct i2c_adapter * ) ; } ;
struct i2c_adapter { struct module * owner ; unsigned int id ; unsigned int class ; const struct i2c_algorithm * algo ; void * algo_data ; u8 level ; struct mutex bus_lock ; int timeout ; int retries ; struct device dev ; int nr ; char name [ 48 ] ; struct completion dev_released ; } ;
struct i2c_client_address_data { const unsigned short * normal_i2c ; const unsigned short * probe ; const unsigned short * ignore ; const unsigned short * const * forces ; } ;

struct i2c_msg { __u16 addr ; __u16 flags ; __u16 len ; __u8 * buf ; } ;
union i2c_smbus_data { __u8 byte ; __u16 word ; __u8 block [ 32 + 2 ] ; } ;
struct fb_fix_screeninfo { char id [ 16 ] ; unsigned long smem_start ; __u32 smem_len ; __u32 type ; __u32 type_aux ; __u32 visual ; __u16 xpanstep ; __u16 ypanstep ; __u16 ywrapstep ; __u32 line_length ; unsigned long mmio_start ; __u32 mmio_len ; __u32 accel ; __u16 reserved [ 3 ] ; } ;

struct fb_bitfield { __u32 offset ; __u32 length ; __u32 msb_right ; } ;

struct fb_var_screeninfo { __u32 xres ; __u32 yres ; __u32 xres_virtual ; __u32 yres_virtual ; __u32 xoffset ; __u32 yoffset ; __u32 bits_per_pixel ; __u32 grayscale ; struct fb_bitfield red ; struct fb_bitfield green ; struct fb_bitfield blue ; struct fb_bitfield transp ; __u32 nonstd ; __u32 activate ; __u32 height ; __u32 width ; __u32 accel_flags ; __u32 pixclock ; __u32 left_margin ; __u32 right_margin ; __u32 upper_margin ; __u32 lower_margin ; __u32 hsync_len ; __u32 vsync_len ; __u32 sync ; __u32 vmode ; __u32 rotate ; __u32 reserved [ 5 ] ; } ;

struct fb_cmap { __u32 start ; __u32 len ; __u16 * red ; __u16 * green ; __u16 * blue ; __u16 * transp ; } ;

struct fb_con2fbmap { __u32 console ; __u32 framebuffer ; } ;

enum { FB_BLANK_UNBLANK = 0 , FB_BLANK_NORMAL = 0 + 1 , FB_BLANK_VSYNC_SUSPEND = 1 + 1 , FB_BLANK_HSYNC_SUSPEND = 2 + 1 , FB_BLANK_POWERDOWN = 3 + 1 } ;
struct fb_vblank { __u32 flags ; __u32 count ; __u32 vcount ; __u32 hcount ; __u32 reserved [ 4 ] ; } ;

struct fb_copyarea { __u32 dx ; __u32 dy ; __u32 width ; __u32 height ; __u32 sx ; __u32 sy ; } ;

struct fb_fillrect { __u32 dx ; __u32 dy ; __u32 width ; __u32 height ; __u32 color ; __u32 rop ; } ;

struct fb_image { __u32 dx ; __u32 dy ; __u32 width ; __u32 height ; __u32 fg_color ; __u32 bg_color ; __u8 depth ; const char * data ; struct fb_cmap cmap ; } ;

struct fbcurpos { __u16 x , y ; } ;

struct fb_cursor { __u16 set ; __u16 enable ; __u16 rop ; const char * mask ; struct fbcurpos hot ; struct fb_image image ; } ;

enum backlight_update_reason { BACKLIGHT_UPDATE_HOTKEY , BACKLIGHT_UPDATE_SYSFS , } ;

struct backlight_device ;

struct fb_info ;

struct backlight_ops { unsigned int options ; int ( * update_status ) ( struct backlight_device * ) ; int ( * get_brightness ) ( struct backlight_device * ) ; int ( * check_fb ) ( struct fb_info * ) ; } ;

struct backlight_properties { int brightness ; int max_brightness ; int power ; int fb_blank ; unsigned int state ; } ;

struct backlight_device { struct backlight_properties props ; struct mutex update_lock ; struct mutex ops_lock ; struct backlight_ops * ops ; struct notifier_block fb_notif ; struct device dev ; } ;
struct generic_bl_info { const char * name ; int max_intensity ; int default_intensity ; int limit_mask ; void ( * set_bl_intensity ) ( int intensity ) ; void ( * kick_battery ) ( void ) ; } ;

struct fb_chroma { __u32 redx ; __u32 greenx ; __u32 bluex ; __u32 whitex ; __u32 redy ; __u32 greeny ; __u32 bluey ; __u32 whitey ; } ;

struct fb_monspecs { struct fb_chroma chroma ; struct fb_videomode * modedb ; __u8 manufacturer [ 4 ] ; __u8 monitor [ 14 ] ; __u8 serial_no [ 14 ] ; __u8 ascii [ 14 ] ; __u32 modedb_len ; __u32 model ; __u32 serial ; __u32 year ; __u32 week ; __u32 hfmin ; __u32 hfmax ; __u32 dclkmin ; __u32 dclkmax ; __u16 input ; __u16 dpms ; __u16 signal ; __u16 vfmin ; __u16 vfmax ; __u16 gamma ; __u16 gtf : 1 ; __u16 misc ; __u8 version ; __u8 revision ; __u8 max_x ; __u8 max_y ; } ;

struct fb_cmap_user { __u32 start ; __u32 len ; __u16 * red ; __u16 * green ; __u16 * blue ; __u16 * transp ; } ;

struct fb_image_user { __u32 dx ; __u32 dy ; __u32 width ; __u32 height ; __u32 fg_color ; __u32 bg_color ; __u8 depth ; const char * data ; struct fb_cmap_user cmap ; } ;

struct fb_cursor_user { __u16 set ; __u16 enable ; __u16 rop ; const char * mask ; struct fbcurpos hot ; struct fb_image_user image ; } ;

struct fb_event { struct fb_info * info ; void * data ; } ;

struct fb_blit_caps { u32 x ; u32 y ; u32 len ; u32 flags ; } ;

struct fb_pixmap { u8 * addr ; u32 size ; u32 offset ; u32 buf_align ; u32 scan_align ; u32 access_align ; u32 flags ; u32 blit_x ; u32 blit_y ; void ( * writeio ) ( struct fb_info * info , void * dst , void * src , unsigned int size ) ; void ( * readio ) ( struct fb_info * info , void * dst , void * src , unsigned int size ) ; } ;

struct fb_ops { struct module * owner ; int ( * fb_open ) ( struct fb_info * info , int user ) ; int ( * fb_release ) ( struct fb_info * info , int user ) ; ssize_t ( * fb_read ) ( struct fb_info * info , char * buf , size_t count , loff_t * ppos ) ; ssize_t ( * fb_write ) ( struct fb_info * info , const char * buf , size_t count , loff_t * ppos ) ; int ( * fb_check_var ) ( struct fb_var_screeninfo * var , struct fb_info * info ) ; int ( * fb_set_par ) ( struct fb_info * info ) ; int ( * fb_setcolreg ) ( unsigned regno , unsigned red , unsigned green , unsigned blue , unsigned transp , struct fb_info * info ) ; int ( * fb_setcmap ) ( struct fb_cmap * cmap , struct fb_info * info ) ; int ( * fb_blank ) ( int blank , struct fb_info * info ) ; int ( * fb_pan_display ) ( struct fb_var_screeninfo * var , struct fb_info * info ) ; void ( * fb_fillrect ) ( struct fb_info * info , const struct fb_fillrect * rect ) ; void ( * fb_copyarea ) ( struct fb_info * info , const struct fb_copyarea * region ) ; void ( * fb_imageblit ) ( struct fb_info * info , const struct fb_image * image ) ; int ( * fb_cursor ) ( struct fb_info * info , struct fb_cursor * cursor ) ; void ( * fb_rotate ) ( struct fb_info * info , int angle ) ; int ( * fb_sync ) ( struct fb_info * info ) ; int ( * fb_ioctl ) ( struct fb_info * info , unsigned int cmd , unsigned long arg ) ; int ( * fb_compat_ioctl ) ( struct fb_info * info , unsigned cmd , unsigned long arg ) ; int ( * fb_mmap ) ( struct fb_info * info , struct vm_area_struct * vma ) ; void ( * fb_get_caps ) ( struct fb_info * info , struct fb_blit_caps * caps , struct fb_var_screeninfo * var ) ; void ( * fb_destroy ) ( struct fb_info * info ) ; } ;

struct fb_tilemap { __u32 width ; __u32 height ; __u32 depth ; __u32 length ; const __u8 * data ; } ;

struct fb_tilerect { __u32 sx ; __u32 sy ; __u32 width ; __u32 height ; __u32 index ; __u32 fg ; __u32 bg ; __u32 rop ; } ;

struct fb_tilearea { __u32 sx ; __u32 sy ; __u32 dx ; __u32 dy ; __u32 width ; __u32 height ; } ;

struct fb_tileblit { __u32 sx ; __u32 sy ; __u32 width ; __u32 height ; __u32 fg ; __u32 bg ; __u32 length ; __u32 * indices ; } ;

struct fb_tilecursor { __u32 sx ; __u32 sy ; __u32 mode ; __u32 shape ; __u32 fg ; __u32 bg ; } ;

struct fb_tile_ops { void ( * fb_settile ) ( struct fb_info * info , struct fb_tilemap * map ) ; void ( * fb_tilecopy ) ( struct fb_info * info , struct fb_tilearea * area ) ; void ( * fb_tilefill ) ( struct fb_info * info , struct fb_tilerect * rect ) ; void ( * fb_tileblit ) ( struct fb_info * info , struct fb_tileblit * blit ) ; void ( * fb_tilecursor ) ( struct fb_info * info , struct fb_tilecursor * cursor ) ; int ( * fb_get_tilemax ) ( struct fb_info * info ) ; } ;

struct fb_info { int node ; int flags ; struct mutex lock ; struct mutex mm_lock ; struct fb_var_screeninfo var ; struct fb_fix_screeninfo fix ; struct fb_monspecs monspecs ; struct work_struct queue ; struct fb_pixmap pixmap ; struct fb_pixmap sprite ; struct fb_cmap cmap ; struct list_head modelist ; struct fb_videomode * mode ; struct backlight_device * bl_dev ; struct mutex bl_curve_mutex ; u8 bl_curve [ 128 ] ; struct fb_ops * fbops ; struct device * device ; struct device * dev ; int class_flag ; struct fb_tile_ops * tileops ; char * screen_base ; unsigned long screen_size ; void * pseudo_palette ; u32 state ; void * fbcon_par ; void * par ; resource_size_t aperture_base ; resource_size_t aperture_size ; } ;
struct fb_videomode { const char * name ; u32 refresh ; u32 xres ; u32 yres ; u32 pixclock ; u32 left_margin ; u32 right_margin ; u32 upper_margin ; u32 lower_margin ; u32 hsync_len ; u32 vsync_len ; u32 sync ; u32 vmode ; u32 flag ; } ;

struct fb_modelist { struct list_head list ; struct fb_videomode mode ; } ;

enum v4l2_field { V4L2_FIELD_ANY = 0 , V4L2_FIELD_NONE = 1 , V4L2_FIELD_TOP = 2 , V4L2_FIELD_BOTTOM = 3 , V4L2_FIELD_INTERLACED = 4 , V4L2_FIELD_SEQ_TB = 5 , V4L2_FIELD_SEQ_BT = 6 , V4L2_FIELD_ALTERNATE = 7 , V4L2_FIELD_INTERLACED_TB = 8 , V4L2_FIELD_INTERLACED_BT = 9 , } ;

enum v4l2_buf_type { V4L2_BUF_TYPE_VIDEO_CAPTURE = 1 , V4L2_BUF_TYPE_VIDEO_OUTPUT = 2 , V4L2_BUF_TYPE_VIDEO_OVERLAY = 3 , V4L2_BUF_TYPE_VBI_CAPTURE = 4 , V4L2_BUF_TYPE_VBI_OUTPUT = 5 , V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6 , V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7 , V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8 , V4L2_BUF_TYPE_PRIVATE = 0x80 , } ;

enum v4l2_ctrl_type { V4L2_CTRL_TYPE_INTEGER = 1 , V4L2_CTRL_TYPE_BOOLEAN = 2 , V4L2_CTRL_TYPE_MENU = 3 , V4L2_CTRL_TYPE_BUTTON = 4 , V4L2_CTRL_TYPE_INTEGER64 = 5 , V4L2_CTRL_TYPE_CTRL_CLASS = 6 , V4L2_CTRL_TYPE_STRING = 7 , } ;

enum v4l2_tuner_type { V4L2_TUNER_RADIO = 1 , V4L2_TUNER_ANALOG_TV = 2 , V4L2_TUNER_DIGITAL_TV = 3 , } ;

enum v4l2_memory { V4L2_MEMORY_MMAP = 1 , V4L2_MEMORY_USERPTR = 2 , V4L2_MEMORY_OVERLAY = 3 , } ;

enum v4l2_colorspace { V4L2_COLORSPACE_SMPTE170M = 1 , V4L2_COLORSPACE_SMPTE240M = 2 , V4L2_COLORSPACE_REC709 = 3 , V4L2_COLORSPACE_BT878 = 4 , V4L2_COLORSPACE_470_SYSTEM_M = 5 , V4L2_COLORSPACE_470_SYSTEM_BG = 6 , V4L2_COLORSPACE_JPEG = 7 , V4L2_COLORSPACE_SRGB = 8 , } ;

enum v4l2_priority { V4L2_PRIORITY_UNSET = 0 , V4L2_PRIORITY_BACKGROUND = 1 , V4L2_PRIORITY_INTERACTIVE = 2 , V4L2_PRIORITY_RECORD = 3 , V4L2_PRIORITY_DEFAULT = V4L2_PRIORITY_INTERACTIVE , } ;

struct v4l2_rect { __s32 left ; __s32 top ; __s32 width ; __s32 height ; } ;

struct v4l2_fract { __u32 numerator ; __u32 denominator ; } ;

struct v4l2_capability { __u8 driver [ 16 ] ; __u8 card [ 32 ] ; __u8 bus_info [ 32 ] ; __u32 version ; __u32 capabilities ; __u32 reserved [ 4 ] ; } ;

struct v4l2_pix_format { __u32 width ; __u32 height ; __u32 pixelformat ; enum v4l2_field field ; __u32 bytesperline ; __u32 sizeimage ; enum v4l2_colorspace colorspace ; __u32 priv ; } ;

struct v4l2_fmtdesc { __u32 index ; enum v4l2_buf_type type ; __u32 flags ; __u8 description [ 32 ] ; __u32 pixelformat ; __u32 reserved [ 4 ] ; } ;

enum v4l2_frmsizetypes { V4L2_FRMSIZE_TYPE_DISCRETE = 1 , V4L2_FRMSIZE_TYPE_CONTINUOUS = 2 , V4L2_FRMSIZE_TYPE_STEPWISE = 3 , } ;

struct v4l2_frmsize_discrete { __u32 width ; __u32 height ; } ;

struct v4l2_frmsize_stepwise { __u32 min_width ; __u32 max_width ; __u32 step_width ; __u32 min_height ; __u32 max_height ; __u32 step_height ; } ;

struct v4l2_frmsizeenum { __u32 index ; __u32 pixel_format ; __u32 type ; union { struct v4l2_frmsize_discrete discrete ; struct v4l2_frmsize_stepwise stepwise ; } ; __u32 reserved [ 2 ] ; } ;

enum v4l2_frmivaltypes { V4L2_FRMIVAL_TYPE_DISCRETE = 1 , V4L2_FRMIVAL_TYPE_CONTINUOUS = 2 , V4L2_FRMIVAL_TYPE_STEPWISE = 3 , } ;

struct v4l2_frmival_stepwise { struct v4l2_fract min ; struct v4l2_fract max ; struct v4l2_fract step ; } ;

struct v4l2_frmivalenum { __u32 index ; __u32 pixel_format ; __u32 width ; __u32 height ; __u32 type ; union { struct v4l2_fract discrete ; struct v4l2_frmival_stepwise stepwise ; } ; __u32 reserved [ 2 ] ; } ;

struct v4l2_timecode { __u32 type ; __u32 flags ; __u8 frames ; __u8 seconds ; __u8 minutes ; __u8 hours ; __u8 userbits [ 4 ] ; } ;

struct v4l2_jpegcompression { int quality ; int APPn ; int APP_len ; char APP_data [ 60 ] ; int COM_len ; char COM_data [ 60 ] ; __u32 jpeg_markers ; } ;

struct v4l2_requestbuffers { __u32 count ; enum v4l2_buf_type type ; enum v4l2_memory memory ; __u32 reserved [ 2 ] ; } ;

struct v4l2_buffer { __u32 index ; enum v4l2_buf_type type ; __u32 bytesused ; __u32 flags ; enum v4l2_field field ; struct timeval timestamp ; struct v4l2_timecode timecode ; __u32 sequence ; enum v4l2_memory memory ; union { __u32 offset ; unsigned long userptr ; } m ; __u32 length ; __u32 input ; __u32 reserved ; } ;

struct v4l2_framebuffer { __u32 capability ; __u32 flags ; void * base ; struct v4l2_pix_format fmt ; } ;

struct v4l2_clip { struct v4l2_rect c ; struct v4l2_clip * next ; } ;

struct v4l2_window { struct v4l2_rect w ; enum v4l2_field field ; __u32 chromakey ; struct v4l2_clip * clips ; __u32 clipcount ; void * bitmap ; __u8 global_alpha ; } ;

struct v4l2_captureparm { __u32 capability ; __u32 capturemode ; struct v4l2_fract timeperframe ; __u32 extendedmode ; __u32 readbuffers ; __u32 reserved [ 4 ] ; } ;

struct v4l2_outputparm { __u32 capability ; __u32 outputmode ; struct v4l2_fract timeperframe ; __u32 extendedmode ; __u32 writebuffers ; __u32 reserved [ 4 ] ; } ;

struct v4l2_cropcap { enum v4l2_buf_type type ; struct v4l2_rect bounds ; struct v4l2_rect defrect ; struct v4l2_fract pixelaspect ; } ;

struct v4l2_crop { enum v4l2_buf_type type ; struct v4l2_rect c ; } ;

typedef __u64 v4l2_std_id ;

struct v4l2_standard { __u32 index ; v4l2_std_id id ; __u8 name [ 24 ] ; struct v4l2_fract frameperiod ; __u32 framelines ; __u32 reserved [ 4 ] ; } ;

struct v4l2_input { __u32 index ; __u8 name [ 32 ] ; __u32 type ; __u32 audioset ; __u32 tuner ; v4l2_std_id std ; __u32 status ; __u32 reserved [ 4 ] ; } ;

struct v4l2_output { __u32 index ; __u8 name [ 32 ] ; __u32 type ; __u32 audioset ; __u32 modulator ; v4l2_std_id std ; __u32 reserved [ 4 ] ; } ;

struct v4l2_control { __u32 id ; __s32 value ; } ;

struct v4l2_ext_control { __u32 id ; __u32 size ; __u32 reserved2 [ 1 ] ; union { __s32 value ; __s64 value64 ; char * string ; } ; } __attribute__ ( ( packed ) ) ;
struct v4l2_ext_controls { __u32 ctrl_class ; __u32 count ; __u32 error_idx ; __u32 reserved [ 2 ] ; struct v4l2_ext_control * controls ; } ;

struct v4l2_queryctrl { __u32 id ; enum v4l2_ctrl_type type ; __u8 name [ 32 ] ; __s32 minimum ; __s32 maximum ; __s32 step ; __s32 default_value ; __u32 flags ; __u32 reserved [ 2 ] ; } ;

struct v4l2_querymenu { __u32 id ; __u32 index ; __u8 name [ 32 ] ; __u32 reserved ; } ;

enum v4l2_power_line_frequency { V4L2_CID_POWER_LINE_FREQUENCY_DISABLED = 0 , V4L2_CID_POWER_LINE_FREQUENCY_50HZ = 1 , V4L2_CID_POWER_LINE_FREQUENCY_60HZ = 2 , } ;

enum v4l2_colorfx { V4L2_COLORFX_NONE = 0 , V4L2_COLORFX_BW = 1 , V4L2_COLORFX_SEPIA = 2 , } ;

enum v4l2_mpeg_stream_type { V4L2_MPEG_STREAM_TYPE_MPEG2_PS = 0 , V4L2_MPEG_STREAM_TYPE_MPEG2_TS = 1 , V4L2_MPEG_STREAM_TYPE_MPEG1_SS = 2 , V4L2_MPEG_STREAM_TYPE_MPEG2_DVD = 3 , V4L2_MPEG_STREAM_TYPE_MPEG1_VCD = 4 , V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5 , } ;

enum v4l2_mpeg_stream_vbi_fmt { V4L2_MPEG_STREAM_VBI_FMT_NONE = 0 , V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1 , } ;

enum v4l2_mpeg_audio_sampling_freq { V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0 , V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1 , V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2 , } ;

enum v4l2_mpeg_audio_encoding { V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0 , V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1 , V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2 , V4L2_MPEG_AUDIO_ENCODING_AAC = 3 , V4L2_MPEG_AUDIO_ENCODING_AC3 = 4 , } ;

enum v4l2_mpeg_audio_l1_bitrate { V4L2_MPEG_AUDIO_L1_BITRATE_32K = 0 , V4L2_MPEG_AUDIO_L1_BITRATE_64K = 1 , V4L2_MPEG_AUDIO_L1_BITRATE_96K = 2 , V4L2_MPEG_AUDIO_L1_BITRATE_128K = 3 , V4L2_MPEG_AUDIO_L1_BITRATE_160K = 4 , V4L2_MPEG_AUDIO_L1_BITRATE_192K = 5 , V4L2_MPEG_AUDIO_L1_BITRATE_224K = 6 , V4L2_MPEG_AUDIO_L1_BITRATE_256K = 7 , V4L2_MPEG_AUDIO_L1_BITRATE_288K = 8 , V4L2_MPEG_AUDIO_L1_BITRATE_320K = 9 , V4L2_MPEG_AUDIO_L1_BITRATE_352K = 10 , V4L2_MPEG_AUDIO_L1_BITRATE_384K = 11 , V4L2_MPEG_AUDIO_L1_BITRATE_416K = 12 , V4L2_MPEG_AUDIO_L1_BITRATE_448K = 13 , } ;

enum v4l2_mpeg_audio_l2_bitrate { V4L2_MPEG_AUDIO_L2_BITRATE_32K = 0 , V4L2_MPEG_AUDIO_L2_BITRATE_48K = 1 , V4L2_MPEG_AUDIO_L2_BITRATE_56K = 2 , V4L2_MPEG_AUDIO_L2_BITRATE_64K = 3 , V4L2_MPEG_AUDIO_L2_BITRATE_80K = 4 , V4L2_MPEG_AUDIO_L2_BITRATE_96K = 5 , V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6 , V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7 , V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8 , V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9 , V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10 , V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11 , V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12 , V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13 , } ;

enum v4l2_mpeg_audio_l3_bitrate { V4L2_MPEG_AUDIO_L3_BITRATE_32K = 0 , V4L2_MPEG_AUDIO_L3_BITRATE_40K = 1 , V4L2_MPEG_AUDIO_L3_BITRATE_48K = 2 , V4L2_MPEG_AUDIO_L3_BITRATE_56K = 3 , V4L2_MPEG_AUDIO_L3_BITRATE_64K = 4 , V4L2_MPEG_AUDIO_L3_BITRATE_80K = 5 , V4L2_MPEG_AUDIO_L3_BITRATE_96K = 6 , V4L2_MPEG_AUDIO_L3_BITRATE_112K = 7 , V4L2_MPEG_AUDIO_L3_BITRATE_128K = 8 , V4L2_MPEG_AUDIO_L3_BITRATE_160K = 9 , V4L2_MPEG_AUDIO_L3_BITRATE_192K = 10 , V4L2_MPEG_AUDIO_L3_BITRATE_224K = 11 , V4L2_MPEG_AUDIO_L3_BITRATE_256K = 12 , V4L2_MPEG_AUDIO_L3_BITRATE_320K = 13 , } ;

enum v4l2_mpeg_audio_mode { V4L2_MPEG_AUDIO_MODE_STEREO = 0 , V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1 , V4L2_MPEG_AUDIO_MODE_DUAL = 2 , V4L2_MPEG_AUDIO_MODE_MONO = 3 , } ;

enum v4l2_mpeg_audio_mode_extension { V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4 = 0 , V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8 = 1 , V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2 , V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3 , } ;

enum v4l2_mpeg_audio_emphasis { V4L2_MPEG_AUDIO_EMPHASIS_NONE = 0 , V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1 , V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17 = 2 , } ;

enum v4l2_mpeg_audio_crc { V4L2_MPEG_AUDIO_CRC_NONE = 0 , V4L2_MPEG_AUDIO_CRC_CRC16 = 1 , } ;

enum v4l2_mpeg_audio_ac3_bitrate { V4L2_MPEG_AUDIO_AC3_BITRATE_32K = 0 , V4L2_MPEG_AUDIO_AC3_BITRATE_40K = 1 , V4L2_MPEG_AUDIO_AC3_BITRATE_48K = 2 , V4L2_MPEG_AUDIO_AC3_BITRATE_56K = 3 , V4L2_MPEG_AUDIO_AC3_BITRATE_64K = 4 , V4L2_MPEG_AUDIO_AC3_BITRATE_80K = 5 , V4L2_MPEG_AUDIO_AC3_BITRATE_96K = 6 , V4L2_MPEG_AUDIO_AC3_BITRATE_112K = 7 , V4L2_MPEG_AUDIO_AC3_BITRATE_128K = 8 , V4L2_MPEG_AUDIO_AC3_BITRATE_160K = 9 , V4L2_MPEG_AUDIO_AC3_BITRATE_192K = 10 , V4L2_MPEG_AUDIO_AC3_BITRATE_224K = 11 , V4L2_MPEG_AUDIO_AC3_BITRATE_256K = 12 , V4L2_MPEG_AUDIO_AC3_BITRATE_320K = 13 , V4L2_MPEG_AUDIO_AC3_BITRATE_384K = 14 , V4L2_MPEG_AUDIO_AC3_BITRATE_448K = 15 , V4L2_MPEG_AUDIO_AC3_BITRATE_512K = 16 , V4L2_MPEG_AUDIO_AC3_BITRATE_576K = 17 , V4L2_MPEG_AUDIO_AC3_BITRATE_640K = 18 , } ;

enum v4l2_mpeg_video_encoding { V4L2_MPEG_VIDEO_ENCODING_MPEG_1 = 0 , V4L2_MPEG_VIDEO_ENCODING_MPEG_2 = 1 , V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC = 2 , } ;

enum v4l2_mpeg_video_aspect { V4L2_MPEG_VIDEO_ASPECT_1x1 = 0 , V4L2_MPEG_VIDEO_ASPECT_4x3 = 1 , V4L2_MPEG_VIDEO_ASPECT_16x9 = 2 , V4L2_MPEG_VIDEO_ASPECT_221x100 = 3 , } ;

enum v4l2_mpeg_video_bitrate_mode { V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0 , V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1 , } ;

enum v4l2_mpeg_cx2341x_video_spatial_filter_mode { V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0 , V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO = 1 , } ;

enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type { V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF = 0 , V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR = 1 , V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT = 2 , V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE = 3 , V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4 , } ;

enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type { V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF = 0 , V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1 , } ;

enum v4l2_mpeg_cx2341x_video_temporal_filter_mode { V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0 , V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO = 1 , } ;

enum v4l2_mpeg_cx2341x_video_median_filter_type { V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF = 0 , V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR = 1 , V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT = 2 , V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3 , V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG = 4 , } ;

enum v4l2_exposure_auto_type { V4L2_EXPOSURE_AUTO = 0 , V4L2_EXPOSURE_MANUAL = 1 , V4L2_EXPOSURE_SHUTTER_PRIORITY = 2 , V4L2_EXPOSURE_APERTURE_PRIORITY = 3 } ;

enum v4l2_preemphasis { V4L2_PREEMPHASIS_DISABLED = 0 , V4L2_PREEMPHASIS_50_uS = 1 , V4L2_PREEMPHASIS_75_uS = 2 , } ;

struct v4l2_tuner { __u32 index ; __u8 name [ 32 ] ; enum v4l2_tuner_type type ; __u32 capability ; __u32 rangelow ; __u32 rangehigh ; __u32 rxsubchans ; __u32 audmode ; __s32 signal ; __s32 afc ; __u32 reserved [ 4 ] ; } ;

struct v4l2_modulator { __u32 index ; __u8 name [ 32 ] ; __u32 capability ; __u32 rangelow ; __u32 rangehigh ; __u32 txsubchans ; __u32 reserved [ 4 ] ; } ;

struct v4l2_frequency { __u32 tuner ; enum v4l2_tuner_type type ; __u32 frequency ; __u32 reserved [ 8 ] ; } ;

struct v4l2_hw_freq_seek { __u32 tuner ; enum v4l2_tuner_type type ; __u32 seek_upward ; __u32 wrap_around ; __u32 reserved [ 8 ] ; } ;

struct v4l2_rds_data { __u8 lsb ; __u8 msb ; __u8 block ; } __attribute__ ( ( packed ) ) ;
struct v4l2_audio { __u32 index ; __u8 name [ 32 ] ; __u32 capability ; __u32 mode ; __u32 reserved [ 2 ] ; } ;

struct v4l2_audioout { __u32 index ; __u8 name [ 32 ] ; __u32 capability ; __u32 mode ; __u32 reserved [ 2 ] ; } ;

struct v4l2_enc_idx_entry { __u64 offset ; __u64 pts ; __u32 length ; __u32 flags ; __u32 reserved [ 2 ] ; } ;

struct v4l2_enc_idx { __u32 entries ; __u32 entries_cap ; __u32 reserved [ 4 ] ; struct v4l2_enc_idx_entry entry [ ( 64 ) ] ; } ;

struct v4l2_encoder_cmd { __u32 cmd ; __u32 flags ; union { struct { __u32 data [ 8 ] ; } raw ; } ; } ;

struct v4l2_vbi_format { __u32 sampling_rate ; __u32 offset ; __u32 samples_per_line ; __u32 sample_format ; __s32 start [ 2 ] ; __u32 count [ 2 ] ; __u32 flags ; __u32 reserved [ 2 ] ; } ;

struct v4l2_sliced_vbi_format { __u16 service_set ; __u16 service_lines [ 2 ] [ 24 ] ; __u32 io_size ; __u32 reserved [ 2 ] ; } ;

struct v4l2_sliced_vbi_cap { __u16 service_set ; __u16 service_lines [ 2 ] [ 24 ] ; enum v4l2_buf_type type ; __u32 reserved [ 3 ] ; } ;

struct v4l2_sliced_vbi_data { __u32 id ; __u32 field ; __u32 line ; __u32 reserved ; __u8 data [ 48 ] ; } ;

struct v4l2_mpeg_vbi_itv0_line { __u8 id ; __u8 data [ 42 ] ; } __attribute__ ( ( packed ) ) ;
struct v4l2_mpeg_vbi_itv0 { __le32 linemask [ 2 ] ; struct v4l2_mpeg_vbi_itv0_line line [ 35 ] ; } __attribute__ ( ( packed ) ) ;
struct v4l2_mpeg_vbi_ITV0 { struct v4l2_mpeg_vbi_itv0_line line [ 36 ] ; } __attribute__ ( ( packed ) ) ;
struct v4l2_mpeg_vbi_fmt_ivtv { __u8 magic [ 4 ] ; union { struct v4l2_mpeg_vbi_itv0 itv0 ; struct v4l2_mpeg_vbi_ITV0 ITV0 ; } ; } __attribute__ ( ( packed ) ) ;
struct v4l2_format { enum v4l2_buf_type type ; union { struct v4l2_pix_format pix ; struct v4l2_window win ; struct v4l2_vbi_format vbi ; struct v4l2_sliced_vbi_format sliced ; __u8 raw_data [ 200 ] ; } fmt ; } ;

struct v4l2_streamparm { enum v4l2_buf_type type ; union { struct v4l2_captureparm capture ; struct v4l2_outputparm output ; __u8 raw_data [ 200 ] ; } parm ; } ;

struct v4l2_dbg_match { __u32 type ; union { __u32 addr ; char name [ 32 ] ; } ; } __attribute__ ( ( packed ) ) ;
struct v4l2_dbg_register { struct v4l2_dbg_match match ; __u32 size ; __u64 reg ; __u64 val ; } __attribute__ ( ( packed ) ) ;
struct v4l2_dbg_chip_ident { struct v4l2_dbg_match match ; __u32 ident ; __u32 revision ; } __attribute__ ( ( packed ) ) ;
struct raw_config_request { int raw_minor ; __u64 block_major ; __u64 block_minor ; } ;

struct smb_inode_info { unsigned int open ; __u16 fileid ; __u16 attr ; __u16 access ; __u16 flags ; unsigned long oldmtime ; unsigned long closed ; unsigned openers ; struct inode vfs_inode ; } ;

enum smb_receive_state { SMB_RECV_START , SMB_RECV_HEADER , SMB_RECV_HCOMPLETE , SMB_RECV_PARAM , SMB_RECV_DATA , SMB_RECV_END , SMB_RECV_DROP , SMB_RECV_REQUEST , } ;

struct smb_sb_info { struct list_head entry ; enum smb_conn_state state ; struct file * sock_file ; int conn_error ; enum smb_receive_state rstate ; atomic_t nr_requests ; struct list_head xmitq ; struct list_head recvq ; u16 mid ; struct smb_mount_data_kernel * mnt ; unsigned int generation ; struct pid * conn_pid ; struct smb_conn_opt opt ; wait_queue_head_t conn_wq ; int conn_complete ; struct semaphore sem ; unsigned char header [ 37 + 20 * 2 + 2 ] ; u32 header_len ; u32 smb_len ; u32 smb_read ; void * data_ready ; struct nls_table * remote_nls ; struct nls_table * local_nls ; struct smb_ops * ops ; struct super_block * super_block ; } ;

struct smb_cache_head { time_t mtime ; unsigned long time ; unsigned long end ; int eof ; } ;

union smb_dir_cache { struct smb_cache_head head ; struct dentry * dentry [ ( ( int ) ( ( ( 1UL ) << 12 ) / sizeof ( struct dentry * ) ) ) ] ; } ;

struct smb_cache_control { struct smb_cache_head head ; struct page * page ; union smb_dir_cache * cache ; unsigned long fpos , ofs ; int filled , valid , idx ; } ;

struct smb_ops { int ( * read ) ( struct inode * inode , loff_t offset , int count , char * data ) ; int ( * write ) ( struct inode * inode , loff_t offset , int count , const char * data ) ; int ( * readdir ) ( struct file * filp , void * dirent , filldir_t filldir , struct smb_cache_control * ctl ) ; int ( * getattr ) ( struct smb_sb_info * server , struct dentry * dir , struct smb_fattr * fattr ) ; int ( * truncate ) ( struct inode * inode , loff_t length ) ; int ( * convert ) ( unsigned char * output , int olen , const unsigned char * input , int ilen , struct nls_table * nls_from , struct nls_table * nls_to ) ; } ;

struct tun_pi { __u16 flags ; __be16 proto ; } ;

struct tun_filter { __u16 flags ; __u16 count ; __u8 addr [ 0 ] [ 6 ] ; } ;

struct i2c_smbus_ioctl_data { __u8 read_write ; __u8 command ; __u32 size ; union i2c_smbus_data * data ; } ;

struct i2c_rdwr_ioctl_data { struct i2c_msg * msgs ; __u32 nmsgs ; } ;

struct atalk_addr { __be16 s_net ; __u8 s_node ; } ;

struct sockaddr_at { sa_family_t sat_family ; __u8 sat_port ; struct atalk_addr sat_addr ; char sat_zero [ 8 ] ; } ;

struct atalk_netrange { __u8 nr_phase ; __be16 nr_firstnet ; __be16 nr_lastnet ; } ;

struct atalk_route { struct net_device * dev ; struct atalk_addr target ; struct atalk_addr gateway ; int flags ; struct atalk_route * next ; } ;

struct atalk_iface { struct net_device * dev ; struct atalk_addr address ; int status ; struct atalk_netrange nets ; struct atalk_iface * next ; } ;

struct atalk_sock { struct sock sk ; __be16 dest_net ; __be16 src_net ; unsigned char dest_node ; unsigned char src_node ; unsigned char dest_port ; unsigned char src_port ; } ;

struct ddpehdr { __be16 deh_len_hops ; __be16 deh_sum ; __be16 deh_dnet ; __be16 deh_snet ; __u8 deh_dnode ; __u8 deh_snode ; __u8 deh_dport ; __u8 deh_sport ; } ;

struct elapaarp { __be16 hw_type ; __be16 pa_type ; __u8 hw_len ; __u8 pa_len ; __be16 function ; __u8 hw_src [ 6 ] ; __u8 pa_src_zero ; __be16 pa_src_net ; __u8 pa_src_node ; __u8 hw_dst [ 6 ] ; __u8 pa_dst_zero ; __be16 pa_dst_net ; __u8 pa_dst_node ; } __attribute__ ( ( packed ) ) ;
struct bt_security { __u8 level ; } ;

enum { BT_CONNECTED = 1 , BT_OPEN , BT_BOUND , BT_LISTEN , BT_CONNECT , BT_CONNECT2 , BT_CONFIG , BT_DISCONN , BT_CLOSED } ;
typedef struct { __u8 b [ 6 ] ; } __attribute__ ( ( packed ) ) bdaddr_t ;

struct bt_sock { struct sock sk ; bdaddr_t src ; bdaddr_t dst ; struct list_head accept_q ; struct sock * parent ; u32 defer_setup ; } ;

struct bt_sock_list { struct hlist_head head ; rwlock_t lock ; } ;

struct bt_skb_cb { __u8 pkt_type ; __u8 incoming ; __u8 tx_seq ; __u8 retries ; __u8 sar ; } ;

enum { HCI_QUIRK_NO_RESET , HCI_QUIRK_RAW_DEVICE , HCI_QUIRK_FIXUP_BUFFER_SIZE } ;
enum { HCI_UP , HCI_INIT , HCI_RUNNING , HCI_PSCAN , HCI_ISCAN , HCI_AUTH , HCI_ENCRYPT , HCI_INQUIRY , HCI_RAW , } ;
struct hci_cp_inquiry { __u8 lap [ 3 ] ; __u8 length ; __u8 num_rsp ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_create_conn { bdaddr_t bdaddr ; __le16 pkt_type ; __u8 pscan_rep_mode ; __u8 pscan_mode ; __le16 clock_offset ; __u8 role_switch ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_disconnect { __le16 handle ; __u8 reason ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_add_sco { __le16 handle ; __le16 pkt_type ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_create_conn_cancel { bdaddr_t bdaddr ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_accept_conn_req { bdaddr_t bdaddr ; __u8 role ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_reject_conn_req { bdaddr_t bdaddr ; __u8 reason ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_link_key_reply { bdaddr_t bdaddr ; __u8 link_key [ 16 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_link_key_neg_reply { bdaddr_t bdaddr ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_pin_code_reply { bdaddr_t bdaddr ; __u8 pin_len ; __u8 pin_code [ 16 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_pin_code_neg_reply { bdaddr_t bdaddr ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_change_conn_ptype { __le16 handle ; __le16 pkt_type ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_auth_requested { __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_set_conn_encrypt { __le16 handle ; __u8 encrypt ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_change_conn_link_key { __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_remote_name_req { bdaddr_t bdaddr ; __u8 pscan_rep_mode ; __u8 pscan_mode ; __le16 clock_offset ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_remote_name_req_cancel { bdaddr_t bdaddr ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_read_remote_features { __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_read_remote_ext_features { __le16 handle ; __u8 page ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_read_remote_version { __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_setup_sync_conn { __le16 handle ; __le32 tx_bandwidth ; __le32 rx_bandwidth ; __le16 max_latency ; __le16 voice_setting ; __u8 retrans_effort ; __le16 pkt_type ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_accept_sync_conn_req { bdaddr_t bdaddr ; __le32 tx_bandwidth ; __le32 rx_bandwidth ; __le16 max_latency ; __le16 content_format ; __u8 retrans_effort ; __le16 pkt_type ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_reject_sync_conn_req { bdaddr_t bdaddr ; __u8 reason ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_sniff_mode { __le16 handle ; __le16 max_interval ; __le16 min_interval ; __le16 attempt ; __le16 timeout ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_exit_sniff_mode { __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_role_discovery { __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_role_discovery { __u8 status ; __le16 handle ; __u8 role ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_switch_role { bdaddr_t bdaddr ; __u8 role ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_read_link_policy { __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_link_policy { __u8 status ; __le16 handle ; __le16 policy ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_write_link_policy { __le16 handle ; __le16 policy ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_write_link_policy { __u8 status ; __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_def_link_policy { __u8 status ; __le16 policy ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_write_def_link_policy { __le16 policy ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_sniff_subrate { __le16 handle ; __le16 max_latency ; __le16 min_remote_timeout ; __le16 min_local_timeout ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_set_event_mask { __u8 mask [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_set_event_flt { __u8 flt_type ; __u8 cond_type ; __u8 condition [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_write_local_name { __u8 name [ 248 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_local_name { __u8 status ; __u8 name [ 248 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_class_of_dev { __u8 status ; __u8 dev_class [ 3 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_write_class_of_dev { __u8 dev_class [ 3 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_voice_setting { __u8 status ; __le16 voice_setting ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_write_voice_setting { __le16 voice_setting ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_host_buffer_size { __le16 acl_mtu ; __u8 sco_mtu ; __le16 acl_max_pkt ; __le16 sco_max_pkt ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_ssp_mode { __u8 status ; __u8 mode ; } __attribute__ ( ( packed ) ) ;
struct hci_cp_write_ssp_mode { __u8 mode ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_local_version { __u8 status ; __u8 hci_ver ; __le16 hci_rev ; __u8 lmp_ver ; __le16 manufacturer ; __le16 lmp_subver ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_local_commands { __u8 status ; __u8 commands [ 64 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_local_features { __u8 status ; __u8 features [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_local_ext_features { __u8 status ; __u8 page ; __u8 max_page ; __u8 features [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_buffer_size { __u8 status ; __le16 acl_mtu ; __u8 sco_mtu ; __le16 acl_max_pkt ; __le16 sco_max_pkt ; } __attribute__ ( ( packed ) ) ;
struct hci_rp_read_bd_addr { __u8 status ; bdaddr_t bdaddr ; } __attribute__ ( ( packed ) ) ;
struct inquiry_info { bdaddr_t bdaddr ; __u8 pscan_rep_mode ; __u8 pscan_period_mode ; __u8 pscan_mode ; __u8 dev_class [ 3 ] ; __le16 clock_offset ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_conn_complete { __u8 status ; __le16 handle ; bdaddr_t bdaddr ; __u8 link_type ; __u8 encr_mode ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_conn_request { bdaddr_t bdaddr ; __u8 dev_class [ 3 ] ; __u8 link_type ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_disconn_complete { __u8 status ; __le16 handle ; __u8 reason ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_auth_complete { __u8 status ; __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_remote_name { __u8 status ; bdaddr_t bdaddr ; __u8 name [ 248 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_encrypt_change { __u8 status ; __le16 handle ; __u8 encrypt ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_change_link_key_complete { __u8 status ; __le16 handle ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_remote_features { __u8 status ; __le16 handle ; __u8 features [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_remote_version { __u8 status ; __le16 handle ; __u8 lmp_ver ; __le16 manufacturer ; __le16 lmp_subver ; } __attribute__ ( ( packed ) ) ;
struct hci_qos { __u8 service_type ; __u32 token_rate ; __u32 peak_bandwidth ; __u32 latency ; __u32 delay_variation ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_qos_setup_complete { __u8 status ; __le16 handle ; struct hci_qos qos ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_cmd_complete { __u8 ncmd ; __le16 opcode ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_cmd_status { __u8 status ; __u8 ncmd ; __le16 opcode ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_role_change { __u8 status ; bdaddr_t bdaddr ; __u8 role ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_num_comp_pkts { __u8 num_hndl ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_mode_change { __u8 status ; __le16 handle ; __u8 mode ; __le16 interval ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_pin_code_req { bdaddr_t bdaddr ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_link_key_req { bdaddr_t bdaddr ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_link_key_notify { bdaddr_t bdaddr ; __u8 link_key [ 16 ] ; __u8 key_type ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_clock_offset { __u8 status ; __le16 handle ; __le16 clock_offset ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_pkt_type_change { __u8 status ; __le16 handle ; __le16 pkt_type ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_pscan_rep_mode { bdaddr_t bdaddr ; __u8 pscan_rep_mode ; } __attribute__ ( ( packed ) ) ;
struct inquiry_info_with_rssi { bdaddr_t bdaddr ; __u8 pscan_rep_mode ; __u8 pscan_period_mode ; __u8 dev_class [ 3 ] ; __le16 clock_offset ; __s8 rssi ; } __attribute__ ( ( packed ) ) ;
struct inquiry_info_with_rssi_and_pscan_mode { bdaddr_t bdaddr ; __u8 pscan_rep_mode ; __u8 pscan_period_mode ; __u8 pscan_mode ; __u8 dev_class [ 3 ] ; __le16 clock_offset ; __s8 rssi ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_remote_ext_features { __u8 status ; __le16 handle ; __u8 page ; __u8 max_page ; __u8 features [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_sync_conn_complete { __u8 status ; __le16 handle ; bdaddr_t bdaddr ; __u8 link_type ; __u8 tx_interval ; __u8 retrans_window ; __le16 rx_pkt_len ; __le16 tx_pkt_len ; __u8 air_mode ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_sync_conn_changed { __u8 status ; __le16 handle ; __u8 tx_interval ; __u8 retrans_window ; __le16 rx_pkt_len ; __le16 tx_pkt_len ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_sniff_subrate { __u8 status ; __le16 handle ; __le16 max_tx_latency ; __le16 max_rx_latency ; __le16 max_remote_timeout ; __le16 max_local_timeout ; } __attribute__ ( ( packed ) ) ;
struct extended_inquiry_info { bdaddr_t bdaddr ; __u8 pscan_rep_mode ; __u8 pscan_period_mode ; __u8 dev_class [ 3 ] ; __le16 clock_offset ; __s8 rssi ; __u8 data [ 240 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_io_capa_request { bdaddr_t bdaddr ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_simple_pair_complete { __u8 status ; bdaddr_t bdaddr ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_remote_host_features { bdaddr_t bdaddr ; __u8 features [ 8 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_stack_internal { __u16 type ; __u8 data [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_si_device { __u16 event ; __u16 dev_id ; } __attribute__ ( ( packed ) ) ;
struct hci_ev_si_security { __u16 event ; __u16 proto ; __u16 subproto ; __u8 incoming ; } __attribute__ ( ( packed ) ) ;
struct hci_command_hdr { __le16 opcode ; __u8 plen ; } __attribute__ ( ( packed ) ) ;
struct hci_event_hdr { __u8 evt ; __u8 plen ; } __attribute__ ( ( packed ) ) ;
struct hci_acl_hdr { __le16 handle ; __le16 dlen ; } __attribute__ ( ( packed ) ) ;
struct hci_sco_hdr { __le16 handle ; __u8 dlen ; } __attribute__ ( ( packed ) ) ;
struct sockaddr_hci { sa_family_t hci_family ; unsigned short hci_dev ; } ;

struct hci_filter { unsigned long type_mask ; unsigned long event_mask [ 2 ] ; __le16 opcode ; } ;

struct hci_ufilter { __u32 type_mask ; __u32 event_mask [ 2 ] ; __le16 opcode ; } ;

struct hci_dev_stats { __u32 err_rx ; __u32 err_tx ; __u32 cmd_tx ; __u32 evt_rx ; __u32 acl_tx ; __u32 acl_rx ; __u32 sco_tx ; __u32 sco_rx ; __u32 byte_rx ; __u32 byte_tx ; } ;

struct hci_dev_info { __u16 dev_id ; char name [ 8 ] ; bdaddr_t bdaddr ; __u32 flags ; __u8 type ; __u8 features [ 8 ] ; __u32 pkt_type ; __u32 link_policy ; __u32 link_mode ; __u16 acl_mtu ; __u16 acl_pkts ; __u16 sco_mtu ; __u16 sco_pkts ; struct hci_dev_stats stat ; } ;

struct hci_conn_info { __u16 handle ; bdaddr_t bdaddr ; __u8 type ; __u8 out ; __u16 state ; __u32 link_mode ; } ;

struct hci_dev_req { __u16 dev_id ; __u32 dev_opt ; } ;

struct hci_dev_list_req { __u16 dev_num ; struct hci_dev_req dev_req [ 0 ] ; } ;

struct hci_conn_list_req { __u16 dev_id ; __u16 conn_num ; struct hci_conn_info conn_info [ 0 ] ; } ;

struct hci_conn_info_req { bdaddr_t bdaddr ; __u8 type ; struct hci_conn_info conn_info [ 0 ] ; } ;

struct hci_auth_info_req { bdaddr_t bdaddr ; __u8 type ; } ;

struct hci_inquiry_req { __u16 dev_id ; __u16 flags ; __u8 lap [ 3 ] ; __u8 length ; __u8 num_rsp ; } ;

struct rfcomm_hdr { u8 addr ; u8 ctrl ; u8 len ; } __attribute__ ( ( packed ) ) ;
struct rfcomm_cmd { u8 addr ; u8 ctrl ; u8 len ; u8 fcs ; } __attribute__ ( ( packed ) ) ;
struct rfcomm_mcc { u8 type ; u8 len ; } __attribute__ ( ( packed ) ) ;
struct rfcomm_pn { u8 dlci ; u8 flow_ctrl ; u8 priority ; u8 ack_timer ; __le16 mtu ; u8 max_retrans ; u8 credits ; } __attribute__ ( ( packed ) ) ;
struct rfcomm_rpn { u8 dlci ; u8 bit_rate ; u8 line_settings ; u8 flow_ctrl ; u8 xon_char ; u8 xoff_char ; __le16 param_mask ; } __attribute__ ( ( packed ) ) ;
struct rfcomm_rls { u8 dlci ; u8 status ; } __attribute__ ( ( packed ) ) ;
struct rfcomm_msc { u8 dlci ; u8 v24_sig ; } __attribute__ ( ( packed ) ) ;
struct rfcomm_session { struct list_head list ; struct socket * sock ; struct timer_list timer ; unsigned long state ; unsigned long flags ; atomic_t refcnt ; int initiator ; int cfc ; uint mtu ; struct list_head dlcs ; } ;

struct rfcomm_dlc { struct list_head list ; struct rfcomm_session * session ; struct sk_buff_head tx_queue ; struct timer_list timer ; spinlock_t lock ; unsigned long state ; unsigned long flags ; atomic_t refcnt ; u8 dlci ; u8 addr ; u8 priority ; u8 v24_sig ; u8 remote_v24_sig ; u8 mscex ; u8 out ; u8 sec_level ; u8 role_switch ; u32 defer_setup ; uint mtu ; uint cfc ; uint rx_credits ; uint tx_credits ; void * owner ; void ( * data_ready ) ( struct rfcomm_dlc * d , struct sk_buff * skb ) ; void ( * state_change ) ( struct rfcomm_dlc * d , int err ) ; void ( * modem_status ) ( struct rfcomm_dlc * d , u8 v24_sig ) ; } ;

struct sockaddr_rc { sa_family_t rc_family ; bdaddr_t rc_bdaddr ; u8 rc_channel ; } ;

struct rfcomm_conninfo { __u16 hci_handle ; __u8 dev_class [ 3 ] ; } ;

struct rfcomm_pinfo { struct bt_sock bt ; struct rfcomm_dlc * dlc ; u8 channel ; u8 sec_level ; u8 role_switch ; } ;

struct rfcomm_dev_req { s16 dev_id ; u32 flags ; bdaddr_t src ; bdaddr_t dst ; u8 channel ; } ;

struct rfcomm_dev_info { s16 id ; u32 flags ; u16 state ; bdaddr_t src ; bdaddr_t dst ; u8 channel ; } ;

struct rfcomm_dev_list_req { u16 dev_num ; struct rfcomm_dev_info dev_info [ 0 ] ; } ;


typedef struct capi_register_params { __u32 level3cnt ; __u32 datablkcnt ; __u32 datablklen ; } capi_register_params ;


typedef struct capi_version { __u32 majorversion ; __u32 minorversion ; __u32 majormanuversion ; __u32 minormanuversion ; } capi_version ;


typedef struct capi_profile { __u16 ncontroller ; __u16 nbchannel ; __u32 goptions ; __u32 support1 ; __u32 support2 ; __u32 support3 ; __u32 reserved [ 6 ] ; __u32 manu [ 5 ] ; } capi_profile ;


typedef struct capi_manufacturer_cmd { unsigned long cmd ; void * data ; } capi_manufacturer_cmd ;


typedef union capi_ioctl_struct { __u32 contr ; capi_register_params rparams ; __u8 manufacturer [ 64 ] ; capi_version version ; __u8 serial [ 8 ] ; capi_profile profile ; capi_manufacturer_cmd cmd ; __u16 errcode ; } capi_ioctl_struct ;

enum { Lo_unbound , Lo_bound , Lo_rundown , } ;
struct loop_func_table ;

struct loop_device { int lo_number ; int lo_refcnt ; loff_t lo_offset ; loff_t lo_sizelimit ; int lo_flags ; int ( * transfer ) ( struct loop_device * , int cmd , struct page * raw_page , unsigned raw_off , struct page * loop_page , unsigned loop_off , int size , sector_t real_block ) ; char lo_file_name [ 64 ] ; char lo_crypt_name [ 64 ] ; char lo_encrypt_key [ 32 ] ; int lo_encrypt_key_size ; struct loop_func_table * lo_encryption ; __u32 lo_init [ 2 ] ; uid_t lo_key_owner ; int ( * ioctl ) ( struct loop_device * , int cmd , unsigned long arg ) ; struct file * lo_backing_file ; struct block_device * lo_device ; unsigned lo_blocksize ; void * key_data ; gfp_t old_gfp_mask ; spinlock_t lo_lock ; struct bio_list lo_bio_list ; int lo_state ; struct mutex lo_ctl_mutex ; struct task_struct * lo_thread ; wait_queue_head_t lo_event ; struct request_queue * lo_queue ; struct gendisk * lo_disk ; struct list_head lo_list ; } ;

enum { LO_FLAGS_READ_ONLY = 1 , LO_FLAGS_USE_AOPS = 2 , LO_FLAGS_AUTOCLEAR = 4 , } ;
struct loop_info { int lo_number ; __kernel_old_dev_t lo_device ; unsigned long lo_inode ; __kernel_old_dev_t lo_rdevice ; int lo_offset ; int lo_encrypt_type ; int lo_encrypt_key_size ; int lo_flags ; char lo_name [ 64 ] ; unsigned char lo_encrypt_key [ 32 ] ; unsigned long lo_init [ 2 ] ; char reserved [ 4 ] ; } ;

struct loop_info64 { __u64 lo_device ; __u64 lo_inode ; __u64 lo_rdevice ; __u64 lo_offset ; __u64 lo_sizelimit ; __u32 lo_number ; __u32 lo_encrypt_type ; __u32 lo_encrypt_key_size ; __u32 lo_flags ; __u8 lo_file_name [ 64 ] ; __u8 lo_crypt_name [ 64 ] ; __u8 lo_encrypt_key [ 32 ] ; __u64 lo_init [ 2 ] ; } ;

struct loop_func_table { int number ; int ( * transfer ) ( struct loop_device * lo , int cmd , struct page * raw_page , unsigned raw_off , struct page * loop_page , unsigned loop_off , int size , sector_t real_block ) ; int ( * init ) ( struct loop_device * , const struct loop_info64 * ) ; int ( * release ) ( struct loop_device * ) ; int ( * ioctl ) ( struct loop_device * , int cmd , unsigned long arg ) ; struct module * owner ; } ;
struct scsi_cmnd ;

struct scsi_varlen_cdb_hdr { u8 opcode ; u8 control ; u8 misc [ 5 ] ; u8 additional_cdb_length ; __be16 service_action ; } ;

enum scsi_protocol { SCSI_PROTOCOL_FCP = 0 , SCSI_PROTOCOL_SPI = 1 , SCSI_PROTOCOL_SSA = 2 , SCSI_PROTOCOL_SBP = 3 , SCSI_PROTOCOL_SRP = 4 , SCSI_PROTOCOL_ISCSI = 5 , SCSI_PROTOCOL_SAS = 6 , SCSI_PROTOCOL_ADT = 7 , SCSI_PROTOCOL_ATA = 8 , SCSI_PROTOCOL_UNSPEC = 0xf , } ;

struct ccs_modesel_head { __u8 _r1 ; __u8 medium ; __u8 _r2 ; __u8 block_desc_length ; __u8 density ; __u8 number_blocks_hi ; __u8 number_blocks_med ; __u8 number_blocks_lo ; __u8 _r3 ; __u8 block_length_hi ; __u8 block_length_med ; __u8 block_length_lo ; } ;

struct scsi_lun { __u8 scsi_lun [ 8 ] ; } ;

struct scsi_device ;

typedef struct scsi_ioctl_command { unsigned int inlen ; unsigned int outlen ; unsigned char data [ 0 ] ; } Scsi_Ioctl_Command ;


typedef struct scsi_idlun { __u32 dev_id ; __u32 host_unique_id ; } Scsi_Idlun ;


typedef struct scsi_fctargaddress { __u32 host_port_id ; unsigned char host_wwn [ 8 ] ; } Scsi_FCTargAddress ;

struct mii_ioctl_data { __u16 phy_id ; __u16 reg_num ; __u16 val_in ; __u16 val_out ; } ;

struct ethtool_cmd ;
struct mii_if_info { int phy_id ; int advertising ; int phy_id_mask ; int reg_num_mask ; unsigned int full_duplex : 1 ; unsigned int force_media : 1 ; unsigned int supports_gmii : 1 ; struct net_device * dev ; int ( * mdio_read ) ( struct net_device * dev , int phy_id , int location ) ; void ( * mdio_write ) ( struct net_device * dev , int phy_id , int location , int val ) ; } ;


typedef struct ifbond { __s32 bond_mode ; __s32 num_slaves ; __s32 miimon ; } ifbond ;


typedef struct ifslave { __s32 slave_id ; char slave_name [ 16 ] ; __s8 link ; __s8 state ; __u32 link_failure_count ; } ifslave ;

struct ad_info { __u16 aggregator_id ; __u16 ports ; __u16 actor_key ; __u16 partner_key ; __u8 partner_system [ 6 ] ; } ;

struct watchdog_info { __u32 options ; __u32 firmware_version ; __u8 identity [ 32 ] ; } ;


typedef struct synth_control { int devno ; char data [ 4000 ] ; } synth_control ;


typedef struct remove_sample { int devno ; int bankno ; int instrno ; } remove_sample ;


typedef struct seq_event_rec { unsigned char arr [ 8 ] ; } seq_event_rec ;

struct patch_info { unsigned short key ; short device_no ; short instr_no ; unsigned int mode ; int len ; int loop_start , loop_end ; unsigned int base_freq ; unsigned int base_note ; unsigned int high_note ; unsigned int low_note ; int panning ; int detuning ; unsigned char env_rate [ 6 ] ; unsigned char env_offset [ 6 ] ; unsigned char tremolo_sweep ; unsigned char tremolo_rate ; unsigned char tremolo_depth ; unsigned char vibrato_sweep ; unsigned char vibrato_rate ; unsigned char vibrato_depth ; int scale_frequency ; unsigned int scale_factor ; int volume ; int fractions ; int reserved1 ; int spare [ 2 ] ; char data [ 1 ] ; } ;

struct sysex_info { short key ; short device_no ; int len ; unsigned char data [ 1 ] ; } ;

typedef unsigned char sbi_instr_data [ 32 ] ;
struct sbi_instrument { unsigned short key ; short device ; int channel ; sbi_instr_data operators ; } ;

struct synth_info { char name [ 30 ] ; int device ; int synth_type ; int synth_subtype ; int perc_mode ; int nr_voices ; int nr_drums ; int instr_bank_size ; unsigned int capabilities ; int dummies [ 19 ] ; } ;

struct sound_timer_info { char name [ 32 ] ; int caps ; } ;

struct midi_info { char name [ 30 ] ; int device ; unsigned int capabilities ; int dev_type ; int dummies [ 18 ] ; } ;

typedef struct { unsigned char cmd ; char nr_args , nr_returns ; unsigned char data [ 30 ] ; } mpu_command_rec ;


typedef struct audio_buf_info { int fragments ; int fragstotal ; int fragsize ; int bytes ; } audio_buf_info ;


typedef struct count_info { int bytes ; int blocks ; int ptr ; } count_info ;


typedef struct buffmem_desc { unsigned * buffer ; int size ; } buffmem_desc ;


typedef struct copr_buffer { int command ; int flags ; int len ; int offs ; unsigned char data [ 4000 ] ; } copr_buffer ;


typedef struct copr_debug_buf { int command ; int parm1 ; int parm2 ; int flags ; int len ; } copr_debug_buf ;


typedef struct copr_msg { int len ; unsigned char data [ 4000 ] ; } copr_msg ;


typedef struct mixer_info { char id [ 16 ] ; char name [ 32 ] ; int modify_counter ; int fillers [ 10 ] ; } mixer_info ;


typedef struct _old_mixer_info { char id [ 16 ] ; char name [ 32 ] ; } _old_mixer_info ;

typedef unsigned char mixer_record [ 128 ] ;

typedef struct mixer_vol_table { int num ; char name [ 32 ] ; int levels [ 32 ] ; } mixer_vol_table ;

struct lp_struct { struct pardevice * dev ; unsigned long flags ; unsigned int chars ; unsigned int time ; unsigned int wait ; char * lp_buffer ; wait_queue_head_t waitq ; unsigned int last_error ; struct mutex port_mutex ; wait_queue_head_t dataq ; long timeout ; unsigned int best_mode ; unsigned int current_mode ; unsigned long bits ; } ;

struct ppdev_frob_struct { unsigned char mask ; unsigned char val ; } ;

typedef struct { unsigned char _ [ 8 ] ; } atm_kptr_t ;

struct atm_blli { unsigned char l2_proto ; union { struct { unsigned char mode ; unsigned char window ; } itu ; unsigned char user ; } l2 ; unsigned char l3_proto ; union { struct { unsigned char mode ; unsigned char def_size ; unsigned char window ; } itu ; unsigned char user ; struct { unsigned char term_type ; unsigned char fw_mpx_cap ; unsigned char bw_mpx_cap ; } h310 ; struct { unsigned char ipi ; unsigned char snap [ 5 ] ; } tr9577 ; } l3 ; } ;

struct atm_bhli { unsigned char hl_type ; unsigned char hl_length ; unsigned char hl_info [ 8 ] ; } ;

struct atm_sap { struct atm_bhli bhli ; struct atm_blli blli [ 3 ] ; } ;

struct atm_trafprm { unsigned char traffic_class ; int max_pcr ; int pcr ; int min_pcr ; int max_cdv ; int max_sdu ; unsigned int icr ; unsigned int tbe ; unsigned int frtt : 24 ; unsigned int rif : 4 ; unsigned int rdf : 4 ; unsigned int nrm_pres : 1 ; unsigned int trm_pres : 1 ; unsigned int adtf_pres : 1 ; unsigned int cdf_pres : 1 ; unsigned int nrm : 3 ; unsigned int trm : 3 ; unsigned int adtf : 10 ; unsigned int cdf : 3 ; unsigned int spare : 9 ; } ;

struct atm_qos { struct atm_trafprm txtp ; struct atm_trafprm rxtp ; unsigned char aal ; } ;

struct sockaddr_atmpvc { unsigned short sap_family ; struct { short itf ; short vpi ; int vci ; } sap_addr ; } ;

struct sockaddr_atmsvc { unsigned short sas_family ; struct { unsigned char prv [ 20 ] ; char pub [ 12 + 1 ] ; char lij_type ; __u32 lij_id ; } sas_addr ; } ;

struct atmif_sioc { int number ; int length ; void * arg ; } ;

struct compat_atmif_sioc { int number ; int length ; compat_uptr_t arg ; } ;

typedef unsigned short atm_backend_t ;

enum atmarp_ctrl_type { act_invalid , act_need , act_up , act_down , act_change } ;

struct atmarp_ctrl { enum atmarp_ctrl_type type ; int itf_num ; __be32 ip ; } ;

struct atm_aal_stats { int tx ; int tx_err ; int rx ; int rx_err ; int rx_drop ; } ;

struct atm_dev_stats { struct atm_aal_stats aal0 ; struct atm_aal_stats aal34 ; struct atm_aal_stats aal5 ; } ;

struct atm_iobuf { int length ; void * buffer ; } ;

struct atm_cirange { signed char vpi_bits ; signed char vci_bits ; } ;

struct compat_atm_iobuf { int length ; compat_uptr_t buffer ; } ;

struct k_atm_aal_stats { atomic_t tx ; atomic_t tx_err ; atomic_t rx ; atomic_t rx_err ; atomic_t rx_drop ; } ;

struct k_atm_dev_stats { struct k_atm_aal_stats aal0 ; struct k_atm_aal_stats aal34 ; struct k_atm_aal_stats aal5 ; } ;

enum { ATM_VF_ADDR , ATM_VF_READY , ATM_VF_PARTIAL , ATM_VF_REGIS , ATM_VF_BOUND , ATM_VF_RELEASED , ATM_VF_HASQOS , ATM_VF_LISTEN , ATM_VF_META , ATM_VF_SESSION , ATM_VF_HASSAP , ATM_VF_CLOSE , ATM_VF_WAITING , ATM_VF_IS_CLIP , } ;
enum { ATM_DF_REMOVED , } ;
struct atm_vcc { struct sock sk ; unsigned long flags ; short vpi ; int vci ; unsigned long aal_options ; unsigned long atm_options ; struct atm_dev * dev ; struct atm_qos qos ; struct atm_sap sap ; void ( * push ) ( struct atm_vcc * vcc , struct sk_buff * skb ) ; void ( * pop ) ( struct atm_vcc * vcc , struct sk_buff * skb ) ; int ( * push_oam ) ( struct atm_vcc * vcc , void * cell ) ; int ( * send ) ( struct atm_vcc * vcc , struct sk_buff * skb ) ; void * dev_data ; void * proto_data ; struct k_atm_aal_stats * stats ; short itf ; struct sockaddr_atmsvc local ; struct sockaddr_atmsvc remote ; struct atm_vcc * session ; void * user_back ; } ;

struct atm_dev_addr { struct sockaddr_atmsvc addr ; struct list_head entry ; } ;

enum atm_addr_type_t { ATM_ADDR_LOCAL , ATM_ADDR_LECS } ;

struct atm_dev { const struct atmdev_ops * ops ; const struct atmphy_ops * phy ; const char * type ; int number ; void * dev_data ; void * phy_data ; unsigned long flags ; struct list_head local ; struct list_head lecs ; unsigned char esi [ 6 ] ; struct atm_cirange ci_range ; struct k_atm_dev_stats stats ; char signal ; int link_rate ; atomic_t refcnt ; spinlock_t lock ; struct proc_dir_entry * proc_entry ; char * proc_name ; struct device class_dev ; struct list_head dev_list ; } ;

struct atmdev_ops { void ( * dev_close ) ( struct atm_dev * dev ) ; int ( * open ) ( struct atm_vcc * vcc ) ; void ( * close ) ( struct atm_vcc * vcc ) ; int ( * ioctl ) ( struct atm_dev * dev , unsigned int cmd , void * arg ) ; int ( * compat_ioctl ) ( struct atm_dev * dev , unsigned int cmd , void * arg ) ; int ( * getsockopt ) ( struct atm_vcc * vcc , int level , int optname , void * optval , int optlen ) ; int ( * setsockopt ) ( struct atm_vcc * vcc , int level , int optname , void * optval , unsigned int optlen ) ; int ( * send ) ( struct atm_vcc * vcc , struct sk_buff * skb ) ; int ( * send_oam ) ( struct atm_vcc * vcc , void * cell , int flags ) ; void ( * phy_put ) ( struct atm_dev * dev , unsigned char value , unsigned long addr ) ; unsigned char ( * phy_get ) ( struct atm_dev * dev , unsigned long addr ) ; int ( * change_qos ) ( struct atm_vcc * vcc , struct atm_qos * qos , int flags ) ; int ( * proc_read ) ( struct atm_dev * dev , loff_t * pos , char * page ) ; struct module * owner ; } ;

struct atmphy_ops { int ( * start ) ( struct atm_dev * dev ) ; int ( * ioctl ) ( struct atm_dev * dev , unsigned int cmd , void * arg ) ; void ( * interrupt ) ( struct atm_dev * dev ) ; int ( * stop ) ( struct atm_dev * dev ) ; } ;

struct atm_skb_data { struct atm_vcc * vcc ; unsigned long atm_options ; } ;

struct atm_ioctl { struct module * owner ; int ( * ioctl ) ( struct socket * , unsigned int cmd , unsigned long arg ) ; struct list_head list ; } ;

typedef enum { l_set_mac_addr , l_del_mac_addr , l_svc_setup , l_addr_delete , l_topology_change , l_flush_complete , l_arp_update , l_narp_req , l_config , l_flush_tran_id , l_set_lecid , l_arp_xmt , l_rdesc_arp_xmt , l_associate_req , l_should_bridge } atmlec_msg_type ;

struct atmlec_config_msg { unsigned int maximum_unknown_frame_count ; unsigned int max_unknown_frame_time ; unsigned short max_retry_count ; unsigned int aging_time ; unsigned int forward_delay_time ; unsigned int arp_response_time ; unsigned int flush_timeout ; unsigned int path_switching_delay ; unsigned int lane_version ; int mtu ; int is_proxy ; } ;

struct atmlec_msg { atmlec_msg_type type ; int sizeoftlvs ; union { struct { unsigned char mac_addr [ 6 ] ; unsigned char atm_addr [ 20 ] ; unsigned int flag ; unsigned int targetless_le_arp ; unsigned int no_source_le_narp ; } normal ; struct atmlec_config_msg config ; struct { __u16 lec_id ; __u32 tran_id ; unsigned char mac_addr [ 6 ] ; unsigned char atm_addr [ 20 ] ; } proxy ; } content ; } ;

struct atmlec_ioc { int dev_num ; unsigned char atm_addr [ 20 ] ; unsigned char receive ; } ;

struct atmmpc_ioc { int dev_num ; __be32 ipaddr ; int type ; } ;


typedef struct in_ctrl_info { __u8 Last_NHRP_CIE_code ; __u8 Last_Q2931_cause_value ; __u8 eg_MPC_ATM_addr [ 20 ] ; __be32 tag ; __be32 in_dst_ip ; __u16 holding_time ; __u32 request_id ; } in_ctrl_info ;


typedef struct eg_ctrl_info { __u8 DLL_header [ 256 ] ; __u8 DH_length ; __be32 cache_id ; __be32 tag ; __be32 mps_ip ; __be32 eg_dst_ip ; __u8 in_MPC_data_ATM_addr [ 20 ] ; __u16 holding_time ; } eg_ctrl_info ;

struct mpc_parameters { __u16 mpc_p1 ; __u16 mpc_p2 ; __u8 mpc_p3 [ 8 ] ; __u16 mpc_p4 ; __u16 mpc_p5 ; __u16 mpc_p6 ; } ;

struct k_message { __u16 type ; __be32 ip_mask ; __u8 MPS_ctrl [ 20 ] ; union { in_ctrl_info in_info ; eg_ctrl_info eg_info ; struct mpc_parameters params ; } content ; struct atm_qos qos ; } ;

struct llc_snap_hdr { __u8 dsap ; __u8 ssap ; __u8 ui ; __u8 org [ 3 ] ; __u8 type [ 2 ] ; } ;

enum atmsvc_msg_type { as_catch_null , as_bind , as_connect , as_accept , as_reject , as_listen , as_okay , as_error , as_indicate , as_close , as_itf_notify , as_modify , as_identify , as_terminate , as_addparty , as_dropparty } ;

struct atmsvc_msg { enum atmsvc_msg_type type ; atm_kptr_t vcc ; atm_kptr_t listen_vcc ; int reply ; struct sockaddr_atmpvc pvc ; struct sockaddr_atmsvc local ; struct atm_qos qos ; struct atm_sap sap ; unsigned int session ; struct sockaddr_atmsvc svc ; } ;

struct atmtcp_hdr { __u16 vpi ; __u16 vci ; __u32 length ; } ;

struct atmtcp_control { struct atmtcp_hdr hdr ; int type ; atm_kptr_t vcc ; struct sockaddr_atmpvc addr ; struct atm_qos qos ; int result ; } ;

struct atm_tcp_ops { int ( * attach ) ( struct atm_vcc * vcc , int itf ) ; int ( * create_persistent ) ( int itf ) ; int ( * remove_persistent ) ( int itf ) ; struct module * owner ; } ;

struct sonet_stats { int section_bip ; int line_bip ; int path_bip ; int line_febe ; int path_febe ; int corr_hcs ; int uncorr_hcs ; int tx_cells ; int rx_cells ; } __attribute__ ( ( packed ) ) ;
struct k_sonet_stats { atomic_t section_bip ; atomic_t line_bip ; atomic_t path_bip ; atomic_t line_febe ; atomic_t path_febe ; atomic_t corr_hcs ; atomic_t uncorr_hcs ; atomic_t tx_cells ; atomic_t rx_cells ; } ;

struct usb_device ;

struct usb_driver ;

struct wusb_dev ;

struct ep_device ;

struct usb_host_ss_ep_comp { struct usb_ss_ep_comp_descriptor desc ; unsigned char * extra ; int extralen ; } ;

struct usb_host_endpoint { struct usb_endpoint_descriptor desc ; struct list_head urb_list ; void * hcpriv ; struct ep_device * ep_dev ; struct usb_host_ss_ep_comp * ss_ep_comp ; unsigned char * extra ; int extralen ; int enabled ; } ;

struct usb_host_interface { struct usb_interface_descriptor desc ; struct usb_host_endpoint * endpoint ; char * string ; unsigned char * extra ; int extralen ; } ;

enum usb_interface_condition { USB_INTERFACE_UNBOUND = 0 , USB_INTERFACE_BINDING , USB_INTERFACE_BOUND , USB_INTERFACE_UNBINDING , } ;

struct usb_interface { struct usb_host_interface * altsetting ; struct usb_host_interface * cur_altsetting ; unsigned num_altsetting ; struct usb_interface_assoc_descriptor * intf_assoc ; int minor ; enum usb_interface_condition condition ; unsigned is_active : 1 ; unsigned sysfs_files_created : 1 ; unsigned ep_devs_created : 1 ; unsigned unregistering : 1 ; unsigned needs_remote_wakeup : 1 ; unsigned needs_altsetting0 : 1 ; unsigned needs_binding : 1 ; unsigned reset_running : 1 ; struct device dev ; struct device * usb_dev ; atomic_t pm_usage_cnt ; struct work_struct reset_ws ; } ;

struct usb_interface_cache { unsigned num_altsetting ; struct kref ref ; struct usb_host_interface altsetting [ 0 ] ; } ;

struct usb_host_config { struct usb_config_descriptor desc ; char * string ; struct usb_interface_assoc_descriptor * intf_assoc [ 32 / 2 ] ; struct usb_interface * interface [ 32 ] ; struct usb_interface_cache * intf_cache [ 32 ] ; unsigned char * extra ; int extralen ; } ;

struct usb_devmap { unsigned long devicemap [ 128 / ( 8 * sizeof ( unsigned long ) ) ] ; } ;

struct usb_bus { struct device * controller ; int busnum ; const char * bus_name ; u8 uses_dma ; u8 otg_port ; unsigned is_b_host : 1 ; unsigned b_hnp_enable : 1 ; int devnum_next ; struct usb_devmap devmap ; struct usb_device * root_hub ; struct list_head bus_list ; int bandwidth_allocated ; int bandwidth_int_reqs ; int bandwidth_isoc_reqs ; struct mon_bus * mon_bus ; int monitored ; } ;

struct usb_tt ;

struct usb_device { int devnum ; char devpath [ 16 ] ; u32 route ; enum usb_device_state state ; enum usb_device_speed speed ; struct usb_tt * tt ; int ttport ; unsigned int toggle [ 2 ] ; struct usb_device * parent ; struct usb_bus * bus ; struct usb_host_endpoint ep0 ; struct device dev ; struct usb_device_descriptor descriptor ; struct usb_host_config * config ; struct usb_host_config * actconfig ; struct usb_host_endpoint * ep_in [ 16 ] ; struct usb_host_endpoint * ep_out [ 16 ] ; char * * rawdescriptors ; unsigned short bus_mA ; u8 portnum ; u8 level ; unsigned can_submit : 1 ; unsigned discon_suspended : 1 ; unsigned persist_enabled : 1 ; unsigned have_langid : 1 ; unsigned authorized : 1 ; unsigned authenticated : 1 ; unsigned wusb : 1 ; int string_langid ; char * product ; char * manufacturer ; char * serial ; struct list_head filelist ; int maxchild ; struct usb_device * children [ ( 31 ) ] ; int pm_usage_cnt ; u32 quirks ; atomic_t urbnum ; unsigned long active_duration ; struct delayed_work autosuspend ; struct work_struct autoresume ; struct mutex pm_mutex ; unsigned long last_busy ; int autosuspend_delay ; unsigned long connect_time ; unsigned auto_pm : 1 ; unsigned do_remote_wakeup : 1 ; unsigned reset_resume : 1 ; unsigned autosuspend_disabled : 1 ; unsigned autoresume_disabled : 1 ; unsigned skip_sys_resume : 1 ; struct wusb_dev * wusb_dev ; int slot_id ; } ;
struct usb_dynids { spinlock_t lock ; struct list_head list ; } ;

struct usb_dynid { struct list_head node ; struct usb_device_id id ; } ;

struct usbdrv_wrap { struct device_driver driver ; int for_devices ; } ;

struct usb_driver { const char * name ; int ( * probe ) ( struct usb_interface * intf , const struct usb_device_id * id ) ; void ( * disconnect ) ( struct usb_interface * intf ) ; int ( * ioctl ) ( struct usb_interface * intf , unsigned int code , void * buf ) ; int ( * suspend ) ( struct usb_interface * intf , pm_message_t message ) ; int ( * resume ) ( struct usb_interface * intf ) ; int ( * reset_resume ) ( struct usb_interface * intf ) ; int ( * pre_reset ) ( struct usb_interface * intf ) ; int ( * post_reset ) ( struct usb_interface * intf ) ; const struct usb_device_id * id_table ; struct usb_dynids dynids ; struct usbdrv_wrap drvwrap ; unsigned int no_dynamic_id : 1 ; unsigned int supports_autosuspend : 1 ; unsigned int soft_unbind : 1 ; } ;
struct usb_device_driver { const char * name ; int ( * probe ) ( struct usb_device * udev ) ; void ( * disconnect ) ( struct usb_device * udev ) ; int ( * suspend ) ( struct usb_device * udev , pm_message_t message ) ; int ( * resume ) ( struct usb_device * udev , pm_message_t message ) ; struct usbdrv_wrap drvwrap ; unsigned int supports_autosuspend : 1 ; } ;

struct usb_class_driver { char * name ; char * ( * devnode ) ( struct device * dev , mode_t * mode ) ; const struct file_operations * fops ; int minor_base ; } ;

struct usb_iso_packet_descriptor { unsigned int offset ; unsigned int length ; unsigned int actual_length ; int status ; } ;

struct urb ;

struct usb_anchor { struct list_head urb_list ; wait_queue_head_t wait ; spinlock_t lock ; unsigned int poisoned : 1 ; } ;

typedef void ( * usb_complete_t ) ( struct urb * ) ;
struct urb { struct kref kref ; void * hcpriv ; atomic_t use_count ; atomic_t reject ; int unlinked ; struct list_head urb_list ; struct list_head anchor_list ; struct usb_anchor * anchor ; struct usb_device * dev ; struct usb_host_endpoint * ep ; unsigned int pipe ; int status ; unsigned int transfer_flags ; void * transfer_buffer ; dma_addr_t transfer_dma ; struct usb_sg_request * sg ; int num_sgs ; u32 transfer_buffer_length ; u32 actual_length ; unsigned char * setup_packet ; dma_addr_t setup_dma ; int start_frame ; int number_of_packets ; int interval ; int error_count ; void * context ; usb_complete_t complete ; struct usb_iso_packet_descriptor iso_frame_desc [ 0 ] ; } ;
struct usb_sg_request { int status ; size_t bytes ; spinlock_t lock ; struct usb_device * dev ; int pipe ; struct scatterlist * sg ; int nents ; int entries ; struct urb * * urbs ; int count ; struct completion complete ; } ;

struct usbdevfs_ctrltransfer { __u8 bRequestType ; __u8 bRequest ; __u16 wValue ; __u16 wIndex ; __u16 wLength ; __u32 timeout ; void * data ; } ;

struct usbdevfs_bulktransfer { unsigned int ep ; unsigned int len ; unsigned int timeout ; void * data ; } ;

struct usbdevfs_setinterface { unsigned int interface ; unsigned int altsetting ; } ;

struct usbdevfs_disconnectsignal { unsigned int signr ; void * context ; } ;

struct usbdevfs_getdriver { unsigned int interface ; char driver [ 255 + 1 ] ; } ;

struct usbdevfs_connectinfo { unsigned int devnum ; unsigned char slow ; } ;

struct usbdevfs_iso_packet_desc { unsigned int length ; unsigned int actual_length ; unsigned int status ; } ;

struct usbdevfs_urb { unsigned char type ; unsigned char endpoint ; int status ; unsigned int flags ; void * buffer ; int buffer_length ; int actual_length ; int start_frame ; int number_of_packets ; int error_count ; unsigned int signr ; void * usercontext ; struct usbdevfs_iso_packet_desc iso_frame_desc [ 0 ] ; } ;

struct usbdevfs_ioctl { int ifno ; int ioctl_code ; void * data ; } ;

struct usbdevfs_hub_portinfo { char nports ; char port [ 127 ] ; } ;

struct usbdevfs_urb32 { unsigned char type ; unsigned char endpoint ; compat_int_t status ; compat_uint_t flags ; compat_caddr_t buffer ; compat_int_t buffer_length ; compat_int_t actual_length ; compat_int_t start_frame ; compat_int_t number_of_packets ; compat_int_t error_count ; compat_uint_t signr ; compat_caddr_t usercontext ; struct usbdevfs_iso_packet_desc iso_frame_desc [ 0 ] ; } ;

struct usbdevfs_ioctl32 { s32 ifno ; s32 ioctl_code ; compat_caddr_t data ; } ;

enum { NBD_CMD_READ = 0 , NBD_CMD_WRITE = 1 , NBD_CMD_DISC = 2 } ;
struct nbd_device { int flags ; int harderror ; struct socket * sock ; struct file * file ; int magic ; spinlock_t queue_lock ; struct list_head queue_head ; struct request * active_req ; wait_queue_head_t active_wq ; struct list_head waiting_queue ; wait_queue_head_t waiting_wq ; struct mutex tx_lock ; struct gendisk * disk ; int blksize ; u64 bytesize ; pid_t pid ; int xmit_timeout ; } ;

struct nbd_request { __be32 magic ; __be32 type ; char handle [ 8 ] ; __be64 from ; __be32 len ; } __attribute__ ( ( packed ) ) ;
struct nbd_reply { __be32 magic ; __be32 error ; char handle [ 8 ] ; } ;

struct pkt_ctrl_command { __u32 command ; __u32 dev_index ; __u32 dev ; __u32 pkt_dev ; __u32 num_devices ; __u32 padding ; } ;

struct packet_settings { __u32 size ; __u8 fp ; __u8 link_loss ; __u8 write_type ; __u8 track_mode ; __u8 block_mode ; } ;

struct packet_stats { unsigned long pkt_started ; unsigned long pkt_ended ; unsigned long secs_w ; unsigned long secs_rg ; unsigned long secs_r ; } ;

struct packet_cdrw { struct list_head pkt_free_list ; struct list_head pkt_active_list ; spinlock_t active_list_lock ; struct task_struct * thread ; atomic_t pending_bios ; } ;

struct packet_iosched { atomic_t attention ; int writing ; spinlock_t lock ; struct bio * read_queue ; struct bio * read_queue_tail ; struct bio * write_queue ; struct bio * write_queue_tail ; sector_t last_write ; int successive_reads ; } ;

enum packet_data_state { PACKET_IDLE_STATE , PACKET_WAITING_STATE , PACKET_READ_WAIT_STATE , PACKET_WRITE_WAIT_STATE , PACKET_RECOVERY_STATE , PACKET_FINISHED_STATE , PACKET_NUM_STATES } ;

struct pktcdvd_device ;

struct packet_data { struct list_head list ; spinlock_t lock ; struct bio * orig_bios ; struct bio * orig_bios_tail ; int write_size ; struct bio * w_bio ; sector_t sector ; int frames ; enum packet_data_state state ; atomic_t run_sm ; long sleep_time ; atomic_t io_wait ; atomic_t io_errors ; struct bio * r_bios [ 128 ] ; struct page * pages [ 128 / ( ( ( 1UL ) << 12 ) / 2048 ) ] ; int cache_valid ; int id ; struct pktcdvd_device * pd ; } ;

struct pkt_rb_node { struct rb_node rb_node ; struct bio * bio ; } ;

struct packet_stacked_data { struct bio * bio ; struct pktcdvd_device * pd ; } ;

struct pktcdvd_kobj { struct kobject kobj ; struct pktcdvd_device * pd ; } ;

struct pktcdvd_device { struct block_device * bdev ; dev_t pkt_dev ; char name [ 20 ] ; struct packet_settings settings ; struct packet_stats stats ; int refcnt ; int write_speed ; int read_speed ; unsigned long offset ; __u8 mode_offset ; __u8 type ; unsigned long flags ; __u16 mmc3_profile ; __u32 nwa ; __u32 lra ; struct packet_cdrw cdrw ; wait_queue_head_t wqueue ; spinlock_t lock ; struct rb_root bio_queue ; int bio_queue_size ; sector_t current_sector ; atomic_t scan_queue ; mempool_t * rb_pool ; struct packet_iosched iosched ; struct gendisk * disk ; int write_congestion_off ; int write_congestion_on ; struct device * dev ; struct pktcdvd_kobj * kobj_stat ; struct pktcdvd_kobj * kobj_wqueue ; struct dentry * dfs_d_root ; struct dentry * dfs_f_info ; } ;
struct hiddev_event { unsigned hid ; signed int value ; } ;

struct hiddev_devinfo { __u32 bustype ; __u32 busnum ; __u32 devnum ; __u32 ifnum ; __s16 vendor ; __s16 product ; __s16 version ; __u32 num_applications ; } ;

struct hiddev_collection_info { __u32 index ; __u32 type ; __u32 usage ; __u32 level ; } ;

struct hiddev_string_descriptor { __s32 index ; char value [ 256 ] ; } ;

struct hiddev_report_info { __u32 report_type ; __u32 report_id ; __u32 num_fields ; } ;

struct hiddev_field_info { __u32 report_type ; __u32 report_id ; __u32 field_index ; __u32 maxusage ; __u32 flags ; __u32 physical ; __u32 logical ; __u32 application ; __s32 logical_minimum ; __s32 logical_maximum ; __s32 physical_minimum ; __s32 physical_maximum ; __u32 unit_exponent ; __u32 unit ; } ;

struct hiddev_usage_ref { __u32 report_type ; __u32 report_id ; __u32 field_index ; __u32 usage_index ; __u32 usage_code ; __s32 value ; } ;

struct hiddev_usage_ref_multi { struct hiddev_usage_ref uref ; __u32 num_values ; __s32 values [ 1024 ] ; } ;

struct hid_device ;

struct hid_usage ;

struct hid_field ;

struct hid_report ;

typedef enum { AUDIO_SOURCE_DEMUX , AUDIO_SOURCE_MEMORY } audio_stream_source_t ;

typedef enum { AUDIO_STOPPED , AUDIO_PLAYING , AUDIO_PAUSED } audio_play_state_t ;

typedef enum { AUDIO_STEREO , AUDIO_MONO_LEFT , AUDIO_MONO_RIGHT , AUDIO_MONO , AUDIO_STEREO_SWAPPED } audio_channel_select_t ;


typedef struct audio_mixer { unsigned int volume_left ; unsigned int volume_right ; } audio_mixer_t ;


typedef struct audio_status { int AV_sync_state ; int mute_state ; audio_play_state_t play_state ; audio_stream_source_t stream_source ; audio_channel_select_t channel_select ; int bypass_mode ; audio_mixer_t mixer_state ; } audio_status_t ;


typedef struct audio_karaoke { int vocal1 ; int vocal2 ; int melody ; } audio_karaoke_t ;

typedef __u16 audio_attributes_t ;

typedef enum { DMX_OUT_DECODER , DMX_OUT_TAP , DMX_OUT_TS_TAP , DMX_OUT_TSDEMUX_TAP } dmx_output_t ;

typedef enum { DMX_IN_FRONTEND , DMX_IN_DVR } dmx_input_t ;

typedef enum { DMX_PES_AUDIO0 , DMX_PES_VIDEO0 , DMX_PES_TELETEXT0 , DMX_PES_SUBTITLE0 , DMX_PES_PCR0 , DMX_PES_AUDIO1 , DMX_PES_VIDEO1 , DMX_PES_TELETEXT1 , DMX_PES_SUBTITLE1 , DMX_PES_PCR1 , DMX_PES_AUDIO2 , DMX_PES_VIDEO2 , DMX_PES_TELETEXT2 , DMX_PES_SUBTITLE2 , DMX_PES_PCR2 , DMX_PES_AUDIO3 , DMX_PES_VIDEO3 , DMX_PES_TELETEXT3 , DMX_PES_SUBTITLE3 , DMX_PES_PCR3 , DMX_PES_OTHER } dmx_pes_type_t ;


typedef struct dmx_filter { __u8 filter [ 16 ] ; __u8 mask [ 16 ] ; __u8 mode [ 16 ] ; } dmx_filter_t ;

struct dmx_sct_filter_params { __u16 pid ; dmx_filter_t filter ; __u32 timeout ; __u32 flags ; } ;

struct dmx_pes_filter_params { __u16 pid ; dmx_input_t input ; dmx_output_t output ; dmx_pes_type_t pes_type ; __u32 flags ; } ;


typedef struct dmx_caps { __u32 caps ; int num_decoders ; } dmx_caps_t ;

typedef enum { DMX_SOURCE_FRONT0 = 0 , DMX_SOURCE_FRONT1 , DMX_SOURCE_FRONT2 , DMX_SOURCE_FRONT3 , DMX_SOURCE_DVR0 = 16 , DMX_SOURCE_DVR1 , DMX_SOURCE_DVR2 , DMX_SOURCE_DVR3 } dmx_source_t ;

struct dmx_stc { unsigned int num ; unsigned int base ; __u64 stc ; } ;


typedef enum fe_type { FE_QPSK , FE_QAM , FE_OFDM , FE_ATSC } fe_type_t ;


typedef enum fe_caps { FE_IS_STUPID = 0 , FE_CAN_INVERSION_AUTO = 0x1 , FE_CAN_FEC_1_2 = 0x2 , FE_CAN_FEC_2_3 = 0x4 , FE_CAN_FEC_3_4 = 0x8 , FE_CAN_FEC_4_5 = 0x10 , FE_CAN_FEC_5_6 = 0x20 , FE_CAN_FEC_6_7 = 0x40 , FE_CAN_FEC_7_8 = 0x80 , FE_CAN_FEC_8_9 = 0x100 , FE_CAN_FEC_AUTO = 0x200 , FE_CAN_QPSK = 0x400 , FE_CAN_QAM_16 = 0x800 , FE_CAN_QAM_32 = 0x1000 , FE_CAN_QAM_64 = 0x2000 , FE_CAN_QAM_128 = 0x4000 , FE_CAN_QAM_256 = 0x8000 , FE_CAN_QAM_AUTO = 0x10000 , FE_CAN_TRANSMISSION_MODE_AUTO = 0x20000 , FE_CAN_BANDWIDTH_AUTO = 0x40000 , FE_CAN_GUARD_INTERVAL_AUTO = 0x80000 , FE_CAN_HIERARCHY_AUTO = 0x100000 , FE_CAN_8VSB = 0x200000 , FE_CAN_16VSB = 0x400000 , FE_HAS_EXTENDED_CAPS = 0x800000 , FE_CAN_2G_MODULATION = 0x10000000 , FE_NEEDS_BENDING = 0x20000000 , FE_CAN_RECOVER = 0x40000000 , FE_CAN_MUTE_TS = 0x80000000 } fe_caps_t ;

struct dvb_frontend_info { char name [ 128 ] ; fe_type_t type ; __u32 frequency_min ; __u32 frequency_max ; __u32 frequency_stepsize ; __u32 frequency_tolerance ; __u32 symbol_rate_min ; __u32 symbol_rate_max ; __u32 symbol_rate_tolerance ; __u32 notifier_delay ; fe_caps_t caps ; } ;

struct dvb_diseqc_master_cmd { __u8 msg [ 6 ] ; __u8 msg_len ; } ;

struct dvb_diseqc_slave_reply { __u8 msg [ 4 ] ; __u8 msg_len ; int timeout ; } ;


typedef enum fe_sec_voltage { SEC_VOLTAGE_13 , SEC_VOLTAGE_18 , SEC_VOLTAGE_OFF } fe_sec_voltage_t ;


typedef enum fe_sec_tone_mode { SEC_TONE_ON , SEC_TONE_OFF } fe_sec_tone_mode_t ;


typedef enum fe_sec_mini_cmd { SEC_MINI_A , SEC_MINI_B } fe_sec_mini_cmd_t ;


typedef enum fe_status { FE_HAS_SIGNAL = 0x01 , FE_HAS_CARRIER = 0x02 , FE_HAS_VITERBI = 0x04 , FE_HAS_SYNC = 0x08 , FE_HAS_LOCK = 0x10 , FE_TIMEDOUT = 0x20 , FE_REINIT = 0x40 } fe_status_t ;


typedef enum fe_spectral_inversion { INVERSION_OFF , INVERSION_ON , INVERSION_AUTO } fe_spectral_inversion_t ;


typedef enum fe_code_rate { FEC_NONE = 0 , FEC_1_2 , FEC_2_3 , FEC_3_4 , FEC_4_5 , FEC_5_6 , FEC_6_7 , FEC_7_8 , FEC_8_9 , FEC_AUTO , FEC_3_5 , FEC_9_10 , } fe_code_rate_t ;


typedef enum fe_modulation { QPSK , QAM_16 , QAM_32 , QAM_64 , QAM_128 , QAM_256 , QAM_AUTO , VSB_8 , VSB_16 , PSK_8 , APSK_16 , APSK_32 , DQPSK , } fe_modulation_t ;


typedef enum fe_transmit_mode { TRANSMISSION_MODE_2K , TRANSMISSION_MODE_8K , TRANSMISSION_MODE_AUTO , TRANSMISSION_MODE_4K } fe_transmit_mode_t ;


typedef enum fe_bandwidth { BANDWIDTH_8_MHZ , BANDWIDTH_7_MHZ , BANDWIDTH_6_MHZ , BANDWIDTH_AUTO } fe_bandwidth_t ;


typedef enum fe_guard_interval { GUARD_INTERVAL_1_32 , GUARD_INTERVAL_1_16 , GUARD_INTERVAL_1_8 , GUARD_INTERVAL_1_4 , GUARD_INTERVAL_AUTO } fe_guard_interval_t ;


typedef enum fe_hierarchy { HIERARCHY_NONE , HIERARCHY_1 , HIERARCHY_2 , HIERARCHY_4 , HIERARCHY_AUTO } fe_hierarchy_t ;

struct dvb_qpsk_parameters { __u32 symbol_rate ; fe_code_rate_t fec_inner ; } ;

struct dvb_qam_parameters { __u32 symbol_rate ; fe_code_rate_t fec_inner ; fe_modulation_t modulation ; } ;

struct dvb_vsb_parameters { fe_modulation_t modulation ; } ;

struct dvb_ofdm_parameters { fe_bandwidth_t bandwidth ; fe_code_rate_t code_rate_HP ; fe_code_rate_t code_rate_LP ; fe_modulation_t constellation ; fe_transmit_mode_t transmission_mode ; fe_guard_interval_t guard_interval ; fe_hierarchy_t hierarchy_information ; } ;

struct dvb_frontend_parameters { __u32 frequency ; fe_spectral_inversion_t inversion ; union { struct dvb_qpsk_parameters qpsk ; struct dvb_qam_parameters qam ; struct dvb_ofdm_parameters ofdm ; struct dvb_vsb_parameters vsb ; } u ; } ;

struct dvb_frontend_event { fe_status_t status ; struct dvb_frontend_parameters parameters ; } ;


typedef enum fe_pilot { PILOT_ON , PILOT_OFF , PILOT_AUTO , } fe_pilot_t ;


typedef enum fe_rolloff { ROLLOFF_35 , ROLLOFF_20 , ROLLOFF_25 , ROLLOFF_AUTO , } fe_rolloff_t ;


typedef enum fe_delivery_system { SYS_UNDEFINED , SYS_DVBC_ANNEX_AC , SYS_DVBC_ANNEX_B , SYS_DVBT , SYS_DSS , SYS_DVBS , SYS_DVBS2 , SYS_DVBH , SYS_ISDBT , SYS_ISDBS , SYS_ISDBC , SYS_ATSC , SYS_ATSCMH , SYS_DMBTH , SYS_CMMB , SYS_DAB , } fe_delivery_system_t ;

struct dtv_cmds_h { char * name ; __u32 cmd ; __u32 set : 1 ; __u32 buffer : 1 ; __u32 reserved : 30 ; } ;

struct dtv_property { __u32 cmd ; __u32 reserved [ 3 ] ; union { __u32 data ; struct { __u8 data [ 32 ] ; __u32 len ; __u32 reserved1 [ 3 ] ; void * reserved2 ; } buffer ; } u ; int result ; } __attribute__ ( ( packed ) ) ;
struct dtv_properties { __u32 num ; struct dtv_property * props ; } ;

typedef enum { VIDEO_FORMAT_4_3 , VIDEO_FORMAT_16_9 , VIDEO_FORMAT_221_1 } video_format_t ;

typedef enum { VIDEO_SYSTEM_PAL , VIDEO_SYSTEM_NTSC , VIDEO_SYSTEM_PALN , VIDEO_SYSTEM_PALNc , VIDEO_SYSTEM_PALM , VIDEO_SYSTEM_NTSC60 , VIDEO_SYSTEM_PAL60 , VIDEO_SYSTEM_PALM60 } video_system_t ;

typedef enum { VIDEO_PAN_SCAN , VIDEO_LETTER_BOX , VIDEO_CENTER_CUT_OUT } video_displayformat_t ;

typedef struct { int w ; int h ; video_format_t aspect_ratio ; } video_size_t ;

typedef enum { VIDEO_SOURCE_DEMUX , VIDEO_SOURCE_MEMORY } video_stream_source_t ;

typedef enum { VIDEO_STOPPED , VIDEO_PLAYING , VIDEO_FREEZED } video_play_state_t ;

struct video_command { __u32 cmd ; __u32 flags ; union { struct { __u64 pts ; } stop ; struct { __s32 speed ; __u32 format ; } play ; struct { __u32 data [ 16 ] ; } raw ; } ; } ;

struct video_event { __s32 type ; __kernel_time_t timestamp ; union { video_size_t size ; unsigned int frame_rate ; unsigned char vsync_field ; } u ; } ;

struct video_status { int video_blank ; video_play_state_t play_state ; video_stream_source_t stream_source ; video_format_t video_format ; video_displayformat_t display_format ; } ;

struct video_still_picture { char * iFrame ; __s32 size ; } ;


typedef struct video_highlight { int active ; __u8 contrast1 ; __u8 contrast2 ; __u8 color1 ; __u8 color2 ; __u32 ypos ; __u32 xpos ; } video_highlight_t ;


typedef struct video_spu { int active ; int stream_id ; } video_spu_t ;


typedef struct video_spu_palette { int length ; __u8 * palette ; } video_spu_palette_t ;


typedef struct video_navi_pack { int length ; __u8 data [ 1024 ] ; } video_navi_pack_t ;

typedef __u16 video_attributes_t ;

struct compat_video_event { int32_t type ; compat_time_t timestamp ; union { video_size_t size ; unsigned int frame_rate ; } u ; } ;

struct compat_video_still_picture { compat_uptr_t iFrame ; int32_t size ; } ;

struct compat_video_spu_palette { int length ; compat_uptr_t palette ; } ;

struct ifmap32 { compat_ulong_t mem_start ; compat_ulong_t mem_end ; unsigned short base_addr ; unsigned char irq ; unsigned char dma ; unsigned char port ; } ;

struct ifreq32 { union { char ifrn_name [ 16 ] ; } ifr_ifrn ; union { struct sockaddr ifru_addr ; struct sockaddr ifru_dstaddr ; struct sockaddr ifru_broadaddr ; struct sockaddr ifru_netmask ; struct sockaddr ifru_hwaddr ; short ifru_flags ; compat_int_t ifru_ivalue ; compat_int_t ifru_mtu ; struct ifmap32 ifru_map ; char ifru_slave [ 16 ] ; char ifru_newname [ 16 ] ; compat_caddr_t ifru_data ; } ifr_ifru ; } ;

struct ifconf32 { compat_int_t ifc_len ; compat_caddr_t ifcbuf ; } ;

struct rtentry32 { u32 rt_pad1 ; struct sockaddr rt_dst ; struct sockaddr rt_gateway ; struct sockaddr rt_genmask ; unsigned short rt_flags ; short rt_pad2 ; u32 rt_pad3 ; unsigned char rt_tos ; unsigned char rt_class ; short rt_pad4 ; short rt_metric ; u32 rt_dev ; u32 rt_mtu ; u32 rt_window ; unsigned short rt_irtt ; } ;

struct in6_rtmsg32 { struct in6_addr rtmsg_dst ; struct in6_addr rtmsg_src ; struct in6_addr rtmsg_gateway ; u32 rtmsg_type ; u16 rtmsg_dst_len ; u16 rtmsg_src_len ; u32 rtmsg_metric ; u32 rtmsg_info ; u32 rtmsg_flags ; s32 rtmsg_ifindex ; } ;


typedef struct sg_io_hdr32 { compat_int_t interface_id ; compat_int_t dxfer_direction ; unsigned char cmd_len ; unsigned char mx_sb_len ; unsigned short iovec_count ; compat_uint_t dxfer_len ; compat_uint_t dxferp ; compat_uptr_t cmdp ; compat_uptr_t sbp ; compat_uint_t timeout ; compat_uint_t flags ; compat_int_t pack_id ; compat_uptr_t usr_ptr ; unsigned char status ; unsigned char masked_status ; unsigned char msg_status ; unsigned char sb_len_wr ; unsigned short host_status ; unsigned short driver_status ; compat_int_t resid ; compat_uint_t duration ; compat_uint_t info ; } sg_io_hdr32_t ;


typedef struct sg_iovec32 { compat_uint_t iov_base ; compat_uint_t iov_len ; } sg_iovec32_t ;

struct compat_sg_req_info { char req_state ; char orphan ; char sg_io_owned ; char problem ; int pack_id ; compat_uptr_t usr_ptr ; unsigned int duration ; int unused ; } ;

struct sock_fprog32 { unsigned short len ; compat_caddr_t filter ; } ;

struct ppp_option_data32 { compat_caddr_t ptr ; u32 length ; compat_int_t transmit ; } ;

struct ppp_idle32 { compat_time_t xmit_idle ; compat_time_t recv_idle ; } ;

struct mtget32 { compat_long_t mt_type ; compat_long_t mt_resid ; compat_long_t mt_dsreg ; compat_long_t mt_gstat ; compat_long_t mt_erreg ; compat_daddr_t mt_fileno ; compat_daddr_t mt_blkno ; } ;

struct mtpos32 { compat_long_t mt_blkno ; } ;

struct consolefontdesc32 { unsigned short charcount ; unsigned short charheight ; compat_caddr_t chardata ; } ;

struct console_font_op32 { compat_uint_t op ; compat_uint_t flags ; compat_uint_t width , height ; compat_uint_t charcount ; compat_caddr_t data ; } ;

struct unimapdesc32 { unsigned short entry_ct ; compat_caddr_t entries ; } ;

struct atmif_sioc32 { compat_int_t number ; compat_int_t length ; compat_caddr_t arg ; } ;

struct atm_iobuf32 { compat_int_t length ; compat_caddr_t buffer ; } ;

struct raw32_config_request { compat_int_t raw_minor ; __u64 block_major ; __u64 block_minor ; } __attribute__ ( ( packed ) ) ;
struct serial_struct32 { compat_int_t type ; compat_int_t line ; compat_uint_t port ; compat_int_t irq ; compat_int_t flags ; compat_int_t xmit_fifo_size ; compat_int_t custom_divisor ; compat_int_t baud_base ; unsigned short close_delay ; char io_type ; char reserved_char [ 1 ] ; compat_int_t hub6 ; unsigned short closing_wait ; unsigned short closing_wait2 ; compat_uint_t iomem_base ; unsigned short iomem_reg_shift ; unsigned int port_high ; compat_int_t reserved [ 1 ] ; } ;

struct usbdevfs_ctrltransfer32 { u8 bRequestType ; u8 bRequest ; u16 wValue ; u16 wIndex ; u16 wLength ; u32 timeout ; compat_caddr_t data ; } ;

struct usbdevfs_bulktransfer32 { compat_uint_t ep ; compat_uint_t len ; compat_uint_t timeout ; compat_caddr_t data ; } ;

struct usbdevfs_disconnectsignal32 { compat_int_t signr ; compat_caddr_t context ; } ;

struct i2c_msg32 { u16 addr ; u16 flags ; u16 len ; compat_caddr_t buf ; } ;

struct i2c_rdwr_ioctl_data32 { compat_caddr_t msgs ; u32 nmsgs ; } ;

struct i2c_smbus_ioctl_data32 { u8 read_write ; u8 command ; u32 size ; compat_caddr_t data ; } ;

struct i2c_rdwr_aligned { struct i2c_rdwr_ioctl_data cmd ; struct i2c_msg msgs [ 0 ] ; } ;

struct space_resv_32 { __s16 l_type ; __s16 l_whence ; __s64 l_start __attribute__ ( ( packed ) ) ; __s64 l_len __attribute__ ( ( packed ) ) ; __s32 l_sysid ; __u32 l_pid ; __s32 l_pad [ 4 ] ; } ;

typedef int ( * ioctl_trans_handler_t ) ( unsigned int , unsigned int , unsigned long , struct file * ) ;
struct ioctl_trans { unsigned long cmd ; ioctl_trans_handler_t handler ; struct ioctl_trans * next ; } ;

long compat_sys_ioctl ( unsigned int fd , unsigned int cmd , unsigned long arg ) ;

long sys_nfsservctl ( int cmd , struct nfsctl_arg * arg , void * res ) ;

struct elf_thread_core_info { struct elf_thread_core_info * next ; struct task_struct * task ; struct elf_prstatus prstatus ; struct memelfnote notes [ 0 ] ; } ;

struct elf_note_info { struct elf_thread_core_info * thread ; struct memelfnote psinfo ; struct memelfnote auxv ; size_t size ; int thread_notes ; } ;

struct compat_elf_siginfo { compat_int_t si_signo ; compat_int_t si_code ; compat_int_t si_errno ; } ;

struct compat_elf_prstatus { struct compat_elf_siginfo pr_info ; short pr_cursig ; compat_ulong_t pr_sigpend ; compat_ulong_t pr_sighold ; compat_pid_t pr_pid ; compat_pid_t pr_ppid ; compat_pid_t pr_pgrp ; compat_pid_t pr_sid ; struct compat_timeval pr_utime ; struct compat_timeval pr_stime ; struct compat_timeval pr_cutime ; struct compat_timeval pr_cstime ; compat_elf_gregset_t pr_reg ; compat_int_t pr_fpvalid ; } ;

struct compat_elf_prpsinfo { char pr_state ; char pr_sname ; char pr_zomb ; char pr_nice ; compat_ulong_t pr_flag ; __compat_uid_t pr_uid ; __compat_gid_t pr_gid ; compat_pid_t pr_pid , pr_ppid , pr_pgrp , pr_sid ; char pr_fname [ 16 ] ; char pr_psargs [ ( 80 ) ] ; } ;

struct elf_thread_core_info { struct elf_thread_core_info * next ; struct task_struct * task ; struct compat_elf_prstatus prstatus ; struct memelfnote notes [ 0 ] ; } ;
struct mb_cache { struct list_head c_cache_list ; const char * c_name ; struct mb_cache_op c_op ; atomic_t c_entry_count ; int c_bucket_bits ; struct kmem_cache * c_entry_cache ; struct list_head * c_block_hash ; struct list_head * c_indexes_hash [ 0 ] ; } ;

struct mb_cache * mb_cache_create ( const char * name , struct mb_cache_op * cache_op , size_t entry_size , int indexes_count , int bucket_bits ) ;

void mb_cache_shrink ( struct block_device * bdev ) ;

void mb_cache_destroy ( struct mb_cache * cache ) ;

struct mb_cache_entry * mb_cache_entry_alloc ( struct mb_cache * cache , gfp_t gfp_flags ) ;

int mb_cache_entry_insert ( struct mb_cache_entry * ce , struct block_device * bdev , sector_t block , unsigned int keys [ ] ) ;

void mb_cache_entry_release ( struct mb_cache_entry * ce ) ;

void mb_cache_entry_free ( struct mb_cache_entry * ce ) ;

struct mb_cache_entry * mb_cache_entry_get ( struct mb_cache * cache , struct block_device * bdev , sector_t block ) ;

struct mb_cache_entry * mb_cache_entry_find_first ( struct mb_cache * cache , int index , struct block_device * bdev , unsigned int key ) ;

struct mb_cache_entry * mb_cache_entry_find_next ( struct mb_cache_entry * prev , int index , struct block_device * bdev , unsigned int key ) ;

struct posix_acl * posix_acl_alloc ( int count , gfp_t flags ) ;

struct posix_acl * posix_acl_clone ( const struct posix_acl * acl , gfp_t flags ) ;

int posix_acl_valid ( const struct posix_acl * acl ) ;

int posix_acl_equiv_mode ( const struct posix_acl * acl , mode_t * mode_p ) ;

struct posix_acl * posix_acl_from_mode ( mode_t mode , gfp_t flags ) ;

int posix_acl_permission ( struct inode * inode , const struct posix_acl * acl , int want ) ;

int posix_acl_create_masq ( struct posix_acl * acl , mode_t * mode_p ) ;

int posix_acl_chmod_masq ( struct posix_acl * acl , mode_t mode ) ;

struct posix_acl * posix_acl_from_xattr ( const void * value , size_t size ) ;

int posix_acl_to_xattr ( const struct posix_acl * acl , void * buffer , size_t size ) ;

size_t generic_acl_list ( struct inode * inode , struct generic_acl_operations * ops , int type , char * list , size_t list_size ) ;

int generic_acl_get ( struct inode * inode , struct generic_acl_operations * ops , int type , void * buffer , size_t size ) ;

int generic_acl_set ( struct inode * inode , struct generic_acl_operations * ops , int type , const void * value , size_t size ) ;

int generic_acl_init ( struct inode * inode , struct inode * dir , struct generic_acl_operations * ops ) ;

int generic_acl_chmod ( struct inode * inode , struct generic_acl_operations * ops ) ;

struct dcookie_struct { struct path path ; struct list_head hash_list ; } ;

int get_dcookie ( struct path * path , unsigned long * cookie ) ;

long sys_lookup_dcookie ( u64 cookie64 , char * buf , size_t len ) ;

struct dcookie_user { struct list_head next ; } ;
struct dcookie_user * dcookie_register ( void ) ;

void dcookie_unregister ( struct dcookie_user * user ) ;

struct ipc_params { key_t key ; int flg ; union { size_t size ; int nsems ; } u ; } ;

struct ipc_ops { int ( * getnew ) ( struct ipc_namespace * , struct ipc_params * ) ; int ( * associate ) ( struct kern_ipc_perm * , int ) ; int ( * more_checks ) ( struct kern_ipc_perm * , struct ipc_params * ) ; } ;

struct ipc_ids ;
struct compat_msgbuf { compat_long_t mtype ; char mtext [ 1 ] ; } ;

struct compat_ipc_perm { key_t key ; __compat_uid_t uid ; __compat_gid_t gid ; __compat_uid_t cuid ; __compat_gid_t cgid ; compat_mode_t mode ; unsigned short seq ; } ;

struct compat_semid_ds { struct compat_ipc_perm sem_perm ; compat_time_t sem_otime ; compat_time_t sem_ctime ; compat_uptr_t sem_base ; compat_uptr_t sem_pending ; compat_uptr_t sem_pending_last ; compat_uptr_t undo ; unsigned short sem_nsems ; } ;

struct compat_msqid_ds { struct compat_ipc_perm msg_perm ; compat_uptr_t msg_first ; compat_uptr_t msg_last ; compat_time_t msg_stime ; compat_time_t msg_rtime ; compat_time_t msg_ctime ; compat_ulong_t msg_lcbytes ; compat_ulong_t msg_lqbytes ; unsigned short msg_cbytes ; unsigned short msg_qnum ; unsigned short msg_qbytes ; compat_ipc_pid_t msg_lspid ; compat_ipc_pid_t msg_lrpid ; } ;

struct compat_shmid_ds { struct compat_ipc_perm shm_perm ; int shm_segsz ; compat_time_t shm_atime ; compat_time_t shm_dtime ; compat_time_t shm_ctime ; compat_ipc_pid_t shm_cpid ; compat_ipc_pid_t shm_lpid ; unsigned short shm_nattch ; unsigned short shm_unused ; compat_uptr_t shm_unused2 ; compat_uptr_t shm_unused3 ; } ;

struct compat_ipc_kludge { compat_uptr_t msgp ; compat_long_t msgtyp ; } ;

struct compat_shminfo64 { compat_ulong_t shmmax ; compat_ulong_t shmmin ; compat_ulong_t shmmni ; compat_ulong_t shmseg ; compat_ulong_t shmall ; compat_ulong_t __unused1 ; compat_ulong_t __unused2 ; compat_ulong_t __unused3 ; compat_ulong_t __unused4 ; } ;

struct compat_shm_info { compat_int_t used_ids ; compat_ulong_t shm_tot , shm_rss , shm_swp ; compat_ulong_t swap_attempts , swap_successes ; } ;

long compat_sys_semctl ( int first , int second , int third , void * uptr ) ;

long compat_sys_msgsnd ( int first , int second , int third , void * uptr ) ;

long compat_sys_msgrcv ( int first , int second , int msgtyp , int third , int version , void * uptr ) ;

long compat_sys_msgctl ( int first , int second , void * uptr ) ;

long compat_sys_shmat ( int first , int second , compat_uptr_t third , int version , void * uptr ) ;

long compat_sys_shmctl ( int first , int second , void * uptr ) ;

long compat_sys_semtimedop ( int semid , struct sembuf * tsems , unsigned nsops , const struct compat_timespec * timeout ) ;

struct ipc_proc_iface { const char * path ; const char * header ; int ids ; int ( * show ) ( struct seq_file * , void * ) ; } ;

void ipc_init_ids ( struct ipc_ids * ids ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ipc_init_proc_interface ( const char * path , const char * header , int ids , int ( * show ) ( struct seq_file * , void * ) ) ;

int ipc_get_maxid ( struct ipc_ids * ids ) ;

int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) ;

void ipc_rmid ( struct ipc_ids * ids , struct kern_ipc_perm * ipcp ) ;

void * ipc_alloc ( int size ) ;

void ipc_free ( void * ptr , int size ) ;

struct ipc_rcu_hdr { int refcount ; int is_vmalloc ; void * data [ 0 ] ; } ;

struct ipc_rcu_grace { struct rcu_head rcu ; void * data [ 0 ] ; } ;

struct ipc_rcu_sched { struct work_struct work ; void * data [ 0 ] ; } ;

void * ipc_rcu_alloc ( int size ) ;

void ipc_rcu_getref ( void * ptr ) ;

void ipc_rcu_putref ( void * ptr ) ;

int ipcperms ( struct kern_ipc_perm * ipcp , short flag ) ;

void kernel_to_ipc64_perm ( struct kern_ipc_perm * in , struct ipc64_perm * out ) ;

void ipc64_perm_to_ipc_perm ( struct ipc64_perm * in , struct ipc_perm * out ) ;

struct kern_ipc_perm * ipc_lock ( struct ipc_ids * ids , int id ) ;

struct kern_ipc_perm * ipc_lock_check ( struct ipc_ids * ids , int id ) ;

int ipcget ( struct ipc_namespace * ns , struct ipc_ids * ids , struct ipc_ops * ops , struct ipc_params * params ) ;

void ipc_update_perm ( struct ipc64_perm * in , struct kern_ipc_perm * out ) ;

struct kern_ipc_perm * ipcctl_pre_down ( struct ipc_ids * ids , int id , int cmd , struct ipc64_perm * perm , int extra_perm ) ;

struct ipc_proc_iter { struct ipc_namespace * ns ; struct ipc_proc_iface * iface ; } ;

struct msg_msgseg { struct msg_msgseg * next ; } ;

struct msg_msg * load_msg ( const void * src , int len ) ;

int store_msg ( void * dest , struct msg_msg * msg , int len ) ;

void free_msg ( struct msg_msg * msg ) ;

struct msg_receiver { struct list_head r_list ; struct task_struct * r_tsk ; int r_mode ; long r_msgtype ; long r_maxsize ; struct msg_msg * volatile r_msg ; } ;

struct msg_sender { struct list_head list ; struct task_struct * tsk ; } ;

void recompute_msgmni ( struct ipc_namespace * ns ) ;

void msg_init_ns ( struct ipc_namespace * ns ) ;

void msg_exit_ns ( struct ipc_namespace * ns ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) msg_init ( void ) ;

long sys_msgget ( key_t key , int msgflg ) ;

long sys_msgctl ( int msqid , int cmd , struct msqid_ds * buf ) ;

long do_msgsnd ( int msqid , long mtype , void * mtext , size_t msgsz , int msgflg ) ;

long sys_msgsnd ( int msqid , struct msgbuf * msgp , size_t msgsz , int msgflg ) ;

long do_msgrcv ( int msqid , long * pmtype , void * mtext , size_t msgsz , long msgtyp , int msgflg ) ;

long sys_msgrcv ( int msqid , struct msgbuf * msgp , size_t msgsz , long msgtyp , int msgflg ) ;

void sem_init_ns ( struct ipc_namespace * ns ) ;

void sem_exit_ns ( struct ipc_namespace * ns ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sem_init ( void ) ;

long sys_semget ( key_t key , int nsems , int semflg ) ;

long sys_semctl ( int semid , int semnum , int cmd , union semun arg ) ;

long sys_semtimedop ( int semid , struct sembuf * tsops , unsigned nsops , const struct timespec * timeout ) ;

long sys_semop ( int semid , struct sembuf * tsops , unsigned nsops ) ;

int copy_semundo ( unsigned long clone_flags , struct task_struct * tsk ) ;

void exit_sem ( struct task_struct * tsk ) ;

struct shm_file_data { int id ; struct ipc_namespace * ns ; struct file * file ; const struct vm_operations_struct * vm_ops ; } ;

void shm_init_ns ( struct ipc_namespace * ns ) ;

void shm_exit_ns ( struct ipc_namespace * ns ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) shm_init ( void ) ;

int is_file_shm_hugepages ( struct file * file ) ;

long sys_shmget ( key_t key , size_t size , int shmflg ) ;

long sys_shmctl ( int shmid , int cmd , struct shmid_ds * buf ) ;

long do_shmat ( int shmid , char * shmaddr , int shmflg , ulong * raddr ) ;

long sys_shmat ( int shmid , char * shmaddr , int shmflg ) ;

long sys_shmdt ( char * shmaddr ) ;

int register_ipcns_notifier ( struct ipc_namespace * ns ) ;

int cond_register_ipcns_notifier ( struct ipc_namespace * ns ) ;

void unregister_ipcns_notifier ( struct ipc_namespace * ns ) ;

int ipcns_notify ( unsigned long val ) ;

struct ext_wait_queue { struct task_struct * task ; struct list_head list ; struct msg_msg * msg ; int state ; } ;

struct mqueue_inode_info { spinlock_t lock ; struct inode vfs_inode ; wait_queue_head_t wait_q ; struct msg_msg * * messages ; struct mq_attr attr ; struct sigevent notify ; struct pid * notify_owner ; struct user_struct * user ; struct sock * notify_sock ; struct sk_buff * notify_cookie ; struct ext_wait_queue e_wait_q [ 2 ] ; unsigned long qsize ; } ;

long sys_mq_open ( const char * u_name , int oflag , mode_t mode , struct mq_attr * u_attr ) ;

long sys_mq_unlink ( const char * u_name ) ;

long sys_mq_timedsend ( mqd_t mqdes , const char * u_msg_ptr , size_t msg_len , unsigned int msg_prio , const struct timespec * u_abs_timeout ) ;

long sys_mq_timedreceive ( mqd_t mqdes , char * u_msg_ptr , size_t msg_len , unsigned int * u_msg_prio , const struct timespec * u_abs_timeout ) ;

long sys_mq_notify ( mqd_t mqdes , const struct sigevent * u_notification ) ;

long sys_mq_getsetattr ( mqd_t mqdes , const struct mq_attr * u_mqstat , struct mq_attr * u_omqstat ) ;

int mq_init_ns ( struct ipc_namespace * ns ) ;

void mq_clear_sbinfo ( struct ipc_namespace * ns ) ;

void mq_put_mnt ( struct ipc_namespace * ns ) ;

struct compat_mq_attr { compat_long_t mq_flags ; compat_long_t mq_maxmsg ; compat_long_t mq_msgsize ; compat_long_t mq_curmsgs ; compat_long_t __reserved [ 4 ] ; } ;

long compat_sys_mq_open ( const char * u_name , int oflag , compat_mode_t mode , struct compat_mq_attr * u_attr ) ;

long compat_sys_mq_timedsend ( mqd_t mqdes , const char * u_msg_ptr , size_t msg_len , unsigned int msg_prio , const struct compat_timespec * u_abs_timeout ) ;

ssize_t compat_sys_mq_timedreceive ( mqd_t mqdes , char * u_msg_ptr , size_t msg_len , unsigned int * u_msg_prio , const struct compat_timespec * u_abs_timeout ) ;

long compat_sys_mq_notify ( mqd_t mqdes , const struct compat_sigevent * u_notification ) ;

long compat_sys_mq_getsetattr ( mqd_t mqdes , const struct compat_mq_attr * u_mqstat , struct compat_mq_attr * u_omqstat ) ;

struct ipc_namespace * copy_ipcs ( unsigned long flags , struct ipc_namespace * ns ) ;

void free_ipcs ( struct ipc_namespace * ns , struct ipc_ids * ids , void ( * free ) ( struct ipc_namespace * , struct kern_ipc_perm * ) ) ;

void put_ipc_ns ( struct ipc_namespace * ns ) ;

struct ctl_table_header * mq_register_sysctl_table ( void ) ;

struct table_set_header { u32 th_magic ; u32 th_hsize ; u32 th_ssize ; u16 th_flags ; char th_version [ ] ; } ;

struct table_header { u16 td_id ; u16 td_flags ; u32 td_hilen ; u32 td_lolen ; char td_data [ ] ; } ;

struct aa_dfa { struct kref count ; u16 flags ; struct table_header * tables [ 8 ] ; } ;

struct aa_profile ;

enum audit_mode { AUDIT_NORMAL , AUDIT_QUIET_DENIED , AUDIT_QUIET , AUDIT_NOQUIET , AUDIT_ALL } ;

struct aa_audit { struct task_struct * task ; gfp_t gfp_mask ; int error ; const char * operation ; const char * info ; } ;

struct aa_caps { kernel_cap_t allowed ; kernel_cap_t audit ; kernel_cap_t quiet ; kernel_cap_t kill ; kernel_cap_t extended ; } ;

struct aa_domain { int size ; char * * table ; } ;

struct path_cond { uid_t uid ; umode_t mode ; } ;

struct file_perms { u16 allowed ; u16 audit ; u16 quiet ; u16 kill ; u16 xindex ; u16 xdelegate ; u16 dindex ; } ;

struct aa_audit_file { struct aa_audit base ; const char * name ; const char * name2 ; const char * name3 ; struct file_perms perms ; u16 request ; struct path_cond * cond ; } ;

struct aa_file_rules { unsigned int start ; struct aa_dfa * dfa ; struct aa_domain trans ; } ;

struct aa_net { u16 allowed [ 37 ] ; u16 audit [ 37 ] ; u16 quiet [ 37 ] ; } ;

struct aa_rlimit { unsigned int mask ; struct rlimit limits [ 16 ] ; } ;

enum profile_mode { APPARMOR_ENFORCE , APPARMOR_COMPLAIN , APPARMOR_KILL , } ;

enum profile_flags { PFLAG_HAT = 1 , PFLAG_UNCONFINED = 2 , PFLAG_NULL = 4 , PFLAG_IX_ON_NAME_ERROR = 8 , PFLAG_IMMUTABLE = 0x10 , PFLAG_USER_DEFINED = 0x20 , PFLAG_NO_LIST_REF = 0x40 , PFLAG_MMAP_MIN_ADDR = 0x80 , PFLAG_OLD_NULL_TRANS = 0x100 , PFLAG_MEDIATE_DELETED = 0x10000 , } ;

struct aa_policy { char * name ; char * hname ; struct kref count ; struct list_head list ; struct list_head profiles ; } ;

struct aa_ns_acct { int max_size ; int max_count ; int size ; int count ; } ;

struct aa_namespace { struct aa_policy base ; struct aa_namespace * parent ; rwlock_t lock ; struct aa_ns_acct acct ; struct aa_profile * unconfined ; struct list_head sub_ns ; } ;

struct aa_profile { struct aa_policy base ; struct aa_profile * parent ; struct aa_namespace * ns ; union { struct aa_profile * replacedby ; const char * rename ; } ; struct aa_dfa * xmatch ; int xmatch_len ; u32 sid ; enum audit_mode audit ; enum profile_mode mode ; u32 flags ; u32 path_flags ; int size ; unsigned long mmap_min_addr ; struct aa_file_rules file ; struct aa_caps caps ; struct aa_net net ; struct aa_rlimit rlimits ; } ;
struct aa_file_cxt { struct aa_profile * profile ; u16 allowed ; } ;

struct aa_task_cxt { struct aa_profile * profile ; struct aa_profile * onexec ; struct aa_profile * previous ; u64 token ; } ;

void aa_destroy_aafs ( void ) ;

int aa_create_aafs ( void ) ;

int aa_audit ( int type , struct aa_profile * profile , struct aa_audit * sa , void ( * cb ) ( struct audit_buffer * , struct aa_audit * ) ) ;
struct audit_cache { struct aa_profile * profile ; kernel_cap_t caps ; } ;

struct aa_audit_caps { struct aa_audit base ; int cap ; } ;

int aa_capable ( struct task_struct * task , struct aa_profile * profile , int cap , int audit ) ;

struct aa_task_cxt * aa_alloc_task_context ( gfp_t flags ) ;

void aa_free_task_context ( struct aa_task_cxt * cxt ) ;

void aa_dup_task_context ( struct aa_task_cxt * new , const struct aa_task_cxt * old ) ;

int aa_replace_current_profiles ( struct aa_profile * profile ) ;

int aa_set_current_onexec ( struct aa_profile * profile ) ;

int aa_set_current_hat ( struct aa_profile * profile , u64 token ) ;

int aa_restore_previous_profile ( u64 token ) ;

struct aa_audit_ptrace { struct aa_audit base ; pid_t tracer , tracee ; } ;

int aa_may_ptrace ( struct task_struct * tracer_task , struct aa_profile * tracer , struct aa_profile * tracee , unsigned int mode ) ;

int aa_ptrace ( struct task_struct * tracer , struct task_struct * tracee , unsigned int mode ) ;

char * skip_spaces ( const char * str ) ;

char * aa_split_fqname ( char * fqname , char * * ns_name ) ;

bool aa_strneq ( const char * str , const char * sub , int len ) ;

void aa_info_message ( const char * str ) ;

void aa_dfa_free_kref ( struct kref * kref ) ;

struct aa_dfa * aa_dfa_unpack ( void * blob , size_t size , int flags ) ;

unsigned int aa_dfa_match_len ( struct aa_dfa * dfa , unsigned int start , const char * str , int len ) ;

unsigned int aa_dfa_match ( struct aa_dfa * dfa , unsigned int start , const char * str ) ;

enum path_flags { PATH_IS_DIR = 0x1 , PATH_CONNECT_PATH = 0x4 , PATH_CHROOT_REL = 0x8 , PATH_CHROOT_NSCONNECT = 0x10 , PATH_MEDIATE_DELETED = 0x10000 , } ;

int aa_get_name ( struct path * path , int flags , char * * buffer , char * * name ) ;

char * sysctl_pathname ( struct ctl_table * table , char * buffer , int buflen ) ;

void aa_free_domain_entries ( struct aa_domain * domain ) ;

int apparmor_bprm_set_creds ( struct linux_binprm * bprm ) ;

int apparmor_bprm_secureexec ( struct linux_binprm * bprm ) ;

void apparmor_bprm_committing_creds ( struct linux_binprm * bprm ) ;

void apparmor_bprm_committed_creds ( struct linux_binprm * bprm ) ;

int aa_change_hat ( const char * hats [ ] , int count , u64 token , bool permtest ) ;

int aa_change_profile ( const char * ns_name , const char * hname , int onexec , bool permtest ) ;

struct aa_audit_iface { struct aa_audit base ; const char * name ; const char * name2 ; long pos ; } ;

void aa_free_namespace_kref ( struct kref * kref ) ;

struct aa_namespace * aa_find_namespace ( struct aa_namespace * root , const char * name ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) aa_alloc_root_ns ( void ) ;

void aa_free_root_ns ( void ) ;

struct aa_profile * aa_alloc_profile ( const char * hname ) ;

struct aa_profile * aa_new_null_profile ( struct aa_profile * parent , int hat ) ;

void aa_free_profile_kref ( struct kref * kref ) ;

struct aa_profile * aa_find_child ( struct aa_profile * parent , const char * name ) ;

struct aa_profile * aa_find_profile ( struct aa_namespace * ns , const char * hname ) ;

ssize_t aa_interface_replace_profiles ( void * udata , size_t size , bool add_only ) ;

ssize_t aa_interface_remove_profiles ( char * fqname , size_t size ) ;

enum aa_code { AA_U8 , AA_U16 , AA_U32 , AA_U64 , AA_NAME , AA_STRING , AA_BLOB , AA_STRUCT , AA_STRUCTEND , AA_LIST , AA_LISTEND , AA_ARRAY , AA_ARRAYEND , } ;

struct aa_ext { void * start ; void * end ; void * pos ; u32 version ; } ;

int aa_audit_iface ( struct aa_audit_iface * sa ) ;
struct aa_profile * aa_unpack ( void * udata , size_t size , struct aa_audit_iface * sa ) ;

int aa_getprocattr ( struct aa_profile * profile , char * * string ) ;

int aa_setprocattr_changehat ( char * args , size_t size , int test ) ;

int aa_setprocattr_changeprofile ( char * fqname , int onexec , int test ) ;

int aa_setprocattr_permipc ( char * fqname ) ;

struct aa_audit_resource { struct aa_audit base ; int rlimit ; } ;

int aa_task_setrlimit ( struct aa_profile * profile , unsigned int resource , struct rlimit * new_rlim ) ;

void __aa_transition_rlimits ( struct aa_profile * old , struct aa_profile * new ) ;

u32 aa_alloc_sid ( void ) ;

void aa_free_sid ( u32 sid ) ;

int aa_audit_file ( struct aa_profile * profile , struct aa_audit_file * sa ) ;
struct file_perms aa_str_perms ( struct aa_dfa * dfa , unsigned int start , const char * name , struct path_cond * cond , unsigned int * rstate ) ;

int aa_pathstr_perm ( struct aa_profile * profile , const char * op , const char * name , u16 request , struct path_cond * cond ) ;

int aa_path_perm ( struct aa_profile * profile , const char * operation , struct path * path , u16 request , struct path_cond * cond ) ;

int aa_path_link ( struct aa_profile * profile , struct dentry * old_dentry , struct path * new_dir , struct dentry * new_dentry ) ;

int aa_file_perm ( struct aa_profile * profile , const char * operation , struct file * file , u16 request ) ;

struct aa_audit_net { struct aa_audit base ; int family , type , protocol ; } ;

int aa_net_perm ( struct aa_profile * profile , char * operation , int family , int type , int protocol ) ;

int aa_revalidate_sk ( struct sock * sk , char * operation ) ;

struct keyring_list { struct rcu_head rcu ; unsigned short maxkeys ; unsigned short nkeys ; unsigned short delkey ; struct key * keys [ 0 ] ; } ;
struct key_construction { struct key * key ; struct key * authkey ; } ;

typedef int ( * request_key_actor_t ) ( struct key_construction * key , const char * op , void * aux ) ;
struct key_type { const char * name ; size_t def_datalen ; int ( * instantiate ) ( struct key * key , const void * data , size_t datalen ) ; int ( * update ) ( struct key * key , const void * data , size_t datalen ) ; int ( * match ) ( const struct key * key , const void * desc ) ; void ( * revoke ) ( struct key * key ) ; void ( * destroy ) ( struct key * key ) ; void ( * describe ) ( const struct key * key , struct seq_file * p ) ; long ( * read ) ( const struct key * key , char * buffer , size_t buflen ) ; request_key_actor_t request_key ; struct list_head link ; } ;
struct key_user { struct rb_node node ; struct mutex cons_lock ; spinlock_t lock ; atomic_t usage ; atomic_t nkeys ; atomic_t nikeys ; uid_t uid ; struct user_namespace * user_ns ; int qnkeys ; int qnbytes ; } ;

typedef int ( * key_match_func_t ) ( const struct key * , const void * ) ;
struct request_key_auth { struct key * target_key ; struct key * dest_keyring ; const struct cred * cred ; void * callout_info ; size_t callout_len ; pid_t pid ; } ;

void key_schedule_gc ( time_t gc_at ) ;

struct key_user * key_user_lookup ( uid_t uid , struct user_namespace * user_ns ) ;

void key_user_put ( struct key_user * user ) ;

struct key * key_alloc ( struct key_type * type , const char * desc , uid_t uid , gid_t gid , const struct cred * cred , key_perm_t perm , unsigned long flags ) ;

int key_payload_reserve ( struct key * key , size_t datalen ) ;

int key_instantiate_and_link ( struct key * key , const void * data , size_t datalen , struct key * keyring , struct key * authkey ) ;

int key_negate_and_link ( struct key * key , unsigned timeout , struct key * keyring , struct key * authkey ) ;

void key_put ( struct key * key ) ;

struct key * key_lookup ( key_serial_t id ) ;

struct key_type * key_type_lookup ( const char * type ) ;

void key_type_put ( struct key_type * ktype ) ;

key_ref_t key_create_or_update ( key_ref_t keyring_ref , const char * type , const char * description , const void * payload , size_t plen , key_perm_t perm , unsigned long flags ) ;

int key_update ( key_ref_t key_ref , const void * payload , size_t plen ) ;

void key_revoke ( struct key * key ) ;

int register_key_type ( struct key_type * ktype ) ;

void unregister_key_type ( struct key_type * ktype ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) key_init ( void ) ;

struct key * keyring_alloc ( const char * description , uid_t uid , gid_t gid , const struct cred * cred , unsigned long flags , struct key * dest ) ;

key_ref_t keyring_search_aux ( key_ref_t keyring_ref , const struct cred * cred , struct key_type * type , const void * description , key_match_func_t match ) ;

key_ref_t keyring_search ( key_ref_t keyring , struct key_type * type , const char * description ) ;

key_ref_t __keyring_search_one ( key_ref_t keyring_ref , const struct key_type * ktype , const char * description , key_perm_t perm ) ;

struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) ;

int __key_link ( struct key * keyring , struct key * key ) ;

int key_link ( struct key * keyring , struct key * key ) ;

int key_unlink ( struct key * keyring , struct key * key ) ;

int keyring_clear ( struct key * keyring ) ;

void keyring_gc ( struct key * keyring , time_t limit ) ;

long sys_add_key ( const char * _type , const char * _description , const void * _payload , size_t plen , key_serial_t ringid ) ;

long sys_request_key ( const char * _type , const char * _description , const char * _callout_info , key_serial_t destringid ) ;

long keyctl_get_keyring_ID ( key_serial_t id , int create ) ;

long keyctl_join_session_keyring ( const char * _name ) ;

long keyctl_update_key ( key_serial_t id , const void * _payload , size_t plen ) ;

long keyctl_revoke_key ( key_serial_t id ) ;

long keyctl_keyring_clear ( key_serial_t ringid ) ;

long keyctl_keyring_link ( key_serial_t id , key_serial_t ringid ) ;

long keyctl_keyring_unlink ( key_serial_t id , key_serial_t ringid ) ;

long keyctl_describe_key ( key_serial_t keyid , char * buffer , size_t buflen ) ;

long keyctl_keyring_search ( key_serial_t ringid , const char * _type , const char * _description , key_serial_t destringid ) ;

long keyctl_read_key ( key_serial_t keyid , char * buffer , size_t buflen ) ;

long keyctl_chown_key ( key_serial_t id , uid_t uid , gid_t gid ) ;

long keyctl_setperm_key ( key_serial_t id , key_perm_t perm ) ;

long keyctl_instantiate_key ( key_serial_t id , const void * _payload , size_t plen , key_serial_t ringid ) ;

long keyctl_negate_key ( key_serial_t id , unsigned timeout , key_serial_t ringid ) ;

long keyctl_set_reqkey_keyring ( int reqkey_defl ) ;

long keyctl_set_timeout ( key_serial_t id , unsigned timeout ) ;

long keyctl_assume_authority ( key_serial_t id ) ;

long keyctl_get_security ( key_serial_t keyid , char * buffer , size_t buflen ) ;

long keyctl_session_to_parent ( void ) ;

long sys_keyctl ( int option , unsigned long arg2 , unsigned long arg3 , unsigned long arg4 , unsigned long arg5 ) ;

int key_task_permission ( const key_ref_t key_ref , const struct cred * cred , key_perm_t perm ) ;

int key_validate ( struct key * key ) ;

int install_user_keyrings ( void ) ;

int install_thread_keyring_to_cred ( struct cred * new ) ;

int install_process_keyring_to_cred ( struct cred * new ) ;

void key_fsuid_changed ( struct task_struct * tsk ) ;

void key_fsgid_changed ( struct task_struct * tsk ) ;

key_ref_t search_process_keyrings ( struct key_type * type , const void * description , key_match_func_t match , const struct cred * cred ) ;

key_ref_t lookup_user_key ( key_serial_t id , unsigned long lflags , key_perm_t perm ) ;

long join_session_keyring ( const char * name ) ;

void key_replace_session_keyring ( void ) ;

void complete_request_key ( struct key_construction * cons , int error ) ;

struct key * request_key_and_link ( struct key_type * type , const char * description , const void * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) ;

int wait_for_key_construction ( struct key * key , bool intr ) ;

struct key * request_key ( struct key_type * type , const char * description , const char * callout_info ) ;

struct key * request_key_with_auxdata ( struct key_type * type , const char * description , const void * callout_info , size_t callout_len , void * aux ) ;

struct key * request_key_async ( struct key_type * type , const char * description , const void * callout_info , size_t callout_len ) ;

struct key * request_key_async_with_auxdata ( struct key_type * type , const char * description , const void * callout_info , size_t callout_len , void * aux ) ;

struct key * request_key_auth_new ( struct key * target , const void * callout_info , size_t callout_len , struct key * dest_keyring ) ;

struct key * key_get_instantiation_authkey ( key_serial_t target_id ) ;

int user_instantiate ( struct key * key , const void * data , size_t datalen ) ;

int user_update ( struct key * key , const void * data , size_t datalen ) ;

int user_match ( const struct key * key , const void * description ) ;

void user_revoke ( struct key * key ) ;

void user_destroy ( struct key * key ) ;

void user_describe ( const struct key * key , struct seq_file * m ) ;

long user_read ( const struct key * key , char * buffer , size_t buflen ) ;

struct sockaddr_un { sa_family_t sun_family ; char sun_path [ 108 ] ; } ;

struct unix_address { atomic_t refcnt ; int len ; unsigned hash ; struct sockaddr_un name [ 0 ] ; } ;

struct unix_skb_parms { struct ucred creds ; struct scm_fp_list * fp ; u32 secid ; } ;

struct unix_sock { struct sock sk ; struct unix_address * addr ; struct dentry * dentry ; struct vfsmount * mnt ; struct mutex readlock ; struct sock * peer ; struct sock * other ; struct list_head link ; atomic_long_t inflight ; spinlock_t lock ; unsigned int gc_candidate : 1 ; unsigned int gc_maybe_cycle : 1 ; wait_queue_head_t peer_wait ; } ;

struct common_audit_data { char type ; struct task_struct * tsk ; union { struct { struct path path ; struct inode * inode ; } fs ; struct { int netif ; struct sock * sk ; u16 family ; __be16 dport ; __be16 sport ; union { struct { __be32 daddr ; __be32 saddr ; } v4 ; struct { struct in6_addr daddr ; struct in6_addr saddr ; } v6 ; } fam ; } net ; int cap ; int ipc_id ; struct task_struct * tsk ; struct { key_serial_t key ; char * key_desc ; } key_struct ; } u ; union { struct smack_audit_data { const char * function ; char * subject ; char * object ; char * request ; int result ; } smack_audit_data ; struct { u32 ssid ; u32 tsid ; u16 tclass ; u32 requested ; u32 audited ; u32 denied ; struct av_decision * avd ; int result ; } selinux_audit_data ; } ; void ( * lsm_pre_audit ) ( struct audit_buffer * , void * ) ; void ( * lsm_post_audit ) ( struct audit_buffer * , void * ) ; } ;

struct netlbl_lsm_secattr ;

enum { POLICYDB_CAPABILITY_NETPEER , POLICYDB_CAPABILITY_OPENPERM , __POLICYDB_CAPABILITY_MAX } ;
struct av_decision { u32 allowed ; u32 auditallow ; u32 auditdeny ; u32 seqno ; u32 flags ; } ;

struct avc_entry ;

struct avc_cache_stats { unsigned int lookups ; unsigned int hits ; unsigned int misses ; unsigned int allocations ; unsigned int reclaims ; unsigned int frees ; } ;

struct av_perm_to_string { u16 tclass ; u32 value ; const char * name ; } ;

struct av_inherit { const char * * common_pts ; u32 common_base ; u16 tclass ; } ;
struct selinux_class_perm { const struct av_perm_to_string * av_perm_to_string ; u32 av_pts_len ; u32 cts_len ; const char * * class_to_string ; const struct av_inherit * av_inherit ; u32 av_inherit_len ; } ;

struct avc_entry { u32 ssid ; u32 tsid ; u16 tclass ; struct av_decision avd ; } ;
struct avc_node { struct avc_entry ae ; struct hlist_node list ; struct rcu_head rhead ; } ;

struct avc_cache { struct hlist_head slots [ 512 ] ; spinlock_t slots_lock [ 512 ] ; atomic_t lru_hint ; atomic_t active_nodes ; u32 latest_notif ; } ;

struct avc_callback_node { int ( * callback ) ( u32 event , u32 ssid , u32 tsid , u16 tclass , u32 perms , u32 * out_retained ) ; u32 events ; u32 ssid ; u32 tsid ; u16 tclass ; u32 perms ; struct avc_callback_node * next ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) avc_init ( void ) ;

int avc_get_hash_stats ( char * page ) ;

void avc_audit ( u32 ssid , u32 tsid , u16 tclass , u32 requested , struct av_decision * avd , int result , struct common_audit_data * a ) ;

int avc_add_callback ( int ( * callback ) ( u32 event , u32 ssid , u32 tsid , u16 tclass , u32 perms , u32 * out_retained ) , u32 events , u32 ssid , u32 tsid , u16 tclass , u32 perms ) ;

int avc_ss_reset ( u32 seqno ) ;

int avc_has_perm_noaudit ( u32 ssid , u32 tsid , u16 tclass , u32 requested , unsigned flags , struct av_decision * in_avd ) ;

int avc_has_perm ( u32 ssid , u32 tsid , u16 tclass , u32 requested , struct common_audit_data * auditdata ) ;

u32 avc_policy_seqno ( void ) ;

void avc_disable ( void ) ;

enum nf_ip_hook_priorities { NF_IP_PRI_FIRST = ( - ( ( int ) ( ~ 0U >> 1 ) ) - 1 ) , NF_IP_PRI_CONNTRACK_DEFRAG = - 400 , NF_IP_PRI_RAW = - 300 , NF_IP_PRI_SELINUX_FIRST = - 225 , NF_IP_PRI_CONNTRACK = - 200 , NF_IP_PRI_MANGLE = - 150 , NF_IP_PRI_NAT_DST = - 100 , NF_IP_PRI_FILTER = 0 , NF_IP_PRI_SECURITY = 50 , NF_IP_PRI_NAT_SRC = 100 , NF_IP_PRI_SELINUX_LAST = 225 , NF_IP_PRI_CONNTRACK_CONFIRM = ( ( int ) ( ~ 0U >> 1 ) ) , NF_IP_PRI_LAST = ( ( int ) ( ~ 0U >> 1 ) ) , } ;

enum nf_ip6_hook_priorities { NF_IP6_PRI_FIRST = ( - ( ( int ) ( ~ 0U >> 1 ) ) - 1 ) , NF_IP6_PRI_CONNTRACK_DEFRAG = - 400 , NF_IP6_PRI_SELINUX_FIRST = - 225 , NF_IP6_PRI_CONNTRACK = - 200 , NF_IP6_PRI_MANGLE = - 150 , NF_IP6_PRI_NAT_DST = - 100 , NF_IP6_PRI_FILTER = 0 , NF_IP6_PRI_SECURITY = 50 , NF_IP6_PRI_NAT_SRC = 100 , NF_IP6_PRI_SELINUX_LAST = 225 , NF_IP6_PRI_LAST = ( ( int ) ( ~ 0U >> 1 ) ) , } ;

struct icmphdr { __u8 type ; __u8 code ; __sum16 checksum ; union { struct { __be16 id ; __be16 sequence ; } echo ; __be32 gateway ; struct { __be16 __unused ; __be16 mtu ; } frag ; } un ; } ;

struct icmp_filter { __u32 data ; } ;

struct icmp_err { int errno ; unsigned fatal : 1 ; } ;

struct raw_sock { struct inet_sock inet ; struct icmp_filter filter ; } ;

struct inet_peer { struct inet_peer * avl_left , * avl_right ; __be32 v4daddr ; __u16 avl_height ; __u16 ip_id_count ; struct list_head unused ; __u32 dtime ; atomic_t refcnt ; atomic_t rid ; __u32 tcp_ts ; unsigned long tcp_ts_stamp ; } ;

struct fib_nh ;

struct inet_peer ;
struct rtable { union { struct dst_entry dst ; } u ; struct flowi fl ; struct in_device * idev ; int rt_genid ; unsigned rt_flags ; __u16 rt_type ; __be32 rt_dst ; __be32 rt_src ; int rt_iif ; __be32 rt_gateway ; __be32 rt_spec_dst ; struct inet_peer * peer ; } ;
struct ip_rt_acct { __u32 o_bytes ; __u32 o_packets ; __u32 i_bytes ; __u32 i_packets ; } ;

struct rt_cache_stat { unsigned int in_hit ; unsigned int in_slow_tot ; unsigned int in_slow_mc ; unsigned int in_no_route ; unsigned int in_brd ; unsigned int in_martian_dst ; unsigned int in_martian_src ; unsigned int out_hit ; unsigned int out_slow_tot ; unsigned int out_slow_mc ; unsigned int gc_total ; unsigned int gc_ignored ; unsigned int gc_goal_miss ; unsigned int gc_dst_overflow ; unsigned int in_hlist_search ; unsigned int out_hlist_search ; } ;

struct in_device ;

struct in_ifaddr ;

struct inet_ehash_bucket { struct hlist_nulls_head chain ; struct hlist_nulls_head twchain ; } ;

struct inet_bind_bucket { struct net * ib_net ; unsigned short port ; signed short fastreuse ; int num_owners ; struct hlist_node node ; struct hlist_head owners ; } ;
struct inet_bind_hashbucket { spinlock_t lock ; struct hlist_head chain ; } ;

struct inet_listen_hashbucket { spinlock_t lock ; struct hlist_nulls_head head ; } ;

struct inet_hashinfo { struct inet_ehash_bucket * ehash ; spinlock_t * ehash_locks ; unsigned int ehash_size ; unsigned int ehash_locks_mask ; struct inet_bind_hashbucket * bhash ; unsigned int bhash_size ; struct kmem_cache * bind_bucket_cachep ; struct inet_listen_hashbucket listening_hash [ 32 ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; atomic_t bsockets ; } ;
typedef __u32 __portpair ;

typedef __u64 __addrpair ;

enum { INET_ECN_NOT_ECT = 0 , INET_ECN_ECT_1 = 1 , INET_ECN_ECT_0 = 2 , INET_ECN_CE = 3 , INET_ECN_MASK = 3 , } ;
struct ipv6hdr ;
enum tcp_tw_status { TCP_TW_SUCCESS = 0 , TCP_TW_RST = 1 , TCP_TW_ACK = 2 , TCP_TW_SYN = 3 } ;

typedef int ( * sk_read_actor_t ) ( read_descriptor_t * , struct sk_buff * , unsigned int , size_t ) ;
struct tcp_skb_cb { union { struct inet_skb_parm h4 ; struct inet6_skb_parm h6 ; } header ; __u32 seq ; __u32 end_seq ; __u32 when ; __u8 flags ; __u8 sacked ; __u32 ack_seq ; } ;

enum tcp_ca_event { CA_EVENT_TX_START , CA_EVENT_CWND_RESTART , CA_EVENT_COMPLETE_CWR , CA_EVENT_FRTO , CA_EVENT_LOSS , CA_EVENT_FAST_ACK , CA_EVENT_SLOW_ACK , } ;

struct tcp_congestion_ops { struct list_head list ; unsigned long flags ; void ( * init ) ( struct sock * sk ) ; void ( * release ) ( struct sock * sk ) ; u32 ( * ssthresh ) ( struct sock * sk ) ; u32 ( * min_cwnd ) ( const struct sock * sk ) ; void ( * cong_avoid ) ( struct sock * sk , u32 ack , u32 in_flight ) ; void ( * set_state ) ( struct sock * sk , u8 new_state ) ; void ( * cwnd_event ) ( struct sock * sk , enum tcp_ca_event ev ) ; u32 ( * undo_cwnd ) ( struct sock * sk ) ; void ( * pkts_acked ) ( struct sock * sk , u32 num_acked , s32 rtt_us ) ; void ( * get_info ) ( struct sock * sk , u32 ext , struct sk_buff * skb ) ; char name [ 16 ] ; struct module * owner ; } ;
struct tcp_md5sig_key { u8 * key ; u8 keylen ; } ;

struct tcp4_md5sig_key { struct tcp_md5sig_key base ; __be32 addr ; } ;

struct tcp6_md5sig_key { struct tcp_md5sig_key base ; struct in6_addr addr ; } ;

struct tcp_md5sig_info { struct tcp4_md5sig_key * keys4 ; struct tcp6_md5sig_key * keys6 ; u32 entries6 ; u32 alloced6 ; u32 entries4 ; u32 alloced4 ; } ;

struct tcp4_pseudohdr { __be32 saddr ; __be32 daddr ; __u8 pad ; __u8 protocol ; __be16 len ; } ;

struct tcp6_pseudohdr { struct in6_addr saddr ; struct in6_addr daddr ; __be32 len ; __be32 protocol ; } ;

union tcp_md5sum_block { struct tcp4_pseudohdr ip4 ; struct tcp6_pseudohdr ip6 ; } ;

struct tcp_md5sig_pool { struct hash_desc md5_desc ; union tcp_md5sum_block md5_blk ; } ;

enum tcp_seq_states { TCP_SEQ_STATE_LISTENING , TCP_SEQ_STATE_OPENREQ , TCP_SEQ_STATE_ESTABLISHED , TCP_SEQ_STATE_TIME_WAIT , } ;

struct tcp_seq_afinfo { char * name ; sa_family_t family ; struct file_operations seq_fops ; struct seq_operations seq_ops ; } ;

struct tcp_iter_state { struct seq_net_private p ; sa_family_t family ; enum tcp_seq_states state ; struct sock * syn_wait_sk ; int bucket , sbucket , num , uid ; } ;

struct tcp_sock_af_ops { struct tcp_md5sig_key * ( * md5_lookup ) ( struct sock * sk , struct sock * addr_sk ) ; int ( * calc_md5_hash ) ( char * location , struct tcp_md5sig_key * md5 , struct sock * sk , struct request_sock * req , struct sk_buff * skb ) ; int ( * md5_add ) ( struct sock * sk , struct sock * addr_sk , u8 * newkey , u8 len ) ; int ( * md5_parse ) ( struct sock * sk , char * optval , int optlen ) ; } ;

struct tcp_request_sock_ops { struct tcp_md5sig_key * ( * md5_lookup ) ( struct sock * sk , struct request_sock * req ) ; int ( * calc_md5_hash ) ( char * location , struct tcp_md5sig_key * md5 , struct sock * sk , struct request_sock * req , struct sk_buff * skb ) ; } ;

struct cipso_v4_doi ;

struct netlbl_audit { u32 secid ; uid_t loginuid ; u32 sessionid ; } ;

struct netlbl_lsm_cache { atomic_t refcount ; void ( * free ) ( const void * data ) ; void * data ; } ;

struct netlbl_lsm_secattr_catmap { u32 startbit ; u64 bitmap [ 4 ] ; struct netlbl_lsm_secattr_catmap * next ; } ;

struct netlbl_lsm_secattr { u32 flags ; u32 type ; char * domain ; struct netlbl_lsm_cache * cache ; struct { struct { struct netlbl_lsm_secattr_catmap * cat ; u32 lvl ; } mls ; u32 secid ; } attr ; } ;
struct dccp_hdr { __be16 dccph_sport , dccph_dport ; __u8 dccph_doff ; __u8 dccph_cscov : 4 , dccph_ccval : 4 ; __sum16 dccph_checksum ; __u8 dccph_x : 1 , dccph_type : 4 , dccph_reserved : 3 ; __u8 dccph_seq2 ; __be16 dccph_seq ; } ;

struct dccp_hdr_ext { __be32 dccph_seq_low ; } ;

struct dccp_hdr_request { __be32 dccph_req_service ; } ;

struct dccp_hdr_ack_bits { __be16 dccph_reserved1 ; __be16 dccph_ack_nr_high ; __be32 dccph_ack_nr_low ; } ;

struct dccp_hdr_response { struct dccp_hdr_ack_bits dccph_resp_ack ; __be32 dccph_resp_service ; } ;

struct dccp_hdr_reset { struct dccp_hdr_ack_bits dccph_reset_ack ; __u8 dccph_reset_code , dccph_reset_data [ 3 ] ; } ;

enum dccp_pkt_type { DCCP_PKT_REQUEST = 0 , DCCP_PKT_RESPONSE , DCCP_PKT_DATA , DCCP_PKT_ACK , DCCP_PKT_DATAACK , DCCP_PKT_CLOSEREQ , DCCP_PKT_CLOSE , DCCP_PKT_RESET , DCCP_PKT_SYNC , DCCP_PKT_SYNCACK , DCCP_PKT_INVALID , } ;

enum dccp_reset_codes { DCCP_RESET_CODE_UNSPECIFIED = 0 , DCCP_RESET_CODE_CLOSED , DCCP_RESET_CODE_ABORTED , DCCP_RESET_CODE_NO_CONNECTION , DCCP_RESET_CODE_PACKET_ERROR , DCCP_RESET_CODE_OPTION_ERROR , DCCP_RESET_CODE_MANDATORY_ERROR , DCCP_RESET_CODE_CONNECTION_REFUSED , DCCP_RESET_CODE_BAD_SERVICE_CODE , DCCP_RESET_CODE_TOO_BUSY , DCCP_RESET_CODE_BAD_INIT_COOKIE , DCCP_RESET_CODE_AGGRESSION_PENALTY , DCCP_MAX_RESET_CODES } ;

enum { DCCPO_PADDING = 0 , DCCPO_MANDATORY = 1 , DCCPO_MIN_RESERVED = 3 , DCCPO_MAX_RESERVED = 31 , DCCPO_CHANGE_L = 32 , DCCPO_CONFIRM_L = 33 , DCCPO_CHANGE_R = 34 , DCCPO_CONFIRM_R = 35 , DCCPO_NDP_COUNT = 37 , DCCPO_ACK_VECTOR_0 = 38 , DCCPO_ACK_VECTOR_1 = 39 , DCCPO_TIMESTAMP = 41 , DCCPO_TIMESTAMP_ECHO = 42 , DCCPO_ELAPSED_TIME = 43 , DCCPO_MAX = 45 , DCCPO_MIN_CCID_SPECIFIC = 128 , DCCPO_MAX_CCID_SPECIFIC = 255 , } ;
enum { DCCPC_CCID2 = 2 , DCCPC_CCID3 = 3 , } ;
enum dccp_feature_numbers { DCCPF_RESERVED = 0 , DCCPF_CCID = 1 , DCCPF_SHORT_SEQNOS = 2 , DCCPF_SEQUENCE_WINDOW = 3 , DCCPF_ECN_INCAPABLE = 4 , DCCPF_ACK_RATIO = 5 , DCCPF_SEND_ACK_VECTOR = 6 , DCCPF_SEND_NDP_COUNT = 7 , DCCPF_MIN_CSUM_COVER = 8 , DCCPF_DATA_CHECKSUM = 9 , DCCPF_MIN_CCID_SPECIFIC = 128 , DCCPF_SEND_LEV_RATE = 192 , DCCPF_MAX_CCID_SPECIFIC = 255 , } ;

enum dccp_state { DCCP_OPEN = TCP_ESTABLISHED , DCCP_REQUESTING = TCP_SYN_SENT , DCCP_LISTEN = TCP_LISTEN , DCCP_RESPOND = TCP_SYN_RECV , DCCP_ACTIVE_CLOSEREQ = TCP_FIN_WAIT1 , DCCP_PASSIVE_CLOSE = TCP_CLOSE_WAIT , DCCP_CLOSING = TCP_CLOSING , DCCP_TIME_WAIT = TCP_TIME_WAIT , DCCP_CLOSED = TCP_CLOSE , DCCP_PARTOPEN = TCP_MAX_STATES , DCCP_PASSIVE_CLOSEREQ , DCCP_MAX_STATES } ;

enum { DCCPF_OPEN = TCPF_ESTABLISHED , DCCPF_REQUESTING = TCPF_SYN_SENT , DCCPF_LISTEN = TCPF_LISTEN , DCCPF_RESPOND = TCPF_SYN_RECV , DCCPF_ACTIVE_CLOSEREQ = TCPF_FIN_WAIT1 , DCCPF_CLOSING = TCPF_CLOSING , DCCPF_TIME_WAIT = TCPF_TIME_WAIT , DCCPF_CLOSED = TCPF_CLOSE , DCCPF_PARTOPEN = ( 1 << DCCP_PARTOPEN ) , } ;
struct dccp_request_sock { struct inet_request_sock dreq_inet_rsk ; __u64 dreq_iss ; __u64 dreq_isr ; __be32 dreq_service ; struct list_head dreq_featneg ; __u32 dreq_timestamp_echo ; __u32 dreq_timestamp_time ; } ;

struct dccp_options_received { u64 dccpor_ndp : 48 ; u32 dccpor_timestamp ; u32 dccpor_timestamp_echo ; u32 dccpor_elapsed_time ; } ;

struct ccid ;

enum dccp_role { DCCP_ROLE_UNDEFINED , DCCP_ROLE_LISTEN , DCCP_ROLE_CLIENT , DCCP_ROLE_SERVER , } ;

struct dccp_service_list { __u32 dccpsl_nr ; __be32 dccpsl_list [ 0 ] ; } ;

struct dccp_ackvec ;

struct dccp_sock { struct inet_connection_sock dccps_inet_connection ; __u64 dccps_swl ; __u64 dccps_swh ; __u64 dccps_awl ; __u64 dccps_awh ; __u64 dccps_iss ; __u64 dccps_isr ; __u64 dccps_osr ; __u64 dccps_gss ; __u64 dccps_gsr ; __u64 dccps_gar ; __be32 dccps_service ; __u32 dccps_mss_cache ; struct dccp_service_list * dccps_service_list ; __u32 dccps_timestamp_echo ; __u32 dccps_timestamp_time ; __u16 dccps_l_ack_ratio ; __u16 dccps_r_ack_ratio ; __u64 dccps_l_seq_win : 48 ; __u64 dccps_r_seq_win : 48 ; __u8 dccps_pcslen : 4 ; __u8 dccps_pcrlen : 4 ; __u8 dccps_send_ndp_count : 1 ; __u64 dccps_ndp_count : 48 ; unsigned long dccps_rate_last ; struct list_head dccps_featneg ; struct dccp_ackvec * dccps_hc_rx_ackvec ; struct ccid * dccps_hc_rx_ccid ; struct ccid * dccps_hc_tx_ccid ; struct dccp_options_received dccps_options_received ; enum dccp_role dccps_role : 2 ; __u8 dccps_hc_rx_insert_options : 1 ; __u8 dccps_hc_tx_insert_options : 1 ; __u8 dccps_server_timewait : 1 ; struct timer_list dccps_xmit_timer ; } ;

struct task_security_struct { u32 osid ; u32 sid ; u32 exec_sid ; u32 create_sid ; u32 keycreate_sid ; u32 sockcreate_sid ; } ;

struct inode_security_struct { struct inode * inode ; struct list_head list ; u32 task_sid ; u32 sid ; u16 sclass ; unsigned char initialized ; struct mutex lock ; } ;

struct file_security_struct { u32 sid ; u32 fown_sid ; u32 isid ; u32 pseqno ; } ;

struct superblock_security_struct { struct super_block * sb ; struct list_head list ; u32 sid ; u32 def_sid ; u32 mntpoint_sid ; unsigned int behavior ; unsigned char flags ; struct mutex lock ; struct list_head isec_head ; spinlock_t isec_lock ; } ;

struct msg_security_struct { u32 sid ; } ;

struct ipc_security_struct { u16 sclass ; u32 sid ; } ;

struct netif_security_struct { int ifindex ; u32 sid ; } ;

struct netnode_security_struct { union { __be32 ipv4 ; struct in6_addr ipv6 ; } addr ; u32 sid ; u16 family ; } ;

struct netport_security_struct { u32 sid ; u16 port ; u8 protocol ; } ;

struct sk_security_struct { enum { NLBL_UNSET = 0 , NLBL_REQUIRE , NLBL_LABELED , NLBL_REQSKB , NLBL_CONNLABELED , } nlbl_state ; struct netlbl_lsm_secattr * nlbl_secattr ; u32 sid ; u32 peer_sid ; u16 sclass ; } ;

struct key_security_struct { u32 sid ; } ;

enum { Opt_error = - 1 , Opt_context = 1 , Opt_fscontext = 2 , Opt_defcontext = 3 , Opt_rootcontext = 4 , Opt_labelsupport = 5 , } ;
void selinux_complete_init ( void ) ;

int selinux_disable ( void ) ;

enum sel_inos { SEL_ROOT_INO = 2 , SEL_LOAD , SEL_ENFORCE , SEL_CONTEXT , SEL_ACCESS , SEL_CREATE , SEL_RELABEL , SEL_USER , SEL_POLICYVERS , SEL_COMMIT_BOOLS , SEL_MLS , SEL_DISABLE , SEL_MEMBER , SEL_CHECKREQPROT , SEL_COMPAT_NET , SEL_REJECT_UNKNOWN , SEL_DENY_UNKNOWN , SEL_INO_NEXT , } ;

void exit_sel_fs ( void ) ;

enum { SELNL_MSG_SETENFORCE = 0x10 , SELNL_MSG_POLICYLOAD , SELNL_MSG_MAX } ;
enum selinux_nlgroups { SELNLGRP_NONE , SELNLGRP_AVC , __SELNLGRP_MAX } ;

struct selnl_msg_setenforce { __s32 val ; } ;

struct selnl_msg_policyload { __u32 seqno ; } ;

void selnl_notify_setenforce ( int val ) ;

void selnl_notify_policyload ( u32 seqno ) ;


typedef struct ipq_packet_msg { unsigned long packet_id ; unsigned long mark ; long timestamp_sec ; long timestamp_usec ; unsigned int hook ; char indev_name [ 16 ] ; char outdev_name [ 16 ] ; __be16 hw_protocol ; unsigned short hw_type ; unsigned char hw_addrlen ; unsigned char hw_addr [ 8 ] ; size_t data_len ; unsigned char payload [ 0 ] ; } ipq_packet_msg_t ;


typedef struct ipq_mode_msg { unsigned char value ; size_t range ; } ipq_mode_msg_t ;


typedef struct ipq_verdict_msg { unsigned int value ; unsigned long id ; size_t data_len ; unsigned char payload [ 0 ] ; } ipq_verdict_msg_t ;


typedef struct ipq_peer_msg { union { ipq_verdict_msg_t verdict ; ipq_mode_msg_t mode ; } msg ; } ipq_peer_msg_t ;

enum { IPQ_COPY_NONE , IPQ_COPY_META , IPQ_COPY_PACKET } ;
struct inet_diag_sockid { __be16 idiag_sport ; __be16 idiag_dport ; __be32 idiag_src [ 4 ] ; __be32 idiag_dst [ 4 ] ; __u32 idiag_if ; __u32 idiag_cookie [ 2 ] ; } ;

struct inet_diag_req { __u8 idiag_family ; __u8 idiag_src_len ; __u8 idiag_dst_len ; __u8 idiag_ext ; struct inet_diag_sockid id ; __u32 idiag_states ; __u32 idiag_dbs ; } ;

enum { INET_DIAG_REQ_NONE , INET_DIAG_REQ_BYTECODE , } ;
struct inet_diag_bc_op { unsigned char code ; unsigned char yes ; unsigned short no ; } ;

enum { INET_DIAG_BC_NOP , INET_DIAG_BC_JMP , INET_DIAG_BC_S_GE , INET_DIAG_BC_S_LE , INET_DIAG_BC_D_GE , INET_DIAG_BC_D_LE , INET_DIAG_BC_AUTO , INET_DIAG_BC_S_COND , INET_DIAG_BC_D_COND , } ;
struct inet_diag_hostcond { __u8 family ; __u8 prefix_len ; int port ; __be32 addr [ 0 ] ; } ;

struct inet_diag_msg { __u8 idiag_family ; __u8 idiag_state ; __u8 idiag_timer ; __u8 idiag_retrans ; struct inet_diag_sockid id ; __u32 idiag_expires ; __u32 idiag_rqueue ; __u32 idiag_wqueue ; __u32 idiag_uid ; __u32 idiag_inode ; } ;

enum { INET_DIAG_NONE , INET_DIAG_MEMINFO , INET_DIAG_INFO , INET_DIAG_VEGASINFO , INET_DIAG_CONG , } ;
struct inet_diag_meminfo { __u32 idiag_rmem ; __u32 idiag_wmem ; __u32 idiag_fmem ; __u32 idiag_tmem ; } ;

struct tcpvegas_info { __u32 tcpv_enabled ; __u32 tcpv_rttcnt ; __u32 tcpv_rtt ; __u32 tcpv_minrtt ; } ;

struct inet_diag_handler { struct inet_hashinfo * idiag_hashinfo ; void ( * idiag_get_info ) ( struct sock * sk , struct inet_diag_msg * r , void * info ) ; __u16 idiag_info_size ; __u16 idiag_type ; } ;

struct nlmsg_perm { u16 nlmsg_type ; u32 perm ; } ;

int selinux_nlmsg_lookup ( u16 sclass , u16 nlmsg_type , u32 * perm ) ;

struct sel_netif { struct list_head list ; struct netif_security_struct nsec ; struct rcu_head rcu_head ; } ;

int sel_netif_sid ( int ifindex , u32 * sid ) ;

struct sel_netnode_bkt { unsigned int size ; struct list_head list ; } ;

struct sel_netnode { struct netnode_security_struct nsec ; struct list_head list ; struct rcu_head rcu ; } ;

int sel_netnode_sid ( void * addr , u16 family , u32 * sid ) ;

struct sel_netport_bkt { int size ; struct list_head list ; } ;

struct sel_netport { struct netport_security_struct psec ; struct list_head list ; struct rcu_head rcu ; } ;

int sel_netport_sid ( u8 protocol , u16 pnum , u32 * sid ) ;

int selinux_string_to_sid ( char * str , u32 * sid ) ;

int selinux_secmark_relabel_packet_permission ( u32 sid ) ;

void selinux_secmark_refcount_inc ( void ) ;

void selinux_secmark_refcount_dec ( void ) ;

bool selinux_is_enabled ( void ) ;

void selinux_netlbl_cache_invalidate ( void ) ;

void selinux_netlbl_err ( struct sk_buff * skb , int error , int gateway ) ;

void selinux_netlbl_sk_security_free ( struct sk_security_struct * ssec ) ;

void selinux_netlbl_sk_security_reset ( struct sk_security_struct * ssec ) ;

int selinux_netlbl_skbuff_getsid ( struct sk_buff * skb , u16 family , u32 * type , u32 * sid ) ;

int selinux_netlbl_skbuff_setsid ( struct sk_buff * skb , u16 family , u32 sid ) ;

int selinux_netlbl_inet_conn_request ( struct request_sock * req , u16 family ) ;

void selinux_netlbl_inet_csk_clone ( struct sock * sk , u16 family ) ;

int selinux_netlbl_socket_post_create ( struct sock * sk , u16 family ) ;

int selinux_netlbl_sock_rcv_skb ( struct sk_security_struct * sksec , struct sk_buff * skb , u16 family , struct common_audit_data * ad ) ;

int selinux_netlbl_socket_setsockopt ( struct socket * sock , int level , int optname ) ;

int selinux_netlbl_socket_connect ( struct sock * sk , struct sockaddr * addr ) ;

struct ebitmap_node { struct ebitmap_node * next ; unsigned long maps [ ( ( 32 - sizeof ( void * ) - sizeof ( u32 ) ) / sizeof ( unsigned long ) ) ] ; u32 startbit ; } ;

struct ebitmap { struct ebitmap_node * node ; u32 highbit ; } ;

struct hashtab_node { void * key ; void * datum ; struct hashtab_node * next ; } ;

struct hashtab { struct hashtab_node * * htable ; u32 size ; u32 nel ; u32 ( * hash_value ) ( struct hashtab * h , const void * key ) ; int ( * keycmp ) ( struct hashtab * h , const void * key1 , const void * key2 ) ; } ;

struct hashtab_info { u32 slots_used ; u32 max_chain_len ; } ;

struct symtab { struct hashtab * table ; u32 nprim ; } ;

struct avtab_key { u16 source_type ; u16 target_type ; u16 target_class ; u16 specified ; } ;

struct avtab_datum { u32 data ; } ;

struct avtab_node { struct avtab_key key ; struct avtab_datum datum ; struct avtab_node * next ; } ;

struct avtab { struct avtab_node * * htable ; u32 nel ; u32 nslot ; u16 mask ; } ;

struct policydb ;

struct mls_level { u32 sens ; struct ebitmap cat ; } ;

struct mls_range { struct mls_level level [ 2 ] ; } ;

struct context { u32 user ; u32 role ; u32 type ; u32 len ; struct mls_range range ; char * str ; } ;
struct sidtab_node { u32 sid ; struct context context ; struct sidtab_node * next ; } ;

struct sidtab { struct sidtab_node * * htable ; unsigned int nel ; unsigned int next_sid ; unsigned char shutdown ; spinlock_t lock ; } ;

struct constraint_expr { u32 expr_type ; u32 attr ; u32 op ; struct ebitmap names ; struct constraint_expr * next ; } ;

struct constraint_node { u32 permissions ; struct constraint_expr * expr ; struct constraint_node * next ; } ;

struct perm_datum { u32 value ; } ;

struct common_datum { u32 value ; struct symtab permissions ; } ;

struct class_datum { u32 value ; char * comkey ; struct common_datum * comdatum ; struct symtab permissions ; struct constraint_node * constraints ; struct constraint_node * validatetrans ; } ;

struct role_datum { u32 value ; u32 bounds ; struct ebitmap dominates ; struct ebitmap types ; } ;

struct role_trans { u32 role ; u32 type ; u32 new_role ; struct role_trans * next ; } ;

struct role_allow { u32 role ; u32 new_role ; struct role_allow * next ; } ;

struct type_datum { u32 value ; u32 bounds ; unsigned char primary ; unsigned char attribute ; } ;

struct user_datum { u32 value ; u32 bounds ; struct ebitmap roles ; struct mls_range range ; struct mls_level dfltlevel ; } ;

struct level_datum { struct mls_level * level ; unsigned char isalias ; } ;

struct cat_datum { u32 value ; unsigned char isalias ; } ;

struct range_trans { u32 source_type ; u32 target_type ; u32 target_class ; struct mls_range target_range ; struct range_trans * next ; } ;

struct cond_bool_datum { __u32 value ; int state ; } ;

struct cond_node ;

struct ocontext { union { char * name ; struct { u8 protocol ; u16 low_port ; u16 high_port ; } port ; struct { u32 addr ; u32 mask ; } node ; struct { u32 addr [ 4 ] ; u32 mask [ 4 ] ; } node6 ; } u ; union { u32 sclass ; u32 behavior ; } v ; struct context context [ 2 ] ; u32 sid [ 2 ] ; struct ocontext * next ; } ;

struct genfs { char * fstype ; struct ocontext * head ; struct genfs * next ; } ;

struct policydb { struct symtab symtab [ 8 ] ; char * * sym_val_to_name [ 8 ] ; struct class_datum * * class_val_to_struct ; struct role_datum * * role_val_to_struct ; struct user_datum * * user_val_to_struct ; struct type_datum * * type_val_to_struct ; struct avtab te_avtab ; struct role_trans * role_tr ; struct cond_bool_datum * * bool_val_to_struct ; struct avtab te_cond_avtab ; struct cond_node * cond_list ; struct role_allow * role_allow ; struct ocontext * ocontexts [ 7 ] ; struct genfs * genfs ; struct range_trans * range_tr ; struct ebitmap * type_attr_map ; struct ebitmap policycaps ; struct ebitmap permissive_map ; unsigned int policyvers ; unsigned int reject_unknown : 1 ; unsigned int allow_unknown : 1 ; u32 * undefined_perms ; } ;
struct policy_file { char * data ; size_t len ; } ;

int ebitmap_cmp ( struct ebitmap * e1 , struct ebitmap * e2 ) ;

int ebitmap_cpy ( struct ebitmap * dst , struct ebitmap * src ) ;

int ebitmap_netlbl_export ( struct ebitmap * ebmap , struct netlbl_lsm_secattr_catmap * * catmap ) ;

int ebitmap_netlbl_import ( struct ebitmap * ebmap , struct netlbl_lsm_secattr_catmap * catmap ) ;

int ebitmap_contains ( struct ebitmap * e1 , struct ebitmap * e2 ) ;

int ebitmap_get_bit ( struct ebitmap * e , unsigned long bit ) ;

int ebitmap_set_bit ( struct ebitmap * e , unsigned long bit , int value ) ;

void ebitmap_destroy ( struct ebitmap * e ) ;

int ebitmap_read ( struct ebitmap * e , void * fp ) ;

struct hashtab * hashtab_create ( u32 ( * hash_value ) ( struct hashtab * h , const void * key ) , int ( * keycmp ) ( struct hashtab * h , const void * key1 , const void * key2 ) , u32 size ) ;

int hashtab_insert ( struct hashtab * h , void * key , void * datum ) ;

void * hashtab_search ( struct hashtab * h , const void * key ) ;

void hashtab_destroy ( struct hashtab * h ) ;

int hashtab_map ( struct hashtab * h , int ( * apply ) ( void * k , void * d , void * args ) , void * args ) ;

void hashtab_stat ( struct hashtab * h , struct hashtab_info * info ) ;

int symtab_init ( struct symtab * s , unsigned int size ) ;

int sidtab_init ( struct sidtab * s ) ;

int sidtab_insert ( struct sidtab * s , u32 sid , struct context * context ) ;

struct context * sidtab_search ( struct sidtab * s , u32 sid ) ;

struct context * sidtab_search_force ( struct sidtab * s , u32 sid ) ;

int sidtab_map ( struct sidtab * s , int ( * apply ) ( u32 sid , struct context * context , void * args ) , void * args ) ;

int sidtab_context_to_sid ( struct sidtab * s , struct context * context , u32 * out_sid ) ;

void sidtab_hash_eval ( struct sidtab * h , char * tag ) ;

void sidtab_destroy ( struct sidtab * s ) ;

void sidtab_set ( struct sidtab * dst , struct sidtab * src ) ;

void sidtab_shutdown ( struct sidtab * s ) ;

struct avtab_node * avtab_insert_nonunique ( struct avtab * h , struct avtab_key * key , struct avtab_datum * datum ) ;

struct avtab_datum * avtab_search ( struct avtab * h , struct avtab_key * key ) ;

struct avtab_node * avtab_search_node ( struct avtab * h , struct avtab_key * key ) ;

struct avtab_node * avtab_search_node_next ( struct avtab_node * node , int specified ) ;

void avtab_destroy ( struct avtab * h ) ;

int avtab_init ( struct avtab * h ) ;

int avtab_alloc ( struct avtab * h , u32 nrules ) ;

void avtab_hash_eval ( struct avtab * h , char * tag ) ;

int avtab_read_item ( struct avtab * a , void * fp , struct policydb * pol , int ( * insertf ) ( struct avtab * a , struct avtab_key * k , struct avtab_datum * d , void * p ) , void * p ) ;

int avtab_read ( struct avtab * a , void * fp , struct policydb * pol ) ;

void avtab_cache_init ( void ) ;

void avtab_cache_destroy ( void ) ;

struct cond_expr { __u32 expr_type ; __u32 bool ; struct cond_expr * next ; } ;

struct cond_av_list { struct avtab_node * node ; struct cond_av_list * next ; } ;

struct cond_node { int cur_state ; struct cond_expr * expr ; struct cond_av_list * true_list ; struct cond_av_list * false_list ; struct cond_node * next ; } ;
struct policydb_compat_info { int version ; int sym_num ; int ocon_num ; } ;

void policydb_destroy ( struct policydb * p ) ;

int policydb_load_isids ( struct policydb * p , struct sidtab * s ) ;

int policydb_class_isvalid ( struct policydb * p , unsigned int class ) ;

int policydb_role_isvalid ( struct policydb * p , unsigned int role ) ;

int policydb_type_isvalid ( struct policydb * p , unsigned int type ) ;

int policydb_context_isvalid ( struct policydb * p , struct context * c ) ;

int policydb_read ( struct policydb * p , void * fp ) ;

int security_validate_transition ( u32 oldsid , u32 newsid , u32 tasksid , u16 tclass ) ;

int security_bounded_transition ( u32 old_sid , u32 new_sid ) ;

int security_compute_av ( u32 ssid , u32 tsid , u16 tclass , u32 requested , struct av_decision * avd ) ;

const char * security_get_initial_sid_context ( u32 sid ) ;

int security_sid_to_context ( u32 sid , char * * scontext , u32 * scontext_len ) ;

int security_sid_to_context_force ( u32 sid , char * * scontext , u32 * scontext_len ) ;

int security_context_to_sid ( const char * scontext , u32 scontext_len , u32 * sid ) ;

int security_context_to_sid_default ( const char * scontext , u32 scontext_len , u32 * sid , u32 def_sid , gfp_t gfp_flags ) ;

int security_context_to_sid_force ( const char * scontext , u32 scontext_len , u32 * sid ) ;

int security_transition_sid ( u32 ssid , u32 tsid , u16 tclass , u32 * out_sid ) ;

int security_member_sid ( u32 ssid , u32 tsid , u16 tclass , u32 * out_sid ) ;

int security_change_sid ( u32 ssid , u32 tsid , u16 tclass , u32 * out_sid ) ;

struct convert_context_args { struct policydb * oldp ; struct policydb * newp ; } ;

int security_load_policy ( void * data , size_t len ) ;

int security_port_sid ( u8 protocol , u16 port , u32 * out_sid ) ;

int security_netif_sid ( char * name , u32 * if_sid ) ;

int security_node_sid ( u16 domain , void * addrp , u32 addrlen , u32 * out_sid ) ;

int security_get_user_sids ( u32 fromsid , char * username , u32 * * sids , u32 * nel ) ;

int security_genfs_sid ( const char * fstype , char * path , u16 sclass , u32 * sid ) ;

int security_fs_use ( const char * fstype , unsigned int * behavior , u32 * sid ) ;

int security_get_bools ( int * len , char * * * names , int * * values ) ;

int security_set_bools ( int len , int * values ) ;

int security_get_bool_value ( int bool ) ;

int security_sid_mls_copy ( u32 sid , u32 mls_sid , u32 * new_sid ) ;

int security_net_peersid_resolve ( u32 nlbl_sid , u32 nlbl_type , u32 xfrm_sid , u32 * peer_sid ) ;

int security_get_classes ( char * * * classes , int * nclasses ) ;

int security_get_permissions ( char * class , char * * * perms , int * nperms ) ;

int security_get_reject_unknown ( void ) ;

int security_get_allow_unknown ( void ) ;

int security_policycap_supported ( unsigned int req_cap ) ;

struct selinux_audit_rule { u32 au_seqno ; struct context au_ctxt ; } ;
void selinux_audit_rule_free ( void * vrule ) ;

int selinux_audit_rule_init ( u32 field , u32 op , char * rulestr , void * * vrule ) ;

int selinux_audit_rule_known ( struct audit_krule * rule ) ;

int selinux_audit_rule_match ( u32 sid , u32 field , u32 op , void * vrule , struct audit_context * actx ) ;

int security_netlbl_secattr_to_sid ( struct netlbl_lsm_secattr * secattr , u32 * sid ) ;

int security_netlbl_sid_to_secattr ( u32 sid , struct netlbl_lsm_secattr * secattr ) ;

int evaluate_cond_node ( struct policydb * p , struct cond_node * node ) ;

int cond_policydb_init ( struct policydb * p ) ;

void cond_policydb_destroy ( struct policydb * p ) ;

int cond_init_bool_indexes ( struct policydb * p ) ;

int cond_destroy_bool ( void * key , void * datum , void * p ) ;

int cond_index_bool ( void * key , void * datum , void * datap ) ;

int cond_read_bool ( struct policydb * p , struct hashtab * h , void * fp ) ;

struct cond_insertf_data { struct policydb * p ; struct cond_av_list * other ; struct cond_av_list * head ; struct cond_av_list * tail ; } ;

int cond_read_list ( struct policydb * p , void * fp ) ;

void cond_compute_av ( struct avtab * ctab , struct avtab_key * key , struct av_decision * avd ) ;

int mls_compute_context_len ( struct context * context ) ;

void mls_sid_to_context ( struct context * context , char * * scontext ) ;

int mls_level_isvalid ( struct policydb * p , struct mls_level * l ) ;

int mls_range_isvalid ( struct policydb * p , struct mls_range * r ) ;

int mls_context_isvalid ( struct policydb * p , struct context * c ) ;

int mls_context_to_sid ( struct policydb * pol , char oldc , char * * scontext , struct context * context , struct sidtab * s , u32 def_sid ) ;

int mls_from_string ( char * str , struct context * context , gfp_t gfp_mask ) ;

int mls_setup_user_range ( struct context * fromcon , struct user_datum * user , struct context * usercon ) ;

int mls_convert_context ( struct policydb * oldp , struct policydb * newp , struct context * c ) ;

int mls_compute_sid ( struct context * scontext , struct context * tcontext , u16 tclass , u32 specified , struct context * newcontext ) ;

void mls_export_netlbl_lvl ( struct context * context , struct netlbl_lsm_secattr * secattr ) ;

void mls_import_netlbl_lvl ( struct context * context , struct netlbl_lsm_secattr * secattr ) ;

int mls_export_netlbl_cat ( struct context * context , struct netlbl_lsm_secattr * secattr ) ;

int mls_import_netlbl_cat ( struct context * context , struct netlbl_lsm_secattr * secattr ) ;

struct cipso_v4_doi { u32 doi ; u32 type ; union { struct cipso_v4_std_map_tbl * std ; } map ; u8 tags [ 5 ] ; atomic_t refcount ; struct list_head list ; struct rcu_head rcu ; } ;
struct cipso_v4_std_map_tbl { struct { u32 * cipso ; u32 * local ; u32 cipso_size ; u32 local_size ; } lvl ; struct { u32 * cipso ; u32 * local ; u32 cipso_size ; u32 local_size ; } cat ; } ;

struct superblock_smack { char * smk_root ; char * smk_floor ; char * smk_hat ; char * smk_default ; int smk_initialized ; spinlock_t smk_sblock ; } ;

struct socket_smack { char * smk_out ; char * smk_in ; char smk_packet [ ( 23 + 1 ) ] ; } ;

struct inode_smack { char * smk_inode ; struct mutex smk_lock ; int smk_flags ; } ;

struct smack_rule { struct list_head list ; char * smk_subject ; char * smk_object ; int smk_access ; } ;

struct smack_cipso { int smk_level ; char smk_catset [ ( 23 + 1 ) ] ; } ;

struct smk_netlbladdr { struct list_head list ; struct sockaddr_in smk_host ; struct in_addr smk_mask ; char * smk_label ; } ;

struct smack_known { struct list_head list ; char smk_known [ ( 23 + 1 ) ] ; u32 smk_secid ; struct smack_cipso * smk_cipso ; spinlock_t smk_cipsolock ; } ;

struct smk_audit_info { struct common_audit_data a ; } ;

struct inode_smack * new_inode_smack ( char * smack ) ;

int smk_access ( char * subject_label , char * object_label , int request , struct smk_audit_info * a ) ;

int smk_curacc ( char * obj_label , u32 mode , struct smk_audit_info * a ) ;

void smack_log ( char * subject_label , char * object_label , int request , int result , struct smk_audit_info * ad ) ;

struct smack_known * smk_import_entry ( const char * string , int len ) ;

char * smk_import ( const char * string , int len ) ;

char * smack_from_secid ( const u32 secid ) ;

u32 smack_to_secid ( const char * smack ) ;

void smack_from_cipso ( u32 level , char * cp , char * result ) ;

int smack_to_cipso ( const char * smack , struct smack_cipso * cp ) ;

enum smk_inos { SMK_ROOT_INO = 2 , SMK_LOAD = 3 , SMK_CIPSO = 4 , SMK_DOI = 5 , SMK_DIRECT = 6 , SMK_AMBIENT = 7 , SMK_NETLBLADDR = 8 , SMK_ONLYCAP = 9 , SMK_LOGGING = 10 , } ;

struct tomoyo_path_info ;

struct tomoyo_io_buffer ;

struct tomoyo_page_buffer { char buffer [ 4096 ] ; } ;

struct tomoyo_path_info { const char * name ; u32 hash ; u16 const_len ; bool is_dir ; bool is_patterned ; u16 depth ; } ;
struct tomoyo_path_info_with_data { struct tomoyo_path_info head ; char barrier1 [ 16 ] ; char body [ 4000 ] ; char barrier2 [ 16 ] ; } ;

struct tomoyo_acl_info { struct list_head list ; u8 type ; } __attribute__ ( ( packed ) ) ;
struct tomoyo_domain_info { struct list_head list ; struct list_head acl_info_list ; const struct tomoyo_path_info * domainname ; u8 profile ; bool is_deleted ; bool quota_warned ; u8 flags ; } ;

struct tomoyo_single_path_acl_record { struct tomoyo_acl_info head ; u16 perm ; const struct tomoyo_path_info * filename ; } ;

struct tomoyo_double_path_acl_record { struct tomoyo_acl_info head ; u8 perm ; const struct tomoyo_path_info * filename1 ; const struct tomoyo_path_info * filename2 ; } ;

struct tomoyo_io_buffer { int ( * read ) ( struct tomoyo_io_buffer * ) ; int ( * write ) ( struct tomoyo_io_buffer * ) ; struct mutex io_sem ; struct list_head * read_var1 ; struct list_head * read_var2 ; struct tomoyo_domain_info * write_var1 ; int read_step ; char * read_buf ; bool read_eof ; bool read_single_domain ; u8 read_bit ; int read_avail ; int readbuf_size ; char * write_buf ; int write_avail ; int writebuf_size ; } ;

bool tomoyo_is_correct_path ( const char * filename , const s8 start_type , const s8 pattern_type , const s8 end_type , const char * function ) ;

bool tomoyo_is_correct_domain ( const unsigned char * domainname , const char * function ) ;

bool tomoyo_is_domain_def ( const unsigned char * buffer ) ;

struct tomoyo_domain_info * tomoyo_find_domain ( const char * domainname ) ;

void tomoyo_fill_path_info ( struct tomoyo_path_info * ptr ) ;

bool tomoyo_path_matches_pattern ( const struct tomoyo_path_info * filename , const struct tomoyo_path_info * pattern ) ;

bool tomoyo_io_printf ( struct tomoyo_io_buffer * head , const char * fmt , ... ) ;

const char * tomoyo_get_msg ( const bool is_enforce ) ;

unsigned int tomoyo_check_flags ( const struct tomoyo_domain_info * domain , const u8 index ) ;

bool tomoyo_verbose_mode ( const struct tomoyo_domain_info * domain ) ;

bool tomoyo_domain_quota_is_ok ( struct tomoyo_domain_info * const domain ) ;

struct tomoyo_policy_manager_entry { struct list_head list ; const struct tomoyo_path_info * manager ; bool is_domain ; bool is_deleted ; } ;

void tomoyo_load_policy ( const char * filename ) ;

void * tomoyo_alloc_acl_element ( const u8 acl_type ) ;

int tomoyo_encode ( char * buffer , int buflen , const char * str ) ;

int tomoyo_realpath_from_path2 ( struct path * path , char * newname , int newname_len ) ;

char * tomoyo_realpath_from_path ( struct path * path ) ;

char * tomoyo_realpath ( const char * pathname ) ;

char * tomoyo_realpath_nofollow ( const char * pathname ) ;

void * tomoyo_alloc_element ( const unsigned int size ) ;

struct tomoyo_name_entry { struct list_head list ; struct tomoyo_path_info entry ; } ;

struct tomoyo_free_memory_block_list { struct list_head list ; char * ptr ; int len ; } ;

const struct tomoyo_path_info * tomoyo_save_name ( const char * name ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) tomoyo_realpath_init ( void ) ;

void * tomoyo_alloc ( const size_t size ) ;

void tomoyo_free ( const void * p ) ;

int tomoyo_read_memory_counter ( struct tomoyo_io_buffer * head ) ;

int tomoyo_write_memory_quota ( struct tomoyo_io_buffer * head ) ;

struct tomoyo_domain_initializer_entry { struct list_head list ; const struct tomoyo_path_info * domainname ; const struct tomoyo_path_info * program ; bool is_deleted ; bool is_not ; bool is_last_name ; } ;

struct tomoyo_domain_keeper_entry { struct list_head list ; const struct tomoyo_path_info * domainname ; const struct tomoyo_path_info * program ; bool is_deleted ; bool is_not ; bool is_last_name ; } ;

struct tomoyo_alias_entry { struct list_head list ; const struct tomoyo_path_info * original_name ; const struct tomoyo_path_info * aliased_name ; bool is_deleted ; } ;

void tomoyo_set_domain_flag ( struct tomoyo_domain_info * domain , const bool is_delete , const u8 flags ) ;

const char * tomoyo_get_last_name ( const struct tomoyo_domain_info * domain ) ;

bool tomoyo_read_domain_initializer_policy ( struct tomoyo_io_buffer * head ) ;

int tomoyo_write_domain_initializer_policy ( char * data , const bool is_not , const bool is_delete ) ;

int tomoyo_write_domain_keeper_policy ( char * data , const bool is_not , const bool is_delete ) ;

bool tomoyo_read_domain_keeper_policy ( struct tomoyo_io_buffer * head ) ;

bool tomoyo_read_alias_policy ( struct tomoyo_io_buffer * head ) ;

int tomoyo_write_alias_policy ( char * data , const bool is_delete ) ;

struct tomoyo_domain_info * tomoyo_find_or_assign_new_domain ( const char * domainname , const u8 profile ) ;

int tomoyo_find_next_domain ( struct linux_binprm * bprm ) ;

struct tomoyo_globally_readable_file_entry { struct list_head list ; const struct tomoyo_path_info * filename ; bool is_deleted ; } ;

struct tomoyo_pattern_entry { struct list_head list ; const struct tomoyo_path_info * pattern ; bool is_deleted ; } ;

struct tomoyo_no_rewrite_entry { struct list_head list ; const struct tomoyo_path_info * pattern ; bool is_deleted ; } ;

const char * tomoyo_sp2keyword ( const u8 operation ) ;

const char * tomoyo_dp2keyword ( const u8 operation ) ;

int tomoyo_write_globally_readable_policy ( char * data , const bool is_delete ) ;

bool tomoyo_read_globally_readable_policy ( struct tomoyo_io_buffer * head ) ;

int tomoyo_write_pattern_policy ( char * data , const bool is_delete ) ;

bool tomoyo_read_file_pattern ( struct tomoyo_io_buffer * head ) ;

int tomoyo_write_no_rewrite_policy ( char * data , const bool is_delete ) ;

bool tomoyo_read_no_rewrite_policy ( struct tomoyo_io_buffer * head ) ;

int tomoyo_write_file_policy ( char * data , struct tomoyo_domain_info * domain , const bool is_delete ) ;

int tomoyo_check_file_perm ( struct tomoyo_domain_info * domain , const char * filename , const u8 perm ) ;

int tomoyo_check_exec_perm ( struct tomoyo_domain_info * domain , const struct tomoyo_path_info * filename ) ;

int tomoyo_check_open_permission ( struct tomoyo_domain_info * domain , struct path * path , const int flag ) ;

int tomoyo_check_1path_perm ( struct tomoyo_domain_info * domain , const u8 operation , struct path * path ) ;

int tomoyo_check_rewrite_permission ( struct tomoyo_domain_info * domain , struct file * filp ) ;

int tomoyo_check_2path_perm ( struct tomoyo_domain_info * const domain , const u8 operation , struct path * path1 , struct path * path2 ) ;

int cap_netlink_send ( struct sock * sk , struct sk_buff * skb ) ;

int cap_netlink_recv ( struct sk_buff * skb , int cap ) ;

int cap_capable ( struct task_struct * tsk , const struct cred * cred , int cap , int audit ) ;

int cap_settime ( struct timespec * ts , struct timezone * tz ) ;

int cap_ptrace_access_check ( struct task_struct * child , unsigned int mode ) ;

int cap_ptrace_traceme ( struct task_struct * parent ) ;

int cap_capget ( struct task_struct * target , kernel_cap_t * effective , kernel_cap_t * inheritable , kernel_cap_t * permitted ) ;

int cap_capset ( struct cred * new , const struct cred * old , const kernel_cap_t * effective , const kernel_cap_t * inheritable , const kernel_cap_t * permitted ) ;

int cap_inode_need_killpriv ( struct dentry * dentry ) ;

int cap_inode_killpriv ( struct dentry * dentry ) ;

int get_vfs_caps_from_disk ( const struct dentry * dentry , struct cpu_vfs_cap_data * cpu_caps ) ;

int cap_bprm_set_creds ( struct linux_binprm * bprm ) ;

int cap_bprm_secureexec ( struct linux_binprm * bprm ) ;

int cap_inode_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

int cap_inode_removexattr ( struct dentry * dentry , const char * name ) ;

int cap_task_fix_setuid ( struct cred * new , const struct cred * old , int flags ) ;

int cap_task_setscheduler ( struct task_struct * p , int policy , struct sched_param * lp ) ;

int cap_task_setioprio ( struct task_struct * p , int ioprio ) ;

int cap_task_setnice ( struct task_struct * p , int nice ) ;

int cap_task_prctl ( int option , unsigned long arg2 , unsigned long arg3 , unsigned long arg4 , unsigned long arg5 ) ;

int cap_syslog ( int type , bool from_file ) ;

int cap_vm_enough_memory ( struct mm_struct * mm , long pages ) ;

int cap_file_mmap ( struct file * file , unsigned long reqprot , unsigned long prot , unsigned long flags , unsigned long addr , unsigned long addr_only ) ;

int mmap_min_addr_handler ( struct ctl_table * table , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_mmap_min_addr ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) security_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) security_module_enable ( struct security_operations * ops ) ;

int register_security ( struct security_operations * ops ) ;

int security_ptrace_access_check ( struct task_struct * child , unsigned int mode ) ;

int security_ptrace_traceme ( struct task_struct * parent ) ;

int security_capget ( struct task_struct * target , kernel_cap_t * effective , kernel_cap_t * inheritable , kernel_cap_t * permitted ) ;

int security_capset ( struct cred * new , const struct cred * old , const kernel_cap_t * effective , const kernel_cap_t * inheritable , const kernel_cap_t * permitted ) ;

int security_capable ( int cap ) ;

int security_real_capable ( struct task_struct * tsk , int cap ) ;

int security_real_capable_noaudit ( struct task_struct * tsk , int cap ) ;

int security_acct ( struct file * file ) ;

int security_sysctl ( struct ctl_table * table , int op ) ;

int security_quotactl ( int cmds , int type , int id , struct super_block * sb ) ;

int security_quota_on ( struct dentry * dentry ) ;

int security_syslog ( int type , bool from_file ) ;

int security_settime ( struct timespec * ts , struct timezone * tz ) ;

int security_vm_enough_memory ( long pages ) ;

int security_vm_enough_memory_mm ( struct mm_struct * mm , long pages ) ;

int security_vm_enough_memory_kern ( long pages ) ;

int security_bprm_set_creds ( struct linux_binprm * bprm ) ;

int security_bprm_check ( struct linux_binprm * bprm ) ;

void security_bprm_committing_creds ( struct linux_binprm * bprm ) ;

void security_bprm_committed_creds ( struct linux_binprm * bprm ) ;

int security_bprm_secureexec ( struct linux_binprm * bprm ) ;

int security_sb_alloc ( struct super_block * sb ) ;

void security_sb_free ( struct super_block * sb ) ;

int security_sb_copy_data ( char * orig , char * copy ) ;

int security_sb_kern_mount ( struct super_block * sb , int flags , void * data ) ;

int security_sb_show_options ( struct seq_file * m , struct super_block * sb ) ;

int security_sb_statfs ( struct dentry * dentry ) ;

int security_sb_mount ( char * dev_name , struct path * path , char * type , unsigned long flags , void * data ) ;

int security_sb_check_sb ( struct vfsmount * mnt , struct path * path ) ;

int security_sb_umount ( struct vfsmount * mnt , int flags ) ;

void security_sb_umount_close ( struct vfsmount * mnt ) ;

void security_sb_umount_busy ( struct vfsmount * mnt ) ;

void security_sb_post_remount ( struct vfsmount * mnt , unsigned long flags , void * data ) ;

void security_sb_post_addmount ( struct vfsmount * mnt , struct path * mountpoint ) ;

int security_sb_pivotroot ( struct path * old_path , struct path * new_path ) ;

void security_sb_post_pivotroot ( struct path * old_path , struct path * new_path ) ;

int security_sb_set_mnt_opts ( struct super_block * sb , struct security_mnt_opts * opts ) ;

void security_sb_clone_mnt_opts ( const struct super_block * oldsb , struct super_block * newsb ) ;

int security_sb_parse_opts_str ( char * options , struct security_mnt_opts * opts ) ;

int security_inode_alloc ( struct inode * inode ) ;

void security_inode_free ( struct inode * inode ) ;

int security_inode_init_security ( struct inode * inode , struct inode * dir , char * * name , void * * value , size_t * len ) ;

int security_path_mknod ( struct path * path , struct dentry * dentry , int mode , unsigned int dev ) ;

int security_path_mkdir ( struct path * path , struct dentry * dentry , int mode ) ;

int security_path_rmdir ( struct path * path , struct dentry * dentry ) ;

int security_path_unlink ( struct path * path , struct dentry * dentry ) ;

int security_path_symlink ( struct path * path , struct dentry * dentry , const char * old_name ) ;

int security_path_link ( struct dentry * old_dentry , struct path * new_dir , struct dentry * new_dentry ) ;

int security_path_rename ( struct path * old_dir , struct dentry * old_dentry , struct path * new_dir , struct dentry * new_dentry ) ;

int security_path_truncate ( struct path * path , loff_t length , unsigned int time_attrs ) ;

int security_path_chmod ( struct dentry * dentry , struct vfsmount * mnt , mode_t mode ) ;

int security_path_chown ( struct path * path , uid_t uid , gid_t gid ) ;

int security_path_chroot ( struct path * path ) ;

int security_inode_create ( struct inode * dir , struct dentry * dentry , int mode ) ;

int security_inode_link ( struct dentry * old_dentry , struct inode * dir , struct dentry * new_dentry ) ;

int security_inode_unlink ( struct inode * dir , struct dentry * dentry ) ;

int security_inode_symlink ( struct inode * dir , struct dentry * dentry , const char * old_name ) ;

int security_inode_mkdir ( struct inode * dir , struct dentry * dentry , int mode ) ;

int security_inode_rmdir ( struct inode * dir , struct dentry * dentry ) ;

int security_inode_mknod ( struct inode * dir , struct dentry * dentry , int mode , dev_t dev ) ;

int security_inode_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) ;

int security_inode_readlink ( struct dentry * dentry ) ;

int security_inode_follow_link ( struct dentry * dentry , struct nameidata * nd ) ;

int security_inode_permission ( struct inode * inode , int mask ) ;

int security_inode_setattr ( struct dentry * dentry , struct iattr * attr ) ;

int security_inode_getattr ( struct vfsmount * mnt , struct dentry * dentry ) ;

void security_inode_delete ( struct inode * inode ) ;

int security_inode_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

void security_inode_post_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) ;

int security_inode_getxattr ( struct dentry * dentry , const char * name ) ;

int security_inode_listxattr ( struct dentry * dentry ) ;

int security_inode_removexattr ( struct dentry * dentry , const char * name ) ;

int security_inode_need_killpriv ( struct dentry * dentry ) ;

int security_inode_killpriv ( struct dentry * dentry ) ;

int security_inode_getsecurity ( const struct inode * inode , const char * name , void * * buffer , bool alloc ) ;

int security_inode_setsecurity ( struct inode * inode , const char * name , const void * value , size_t size , int flags ) ;

int security_inode_listsecurity ( struct inode * inode , char * buffer , size_t buffer_size ) ;

void security_inode_getsecid ( const struct inode * inode , u32 * secid ) ;

int security_file_permission ( struct file * file , int mask ) ;

int security_file_alloc ( struct file * file ) ;

void security_file_free ( struct file * file ) ;

int security_file_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) ;

int security_file_mmap ( struct file * file , unsigned long reqprot , unsigned long prot , unsigned long flags , unsigned long addr , unsigned long addr_only ) ;

int security_file_mprotect ( struct vm_area_struct * vma , unsigned long reqprot , unsigned long prot ) ;

int security_file_lock ( struct file * file , unsigned int cmd ) ;

int security_file_fcntl ( struct file * file , unsigned int cmd , unsigned long arg ) ;

int security_file_set_fowner ( struct file * file ) ;

int security_file_send_sigiotask ( struct task_struct * tsk , struct fown_struct * fown , int sig ) ;

int security_file_receive ( struct file * file ) ;

int security_dentry_open ( struct file * file , const struct cred * cred ) ;

int security_task_create ( unsigned long clone_flags ) ;

int security_cred_alloc_blank ( struct cred * cred , gfp_t gfp ) ;

void security_cred_free ( struct cred * cred ) ;

int security_prepare_creds ( struct cred * new , const struct cred * old , gfp_t gfp ) ;

void security_commit_creds ( struct cred * new , const struct cred * old ) ;

void security_transfer_creds ( struct cred * new , const struct cred * old ) ;

int security_kernel_act_as ( struct cred * new , u32 secid ) ;

int security_kernel_create_files_as ( struct cred * new , struct inode * inode ) ;

int security_kernel_module_request ( void ) ;

int security_task_setuid ( uid_t id0 , uid_t id1 , uid_t id2 , int flags ) ;

int security_task_fix_setuid ( struct cred * new , const struct cred * old , int flags ) ;

int security_task_setgid ( gid_t id0 , gid_t id1 , gid_t id2 , int flags ) ;

int security_task_setpgid ( struct task_struct * p , pid_t pgid ) ;

int security_task_getpgid ( struct task_struct * p ) ;

int security_task_getsid ( struct task_struct * p ) ;

void security_task_getsecid ( struct task_struct * p , u32 * secid ) ;

int security_task_setgroups ( struct group_info * group_info ) ;

int security_task_setnice ( struct task_struct * p , int nice ) ;

int security_task_setioprio ( struct task_struct * p , int ioprio ) ;

int security_task_getioprio ( struct task_struct * p ) ;

int security_task_setrlimit ( unsigned int resource , struct rlimit * new_rlim ) ;

int security_task_setscheduler ( struct task_struct * p , int policy , struct sched_param * lp ) ;

int security_task_getscheduler ( struct task_struct * p ) ;

int security_task_movememory ( struct task_struct * p ) ;

int security_task_kill ( struct task_struct * p , struct siginfo * info , int sig , u32 secid ) ;

int security_task_wait ( struct task_struct * p ) ;

int security_task_prctl ( int option , unsigned long arg2 , unsigned long arg3 , unsigned long arg4 , unsigned long arg5 ) ;

void security_task_to_inode ( struct task_struct * p , struct inode * inode ) ;

int security_ipc_permission ( struct kern_ipc_perm * ipcp , short flag ) ;

void security_ipc_getsecid ( struct kern_ipc_perm * ipcp , u32 * secid ) ;

int security_msg_msg_alloc ( struct msg_msg * msg ) ;

void security_msg_msg_free ( struct msg_msg * msg ) ;

int security_msg_queue_alloc ( struct msg_queue * msq ) ;

void security_msg_queue_free ( struct msg_queue * msq ) ;

int security_msg_queue_associate ( struct msg_queue * msq , int msqflg ) ;

int security_msg_queue_msgctl ( struct msg_queue * msq , int cmd ) ;

int security_msg_queue_msgsnd ( struct msg_queue * msq , struct msg_msg * msg , int msqflg ) ;

int security_msg_queue_msgrcv ( struct msg_queue * msq , struct msg_msg * msg , struct task_struct * target , long type , int mode ) ;

int security_shm_alloc ( struct shmid_kernel * shp ) ;

void security_shm_free ( struct shmid_kernel * shp ) ;

int security_shm_associate ( struct shmid_kernel * shp , int shmflg ) ;

int security_shm_shmctl ( struct shmid_kernel * shp , int cmd ) ;

int security_shm_shmat ( struct shmid_kernel * shp , char * shmaddr , int shmflg ) ;

int security_sem_alloc ( struct sem_array * sma ) ;

void security_sem_free ( struct sem_array * sma ) ;

int security_sem_associate ( struct sem_array * sma , int semflg ) ;

int security_sem_semctl ( struct sem_array * sma , int cmd ) ;

int security_sem_semop ( struct sem_array * sma , struct sembuf * sops , unsigned nsops , int alter ) ;

void security_d_instantiate ( struct dentry * dentry , struct inode * inode ) ;

int security_getprocattr ( struct task_struct * p , char * name , char * * value ) ;

int security_setprocattr ( struct task_struct * p , char * name , void * value , size_t size ) ;

int security_netlink_send ( struct sock * sk , struct sk_buff * skb ) ;

int security_netlink_recv ( struct sk_buff * skb , int cap ) ;

int security_secid_to_secctx ( u32 secid , char * * secdata , u32 * seclen ) ;

int security_secctx_to_secid ( const char * secdata , u32 seclen , u32 * secid ) ;

void security_release_secctx ( char * secdata , u32 seclen ) ;

int security_inode_notifysecctx ( struct inode * inode , void * ctx , u32 ctxlen ) ;

int security_inode_setsecctx ( struct dentry * dentry , void * ctx , u32 ctxlen ) ;

int security_inode_getsecctx ( struct inode * inode , void * * ctx , u32 * ctxlen ) ;

int security_unix_stream_connect ( struct socket * sock , struct socket * other , struct sock * newsk ) ;

int security_unix_may_send ( struct socket * sock , struct socket * other ) ;

int security_socket_create ( int family , int type , int protocol , int kern ) ;

int security_socket_post_create ( struct socket * sock , int family , int type , int protocol , int kern ) ;

int security_socket_bind ( struct socket * sock , struct sockaddr * address , int addrlen ) ;

int security_socket_connect ( struct socket * sock , struct sockaddr * address , int addrlen ) ;

int security_socket_listen ( struct socket * sock , int backlog ) ;

int security_socket_accept ( struct socket * sock , struct socket * newsock ) ;

int security_socket_sendmsg ( struct socket * sock , struct msghdr * msg , int size ) ;

int security_socket_recvmsg ( struct socket * sock , struct msghdr * msg , int size , int flags ) ;

int security_socket_getsockname ( struct socket * sock ) ;

int security_socket_getpeername ( struct socket * sock ) ;

int security_socket_getsockopt ( struct socket * sock , int level , int optname ) ;

int security_socket_setsockopt ( struct socket * sock , int level , int optname ) ;

int security_socket_shutdown ( struct socket * sock , int how ) ;

int security_sock_rcv_skb ( struct sock * sk , struct sk_buff * skb ) ;

int security_socket_getpeersec_stream ( struct socket * sock , char * optval , int * optlen , unsigned len ) ;

int security_socket_getpeersec_dgram ( struct socket * sock , struct sk_buff * skb , u32 * secid ) ;

int security_sk_alloc ( struct sock * sk , int family , gfp_t priority ) ;

void security_sk_free ( struct sock * sk ) ;

void security_sk_clone ( const struct sock * sk , struct sock * newsk ) ;

void security_sk_classify_flow ( struct sock * sk , struct flowi * fl ) ;

void security_req_classify_flow ( const struct request_sock * req , struct flowi * fl ) ;

void security_sock_graft ( struct sock * sk , struct socket * parent ) ;

int security_inet_conn_request ( struct sock * sk , struct sk_buff * skb , struct request_sock * req ) ;

void security_inet_csk_clone ( struct sock * newsk , const struct request_sock * req ) ;

void security_inet_conn_established ( struct sock * sk , struct sk_buff * skb ) ;

int security_tun_dev_create ( void ) ;

void security_tun_dev_post_create ( struct sock * sk ) ;

int security_tun_dev_attach ( struct sock * sk ) ;

int security_key_alloc ( struct key * key , const struct cred * cred , unsigned long flags ) ;

void security_key_free ( struct key * key ) ;

int security_key_permission ( key_ref_t key_ref , const struct cred * cred , key_perm_t perm ) ;

int security_key_getsecurity ( struct key * key , char * * _buffer ) ;

int security_key_session_to_parent ( const struct cred * cred , const struct cred * parent_cred , struct key * key ) ;

int security_audit_rule_init ( u32 field , u32 op , char * rulestr , void * * lsmrule ) ;

int security_audit_rule_known ( struct audit_krule * krule ) ;

void security_audit_rule_free ( void * lsmrule ) ;

int security_audit_rule_match ( u32 secid , u32 field , u32 op , void * lsmrule , struct audit_context * actx ) ;

void security_fixup_ops ( struct security_operations * ops ) ;

struct dentry * securityfs_create_file ( const char * name , mode_t mode , struct dentry * parent , void * data , const struct file_operations * fops ) ;

struct dentry * securityfs_create_dir ( const char * name , struct dentry * parent ) ;

void securityfs_remove ( struct dentry * dentry ) ;


typedef struct sctphdr { __be16 source ; __be16 dest ; __be32 vtag ; __le32 checksum ; } __attribute__ ( ( packed ) ) sctp_sctphdr_t ;


typedef struct sctp_chunkhdr { __u8 type ; __u8 flags ; __be16 length ; } __attribute__ ( ( packed ) ) sctp_chunkhdr_t ;

typedef enum { SCTP_CID_DATA = 0 , SCTP_CID_INIT = 1 , SCTP_CID_INIT_ACK = 2 , SCTP_CID_SACK = 3 , SCTP_CID_HEARTBEAT = 4 , SCTP_CID_HEARTBEAT_ACK = 5 , SCTP_CID_ABORT = 6 , SCTP_CID_SHUTDOWN = 7 , SCTP_CID_SHUTDOWN_ACK = 8 , SCTP_CID_ERROR = 9 , SCTP_CID_COOKIE_ECHO = 10 , SCTP_CID_COOKIE_ACK = 11 , SCTP_CID_ECN_ECNE = 12 , SCTP_CID_ECN_CWR = 13 , SCTP_CID_SHUTDOWN_COMPLETE = 14 , SCTP_CID_AUTH = 0x0F , SCTP_CID_FWD_TSN = 0xC0 , SCTP_CID_ASCONF = 0xC1 , SCTP_CID_ASCONF_ACK = 0x80 , } sctp_cid_t ;

typedef enum { SCTP_CID_ACTION_DISCARD = 0x00 , SCTP_CID_ACTION_DISCARD_ERR = 0x40 , SCTP_CID_ACTION_SKIP = 0x80 , SCTP_CID_ACTION_SKIP_ERR = 0xc0 , } sctp_cid_action_t ;

enum { SCTP_CID_ACTION_MASK = 0xc0 , } ;
enum { SCTP_CHUNK_FLAG_T = 0x01 } ;

typedef struct sctp_paramhdr { __be16 type ; __be16 length ; } __attribute__ ( ( packed ) ) sctp_paramhdr_t ;

typedef enum { SCTP_PARAM_HEARTBEAT_INFO = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 1 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 1 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 1 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 1 ) ) ) ) , SCTP_PARAM_IPV4_ADDRESS = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 5 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 5 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 5 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 5 ) ) ) ) , SCTP_PARAM_IPV6_ADDRESS = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 6 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 6 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 6 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 6 ) ) ) ) , SCTP_PARAM_STATE_COOKIE = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 7 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 7 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 7 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 7 ) ) ) ) , SCTP_PARAM_UNRECOGNIZED_PARAMETERS = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 8 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 8 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 8 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 8 ) ) ) ) , SCTP_PARAM_COOKIE_PRESERVATIVE = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 9 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 9 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 9 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 9 ) ) ) ) , SCTP_PARAM_HOST_NAME_ADDRESS = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 11 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 11 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 11 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 11 ) ) ) ) , SCTP_PARAM_SUPPORTED_ADDRESS_TYPES = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 12 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 12 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 12 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 12 ) ) ) ) , SCTP_PARAM_ECN_CAPABLE = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x8000 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x8000 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x8000 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x8000 ) ) ) ) , SCTP_PARAM_RANDOM = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x8002 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x8002 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x8002 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x8002 ) ) ) ) , SCTP_PARAM_CHUNKS = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x8003 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x8003 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x8003 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x8003 ) ) ) ) , SCTP_PARAM_HMAC_ALGO = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x8004 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x8004 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x8004 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x8004 ) ) ) ) , SCTP_PARAM_SUPPORTED_EXT = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x8008 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x8008 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x8008 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x8008 ) ) ) ) , SCTP_PARAM_FWD_TSN_SUPPORT = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0xc000 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0xc000 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0xc000 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0xc000 ) ) ) ) , SCTP_PARAM_ADD_IP = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0xc001 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0xc001 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0xc001 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0xc001 ) ) ) ) , SCTP_PARAM_DEL_IP = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0xc002 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0xc002 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0xc002 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0xc002 ) ) ) ) , SCTP_PARAM_ERR_CAUSE = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0xc003 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0xc003 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0xc003 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0xc003 ) ) ) ) , SCTP_PARAM_SET_PRIMARY = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0xc004 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0xc004 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0xc004 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0xc004 ) ) ) ) , SCTP_PARAM_SUCCESS_REPORT = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0xc005 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0xc005 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0xc005 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0xc005 ) ) ) ) , SCTP_PARAM_ADAPTATION_LAYER_IND = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0xc006 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0xc006 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0xc006 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0xc006 ) ) ) ) , } sctp_param_t ;

typedef enum { SCTP_PARAM_ACTION_DISCARD = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x0000 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x0000 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x0000 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x0000 ) ) ) ) , SCTP_PARAM_ACTION_DISCARD_ERR = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x4000 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x4000 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x4000 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x4000 ) ) ) ) , SCTP_PARAM_ACTION_SKIP = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x8000 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x8000 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x8000 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x8000 ) ) ) ) , SCTP_PARAM_ACTION_SKIP_ERR = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0xc000 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0xc000 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0xc000 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0xc000 ) ) ) ) , } sctp_param_action_t ;

enum { SCTP_PARAM_ACTION_MASK = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0xc000 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0xc000 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0xc000 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0xc000 ) ) ) ) , } ;

typedef struct sctp_datahdr { __be32 tsn ; __be16 stream ; __be16 ssn ; __be32 ppid ; __u8 payload [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_datahdr_t ;


typedef struct sctp_data_chunk { sctp_chunkhdr_t chunk_hdr ; sctp_datahdr_t data_hdr ; } __attribute__ ( ( packed ) ) sctp_data_chunk_t ;

enum { SCTP_DATA_MIDDLE_FRAG = 0x00 , SCTP_DATA_LAST_FRAG = 0x01 , SCTP_DATA_FIRST_FRAG = 0x02 , SCTP_DATA_NOT_FRAG = 0x03 , SCTP_DATA_UNORDERED = 0x04 , } ;
enum { SCTP_DATA_FRAG_MASK = 0x03 , } ;

typedef struct sctp_inithdr { __be32 init_tag ; __be32 a_rwnd ; __be16 num_outbound_streams ; __be16 num_inbound_streams ; __be32 initial_tsn ; __u8 params [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_inithdr_t ;


typedef struct sctp_init_chunk { sctp_chunkhdr_t chunk_hdr ; sctp_inithdr_t init_hdr ; } __attribute__ ( ( packed ) ) sctp_init_chunk_t ;


typedef struct sctp_ipv4addr_param { sctp_paramhdr_t param_hdr ; struct in_addr addr ; } __attribute__ ( ( packed ) ) sctp_ipv4addr_param_t ;


typedef struct sctp_ipv6addr_param { sctp_paramhdr_t param_hdr ; struct in6_addr addr ; } __attribute__ ( ( packed ) ) sctp_ipv6addr_param_t ;


typedef struct sctp_cookie_preserve_param { sctp_paramhdr_t param_hdr ; __be32 lifespan_increment ; } __attribute__ ( ( packed ) ) sctp_cookie_preserve_param_t ;


typedef struct sctp_hostname_param { sctp_paramhdr_t param_hdr ; uint8_t hostname [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_hostname_param_t ;


typedef struct sctp_supported_addrs_param { sctp_paramhdr_t param_hdr ; __be16 types [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_supported_addrs_param_t ;


typedef struct sctp_ecn_capable_param { sctp_paramhdr_t param_hdr ; } __attribute__ ( ( packed ) ) sctp_ecn_capable_param_t ;


typedef struct sctp_adaptation_ind_param { struct sctp_paramhdr param_hdr ; __be32 adaptation_ind ; } __attribute__ ( ( packed ) ) sctp_adaptation_ind_param_t ;


typedef struct sctp_supported_ext_param { struct sctp_paramhdr param_hdr ; __u8 chunks [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_supported_ext_param_t ;


typedef struct sctp_random_param { sctp_paramhdr_t param_hdr ; __u8 random_val [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_random_param_t ;


typedef struct sctp_chunks_param { sctp_paramhdr_t param_hdr ; __u8 chunks [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_chunks_param_t ;


typedef struct sctp_hmac_algo_param { sctp_paramhdr_t param_hdr ; __be16 hmac_ids [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_hmac_algo_param_t ;

typedef sctp_init_chunk_t sctp_initack_chunk_t ;


typedef struct sctp_cookie_param { sctp_paramhdr_t p ; __u8 body [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_cookie_param_t ;


typedef struct sctp_unrecognized_param { sctp_paramhdr_t param_hdr ; sctp_paramhdr_t unrecognized ; } __attribute__ ( ( packed ) ) sctp_unrecognized_param_t ;


typedef struct sctp_gap_ack_block { __be16 start ; __be16 end ; } __attribute__ ( ( packed ) ) sctp_gap_ack_block_t ;

typedef __be32 sctp_dup_tsn_t ;

typedef union { sctp_gap_ack_block_t gab ; sctp_dup_tsn_t dup ; } sctp_sack_variable_t ;


typedef struct sctp_sackhdr { __be32 cum_tsn_ack ; __be32 a_rwnd ; __be16 num_gap_ack_blocks ; __be16 num_dup_tsns ; sctp_sack_variable_t variable [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_sackhdr_t ;


typedef struct sctp_sack_chunk { sctp_chunkhdr_t chunk_hdr ; sctp_sackhdr_t sack_hdr ; } __attribute__ ( ( packed ) ) sctp_sack_chunk_t ;


typedef struct sctp_heartbeathdr { sctp_paramhdr_t info ; } __attribute__ ( ( packed ) ) sctp_heartbeathdr_t ;


typedef struct sctp_heartbeat_chunk { sctp_chunkhdr_t chunk_hdr ; sctp_heartbeathdr_t hb_hdr ; } __attribute__ ( ( packed ) ) sctp_heartbeat_chunk_t ;


typedef struct sctp_abort_chunk { sctp_chunkhdr_t uh ; } __attribute__ ( ( packed ) ) sctp_abort_chunk_t ;


typedef struct sctp_shutdownhdr { __be32 cum_tsn_ack ; } __attribute__ ( ( packed ) ) sctp_shutdownhdr_t ;

struct sctp_shutdown_chunk_t { sctp_chunkhdr_t chunk_hdr ; sctp_shutdownhdr_t shutdown_hdr ; } __attribute__ ( ( packed ) ) ;

typedef struct sctp_errhdr { __be16 cause ; __be16 length ; __u8 variable [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_errhdr_t ;


typedef struct sctp_operr_chunk { sctp_chunkhdr_t chunk_hdr ; sctp_errhdr_t err_hdr ; } __attribute__ ( ( packed ) ) sctp_operr_chunk_t ;

typedef enum { SCTP_ERROR_NO_ERROR = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x00 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x00 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x00 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x00 ) ) ) ) , SCTP_ERROR_INV_STRM = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x01 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x01 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x01 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x01 ) ) ) ) , SCTP_ERROR_MISS_PARAM = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x02 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x02 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x02 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x02 ) ) ) ) , SCTP_ERROR_STALE_COOKIE = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x03 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x03 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x03 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x03 ) ) ) ) , SCTP_ERROR_NO_RESOURCE = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x04 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x04 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x04 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x04 ) ) ) ) , SCTP_ERROR_DNS_FAILED = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x05 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x05 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x05 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x05 ) ) ) ) , SCTP_ERROR_UNKNOWN_CHUNK = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x06 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x06 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x06 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x06 ) ) ) ) , SCTP_ERROR_INV_PARAM = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x07 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x07 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x07 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x07 ) ) ) ) , SCTP_ERROR_UNKNOWN_PARAM = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x08 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x08 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x08 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x08 ) ) ) ) , SCTP_ERROR_NO_DATA = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x09 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x09 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x09 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x09 ) ) ) ) , SCTP_ERROR_COOKIE_IN_SHUTDOWN = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x0a ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x0a ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x0a ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x0a ) ) ) ) , SCTP_ERROR_RESTART = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x0b ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x0b ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x0b ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x0b ) ) ) ) , SCTP_ERROR_USER_ABORT = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x0c ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x0c ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x0c ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x0c ) ) ) ) , SCTP_ERROR_PROTO_VIOLATION = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x0d ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x0d ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x0d ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x0d ) ) ) ) , SCTP_ERROR_DEL_LAST_IP = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x00A0 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x00A0 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x00A0 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x00A0 ) ) ) ) , SCTP_ERROR_RSRC_LOW = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x00A1 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x00A1 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x00A1 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x00A1 ) ) ) ) , SCTP_ERROR_DEL_SRC_IP = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x00A2 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x00A2 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x00A2 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x00A2 ) ) ) ) , SCTP_ERROR_ASCONF_ACK = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x00A3 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x00A3 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x00A3 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x00A3 ) ) ) ) , SCTP_ERROR_REQ_REFUSED = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x00A4 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x00A4 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x00A4 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x00A4 ) ) ) ) , SCTP_ERROR_UNSUP_HMAC = ( ( __be16 ) ( __builtin_constant_p ( ( __u16 ) ( ( 0x0105 ) ) ) ? ( ( __u16 ) ( ( ( ( __u16 ) ( ( 0x0105 ) ) & ( __u16 ) 0x00ffU ) << 8 ) | ( ( ( __u16 ) ( ( 0x0105 ) ) & ( __u16 ) 0xff00U ) >> 8 ) ) ) : __fswab16 ( ( 0x0105 ) ) ) ) } sctp_error_t ;


typedef struct sctp_ecnehdr { __be32 lowest_tsn ; } sctp_ecnehdr_t ;


typedef struct sctp_ecne_chunk { sctp_chunkhdr_t chunk_hdr ; sctp_ecnehdr_t ence_hdr ; } __attribute__ ( ( packed ) ) sctp_ecne_chunk_t ;


typedef struct sctp_cwrhdr { __be32 lowest_tsn ; } sctp_cwrhdr_t ;


typedef struct sctp_cwr_chunk { sctp_chunkhdr_t chunk_hdr ; sctp_cwrhdr_t cwr_hdr ; } __attribute__ ( ( packed ) ) sctp_cwr_chunk_t ;

struct sctp_fwdtsn_skip { __be16 stream ; __be16 ssn ; } __attribute__ ( ( packed ) ) ;
struct sctp_fwdtsn_hdr { __be32 new_cum_tsn ; struct sctp_fwdtsn_skip skip [ 0 ] ; } __attribute ( ( packed ) ) ;
struct sctp_fwdtsn_chunk { struct sctp_chunkhdr chunk_hdr ; struct sctp_fwdtsn_hdr fwdtsn_hdr ; } __attribute ( ( packed ) ) ;

typedef struct sctp_addip_param { sctp_paramhdr_t param_hdr ; __be32 crr_id ; } __attribute__ ( ( packed ) ) sctp_addip_param_t ;


typedef struct sctp_addiphdr { __be32 serial ; __u8 params [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_addiphdr_t ;


typedef struct sctp_addip_chunk { sctp_chunkhdr_t chunk_hdr ; sctp_addiphdr_t addip_hdr ; } __attribute__ ( ( packed ) ) sctp_addip_chunk_t ;


typedef struct sctp_authhdr { __be16 shkey_id ; __be16 hmac_id ; __u8 hmac [ 0 ] ; } __attribute__ ( ( packed ) ) sctp_authhdr_t ;


typedef struct sctp_auth_chunk { sctp_chunkhdr_t chunk_hdr ; sctp_authhdr_t auth_hdr ; } __attribute__ ( ( packed ) ) sctp_auth_chunk_t ;

int ipv4_skb_to_auditdata ( struct sk_buff * skb , struct common_audit_data * ad , u8 * proto ) ;

int ipv6_skb_to_auditdata ( struct sk_buff * skb , struct common_audit_data * ad , u8 * proto ) ;

void common_lsm_audit ( struct common_audit_data * a ) ;

struct dev_whitelist_item { u32 major , minor ; short type ; short access ; struct list_head list ; struct rcu_head rcu ; } ;

struct dev_cgroup { struct cgroup_subsys_state css ; struct list_head whitelist ; } ;

int devcgroup_inode_permission ( struct inode * inode , int mask ) ;

int devcgroup_inode_mknod ( int mode , dev_t dev ) ;

struct rtattr ;
struct crypto_type { unsigned int ( * ctxsize ) ( struct crypto_alg * alg , u32 type , u32 mask ) ; unsigned int ( * extsize ) ( struct crypto_alg * alg ) ; int ( * init ) ( struct crypto_tfm * tfm , u32 type , u32 mask ) ; int ( * init_tfm ) ( struct crypto_tfm * tfm ) ; void ( * show ) ( struct seq_file * m , struct crypto_alg * alg ) ; struct crypto_alg * ( * lookup ) ( const char * name , u32 type , u32 mask ) ; unsigned int type ; unsigned int maskclear ; unsigned int maskset ; unsigned int tfmsize ; } ;
struct crypto_instance { struct crypto_alg alg ; struct crypto_template * tmpl ; struct hlist_node list ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;

struct crypto_template { struct list_head list ; struct hlist_head instances ; struct module * module ; struct crypto_instance * ( * alloc ) ( struct rtattr * * tb ) ; void ( * free ) ( struct crypto_instance * inst ) ; int ( * create ) ( struct crypto_template * tmpl , struct rtattr * * tb ) ; char name [ 64 ] ; } ;

struct crypto_spawn { struct list_head list ; struct crypto_alg * alg ; struct crypto_instance * inst ; const struct crypto_type * frontend ; u32 mask ; } ;

struct crypto_queue { struct list_head list ; struct list_head * backlog ; unsigned int qlen ; unsigned int max_qlen ; } ;

struct scatter_walk { struct scatterlist * sg ; unsigned int offset ; } ;

struct blkcipher_walk { union { struct { struct page * page ; unsigned long offset ; } phys ; struct { u8 * page ; u8 * addr ; } virt ; } src , dst ; struct scatter_walk in ; unsigned int nbytes ; struct scatter_walk out ; unsigned int total ; void * page ; u8 * buffer ; u8 * iv ; int flags ; unsigned int blocksize ; } ;

enum { CRYPTO_MSG_ALG_REQUEST , CRYPTO_MSG_ALG_REGISTER , CRYPTO_MSG_ALG_UNREGISTER , CRYPTO_MSG_TMPL_REGISTER , CRYPTO_MSG_TMPL_UNREGISTER , } ;
struct crypto_instance ;
struct crypto_template ;
struct crypto_larval { struct crypto_alg alg ; struct crypto_alg * adult ; struct completion completion ; u32 mask ; } ;

struct crypto_alg * crypto_mod_get ( struct crypto_alg * alg ) ;

void crypto_mod_put ( struct crypto_alg * alg ) ;

struct crypto_larval * crypto_larval_alloc ( const char * name , u32 type , u32 mask ) ;

void crypto_larval_kill ( struct crypto_alg * alg ) ;

struct crypto_alg * crypto_alg_lookup ( const char * name , u32 type , u32 mask ) ;

struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) ;

int crypto_probing_notify ( unsigned long val , void * v ) ;

struct crypto_alg * crypto_alg_mod_lookup ( const char * name , u32 type , u32 mask ) ;

void crypto_shoot_alg ( struct crypto_alg * alg ) ;

struct crypto_tfm * __crypto_alloc_tfm ( struct crypto_alg * alg , u32 type , u32 mask ) ;

struct crypto_tfm * crypto_alloc_base ( const char * alg_name , u32 type , u32 mask ) ;

void * crypto_create_tfm ( struct crypto_alg * alg , const struct crypto_type * frontend ) ;

struct crypto_alg * crypto_find_alg ( const char * alg_name , const struct crypto_type * frontend , u32 type , u32 mask ) ;

void * crypto_alloc_tfm ( const char * alg_name , const struct crypto_type * frontend , u32 type , u32 mask ) ;

void crypto_destroy_tfm ( void * mem , struct crypto_tfm * tfm ) ;

int crypto_has_alg ( const char * name , u32 type , u32 mask ) ;

int crypto_init_cipher_ops ( struct crypto_tfm * tfm ) ;

void crypto_exit_cipher_ops ( struct crypto_tfm * tfm ) ;

int crypto_init_compress_ops ( struct crypto_tfm * tfm ) ;

void crypto_exit_compress_ops ( struct crypto_tfm * tfm ) ;

void crypto_larval_error ( const char * name , u32 type , u32 mask ) ;

void crypto_alg_tested ( const char * name , int err ) ;

int crypto_register_alg ( struct crypto_alg * alg ) ;

int crypto_unregister_alg ( struct crypto_alg * alg ) ;

int crypto_register_template ( struct crypto_template * tmpl ) ;

void crypto_unregister_template ( struct crypto_template * tmpl ) ;

struct crypto_template * crypto_lookup_template ( const char * name ) ;

int crypto_register_instance ( struct crypto_template * tmpl , struct crypto_instance * inst ) ;

int crypto_init_spawn ( struct crypto_spawn * spawn , struct crypto_alg * alg , struct crypto_instance * inst , u32 mask ) ;

int crypto_init_spawn2 ( struct crypto_spawn * spawn , struct crypto_alg * alg , struct crypto_instance * inst , const struct crypto_type * frontend ) ;

void crypto_drop_spawn ( struct crypto_spawn * spawn ) ;

struct crypto_tfm * crypto_spawn_tfm ( struct crypto_spawn * spawn , u32 type , u32 mask ) ;

void * crypto_spawn_tfm2 ( struct crypto_spawn * spawn ) ;

int crypto_register_notifier ( struct notifier_block * nb ) ;

int crypto_unregister_notifier ( struct notifier_block * nb ) ;

struct crypto_attr_type * crypto_get_attr_type ( struct rtattr * * tb ) ;

int crypto_check_attr_type ( struct rtattr * * tb , u32 type ) ;

const char * crypto_attr_alg_name ( struct rtattr * rta ) ;

struct crypto_alg * crypto_attr_alg2 ( struct rtattr * rta , const struct crypto_type * frontend , u32 type , u32 mask ) ;

int crypto_attr_u32 ( struct rtattr * rta , u32 * num ) ;
void * crypto_alloc_instance2 ( const char * name , struct crypto_alg * alg , unsigned int head ) ;

struct crypto_instance * crypto_alloc_instance ( const char * name , struct crypto_alg * alg ) ;

void crypto_init_queue ( struct crypto_queue * queue , unsigned int max_qlen ) ;

int crypto_enqueue_request ( struct crypto_queue * queue , struct crypto_async_request * request ) ;

void * __crypto_dequeue_request ( struct crypto_queue * queue , unsigned int offset ) ;

struct crypto_async_request * crypto_dequeue_request ( struct crypto_queue * queue ) ;

int crypto_tfm_in_queue ( struct crypto_queue * queue , struct crypto_tfm * tfm ) ;

void crypto_inc ( u8 * a , unsigned int size ) ;

void crypto_xor ( u8 * dst , const u8 * src , unsigned int size ) ;

void scatterwalk_start ( struct scatter_walk * walk , struct scatterlist * sg ) ;

void * scatterwalk_map ( struct scatter_walk * walk , int out ) ;

void scatterwalk_done ( struct scatter_walk * walk , int out , int more ) ;

void scatterwalk_copychunks ( void * buf , struct scatter_walk * walk , size_t nbytes , int out ) ;

void scatterwalk_map_and_copy ( void * buf , struct scatterlist * sg , unsigned int start , unsigned int nbytes , int out ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) crypto_init_proc ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __used__ ) ) __attribute__ ( ( __cold__ ) ) crypto_exit_proc ( void ) ;

struct skcipher_givcrypt_request { u64 seq ; u8 * giv ; struct ablkcipher_request creq ; } ;
struct crypto_skcipher_spawn { struct crypto_spawn base ; } ;

int skcipher_null_givencrypt ( struct skcipher_givcrypt_request * req ) ;

int skcipher_null_givdecrypt ( struct skcipher_givcrypt_request * req ) ;

const char * crypto_default_geniv ( const struct crypto_alg * alg ) ;

int crypto_grab_skcipher ( struct crypto_skcipher_spawn * spawn , const char * name , u32 type , u32 mask ) ;

struct crypto_ablkcipher * crypto_alloc_ablkcipher ( const char * alg_name , u32 type , u32 mask ) ;

enum { BLKCIPHER_WALK_PHYS = 1 << 0 , BLKCIPHER_WALK_SLOW = 1 << 1 , BLKCIPHER_WALK_COPY = 1 << 2 , BLKCIPHER_WALK_DIFF = 1 << 3 , } ;
int blkcipher_walk_done ( struct blkcipher_desc * desc , struct blkcipher_walk * walk , int err ) ;

int blkcipher_walk_virt ( struct blkcipher_desc * desc , struct blkcipher_walk * walk ) ;

int blkcipher_walk_phys ( struct blkcipher_desc * desc , struct blkcipher_walk * walk ) ;

int blkcipher_walk_virt_block ( struct blkcipher_desc * desc , struct blkcipher_walk * walk , unsigned int blocksize ) ;

struct crypto_instance * skcipher_geniv_alloc ( struct crypto_template * tmpl , struct rtattr * * tb , u32 type , u32 mask ) ;

void skcipher_geniv_free ( struct crypto_instance * inst ) ;

int skcipher_geniv_init ( struct crypto_tfm * tfm ) ;

void skcipher_geniv_exit ( struct crypto_tfm * tfm ) ;

struct crypto_ahash ;

struct hash_alg_common { unsigned int digestsize ; unsigned int statesize ; struct crypto_alg base ; } ;

struct ahash_request { struct crypto_async_request base ; unsigned int nbytes ; struct scatterlist * src ; u8 * result ; void * priv ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;

struct ahash_alg { int ( * init ) ( struct ahash_request * req ) ; int ( * update ) ( struct ahash_request * req ) ; int ( * final ) ( struct ahash_request * req ) ; int ( * finup ) ( struct ahash_request * req ) ; int ( * digest ) ( struct ahash_request * req ) ; int ( * export ) ( struct ahash_request * req , void * out ) ; int ( * import ) ( struct ahash_request * req , const void * in ) ; int ( * setkey ) ( struct crypto_ahash * tfm , const u8 * key , unsigned int keylen ) ; struct hash_alg_common halg ; } ;

struct shash_desc { struct crypto_shash * tfm ; u32 flags ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;

struct shash_alg { int ( * init ) ( struct shash_desc * desc ) ; int ( * update ) ( struct shash_desc * desc , const u8 * data , unsigned int len ) ; int ( * final ) ( struct shash_desc * desc , u8 * out ) ; int ( * finup ) ( struct shash_desc * desc , const u8 * data , unsigned int len , u8 * out ) ; int ( * digest ) ( struct shash_desc * desc , const u8 * data , unsigned int len , u8 * out ) ; int ( * export ) ( struct shash_desc * desc , void * out ) ; int ( * import ) ( struct shash_desc * desc , const void * in ) ; int ( * setkey ) ( struct crypto_shash * tfm , const u8 * key , unsigned int keylen ) ; unsigned int descsize ; unsigned int digestsize __attribute__ ( ( aligned ( __alignof__ ( struct hash_alg_common ) ) ) ) ; unsigned int statesize ; struct crypto_alg base ; } ;

struct crypto_ahash { int ( * init ) ( struct ahash_request * req ) ; int ( * update ) ( struct ahash_request * req ) ; int ( * final ) ( struct ahash_request * req ) ; int ( * finup ) ( struct ahash_request * req ) ; int ( * digest ) ( struct ahash_request * req ) ; int ( * export ) ( struct ahash_request * req , void * out ) ; int ( * import ) ( struct ahash_request * req , const void * in ) ; int ( * setkey ) ( struct crypto_ahash * tfm , const u8 * key , unsigned int keylen ) ; unsigned int reqsize ; struct crypto_tfm base ; } ;
struct crypto_shash { unsigned int descsize ; struct crypto_tfm base ; } ;

struct ahash_request ;
struct crypto_hash_walk { char * data ; unsigned int offset ; unsigned int alignmask ; struct page * pg ; unsigned int entrylen ; unsigned int total ; struct scatterlist * sg ; unsigned int flags ; } ;

struct ahash_instance { struct ahash_alg alg ; } ;

struct shash_instance { struct shash_alg alg ; } ;

struct crypto_ahash_spawn { struct crypto_spawn base ; } ;

struct crypto_shash_spawn { struct crypto_spawn base ; } ;

struct ahash_request_priv { crypto_completion_t complete ; void * data ; u8 * result ; void * ubuf [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; } ;

int crypto_hash_walk_done ( struct crypto_hash_walk * walk , int err ) ;

int crypto_hash_walk_first ( struct ahash_request * req , struct crypto_hash_walk * walk ) ;

int crypto_hash_walk_first_compat ( struct hash_desc * hdesc , struct crypto_hash_walk * walk , struct scatterlist * sg , unsigned int len ) ;

int crypto_ahash_setkey ( struct crypto_ahash * tfm , const u8 * key , unsigned int keylen ) ;

int crypto_ahash_final ( struct ahash_request * req ) ;

int crypto_ahash_finup ( struct ahash_request * req ) ;

int crypto_ahash_digest ( struct ahash_request * req ) ;

struct crypto_ahash * crypto_alloc_ahash ( const char * alg_name , u32 type , u32 mask ) ;

int crypto_register_ahash ( struct ahash_alg * alg ) ;

int crypto_unregister_ahash ( struct ahash_alg * alg ) ;

int ahash_register_instance ( struct crypto_template * tmpl , struct ahash_instance * inst ) ;

void ahash_free_instance ( struct crypto_instance * inst ) ;

int crypto_init_ahash_spawn ( struct crypto_ahash_spawn * spawn , struct hash_alg_common * alg , struct crypto_instance * inst ) ;

struct hash_alg_common * ahash_attr_alg ( struct rtattr * rta , u32 type , u32 mask ) ;

int crypto_shash_setkey ( struct crypto_shash * tfm , const u8 * key , unsigned int keylen ) ;

int crypto_shash_update ( struct shash_desc * desc , const u8 * data , unsigned int len ) ;

int crypto_shash_final ( struct shash_desc * desc , u8 * out ) ;

int crypto_shash_finup ( struct shash_desc * desc , const u8 * data , unsigned int len , u8 * out ) ;

int crypto_shash_digest ( struct shash_desc * desc , const u8 * data , unsigned int len , u8 * out ) ;

int shash_ahash_update ( struct ahash_request * req , struct shash_desc * desc ) ;

int shash_ahash_finup ( struct ahash_request * req , struct shash_desc * desc ) ;

int shash_ahash_digest ( struct ahash_request * req , struct shash_desc * desc ) ;

int crypto_init_shash_ops_async ( struct crypto_tfm * tfm ) ;

struct crypto_shash * crypto_alloc_shash ( const char * alg_name , u32 type , u32 mask ) ;

int crypto_register_shash ( struct shash_alg * alg ) ;

int crypto_unregister_shash ( struct shash_alg * alg ) ;

int shash_register_instance ( struct crypto_template * tmpl , struct shash_instance * inst ) ;

void shash_free_instance ( struct crypto_instance * inst ) ;

int crypto_init_shash_spawn ( struct crypto_shash_spawn * spawn , struct shash_alg * alg , struct crypto_instance * inst ) ;

struct shash_alg * shash_attr_alg ( struct rtattr * rta , u32 type , u32 mask ) ;

struct aead_givcrypt_request { u64 seq ; u8 * giv ; struct aead_request areq ; } ;
struct crypto_aead_spawn { struct crypto_spawn base ; } ;

struct cryptomgr_param { struct rtattr * tb [ 32 + 2 ] ; struct { struct rtattr attr ; struct crypto_attr_type data ; } type ; union { struct rtattr attr ; struct { struct rtattr attr ; struct crypto_attr_alg data ; } alg ; struct { struct rtattr attr ; struct crypto_attr_u32 data ; } nu32 ; } attrs [ 32 ] ; char larval [ 64 ] ; char template [ 64 ] ; u32 otype ; u32 omask ; } ;

struct crypto_test_param { char driver [ 64 ] ; char alg [ 64 ] ; u32 type ; } ;

struct comp_request { const void * next_in ; void * next_out ; unsigned int avail_in ; unsigned int avail_out ; } ;

enum zlib_comp_params { ZLIB_COMP_LEVEL = 1 , ZLIB_COMP_METHOD , ZLIB_COMP_WINDOWBITS , ZLIB_COMP_MEMLEVEL , ZLIB_COMP_STRATEGY , __ZLIB_COMP_MAX , } ;

enum zlib_decomp_params { ZLIB_DECOMP_WINDOWBITS = 1 , __ZLIB_DECOMP_MAX , } ;

struct crypto_pcomp { struct crypto_tfm base ; } ;

struct pcomp_alg { int ( * compress_setup ) ( struct crypto_pcomp * tfm , void * params , unsigned int len ) ; int ( * compress_init ) ( struct crypto_pcomp * tfm ) ; int ( * compress_update ) ( struct crypto_pcomp * tfm , struct comp_request * req ) ; int ( * compress_final ) ( struct crypto_pcomp * tfm , struct comp_request * req ) ; int ( * decompress_setup ) ( struct crypto_pcomp * tfm , void * params , unsigned int len ) ; int ( * decompress_init ) ( struct crypto_pcomp * tfm ) ; int ( * decompress_update ) ( struct crypto_pcomp * tfm , struct comp_request * req ) ; int ( * decompress_final ) ( struct crypto_pcomp * tfm , struct comp_request * req ) ; struct crypto_alg base ; } ;

struct hash_testvec { char * key ; char * plaintext ; char * digest ; unsigned char tap [ 8 ] ; unsigned char psize ; unsigned char np ; unsigned char ksize ; } ;

struct cipher_testvec { char * key ; char * iv ; char * input ; char * result ; unsigned short tap [ 8 ] ; int np ; unsigned char fail ; unsigned char wk ; unsigned char klen ; unsigned short ilen ; unsigned short rlen ; } ;

struct aead_testvec { char * key ; char * iv ; char * input ; char * assoc ; char * result ; unsigned char tap [ 8 ] ; unsigned char atap [ 8 ] ; int np ; int anp ; unsigned char fail ; unsigned char novrfy ; unsigned char wk ; unsigned char klen ; unsigned short ilen ; unsigned short alen ; unsigned short rlen ; } ;

struct cprng_testvec { char * key ; char * dt ; char * v ; char * result ; unsigned char klen ; unsigned short dtlen ; unsigned short vlen ; unsigned short rlen ; unsigned short loops ; } ;

struct comp_testvec { int inlen , outlen ; char input [ 512 ] ; char output [ 512 ] ; } ;

struct pcomp_testvec { void * params ; unsigned int paramsize ; int inlen , outlen ; char input [ 512 ] ; char output [ 512 ] ; } ;

struct tcrypt_result { struct completion completion ; int err ; } ;

struct aead_test_suite { struct { struct aead_testvec * vecs ; unsigned int count ; } enc , dec ; } ;

struct cipher_test_suite { struct { struct cipher_testvec * vecs ; unsigned int count ; } enc , dec ; } ;

struct comp_test_suite { struct { struct comp_testvec * vecs ; unsigned int count ; } comp , decomp ; } ;

struct pcomp_test_suite { struct { struct pcomp_testvec * vecs ; unsigned int count ; } comp , decomp ; } ;

struct hash_test_suite { struct hash_testvec * vecs ; unsigned int count ; } ;

struct cprng_test_suite { struct cprng_testvec * vecs ; unsigned int count ; } ;

struct alg_test_desc { const char * alg ; int ( * test ) ( const struct alg_test_desc * desc , const char * driver , u32 type , u32 mask ) ; int fips_allowed ; union { struct aead_test_suite aead ; struct cipher_test_suite cipher ; struct comp_test_suite comp ; struct pcomp_test_suite pcomp ; struct hash_test_suite hash ; struct cprng_test_suite cprng ; } suite ; } ;

int alg_test ( const char * driver , const char * alg , u32 type , u32 mask ) ;

int crypto_aead_setauthsize ( struct crypto_aead * tfm , unsigned int authsize ) ;

struct crypto_instance * aead_geniv_alloc ( struct crypto_template * tmpl , struct rtattr * * tb , u32 type , u32 mask ) ;

void aead_geniv_free ( struct crypto_instance * inst ) ;

int aead_geniv_init ( struct crypto_tfm * tfm ) ;

void aead_geniv_exit ( struct crypto_tfm * tfm ) ;

int crypto_grab_aead ( struct crypto_aead_spawn * spawn , const char * name , u32 type , u32 mask ) ;

struct crypto_aead * crypto_alloc_aead ( const char * alg_name , u32 type , u32 mask ) ;

enum { CHAINIV_STATE_INUSE = 0 , } ;
struct chainiv_ctx { spinlock_t lock ; char iv [ ] ; } ;

struct async_chainiv_ctx { unsigned long state ; spinlock_t lock ; int err ; struct crypto_queue queue ; struct work_struct postponed ; char iv [ ] ; } ;

struct eseqiv_request_ctx { struct scatterlist src [ 2 ] ; struct scatterlist dst [ 2 ] ; char tail [ ] ; } ;

struct eseqiv_ctx { spinlock_t lock ; unsigned int reqoff ; char salt [ ] ; } ;

struct crypto_pcomp * crypto_alloc_pcomp ( const char * alg_name , u32 type , u32 mask ) ;

int crypto_register_pcomp ( struct pcomp_alg * alg ) ;

int crypto_unregister_pcomp ( struct pcomp_alg * alg ) ;

struct hmac_ctx { struct crypto_shash * hash ; } ;

struct md5_ctx { u32 hash [ 4 ] ; u32 block [ 16 ] ; u64 byte_count ; } ;

struct crypto_ecb_ctx { struct crypto_cipher * child ; } ;

struct crypto_cbc_ctx { struct crypto_cipher * child ; } ;

int crypto_get_default_rng ( void ) ;

void crypto_put_default_rng ( void ) ;

struct des_ctx { u32 expkey [ 32 ] ; } ;

struct des3_ede_ctx { u32 expkey [ ( 3 * 32 ) ] ; } ;

unsigned long des_ekey ( u32 * pe , const u8 * k ) ;

struct deflate_ctx { struct z_stream_s comp_stream ; struct z_stream_s decomp_stream ; } ;

struct zlib_ctx { struct z_stream_s comp_stream ; struct z_stream_s decomp_stream ; int decomp_windowBits ; } ;

struct chksum_ctx { u32 key ; } ;

struct chksum_desc_ctx { u32 crc ; } ;

enum rq_atomic_flags { REQ_ATOM_COMPLETE = 0 , } ;

int elv_rq_merge_ok ( struct request * rq , struct bio * bio ) ;

int elevator_init ( struct request_queue * q , char * name ) ;

void elevator_exit ( struct elevator_queue * e ) ;

struct request * elv_rb_add ( struct rb_root * root , struct request * rq ) ;

void elv_rb_del ( struct rb_root * root , struct request * rq ) ;

struct request * elv_rb_find ( struct rb_root * root , sector_t sector ) ;

void elv_dispatch_sort ( struct request_queue * q , struct request * rq ) ;

void elv_dispatch_add_tail ( struct request_queue * q , struct request * rq ) ;

int elv_merge ( struct request_queue * q , struct request * * req , struct bio * bio ) ;

void elv_merged_request ( struct request_queue * q , struct request * rq , int type ) ;

void elv_merge_requests ( struct request_queue * q , struct request * rq , struct request * next ) ;

void elv_requeue_request ( struct request_queue * q , struct request * rq ) ;

void elv_drain_elevator ( struct request_queue * q ) ;

void elv_quiesce_start ( struct request_queue * q ) ;

void elv_quiesce_end ( struct request_queue * q ) ;

void elv_insert ( struct request_queue * q , struct request * rq , int where ) ;

void __elv_add_request ( struct request_queue * q , struct request * rq , int where , int plug ) ;

void elv_add_request ( struct request_queue * q , struct request * rq , int where , int plug ) ;

int elv_queue_empty ( struct request_queue * q ) ;

struct request * elv_latter_request ( struct request_queue * q , struct request * rq ) ;

struct request * elv_former_request ( struct request_queue * q , struct request * rq ) ;

int elv_set_request ( struct request_queue * q , struct request * rq , gfp_t gfp_mask ) ;

void elv_put_request ( struct request_queue * q , struct request * rq ) ;

int elv_may_queue ( struct request_queue * q , int rw ) ;

void elv_abort_queue ( struct request_queue * q ) ;

void elv_completed_request ( struct request_queue * q , struct request * rq ) ;

int elv_register_queue ( struct request_queue * q ) ;

void elv_unregister_queue ( struct request_queue * q ) ;

void elv_register ( struct elevator_type * e ) ;

void elv_unregister ( struct elevator_type * e ) ;

ssize_t elv_iosched_store ( struct request_queue * q , const char * name , size_t count ) ;

ssize_t elv_iosched_show ( struct request_queue * q , char * name ) ;

struct request * elv_rb_former_request ( struct request_queue * q , struct request * rq ) ;

struct request * elv_rb_latter_request ( struct request_queue * q , struct request * rq ) ;

struct ftrace_raw_block_rq_abort { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; int errors ; char rwbs [ 6 ] ; u32 __data_loc_cmd ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_rq_insert { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; unsigned int bytes ; char rwbs [ 6 ] ; char comm [ 16 ] ; u32 __data_loc_cmd ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_rq_issue { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; unsigned int bytes ; char rwbs [ 6 ] ; char comm [ 16 ] ; u32 __data_loc_cmd ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_rq_requeue { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; int errors ; char rwbs [ 6 ] ; u32 __data_loc_cmd ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_rq_complete { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; int errors ; char rwbs [ 6 ] ; u32 __data_loc_cmd ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_bio_bounce { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; char rwbs [ 6 ] ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_bio_complete { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned nr_sector ; int error ; char rwbs [ 6 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_bio_backmerge { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; char rwbs [ 6 ] ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_bio_frontmerge { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned nr_sector ; char rwbs [ 6 ] ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_bio_queue { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; char rwbs [ 6 ] ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_getrq { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; char rwbs [ 6 ] ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_sleeprq { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; char rwbs [ 6 ] ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_plug { struct trace_entry ent ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_unplug_timer { struct trace_entry ent ; int nr_rq ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_unplug_io { struct trace_entry ent ; int nr_rq ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_split { struct trace_entry ent ; dev_t dev ; sector_t sector ; sector_t new_sector ; char rwbs [ 6 ] ; char comm [ 16 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_remap { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; dev_t old_dev ; sector_t old_sector ; char rwbs [ 6 ] ; char __data [ 0 ] ; } ;

struct ftrace_raw_block_rq_remap { struct trace_entry ent ; dev_t dev ; sector_t sector ; unsigned int nr_sector ; dev_t old_dev ; sector_t old_sector ; char rwbs [ 6 ] ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_block_rq_abort { u32 cmd ; ; } ;

struct ftrace_data_offsets_block_rq_insert { u32 cmd ; ; } ;

struct ftrace_data_offsets_block_rq_issue { u32 cmd ; ; } ;

struct ftrace_data_offsets_block_rq_requeue { u32 cmd ; ; } ;

struct ftrace_data_offsets_block_rq_complete { u32 cmd ; ; } ;

struct ftrace_data_offsets_block_bio_bounce { ; } ;

struct ftrace_data_offsets_block_bio_complete { ; } ;

struct ftrace_data_offsets_block_bio_backmerge { ; } ;

struct ftrace_data_offsets_block_bio_frontmerge { ; } ;

struct ftrace_data_offsets_block_bio_queue { ; } ;

struct ftrace_data_offsets_block_getrq { ; } ;

struct ftrace_data_offsets_block_sleeprq { ; } ;

struct ftrace_data_offsets_block_plug { ; } ;

struct ftrace_data_offsets_block_unplug_timer { ; } ;

struct ftrace_data_offsets_block_unplug_io { ; } ;

struct ftrace_data_offsets_block_split { ; } ;

struct ftrace_data_offsets_block_remap { ; } ;

struct ftrace_data_offsets_block_rq_remap { ; } ;

void blk_queue_congestion_threshold ( struct request_queue * q ) ;

struct backing_dev_info * blk_get_backing_dev_info ( struct block_device * bdev ) ;

void blk_rq_init ( struct request_queue * q , struct request * rq ) ;

void blk_dump_rq_flags ( struct request * rq , char * msg ) ;

void blk_plug_device ( struct request_queue * q ) ;

void blk_plug_device_unlocked ( struct request_queue * q ) ;

int blk_remove_plug ( struct request_queue * q ) ;

void __generic_unplug_device ( struct request_queue * q ) ;

void generic_unplug_device ( struct request_queue * q ) ;

void blk_unplug_work ( struct work_struct * work ) ;

void blk_unplug_timeout ( unsigned long data ) ;

void blk_unplug ( struct request_queue * q ) ;

void blk_start_queue ( struct request_queue * q ) ;

void blk_stop_queue ( struct request_queue * q ) ;

void blk_sync_queue ( struct request_queue * q ) ;

void __blk_run_queue ( struct request_queue * q ) ;

void blk_run_queue ( struct request_queue * q ) ;

void blk_put_queue ( struct request_queue * q ) ;

void blk_cleanup_queue ( struct request_queue * q ) ;

struct request_queue * blk_alloc_queue ( gfp_t gfp_mask ) ;

struct request_queue * blk_alloc_queue_node ( gfp_t gfp_mask , int node_id ) ;

struct request_queue * blk_init_queue ( request_fn_proc * rfn , spinlock_t * lock ) ;

struct request_queue * blk_init_queue_node ( request_fn_proc * rfn , spinlock_t * lock , int node_id ) ;

int blk_get_queue ( struct request_queue * q ) ;

struct request * blk_get_request ( struct request_queue * q , int rw , gfp_t gfp_mask ) ;

struct request * blk_make_request ( struct request_queue * q , struct bio * bio , gfp_t gfp_mask ) ;

void blk_requeue_request ( struct request_queue * q , struct request * rq ) ;

void blk_insert_request ( struct request_queue * q , struct request * rq , int at_head , void * data ) ;

void part_round_stats ( int cpu , struct hd_struct * part ) ;

void __blk_put_request ( struct request_queue * q , struct request * req ) ;

void blk_put_request ( struct request * req ) ;

void init_request_from_bio ( struct request * req , struct bio * bio ) ;

void generic_make_request ( struct bio * bio ) ;

void submit_bio ( int rw , struct bio * bio ) ;

int blk_rq_check_limits ( struct request_queue * q , struct request * rq ) ;

int blk_insert_cloned_request ( struct request_queue * q , struct request * rq ) ;

unsigned int blk_rq_err_bytes ( const struct request * rq ) ;

struct request * blk_peek_request ( struct request_queue * q ) ;

void blk_dequeue_request ( struct request * rq ) ;

void blk_start_request ( struct request * req ) ;

struct request * blk_fetch_request ( struct request_queue * q ) ;

bool blk_update_request ( struct request * req , int error , unsigned int nr_bytes ) ;

bool blk_end_request ( struct request * rq , int error , unsigned int nr_bytes ) ;

void blk_end_request_all ( struct request * rq , int error ) ;

bool blk_end_request_cur ( struct request * rq , int error ) ;

bool blk_end_request_err ( struct request * rq , int error ) ;

bool __blk_end_request ( struct request * rq , int error , unsigned int nr_bytes ) ;

void __blk_end_request_all ( struct request * rq , int error ) ;

bool __blk_end_request_cur ( struct request * rq , int error ) ;

bool __blk_end_request_err ( struct request * rq , int error ) ;

void blk_rq_bio_prep ( struct request_queue * q , struct request * rq , struct bio * bio ) ;

int blk_lld_busy ( struct request_queue * q ) ;

void blk_rq_unprep_clone ( struct request * rq ) ;

int blk_rq_prep_clone ( struct request * rq , struct request * rq_src , struct bio_set * bs , gfp_t gfp_mask , int ( * bio_ctr ) ( struct bio * , struct bio * , void * ) , void * data ) ;

int kblockd_schedule_work ( struct request_queue * q , struct work_struct * work ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) blk_dev_init ( void ) ;

struct request * blk_queue_find_tag ( struct request_queue * q , int tag ) ;

void __blk_queue_free_tags ( struct request_queue * q ) ;

void blk_free_tags ( struct blk_queue_tag * bqt ) ;

void blk_queue_free_tags ( struct request_queue * q ) ;

struct blk_queue_tag * blk_init_tags ( int depth ) ;

int blk_queue_init_tags ( struct request_queue * q , int depth , struct blk_queue_tag * tags ) ;

int blk_queue_resize_tags ( struct request_queue * q , int new_depth ) ;

void blk_queue_end_tag ( struct request_queue * q , struct request * rq ) ;

int blk_queue_start_tag ( struct request_queue * q , struct request * rq ) ;

void blk_queue_invalidate_tags ( struct request_queue * q ) ;

struct queue_sysfs_entry { struct attribute attr ; ssize_t ( * show ) ( struct request_queue * , char * ) ; ssize_t ( * store ) ( struct request_queue * , const char * , size_t ) ; } ;

int blk_register_queue ( struct gendisk * disk ) ;

void blk_unregister_queue ( struct gendisk * disk ) ;

int blk_queue_ordered ( struct request_queue * q , unsigned ordered , prepare_flush_fn * prepare_flush_fn ) ;

unsigned blk_ordered_cur_seq ( struct request_queue * q ) ;

unsigned blk_ordered_req_seq ( struct request * rq ) ;

bool blk_ordered_complete_seq ( struct request_queue * q , unsigned seq , int error ) ;

bool blk_do_ordered ( struct request_queue * q , struct request * * rqp ) ;

int blkdev_issue_flush ( struct block_device * bdev , sector_t * error_sector ) ;

int blkdev_issue_discard ( struct block_device * bdev , sector_t sector , sector_t nr_sects , gfp_t gfp_mask , int flags ) ;

void blk_queue_prep_rq ( struct request_queue * q , prep_rq_fn * pfn ) ;

void blk_queue_merge_bvec ( struct request_queue * q , merge_bvec_fn * mbfn ) ;

void blk_queue_softirq_done ( struct request_queue * q , softirq_done_fn * fn ) ;

void blk_queue_rq_timeout ( struct request_queue * q , unsigned int timeout ) ;

void blk_queue_rq_timed_out ( struct request_queue * q , rq_timed_out_fn * fn ) ;

void blk_queue_lld_busy ( struct request_queue * q , lld_busy_fn * fn ) ;

void blk_set_default_limits ( struct queue_limits * lim ) ;

void blk_queue_make_request ( struct request_queue * q , make_request_fn * mfn ) ;

void blk_queue_bounce_limit ( struct request_queue * q , u64 dma_mask ) ;

void blk_queue_max_sectors ( struct request_queue * q , unsigned int max_sectors ) ;

void blk_queue_max_hw_sectors ( struct request_queue * q , unsigned int max_sectors ) ;

void blk_queue_max_discard_sectors ( struct request_queue * q , unsigned int max_discard_sectors ) ;

void blk_queue_max_phys_segments ( struct request_queue * q , unsigned short max_segments ) ;

void blk_queue_max_hw_segments ( struct request_queue * q , unsigned short max_segments ) ;

void blk_queue_max_segment_size ( struct request_queue * q , unsigned int max_size ) ;

void blk_queue_logical_block_size ( struct request_queue * q , unsigned short size ) ;

void blk_queue_physical_block_size ( struct request_queue * q , unsigned short size ) ;

void blk_queue_alignment_offset ( struct request_queue * q , unsigned int offset ) ;

void blk_limits_io_min ( struct queue_limits * limits , unsigned int min ) ;

void blk_queue_io_min ( struct request_queue * q , unsigned int min ) ;

void blk_limits_io_opt ( struct queue_limits * limits , unsigned int opt ) ;

void blk_queue_io_opt ( struct request_queue * q , unsigned int opt ) ;

void blk_queue_stack_limits ( struct request_queue * t , struct request_queue * b ) ;

int blk_stack_limits ( struct queue_limits * t , struct queue_limits * b , sector_t offset ) ;

int bdev_stack_limits ( struct queue_limits * t , struct block_device * bdev , sector_t start ) ;

void disk_stack_limits ( struct gendisk * disk , struct block_device * bdev , sector_t offset ) ;

void blk_queue_dma_pad ( struct request_queue * q , unsigned int mask ) ;

void blk_queue_update_dma_pad ( struct request_queue * q , unsigned int mask ) ;

int blk_queue_dma_drain ( struct request_queue * q , dma_drain_needed_fn * dma_drain_needed , void * buf , unsigned int size ) ;

void blk_queue_segment_boundary ( struct request_queue * q , unsigned long mask ) ;

void blk_queue_dma_alignment ( struct request_queue * q , int mask ) ;

void blk_queue_update_dma_alignment ( struct request_queue * q , int mask ) ;

int put_io_context ( struct io_context * ioc ) ;

void exit_io_context ( void ) ;

struct io_context * alloc_io_context ( gfp_t gfp_flags , int node ) ;

struct io_context * current_io_context ( gfp_t gfp_flags , int node ) ;

struct io_context * get_io_context ( gfp_t gfp_flags , int node ) ;

void copy_io_context ( struct io_context * * pdst , struct io_context * * psrc ) ;

int blk_rq_append_bio ( struct request_queue * q , struct request * rq , struct bio * bio ) ;

int blk_rq_map_user ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , void * ubuf , unsigned long len , gfp_t gfp_mask ) ;

int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , struct sg_iovec * iov , int iov_count , unsigned int len , gfp_t gfp_mask ) ;

int blk_rq_unmap_user ( struct bio * bio ) ;

int blk_rq_map_kern ( struct request_queue * q , struct request * rq , void * kbuf , unsigned int len , gfp_t gfp_mask ) ;

struct Scsi_Host ;

struct scsi_data_buffer { struct sg_table table ; unsigned length ; int resid ; } ;

struct scsi_pointer { char * ptr ; int this_residual ; struct scatterlist * buffer ; int buffers_residual ; dma_addr_t dma_handle ; volatile int Status ; volatile int Message ; volatile int have_data_in ; volatile int sent_command ; volatile int phase ; } ;

struct scsi_cmnd { struct scsi_device * device ; struct list_head list ; struct list_head eh_entry ; int eh_eflags ; unsigned long serial_number ; unsigned long jiffies_at_alloc ; int retries ; int allowed ; unsigned char prot_op ; unsigned char prot_type ; unsigned short cmd_len ; enum dma_data_direction sc_data_direction ; unsigned char * cmnd ; struct scsi_data_buffer sdb ; struct scsi_data_buffer * prot_sdb ; unsigned underflow ; unsigned transfersize ; struct request * request ; unsigned char * sense_buffer ; void ( * scsi_done ) ( struct scsi_cmnd * ) ; struct scsi_pointer SCp ; unsigned char * host_scribble ; int result ; unsigned char tag ; } ;
enum scsi_prot_operations { SCSI_PROT_NORMAL = 0 , SCSI_PROT_READ_INSERT , SCSI_PROT_WRITE_STRIP , SCSI_PROT_READ_STRIP , SCSI_PROT_WRITE_INSERT , SCSI_PROT_READ_PASS , SCSI_PROT_WRITE_PASS , } ;

enum scsi_prot_target_type { SCSI_PROT_DIF_TYPE0 = 0 , SCSI_PROT_DIF_TYPE1 , SCSI_PROT_DIF_TYPE2 , SCSI_PROT_DIF_TYPE3 , } ;

void blk_execute_rq_nowait ( struct request_queue * q , struct gendisk * bd_disk , struct request * rq , int at_head , rq_end_io_fn * done ) ;

int blk_execute_rq ( struct request_queue * q , struct gendisk * bd_disk , struct request * rq , int at_head ) ;

void blk_recalc_rq_segments ( struct request * rq ) ;

void blk_recount_segments ( struct request_queue * q , struct bio * bio ) ;

int blk_rq_map_sg ( struct request_queue * q , struct request * rq , struct scatterlist * sglist ) ;

int ll_back_merge_fn ( struct request_queue * q , struct request * req , struct bio * bio ) ;

int ll_front_merge_fn ( struct request_queue * q , struct request * req , struct bio * bio ) ;

void blk_rq_set_mixed_merge ( struct request * rq ) ;

int attempt_back_merge ( struct request_queue * q , struct request * rq ) ;

int attempt_front_merge ( struct request_queue * q , struct request * rq ) ;

void __blk_complete_request ( struct request * req ) ;

void blk_complete_request ( struct request * req ) ;

void blk_delete_timer ( struct request * req ) ;

void blk_rq_timed_out_timer ( unsigned long data ) ;

void blk_abort_request ( struct request * req ) ;

void blk_add_timer ( struct request * req ) ;

void blk_abort_queue ( struct request_queue * q ) ;

struct blk_iopoll ;

typedef int ( blk_iopoll_fn ) ( struct blk_iopoll * , int ) ;
struct blk_iopoll { struct list_head list ; unsigned long state ; unsigned long data ; int weight ; int max ; blk_iopoll_fn * poll ; } ;
enum { IOPOLL_F_SCHED = 0 , IOPOLL_F_DISABLE = 1 , } ;
void blk_iopoll_sched ( struct blk_iopoll * iop ) ;

void __blk_iopoll_complete ( struct blk_iopoll * iop ) ;

void blk_iopoll_complete ( struct blk_iopoll * iopoll ) ;

void blk_iopoll_disable ( struct blk_iopoll * iop ) ;

void blk_iopoll_enable ( struct blk_iopoll * iop ) ;

void blk_iopoll_init ( struct blk_iopoll * iop , int weight , blk_iopoll_fn * poll_fn ) ;


typedef union ide_reg_valid_s { unsigned all : 16 ; struct { unsigned data : 1 ; unsigned error_feature : 1 ; unsigned sector : 1 ; unsigned nsector : 1 ; unsigned lcyl : 1 ; unsigned hcyl : 1 ; unsigned select : 1 ; unsigned status_command : 1 ; unsigned data_hob : 1 ; unsigned error_feature_hob : 1 ; unsigned sector_hob : 1 ; unsigned nsector_hob : 1 ; unsigned lcyl_hob : 1 ; unsigned hcyl_hob : 1 ; unsigned select_hob : 1 ; unsigned control_hob : 1 ; } b ; } ide_reg_valid_t ;


typedef struct ide_task_request_s { __u8 io_ports [ 8 ] ; __u8 hob_ports [ 8 ] ; ide_reg_valid_t out_flags ; ide_reg_valid_t in_flags ; int data_phase ; int req_cmd ; unsigned long out_size ; unsigned long in_size ; } ide_task_request_t ;


typedef struct ide_ioctl_request_s { ide_task_request_t * task_request ; unsigned char * out_buffer ; unsigned char * in_buffer ; } ide_ioctl_request_t ;

struct hd_drive_cmd_hdr { __u8 command ; __u8 sector_number ; __u8 feature ; __u8 sector_count ; } ;

struct hd_geometry { unsigned char heads ; unsigned char sectors ; unsigned short cylinders ; unsigned long start ; } ;
enum { BUSSTATE_OFF = 0 , BUSSTATE_ON , BUSSTATE_TRISTATE } ;
int __blkdev_driver_ioctl ( struct block_device * bdev , fmode_t mode , unsigned cmd , unsigned long arg ) ;

int blkdev_ioctl ( struct block_device * bdev , fmode_t mode , unsigned cmd , unsigned long arg ) ;

struct hd_struct * disk_get_part ( struct gendisk * disk , int partno ) ;

void disk_part_iter_init ( struct disk_part_iter * piter , struct gendisk * disk , unsigned int flags ) ;

struct hd_struct * disk_part_iter_next ( struct disk_part_iter * piter ) ;

void disk_part_iter_exit ( struct disk_part_iter * piter ) ;

struct hd_struct * disk_map_sector_rcu ( struct gendisk * disk , sector_t sector ) ;


void blkdev_show ( struct seq_file * seqf , off_t offset ) ;

int register_blkdev ( unsigned int major , const char * name ) ;

void unregister_blkdev ( unsigned int major , const char * name ) ;

int blk_alloc_devt ( struct hd_struct * part , dev_t * devt ) ;

void blk_free_devt ( dev_t devt ) ;

void blk_register_region ( dev_t devt , unsigned long range , struct module * module , struct kobject * ( * probe ) ( dev_t , int * , void * ) , int ( * lock ) ( dev_t , void * ) , void * data ) ;

void blk_unregister_region ( dev_t devt , unsigned long range ) ;

void add_disk ( struct gendisk * disk ) ;

void unlink_gendisk ( struct gendisk * disk ) ;

struct gendisk * get_gendisk ( dev_t devt , int * partno ) ;

struct block_device * bdget_disk ( struct gendisk * disk , int partno ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) printk_all_partitions ( void ) ;

int disk_expand_part_tbl ( struct gendisk * disk , int partno ) ;

dev_t blk_lookup_devt ( const char * name , int partno ) ;

struct gendisk * alloc_disk ( int minors ) ;

struct gendisk * alloc_disk_node ( int minors , int node_id ) ;

struct kobject * get_disk ( struct gendisk * disk ) ;

void put_disk ( struct gendisk * disk ) ;

void set_device_ro ( struct block_device * bdev , int flag ) ;

void set_disk_ro ( struct gendisk * disk , int flag ) ;

int bdev_read_only ( struct block_device * bdev ) ;

int invalidate_partition ( struct gendisk * disk , int partno ) ;


int blk_verify_command ( unsigned char * cmd , fmode_t has_write_perm ) ;

int sg_scsi_ioctl ( struct request_queue * q , struct gendisk * disk , fmode_t mode , struct scsi_ioctl_command * sic ) ;

int scsi_cmd_ioctl ( struct request_queue * q , struct gendisk * bd_disk , fmode_t mode , unsigned int cmd , void * arg ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) blk_scsi_ioctl_init ( void ) ;

struct scsi_lun ;
struct scsi_sense_hdr ;

struct scsi_mode_data { __u32 length ; __u16 block_descriptor_length ; __u8 medium_type ; __u8 device_specific ; __u8 header_length ; __u8 longlba : 1 ; } ;

enum scsi_device_state { SDEV_CREATED = 1 , SDEV_RUNNING , SDEV_CANCEL , SDEV_DEL , SDEV_QUIESCE , SDEV_OFFLINE , SDEV_BLOCK , SDEV_CREATED_BLOCK , } ;

enum scsi_device_event { SDEV_EVT_MEDIA_CHANGE = 1 , SDEV_EVT_LAST = SDEV_EVT_MEDIA_CHANGE , SDEV_EVT_MAXBITS = SDEV_EVT_LAST + 1 } ;

struct scsi_event { enum scsi_device_event evt_type ; struct list_head node ; } ;

struct scsi_device { struct Scsi_Host * host ; struct request_queue * request_queue ; struct list_head siblings ; struct list_head same_target_siblings ; unsigned int device_busy ; spinlock_t list_lock ; struct list_head cmd_list ; struct list_head starved_entry ; struct scsi_cmnd * current_cmnd ; unsigned short queue_depth ; unsigned short last_queue_full_depth ; unsigned short last_queue_full_count ; unsigned long last_queue_full_time ; unsigned int id , lun , channel ; unsigned int manufacturer ; unsigned sector_size ; void * hostdata ; char type ; char scsi_level ; char inq_periph_qual ; unsigned char inquiry_len ; unsigned char * inquiry ; const char * vendor ; const char * model ; const char * rev ; unsigned char current_tag ; struct scsi_target * sdev_target ; unsigned int sdev_bflags ; unsigned writeable : 1 ; unsigned removable : 1 ; unsigned changed : 1 ; unsigned busy : 1 ; unsigned lockable : 1 ; unsigned locked : 1 ; unsigned borken : 1 ; unsigned disconnect : 1 ; unsigned soft_reset : 1 ; unsigned sdtr : 1 ; unsigned wdtr : 1 ; unsigned ppr : 1 ; unsigned tagged_supported : 1 ; unsigned simple_tags : 1 ; unsigned ordered_tags : 1 ; unsigned was_reset : 1 ; unsigned expecting_cc_ua : 1 ; unsigned use_10_for_rw : 1 ; unsigned use_10_for_ms : 1 ; unsigned skip_ms_page_8 : 1 ; unsigned skip_ms_page_3f : 1 ; unsigned use_192_bytes_for_3f : 1 ; unsigned no_start_on_add : 1 ; unsigned allow_restart : 1 ; unsigned manage_start_stop : 1 ; unsigned start_stop_pwr_cond : 1 ; unsigned no_uld_attach : 1 ; unsigned select_no_atn : 1 ; unsigned fix_capacity : 1 ; unsigned guess_capacity : 1 ; unsigned retry_hwerror : 1 ; unsigned last_sector_bug : 1 ; unsigned is_visible : 1 ; unsigned long supported_events [ ( ( ( SDEV_EVT_MAXBITS ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; struct list_head event_list ; struct work_struct event_work ; unsigned int device_blocked ; unsigned int max_device_blocked ; atomic_t iorequest_cnt ; atomic_t iodone_cnt ; atomic_t ioerr_cnt ; struct device sdev_gendev , sdev_dev ; struct execute_work ew ; struct scsi_dh_data * scsi_dh_data ; enum scsi_device_state sdev_state ; unsigned long sdev_data [ 0 ] ; } __attribute__ ( ( aligned ( sizeof ( unsigned long ) ) ) ) ;
struct scsi_dh_devlist { char * vendor ; char * model ; } ;

struct scsi_device_handler { struct list_head list ; struct module * module ; const char * name ; const struct scsi_dh_devlist * devlist ; int ( * check_sense ) ( struct scsi_device * , struct scsi_sense_hdr * ) ; int ( * attach ) ( struct scsi_device * ) ; void ( * detach ) ( struct scsi_device * ) ; int ( * activate ) ( struct scsi_device * ) ; int ( * prep_fn ) ( struct scsi_device * , struct request * ) ; int ( * set_params ) ( struct scsi_device * , const char * ) ; } ;

struct scsi_dh_data { struct scsi_device_handler * scsi_dh ; struct scsi_device * sdev ; struct kref kref ; char buf [ 0 ] ; } ;

enum scsi_target_state { STARGET_CREATED = 1 , STARGET_RUNNING , STARGET_DEL , } ;

struct scsi_target { struct scsi_device * starget_sdev_user ; struct list_head siblings ; struct list_head devices ; struct device dev ; unsigned int reap_ref ; unsigned int channel ; unsigned int id ; unsigned int create : 1 ; unsigned int single_lun : 1 ; unsigned int pdt_1f_for_no_lun ; unsigned int target_busy ; unsigned int can_queue ; unsigned int target_blocked ; unsigned int max_target_blocked ; char scsi_level ; struct execute_work ew ; enum scsi_target_state state ; void * hostdata ; unsigned long starget_data [ 0 ] ; } __attribute__ ( ( aligned ( sizeof ( unsigned long ) ) ) ) ;
struct scsi_driver { struct module * owner ; struct device_driver gendrv ; void ( * rescan ) ( struct device * ) ; int ( * done ) ( struct scsi_cmnd * ) ; } ;

struct bsg_device { struct request_queue * queue ; spinlock_t lock ; struct list_head busy_list ; struct list_head done_list ; struct hlist_node dev_list ; atomic_t ref_count ; int queued_cmds ; int done_cmds ; wait_queue_head_t wq_done ; wait_queue_head_t wq_free ; char name [ 20 ] ; int max_queue ; unsigned long flags ; } ;

enum { BSG_F_BLOCK = 1 , } ;
struct bsg_command { struct bsg_device * bd ; struct list_head list ; struct request * rq ; struct bio * bio ; struct bio * bidi_bio ; int err ; struct sg_io_v4 hdr ; char sense [ 96 ] ; } ;

void bsg_unregister_queue ( struct request_queue * q ) ;

int bsg_register_queue ( struct request_queue * q , struct device * parent , const char * name , void ( * release ) ( struct device * ) ) ;

struct noop_data { struct list_head queue ; } ;

enum as_io_states { AS_TASK_RUNNING = 0 , AS_TASK_IOSTARTED , AS_TASK_IORUNNING , } ;

enum anticipation_status { ANTIC_OFF = 0 , ANTIC_WAIT_REQ , ANTIC_WAIT_NEXT , ANTIC_FINISHED , } ;

struct as_data { struct request_queue * q ; struct rb_root sort_list [ 2 ] ; struct list_head fifo_list [ 2 ] ; struct request * next_rq [ 2 ] ; sector_t last_sector [ 2 ] ; unsigned long exit_prob ; unsigned long exit_no_coop ; unsigned long new_ttime_total ; unsigned long new_ttime_mean ; u64 new_seek_total ; sector_t new_seek_mean ; unsigned long current_batch_expires ; unsigned long last_check_fifo [ 2 ] ; int changed_batch ; int new_batch ; int batch_data_dir ; int write_batch_count ; int current_write_count ; int write_batch_idled ; enum anticipation_status antic_status ; unsigned long antic_start ; struct timer_list antic_timer ; struct work_struct antic_work ; struct io_context * io_context ; int ioc_finished ; int nr_dispatched ; unsigned long fifo_expire [ 2 ] ; unsigned long batch_expire [ 2 ] ; unsigned long antic_expire ; } ;

enum arq_state { AS_RQ_NEW = 0 , AS_RQ_QUEUED , AS_RQ_DISPATCHED , AS_RQ_PRESCHED , AS_RQ_REMOVED , AS_RQ_MERGED , AS_RQ_POSTSCHED , } ;

struct deadline_data { struct rb_root sort_list [ 2 ] ; struct list_head fifo_list [ 2 ] ; struct request * next_rq [ 2 ] ; unsigned int batching ; sector_t last_sector ; unsigned int starved ; int fifo_expire [ 2 ] ; int fifo_batch ; int writes_starved ; int front_merges ; } ;

struct cfq_rb_root { struct rb_root rb ; struct rb_node * left ; } ;

struct cfq_queue { atomic_t ref ; unsigned int flags ; struct cfq_data * cfqd ; struct rb_node rb_node ; unsigned long rb_key ; struct rb_node p_node ; struct rb_root * p_root ; struct rb_root sort_list ; struct request * next_rq ; int queued [ 2 ] ; int allocated [ 2 ] ; struct list_head fifo ; unsigned long slice_end ; long slice_resid ; unsigned int slice_dispatch ; int meta_pending ; int dispatched ; unsigned short ioprio , org_ioprio ; unsigned short ioprio_class , org_ioprio_class ; pid_t pid ; } ;
struct cfq_data { struct request_queue * queue ; struct cfq_rb_root service_tree ; struct rb_root prio_trees [ ( 8 ) ] ; unsigned int busy_queues ; int rq_in_driver [ 2 ] ; int sync_flight ; int rq_queued ; int hw_tag ; int hw_tag_samples ; int rq_in_driver_peak ; struct timer_list idle_slice_timer ; struct work_struct unplug_work ; struct cfq_queue * active_queue ; struct cfq_io_context * active_cic ; struct cfq_queue * async_cfqq [ 2 ] [ ( 8 ) ] ; struct cfq_queue * async_idle_cfqq ; sector_t last_position ; unsigned int cfq_quantum ; unsigned int cfq_fifo_expire [ 2 ] ; unsigned int cfq_back_penalty ; unsigned int cfq_back_max ; unsigned int cfq_slice [ 2 ] ; unsigned int cfq_slice_async_rq ; unsigned int cfq_slice_idle ; unsigned int cfq_latency ; struct list_head cic_list ; struct cfq_queue oom_cfqq ; unsigned long last_end_sync_rq ; } ;

enum cfqq_state_flags { CFQ_CFQQ_FLAG_on_rr = 0 , CFQ_CFQQ_FLAG_wait_request , CFQ_CFQQ_FLAG_must_dispatch , CFQ_CFQQ_FLAG_must_alloc_slice , CFQ_CFQQ_FLAG_fifo_expire , CFQ_CFQQ_FLAG_idle_window , CFQ_CFQQ_FLAG_prio_changed , CFQ_CFQQ_FLAG_slice_new , CFQ_CFQQ_FLAG_sync , CFQ_CFQQ_FLAG_coop , CFQ_CFQQ_FLAG_coop_preempt , } ;

struct compat_hd_geometry { unsigned char heads ; unsigned char sectors ; unsigned short cylinders ; u32 start ; } ;

struct compat_cdrom_read_audio { union cdrom_addr addr ; u8 addr_format ; compat_int_t nframes ; compat_caddr_t buf ; } ;

struct compat_cdrom_generic_command { unsigned char cmd [ 12 ] ; compat_caddr_t buffer ; compat_uint_t buflen ; compat_int_t stat ; compat_caddr_t sense ; unsigned char data_direction ; compat_int_t quiet ; compat_int_t timeout ; compat_caddr_t reserved [ 1 ] ; } ;

struct compat_blkpg_ioctl_arg { compat_int_t op ; compat_int_t flags ; compat_int_t datalen ; compat_caddr_t data ; } ;

struct compat_floppy_struct { compat_uint_t size ; compat_uint_t sect ; compat_uint_t head ; compat_uint_t track ; compat_uint_t stretch ; unsigned char gap ; unsigned char rate ; unsigned char spec1 ; unsigned char fmt_gap ; const compat_caddr_t name ; } ;

struct compat_floppy_drive_params { char cmos ; compat_ulong_t max_dtr ; compat_ulong_t hlt ; compat_ulong_t hut ; compat_ulong_t srt ; compat_ulong_t spinup ; compat_ulong_t spindown ; unsigned char spindown_offset ; unsigned char select_delay ; unsigned char rps ; unsigned char tracks ; compat_ulong_t timeout ; unsigned char interleave_sect ; struct floppy_max_errors max_errors ; char flags ; char read_track ; short autodetect [ 8 ] ; compat_int_t checkfreq ; compat_int_t native_format ; } ;

struct compat_floppy_drive_struct { signed char flags ; compat_ulong_t spinup_date ; compat_ulong_t select_date ; compat_ulong_t first_read_date ; short probed_format ; short track ; short maxblock ; short maxtrack ; compat_int_t generation ; compat_int_t keep_data ; compat_int_t fd_ref ; compat_int_t fd_device ; compat_int_t last_checked ; compat_caddr_t dmabuf ; compat_int_t bufblocks ; } ;

struct compat_floppy_fdc_state { compat_int_t spec1 ; compat_int_t spec2 ; compat_int_t dtr ; unsigned char version ; unsigned char dor ; compat_ulong_t address ; unsigned int rawcmd : 2 ; unsigned int reset : 1 ; unsigned int need_configure : 1 ; unsigned int perp_mode : 2 ; unsigned int has_fifo : 1 ; unsigned int driver_version ; unsigned char track [ 4 ] ; } ;

struct compat_floppy_write_errors { unsigned int write_errors ; compat_ulong_t first_error_sector ; compat_int_t first_error_generation ; compat_ulong_t last_error_sector ; compat_int_t last_error_generation ; compat_uint_t badness ; } ;

struct compat_blk_user_trace_setup { char name [ 32 ] ; u16 act_mask ; u32 buf_size ; u32 buf_nr ; compat_u64 start_lba ; compat_u64 end_lba ; u32 pid ; } ;

long compat_blkdev_ioctl ( struct file * file , unsigned cmd , unsigned long arg ) ;

int blk_rq_count_integrity_sg ( struct request * rq ) ;

int blk_rq_map_integrity_sg ( struct request * rq , struct scatterlist * sglist ) ;

int blk_integrity_compare ( struct gendisk * gd1 , struct gendisk * gd2 ) ;

struct integrity_sysfs_entry { struct attribute attr ; ssize_t ( * show ) ( struct blk_integrity * , char * ) ; ssize_t ( * store ) ( struct blk_integrity * , const char * , size_t ) ; } ;

int blk_integrity_register ( struct gendisk * disk , struct blk_integrity * template ) ;

void blk_integrity_unregister ( struct gendisk * disk ) ;

void acpi_table_print_madt_entry ( struct acpi_subtable_header * header ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_table_parse_entries ( char * id , unsigned long table_size , int entry_id , acpi_table_entry_handler handler , unsigned int max_entries ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_table_parse_madt ( enum acpi_madt_type id , acpi_table_entry_handler handler , unsigned int max_entries ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_table_parse ( char * id , acpi_table_handler handler ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_table_init ( void ) ;

enum acpi_blacklist_predicates { all_versions , less_than_or_equal , equal , greater_than_or_equal , } ;

struct acpi_blacklist_item { char oem_id [ 7 ] ; char oem_table_id [ 9 ] ; u32 oem_revision ; char * table ; enum acpi_blacklist_predicates oem_revision_predicate ; char * reason ; u32 is_critical_error ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_blacklisted ( void ) ;

struct acpi_os_dpc { acpi_osd_exec_callback function ; void * context ; struct work_struct work ; int wait ; } ;

struct acpi_res_list { resource_size_t start ; resource_size_t end ; acpi_adr_space_type resource_type ; char name [ 5 ] ; struct list_head resource_list ; int count ; } ;


acpi_status __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_os_initialize ( void ) ;

acpi_status acpi_os_initialize1 ( void ) ;

acpi_status acpi_os_terminate ( void ) ;

void acpi_os_printf ( const char * fmt , ... ) ;

void acpi_os_vprintf ( const char * fmt , va_list args ) ;

acpi_physical_address __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_os_get_root_pointer ( void ) ;

void * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) acpi_os_map_memory ( acpi_physical_address phys , acpi_size size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) acpi_os_unmap_memory ( void * virt , acpi_size size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_acpi_os_unmap_memory ( void * virt , acpi_size size ) ;

acpi_status acpi_os_predefined_override ( const struct acpi_predefined_names * init_val , acpi_string * new_val ) ;

acpi_status acpi_os_table_override ( struct acpi_table_header * existing_table , struct acpi_table_header * * new_table ) ;

acpi_status acpi_os_install_interrupt_handler ( u32 gsi , acpi_osd_handler handler , void * context ) ;

acpi_status acpi_os_remove_interrupt_handler ( u32 irq , acpi_osd_handler handler ) ;

void acpi_os_sleep ( acpi_integer ms ) ;

void acpi_os_stall ( u32 us ) ;

u64 acpi_os_get_timer ( void ) ;

acpi_status acpi_os_read_port ( acpi_io_address port , u32 * value , u32 width ) ;

acpi_status acpi_os_write_port ( acpi_io_address port , u32 value , u32 width ) ;

acpi_status acpi_os_read_memory ( acpi_physical_address phys_addr , u32 * value , u32 width ) ;

acpi_status acpi_os_write_memory ( acpi_physical_address phys_addr , u32 value , u32 width ) ;

acpi_status acpi_os_read_pci_configuration ( struct acpi_pci_id * pci_id , u32 reg , u32 * value , u32 width ) ;

acpi_status acpi_os_write_pci_configuration ( struct acpi_pci_id * pci_id , u32 reg , acpi_integer value , u32 width ) ;

void acpi_os_derive_pci_id ( acpi_handle rhandle , acpi_handle chandle , struct acpi_pci_id * * id ) ;

acpi_status acpi_os_execute ( acpi_execute_type type , acpi_osd_exec_callback function , void * context ) ;

acpi_status acpi_os_hotplug_execute ( acpi_osd_exec_callback function , void * context ) ;

void acpi_os_wait_events_complete ( void * context ) ;

acpi_status acpi_os_create_lock ( spinlock_t * * handle ) ;

void acpi_os_delete_lock ( spinlock_t * handle ) ;

acpi_status acpi_os_create_semaphore ( u32 max_units , u32 initial_units , acpi_handle * handle ) ;

acpi_status acpi_os_delete_semaphore ( acpi_handle handle ) ;

acpi_status acpi_os_wait_semaphore ( acpi_handle handle , u32 units , u16 timeout ) ;

acpi_status acpi_os_signal_semaphore ( acpi_handle handle , u32 units ) ;

acpi_status acpi_os_signal ( u32 function , void * info ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_dmi_osi_linux ( int enable , const struct dmi_system_id * d ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_osi_setup ( char * str ) ;

int acpi_check_resource_conflict ( struct resource * res ) ;

int acpi_check_region ( resource_size_t start , resource_size_t n , const char * name ) ;

int acpi_check_mem_region ( resource_size_t start , resource_size_t n , const char * name ) ;

unsigned long acpi_os_acquire_lock ( spinlock_t * lockp ) ;

void acpi_os_release_lock ( spinlock_t * lockp , unsigned long flags ) ;

acpi_status acpi_os_create_cache ( char * name , u16 size , u16 depth , struct kmem_cache * * cache ) ;

acpi_status acpi_os_purge_cache ( struct kmem_cache * cache ) ;

acpi_status acpi_os_delete_cache ( struct kmem_cache * cache ) ;

acpi_status acpi_os_release_object ( struct kmem_cache * cache , void * object ) ;

acpi_status acpi_os_validate_interface ( char * interface ) ;

acpi_status acpi_os_invalidate_address ( u8 space_id , acpi_physical_address address , acpi_size length ) ;

acpi_status acpi_os_validate_address ( u8 space_id , acpi_physical_address address , acpi_size length , char * name ) ;

acpi_status acpi_extract_package ( union acpi_object * package , struct acpi_buffer * format , struct acpi_buffer * buffer ) ;

acpi_status acpi_evaluate_integer ( acpi_handle handle , acpi_string pathname , struct acpi_object_list * arguments , unsigned long long * data ) ;

acpi_status acpi_evaluate_reference ( acpi_handle handle , acpi_string pathname , struct acpi_object_list * arguments , struct acpi_handle_list * list ) ;

void acpi_reboot ( void ) ;

void acpi_enable_wakeup_device_prep ( u8 sleep_state ) ;

void acpi_enable_wakeup_device ( u8 sleep_state ) ;

void acpi_disable_wakeup_device ( u8 sleep_state ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_wakeup_device_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_old_suspend_ordering ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_s4_no_nvs ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_no_s4_hw_signature ( void ) ;

int acpi_suspend ( u32 acpi_state ) ;

int acpi_pm_device_sleep_state ( struct device * dev , int * d_min_p ) ;

int acpi_pm_device_sleep_wake ( struct device * dev , bool enable ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_gts_bfs_check ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_sleep_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_sleep_proc_init ( void ) ;

int acpi_bus_get_device ( acpi_handle handle , struct acpi_device * * device ) ;

acpi_status acpi_bus_get_status_handle ( acpi_handle handle , unsigned long long * sta ) ;

int acpi_bus_get_status ( struct acpi_device * device ) ;

void acpi_bus_private_data_handler ( acpi_handle handle , void * context ) ;

int acpi_bus_get_private_data ( acpi_handle handle , void * * data ) ;

int acpi_bus_get_power ( acpi_handle handle , int * state ) ;

int acpi_bus_set_power ( acpi_handle handle , int state ) ;

bool acpi_bus_power_manageable ( acpi_handle handle ) ;

bool acpi_bus_can_wakeup ( acpi_handle handle ) ;

acpi_status acpi_run_osc ( acpi_handle handle , struct acpi_osc_context * context ) ;

int acpi_bus_generate_proc_event4 ( const char * device_class , const char * bus_id , u8 type , int data ) ;

int acpi_bus_generate_proc_event ( struct acpi_device * device , u8 type , int data ) ;

int acpi_bus_receive_event ( struct acpi_bus_event * event ) ;

int register_acpi_bus_notifier ( struct notifier_block * nb ) ;

void unregister_acpi_bus_notifier ( struct notifier_block * nb ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_early_init ( void ) ;

int register_acpi_bus_type ( struct acpi_bus_type * type ) ;

int unregister_acpi_bus_type ( struct acpi_bus_type * type ) ;

struct acpi_find_child { acpi_handle handle ; acpi_integer address ; } ;

acpi_handle acpi_get_child ( acpi_handle parent , acpi_integer address ) ;

struct device * acpi_get_physical_device ( acpi_handle handle ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) init_acpi_device_notify ( void ) ;

struct acpi_device_bus_id { char bus_id [ 15 ] ; unsigned int instance_no ; struct list_head node ; } ;

int acpi_match_device_ids ( struct acpi_device * device , const struct acpi_device_id * ids ) ;

int acpi_bus_register_driver ( struct acpi_driver * driver ) ;

void acpi_bus_unregister_driver ( struct acpi_driver * driver ) ;

acpi_status acpi_bus_get_ejd ( acpi_handle handle , acpi_handle * ejd ) ;

void acpi_bus_data_handler ( acpi_handle handle , void * context ) ;

char * acpi_device_hid ( struct acpi_device * device ) ;

int acpi_bus_add ( struct acpi_device * * child , struct acpi_device * parent , acpi_handle handle , int type ) ;

int acpi_bus_start ( struct acpi_device * device ) ;

int acpi_bus_trim ( struct acpi_device * start , int rmdevice ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_scan_init ( void ) ;

enum ec_command { ACPI_EC_COMMAND_READ = 0x80 , ACPI_EC_COMMAND_WRITE = 0x81 , ACPI_EC_BURST_ENABLE = 0x82 , ACPI_EC_BURST_DISABLE = 0x83 , ACPI_EC_COMMAND_QUERY = 0x84 , } ;

enum { EC_FLAGS_QUERY_PENDING , EC_FLAGS_GPE_STORM , EC_FLAGS_HANDLERS_INSTALLED } ;
typedef int ( * acpi_ec_query_func ) ( void * data ) ;
struct acpi_ec_query_handler { struct list_head node ; acpi_ec_query_func func ; acpi_handle handle ; void * data ; u8 query_bit ; } ;

struct transaction { const u8 * wdata ; u8 * rdata ; unsigned short irq_count ; u8 command ; u8 wi ; u8 ri ; u8 wlen ; u8 rlen ; bool done ; } ;


int ec_burst_enable ( void ) ;

int ec_burst_disable ( void ) ;

int ec_read ( u8 addr , u8 * val ) ;

int ec_write ( u8 addr , u8 val ) ;

int ec_transaction ( u8 command , const u8 * wdata , unsigned wdata_len , u8 * rdata , unsigned rdata_len , int force_poll ) ;

int acpi_ec_add_query_handler ( struct acpi_ec * ec , u8 query_bit , acpi_handle handle , acpi_ec_query_func func , void * data ) ;

void acpi_ec_remove_query_handler ( struct acpi_ec * ec , u8 query_bit ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_boot_ec_enable ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_ec_ecdt_probe ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_ec_init ( void ) ;

struct dock_station { acpi_handle handle ; unsigned long last_dock_time ; u32 flags ; spinlock_t dd_lock ; struct mutex hp_lock ; struct list_head dependent_devices ; struct list_head hotplug_devices ; struct list_head sibling ; struct platform_device * dock_device ; } ;

struct dock_dependent_device { struct list_head list ; struct list_head hotplug_list ; acpi_handle handle ; struct acpi_dock_ops * ops ; void * context ; } ;

int is_dock_device ( acpi_handle handle ) ;

int register_dock_notifier ( struct notifier_block * nb ) ;

void unregister_dock_notifier ( struct notifier_block * nb ) ;

int register_hotplug_dock_device ( acpi_handle handle , struct acpi_dock_ops * ops , void * context ) ;

void unregister_hotplug_dock_device ( acpi_handle handle ) ;

struct dock_data { acpi_handle handle ; unsigned long event ; struct dock_station * ds ; } ;

int acpi_pci_register_driver ( struct acpi_pci_driver * driver ) ;

void acpi_pci_unregister_driver ( struct acpi_pci_driver * driver ) ;

acpi_handle acpi_get_pci_rootbridge_handle ( unsigned int seg , unsigned int bus ) ;

int acpi_is_root_bridge ( acpi_handle handle ) ;

struct acpi_pci_root * acpi_pci_find_root ( acpi_handle handle ) ;

struct acpi_handle_node { struct list_head node ; acpi_handle handle ; } ;

struct pci_dev * acpi_get_pci_dev ( acpi_handle handle ) ;

acpi_status acpi_pci_osc_control_set ( acpi_handle handle , u32 flags ) ;

struct acpi_pci_link_irq { u8 active ; u8 triggering ; u8 polarity ; u8 resource_type ; u8 possible_count ; u8 possible [ 16 ] ; u8 initialized : 1 ; u8 reserved : 7 ; } ;

struct acpi_pci_link { struct list_head list ; struct acpi_device * device ; struct acpi_pci_link_irq irq ; int refcnt ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_irq_penalty_init ( void ) ;

int acpi_pci_link_allocate_irq ( acpi_handle handle , int index , int * triggering , int * polarity , char * * name ) ;

int acpi_pci_link_free_irq ( acpi_handle handle ) ;

void acpi_penalize_isa_irq ( int irq , int active ) ;

struct acpi_prt_entry { struct list_head list ; struct acpi_pci_id id ; u8 pin ; acpi_handle link ; u32 index ; } ;

struct prt_quirk { const struct dmi_system_id * system ; unsigned int segment ; unsigned int bus ; unsigned int device ; unsigned char pin ; const char * source ; const char * actual_source ; } ;

int acpi_pci_irq_add_prt ( acpi_handle handle , struct pci_bus * bus ) ;

void acpi_pci_irq_del_prt ( struct pci_bus * bus ) ;

int acpi_pci_irq_enable ( struct pci_dev * dev ) ;

void __attribute__ ( ( weak ) ) acpi_unregister_gsi ( u32 i ) ;

void acpi_pci_irq_disable ( struct pci_dev * dev ) ;

int acpi_pci_bind_root ( struct acpi_device * device ) ;

struct acpi_power_reference { struct list_head node ; struct acpi_device * device ; } ;

struct acpi_power_resource { struct acpi_device * device ; acpi_bus_id name ; u32 system_level ; u32 order ; struct mutex resource_lock ; struct list_head reference ; } ;

int acpi_device_sleep_wake ( struct acpi_device * dev , int enable , int sleep_state , int dev_state ) ;

int acpi_enable_wakeup_device_power ( struct acpi_device * dev , int sleep_state ) ;

int acpi_disable_wakeup_device_power ( struct acpi_device * dev ) ;

int acpi_power_get_inferred_state ( struct acpi_device * device ) ;

int acpi_power_transition ( struct acpi_device * device , int state ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_power_init ( void ) ;

struct acpi_table_attr { struct bin_attribute attr ; char name [ 8 ] ; int instance ; struct list_head node ; } ;

struct event_counter { u32 count ; u32 flags ; } ;

void acpi_os_gpe_count ( u32 gpe_number ) ;

void acpi_os_fixed_event_count ( u32 event_number ) ;

void acpi_irq_stats_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_system_init ( void ) ;

int acpi_notifier_call_chain ( struct acpi_device * dev , u32 type , u32 data ) ;

int register_acpi_notifier ( struct notifier_block * nb ) ;

int unregister_acpi_notifier ( struct notifier_block * nb ) ;

struct acpi_genl_event { acpi_device_class device_class ; char bus_id [ 15 ] ; u32 type ; u32 data ; } ;

enum { ACPI_GENL_ATTR_UNSPEC , ACPI_GENL_ATTR_EVENT , __ACPI_GENL_ATTR_MAX , } ;
enum { ACPI_GENL_CMD_UNSPEC , ACPI_GENL_CMD_EVENT , __ACPI_GENL_CMD_MAX , } ;
int acpi_bus_generate_netlink_event ( const char * device_class , const char * bus_id , u8 type , int data ) ;

int pxm_to_node ( int pxm ) ;

int node_to_pxm ( int node ) ;

void __acpi_map_pxm_to_node ( int pxm , int node ) ;

int acpi_map_pxm_to_node ( int pxm ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) __attribute__ ( ( weak ) ) acpi_numa_x2apic_affinity_init ( struct acpi_srat_x2apic_cpu_affinity * pa ) ;
int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_numa_init ( void ) ;

int acpi_get_pxm ( acpi_handle h ) ;

int acpi_get_node ( acpi_handle * handle ) ;

struct proc_dir_entry * acpi_lock_ac_dir ( void ) ;

void acpi_unlock_ac_dir ( struct proc_dir_entry * acpi_ac_dir_param ) ;

struct proc_dir_entry * acpi_lock_battery_dir ( void ) ;

void acpi_unlock_battery_dir ( struct proc_dir_entry * acpi_battery_dir_param ) ;

long acpi_is_video_device ( struct acpi_device * device ) ;

long acpi_video_get_capabilities ( acpi_handle graphics_handle ) ;

int acpi_video_backlight_support ( void ) ;

int acpi_video_display_switch_support ( void ) ;

struct throttling_tstate { unsigned int cpu ; int target_state ; } ;

void acpi_processor_throttling_init ( void ) ;

int acpi_processor_tstate_has_changed ( struct acpi_processor * pr ) ;

int acpi_processor_set_throttling ( struct acpi_processor * pr , int state , bool force ) ;

int acpi_processor_get_throttling_info ( struct acpi_processor * pr ) ;

int acpi_processor_suspend ( struct acpi_device * device , pm_message_t state ) ;

int acpi_processor_resume ( struct acpi_device * device ) ;

int acpi_processor_cst_has_changed ( struct acpi_processor * pr ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) acpi_processor_power_init ( struct acpi_processor * pr , struct acpi_device * device ) ;

int acpi_processor_power_exit ( struct acpi_processor * pr , struct acpi_device * device ) ;

void acpi_thermal_cpufreq_init ( void ) ;

void acpi_thermal_cpufreq_exit ( void ) ;

int acpi_processor_set_thermal_limit ( acpi_handle handle , int type ) ;

int acpi_processor_get_limit_info ( struct acpi_processor * pr ) ;

int acpi_processor_ppc_has_changed ( struct acpi_processor * pr ) ;

void acpi_processor_ppc_init ( void ) ;

void acpi_processor_ppc_exit ( void ) ;

int acpi_processor_notify_smm ( struct module * calling_module ) ;

int acpi_processor_preregister_performance ( struct acpi_processor_performance * performance ) ;

int acpi_processor_register_performance ( struct acpi_processor_performance * performance , unsigned int cpu ) ;

void acpi_processor_unregister_performance ( struct acpi_processor_performance * performance , unsigned int cpu ) ;

typedef u32 acpi_mutex_handle ;

struct acpi_walk_state ;

struct acpi_obj_mutex ;

union acpi_parse_object ;

struct acpi_rw_lock { void * writer_mutex ; void * reader_mutex ; u32 num_readers ; } ;

struct acpi_mutex_info { void * mutex ; u32 use_count ; struct task_struct * thread_id ; } ;

typedef enum { ACPI_IMODE_LOAD_PASS1 = 0x01 , ACPI_IMODE_LOAD_PASS2 = 0x02 , ACPI_IMODE_EXECUTE = 0x03 } acpi_interpreter_mode ;

struct acpi_namespace_node { union acpi_operand_object * object ; u8 descriptor_type ; u8 type ; u8 flags ; acpi_owner_id owner_id ; union acpi_name_union name ; struct acpi_namespace_node * child ; struct acpi_namespace_node * peer ; } ;

struct acpi_internal_rsdt { struct acpi_table_desc * tables ; u32 count ; u32 size ; u8 flags ; } ;

struct acpi_find_context { char * search_for ; acpi_handle * list ; u32 * count ; } ;

struct acpi_ns_search_data { struct acpi_namespace_node * node ; } ;

struct acpi_namestring_info { const char * external_name ; const char * next_external_char ; char * internal_name ; u32 length ; u32 num_segments ; u32 num_carats ; u8 fully_qualified ; } ;

struct acpi_create_field_info { struct acpi_namespace_node * region_node ; struct acpi_namespace_node * field_node ; struct acpi_namespace_node * register_node ; struct acpi_namespace_node * data_register_node ; u32 bank_value ; u32 field_bit_position ; u32 field_bit_length ; u8 field_flags ; u8 attribute ; u8 field_type ; } ;

typedef acpi_status ( * ACPI_INTERNAL_METHOD ) ( struct acpi_walk_state * walk_state ) ;
struct acpi_name_info { char name [ 4 ] ; u8 param_count ; u8 expected_btypes ; } ;

struct acpi_package_info { u8 type ; u8 object_type1 ; u8 count1 ; u8 object_type2 ; u8 count2 ; u8 reserved ; } ;

struct acpi_package_info2 { u8 type ; u8 count ; u8 object_type [ 4 ] ; } ;

struct acpi_package_info3 { u8 type ; u8 count ; u8 object_type [ 2 ] ; u8 tail_object_type ; u8 reserved ; } ;

union acpi_predefined_info { struct acpi_name_info info ; struct acpi_package_info ret_info ; struct acpi_package_info2 ret_info2 ; struct acpi_package_info3 ret_info3 ; } ;

struct acpi_predefined_data { char * pathname ; const union acpi_predefined_info * predefined ; u32 flags ; u8 node_flags ; } ;

struct acpi_handler_info { acpi_event_handler address ; void * context ; struct acpi_namespace_node * method_node ; } ;

union acpi_gpe_dispatch_info { struct acpi_namespace_node * method_node ; struct acpi_handler_info * handler ; } ;

struct acpi_gpe_event_info { union acpi_gpe_dispatch_info dispatch ; struct acpi_gpe_register_info * register_info ; u8 flags ; u8 gpe_number ; } ;

struct acpi_gpe_register_info { struct acpi_generic_address status_address ; struct acpi_generic_address enable_address ; u8 enable_for_wake ; u8 enable_for_run ; u8 base_gpe_number ; } ;

struct acpi_gpe_block_info { struct acpi_namespace_node * node ; struct acpi_gpe_block_info * previous ; struct acpi_gpe_block_info * next ; struct acpi_gpe_xrupt_info * xrupt_block ; struct acpi_gpe_register_info * register_info ; struct acpi_gpe_event_info * event_info ; struct acpi_generic_address block_address ; u32 register_count ; u8 block_base_number ; } ;

struct acpi_gpe_xrupt_info { struct acpi_gpe_xrupt_info * previous ; struct acpi_gpe_xrupt_info * next ; struct acpi_gpe_block_info * gpe_block_list_head ; u32 interrupt_number ; } ;

struct acpi_gpe_walk_info { struct acpi_namespace_node * gpe_device ; struct acpi_gpe_block_info * gpe_block ; } ;

struct acpi_gpe_device_info { u32 index ; u32 next_block_base_index ; acpi_status status ; struct acpi_namespace_node * gpe_device ; } ;

typedef acpi_status ( * acpi_gpe_callback ) ( struct acpi_gpe_xrupt_info * gpe_xrupt_info , struct acpi_gpe_block_info * gpe_block , void * context ) ;
struct acpi_fixed_event_handler { acpi_event_handler handler ; void * context ; } ;

struct acpi_fixed_event_info { u8 status_register_id ; u8 enable_register_id ; u16 status_bit_mask ; u16 enable_bit_mask ; } ;

struct acpi_field_info { u8 skip_field ; u8 field_flag ; u32 pkg_length ; } ;

struct acpi_common_state { void * next ; u8 descriptor_type ; u8 flags ; u16 value ; u16 state ; } ;

struct acpi_update_state { void * next ; u8 descriptor_type ; u8 flags ; u16 value ; u16 state ; union acpi_operand_object * object ; } ;

struct acpi_pkg_state { void * next ; u8 descriptor_type ; u8 flags ; u16 value ; u16 state ; u16 index ; union acpi_operand_object * source_object ; union acpi_operand_object * dest_object ; struct acpi_walk_state * walk_state ; void * this_target_obj ; u32 num_packages ; } ;

struct acpi_control_state { void * next ; u8 descriptor_type ; u8 flags ; u16 value ; u16 state ; u16 opcode ; union acpi_parse_object * predicate_op ; u8 * aml_predicate_start ; u8 * package_end ; u32 loop_count ; } ;

struct acpi_scope_state { void * next ; u8 descriptor_type ; u8 flags ; u16 value ; u16 state ; struct acpi_namespace_node * node ; } ;

struct acpi_pscope_state { void * next ; u8 descriptor_type ; u8 flags ; u16 value ; u16 state ; u32 arg_count ; union acpi_parse_object * op ; u8 * arg_end ; u8 * pkg_end ; u32 arg_list ; } ;

struct acpi_thread_state { void * next ; u8 descriptor_type ; u8 flags ; u16 value ; u16 state ; u8 current_sync_level ; struct acpi_walk_state * walk_state_list ; union acpi_operand_object * acquired_mutex_list ; struct task_struct * thread_id ; } ;

struct acpi_result_values { void * next ; u8 descriptor_type ; u8 flags ; u16 value ; u16 state ; union acpi_operand_object * obj_desc [ 8 ] ; } ;

typedef acpi_status ( * acpi_parse_downwards ) ( struct acpi_walk_state * walk_state , union acpi_parse_object * * out_op ) ;
typedef acpi_status ( * acpi_parse_upwards ) ( struct acpi_walk_state * walk_state ) ;
struct acpi_notify_info { void * next ; u8 descriptor_type ; u8 flags ; u16 value ; u16 state ; struct acpi_namespace_node * node ; union acpi_operand_object * handler_obj ; } ;

union acpi_generic_state { struct acpi_common_state common ; struct acpi_control_state control ; struct acpi_update_state update ; struct acpi_scope_state scope ; struct acpi_pscope_state parse_scope ; struct acpi_pkg_state pkg ; struct acpi_thread_state thread ; struct acpi_result_values results ; struct acpi_notify_info notify ; } ;

typedef acpi_status ( * ACPI_EXECUTE_OP ) ( struct acpi_walk_state * walk_state ) ;
struct acpi_opcode_info { u32 parse_args ; u32 runtime_args ; u16 flags ; u8 object_type ; u8 class ; u8 type ; } ;

union acpi_parse_value { acpi_integer integer ; struct uint64_struct integer64 ; u32 size ; char * string ; u8 * buffer ; char * name ; union acpi_parse_object * arg ; } ;

struct acpi_parse_obj_common { union acpi_parse_object * parent ; u8 descriptor_type ; u8 flags ; u16 aml_opcode ; u32 aml_offset ; union acpi_parse_object * next ; struct acpi_namespace_node * node ; union acpi_parse_value value ; u8 arg_list_length ; } ;

struct acpi_parse_obj_named { union acpi_parse_object * parent ; u8 descriptor_type ; u8 flags ; u16 aml_opcode ; u32 aml_offset ; union acpi_parse_object * next ; struct acpi_namespace_node * node ; union acpi_parse_value value ; u8 arg_list_length ; u8 * path ; u8 * data ; u32 length ; u32 name ; } ;

struct acpi_parse_obj_asl { union acpi_parse_object * parent ; u8 descriptor_type ; u8 flags ; u16 aml_opcode ; u32 aml_offset ; union acpi_parse_object * next ; struct acpi_namespace_node * node ; union acpi_parse_value value ; u8 arg_list_length ; union acpi_parse_object * child ; union acpi_parse_object * parent_method ; char * filename ; char * external_name ; char * namepath ; char name_seg [ 4 ] ; u32 extra_value ; u32 column ; u32 line_number ; u32 logical_line_number ; u32 logical_byte_offset ; u32 end_line ; u32 end_logical_line ; u32 acpi_btype ; u32 aml_length ; u32 aml_subtree_length ; u32 final_aml_length ; u32 final_aml_offset ; u32 compile_flags ; u16 parse_opcode ; u8 aml_opcode_length ; u8 aml_pkg_len_bytes ; u8 extra ; char parse_op_name [ 20 ] ; } ;

union acpi_parse_object { struct acpi_parse_obj_common common ; struct acpi_parse_obj_named named ; struct acpi_parse_obj_asl asl ; } ;
struct acpi_parse_state { u8 * aml_start ; u8 * aml ; u8 * aml_end ; u8 * pkg_start ; u8 * pkg_end ; union acpi_parse_object * start_op ; struct acpi_namespace_node * start_node ; union acpi_generic_state * scope ; union acpi_parse_object * start_scope ; u32 aml_size ; } ;

struct acpi_bit_register_info { u8 parent_register ; u8 bit_position ; u16 access_bit_mask ; } ;

struct acpi_interface_info { char * name ; u8 value ; } ;

struct acpi_port_info { char * name ; u16 start ; u16 end ; u8 osi_dependency ; } ;

struct acpi_db_method_info { acpi_handle main_thread_gate ; acpi_handle thread_complete_gate ; u32 * threads ; u32 num_threads ; u32 num_created ; u32 num_completed ; char * name ; u32 flags ; u32 num_loops ; char pathname [ 128 ] ; char * * args ; char init_args ; char * arguments [ 4 ] ; char num_threads_str [ 11 ] ; char id_of_thread_str [ 11 ] ; char index_of_thread_str [ 11 ] ; } ;

struct acpi_integrity_info { u32 nodes ; u32 objects ; } ;

struct acpi_debug_mem_header { struct acpi_debug_mem_block * previous ; struct acpi_debug_mem_block * next ; u32 size ; u32 component ; u32 line ; char module [ 16 ] ; u8 alloc_type ; } ;

struct acpi_debug_mem_block { struct acpi_debug_mem_block * previous ; struct acpi_debug_mem_block * next ; u32 size ; u32 component ; u32 line ; char module [ 16 ] ; u8 alloc_type ; u64 user_space ; } ;

struct acpi_object_common { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; } ;

struct acpi_object_integer { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 fill [ 3 ] ; acpi_integer value ; } ;

struct acpi_object_string { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; char * pointer ; u32 length ; } ;

struct acpi_object_buffer { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 * pointer ; u32 length ; u32 aml_length ; u8 * aml_start ; struct acpi_namespace_node * node ; } ;

struct acpi_object_package { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; struct acpi_namespace_node * node ; union acpi_operand_object * * elements ; u8 * aml_start ; u32 aml_length ; u32 count ; } ;

struct acpi_object_event { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; void * os_semaphore ; } ;

struct acpi_object_mutex { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 sync_level ; u16 acquisition_depth ; void * os_mutex ; struct task_struct * thread_id ; struct acpi_thread_state * owner_thread ; union acpi_operand_object * prev ; union acpi_operand_object * next ; struct acpi_namespace_node * node ; u8 original_sync_level ; } ;

struct acpi_object_region { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 space_id ; struct acpi_namespace_node * node ; union acpi_operand_object * handler ; union acpi_operand_object * next ; acpi_physical_address address ; u32 length ; } ;

struct acpi_object_method { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 method_flags ; u8 param_count ; u8 sync_level ; union acpi_operand_object * mutex ; u8 * aml_start ; ACPI_INTERNAL_METHOD implementation ; u32 aml_length ; u8 thread_count ; acpi_owner_id owner_id ; } ;

struct acpi_object_notify_common { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; union acpi_operand_object * system_notify ; union acpi_operand_object * device_notify ; union acpi_operand_object * handler ; } ;

struct acpi_object_device { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; union acpi_operand_object * system_notify ; union acpi_operand_object * device_notify ; union acpi_operand_object * handler ; struct acpi_gpe_block_info * gpe_block ; } ;

struct acpi_object_power_resource { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; union acpi_operand_object * system_notify ; union acpi_operand_object * device_notify ; union acpi_operand_object * handler ; u32 system_level ; u32 resource_order ; } ;

struct acpi_object_processor { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 proc_id ; u8 length ; union acpi_operand_object * system_notify ; union acpi_operand_object * device_notify ; union acpi_operand_object * handler ; acpi_io_address address ; } ;

struct acpi_object_thermal_zone { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; union acpi_operand_object * system_notify ; union acpi_operand_object * device_notify ; union acpi_operand_object * handler ; } ;

struct acpi_object_field_common { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 field_flags ; u8 attribute ; u8 access_byte_width ; struct acpi_namespace_node * node ; u32 bit_length ; u32 base_byte_offset ; u32 value ; u8 start_field_bit_offset ; u8 access_bit_width ; union acpi_operand_object * region_obj ; } ;

struct acpi_object_region_field { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 field_flags ; u8 attribute ; u8 access_byte_width ; struct acpi_namespace_node * node ; u32 bit_length ; u32 base_byte_offset ; u32 value ; u8 start_field_bit_offset ; u8 access_bit_width ; union acpi_operand_object * region_obj ; } ;

struct acpi_object_bank_field { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 field_flags ; u8 attribute ; u8 access_byte_width ; struct acpi_namespace_node * node ; u32 bit_length ; u32 base_byte_offset ; u32 value ; u8 start_field_bit_offset ; u8 access_bit_width ; union acpi_operand_object * region_obj ; union acpi_operand_object * bank_obj ; } ;

struct acpi_object_index_field { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 field_flags ; u8 attribute ; u8 access_byte_width ; struct acpi_namespace_node * node ; u32 bit_length ; u32 base_byte_offset ; u32 value ; u8 start_field_bit_offset ; u8 access_bit_width ; union acpi_operand_object * index_obj ; union acpi_operand_object * data_obj ; } ;

struct acpi_object_buffer_field { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 field_flags ; u8 attribute ; u8 access_byte_width ; struct acpi_namespace_node * node ; u32 bit_length ; u32 base_byte_offset ; u32 value ; u8 start_field_bit_offset ; u8 access_bit_width ; union acpi_operand_object * buffer_obj ; } ;

struct acpi_object_notify_handler { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; struct acpi_namespace_node * node ; acpi_notify_handler handler ; void * context ; } ;

struct acpi_object_addr_handler { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 space_id ; u8 handler_flags ; acpi_adr_space_handler handler ; struct acpi_namespace_node * node ; void * context ; acpi_adr_space_setup setup ; union acpi_operand_object * region_list ; union acpi_operand_object * next ; } ;

struct acpi_object_reference { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; u8 class ; u8 target_type ; u8 reserved ; void * object ; struct acpi_namespace_node * node ; union acpi_operand_object * * where ; u32 value ; } ;

typedef enum { ACPI_REFCLASS_LOCAL = 0 , ACPI_REFCLASS_ARG = 1 , ACPI_REFCLASS_REFOF = 2 , ACPI_REFCLASS_INDEX = 3 , ACPI_REFCLASS_TABLE = 4 , ACPI_REFCLASS_NAME = 5 , ACPI_REFCLASS_DEBUG = 6 , ACPI_REFCLASS_MAX = 6 } ACPI_REFERENCE_CLASSES ;

struct acpi_object_extra { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; struct acpi_namespace_node * method_REG ; void * region_context ; u8 * aml_start ; u32 aml_length ; } ;

struct acpi_object_data { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; acpi_object_handler handler ; void * pointer ; } ;

struct acpi_object_cache_list { union acpi_operand_object * next_object ; u8 descriptor_type ; u8 type ; u16 reference_count ; u8 flags ; union acpi_operand_object * next ; } ;

union acpi_operand_object { struct acpi_object_common common ; struct acpi_object_integer integer ; struct acpi_object_string string ; struct acpi_object_buffer buffer ; struct acpi_object_package package ; struct acpi_object_event event ; struct acpi_object_method method ; struct acpi_object_mutex mutex ; struct acpi_object_region region ; struct acpi_object_notify_common common_notify ; struct acpi_object_device device ; struct acpi_object_power_resource power_resource ; struct acpi_object_processor processor ; struct acpi_object_thermal_zone thermal_zone ; struct acpi_object_field_common common_field ; struct acpi_object_region_field field ; struct acpi_object_buffer_field buffer_field ; struct acpi_object_bank_field bank_field ; struct acpi_object_index_field index_field ; struct acpi_object_notify_handler notify ; struct acpi_object_addr_handler address_space ; struct acpi_object_reference reference ; struct acpi_object_extra extra ; struct acpi_object_data data ; struct acpi_object_cache_list cache ; struct acpi_namespace_node node ; } ;

struct acpi_common_descriptor { void * common_pointer ; u8 descriptor_type ; } ;

union acpi_descriptor { struct acpi_common_descriptor common ; union acpi_operand_object object ; struct acpi_namespace_node node ; union acpi_parse_object op ; } ;

struct acpi_walk_state { struct acpi_walk_state * next ; u8 descriptor_type ; u8 walk_type ; u16 opcode ; u8 next_op_info ; u8 num_operands ; u8 operand_index ; acpi_owner_id owner_id ; u8 last_predicate ; u8 current_result ; u8 return_used ; u8 scope_depth ; u8 pass_number ; u8 result_size ; u8 result_count ; u32 aml_offset ; u32 arg_types ; u32 method_breakpoint ; u32 user_breakpoint ; u32 parse_flags ; struct acpi_parse_state parser_state ; u32 prev_arg_types ; u32 arg_count ; struct acpi_namespace_node arguments [ 7 ] ; struct acpi_namespace_node local_variables [ 8 ] ; union acpi_operand_object * operands [ 8 + 1 ] ; union acpi_operand_object * * params ; u8 * aml_last_while ; union acpi_operand_object * * caller_return_desc ; union acpi_generic_state * control_state ; struct acpi_namespace_node * deferred_node ; union acpi_operand_object * implicit_return_obj ; struct acpi_namespace_node * method_call_node ; union acpi_parse_object * method_call_op ; union acpi_operand_object * method_desc ; struct acpi_namespace_node * method_node ; union acpi_parse_object * op ; const struct acpi_opcode_info * op_info ; union acpi_parse_object * origin ; union acpi_operand_object * result_obj ; union acpi_generic_state * results ; union acpi_operand_object * return_desc ; union acpi_generic_state * scope_info ; union acpi_parse_object * prev_op ; union acpi_parse_object * next_op ; struct acpi_thread_state * thread ; acpi_parse_downwards descending_callback ; acpi_parse_upwards ascending_callback ; } ;
struct acpi_init_walk_info { u16 method_count ; u16 device_count ; u16 op_region_count ; u16 field_count ; u16 buffer_count ; u16 package_count ; u16 op_region_init ; u16 field_init ; u16 buffer_init ; u16 package_init ; u16 object_count ; acpi_owner_id owner_id ; u32 table_index ; } ;

struct acpi_get_devices_info { acpi_walk_callback user_function ; void * context ; const char * hid ; } ;

union acpi_aml_operands { union acpi_operand_object * operands [ 7 ] ; struct { struct acpi_object_integer * type ; struct acpi_object_integer * code ; struct acpi_object_integer * argument ; } fatal ; struct { union acpi_operand_object * source ; struct acpi_object_integer * index ; union acpi_operand_object * target ; } index ; struct { union acpi_operand_object * source ; struct acpi_object_integer * index ; struct acpi_object_integer * length ; union acpi_operand_object * target ; } mid ; } ;

struct acpi_evaluate_info { struct acpi_namespace_node * prefix_node ; char * pathname ; union acpi_operand_object * obj_desc ; union acpi_operand_object * * parameters ; struct acpi_namespace_node * resolved_node ; union acpi_operand_object * return_object ; u8 param_count ; u8 pass_number ; u8 return_object_type ; u8 flags ; } ;

struct acpi_device_walk_info { u16 device_count ; u16 num_STA ; u16 num_INI ; struct acpi_table_desc * table_desc ; struct acpi_evaluate_info * evaluate_info ; } ;

struct acpi_walk_info { u32 debug_level ; u32 count ; acpi_owner_id owner_id ; u8 display_type ; } ;

typedef acpi_status ( * acpi_walk_aml_callback ) ( u8 * aml , u32 length , u32 offset , u8 resource_index , void * * context ) ;
typedef acpi_status ( * acpi_pkg_callback ) ( u8 object_type , union acpi_operand_object * source_object , union acpi_generic_state * state , void * context ) ;
struct acpi_pkg_info { u8 * free_space ; acpi_size length ; u32 object_space ; u32 num_packages ; } ;

typedef enum { REGION_MEMORY = 0 , REGION_IO , REGION_PCI_CONFIG , REGION_EC , REGION_SMBUS , REGION_CMOS , REGION_PCI_BAR , REGION_IPMI , REGION_DATA_TABLE , REGION_FIXED_HW = 0x7F } AML_REGION_TYPES ;

typedef enum { MATCH_MTR = 0 , MATCH_MEQ = 1 , MATCH_MLE = 2 , MATCH_MLT = 3 , MATCH_MGE = 4 , MATCH_MGT = 5 } AML_MATCH_OPERATOR ;

typedef enum { AML_FIELD_ACCESS_ANY = 0x00 , AML_FIELD_ACCESS_BYTE = 0x01 , AML_FIELD_ACCESS_WORD = 0x02 , AML_FIELD_ACCESS_DWORD = 0x03 , AML_FIELD_ACCESS_QWORD = 0x04 , AML_FIELD_ACCESS_BUFFER = 0x05 } AML_ACCESS_TYPE ;

typedef enum { AML_FIELD_LOCK_NEVER = 0x00 , AML_FIELD_LOCK_ALWAYS = 0x10 } AML_LOCK_RULE ;

typedef enum { AML_FIELD_UPDATE_PRESERVE = 0x00 , AML_FIELD_UPDATE_WRITE_AS_ONES = 0x20 , AML_FIELD_UPDATE_WRITE_AS_ZEROS = 0x40 } AML_UPDATE_RULE ;

typedef enum { AML_FIELD_ATTRIB_SMB_QUICK = 0x02 , AML_FIELD_ATTRIB_SMB_SEND_RCV = 0x04 , AML_FIELD_ATTRIB_SMB_BYTE = 0x06 , AML_FIELD_ATTRIB_SMB_WORD = 0x08 , AML_FIELD_ATTRIB_SMB_BLOCK = 0x0A , AML_FIELD_ATTRIB_SMB_WORD_CALL = 0x0C , AML_FIELD_ATTRIB_SMB_BLOCK_CALL = 0x0D } AML_ACCESS_ATTRIBUTE ;


typedef const struct acpi_exdump_info { u8 opcode ; u8 offset ; char * name ; } acpi_exdump_info ;

acpi_status acpi_ds_create_buffer_field ( union acpi_parse_object * op , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_create_field ( union acpi_parse_object * op , struct acpi_namespace_node * region_node , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_init_field_objects ( union acpi_parse_object * op , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_create_bank_field ( union acpi_parse_object * op , struct acpi_namespace_node * region_node , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_create_index_field ( union acpi_parse_object * op , struct acpi_namespace_node * region_node , struct acpi_walk_state * walk_state ) ;

void acpi_ds_method_data_init ( struct acpi_walk_state * walk_state ) ;

void acpi_ds_method_data_delete_all ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_method_data_init_args ( union acpi_operand_object * * params , u32 max_param_count , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_method_data_get_node ( u8 type , u32 index , struct acpi_walk_state * walk_state , struct acpi_namespace_node * * node ) ;

acpi_status acpi_ds_method_data_get_value ( u8 type , u32 index , struct acpi_walk_state * walk_state , union acpi_operand_object * * dest_desc ) ;

acpi_status acpi_ds_store_object_to_local ( u8 type , u32 index , union acpi_operand_object * obj_desc , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_get_buffer_field_arguments ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ds_get_bank_field_arguments ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ds_get_buffer_arguments ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ds_get_package_arguments ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ds_get_region_arguments ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ds_initialize_region ( acpi_handle obj_handle ) ;

acpi_status acpi_ds_eval_buffer_field_operands ( struct acpi_walk_state * walk_state , union acpi_parse_object * op ) ;

acpi_status acpi_ds_eval_region_operands ( struct acpi_walk_state * walk_state , union acpi_parse_object * op ) ;

acpi_status acpi_ds_eval_table_region_operands ( struct acpi_walk_state * walk_state , union acpi_parse_object * op ) ;

acpi_status acpi_ds_eval_data_object_operands ( struct acpi_walk_state * walk_state , union acpi_parse_object * op , union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ds_eval_bank_field_operands ( struct acpi_walk_state * walk_state , union acpi_parse_object * op ) ;

acpi_status acpi_ds_exec_begin_control_op ( struct acpi_walk_state * walk_state , union acpi_parse_object * op ) ;

acpi_status acpi_ds_exec_end_control_op ( struct acpi_walk_state * walk_state , union acpi_parse_object * op ) ;

struct command_info { char * name ; u8 min_args ; } ;

struct argument_info { char * name ; } ;

acpi_status acpi_ds_get_predicate_value ( struct acpi_walk_state * walk_state , union acpi_operand_object * result_obj ) ;

acpi_status acpi_ds_exec_begin_op ( struct acpi_walk_state * walk_state , union acpi_parse_object * * out_op ) ;

acpi_status acpi_ds_exec_end_op ( struct acpi_walk_state * walk_state ) ;

void acpi_ds_scope_stack_clear ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_scope_stack_push ( struct acpi_namespace_node * node , acpi_object_type type , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_scope_stack_pop ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_method_error ( acpi_status status , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_begin_method_execution ( struct acpi_namespace_node * method_node , union acpi_operand_object * obj_desc , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_call_control_method ( struct acpi_thread_state * thread , struct acpi_walk_state * this_walk_state , union acpi_parse_object * op ) ;

acpi_status acpi_ds_restart_control_method ( struct acpi_walk_state * walk_state , union acpi_operand_object * return_desc ) ;

void acpi_ds_terminate_control_method ( union acpi_operand_object * method_desc , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_build_internal_buffer_obj ( struct acpi_walk_state * walk_state , union acpi_parse_object * op , u32 buffer_length , union acpi_operand_object * * obj_desc_ptr ) ;

acpi_status acpi_ds_build_internal_package_obj ( struct acpi_walk_state * walk_state , union acpi_parse_object * op , u32 element_count , union acpi_operand_object * * obj_desc_ptr ) ;

acpi_status acpi_ds_create_node ( struct acpi_walk_state * walk_state , struct acpi_namespace_node * node , union acpi_parse_object * op ) ;

acpi_status acpi_ds_init_object_from_op ( struct acpi_walk_state * walk_state , union acpi_parse_object * op , u16 opcode , union acpi_operand_object * * ret_obj_desc ) ;

void acpi_ds_clear_implicit_return ( struct acpi_walk_state * walk_state ) ;

u8 acpi_ds_do_implicit_return ( union acpi_operand_object * return_desc , struct acpi_walk_state * walk_state , u8 add_reference ) ;

u8 acpi_ds_is_result_used ( union acpi_parse_object * op , struct acpi_walk_state * walk_state ) ;

void acpi_ds_delete_result_if_not_used ( union acpi_parse_object * op , union acpi_operand_object * result_obj , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_resolve_operands ( struct acpi_walk_state * walk_state ) ;

void acpi_ds_clear_operands ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_create_operand ( struct acpi_walk_state * walk_state , union acpi_parse_object * arg , u32 arg_index ) ;

acpi_status acpi_ds_create_operands ( struct acpi_walk_state * walk_state , union acpi_parse_object * first_arg ) ;

acpi_status acpi_ds_evaluate_name_path ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_init_callbacks ( struct acpi_walk_state * walk_state , u32 pass_number ) ;

acpi_status acpi_ds_load1_begin_op ( struct acpi_walk_state * walk_state , union acpi_parse_object * * out_op ) ;

acpi_status acpi_ds_load1_end_op ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_load2_begin_op ( struct acpi_walk_state * walk_state , union acpi_parse_object * * out_op ) ;

acpi_status acpi_ds_load2_end_op ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_result_pop ( union acpi_operand_object * * object , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_result_push ( union acpi_operand_object * object , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_obj_stack_push ( void * object , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_obj_stack_pop ( u32 pop_count , struct acpi_walk_state * walk_state ) ;

void acpi_ds_obj_stack_pop_and_delete ( u32 pop_count , struct acpi_walk_state * walk_state ) ;

struct acpi_walk_state * acpi_ds_get_current_walk_state ( struct acpi_thread_state * thread ) ;

void acpi_ds_push_walk_state ( struct acpi_walk_state * walk_state , struct acpi_thread_state * thread ) ;

struct acpi_walk_state * acpi_ds_pop_walk_state ( struct acpi_thread_state * thread ) ;

struct acpi_walk_state * acpi_ds_create_walk_state ( acpi_owner_id owner_id , union acpi_parse_object * origin , union acpi_operand_object * method_desc , struct acpi_thread_state * thread ) ;

acpi_status acpi_ds_init_aml_walk ( struct acpi_walk_state * walk_state , union acpi_parse_object * op , struct acpi_namespace_node * method_node , u8 * aml_start , u32 aml_length , struct acpi_evaluate_info * info , u8 pass_number ) ;

void acpi_ds_delete_walk_state ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ds_initialize_objects ( u32 table_index , struct acpi_namespace_node * start_node ) ;

acpi_status acpi_ev_initialize_events ( void ) ;

acpi_status acpi_ev_install_fadt_gpes ( void ) ;

acpi_status acpi_ev_install_xrupt_handlers ( void ) ;

u32 acpi_ev_fixed_event_detect ( void ) ;

acpi_status acpi_ev_install_region_handlers ( void ) ;

acpi_status acpi_ev_initialize_op_regions ( void ) ;

acpi_status acpi_ev_execute_reg_method ( union acpi_operand_object * region_obj , u32 function ) ;

acpi_status acpi_ev_address_space_dispatch ( union acpi_operand_object * region_obj , u32 function , u32 region_offset , u32 bit_width , acpi_integer * value ) ;

void acpi_ev_detach_region ( union acpi_operand_object * region_obj , u8 acpi_ns_is_locked ) ;

acpi_status acpi_ev_attach_region ( union acpi_operand_object * handler_obj , union acpi_operand_object * region_obj , u8 acpi_ns_is_locked ) ;

acpi_status acpi_ev_install_space_handler ( struct acpi_namespace_node * node , acpi_adr_space_type space_id , acpi_adr_space_handler handler , acpi_adr_space_setup setup , void * context ) ;

acpi_status acpi_ev_execute_reg_methods ( struct acpi_namespace_node * node , acpi_adr_space_type space_id ) ;

u32 acpi_ev_gpe_xrupt_handler ( void * context ) ;

u32 acpi_ev_install_sci_handler ( void ) ;

acpi_status acpi_ev_remove_sci_handler ( void ) ;

acpi_status acpi_enable ( void ) ;

acpi_status acpi_disable ( void ) ;

acpi_status acpi_enable_event ( u32 event , u32 flags ) ;

acpi_status acpi_set_gpe_type ( acpi_handle gpe_device , u32 gpe_number , u8 type ) ;

acpi_status acpi_enable_gpe ( acpi_handle gpe_device , u32 gpe_number ) ;

acpi_status acpi_disable_gpe ( acpi_handle gpe_device , u32 gpe_number ) ;

acpi_status acpi_disable_event ( u32 event , u32 flags ) ;

acpi_status acpi_clear_event ( u32 event ) ;

acpi_status acpi_clear_gpe ( acpi_handle gpe_device , u32 gpe_number , u32 flags ) ;

acpi_status acpi_get_event_status ( u32 event , acpi_event_status * event_status ) ;

acpi_status acpi_get_gpe_status ( acpi_handle gpe_device , u32 gpe_number , u32 flags , acpi_event_status * event_status ) ;

acpi_status acpi_install_gpe_block ( acpi_handle gpe_device , struct acpi_generic_address * gpe_block_address , u32 register_count , u32 interrupt_number ) ;

acpi_status acpi_remove_gpe_block ( acpi_handle gpe_device ) ;

acpi_status acpi_get_gpe_device ( u32 index , acpi_handle * gpe_device ) ;

acpi_status acpi_disable_all_gpes ( void ) ;

acpi_status acpi_enable_all_runtime_gpes ( void ) ;

u8 acpi_ev_is_notify_object ( struct acpi_namespace_node * node ) ;

acpi_status acpi_ev_queue_notify_request ( struct acpi_namespace_node * node , u32 notify_value ) ;

acpi_status acpi_ev_init_global_lock_handler ( void ) ;

acpi_status acpi_ev_acquire_global_lock ( u16 timeout ) ;

acpi_status acpi_ev_release_global_lock ( void ) ;

void acpi_ev_terminate ( void ) ;

acpi_status acpi_ev_system_memory_region_setup ( acpi_handle handle , u32 function , void * handler_context , void * * region_context ) ;

acpi_status acpi_ev_io_space_region_setup ( acpi_handle handle , u32 function , void * handler_context , void * * region_context ) ;

acpi_status acpi_ev_pci_config_region_setup ( acpi_handle handle , u32 function , void * handler_context , void * * region_context ) ;

acpi_status acpi_ev_pci_bar_region_setup ( acpi_handle handle , u32 function , void * handler_context , void * * region_context ) ;

acpi_status acpi_ev_cmos_region_setup ( acpi_handle handle , u32 function , void * handler_context , void * * region_context ) ;

acpi_status acpi_ev_default_region_setup ( acpi_handle handle , u32 function , void * handler_context , void * * region_context ) ;

acpi_status acpi_ev_initialize_region ( union acpi_operand_object * region_obj , u8 acpi_ns_locked ) ;

acpi_status acpi_install_fixed_event_handler ( u32 event , acpi_event_handler handler , void * context ) ;

acpi_status acpi_remove_fixed_event_handler ( u32 event , acpi_event_handler handler ) ;

acpi_status acpi_install_notify_handler ( acpi_handle device , u32 handler_type , acpi_notify_handler handler , void * context ) ;

acpi_status acpi_remove_notify_handler ( acpi_handle device , u32 handler_type , acpi_notify_handler handler ) ;

acpi_status acpi_install_gpe_handler ( acpi_handle gpe_device , u32 gpe_number , u32 type , acpi_event_handler address , void * context ) ;

acpi_status acpi_remove_gpe_handler ( acpi_handle gpe_device , u32 gpe_number , acpi_event_handler address ) ;

acpi_status acpi_acquire_global_lock ( u16 timeout , u32 * handle ) ;

acpi_status acpi_release_global_lock ( u32 handle ) ;

acpi_status acpi_install_address_space_handler ( acpi_handle device , acpi_adr_space_type space_id , acpi_adr_space_handler handler , acpi_adr_space_setup setup , void * context ) ;

acpi_status acpi_remove_address_space_handler ( acpi_handle device , acpi_adr_space_type space_id , acpi_adr_space_handler handler ) ;

acpi_status acpi_ev_set_gpe_type ( struct acpi_gpe_event_info * gpe_event_info , u8 type ) ;

acpi_status acpi_ev_update_gpe_enable_masks ( struct acpi_gpe_event_info * gpe_event_info , u8 type ) ;

acpi_status acpi_ev_enable_gpe ( struct acpi_gpe_event_info * gpe_event_info , u8 write_to_hardware ) ;

acpi_status acpi_ev_disable_gpe ( struct acpi_gpe_event_info * gpe_event_info ) ;

struct acpi_gpe_event_info * acpi_ev_get_gpe_event_info ( acpi_handle gpe_device , u32 gpe_number ) ;

u32 acpi_ev_gpe_detect ( struct acpi_gpe_xrupt_info * gpe_xrupt_list ) ;

u32 acpi_ev_gpe_dispatch ( struct acpi_gpe_event_info * gpe_event_info , u32 gpe_number ) ;

u8 acpi_ev_valid_gpe_event ( struct acpi_gpe_event_info * gpe_event_info ) ;

acpi_status acpi_ev_walk_gpe_list ( acpi_gpe_callback gpe_walk_callback , void * context ) ;

acpi_status acpi_ev_delete_gpe_handlers ( struct acpi_gpe_xrupt_info * gpe_xrupt_info , struct acpi_gpe_block_info * gpe_block , void * context ) ;

acpi_status acpi_ev_delete_gpe_block ( struct acpi_gpe_block_info * gpe_block ) ;

acpi_status acpi_ev_create_gpe_block ( struct acpi_namespace_node * gpe_device , struct acpi_generic_address * gpe_block_address , u32 register_count , u8 gpe_block_base_number , u32 interrupt_number , struct acpi_gpe_block_info * * return_gpe_block ) ;

acpi_status acpi_ev_initialize_gpe_block ( struct acpi_namespace_node * gpe_device , struct acpi_gpe_block_info * gpe_block ) ;

acpi_status acpi_ev_gpe_initialize ( void ) ;

acpi_status acpi_ex_load_table_op ( struct acpi_walk_state * walk_state , union acpi_operand_object * * return_desc ) ;

acpi_status acpi_ex_load_op ( union acpi_operand_object * obj_desc , union acpi_operand_object * target , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_unload_table ( union acpi_operand_object * ddb_handle ) ;

acpi_status acpi_ex_read_data_from_field ( struct acpi_walk_state * walk_state , union acpi_operand_object * obj_desc , union acpi_operand_object * * ret_buffer_desc ) ;

acpi_status acpi_ex_write_data_to_field ( union acpi_operand_object * source_desc , union acpi_operand_object * obj_desc , union acpi_operand_object * * result_desc ) ;

acpi_status acpi_ex_get_name_string ( acpi_object_type data_type , u8 * in_aml_address , char * * out_name_string , u32 * out_name_length ) ;

acpi_status acpi_ex_opcode_6A_0T_1R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_resolve_to_value ( union acpi_operand_object * * stack_ptr , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_resolve_multiple ( struct acpi_walk_state * walk_state , union acpi_operand_object * operand , acpi_object_type * return_type , union acpi_operand_object * * return_desc ) ;

acpi_status acpi_ex_store_buffer_to_buffer ( union acpi_operand_object * source_desc , union acpi_operand_object * target_desc ) ;

acpi_status acpi_ex_store_string_to_string ( union acpi_operand_object * source_desc , union acpi_operand_object * target_desc ) ;

acpi_status acpi_ex_convert_to_integer ( union acpi_operand_object * obj_desc , union acpi_operand_object * * result_desc , u32 flags ) ;

acpi_status acpi_ex_convert_to_buffer ( union acpi_operand_object * obj_desc , union acpi_operand_object * * result_desc ) ;

acpi_status acpi_ex_convert_to_string ( union acpi_operand_object * obj_desc , union acpi_operand_object * * result_desc , u32 type ) ;

acpi_status acpi_ex_convert_to_target_type ( acpi_object_type destination_type , union acpi_operand_object * source_desc , union acpi_operand_object * * result_desc , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_access_region ( union acpi_operand_object * obj_desc , u32 field_datum_byte_offset , acpi_integer * value , u32 function ) ;

acpi_status acpi_ex_write_with_update_rule ( union acpi_operand_object * obj_desc , acpi_integer mask , acpi_integer field_value , u32 field_datum_byte_offset ) ;

acpi_status acpi_ex_extract_from_field ( union acpi_operand_object * obj_desc , void * buffer , u32 buffer_length ) ;

acpi_status acpi_ex_insert_into_field ( union acpi_operand_object * obj_desc , void * buffer , u32 buffer_length ) ;

acpi_status acpi_ex_opcode_0A_0T_1R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_opcode_1A_0T_0R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_opcode_1A_1T_0R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_opcode_1A_1T_1R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_opcode_1A_0T_1R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_prep_common_field_object ( union acpi_operand_object * obj_desc , u8 field_flags , u8 field_attribute , u32 field_bit_position , u32 field_bit_length ) ;

acpi_status acpi_ex_prep_field_value ( struct acpi_create_field_info * info ) ;

acpi_status acpi_ex_resolve_operands ( u16 opcode , union acpi_operand_object * * stack_ptr , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_system_wait_semaphore ( void * semaphore , u16 timeout ) ;

acpi_status acpi_ex_system_wait_mutex ( void * mutex , u16 timeout ) ;

acpi_status acpi_ex_system_do_stall ( u32 how_long ) ;

acpi_status acpi_ex_system_do_suspend ( acpi_integer how_long ) ;

acpi_status acpi_ex_system_signal_event ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ex_system_wait_event ( union acpi_operand_object * time_desc , union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ex_system_reset_event ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ex_create_alias ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_create_event ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_create_mutex ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_create_region ( u8 * aml_start , u32 aml_length , u8 region_space , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_create_processor ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_create_power_resource ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_create_method ( u8 * aml_start , u32 aml_length , struct acpi_walk_state * walk_state ) ;

struct asl_resource_node { u32 buffer_length ; void * buffer ; struct asl_resource_node * next ; } ;

struct aml_resource_small_header { u8 descriptor_type ; } ;

struct aml_resource_irq { u8 descriptor_type ; u16 irq_mask ; u8 flags ; } ;

struct aml_resource_irq_noflags { u8 descriptor_type ; u16 irq_mask ; } ;

struct aml_resource_dma { u8 descriptor_type ; u8 dma_channel_mask ; u8 flags ; } ;

struct aml_resource_start_dependent { u8 descriptor_type ; u8 flags ; } ;

struct aml_resource_start_dependent_noprio { u8 descriptor_type ; } ;

struct aml_resource_end_dependent { u8 descriptor_type ; } ;

struct aml_resource_io { u8 descriptor_type ; u8 flags ; u16 minimum ; u16 maximum ; u8 alignment ; u8 address_length ; } ;

struct aml_resource_fixed_io { u8 descriptor_type ; u16 address ; u8 address_length ; } ;

struct aml_resource_vendor_small { u8 descriptor_type ; } ;

struct aml_resource_end_tag { u8 descriptor_type ; u8 checksum ; } ;

struct aml_resource_large_header { u8 descriptor_type ; u16 resource_length ; } ;

struct aml_resource_memory24 { u8 descriptor_type ; u16 resource_length ; u8 flags ; u16 minimum ; u16 maximum ; u16 alignment ; u16 address_length ; } ;

struct aml_resource_vendor_large { u8 descriptor_type ; u16 resource_length ; } ;

struct aml_resource_memory32 { u8 descriptor_type ; u16 resource_length ; u8 flags ; u32 minimum ; u32 maximum ; u32 alignment ; u32 address_length ; } ;

struct aml_resource_fixed_memory32 { u8 descriptor_type ; u16 resource_length ; u8 flags ; u32 address ; u32 address_length ; } ;

struct aml_resource_address { u8 descriptor_type ; u16 resource_length ; u8 resource_type ; u8 flags ; u8 specific_flags ; } ;

struct aml_resource_extended_address64 { u8 descriptor_type ; u16 resource_length ; u8 resource_type ; u8 flags ; u8 specific_flags ; u8 revision_iD ; u8 reserved ; u64 granularity ; u64 minimum ; u64 maximum ; u64 translation_offset ; u64 address_length ; u64 type_specific ; } ;

struct aml_resource_address64 { u8 descriptor_type ; u16 resource_length ; u8 resource_type ; u8 flags ; u8 specific_flags ; u64 granularity ; u64 minimum ; u64 maximum ; u64 translation_offset ; u64 address_length ; } ;

struct aml_resource_address32 { u8 descriptor_type ; u16 resource_length ; u8 resource_type ; u8 flags ; u8 specific_flags ; u32 granularity ; u32 minimum ; u32 maximum ; u32 translation_offset ; u32 address_length ; } ;

struct aml_resource_address16 { u8 descriptor_type ; u16 resource_length ; u8 resource_type ; u8 flags ; u8 specific_flags ; u16 granularity ; u16 minimum ; u16 maximum ; u16 translation_offset ; u16 address_length ; } ;

struct aml_resource_extended_irq { u8 descriptor_type ; u16 resource_length ; u8 flags ; u8 interrupt_count ; u32 interrupts [ 1 ] ; } ;

struct aml_resource_generic_register { u8 descriptor_type ; u16 resource_length ; u8 address_space_id ; u8 bit_width ; u8 bit_offset ; u8 access_size ; u64 address ; } ;

union aml_resource { u8 descriptor_type ; struct aml_resource_small_header small_header ; struct aml_resource_large_header large_header ; struct aml_resource_irq irq ; struct aml_resource_dma dma ; struct aml_resource_start_dependent start_dpf ; struct aml_resource_end_dependent end_dpf ; struct aml_resource_io io ; struct aml_resource_fixed_io fixed_io ; struct aml_resource_vendor_small vendor_small ; struct aml_resource_end_tag end_tag ; struct aml_resource_memory24 memory24 ; struct aml_resource_generic_register generic_reg ; struct aml_resource_vendor_large vendor_large ; struct aml_resource_memory32 memory32 ; struct aml_resource_fixed_memory32 fixed_memory32 ; struct aml_resource_address16 address16 ; struct aml_resource_address32 address32 ; struct aml_resource_address64 address64 ; struct aml_resource_extended_address64 ext_address64 ; struct aml_resource_extended_irq extended_irq ; struct aml_resource_address address ; u32 dword_item ; u16 word_item ; u8 byte_item ; } ;

acpi_status acpi_ex_get_object_reference ( union acpi_operand_object * obj_desc , union acpi_operand_object * * return_desc , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_concat_template ( union acpi_operand_object * operand0 , union acpi_operand_object * operand1 , union acpi_operand_object * * actual_return_desc , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_do_concatenate ( union acpi_operand_object * operand0 , union acpi_operand_object * operand1 , union acpi_operand_object * * actual_return_desc , struct acpi_walk_state * walk_state ) ;

acpi_integer acpi_ex_do_math_op ( u16 opcode , acpi_integer integer0 , acpi_integer integer1 ) ;

acpi_status acpi_ex_do_logical_numeric_op ( u16 opcode , acpi_integer integer0 , acpi_integer integer1 , u8 * logical_result ) ;

acpi_status acpi_ex_do_logical_op ( u16 opcode , union acpi_operand_object * operand0 , union acpi_operand_object * operand1 , u8 * logical_result ) ;

acpi_status acpi_ex_opcode_2A_0T_0R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_opcode_2A_2T_1R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_opcode_2A_1T_1R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_opcode_2A_0T_1R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_system_memory_space_handler ( u32 function , acpi_physical_address address , u32 bit_width , acpi_integer * value , void * handler_context , void * region_context ) ;

acpi_status acpi_ex_system_io_space_handler ( u32 function , acpi_physical_address address , u32 bit_width , acpi_integer * value , void * handler_context , void * region_context ) ;

acpi_status acpi_ex_pci_config_space_handler ( u32 function , acpi_physical_address address , u32 bit_width , acpi_integer * value , void * handler_context , void * region_context ) ;

acpi_status acpi_ex_cmos_space_handler ( u32 function , acpi_physical_address address , u32 bit_width , acpi_integer * value , void * handler_context , void * region_context ) ;

acpi_status acpi_ex_pci_bar_space_handler ( u32 function , acpi_physical_address address , u32 bit_width , acpi_integer * value , void * handler_context , void * region_context ) ;

acpi_status acpi_ex_data_table_space_handler ( u32 function , acpi_physical_address address , u32 bit_width , acpi_integer * value , void * handler_context , void * region_context ) ;

acpi_status acpi_ex_store ( union acpi_operand_object * source_desc , union acpi_operand_object * dest_desc , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_store_object_to_node ( union acpi_operand_object * source_desc , struct acpi_namespace_node * node , struct acpi_walk_state * walk_state , u8 implicit_conversion ) ;

void acpi_ex_enter_interpreter ( void ) ;

void acpi_ex_reacquire_interpreter ( void ) ;

void acpi_ex_exit_interpreter ( void ) ;

void acpi_ex_relinquish_interpreter ( void ) ;

void acpi_ex_truncate_for32bit_table ( union acpi_operand_object * obj_desc ) ;

void acpi_ex_acquire_global_lock ( u32 field_flags ) ;

void acpi_ex_release_global_lock ( u32 field_flags ) ;

void acpi_ex_eisa_id_to_string ( char * out_string , acpi_integer compressed_id ) ;

void acpi_ex_integer_to_string ( char * out_string , acpi_integer value ) ;

void acpi_ex_unlink_mutex ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ex_acquire_mutex_object ( u16 timeout , union acpi_operand_object * obj_desc , struct task_struct * thread_id ) ;

acpi_status acpi_ex_acquire_mutex ( union acpi_operand_object * time_desc , union acpi_operand_object * obj_desc , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_release_mutex_object ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ex_release_mutex ( union acpi_operand_object * obj_desc , struct acpi_walk_state * walk_state ) ;

void acpi_ex_release_all_mutexes ( struct acpi_thread_state * thread ) ;

acpi_status acpi_ex_opcode_3A_0T_0R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_opcode_3A_1T_1R ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_resolve_node_to_value ( struct acpi_namespace_node * * object_ptr , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_resolve_object ( union acpi_operand_object * * source_desc_ptr , acpi_object_type target_type , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ex_store_object_to_object ( union acpi_operand_object * source_desc , union acpi_operand_object * dest_desc , union acpi_operand_object * * new_desc , struct acpi_walk_state * walk_state ) ;

acpi_status acpi_hw_set_mode ( u32 mode ) ;

u32 acpi_hw_get_mode ( void ) ;

acpi_status acpi_hw_low_disable_gpe ( struct acpi_gpe_event_info * gpe_event_info ) ;

acpi_status acpi_hw_write_gpe_enable_reg ( struct acpi_gpe_event_info * gpe_event_info ) ;

acpi_status acpi_hw_clear_gpe ( struct acpi_gpe_event_info * gpe_event_info ) ;

acpi_status acpi_hw_get_gpe_status ( struct acpi_gpe_event_info * gpe_event_info , acpi_event_status * event_status ) ;

acpi_status acpi_hw_disable_gpe_block ( struct acpi_gpe_xrupt_info * gpe_xrupt_info , struct acpi_gpe_block_info * gpe_block , void * context ) ;

acpi_status acpi_hw_clear_gpe_block ( struct acpi_gpe_xrupt_info * gpe_xrupt_info , struct acpi_gpe_block_info * gpe_block , void * context ) ;

acpi_status acpi_hw_enable_runtime_gpe_block ( struct acpi_gpe_xrupt_info * gpe_xrupt_info , struct acpi_gpe_block_info * gpe_block , void * context ) ;

acpi_status acpi_hw_disable_all_gpes ( void ) ;

acpi_status acpi_hw_enable_all_runtime_gpes ( void ) ;

acpi_status acpi_hw_enable_all_wakeup_gpes ( void ) ;

acpi_status acpi_hw_validate_register ( struct acpi_generic_address * reg , u8 max_bit_width , u64 * address ) ;

acpi_status acpi_hw_read ( u32 * value , struct acpi_generic_address * reg ) ;

acpi_status acpi_hw_write ( u32 value , struct acpi_generic_address * reg ) ;

acpi_status acpi_hw_clear_acpi_status ( void ) ;

struct acpi_bit_register_info * acpi_hw_get_bit_register_info ( u32 register_id ) ;

acpi_status acpi_hw_write_pm1_control ( u32 pm1a_control , u32 pm1b_control ) ;

acpi_status acpi_hw_register_read ( u32 register_id , u32 * return_value ) ;

acpi_status acpi_hw_register_write ( u32 register_id , u32 value ) ;

acpi_status acpi_set_firmware_waking_vector ( u32 physical_address ) ;

acpi_status acpi_set_firmware_waking_vector64 ( u64 physical_address ) ;

acpi_status acpi_enter_sleep_state_prep ( u8 sleep_state ) ;

acpi_status acpi_enter_sleep_state ( u8 sleep_state ) ;

acpi_status acpi_enter_sleep_state_s4bios ( void ) ;

acpi_status acpi_leave_sleep_state_prep ( u8 sleep_state ) ;

acpi_status acpi_leave_sleep_state ( u8 sleep_state ) ;

acpi_status acpi_reset ( void ) ;

acpi_status acpi_read ( u64 * return_value , struct acpi_generic_address * reg ) ;

acpi_status acpi_write ( u64 value , struct acpi_generic_address * reg ) ;

acpi_status acpi_read_bit_register ( u32 register_id , u32 * return_value ) ;

acpi_status acpi_write_bit_register ( u32 register_id , u32 value ) ;

acpi_status acpi_get_sleep_type_data ( u8 sleep_state , u8 * sleep_type_a , u8 * sleep_type_b ) ;

acpi_status acpi_hw_read_port ( acpi_io_address address , u32 * value , u32 width ) ;

acpi_status acpi_hw_write_port ( acpi_io_address address , u32 value , u32 width ) ;

acpi_status acpi_ns_root_initialize ( void ) ;

acpi_status acpi_ns_lookup ( union acpi_generic_state * scope_info , char * pathname , acpi_object_type type , acpi_interpreter_mode interpreter_mode , u32 flags , struct acpi_walk_state * walk_state , struct acpi_namespace_node * * return_node ) ;

acpi_status acpi_ns_load_table ( u32 table_index , struct acpi_namespace_node * node ) ;

acpi_status acpi_ns_search_one_scope ( u32 target_name , struct acpi_namespace_node * parent_node , acpi_object_type type , struct acpi_namespace_node * * return_node ) ;

acpi_status acpi_ns_search_and_enter ( u32 target_name , struct acpi_walk_state * walk_state , struct acpi_namespace_node * node , acpi_interpreter_mode interpreter_mode , acpi_object_type type , u32 flags , struct acpi_namespace_node * * return_node ) ;

acpi_status acpi_evaluate_object_typed ( acpi_handle handle , acpi_string pathname , struct acpi_object_list * external_params , struct acpi_buffer * return_buffer , acpi_object_type return_type ) ;

acpi_status acpi_evaluate_object ( acpi_handle handle , acpi_string pathname , struct acpi_object_list * external_params , struct acpi_buffer * return_buffer ) ;

acpi_status acpi_walk_namespace ( acpi_object_type type , acpi_handle start_object , u32 max_depth , acpi_walk_callback user_function , void * context , void * * return_value ) ;

acpi_status acpi_get_devices ( const char * HID , acpi_walk_callback user_function , void * context , void * * return_value ) ;

acpi_status acpi_attach_data ( acpi_handle obj_handle , acpi_object_handler handler , void * data ) ;

acpi_status acpi_detach_data ( acpi_handle obj_handle , acpi_object_handler handler ) ;

acpi_status acpi_get_data ( acpi_handle obj_handle , acpi_object_handler handler , void * * data ) ;

struct acpi_namespace_node * acpi_ns_create_node ( u32 name ) ;

void acpi_ns_delete_node ( struct acpi_namespace_node * node ) ;

void acpi_ns_remove_node ( struct acpi_namespace_node * node ) ;

void acpi_ns_install_node ( struct acpi_walk_state * walk_state , struct acpi_namespace_node * parent_node , struct acpi_namespace_node * node , acpi_object_type type ) ;

void acpi_ns_delete_children ( struct acpi_namespace_node * parent_node ) ;

void acpi_ns_delete_namespace_subtree ( struct acpi_namespace_node * parent_node ) ;

void acpi_ns_delete_namespace_by_owner ( acpi_owner_id owner_id ) ;

acpi_status acpi_ns_evaluate ( struct acpi_evaluate_info * info ) ;

void acpi_ns_exec_module_code_list ( void ) ;

acpi_status acpi_ns_build_external_path ( struct acpi_namespace_node * node , acpi_size size , char * name_buffer ) ;

char * acpi_ns_get_external_pathname ( struct acpi_namespace_node * node ) ;

acpi_size acpi_ns_get_pathname_length ( struct acpi_namespace_node * node ) ;

acpi_status acpi_ns_handle_to_pathname ( acpi_handle target_handle , struct acpi_buffer * buffer ) ;

void acpi_ns_report_error ( const char * module_name , u32 line_number , const char * internal_name , acpi_status lookup_status ) ;

void acpi_ns_report_method_error ( const char * module_name , u32 line_number , const char * message , struct acpi_namespace_node * prefix_node , const char * path , acpi_status method_status ) ;

void acpi_ns_print_node_pathname ( struct acpi_namespace_node * node , const char * message ) ;

u8 acpi_ns_valid_root_prefix ( char prefix ) ;

acpi_object_type acpi_ns_get_type ( struct acpi_namespace_node * node ) ;

u32 acpi_ns_local ( acpi_object_type type ) ;

void acpi_ns_get_internal_name_length ( struct acpi_namestring_info * info ) ;

acpi_status acpi_ns_build_internal_name ( struct acpi_namestring_info * info ) ;

acpi_status acpi_ns_internalize_name ( const char * external_name , char * * converted_name ) ;

acpi_status acpi_ns_externalize_name ( u32 internal_name_length , const char * internal_name , u32 * converted_name_length , char * * converted_name ) ;

struct acpi_namespace_node * acpi_ns_map_handle_to_node ( acpi_handle handle ) ;

acpi_handle acpi_ns_convert_entry_to_handle ( struct acpi_namespace_node * node ) ;

void acpi_ns_terminate ( void ) ;

u32 acpi_ns_opens_scope ( acpi_object_type type ) ;

acpi_status acpi_ns_get_node ( struct acpi_namespace_node * prefix_node , const char * pathname , u32 flags , struct acpi_namespace_node * * return_node ) ;

struct acpi_namespace_node * acpi_ns_get_parent_node ( struct acpi_namespace_node * node ) ;

struct acpi_namespace_node * acpi_ns_get_next_valid_node ( struct acpi_namespace_node * node ) ;

acpi_status acpi_get_handle ( acpi_handle parent , acpi_string pathname , acpi_handle * ret_handle ) ;

acpi_status acpi_get_name ( acpi_handle handle , u32 name_type , struct acpi_buffer * buffer ) ;

acpi_status acpi_get_object_info ( acpi_handle handle , struct acpi_device_info * * return_buffer ) ;

acpi_status acpi_install_method ( u8 * buffer ) ;

acpi_status acpi_ns_initialize_objects ( void ) ;

acpi_status acpi_ns_initialize_devices ( void ) ;

acpi_status acpi_ns_attach_object ( struct acpi_namespace_node * node , union acpi_operand_object * object , acpi_object_type type ) ;

void acpi_ns_detach_object ( struct acpi_namespace_node * node ) ;

union acpi_operand_object * acpi_ns_get_attached_object ( struct acpi_namespace_node * node ) ;

union acpi_operand_object * acpi_ns_get_secondary_object ( union acpi_operand_object * obj_desc ) ;

acpi_status acpi_ns_attach_data ( struct acpi_namespace_node * node , acpi_object_handler handler , void * data ) ;

acpi_status acpi_ns_detach_data ( struct acpi_namespace_node * node , acpi_object_handler handler ) ;

acpi_status acpi_ns_get_attached_data ( struct acpi_namespace_node * node , acpi_object_handler handler , void * * data ) ;

struct acpi_namespace_node * acpi_ns_get_next_node ( struct acpi_namespace_node * parent_node , struct acpi_namespace_node * child_node ) ;

struct acpi_namespace_node * acpi_ns_get_next_node_typed ( acpi_object_type type , struct acpi_namespace_node * parent_node , struct acpi_namespace_node * child_node ) ;

acpi_status acpi_ns_walk_namespace ( acpi_object_type type , acpi_handle start_node , u32 max_depth , u32 flags , acpi_walk_callback user_function , void * context , void * * return_value ) ;

acpi_status acpi_get_id ( acpi_handle handle , acpi_owner_id * ret_id ) ;

acpi_status acpi_get_type ( acpi_handle handle , acpi_object_type * ret_type ) ;

acpi_status acpi_get_parent ( acpi_handle handle , acpi_handle * ret_handle ) ;

acpi_status acpi_get_next_object ( acpi_object_type type , acpi_handle parent , acpi_handle child , acpi_handle * ret_handle ) ;

acpi_status acpi_ns_one_complete_parse ( u32 pass_number , u32 table_index , struct acpi_namespace_node * start_node ) ;

acpi_status acpi_ns_parse_table ( u32 table_index , struct acpi_namespace_node * start_node ) ;

enum acpi_return_package_types { ACPI_PTYPE1_FIXED = 1 , ACPI_PTYPE1_VAR = 2 , ACPI_PTYPE1_OPTION = 3 , ACPI_PTYPE2 = 4 , ACPI_PTYPE2_COUNT = 5 , ACPI_PTYPE2_PKG_COUNT = 6 , ACPI_PTYPE2_FIXED = 7 , ACPI_PTYPE2_MIN = 8 , ACPI_PTYPE2_REV_FIXED = 9 } ;

acpi_status acpi_ns_check_predefined_names ( struct acpi_namespace_node * node , u32 user_param_count , acpi_status return_status , union acpi_operand_object * * return_object_ptr ) ;

void acpi_ns_check_parameter_count ( char * pathname , struct acpi_namespace_node * node , u32 user_param_count , const union acpi_predefined_info * predefined ) ;

const union acpi_predefined_info * acpi_ns_check_for_predefined_name ( struct acpi_namespace_node * node ) ;

acpi_status acpi_ns_repair_object ( struct acpi_predefined_data * data , u32 expected_btypes , u32 package_index , union acpi_operand_object * * return_object_ptr ) ;

acpi_status acpi_ns_repair_package_list ( struct acpi_predefined_data * data , union acpi_operand_object * * obj_desc_ptr ) ;

u8 * acpi_ps_get_next_package_end ( struct acpi_parse_state * parser_state ) ;

char * acpi_ps_get_next_namestring ( struct acpi_parse_state * parser_state ) ;

acpi_status acpi_ps_get_next_namepath ( struct acpi_walk_state * walk_state , struct acpi_parse_state * parser_state , union acpi_parse_object * arg , u8 possible_method_call ) ;

void acpi_ps_get_next_simple_arg ( struct acpi_parse_state * parser_state , u32 arg_type , union acpi_parse_object * arg ) ;

acpi_status acpi_ps_get_next_arg ( struct acpi_walk_state * walk_state , struct acpi_parse_state * parser_state , u32 arg_type , union acpi_parse_object * * return_arg ) ;

u32 acpi_ps_get_opcode_size ( u32 opcode ) ;

u16 acpi_ps_peek_opcode ( struct acpi_parse_state * parser_state ) ;

acpi_status acpi_ps_complete_this_op ( struct acpi_walk_state * walk_state , union acpi_parse_object * op ) ;

acpi_status acpi_ps_next_parse_state ( struct acpi_walk_state * walk_state , union acpi_parse_object * op , acpi_status callback_status ) ;

acpi_status acpi_ps_parse_aml ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_ps_parse_loop ( struct acpi_walk_state * walk_state ) ;

union acpi_parse_object * acpi_ps_get_arg ( union acpi_parse_object * op , u32 argn ) ;

void acpi_ps_append_arg ( union acpi_parse_object * op , union acpi_parse_object * arg ) ;

void acpi_ps_delete_parse_tree ( union acpi_parse_object * subtree_root ) ;

const struct acpi_opcode_info * acpi_ps_get_opcode_info ( u16 opcode ) ;

char * acpi_ps_get_opcode_name ( u16 opcode ) ;

u8 acpi_ps_get_argument_count ( u32 op_type ) ;

union acpi_parse_object * acpi_ps_get_parent_scope ( struct acpi_parse_state * parser_state ) ;

u8 acpi_ps_has_completed_scope ( struct acpi_parse_state * parser_state ) ;

acpi_status acpi_ps_init_scope ( struct acpi_parse_state * parser_state , union acpi_parse_object * root_op ) ;

acpi_status acpi_ps_push_scope ( struct acpi_parse_state * parser_state , union acpi_parse_object * op , u32 remaining_args , u32 arg_count ) ;

void acpi_ps_pop_scope ( struct acpi_parse_state * parser_state , union acpi_parse_object * * op , u32 * arg_list , u32 * arg_count ) ;

void acpi_ps_cleanup_scope ( struct acpi_parse_state * parser_state ) ;

union acpi_parse_object * acpi_ps_create_scope_op ( void ) ;

void acpi_ps_init_op ( union acpi_parse_object * op , u16 opcode ) ;

union acpi_parse_object * acpi_ps_alloc_op ( u16 opcode ) ;

void acpi_ps_free_op ( union acpi_parse_object * op ) ;

u8 acpi_ps_is_leading_char ( u32 c ) ;

u8 acpi_ps_is_prefix_char ( u32 c ) ;

void acpi_ps_set_name ( union acpi_parse_object * op , u32 name ) ;

acpi_status acpi_debug_trace ( char * name , u32 debug_level , u32 debug_layer , u32 flags ) ;

acpi_status acpi_ps_execute_method ( struct acpi_evaluate_info * info ) ;


typedef const struct acpi_rsconvert_info { u8 opcode ; u8 resource_offset ; u8 aml_offset ; u8 value ; } acpi_rsconvert_info ;


typedef const struct acpi_rsdump_info { u8 opcode ; u8 offset ; char * name ; const char * * pointer ; } acpi_rsdump_info ;

struct acpi_vendor_walk_info { struct acpi_vendor_uuid * uuid ; struct acpi_buffer * buffer ; acpi_status status ; } ;

u8 acpi_rs_get_address_common ( struct acpi_resource * resource , union aml_resource * aml ) ;

void acpi_rs_set_address_common ( union aml_resource * aml , struct acpi_resource * resource ) ;

acpi_status acpi_rs_create_resource_list ( union acpi_operand_object * aml_buffer , struct acpi_buffer * output_buffer ) ;

acpi_status acpi_rs_create_pci_routing_table ( union acpi_operand_object * package_object , struct acpi_buffer * output_buffer ) ;

acpi_status acpi_rs_create_aml_resources ( struct acpi_resource * linked_list_buffer , struct acpi_buffer * output_buffer ) ;

acpi_status acpi_rs_convert_aml_to_resources ( u8 * aml , u32 length , u32 offset , u8 resource_index , void * * context ) ;

acpi_status acpi_rs_convert_resources_to_aml ( struct acpi_resource * resource , acpi_size aml_size_needed , u8 * output_buffer ) ;

acpi_status acpi_rs_convert_aml_to_resource ( struct acpi_resource * resource , union aml_resource * aml , struct acpi_rsconvert_info * info ) ;

acpi_status acpi_rs_convert_resource_to_aml ( struct acpi_resource * resource , union aml_resource * aml , struct acpi_rsconvert_info * info ) ;

acpi_status acpi_get_irq_routing_table ( acpi_handle device_handle , struct acpi_buffer * ret_buffer ) ;

acpi_status acpi_get_current_resources ( acpi_handle device_handle , struct acpi_buffer * ret_buffer ) ;

acpi_status acpi_set_current_resources ( acpi_handle device_handle , struct acpi_buffer * in_buffer ) ;

acpi_status acpi_resource_to_address64 ( struct acpi_resource * resource , struct acpi_resource_address64 * out ) ;

acpi_status acpi_get_vendor_resource ( acpi_handle device_handle , char * name , struct acpi_vendor_uuid * uuid , struct acpi_buffer * ret_buffer ) ;

acpi_status acpi_walk_resources ( acpi_handle device_handle , char * name , acpi_walk_resource_callback user_function , void * context ) ;

acpi_status acpi_rs_get_aml_length ( struct acpi_resource * resource , acpi_size * size_needed ) ;

acpi_status acpi_rs_get_list_length ( u8 * aml_buffer , u32 aml_buffer_length , acpi_size * size_needed ) ;

acpi_status acpi_rs_get_pci_routing_table_length ( union acpi_operand_object * package_object , acpi_size * buffer_size_needed ) ;

u8 acpi_rs_decode_bitmask ( u16 mask , u8 * list ) ;

u16 acpi_rs_encode_bitmask ( u8 * list , u8 count ) ;

void acpi_rs_move_data ( void * destination , void * source , u16 item_count , u8 move_type ) ;

void acpi_rs_set_resource_length ( acpi_rsdesc_size total_length , union aml_resource * aml ) ;

void acpi_rs_set_resource_header ( u8 descriptor_type , acpi_rsdesc_size total_length , union aml_resource * aml ) ;

acpi_rs_length acpi_rs_get_resource_source ( acpi_rs_length resource_length , acpi_rs_length minimum_length , struct acpi_resource_source * resource_source , union aml_resource * aml , char * string_ptr ) ;

acpi_rsdesc_size acpi_rs_set_resource_source ( union aml_resource * aml , acpi_rs_length minimum_length , struct acpi_resource_source * resource_source ) ;

acpi_status acpi_rs_get_prt_method_data ( struct acpi_namespace_node * node , struct acpi_buffer * ret_buffer ) ;

acpi_status acpi_rs_get_crs_method_data ( struct acpi_namespace_node * node , struct acpi_buffer * ret_buffer ) ;

acpi_status acpi_rs_get_method_data ( acpi_handle handle , char * path , struct acpi_buffer * ret_buffer ) ;

acpi_status acpi_rs_set_srs_method_data ( struct acpi_namespace_node * node , struct acpi_buffer * in_buffer ) ;

acpi_status acpi_allocate_root_table ( u32 initial_table_count ) ;

acpi_status __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_initialize_tables ( struct acpi_table_desc * initial_table_array , u32 initial_table_count , u8 allow_resize ) ;

acpi_status acpi_reallocate_root_table ( void ) ;

acpi_status acpi_load_table ( struct acpi_table_header * table_ptr ) ;

acpi_status acpi_get_table_header ( char * signature , u32 instance , struct acpi_table_header * out_table_header ) ;

acpi_status acpi_unload_table_id ( acpi_owner_id id ) ;

acpi_status acpi_get_table_with_size ( char * signature , u32 instance , struct acpi_table_header * * out_table , acpi_size * tbl_size ) ;

acpi_status acpi_get_table ( char * signature , u32 instance , struct acpi_table_header * * out_table ) ;

acpi_status acpi_get_table_by_index ( u32 table_index , struct acpi_table_header * * table ) ;

acpi_status acpi_load_tables ( void ) ;

acpi_status acpi_install_table_handler ( acpi_tbl_handler handler , void * context ) ;

acpi_status acpi_remove_table_handler ( acpi_tbl_handler handler ) ;

acpi_status acpi_tb_verify_table ( struct acpi_table_desc * table_desc ) ;

acpi_status acpi_tb_add_table ( struct acpi_table_desc * table_desc , u32 * table_index ) ;

acpi_status acpi_tb_resize_root_table_list ( void ) ;

acpi_status acpi_tb_store_table ( acpi_physical_address address , struct acpi_table_header * table , u32 length , u8 flags , u32 * table_index ) ;

void acpi_tb_delete_table ( struct acpi_table_desc * table_desc ) ;

void acpi_tb_terminate ( void ) ;

acpi_status acpi_tb_delete_namespace_by_owner ( u32 table_index ) ;

acpi_status acpi_tb_allocate_owner_id ( u32 table_index ) ;

acpi_status acpi_tb_release_owner_id ( u32 table_index ) ;

acpi_status acpi_tb_get_owner_id ( u32 table_index , acpi_owner_id * owner_id ) ;

u8 acpi_tb_is_table_loaded ( u32 table_index ) ;

void acpi_tb_set_table_loaded_flag ( u32 table_index , u8 is_loaded ) ;

acpi_status acpi_tb_initialize_facs ( void ) ;

u8 acpi_tb_tables_loaded ( void ) ;

void acpi_tb_print_table_header ( acpi_physical_address address , struct acpi_table_header * header ) ;

acpi_status acpi_tb_verify_checksum ( struct acpi_table_header * table , u32 length ) ;

u8 acpi_tb_checksum ( u8 * buffer , u32 length ) ;

void acpi_tb_install_table ( acpi_physical_address address , char * signature , u32 table_index ) ;

acpi_status __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_tb_parse_root_table ( acpi_physical_address rsdp_address ) ;

acpi_status acpi_tb_find_table ( char * signature , char * oem_id , char * oem_table_id , u32 * table_index ) ;


typedef struct acpi_fadt_info { char * name ; u8 address64 ; u8 address32 ; u8 length ; u8 default_length ; u8 type ; } acpi_fadt_info ;


typedef struct acpi_fadt_pm_info { struct acpi_generic_address * target ; u8 source ; u8 register_num ; } acpi_fadt_pm_info ;

void acpi_tb_parse_fadt ( u32 table_index ) ;

void acpi_tb_create_local_fadt ( struct acpi_table_header * table , u32 length ) ;

acpi_status acpi_find_root_pointer ( acpi_size * table_address ) ;

acpi_status acpi_ut_create_caches ( void ) ;

acpi_status acpi_ut_delete_caches ( void ) ;

acpi_status acpi_ut_validate_buffer ( struct acpi_buffer * buffer ) ;

acpi_status acpi_ut_initialize_buffer ( struct acpi_buffer * buffer , acpi_size required_length ) ;

void acpi_ut_dump_buffer2 ( u8 * buffer , u32 count , u32 display ) ;

void acpi_ut_dump_buffer ( u8 * buffer , u32 count , u32 display , u32 component_id ) ;

acpi_status acpi_ut_osi_implementation ( struct acpi_walk_state * walk_state ) ;

acpi_status acpi_osi_invalidate ( char * interface ) ;

acpi_status acpi_ut_evaluate_object ( struct acpi_namespace_node * prefix_node , char * path , u32 expected_return_btypes , union acpi_operand_object * * return_desc ) ;

acpi_status acpi_ut_evaluate_numeric_object ( char * object_name , struct acpi_namespace_node * device_node , acpi_integer * value ) ;

acpi_status acpi_ut_execute_STA ( struct acpi_namespace_node * device_node , u32 * flags ) ;

acpi_status acpi_ut_execute_power_methods ( struct acpi_namespace_node * device_node , const char * * method_names , u8 method_count , u8 * out_values ) ;

void acpi_ut_subsystem_shutdown ( void ) ;

const char * acpi_ut_validate_exception ( acpi_status status ) ;

u8 acpi_ut_is_pci_root_bridge ( char * id ) ;

u8 acpi_ut_is_aml_table ( struct acpi_table_header * table ) ;

acpi_status acpi_ut_allocate_owner_id ( acpi_owner_id * owner_id ) ;

void acpi_ut_release_owner_id ( acpi_owner_id * owner_id_ptr ) ;

void acpi_ut_strupr ( char * src_string ) ;

void acpi_ut_print_string ( char * string , u8 max_length ) ;

u32 acpi_ut_dword_byte_swap ( u32 value ) ;

void acpi_ut_set_integer_width ( u8 revision ) ;

u8 acpi_ut_valid_acpi_char ( char character , u32 position ) ;

u8 acpi_ut_valid_acpi_name ( u32 name ) ;

acpi_name acpi_ut_repair_name ( char * name ) ;

acpi_status acpi_ut_strtoul64 ( char * string , u32 base , acpi_integer * ret_integer ) ;

acpi_status acpi_ut_create_update_state_and_push ( union acpi_operand_object * object , u16 action , union acpi_generic_state * * state_list ) ;

acpi_status acpi_ut_walk_package_tree ( union acpi_operand_object * source_object , void * target_object , acpi_pkg_callback walk_callback , void * context ) ;

void acpi_error ( const char * module_name , u32 line_number , const char * format , ... ) ;

void acpi_exception ( const char * module_name , u32 line_number , acpi_status status , const char * format , ... ) ;

void acpi_warning ( const char * module_name , u32 line_number , const char * format , ... ) ;

void acpi_info ( const char * module_name , u32 line_number , const char * format , ... ) ;

void acpi_ut_predefined_warning ( const char * module_name , u32 line_number , char * pathname , u8 node_flags , const char * format , ... ) ;

acpi_status __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) acpi_initialize_subsystem ( void ) ;

acpi_status acpi_enable_subsystem ( u32 flags ) ;

acpi_status acpi_initialize_objects ( u32 flags ) ;

acpi_status acpi_terminate ( void ) ;

acpi_status acpi_purge_cached_objects ( void ) ;

acpi_status acpi_ut_copy_iobject_to_eobject ( union acpi_operand_object * internal_object , struct acpi_buffer * ret_buffer ) ;

acpi_status acpi_ut_copy_eobject_to_iobject ( union acpi_object * external_object , union acpi_operand_object * * internal_object ) ;

acpi_status acpi_ut_copy_iobject_to_iobject ( union acpi_operand_object * source_desc , union acpi_operand_object * * dest_desc , struct acpi_walk_state * walk_state ) ;

void acpi_ut_delete_internal_object_list ( union acpi_operand_object * * obj_list ) ;

acpi_status acpi_ut_update_object_reference ( union acpi_operand_object * object , u16 action ) ;

void acpi_ut_add_reference ( union acpi_operand_object * object ) ;

void acpi_ut_remove_reference ( union acpi_operand_object * object ) ;

const char * acpi_format_exception ( acpi_status status ) ;

char acpi_ut_hex_to_ascii_char ( acpi_integer integer , u32 position ) ;

char * acpi_ut_get_region_name ( u8 space_id ) ;

char * acpi_ut_get_event_name ( u32 event_id ) ;

char * acpi_ut_get_type_name ( acpi_object_type type ) ;

char * acpi_ut_get_object_type_name ( union acpi_operand_object * obj_desc ) ;

char * acpi_ut_get_node_name ( void * object ) ;

char * acpi_ut_get_descriptor_name ( void * object ) ;

const char * acpi_ut_get_reference_name ( union acpi_operand_object * object ) ;

u8 acpi_ut_valid_object_type ( acpi_object_type type ) ;

acpi_status acpi_ut_init_globals ( void ) ;

acpi_status acpi_ut_short_divide ( acpi_integer in_dividend , u32 divisor , acpi_integer * out_quotient , u32 * out_remainder ) ;

acpi_status acpi_ut_divide ( acpi_integer in_dividend , acpi_integer in_divisor , acpi_integer * out_quotient , acpi_integer * out_remainder ) ;

union acpi_operand_object * acpi_ut_create_internal_object_dbg ( const char * module_name , u32 line_number , u32 component_id , acpi_object_type type ) ;

union acpi_operand_object * acpi_ut_create_package_object ( u32 count ) ;

union acpi_operand_object * acpi_ut_create_buffer_object ( acpi_size buffer_size ) ;

union acpi_operand_object * acpi_ut_create_string_object ( acpi_size string_size ) ;

u8 acpi_ut_valid_internal_object ( void * object ) ;

void * acpi_ut_allocate_object_desc_dbg ( const char * module_name , u32 line_number , u32 component_id ) ;

void acpi_ut_delete_object_desc ( union acpi_operand_object * object ) ;

acpi_status acpi_ut_get_object_size ( union acpi_operand_object * internal_object , acpi_size * obj_length ) ;

acpi_status acpi_ut_create_pkg_state_and_push ( void * internal_object , void * external_object , u16 index , union acpi_generic_state * * state_list ) ;

void acpi_ut_push_generic_state ( union acpi_generic_state * * list_head , union acpi_generic_state * state ) ;

union acpi_generic_state * acpi_ut_pop_generic_state ( union acpi_generic_state * * list_head ) ;

union acpi_generic_state * acpi_ut_create_generic_state ( void ) ;

struct acpi_thread_state * acpi_ut_create_thread_state ( void ) ;

union acpi_generic_state * acpi_ut_create_update_state ( union acpi_operand_object * object , u16 action ) ;

union acpi_generic_state * acpi_ut_create_pkg_state ( void * internal_object , void * external_object , u16 index ) ;

union acpi_generic_state * acpi_ut_create_control_state ( void ) ;

void acpi_ut_delete_generic_state ( union acpi_generic_state * state ) ;

acpi_status acpi_ut_mutex_initialize ( void ) ;

void acpi_ut_mutex_terminate ( void ) ;

acpi_status acpi_ut_acquire_mutex ( acpi_mutex_handle mutex_id ) ;

acpi_status acpi_ut_release_mutex ( acpi_mutex_handle mutex_id ) ;

acpi_status acpi_ut_walk_aml_resources ( u8 * aml , acpi_size aml_length , acpi_walk_aml_callback user_function , void * * context ) ;

acpi_status acpi_ut_validate_resource ( void * aml , u8 * return_index ) ;

u8 acpi_ut_get_resource_type ( void * aml ) ;

u16 acpi_ut_get_resource_length ( void * aml ) ;

u8 acpi_ut_get_resource_header_length ( void * aml ) ;

u32 acpi_ut_get_descriptor_length ( void * aml ) ;

acpi_status acpi_ut_get_resource_end_tag ( union acpi_operand_object * obj_desc , u8 * * end_tag ) ;

acpi_status acpi_ut_create_rw_lock ( struct acpi_rw_lock * lock ) ;

void acpi_ut_delete_rw_lock ( struct acpi_rw_lock * lock ) ;

acpi_status acpi_ut_acquire_read_lock ( struct acpi_rw_lock * lock ) ;

acpi_status acpi_ut_release_read_lock ( struct acpi_rw_lock * lock ) ;

acpi_status acpi_ut_acquire_write_lock ( struct acpi_rw_lock * lock ) ;

void acpi_ut_release_write_lock ( struct acpi_rw_lock * lock ) ;

acpi_status acpi_ut_execute_HID ( struct acpi_namespace_node * device_node , struct acpica_device_id * * return_id ) ;

acpi_status acpi_ut_execute_UID ( struct acpi_namespace_node * device_node , struct acpica_device_id * * return_id ) ;

acpi_status acpi_ut_execute_CID ( struct acpi_namespace_node * device_node , struct acpica_device_id_list * * return_cid_list ) ;

enum led_brightness { LED_OFF = 0 , LED_HALF = 127 , LED_FULL = 255 , } ;

struct led_classdev { const char * name ; int brightness ; int max_brightness ; int flags ; void ( * brightness_set ) ( struct led_classdev * led_cdev , enum led_brightness brightness ) ; enum led_brightness ( * brightness_get ) ( struct led_classdev * led_cdev ) ; int ( * blink_set ) ( struct led_classdev * led_cdev , unsigned long * delay_on , unsigned long * delay_off ) ; struct device * dev ; struct list_head node ; const char * default_trigger ; struct rw_semaphore trigger_lock ; struct led_trigger * trigger ; struct list_head trig_list ; void * trigger_data ; } ;

struct led_trigger { const char * name ; void ( * activate ) ( struct led_classdev * led_cdev ) ; void ( * deactivate ) ( struct led_classdev * led_cdev ) ; rwlock_t leddev_list_lock ; struct list_head led_cdevs ; struct list_head next_trig ; } ;

struct led_info { const char * name ; const char * default_trigger ; int flags ; } ;

struct led_platform_data { int num_leds ; struct led_info * leds ; } ;

struct gpio_led { const char * name ; const char * default_trigger ; unsigned gpio ; unsigned active_low : 1 ; unsigned retain_state_suspended : 1 ; unsigned default_state : 2 ; } ;

struct gpio_led_platform_data { int num_leds ; struct gpio_led * leds ; int ( * gpio_blink_set ) ( unsigned gpio , unsigned long * delay_on , unsigned long * delay_off ) ; } ;

enum { POWER_SUPPLY_STATUS_UNKNOWN = 0 , POWER_SUPPLY_STATUS_CHARGING , POWER_SUPPLY_STATUS_DISCHARGING , POWER_SUPPLY_STATUS_NOT_CHARGING , POWER_SUPPLY_STATUS_FULL , } ;
enum { POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0 , POWER_SUPPLY_CHARGE_TYPE_NONE , POWER_SUPPLY_CHARGE_TYPE_TRICKLE , POWER_SUPPLY_CHARGE_TYPE_FAST , } ;
enum { POWER_SUPPLY_HEALTH_UNKNOWN = 0 , POWER_SUPPLY_HEALTH_GOOD , POWER_SUPPLY_HEALTH_OVERHEAT , POWER_SUPPLY_HEALTH_DEAD , POWER_SUPPLY_HEALTH_OVERVOLTAGE , POWER_SUPPLY_HEALTH_UNSPEC_FAILURE , POWER_SUPPLY_HEALTH_COLD , } ;
enum { POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0 , POWER_SUPPLY_TECHNOLOGY_NiMH , POWER_SUPPLY_TECHNOLOGY_LION , POWER_SUPPLY_TECHNOLOGY_LIPO , POWER_SUPPLY_TECHNOLOGY_LiFe , POWER_SUPPLY_TECHNOLOGY_NiCd , POWER_SUPPLY_TECHNOLOGY_LiMn , } ;
enum { POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0 , POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL , POWER_SUPPLY_CAPACITY_LEVEL_LOW , POWER_SUPPLY_CAPACITY_LEVEL_NORMAL , POWER_SUPPLY_CAPACITY_LEVEL_HIGH , POWER_SUPPLY_CAPACITY_LEVEL_FULL , } ;
enum power_supply_property { POWER_SUPPLY_PROP_STATUS = 0 , POWER_SUPPLY_PROP_CHARGE_TYPE , POWER_SUPPLY_PROP_HEALTH , POWER_SUPPLY_PROP_PRESENT , POWER_SUPPLY_PROP_ONLINE , POWER_SUPPLY_PROP_TECHNOLOGY , POWER_SUPPLY_PROP_VOLTAGE_MAX , POWER_SUPPLY_PROP_VOLTAGE_MIN , POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN , POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN , POWER_SUPPLY_PROP_VOLTAGE_NOW , POWER_SUPPLY_PROP_VOLTAGE_AVG , POWER_SUPPLY_PROP_CURRENT_NOW , POWER_SUPPLY_PROP_CURRENT_AVG , POWER_SUPPLY_PROP_POWER_NOW , POWER_SUPPLY_PROP_POWER_AVG , POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN , POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN , POWER_SUPPLY_PROP_CHARGE_FULL , POWER_SUPPLY_PROP_CHARGE_EMPTY , POWER_SUPPLY_PROP_CHARGE_NOW , POWER_SUPPLY_PROP_CHARGE_AVG , POWER_SUPPLY_PROP_CHARGE_COUNTER , POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN , POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN , POWER_SUPPLY_PROP_ENERGY_FULL , POWER_SUPPLY_PROP_ENERGY_EMPTY , POWER_SUPPLY_PROP_ENERGY_NOW , POWER_SUPPLY_PROP_ENERGY_AVG , POWER_SUPPLY_PROP_CAPACITY , POWER_SUPPLY_PROP_CAPACITY_LEVEL , POWER_SUPPLY_PROP_TEMP , POWER_SUPPLY_PROP_TEMP_AMBIENT , POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW , POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG , POWER_SUPPLY_PROP_TIME_TO_FULL_NOW , POWER_SUPPLY_PROP_TIME_TO_FULL_AVG , POWER_SUPPLY_PROP_MODEL_NAME , POWER_SUPPLY_PROP_MANUFACTURER , POWER_SUPPLY_PROP_SERIAL_NUMBER , } ;

enum power_supply_type { POWER_SUPPLY_TYPE_BATTERY = 0 , POWER_SUPPLY_TYPE_UPS , POWER_SUPPLY_TYPE_MAINS , POWER_SUPPLY_TYPE_USB , } ;

union power_supply_propval { int intval ; const char * strval ; } ;

struct power_supply { const char * name ; enum power_supply_type type ; enum power_supply_property * properties ; size_t num_properties ; char * * supplied_to ; size_t num_supplicants ; int ( * get_property ) ( struct power_supply * psy , enum power_supply_property psp , union power_supply_propval * val ) ; void ( * external_power_changed ) ( struct power_supply * psy ) ; void ( * set_charged ) ( struct power_supply * psy ) ; int use_for_apm ; struct device * dev ; struct work_struct changed_work ; struct led_trigger * charging_full_trig ; char * charging_full_trig_name ; struct led_trigger * charging_trig ; char * charging_trig_name ; struct led_trigger * full_trig ; char * full_trig_name ; struct led_trigger * online_trig ; char * online_trig_name ; } ;

struct power_supply_info { const char * name ; int technology ; int voltage_max_design ; int voltage_min_design ; int charge_full_design ; int charge_empty_design ; int energy_full_design ; int energy_empty_design ; int use_for_apm ; } ;

struct acpi_ac { struct power_supply charger ; struct acpi_device * device ; unsigned long long state ; } ;

struct acpi_button { unsigned int type ; struct input_dev * input ; char phys [ 32 ] ; unsigned long pushed ; } ;

int acpi_lid_notifier_register ( struct notifier_block * nb ) ;

int acpi_lid_notifier_unregister ( struct notifier_block * nb ) ;

int acpi_lid_open ( void ) ;

struct acpi_pci_slot { acpi_handle root_handle ; struct pci_slot * pci_slot ; struct list_head list ; } ;

struct callback_args { acpi_walk_callback user_function ; struct pci_bus * pci_bus ; acpi_handle root_handle ; } ;

struct acpi_container { acpi_handle handle ; unsigned long sun ; int state ; } ;

struct acpi_thermal_state { u8 critical : 1 ; u8 hot : 1 ; u8 passive : 1 ; u8 active : 1 ; u8 reserved : 4 ; int active_index ; } ;

struct acpi_thermal_state_flags { u8 valid : 1 ; u8 enabled : 1 ; u8 reserved : 6 ; } ;

struct acpi_thermal_critical { struct acpi_thermal_state_flags flags ; unsigned long temperature ; } ;

struct acpi_thermal_hot { struct acpi_thermal_state_flags flags ; unsigned long temperature ; } ;

struct acpi_thermal_passive { struct acpi_thermal_state_flags flags ; unsigned long temperature ; unsigned long tc1 ; unsigned long tc2 ; unsigned long tsp ; struct acpi_handle_list devices ; } ;

struct acpi_thermal_active { struct acpi_thermal_state_flags flags ; unsigned long temperature ; struct acpi_handle_list devices ; } ;

struct acpi_thermal_trips { struct acpi_thermal_critical critical ; struct acpi_thermal_hot hot ; struct acpi_thermal_passive passive ; struct acpi_thermal_active active [ 10 ] ; } ;

struct acpi_thermal_flags { u8 cooling_mode : 1 ; u8 devices : 1 ; u8 reserved : 6 ; } ;

struct acpi_thermal { struct acpi_device * device ; acpi_bus_id name ; unsigned long temperature ; unsigned long last_temperature ; unsigned long polling_frequency ; volatile u8 zombie ; struct acpi_thermal_flags flags ; struct acpi_thermal_state state ; struct acpi_thermal_trips trips ; struct acpi_handle_list devices ; struct thermal_zone_device * thermal_zone ; int tz_enabled ; int kelvin_offset ; struct mutex lock ; } ;

typedef int ( * cb ) ( struct thermal_zone_device * , int , struct thermal_cooling_device * ) ;
enum acpi_battery_files { info_tag = 0 , state_tag , alarm_tag , ACPI_BATTERY_NUMFILES , } ;

struct acpi_battery { struct mutex lock ; struct power_supply bat ; struct acpi_device * device ; unsigned long update_time ; int rate_now ; int capacity_now ; int voltage_now ; int design_capacity ; int full_charge_capacity ; int technology ; int design_voltage ; int design_capacity_warning ; int design_capacity_low ; int capacity_granularity_1 ; int capacity_granularity_2 ; int alarm ; char model_number [ 32 ] ; char serial_number [ 32 ] ; char type [ 32 ] ; char oem_info [ 32 ] ; int state ; int power_unit ; u8 alarm_present ; long quirks ; } ;

struct acpi_offsets { size_t offset ; u8 mode ; } ;

typedef int ( * print_func ) ( struct seq_file * seq , int result ) ;

struct acpi_smb_hc ;

enum acpi_smb_protocol { SMBUS_WRITE_QUICK = 2 , SMBUS_READ_QUICK = 3 , SMBUS_SEND_BYTE = 4 , SMBUS_RECEIVE_BYTE = 5 , SMBUS_WRITE_BYTE = 6 , SMBUS_READ_BYTE = 7 , SMBUS_WRITE_WORD = 8 , SMBUS_READ_WORD = 9 , SMBUS_WRITE_BLOCK = 0xa , SMBUS_READ_BLOCK = 0xb , SMBUS_PROCESS_CALL = 0xc , SMBUS_BLOCK_PROCESS_CALL = 0xd , } ;

enum acpi_sbs_device_addr { ACPI_SBS_CHARGER = 0x9 , ACPI_SBS_MANAGER = 0xa , ACPI_SBS_BATTERY = 0xb , } ;

typedef void ( * smbus_alarm_callback ) ( void * context ) ;
struct acpi_smb_hc { struct acpi_ec * ec ; struct mutex lock ; wait_queue_head_t wait ; u8 offset ; u8 query_bit ; smbus_alarm_callback callback ; void * context ; } ;
union acpi_smb_status { u8 raw ; struct { u8 status : 5 ; u8 reserved : 1 ; u8 alarm : 1 ; u8 done : 1 ; } fields ; } ;

enum acpi_smb_status_codes { SMBUS_OK = 0 , SMBUS_UNKNOWN_FAILURE = 0x07 , SMBUS_DEVICE_ADDRESS_NACK = 0x10 , SMBUS_DEVICE_ERROR = 0x11 , SMBUS_DEVICE_COMMAND_ACCESS_DENIED = 0x12 , SMBUS_UNKNOWN_ERROR = 0x13 , SMBUS_DEVICE_ACCESS_DENIED = 0x17 , SMBUS_TIMEOUT = 0x18 , SMBUS_HOST_UNSUPPORTED_PROTOCOL = 0x19 , SMBUS_BUSY = 0x1a , SMBUS_PEC_ERROR = 0x1f , } ;

enum acpi_smb_offset { ACPI_SMB_PROTOCOL = 0 , ACPI_SMB_STATUS = 1 , ACPI_SMB_ADDRESS = 2 , ACPI_SMB_COMMAND = 3 , ACPI_SMB_DATA = 4 , ACPI_SMB_BLOCK_COUNT = 0x24 , ACPI_SMB_ALARM_ADDRESS = 0x25 , ACPI_SMB_ALARM_DATA = 0x26 , } ;

int acpi_smbus_read ( struct acpi_smb_hc * hc , u8 protocol , u8 address , u8 command , u8 * data ) ;

int acpi_smbus_write ( struct acpi_smb_hc * hc , u8 protocol , u8 address , u8 command , u8 * data , u8 length ) ;

int acpi_smbus_register_callback ( struct acpi_smb_hc * hc , smbus_alarm_callback callback , void * context ) ;

int acpi_smbus_unregister_callback ( struct acpi_smb_hc * hc ) ;

struct acpi_battery { struct power_supply bat ; struct acpi_sbs * sbs ; struct proc_dir_entry * proc_entry ; unsigned long update_time ; char name [ 8 ] ; char manufacturer_name [ 32 ] ; char device_name [ 32 ] ; char device_chemistry [ 32 ] ; u16 alarm_capacity ; u16 full_charge_capacity ; u16 design_capacity ; u16 design_voltage ; u16 serial_number ; u16 cycle_count ; u16 temp_now ; u16 voltage_now ; s16 rate_now ; s16 rate_avg ; u16 capacity_now ; u16 state_of_charge ; u16 state ; u16 mode ; u16 spec ; u8 id ; u8 present : 1 ; u8 have_sysfs_alarm : 1 ; } ;
struct acpi_sbs { struct power_supply charger ; struct acpi_device * device ; struct acpi_smb_hc * hc ; struct mutex lock ; struct proc_dir_entry * charger_entry ; struct acpi_battery battery [ 4 ] ; u8 batteries_supported : 4 ; u8 manager_present : 1 ; u8 charger_present : 1 ; } ;

struct acpi_battery_reader { u8 command ; u8 mode ; size_t offset ; } ;

struct output_device ;

struct output_properties { int ( * set_state ) ( struct output_device * ) ; int ( * get_status ) ( struct output_device * ) ; } ;

struct output_device { int request_state ; struct output_properties * props ; struct device dev ; } ;
struct acpi_video_bus_flags { u8 multihead : 1 ; u8 rom : 1 ; u8 post : 1 ; u8 reserved : 5 ; } ;

struct acpi_video_bus_cap { u8 _DOS : 1 ; u8 _DOD : 1 ; u8 _ROM : 1 ; u8 _GPD : 1 ; u8 _SPD : 1 ; u8 _VPO : 1 ; u8 reserved : 2 ; } ;

struct acpi_video_device_attrib { u32 display_index : 4 ; u32 display_port_attachment : 4 ; u32 display_type : 4 ; u32 vendor_specific : 4 ; u32 bios_can_detect : 1 ; u32 depend_on_vga : 1 ; u32 pipe_id : 3 ; u32 reserved : 10 ; u32 device_id_scheme : 1 ; } ;

struct acpi_video_enumerated_device { union { u32 int_val ; struct acpi_video_device_attrib attrib ; } value ; struct acpi_video_device * bind_info ; } ;

struct acpi_video_bus { struct acpi_device * device ; u8 dos_setting ; struct acpi_video_enumerated_device * attached_array ; u8 attached_count ; struct acpi_video_bus_cap cap ; struct acpi_video_bus_flags flags ; struct list_head video_device_list ; struct mutex device_list_lock ; struct proc_dir_entry * dir ; struct input_dev * input ; char phys [ 32 ] ; } ;

struct acpi_video_device_flags { u8 crt : 1 ; u8 lcd : 1 ; u8 tvout : 1 ; u8 dvi : 1 ; u8 bios : 1 ; u8 unknown : 1 ; u8 reserved : 2 ; } ;

struct acpi_video_device_cap { u8 _ADR : 1 ; u8 _BCL : 1 ; u8 _BCM : 1 ; u8 _BQC : 1 ; u8 _BCQ : 1 ; u8 _DDC : 1 ; u8 _DCS : 1 ; u8 _DGS : 1 ; u8 _DSS : 1 ; } ;

struct acpi_video_brightness_flags { u8 _BCL_no_ac_battery_levels : 1 ; u8 _BCL_reversed : 1 ; u8 _BCL_use_index : 1 ; u8 _BCM_use_index : 1 ; u8 _BQC_use_index : 1 ; } ;

struct acpi_video_device_brightness { int curr ; int count ; int * levels ; struct acpi_video_brightness_flags flags ; } ;

struct acpi_video_device { unsigned long device_id ; struct acpi_video_device_flags flags ; struct acpi_video_device_cap cap ; struct list_head entry ; struct acpi_video_bus * video ; struct acpi_device * dev ; struct acpi_video_device_brightness * brightness ; struct backlight_device * backlight ; struct thermal_cooling_device * cooling_dev ; struct output_device * output_dev ; } ;

int acpi_video_register ( void ) ;

void acpi_video_unregister ( void ) ;

struct scsi_target ;

struct scsi_host_cmd_pool ;

struct scsi_transport_template ;

struct blk_queue_tags ;

struct scsi_host_template { struct module * module ; const char * name ; int ( * detect ) ( struct scsi_host_template * ) ; int ( * release ) ( struct Scsi_Host * ) ; const char * ( * info ) ( struct Scsi_Host * ) ; int ( * ioctl ) ( struct scsi_device * dev , int cmd , void * arg ) ; int ( * compat_ioctl ) ( struct scsi_device * dev , int cmd , void * arg ) ; int ( * queuecommand ) ( struct scsi_cmnd * , void ( * done ) ( struct scsi_cmnd * ) ) ; int ( * transfer_response ) ( struct scsi_cmnd * , void ( * done ) ( struct scsi_cmnd * ) ) ; int ( * eh_abort_handler ) ( struct scsi_cmnd * ) ; int ( * eh_device_reset_handler ) ( struct scsi_cmnd * ) ; int ( * eh_target_reset_handler ) ( struct scsi_cmnd * ) ; int ( * eh_bus_reset_handler ) ( struct scsi_cmnd * ) ; int ( * eh_host_reset_handler ) ( struct scsi_cmnd * ) ; int ( * slave_alloc ) ( struct scsi_device * ) ; int ( * slave_configure ) ( struct scsi_device * ) ; void ( * slave_destroy ) ( struct scsi_device * ) ; int ( * target_alloc ) ( struct scsi_target * ) ; void ( * target_destroy ) ( struct scsi_target * ) ; int ( * scan_finished ) ( struct Scsi_Host * , unsigned long ) ; void ( * scan_start ) ( struct Scsi_Host * ) ; int ( * change_queue_depth ) ( struct scsi_device * , int ) ; int ( * change_queue_type ) ( struct scsi_device * , int ) ; int ( * bios_param ) ( struct scsi_device * , struct block_device * , sector_t , int [ ] ) ; int ( * proc_info ) ( struct Scsi_Host * , char * , char * * , off_t , int , int ) ; enum blk_eh_timer_return ( * eh_timed_out ) ( struct scsi_cmnd * ) ; const char * proc_name ; struct proc_dir_entry * proc_dir ; int can_queue ; int this_id ; unsigned short sg_tablesize ; unsigned short max_sectors ; unsigned long dma_boundary ; short cmd_per_lun ; unsigned char present ; unsigned supported_mode : 2 ; unsigned unchecked_isa_dma : 1 ; unsigned use_clustering : 1 ; unsigned emulated : 1 ; unsigned skip_settle_delay : 1 ; unsigned ordered_tag : 1 ; unsigned int max_host_blocked ; struct device_attribute * * shost_attrs ; struct device_attribute * * sdev_attrs ; struct list_head legacy_hosts ; u64 vendor_id ; } ;

enum scsi_host_state { SHOST_CREATED = 1 , SHOST_RUNNING , SHOST_CANCEL , SHOST_DEL , SHOST_RECOVERY , SHOST_CANCEL_RECOVERY , SHOST_DEL_RECOVERY , } ;

struct Scsi_Host { struct list_head __devices ; struct list_head __targets ; struct scsi_host_cmd_pool * cmd_pool ; spinlock_t free_list_lock ; struct list_head free_list ; struct list_head starved_list ; spinlock_t default_lock ; spinlock_t * host_lock ; struct mutex scan_mutex ; struct list_head eh_cmd_q ; struct task_struct * ehandler ; struct completion * eh_action ; wait_queue_head_t host_wait ; struct scsi_host_template * hostt ; struct scsi_transport_template * transportt ; struct blk_queue_tag * bqt ; unsigned int host_busy ; unsigned int host_failed ; unsigned int host_eh_scheduled ; unsigned int host_no ; int resetting ; unsigned long last_reset ; unsigned int max_id ; unsigned int max_lun ; unsigned int max_channel ; unsigned int unique_id ; unsigned short max_cmd_len ; int this_id ; int can_queue ; short cmd_per_lun ; short unsigned int sg_tablesize ; short unsigned int max_sectors ; unsigned long dma_boundary ; unsigned long cmd_serial_number ; unsigned active_mode : 2 ; unsigned unchecked_isa_dma : 1 ; unsigned use_clustering : 1 ; unsigned use_blk_tcq : 1 ; unsigned host_self_blocked : 1 ; unsigned reverse_ordering : 1 ; unsigned ordered_tag : 1 ; unsigned tmf_in_progress : 1 ; unsigned async_scan : 1 ; char work_q_name [ 20 ] ; struct workqueue_struct * work_q ; unsigned int host_blocked ; unsigned int max_host_blocked ; unsigned int prot_capabilities ; unsigned char prot_guard_type ; struct request_queue * uspace_req_q ; unsigned long base ; unsigned long io_port ; unsigned char n_io_port ; unsigned char dma_channel ; unsigned int irq ; enum scsi_host_state shost_state ; struct device shost_gendev , shost_dev ; struct list_head sht_legacy_list ; void * shost_data ; struct device * dma_dev ; unsigned long hostdata [ 0 ] __attribute__ ( ( aligned ( sizeof ( unsigned long ) ) ) ) ; } ;
struct class_container ;

enum scsi_host_prot_capabilities { SHOST_DIF_TYPE1_PROTECTION = 1 << 0 , SHOST_DIF_TYPE2_PROTECTION = 1 << 1 , SHOST_DIF_TYPE3_PROTECTION = 1 << 2 , SHOST_DIX_TYPE0_PROTECTION = 1 << 3 , SHOST_DIX_TYPE1_PROTECTION = 1 << 4 , SHOST_DIX_TYPE2_PROTECTION = 1 << 5 , SHOST_DIX_TYPE3_PROTECTION = 1 << 6 , } ;

enum scsi_host_guard_type { SHOST_DIX_GUARD_CRC = 1 << 0 , SHOST_DIX_GUARD_IP = 1 << 1 , } ;

enum { ATA_MAX_DEVICES = 2 , ATA_MAX_PRD = 256 , ATA_SECT_SIZE = 512 , ATA_MAX_SECTORS_128 = 128 , ATA_MAX_SECTORS = 256 , ATA_MAX_SECTORS_LBA48 = 65535 , ATA_MAX_SECTORS_TAPE = 65535 , ATA_ID_WORDS = 256 , ATA_ID_CONFIG = 0 , ATA_ID_CYLS = 1 , ATA_ID_HEADS = 3 , ATA_ID_SECTORS = 6 , ATA_ID_SERNO = 10 , ATA_ID_BUF_SIZE = 21 , ATA_ID_FW_REV = 23 , ATA_ID_PROD = 27 , ATA_ID_MAX_MULTSECT = 47 , ATA_ID_DWORD_IO = 48 , ATA_ID_CAPABILITY = 49 , ATA_ID_OLD_PIO_MODES = 51 , ATA_ID_OLD_DMA_MODES = 52 , ATA_ID_FIELD_VALID = 53 , ATA_ID_CUR_CYLS = 54 , ATA_ID_CUR_HEADS = 55 , ATA_ID_CUR_SECTORS = 56 , ATA_ID_MULTSECT = 59 , ATA_ID_LBA_CAPACITY = 60 , ATA_ID_SWDMA_MODES = 62 , ATA_ID_MWDMA_MODES = 63 , ATA_ID_PIO_MODES = 64 , ATA_ID_EIDE_DMA_MIN = 65 , ATA_ID_EIDE_DMA_TIME = 66 , ATA_ID_EIDE_PIO = 67 , ATA_ID_EIDE_PIO_IORDY = 68 , ATA_ID_QUEUE_DEPTH = 75 , ATA_ID_MAJOR_VER = 80 , ATA_ID_COMMAND_SET_1 = 82 , ATA_ID_COMMAND_SET_2 = 83 , ATA_ID_CFSSE = 84 , ATA_ID_CFS_ENABLE_1 = 85 , ATA_ID_CFS_ENABLE_2 = 86 , ATA_ID_CSF_DEFAULT = 87 , ATA_ID_UDMA_MODES = 88 , ATA_ID_HW_CONFIG = 93 , ATA_ID_SPG = 98 , ATA_ID_LBA_CAPACITY_2 = 100 , ATA_ID_LAST_LUN = 126 , ATA_ID_DLF = 128 , ATA_ID_CSFO = 129 , ATA_ID_CFA_POWER = 160 , ATA_ID_CFA_KEY_MGMT = 162 , ATA_ID_CFA_MODES = 163 , ATA_ID_DATA_SET_MGMT = 169 , ATA_ID_ROT_SPEED = 217 , ATA_ID_PIO4 = ( 1 << 1 ) , ATA_ID_SERNO_LEN = 20 , ATA_ID_FW_REV_LEN = 8 , ATA_ID_PROD_LEN = 40 , ATA_PCI_CTL_OFS = 2 , ATA_PIO0 = ( 1 << 0 ) , ATA_PIO1 = ATA_PIO0 | ( 1 << 1 ) , ATA_PIO2 = ATA_PIO1 | ( 1 << 2 ) , ATA_PIO3 = ATA_PIO2 | ( 1 << 3 ) , ATA_PIO4 = ATA_PIO3 | ( 1 << 4 ) , ATA_PIO5 = ATA_PIO4 | ( 1 << 5 ) , ATA_PIO6 = ATA_PIO5 | ( 1 << 6 ) , ATA_PIO4_ONLY = ( 1 << 4 ) , ATA_SWDMA0 = ( 1 << 0 ) , ATA_SWDMA1 = ATA_SWDMA0 | ( 1 << 1 ) , ATA_SWDMA2 = ATA_SWDMA1 | ( 1 << 2 ) , ATA_SWDMA2_ONLY = ( 1 << 2 ) , ATA_MWDMA0 = ( 1 << 0 ) , ATA_MWDMA1 = ATA_MWDMA0 | ( 1 << 1 ) , ATA_MWDMA2 = ATA_MWDMA1 | ( 1 << 2 ) , ATA_MWDMA3 = ATA_MWDMA2 | ( 1 << 3 ) , ATA_MWDMA4 = ATA_MWDMA3 | ( 1 << 4 ) , ATA_MWDMA12_ONLY = ( 1 << 1 ) | ( 1 << 2 ) , ATA_MWDMA2_ONLY = ( 1 << 2 ) , ATA_UDMA0 = ( 1 << 0 ) , ATA_UDMA1 = ATA_UDMA0 | ( 1 << 1 ) , ATA_UDMA2 = ATA_UDMA1 | ( 1 << 2 ) , ATA_UDMA3 = ATA_UDMA2 | ( 1 << 3 ) , ATA_UDMA4 = ATA_UDMA3 | ( 1 << 4 ) , ATA_UDMA5 = ATA_UDMA4 | ( 1 << 5 ) , ATA_UDMA6 = ATA_UDMA5 | ( 1 << 6 ) , ATA_UDMA7 = ATA_UDMA6 | ( 1 << 7 ) , ATA_UDMA24_ONLY = ( 1 << 2 ) | ( 1 << 4 ) , ATA_UDMA_MASK_40C = ATA_UDMA2 , ATA_PRD_SZ = 8 , ATA_PRD_TBL_SZ = ( ATA_MAX_PRD * ATA_PRD_SZ ) , ATA_PRD_EOT = ( 1 << 31 ) , ATA_DMA_TABLE_OFS = 4 , ATA_DMA_STATUS = 2 , ATA_DMA_CMD = 0 , ATA_DMA_WR = ( 1 << 3 ) , ATA_DMA_START = ( 1 << 0 ) , ATA_DMA_INTR = ( 1 << 2 ) , ATA_DMA_ERR = ( 1 << 1 ) , ATA_DMA_ACTIVE = ( 1 << 0 ) , ATA_HOB = ( 1 << 7 ) , ATA_NIEN = ( 1 << 1 ) , ATA_LBA = ( 1 << 6 ) , ATA_DEV1 = ( 1 << 4 ) , ATA_DEVICE_OBS = ( 1 << 7 ) | ( 1 << 5 ) , ATA_DEVCTL_OBS = ( 1 << 3 ) , ATA_BUSY = ( 1 << 7 ) , ATA_DRDY = ( 1 << 6 ) , ATA_DF = ( 1 << 5 ) , ATA_DSC = ( 1 << 4 ) , ATA_DRQ = ( 1 << 3 ) , ATA_CORR = ( 1 << 2 ) , ATA_IDX = ( 1 << 1 ) , ATA_ERR = ( 1 << 0 ) , ATA_SRST = ( 1 << 2 ) , ATA_ICRC = ( 1 << 7 ) , ATA_BBK = ATA_ICRC , ATA_UNC = ( 1 << 6 ) , ATA_MC = ( 1 << 5 ) , ATA_IDNF = ( 1 << 4 ) , ATA_MCR = ( 1 << 3 ) , ATA_ABORTED = ( 1 << 2 ) , ATA_TRK0NF = ( 1 << 1 ) , ATA_AMNF = ( 1 << 0 ) , ATAPI_LFS = 0xF0 , ATAPI_EOM = ATA_TRK0NF , ATAPI_ILI = ATA_AMNF , ATAPI_IO = ( 1 << 1 ) , ATAPI_COD = ( 1 << 0 ) , ATA_REG_DATA = 0x00 , ATA_REG_ERR = 0x01 , ATA_REG_NSECT = 0x02 , ATA_REG_LBAL = 0x03 , ATA_REG_LBAM = 0x04 , ATA_REG_LBAH = 0x05 , ATA_REG_DEVICE = 0x06 , ATA_REG_STATUS = 0x07 , ATA_REG_FEATURE = ATA_REG_ERR , ATA_REG_CMD = ATA_REG_STATUS , ATA_REG_BYTEL = ATA_REG_LBAM , ATA_REG_BYTEH = ATA_REG_LBAH , ATA_REG_DEVSEL = ATA_REG_DEVICE , ATA_REG_IRQ = ATA_REG_NSECT , ATA_CMD_DEV_RESET = 0x08 , ATA_CMD_CHK_POWER = 0xE5 , ATA_CMD_STANDBY = 0xE2 , ATA_CMD_IDLE = 0xE3 , ATA_CMD_EDD = 0x90 , ATA_CMD_DOWNLOAD_MICRO = 0x92 , ATA_CMD_NOP = 0x00 , ATA_CMD_FLUSH = 0xE7 , ATA_CMD_FLUSH_EXT = 0xEA , ATA_CMD_ID_ATA = 0xEC , ATA_CMD_ID_ATAPI = 0xA1 , ATA_CMD_SERVICE = 0xA2 , ATA_CMD_READ = 0xC8 , ATA_CMD_READ_EXT = 0x25 , ATA_CMD_READ_QUEUED = 0x26 , ATA_CMD_READ_STREAM_EXT = 0x2B , ATA_CMD_READ_STREAM_DMA_EXT = 0x2A , ATA_CMD_WRITE = 0xCA , ATA_CMD_WRITE_EXT = 0x35 , ATA_CMD_WRITE_QUEUED = 0x36 , ATA_CMD_WRITE_STREAM_EXT = 0x3B , ATA_CMD_WRITE_STREAM_DMA_EXT = 0x3A , ATA_CMD_WRITE_FUA_EXT = 0x3D , ATA_CMD_WRITE_QUEUED_FUA_EXT = 0x3E , ATA_CMD_FPDMA_READ = 0x60 , ATA_CMD_FPDMA_WRITE = 0x61 , ATA_CMD_PIO_READ = 0x20 , ATA_CMD_PIO_READ_EXT = 0x24 , ATA_CMD_PIO_WRITE = 0x30 , ATA_CMD_PIO_WRITE_EXT = 0x34 , ATA_CMD_READ_MULTI = 0xC4 , ATA_CMD_READ_MULTI_EXT = 0x29 , ATA_CMD_WRITE_MULTI = 0xC5 , ATA_CMD_WRITE_MULTI_EXT = 0x39 , ATA_CMD_WRITE_MULTI_FUA_EXT = 0xCE , ATA_CMD_SET_FEATURES = 0xEF , ATA_CMD_SET_MULTI = 0xC6 , ATA_CMD_PACKET = 0xA0 , ATA_CMD_VERIFY = 0x40 , ATA_CMD_VERIFY_EXT = 0x42 , ATA_CMD_WRITE_UNCORR_EXT = 0x45 , ATA_CMD_STANDBYNOW1 = 0xE0 , ATA_CMD_IDLEIMMEDIATE = 0xE1 , ATA_CMD_SLEEP = 0xE6 , ATA_CMD_INIT_DEV_PARAMS = 0x91 , ATA_CMD_READ_NATIVE_MAX = 0xF8 , ATA_CMD_READ_NATIVE_MAX_EXT = 0x27 , ATA_CMD_SET_MAX = 0xF9 , ATA_CMD_SET_MAX_EXT = 0x37 , ATA_CMD_READ_LOG_EXT = 0x2F , ATA_CMD_WRITE_LOG_EXT = 0x3F , ATA_CMD_READ_LOG_DMA_EXT = 0x47 , ATA_CMD_WRITE_LOG_DMA_EXT = 0x57 , ATA_CMD_TRUSTED_RCV = 0x5C , ATA_CMD_TRUSTED_RCV_DMA = 0x5D , ATA_CMD_TRUSTED_SND = 0x5E , ATA_CMD_TRUSTED_SND_DMA = 0x5F , ATA_CMD_PMP_READ = 0xE4 , ATA_CMD_PMP_WRITE = 0xE8 , ATA_CMD_CONF_OVERLAY = 0xB1 , ATA_CMD_SEC_SET_PASS = 0xF1 , ATA_CMD_SEC_UNLOCK = 0xF2 , ATA_CMD_SEC_ERASE_PREP = 0xF3 , ATA_CMD_SEC_ERASE_UNIT = 0xF4 , ATA_CMD_SEC_FREEZE_LOCK = 0xF5 , ATA_CMD_SEC_DISABLE_PASS = 0xF6 , ATA_CMD_CONFIG_STREAM = 0x51 , ATA_CMD_SMART = 0xB0 , ATA_CMD_MEDIA_LOCK = 0xDE , ATA_CMD_MEDIA_UNLOCK = 0xDF , ATA_CMD_DSM = 0x06 , ATA_CMD_CHK_MED_CRD_TYP = 0xD1 , ATA_CMD_CFA_REQ_EXT_ERR = 0x03 , ATA_CMD_CFA_WRITE_NE = 0x38 , ATA_CMD_CFA_TRANS_SECT = 0x87 , ATA_CMD_CFA_ERASE = 0xC0 , ATA_CMD_CFA_WRITE_MULT_NE = 0xCD , ATA_CMD_RESTORE = 0x10 , ATA_LOG_SATA_NCQ = 0x10 , ATA_CMD_READ_LONG = 0x22 , ATA_CMD_READ_LONG_ONCE = 0x23 , ATA_CMD_WRITE_LONG = 0x32 , ATA_CMD_WRITE_LONG_ONCE = 0x33 , SETFEATURES_XFER = 0x03 , XFER_UDMA_7 = 0x47 , XFER_UDMA_6 = 0x46 , XFER_UDMA_5 = 0x45 , XFER_UDMA_4 = 0x44 , XFER_UDMA_3 = 0x43 , XFER_UDMA_2 = 0x42 , XFER_UDMA_1 = 0x41 , XFER_UDMA_0 = 0x40 , XFER_MW_DMA_4 = 0x24 , XFER_MW_DMA_3 = 0x23 , XFER_MW_DMA_2 = 0x22 , XFER_MW_DMA_1 = 0x21 , XFER_MW_DMA_0 = 0x20 , XFER_SW_DMA_2 = 0x12 , XFER_SW_DMA_1 = 0x11 , XFER_SW_DMA_0 = 0x10 , XFER_PIO_6 = 0x0E , XFER_PIO_5 = 0x0D , XFER_PIO_4 = 0x0C , XFER_PIO_3 = 0x0B , XFER_PIO_2 = 0x0A , XFER_PIO_1 = 0x09 , XFER_PIO_0 = 0x08 , XFER_PIO_SLOW = 0x00 , SETFEATURES_WC_ON = 0x02 , SETFEATURES_WC_OFF = 0x82 , SETFEATURES_AAM_ON = 0x42 , SETFEATURES_AAM_OFF = 0xC2 , SETFEATURES_SPINUP = 0x07 , SETFEATURES_SATA_ENABLE = 0x10 , SETFEATURES_SATA_DISABLE = 0x90 , SATA_FPDMA_OFFSET = 0x01 , SATA_FPDMA_AA = 0x02 , SATA_DIPM = 0x03 , SATA_FPDMA_IN_ORDER = 0x04 , SATA_AN = 0x05 , SATA_SSP = 0x06 , ATA_SET_MAX_ADDR = 0x00 , ATA_SET_MAX_PASSWD = 0x01 , ATA_SET_MAX_LOCK = 0x02 , ATA_SET_MAX_UNLOCK = 0x03 , ATA_SET_MAX_FREEZE_LOCK = 0x04 , ATA_DCO_RESTORE = 0xC0 , ATA_DCO_FREEZE_LOCK = 0xC1 , ATA_DCO_IDENTIFY = 0xC2 , ATA_DCO_SET = 0xC3 , ATA_SMART_ENABLE = 0xD8 , ATA_SMART_READ_VALUES = 0xD0 , ATA_SMART_READ_THRESHOLDS = 0xD1 , ATA_DSM_TRIM = 0x01 , ATA_SMART_LBAM_PASS = 0x4F , ATA_SMART_LBAH_PASS = 0xC2 , ATAPI_PKT_DMA = ( 1 << 0 ) , ATAPI_DMADIR = ( 1 << 2 ) , ATAPI_CDB_LEN = 16 , SATA_PMP_MAX_PORTS = 15 , SATA_PMP_CTRL_PORT = 15 , SATA_PMP_GSCR_DWORDS = 128 , SATA_PMP_GSCR_PROD_ID = 0 , SATA_PMP_GSCR_REV = 1 , SATA_PMP_GSCR_PORT_INFO = 2 , SATA_PMP_GSCR_ERROR = 32 , SATA_PMP_GSCR_ERROR_EN = 33 , SATA_PMP_GSCR_FEAT = 64 , SATA_PMP_GSCR_FEAT_EN = 96 , SATA_PMP_PSCR_STATUS = 0 , SATA_PMP_PSCR_ERROR = 1 , SATA_PMP_PSCR_CONTROL = 2 , SATA_PMP_FEAT_BIST = ( 1 << 0 ) , SATA_PMP_FEAT_PMREQ = ( 1 << 1 ) , SATA_PMP_FEAT_DYNSSC = ( 1 << 2 ) , SATA_PMP_FEAT_NOTIFY = ( 1 << 3 ) , ATA_CBL_NONE = 0 , ATA_CBL_PATA40 = 1 , ATA_CBL_PATA80 = 2 , ATA_CBL_PATA40_SHORT = 3 , ATA_CBL_PATA_UNK = 4 , ATA_CBL_PATA_IGN = 5 , ATA_CBL_SATA = 6 , SCR_STATUS = 0 , SCR_ERROR = 1 , SCR_CONTROL = 2 , SCR_ACTIVE = 3 , SCR_NOTIFICATION = 4 , SERR_DATA_RECOVERED = ( 1 << 0 ) , SERR_COMM_RECOVERED = ( 1 << 1 ) , SERR_DATA = ( 1 << 8 ) , SERR_PERSISTENT = ( 1 << 9 ) , SERR_PROTOCOL = ( 1 << 10 ) , SERR_INTERNAL = ( 1 << 11 ) , SERR_PHYRDY_CHG = ( 1 << 16 ) , SERR_PHY_INT_ERR = ( 1 << 17 ) , SERR_COMM_WAKE = ( 1 << 18 ) , SERR_10B_8B_ERR = ( 1 << 19 ) , SERR_DISPARITY = ( 1 << 20 ) , SERR_CRC = ( 1 << 21 ) , SERR_HANDSHAKE = ( 1 << 22 ) , SERR_LINK_SEQ_ERR = ( 1 << 23 ) , SERR_TRANS_ST_ERROR = ( 1 << 24 ) , SERR_UNRECOG_FIS = ( 1 << 25 ) , SERR_DEV_XCHG = ( 1 << 26 ) , ATA_TFLAG_LBA48 = ( 1 << 0 ) , ATA_TFLAG_ISADDR = ( 1 << 1 ) , ATA_TFLAG_DEVICE = ( 1 << 2 ) , ATA_TFLAG_WRITE = ( 1 << 3 ) , ATA_TFLAG_LBA = ( 1 << 4 ) , ATA_TFLAG_FUA = ( 1 << 5 ) , ATA_TFLAG_POLLING = ( 1 << 6 ) , ATA_PROT_FLAG_PIO = ( 1 << 0 ) , ATA_PROT_FLAG_DMA = ( 1 << 1 ) , ATA_PROT_FLAG_DATA = ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA , ATA_PROT_FLAG_NCQ = ( 1 << 2 ) , ATA_PROT_FLAG_ATAPI = ( 1 << 3 ) , } ;
enum ata_tf_protocols { ATA_PROT_UNKNOWN , ATA_PROT_NODATA , ATA_PROT_PIO , ATA_PROT_DMA , ATA_PROT_NCQ , ATAPI_PROT_NODATA , ATAPI_PROT_PIO , ATAPI_PROT_DMA , } ;

enum ata_ioctls { ATA_IOC_GET_IO32 = 0x309 , ATA_IOC_SET_IO32 = 0x324 , } ;

struct ata_prd { __le32 addr ; __le32 flags_len ; } ;

struct ata_taskfile { unsigned long flags ; u8 protocol ; u8 ctl ; u8 hob_feature ; u8 hob_nsect ; u8 hob_lbal ; u8 hob_lbam ; u8 hob_lbah ; u8 feature ; u8 nsect ; u8 lbal ; u8 lbam ; u8 lbah ; u8 device ; u8 command ; } ;

enum { ATA_MSG_DRV = 0x0001 , ATA_MSG_INFO = 0x0002 , ATA_MSG_PROBE = 0x0004 , ATA_MSG_WARN = 0x0008 , ATA_MSG_MALLOC = 0x0010 , ATA_MSG_CTL = 0x0020 , ATA_MSG_INTR = 0x0040 , ATA_MSG_ERR = 0x0080 , } ;
enum { LIBATA_MAX_PRD = ATA_MAX_PRD / 2 , LIBATA_DUMB_MAX_PRD = ATA_MAX_PRD / 4 , ATA_DEF_QUEUE = 1 , ATA_MAX_QUEUE = 32 , ATA_TAG_INTERNAL = ATA_MAX_QUEUE - 1 , ATA_SHORT_PAUSE = 16 , ATAPI_MAX_DRAIN = 16 << 10 , ATA_ALL_DEVICES = ( 1 << ATA_MAX_DEVICES ) - 1 , ATA_SHT_EMULATED = 1 , ATA_SHT_CMD_PER_LUN = 1 , ATA_SHT_THIS_ID = - 1 , ATA_SHT_USE_CLUSTERING = 1 , ATA_DFLAG_LBA = ( 1 << 0 ) , ATA_DFLAG_LBA48 = ( 1 << 1 ) , ATA_DFLAG_CDB_INTR = ( 1 << 2 ) , ATA_DFLAG_NCQ = ( 1 << 3 ) , ATA_DFLAG_FLUSH_EXT = ( 1 << 4 ) , ATA_DFLAG_ACPI_PENDING = ( 1 << 5 ) , ATA_DFLAG_ACPI_FAILED = ( 1 << 6 ) , ATA_DFLAG_AN = ( 1 << 7 ) , ATA_DFLAG_HIPM = ( 1 << 8 ) , ATA_DFLAG_DIPM = ( 1 << 9 ) , ATA_DFLAG_DMADIR = ( 1 << 10 ) , ATA_DFLAG_CFG_MASK = ( 1 << 12 ) - 1 , ATA_DFLAG_PIO = ( 1 << 12 ) , ATA_DFLAG_NCQ_OFF = ( 1 << 13 ) , ATA_DFLAG_SLEEPING = ( 1 << 15 ) , ATA_DFLAG_DUBIOUS_XFER = ( 1 << 16 ) , ATA_DFLAG_NO_UNLOAD = ( 1 << 17 ) , ATA_DFLAG_INIT_MASK = ( 1 << 24 ) - 1 , ATA_DFLAG_DETACH = ( 1 << 24 ) , ATA_DFLAG_DETACHED = ( 1 << 25 ) , ATA_DEV_UNKNOWN = 0 , ATA_DEV_ATA = 1 , ATA_DEV_ATA_UNSUP = 2 , ATA_DEV_ATAPI = 3 , ATA_DEV_ATAPI_UNSUP = 4 , ATA_DEV_PMP = 5 , ATA_DEV_PMP_UNSUP = 6 , ATA_DEV_SEMB = 7 , ATA_DEV_SEMB_UNSUP = 8 , ATA_DEV_NONE = 9 , ATA_LFLAG_NO_HRST = ( 1 << 1 ) , ATA_LFLAG_NO_SRST = ( 1 << 2 ) , ATA_LFLAG_ASSUME_ATA = ( 1 << 3 ) , ATA_LFLAG_ASSUME_SEMB = ( 1 << 4 ) , ATA_LFLAG_ASSUME_CLASS = ATA_LFLAG_ASSUME_ATA | ATA_LFLAG_ASSUME_SEMB , ATA_LFLAG_NO_RETRY = ( 1 << 5 ) , ATA_LFLAG_DISABLED = ( 1 << 6 ) , ATA_LFLAG_SW_ACTIVITY = ( 1 << 7 ) , ATA_FLAG_SLAVE_POSS = ( 1 << 0 ) , ATA_FLAG_SATA = ( 1 << 1 ) , ATA_FLAG_NO_LEGACY = ( 1 << 2 ) , ATA_FLAG_MMIO = ( 1 << 3 ) , ATA_FLAG_SRST = ( 1 << 4 ) , ATA_FLAG_SATA_RESET = ( 1 << 5 ) , ATA_FLAG_NO_ATAPI = ( 1 << 6 ) , ATA_FLAG_PIO_DMA = ( 1 << 7 ) , ATA_FLAG_PIO_LBA48 = ( 1 << 8 ) , ATA_FLAG_PIO_POLLING = ( 1 << 9 ) , ATA_FLAG_NCQ = ( 1 << 10 ) , ATA_FLAG_NO_POWEROFF_SPINDOWN = ( 1 << 11 ) , ATA_FLAG_NO_HIBERNATE_SPINDOWN = ( 1 << 12 ) , ATA_FLAG_DEBUGMSG = ( 1 << 13 ) , ATA_FLAG_FPDMA_AA = ( 1 << 14 ) , ATA_FLAG_IGN_SIMPLEX = ( 1 << 15 ) , ATA_FLAG_NO_IORDY = ( 1 << 16 ) , ATA_FLAG_ACPI_SATA = ( 1 << 17 ) , ATA_FLAG_AN = ( 1 << 18 ) , ATA_FLAG_PMP = ( 1 << 19 ) , ATA_FLAG_IPM = ( 1 << 20 ) , ATA_FLAG_EM = ( 1 << 21 ) , ATA_FLAG_SW_ACTIVITY = ( 1 << 22 ) , ATA_FLAG_DISABLED = ( 1 << 23 ) , ATA_PFLAG_EH_PENDING = ( 1 << 0 ) , ATA_PFLAG_EH_IN_PROGRESS = ( 1 << 1 ) , ATA_PFLAG_FROZEN = ( 1 << 2 ) , ATA_PFLAG_RECOVERED = ( 1 << 3 ) , ATA_PFLAG_LOADING = ( 1 << 4 ) , ATA_PFLAG_SCSI_HOTPLUG = ( 1 << 6 ) , ATA_PFLAG_INITIALIZING = ( 1 << 7 ) , ATA_PFLAG_RESETTING = ( 1 << 8 ) , ATA_PFLAG_UNLOADING = ( 1 << 9 ) , ATA_PFLAG_UNLOADED = ( 1 << 10 ) , ATA_PFLAG_SUSPENDED = ( 1 << 17 ) , ATA_PFLAG_PM_PENDING = ( 1 << 18 ) , ATA_PFLAG_INIT_GTM_VALID = ( 1 << 19 ) , ATA_PFLAG_PIO32 = ( 1 << 20 ) , ATA_PFLAG_PIO32CHANGE = ( 1 << 21 ) , ATA_QCFLAG_ACTIVE = ( 1 << 0 ) , ATA_QCFLAG_DMAMAP = ( 1 << 1 ) , ATA_QCFLAG_IO = ( 1 << 3 ) , ATA_QCFLAG_RESULT_TF = ( 1 << 4 ) , ATA_QCFLAG_CLEAR_EXCL = ( 1 << 5 ) , ATA_QCFLAG_QUIET = ( 1 << 6 ) , ATA_QCFLAG_RETRY = ( 1 << 7 ) , ATA_QCFLAG_FAILED = ( 1 << 16 ) , ATA_QCFLAG_SENSE_VALID = ( 1 << 17 ) , ATA_QCFLAG_EH_SCHEDULED = ( 1 << 18 ) , ATA_HOST_SIMPLEX = ( 1 << 0 ) , ATA_HOST_STARTED = ( 1 << 1 ) , ATA_HOST_PARALLEL_SCAN = ( 1 << 2 ) , ATA_TMOUT_BOOT = 30000 , ATA_TMOUT_BOOT_QUICK = 7000 , ATA_TMOUT_INTERNAL_QUICK = 5000 , ATA_TMOUT_MAX_PARK = 30000 , ATA_TMOUT_FF_WAIT = 800 , ATA_WAIT_AFTER_RESET = 150 , ATA_TMOUT_PMP_SRST_WAIT = 5000 , BUS_UNKNOWN = 0 , BUS_DMA = 1 , BUS_IDLE = 2 , BUS_NOINTR = 3 , BUS_NODATA = 4 , BUS_TIMER = 5 , BUS_PIO = 6 , BUS_EDD = 7 , BUS_IDENTIFY = 8 , BUS_PACKET = 9 , PORT_UNKNOWN = 0 , PORT_ENABLED = 1 , PORT_DISABLED = 2 , ATA_NR_PIO_MODES = 7 , ATA_NR_MWDMA_MODES = 5 , ATA_NR_UDMA_MODES = 8 , ATA_SHIFT_PIO = 0 , ATA_SHIFT_MWDMA = ATA_SHIFT_PIO + ATA_NR_PIO_MODES , ATA_SHIFT_UDMA = ATA_SHIFT_MWDMA + ATA_NR_MWDMA_MODES , ATA_DMA_PAD_SZ = 4 , ATA_ERING_SIZE = 32 , ATA_DEFER_LINK = 1 , ATA_DEFER_PORT = 2 , ATA_EH_DESC_LEN = 80 , ATA_EH_REVALIDATE = ( 1 << 0 ) , ATA_EH_SOFTRESET = ( 1 << 1 ) , ATA_EH_HARDRESET = ( 1 << 2 ) , ATA_EH_RESET = ATA_EH_SOFTRESET | ATA_EH_HARDRESET , ATA_EH_ENABLE_LINK = ( 1 << 3 ) , ATA_EH_LPM = ( 1 << 4 ) , ATA_EH_PARK = ( 1 << 5 ) , ATA_EH_PERDEV_MASK = ATA_EH_REVALIDATE | ATA_EH_PARK , ATA_EH_ALL_ACTIONS = ATA_EH_REVALIDATE | ATA_EH_RESET | ATA_EH_ENABLE_LINK | ATA_EH_LPM , ATA_EHI_HOTPLUGGED = ( 1 << 0 ) , ATA_EHI_NO_AUTOPSY = ( 1 << 2 ) , ATA_EHI_QUIET = ( 1 << 3 ) , ATA_EHI_DID_SOFTRESET = ( 1 << 16 ) , ATA_EHI_DID_HARDRESET = ( 1 << 17 ) , ATA_EHI_PRINTINFO = ( 1 << 18 ) , ATA_EHI_SETMODE = ( 1 << 19 ) , ATA_EHI_POST_SETMODE = ( 1 << 20 ) , ATA_EHI_DID_RESET = ATA_EHI_DID_SOFTRESET | ATA_EHI_DID_HARDRESET , ATA_EHI_TO_SLAVE_MASK = ATA_EHI_NO_AUTOPSY | ATA_EHI_QUIET , ATA_EH_MAX_TRIES = 5 , ATA_LINK_RESUME_TRIES = 5 , ATA_PROBE_MAX_TRIES = 3 , ATA_EH_DEV_TRIES = 3 , ATA_EH_PMP_TRIES = 5 , ATA_EH_PMP_LINK_TRIES = 3 , SATA_PMP_RW_TIMEOUT = 3000 , ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 5 , ATA_HORKAGE_DIAGNOSTIC = ( 1 << 0 ) , ATA_HORKAGE_NODMA = ( 1 << 1 ) , ATA_HORKAGE_NONCQ = ( 1 << 2 ) , ATA_HORKAGE_MAX_SEC_128 = ( 1 << 3 ) , ATA_HORKAGE_BROKEN_HPA = ( 1 << 4 ) , ATA_HORKAGE_DISABLE = ( 1 << 5 ) , ATA_HORKAGE_HPA_SIZE = ( 1 << 6 ) , ATA_HORKAGE_IPM = ( 1 << 7 ) , ATA_HORKAGE_IVB = ( 1 << 8 ) , ATA_HORKAGE_STUCK_ERR = ( 1 << 9 ) , ATA_HORKAGE_BRIDGE_OK = ( 1 << 10 ) , ATA_HORKAGE_ATAPI_MOD16_DMA = ( 1 << 11 ) , ATA_HORKAGE_FIRMWARE_WARN = ( 1 << 12 ) , ATA_HORKAGE_1_5_GBPS = ( 1 << 13 ) , ATA_HORKAGE_NOSETXFER = ( 1 << 14 ) , ATA_HORKAGE_BROKEN_FPDMA_AA = ( 1 << 15 ) , ATA_DMA_MASK_ATA = ( 1 << 0 ) , ATA_DMA_MASK_ATAPI = ( 1 << 1 ) , ATA_DMA_MASK_CFA = ( 1 << 2 ) , ATAPI_READ = 0 , ATAPI_WRITE = 1 , ATAPI_READ_CD = 2 , ATAPI_PASS_THRU = 3 , ATAPI_MISC = 4 , ATA_TIMING_SETUP = ( 1 << 0 ) , ATA_TIMING_ACT8B = ( 1 << 1 ) , ATA_TIMING_REC8B = ( 1 << 2 ) , ATA_TIMING_CYC8B = ( 1 << 3 ) , ATA_TIMING_8BIT = ATA_TIMING_ACT8B | ATA_TIMING_REC8B | ATA_TIMING_CYC8B , ATA_TIMING_ACTIVE = ( 1 << 4 ) , ATA_TIMING_RECOVER = ( 1 << 5 ) , ATA_TIMING_DMACK_HOLD = ( 1 << 6 ) , ATA_TIMING_CYCLE = ( 1 << 7 ) , ATA_TIMING_UDMA = ( 1 << 8 ) , ATA_TIMING_ALL = ATA_TIMING_SETUP | ATA_TIMING_ACT8B | ATA_TIMING_REC8B | ATA_TIMING_CYC8B | ATA_TIMING_ACTIVE | ATA_TIMING_RECOVER | ATA_TIMING_DMACK_HOLD | ATA_TIMING_CYCLE | ATA_TIMING_UDMA , ATA_ACPI_FILTER_SETXFER = 1 << 0 , ATA_ACPI_FILTER_LOCK = 1 << 1 , ATA_ACPI_FILTER_DIPM = 1 << 2 , ATA_ACPI_FILTER_FPDMA_OFFSET = 1 << 3 , ATA_ACPI_FILTER_FPDMA_AA = 1 << 4 , ATA_ACPI_FILTER_DEFAULT = ATA_ACPI_FILTER_SETXFER | ATA_ACPI_FILTER_LOCK | ATA_ACPI_FILTER_DIPM , } ;
enum ata_xfer_mask { ATA_MASK_PIO = ( ( 1LU << ATA_NR_PIO_MODES ) - 1 ) << ATA_SHIFT_PIO , ATA_MASK_MWDMA = ( ( 1LU << ATA_NR_MWDMA_MODES ) - 1 ) << ATA_SHIFT_MWDMA , ATA_MASK_UDMA = ( ( 1LU << ATA_NR_UDMA_MODES ) - 1 ) << ATA_SHIFT_UDMA , } ;

enum hsm_task_states { HSM_ST_IDLE , HSM_ST_FIRST , HSM_ST , HSM_ST_LAST , HSM_ST_ERR , } ;

enum ata_completion_errors { AC_ERR_DEV = ( 1 << 0 ) , AC_ERR_HSM = ( 1 << 1 ) , AC_ERR_TIMEOUT = ( 1 << 2 ) , AC_ERR_MEDIA = ( 1 << 3 ) , AC_ERR_ATA_BUS = ( 1 << 4 ) , AC_ERR_HOST_BUS = ( 1 << 5 ) , AC_ERR_SYSTEM = ( 1 << 6 ) , AC_ERR_INVALID = ( 1 << 7 ) , AC_ERR_OTHER = ( 1 << 8 ) , AC_ERR_NODEV_HINT = ( 1 << 9 ) , AC_ERR_NCQ = ( 1 << 10 ) , } ;

struct ata_port_operations ;

struct ata_port ;

struct ata_link ;

struct ata_queued_cmd ;

typedef void ( * ata_qc_cb_t ) ( struct ata_queued_cmd * qc ) ;
typedef int ( * ata_prereset_fn_t ) ( struct ata_link * link , unsigned long deadline ) ;
typedef int ( * ata_reset_fn_t ) ( struct ata_link * link , unsigned int * classes , unsigned long deadline ) ;
typedef void ( * ata_postreset_fn_t ) ( struct ata_link * link , unsigned int * classes ) ;
enum link_pm { NOT_AVAILABLE , MIN_POWER , MAX_PERFORMANCE , MEDIUM_POWER , } ;

enum sw_activity { OFF , BLINK_ON , BLINK_OFF , } ;

struct ata_ioports { void * cmd_addr ; void * data_addr ; void * error_addr ; void * feature_addr ; void * nsect_addr ; void * lbal_addr ; void * lbam_addr ; void * lbah_addr ; void * device_addr ; void * status_addr ; void * command_addr ; void * altstatus_addr ; void * ctl_addr ; void * bmdma_addr ; void * scr_addr ; } ;

struct ata_host { spinlock_t lock ; struct device * dev ; void * const * iomap ; unsigned int n_ports ; void * private_data ; struct ata_port_operations * ops ; unsigned long flags ; acpi_handle acpi_handle ; struct ata_port * simplex_claimed ; struct ata_port * ports [ 0 ] ; } ;

struct ata_queued_cmd { struct ata_port * ap ; struct ata_device * dev ; struct scsi_cmnd * scsicmd ; void ( * scsidone ) ( struct scsi_cmnd * ) ; struct ata_taskfile tf ; u8 cdb [ ATAPI_CDB_LEN ] ; unsigned long flags ; unsigned int tag ; unsigned int n_elem ; unsigned int orig_n_elem ; int dma_dir ; unsigned int sect_size ; unsigned int nbytes ; unsigned int extrabytes ; unsigned int curbytes ; struct scatterlist * cursg ; unsigned int cursg_ofs ; struct scatterlist sgent ; struct scatterlist * sg ; unsigned int err_mask ; struct ata_taskfile result_tf ; ata_qc_cb_t complete_fn ; void * private_data ; void * lldd_task ; } ;
struct ata_port_stats { unsigned long unhandled_irq ; unsigned long idle_irq ; unsigned long rw_reqbuf ; } ;

struct ata_ering_entry { unsigned int eflags ; unsigned int err_mask ; u64 timestamp ; } ;

struct ata_ering { int cursor ; struct ata_ering_entry ring [ ATA_ERING_SIZE ] ; } ;

struct ata_device { struct ata_link * link ; unsigned int devno ; unsigned int horkage ; unsigned long flags ; struct scsi_device * sdev ; acpi_handle acpi_handle ; union acpi_object * gtf_cache ; unsigned int gtf_filter ; u64 n_sectors ; u64 n_native_sectors ; unsigned int class ; unsigned long unpark_deadline ; u8 pio_mode ; u8 dma_mode ; u8 xfer_mode ; unsigned int xfer_shift ; unsigned int multi_count ; unsigned int max_sectors ; unsigned int cdb_len ; unsigned long pio_mask ; unsigned long mwdma_mask ; unsigned long udma_mask ; u16 cylinders ; u16 heads ; u16 sectors ; union { u16 id [ ATA_ID_WORDS ] ; u32 gscr [ SATA_PMP_GSCR_DWORDS ] ; } ; int spdn_cnt ; struct ata_ering ering ; } ;

struct ata_eh_info { struct ata_device * dev ; u32 serror ; unsigned int err_mask ; unsigned int action ; unsigned int dev_action [ ATA_MAX_DEVICES ] ; unsigned int flags ; unsigned int probe_mask ; char desc [ ATA_EH_DESC_LEN ] ; int desc_len ; } ;

struct ata_eh_context { struct ata_eh_info i ; int tries [ ATA_MAX_DEVICES ] ; int cmd_timeout_idx [ ATA_MAX_DEVICES ] [ ATA_EH_CMD_TIMEOUT_TABLE_SIZE ] ; unsigned int classes [ ATA_MAX_DEVICES ] ; unsigned int did_probe_mask ; unsigned int unloaded_mask ; unsigned int saved_ncq_enabled ; u8 saved_xfer_mode [ ATA_MAX_DEVICES ] ; unsigned long last_reset ; } ;

struct ata_acpi_drive { u32 pio ; u32 dma ; } __attribute__ ( ( packed ) ) ;
struct ata_acpi_gtm { struct ata_acpi_drive drive [ 2 ] ; u32 flags ; } __attribute__ ( ( packed ) ) ;
struct ata_link { struct ata_port * ap ; int pmp ; unsigned int active_tag ; u32 sactive ; unsigned int flags ; u32 saved_scontrol ; unsigned int hw_sata_spd_limit ; unsigned int sata_spd_limit ; unsigned int sata_spd ; struct ata_eh_info eh_info ; struct ata_eh_context eh_context ; struct ata_device device [ ATA_MAX_DEVICES ] ; } ;
struct ata_port { struct Scsi_Host * scsi_host ; struct ata_port_operations * ops ; spinlock_t * lock ; unsigned long flags ; unsigned int pflags ; unsigned int print_id ; unsigned int port_no ; struct ata_prd * prd ; dma_addr_t prd_dma ; struct ata_ioports ioaddr ; u8 ctl ; u8 last_ctl ; unsigned int pio_mask ; unsigned int mwdma_mask ; unsigned int udma_mask ; unsigned int cbl ; struct ata_queued_cmd qcmd [ ATA_MAX_QUEUE ] ; unsigned long qc_allocated ; unsigned int qc_active ; int nr_active_links ; struct ata_link link ; struct ata_link * slave_link ; int nr_pmp_links ; struct ata_link * pmp_link ; struct ata_link * excl_link ; struct ata_port_stats stats ; struct ata_host * host ; struct device * dev ; void * port_task_data ; struct delayed_work port_task ; struct delayed_work hotplug_task ; struct work_struct scsi_rescan_task ; unsigned int hsm_task_state ; u32 msg_enable ; struct list_head eh_done_q ; wait_queue_head_t eh_wait_q ; int eh_tries ; struct completion park_req_pending ; pm_message_t pm_mesg ; int * pm_result ; enum link_pm pm_policy ; struct timer_list fastdrain_timer ; unsigned long fastdrain_cnt ; int em_message_type ; void * private_data ; acpi_handle acpi_handle ; struct ata_acpi_gtm __acpi_init_gtm ; u8 sector_buf [ ATA_SECT_SIZE ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; } ;
struct ata_port_operations { int ( * qc_defer ) ( struct ata_queued_cmd * qc ) ; int ( * check_atapi_dma ) ( struct ata_queued_cmd * qc ) ; void ( * qc_prep ) ( struct ata_queued_cmd * qc ) ; unsigned int ( * qc_issue ) ( struct ata_queued_cmd * qc ) ; bool ( * qc_fill_rtf ) ( struct ata_queued_cmd * qc ) ; int ( * cable_detect ) ( struct ata_port * ap ) ; unsigned long ( * mode_filter ) ( struct ata_device * dev , unsigned long xfer_mask ) ; void ( * set_piomode ) ( struct ata_port * ap , struct ata_device * dev ) ; void ( * set_dmamode ) ( struct ata_port * ap , struct ata_device * dev ) ; int ( * set_mode ) ( struct ata_link * link , struct ata_device * * r_failed_dev ) ; unsigned int ( * read_id ) ( struct ata_device * dev , struct ata_taskfile * tf , u16 * id ) ; void ( * dev_config ) ( struct ata_device * dev ) ; void ( * freeze ) ( struct ata_port * ap ) ; void ( * thaw ) ( struct ata_port * ap ) ; ata_prereset_fn_t prereset ; ata_reset_fn_t softreset ; ata_reset_fn_t hardreset ; ata_postreset_fn_t postreset ; ata_prereset_fn_t pmp_prereset ; ata_reset_fn_t pmp_softreset ; ata_reset_fn_t pmp_hardreset ; ata_postreset_fn_t pmp_postreset ; void ( * error_handler ) ( struct ata_port * ap ) ; void ( * lost_interrupt ) ( struct ata_port * ap ) ; void ( * post_internal_cmd ) ( struct ata_queued_cmd * qc ) ; int ( * scr_read ) ( struct ata_link * link , unsigned int sc_reg , u32 * val ) ; int ( * scr_write ) ( struct ata_link * link , unsigned int sc_reg , u32 val ) ; void ( * pmp_attach ) ( struct ata_port * ap ) ; void ( * pmp_detach ) ( struct ata_port * ap ) ; int ( * enable_pm ) ( struct ata_port * ap , enum link_pm policy ) ; void ( * disable_pm ) ( struct ata_port * ap ) ; int ( * port_suspend ) ( struct ata_port * ap , pm_message_t mesg ) ; int ( * port_resume ) ( struct ata_port * ap ) ; int ( * port_start ) ( struct ata_port * ap ) ; void ( * port_stop ) ( struct ata_port * ap ) ; void ( * host_stop ) ( struct ata_host * host ) ; void ( * sff_dev_select ) ( struct ata_port * ap , unsigned int device ) ; u8 ( * sff_check_status ) ( struct ata_port * ap ) ; u8 ( * sff_check_altstatus ) ( struct ata_port * ap ) ; void ( * sff_tf_load ) ( struct ata_port * ap , const struct ata_taskfile * tf ) ; void ( * sff_tf_read ) ( struct ata_port * ap , struct ata_taskfile * tf ) ; void ( * sff_exec_command ) ( struct ata_port * ap , const struct ata_taskfile * tf ) ; unsigned int ( * sff_data_xfer ) ( struct ata_device * dev , unsigned char * buf , unsigned int buflen , int rw ) ; u8 ( * sff_irq_on ) ( struct ata_port * ) ; void ( * sff_irq_clear ) ( struct ata_port * ) ; void ( * bmdma_setup ) ( struct ata_queued_cmd * qc ) ; void ( * bmdma_start ) ( struct ata_queued_cmd * qc ) ; void ( * bmdma_stop ) ( struct ata_queued_cmd * qc ) ; u8 ( * bmdma_status ) ( struct ata_port * ap ) ; void ( * drain_fifo ) ( struct ata_queued_cmd * qc ) ; ssize_t ( * em_show ) ( struct ata_port * ap , char * buf ) ; ssize_t ( * em_store ) ( struct ata_port * ap , const char * message , size_t size ) ; ssize_t ( * sw_activity_show ) ( struct ata_device * dev , char * buf ) ; ssize_t ( * sw_activity_store ) ( struct ata_device * dev , enum sw_activity val ) ; void ( * phy_reset ) ( struct ata_port * ap ) ; void ( * eng_timeout ) ( struct ata_port * ap ) ; const struct ata_port_operations * inherits ; } ;
struct ata_port_info { unsigned long flags ; unsigned long link_flags ; unsigned long pio_mask ; unsigned long mwdma_mask ; unsigned long udma_mask ; struct ata_port_operations * port_ops ; void * private_data ; } ;

struct ata_timing { unsigned short mode ; unsigned short setup ; unsigned short act8b ; unsigned short rec8b ; unsigned short cyc8b ; unsigned short active ; unsigned short recover ; unsigned short dmack_hold ; unsigned short cycle ; unsigned short udma ; } ;

struct pci_bits { unsigned int reg ; unsigned int width ; unsigned long mask ; unsigned long val ; } ;

enum ata_link_iter_mode { ATA_LITER_EDGE , ATA_LITER_HOST_FIRST , ATA_LITER_PMP_FIRST , } ;

enum ata_dev_iter_mode { ATA_DITER_ENABLED , ATA_DITER_ENABLED_REVERSE , ATA_DITER_ALL , ATA_DITER_ALL_REVERSE , } ;

struct ata_scsi_args { struct ata_device * dev ; u16 * id ; struct scsi_cmnd * cmd ; void ( * done ) ( struct scsi_cmnd * ) ; } ;

enum { ATA_READID_POSTRESET = ( 1 << 0 ) , ATA_DNXFER_PIO = 0 , ATA_DNXFER_DMA = 1 , ATA_DNXFER_40C = 2 , ATA_DNXFER_FORCE_PIO = 3 , ATA_DNXFER_FORCE_PIO0 = 4 , ATA_DNXFER_QUIET = ( 1 << 31 ) , } ;
struct ata_force_param { const char * name ; unsigned int cbl ; int spd_limit ; unsigned long xfer_mask ; unsigned int horkage_on ; unsigned int horkage_off ; unsigned int lflags ; } ;

struct ata_force_ent { int port ; int device ; struct ata_force_param param ; } ;

struct ata_link * ata_link_next ( struct ata_link * link , struct ata_port * ap , enum ata_link_iter_mode mode ) ;

struct ata_device * ata_dev_next ( struct ata_device * dev , struct ata_link * link , enum ata_dev_iter_mode mode ) ;

struct ata_link * ata_dev_phys_link ( struct ata_device * dev ) ;

void ata_force_cbl ( struct ata_port * ap ) ;

int atapi_cmd_type ( u8 opcode ) ;

void ata_tf_to_fis ( const struct ata_taskfile * tf , u8 pmp , int is_cmd , u8 * fis ) ;

void ata_tf_from_fis ( const u8 * fis , struct ata_taskfile * tf ) ;

u64 ata_tf_read_block ( struct ata_taskfile * tf , struct ata_device * dev ) ;

int ata_build_rw_tf ( struct ata_taskfile * tf , struct ata_device * dev , u64 block , u32 n_block , unsigned int tf_flags , unsigned int tag ) ;

unsigned long ata_pack_xfermask ( unsigned long pio_mask , unsigned long mwdma_mask , unsigned long udma_mask ) ;

void ata_unpack_xfermask ( unsigned long xfer_mask , unsigned long * pio_mask , unsigned long * mwdma_mask , unsigned long * udma_mask ) ;


u8 ata_xfer_mask2mode ( unsigned long xfer_mask ) ;

unsigned long ata_xfer_mode2mask ( u8 xfer_mode ) ;

int ata_xfer_mode2shift ( unsigned long xfer_mode ) ;

const char * ata_mode_string ( unsigned long xfer_mask ) ;

void ata_dev_enable_pm ( struct ata_device * dev , enum link_pm policy ) ;

void ata_lpm_schedule ( struct ata_port * ap , enum link_pm policy ) ;

unsigned int ata_dev_classify ( const struct ata_taskfile * tf ) ;

void ata_id_string ( const u16 * id , unsigned char * s , unsigned int ofs , unsigned int len ) ;

void ata_id_c_string ( const u16 * id , unsigned char * s , unsigned int ofs , unsigned int len ) ;

u64 ata_tf_to_lba48 ( const struct ata_taskfile * tf ) ;

u64 ata_tf_to_lba ( const struct ata_taskfile * tf ) ;

unsigned long ata_id_xfermask ( const u16 * id ) ;

void ata_pio_queue_task ( struct ata_port * ap , void * data , unsigned long delay ) ;

void ata_port_flush_task ( struct ata_port * ap ) ;

unsigned ata_exec_internal_sg ( struct ata_device * dev , struct ata_taskfile * tf , const u8 * cdb , int dma_dir , struct scatterlist * sgl , unsigned int n_elem , unsigned long timeout ) ;

unsigned ata_exec_internal ( struct ata_device * dev , struct ata_taskfile * tf , const u8 * cdb , int dma_dir , void * buf , unsigned int buflen , unsigned long timeout ) ;

unsigned int ata_do_simple_cmd ( struct ata_device * dev , u8 cmd ) ;

unsigned int ata_pio_need_iordy ( const struct ata_device * adev ) ;

unsigned int ata_do_dev_read_id ( struct ata_device * dev , struct ata_taskfile * tf , u16 * id ) ;

int ata_dev_read_id ( struct ata_device * dev , unsigned int * p_class , unsigned int flags , u16 * id ) ;

int ata_dev_configure ( struct ata_device * dev ) ;

int ata_cable_40wire ( struct ata_port * ap ) ;

int ata_cable_80wire ( struct ata_port * ap ) ;

int ata_cable_unknown ( struct ata_port * ap ) ;

int ata_cable_ignore ( struct ata_port * ap ) ;

int ata_cable_sata ( struct ata_port * ap ) ;

int ata_bus_probe ( struct ata_port * ap ) ;

void ata_port_probe ( struct ata_port * ap ) ;

struct ata_device * ata_dev_pair ( struct ata_device * adev ) ;

void ata_port_disable ( struct ata_port * ap ) ;

int sata_down_spd_limit ( struct ata_link * link , u32 spd_limit ) ;

int sata_set_spd ( struct ata_link * link ) ;

void ata_timing_merge ( const struct ata_timing * a , const struct ata_timing * b , struct ata_timing * m , unsigned int what ) ;

const struct ata_timing * ata_timing_find_mode ( u8 xfer_mode ) ;

int ata_timing_compute ( struct ata_device * adev , unsigned short speed , struct ata_timing * t , int T , int UT ) ;

u8 ata_timing_cycle2mode ( unsigned int xfer_shift , int cycle ) ;

int ata_down_xfermask_limit ( struct ata_device * dev , unsigned int sel ) ;

int ata_do_set_mode ( struct ata_link * link , struct ata_device * * r_failed_dev ) ;

int ata_wait_ready ( struct ata_link * link , unsigned long deadline , int ( * check_ready ) ( struct ata_link * link ) ) ;

int ata_wait_after_reset ( struct ata_link * link , unsigned long deadline , int ( * check_ready ) ( struct ata_link * link ) ) ;

int sata_link_debounce ( struct ata_link * link , const unsigned long * params , unsigned long deadline ) ;

int sata_link_resume ( struct ata_link * link , const unsigned long * params , unsigned long deadline ) ;

int ata_std_prereset ( struct ata_link * link , unsigned long deadline ) ;

int sata_link_hardreset ( struct ata_link * link , const unsigned long * timing , unsigned long deadline , bool * online , int ( * check_ready ) ( struct ata_link * ) ) ;

int sata_std_hardreset ( struct ata_link * link , unsigned int * class , unsigned long deadline ) ;

void ata_std_postreset ( struct ata_link * link , unsigned int * classes ) ;

int ata_dev_reread_id ( struct ata_device * dev , unsigned int readid_flags ) ;

int ata_dev_revalidate ( struct ata_device * dev , unsigned int new_class , unsigned int readid_flags ) ;

struct ata_blacklist_entry { const char * model_num ; const char * model_rev ; unsigned long horkage ; } ;

void ata_sg_clean ( struct ata_queued_cmd * qc ) ;

int atapi_check_dma ( struct ata_queued_cmd * qc ) ;

int ata_std_qc_defer ( struct ata_queued_cmd * qc ) ;

void ata_noop_qc_prep ( struct ata_queued_cmd * qc ) ;

void ata_sg_init ( struct ata_queued_cmd * qc , struct scatterlist * sg , unsigned int n_elem ) ;

void swap_buf_le16 ( u16 * buf , unsigned int buf_words ) ;

struct ata_queued_cmd * ata_qc_new_init ( struct ata_device * dev ) ;

void ata_qc_free ( struct ata_queued_cmd * qc ) ;

void __ata_qc_complete ( struct ata_queued_cmd * qc ) ;

void ata_qc_complete ( struct ata_queued_cmd * qc ) ;

int ata_qc_complete_multiple ( struct ata_port * ap , u32 qc_active ) ;

void ata_qc_issue ( struct ata_queued_cmd * qc ) ;

int sata_scr_valid ( struct ata_link * link ) ;

int sata_scr_read ( struct ata_link * link , int reg , u32 * val ) ;

int sata_scr_write ( struct ata_link * link , int reg , u32 val ) ;

int sata_scr_write_flush ( struct ata_link * link , int reg , u32 val ) ;

bool ata_phys_link_online ( struct ata_link * link ) ;

bool ata_phys_link_offline ( struct ata_link * link ) ;

bool ata_link_online ( struct ata_link * link ) ;

bool ata_link_offline ( struct ata_link * link ) ;

int ata_host_suspend ( struct ata_host * host , pm_message_t mesg ) ;

void ata_host_resume ( struct ata_host * host ) ;

int ata_port_start ( struct ata_port * ap ) ;

void ata_dev_init ( struct ata_device * dev ) ;

void ata_link_init ( struct ata_port * ap , struct ata_link * link , int pmp ) ;

int sata_link_init_spd ( struct ata_link * link ) ;

struct ata_port * ata_port_alloc ( struct ata_host * host ) ;

struct ata_host * ata_host_alloc ( struct device * dev , int max_ports ) ;

struct ata_host * ata_host_alloc_pinfo ( struct device * dev , const struct ata_port_info * const * ppi , int n_ports ) ;

int ata_slave_link_init ( struct ata_port * ap ) ;

int ata_host_start ( struct ata_host * host ) ;

void ata_host_init ( struct ata_host * host , struct device * dev , unsigned long flags , struct ata_port_operations * ops ) ;

int ata_host_register ( struct ata_host * host , struct scsi_host_template * sht ) ;

int ata_host_activate ( struct ata_host * host , int irq , irq_handler_t irq_handler , unsigned long irq_flags , struct scsi_host_template * sht ) ;

void ata_host_detach ( struct ata_host * host ) ;

void ata_pci_remove_one ( struct pci_dev * pdev ) ;

int pci_test_config_bits ( struct pci_dev * pdev , const struct pci_bits * bits ) ;

void ata_pci_device_do_suspend ( struct pci_dev * pdev , pm_message_t mesg ) ;

int ata_pci_device_do_resume ( struct pci_dev * pdev ) ;

int ata_pci_device_suspend ( struct pci_dev * pdev , pm_message_t mesg ) ;

int ata_pci_device_resume ( struct pci_dev * pdev ) ;

int ata_ratelimit ( void ) ;

u32 ata_wait_register ( void * reg , u32 mask , u32 val , unsigned long interval , unsigned long timeout ) ;

struct scsi_sense_hdr { u8 response_code ; u8 sense_key ; u8 asc ; u8 ascq ; u8 byte4 ; u8 byte5 ; u8 byte6 ; u8 additional_length ; } ;
struct scsi_eh_save { int result ; enum dma_data_direction data_direction ; unsigned underflow ; unsigned char cmd_len ; unsigned char prot_op ; unsigned char * cmnd ; struct scsi_data_buffer sdb ; struct request * next_rq ; unsigned char eh_cmnd [ 16 ] ; struct scatterlist sense_sgl ; } ;

struct attribute_container { struct list_head node ; struct klist containers ; struct class * class ; const struct attribute_group * grp ; struct device_attribute * * attrs ; int ( * match ) ( struct attribute_container * , struct device * ) ; unsigned long flags ; } ;

struct transport_container ;

struct transport_class { struct class class ; int ( * setup ) ( struct transport_container * , struct device * , struct device * ) ; int ( * configure ) ( struct transport_container * , struct device * , struct device * ) ; int ( * remove ) ( struct transport_container * , struct device * , struct device * ) ; } ;

struct anon_transport_class { struct transport_class tclass ; struct attribute_container container ; } ;

struct transport_container { struct attribute_container ac ; const struct attribute_group * statistics ; } ;
struct scsi_transport_template { struct transport_container host_attrs ; struct transport_container target_attrs ; struct transport_container device_attrs ; int ( * user_scan ) ( struct Scsi_Host * , uint , uint , uint ) ; int device_size ; int device_private_offset ; int target_size ; int target_private_offset ; int host_size ; unsigned int create_work_queue : 1 ; void ( * eh_strategy_handler ) ( struct Scsi_Host * ) ; enum blk_eh_timer_return ( * eh_timed_out ) ( struct scsi_cmnd * ) ; int ( * it_nexus_response ) ( struct Scsi_Host * , u64 , int ) ; int ( * tsk_mgmt_response ) ( struct Scsi_Host * , u64 , u64 , int ) ; } ;
typedef unsigned int ( * ata_xlat_func_t ) ( struct ata_queued_cmd * qc ) ;
int ata_std_bios_param ( struct scsi_device * sdev , struct block_device * bdev , sector_t capacity , int geom [ ] ) ;

int ata_cmd_ioctl ( struct scsi_device * scsidev , void * arg ) ;

int ata_task_ioctl ( struct scsi_device * scsidev , void * arg ) ;

int ata_sas_scsi_ioctl ( struct ata_port * ap , struct scsi_device * scsidev , int cmd , void * arg ) ;

int ata_scsi_ioctl ( struct scsi_device * scsidev , int cmd , void * arg ) ;

int ata_scsi_slave_config ( struct scsi_device * sdev ) ;

void ata_scsi_slave_destroy ( struct scsi_device * sdev ) ;

int ata_scsi_change_queue_depth ( struct scsi_device * sdev , int queue_depth ) ;

int ata_scsi_queuecmd ( struct scsi_cmnd * cmd , void ( * done ) ( struct scsi_cmnd * ) ) ;

void ata_scsi_simulate ( struct ata_device * dev , struct scsi_cmnd * cmd , void ( * done ) ( struct scsi_cmnd * ) ) ;

int ata_scsi_add_hosts ( struct ata_host * host , struct scsi_host_template * sht ) ;

void ata_scsi_scan_host ( struct ata_port * ap , int sync ) ;

int ata_scsi_offline_dev ( struct ata_device * dev ) ;

void ata_scsi_media_change_notify ( struct ata_device * dev ) ;

void ata_scsi_hotplug ( struct work_struct * work ) ;

void ata_scsi_dev_rescan ( struct work_struct * work ) ;

struct ata_port * ata_sas_port_alloc ( struct ata_host * host , struct ata_port_info * port_info , struct Scsi_Host * shost ) ;

int ata_sas_port_start ( struct ata_port * ap ) ;

void ata_sas_port_stop ( struct ata_port * ap ) ;

int ata_sas_port_init ( struct ata_port * ap ) ;

void ata_sas_port_destroy ( struct ata_port * ap ) ;

int ata_sas_slave_configure ( struct scsi_device * sdev , struct ata_port * ap ) ;

int ata_sas_queuecmd ( struct scsi_cmnd * cmd , void ( * done ) ( struct scsi_cmnd * ) , struct ata_port * ap ) ;

enum { ATA_EH_SPDN_NCQ_OFF = ( 1 << 0 ) , ATA_EH_SPDN_SPEED_DOWN = ( 1 << 1 ) , ATA_EH_SPDN_FALLBACK_TO_PIO = ( 1 << 2 ) , ATA_EH_SPDN_KEEP_ERRORS = ( 1 << 3 ) , ATA_EFLAG_IS_IO = ( 1 << 0 ) , ATA_EFLAG_DUBIOUS_XFER = ( 1 << 1 ) , ATA_ECAT_NONE = 0 , ATA_ECAT_ATA_BUS = 1 , ATA_ECAT_TOUT_HSM = 2 , ATA_ECAT_UNK_DEV = 3 , ATA_ECAT_DUBIOUS_NONE = 4 , ATA_ECAT_DUBIOUS_ATA_BUS = 5 , ATA_ECAT_DUBIOUS_TOUT_HSM = 6 , ATA_ECAT_DUBIOUS_UNK_DEV = 7 , ATA_ECAT_NR = 8 , ATA_EH_CMD_DFL_TIMEOUT = 5000 , ATA_EH_RESET_COOL_DOWN = 5000 , ATA_EH_PRERESET_TIMEOUT = 10000 , ATA_EH_FASTDRAIN_INTERVAL = 3000 , ATA_EH_UA_TRIES = 5 , ATA_EH_PROBE_TRIAL_INTERVAL = 60000 , ATA_EH_PROBE_TRIALS = 2 , } ;
struct ata_eh_cmd_timeout_ent { const u8 * commands ; const unsigned long * timeouts ; } ;

void __ata_ehi_push_desc ( struct ata_eh_info * ehi , const char * fmt , ... ) ;

void ata_ehi_push_desc ( struct ata_eh_info * ehi , const char * fmt , ... ) ;

void ata_ehi_clear_desc ( struct ata_eh_info * ehi ) ;

void ata_port_desc ( struct ata_port * ap , const char * fmt , ... ) ;

void ata_port_pbar_desc ( struct ata_port * ap , int bar , ssize_t offset , const char * name ) ;

unsigned long ata_internal_cmd_timeout ( struct ata_device * dev , u8 cmd ) ;

void ata_internal_cmd_timed_out ( struct ata_device * dev , u8 cmd ) ;

enum blk_eh_timer_return ata_scsi_timed_out ( struct scsi_cmnd * cmd ) ;

void ata_scsi_error ( struct Scsi_Host * host ) ;

void ata_port_wait_eh ( struct ata_port * ap ) ;

void ata_eh_fastdrain_timerfn ( unsigned long arg ) ;

void ata_qc_schedule_eh ( struct ata_queued_cmd * qc ) ;

void ata_port_schedule_eh ( struct ata_port * ap ) ;

int ata_link_abort ( struct ata_link * link ) ;

int ata_port_abort ( struct ata_port * ap ) ;

int ata_port_freeze ( struct ata_port * ap ) ;

int sata_async_notification ( struct ata_port * ap ) ;

void ata_eh_freeze_port ( struct ata_port * ap ) ;

void ata_eh_thaw_port ( struct ata_port * ap ) ;

void ata_eh_qc_complete ( struct ata_queued_cmd * qc ) ;

void ata_eh_qc_retry ( struct ata_queued_cmd * qc ) ;

void ata_dev_disable ( struct ata_device * dev ) ;

void ata_eh_detach_dev ( struct ata_device * dev ) ;

void ata_eh_about_to_do ( struct ata_link * link , struct ata_device * dev , unsigned int action ) ;

void ata_eh_done ( struct ata_link * link , struct ata_device * dev , unsigned int action ) ;

void ata_eh_analyze_ncq_error ( struct ata_link * link ) ;

struct speed_down_verdict_arg { u64 since ; int xfer_ok ; int nr_errors [ ATA_ECAT_NR ] ; } ;

void ata_eh_autopsy ( struct ata_port * ap ) ;

const char * ata_get_cmd_descript ( u8 command ) ;

void ata_eh_report ( struct ata_port * ap ) ;

int ata_eh_reset ( struct ata_link * link , int classify , ata_prereset_fn_t prereset , ata_reset_fn_t softreset , ata_reset_fn_t hardreset , ata_postreset_fn_t postreset ) ;

int ata_set_mode ( struct ata_link * link , struct ata_device * * r_failed_dev ) ;

int ata_eh_recover ( struct ata_port * ap , ata_prereset_fn_t prereset , ata_reset_fn_t softreset , ata_reset_fn_t hardreset , ata_postreset_fn_t postreset , struct ata_link * * r_failed_link ) ;

void ata_eh_finish ( struct ata_port * ap ) ;

void ata_do_eh ( struct ata_port * ap , ata_prereset_fn_t prereset , ata_reset_fn_t softreset , ata_reset_fn_t hardreset , ata_postreset_fn_t postreset ) ;

void ata_std_error_handler ( struct ata_port * ap ) ;

void ata_sff_qc_prep ( struct ata_queued_cmd * qc ) ;

void ata_sff_dumb_qc_prep ( struct ata_queued_cmd * qc ) ;

u8 ata_sff_check_status ( struct ata_port * ap ) ;

void ata_sff_pause ( struct ata_port * ap ) ;

void ata_sff_dma_pause ( struct ata_port * ap ) ;

int ata_sff_busy_sleep ( struct ata_port * ap , unsigned long tmout_pat , unsigned long tmout ) ;

int ata_sff_wait_ready ( struct ata_link * link , unsigned long deadline ) ;

void ata_sff_dev_select ( struct ata_port * ap , unsigned int device ) ;

void ata_dev_select ( struct ata_port * ap , unsigned int device , unsigned int wait , unsigned int can_sleep ) ;

u8 ata_sff_irq_on ( struct ata_port * ap ) ;

void ata_sff_irq_clear ( struct ata_port * ap ) ;

void ata_sff_tf_load ( struct ata_port * ap , const struct ata_taskfile * tf ) ;

void ata_sff_tf_read ( struct ata_port * ap , struct ata_taskfile * tf ) ;

void ata_sff_exec_command ( struct ata_port * ap , const struct ata_taskfile * tf ) ;

unsigned int ata_sff_data_xfer ( struct ata_device * dev , unsigned char * buf , unsigned int buflen , int rw ) ;

unsigned int ata_sff_data_xfer32 ( struct ata_device * dev , unsigned char * buf , unsigned int buflen , int rw ) ;

unsigned int ata_sff_data_xfer_noirq ( struct ata_device * dev , unsigned char * buf , unsigned int buflen , int rw ) ;

int ata_sff_hsm_move ( struct ata_port * ap , struct ata_queued_cmd * qc , u8 status , int in_wq ) ;

void ata_pio_task ( struct work_struct * work ) ;

unsigned int ata_sff_qc_issue ( struct ata_queued_cmd * qc ) ;

bool ata_sff_qc_fill_rtf ( struct ata_queued_cmd * qc ) ;

unsigned int ata_sff_host_intr ( struct ata_port * ap , struct ata_queued_cmd * qc ) ;

irqreturn_t ata_sff_interrupt ( int irq , void * dev_instance ) ;

void ata_sff_lost_interrupt ( struct ata_port * ap ) ;

void ata_sff_freeze ( struct ata_port * ap ) ;

void ata_sff_thaw ( struct ata_port * ap ) ;

int ata_sff_prereset ( struct ata_link * link , unsigned long deadline ) ;

unsigned int ata_sff_dev_classify ( struct ata_device * dev , int present , u8 * r_err ) ;

int ata_sff_wait_after_reset ( struct ata_link * link , unsigned int devmask , unsigned long deadline ) ;

int ata_sff_softreset ( struct ata_link * link , unsigned int * classes , unsigned long deadline ) ;

int sata_sff_hardreset ( struct ata_link * link , unsigned int * class , unsigned long deadline ) ;

void ata_sff_postreset ( struct ata_link * link , unsigned int * classes ) ;

void ata_sff_drain_fifo ( struct ata_queued_cmd * qc ) ;

void ata_sff_error_handler ( struct ata_port * ap ) ;

void ata_sff_post_internal_cmd ( struct ata_queued_cmd * qc ) ;

int ata_sff_port_start ( struct ata_port * ap ) ;

int ata_sff_port_start32 ( struct ata_port * ap ) ;

void ata_sff_std_ports ( struct ata_ioports * ioaddr ) ;

unsigned long ata_bmdma_mode_filter ( struct ata_device * adev , unsigned long xfer_mask ) ;

void ata_bmdma_setup ( struct ata_queued_cmd * qc ) ;

void ata_bmdma_start ( struct ata_queued_cmd * qc ) ;

void ata_bmdma_stop ( struct ata_queued_cmd * qc ) ;

u8 ata_bmdma_status ( struct ata_port * ap ) ;

void ata_bus_reset ( struct ata_port * ap ) ;

int ata_pci_bmdma_clear_simplex ( struct pci_dev * pdev ) ;

int ata_pci_bmdma_init ( struct ata_host * host ) ;

int ata_pci_sff_init_host ( struct ata_host * host ) ;

int ata_pci_sff_prepare_host ( struct pci_dev * pdev , const struct ata_port_info * const * ppi , struct ata_host * * r_host ) ;

int ata_pci_sff_activate_host ( struct ata_host * host , irq_handler_t irq_handler , struct scsi_host_template * sht ) ;

int ata_pci_sff_init_one ( struct pci_dev * pdev , const struct ata_port_info * const * ppi , struct scsi_host_template * sht , void * host_priv ) ;

int sata_pmp_qc_defer_cmd_switch ( struct ata_queued_cmd * qc ) ;

int sata_pmp_scr_read ( struct ata_link * link , int reg , u32 * r_val ) ;

int sata_pmp_scr_write ( struct ata_link * link , int reg , u32 val ) ;

int sata_pmp_attach ( struct ata_device * dev ) ;

void sata_pmp_error_handler ( struct ata_port * ap ) ;

struct ata_acpi_gtf { u8 tf [ 7 ] ; } __attribute__ ( ( packed ) ) ;
void ata_acpi_associate_sata_port ( struct ata_port * ap ) ;

void ata_acpi_associate ( struct ata_host * host ) ;

void ata_acpi_dissociate ( struct ata_host * host ) ;

int ata_acpi_gtm ( struct ata_port * ap , struct ata_acpi_gtm * gtm ) ;

int ata_acpi_stm ( struct ata_port * ap , const struct ata_acpi_gtm * stm ) ;

unsigned long ata_acpi_gtm_xfermask ( struct ata_device * dev , const struct ata_acpi_gtm * gtm ) ;

int ata_acpi_cbl_80wire ( struct ata_port * ap , const struct ata_acpi_gtm * gtm ) ;

int ata_acpi_on_suspend ( struct ata_port * ap ) ;

void ata_acpi_on_resume ( struct ata_port * ap ) ;

void ata_acpi_set_state ( struct ata_port * ap , pm_message_t state ) ;

int ata_acpi_on_devcfg ( struct ata_device * dev ) ;

void ata_acpi_on_disable ( struct ata_device * dev ) ;

enum { PIIX_IOCFG = 0x54 , ICH5_PMR = 0x90 , ICH5_PCS = 0x92 , PIIX_SIDPR_BAR = 5 , PIIX_SIDPR_LEN = 16 , PIIX_SIDPR_IDX = 0 , PIIX_SIDPR_DATA = 4 , PIIX_FLAG_CHECKINTR = ( 1 << 28 ) , PIIX_FLAG_SIDPR = ( 1 << 29 ) , PIIX_PATA_FLAGS = ATA_FLAG_SLAVE_POSS , PIIX_SATA_FLAGS = ATA_FLAG_SATA | PIIX_FLAG_CHECKINTR , PIIX_80C_PRI = ( 1 << 5 ) | ( 1 << 4 ) , PIIX_80C_SEC = ( 1 << 7 ) | ( 1 << 6 ) , P0 = 0 , P1 = 1 , P2 = 2 , P3 = 3 , IDE = - 1 , NA = - 2 , RV = - 3 , PIIX_AHCI_DEVICE = 6 , PIIX_HOST_BROKEN_SUSPEND = ( 1 << 24 ) , } ;
enum piix_controller_ids { piix_pata_mwdma , piix_pata_33 , ich_pata_33 , ich_pata_66 , ich_pata_100 , ich_pata_100_nomwdma1 , ich5_sata , ich6_sata , ich6m_sata , ich8_sata , ich8_2port_sata , ich8m_apple_sata , tolapai_sata , piix_pata_vmw , } ;

struct piix_map_db { const u32 mask ; const u16 port_enable ; const int map [ ] [ 4 ] ; } ;

struct piix_host_priv { const int * map ; u32 saved_iocfg ; spinlock_t sidpr_lock ; void * sidpr ; } ;

struct ich_laptop { u16 device ; u16 subvendor ; u16 subdevice ; } ;

enum { ADMA_MMIO_BAR = 4 , ADMA_PORTS = 2 , ADMA_CPB_BYTES = 40 , ADMA_PRD_BYTES = LIBATA_MAX_PRD * 16 , ADMA_PKT_BYTES = ADMA_CPB_BYTES + ADMA_PRD_BYTES , ADMA_DMA_BOUNDARY = 0xffffffff , ADMA_MODE_LOCK = 0x00c7 , ADMA_CONTROL = 0x0000 , ADMA_STATUS = 0x0002 , ADMA_CPB_COUNT = 0x0004 , ADMA_CPB_CURRENT = 0x000c , ADMA_CPB_NEXT = 0x000c , ADMA_CPB_LOOKUP = 0x0010 , ADMA_FIFO_IN = 0x0014 , ADMA_FIFO_OUT = 0x0016 , aNIEN = ( 1 << 8 ) , aGO = ( 1 << 7 ) , aRSTADM = ( 1 << 5 ) , aPIOMD4 = 0x0003 , aPSD = ( 1 << 6 ) , aUIRQ = ( 1 << 4 ) , aPERR = ( 1 << 0 ) , cDONE = ( 1 << 0 ) , cATERR = ( 1 << 3 ) , cVLD = ( 1 << 0 ) , cDAT = ( 1 << 2 ) , cIEN = ( 1 << 3 ) , pORD = ( 1 << 4 ) , pDIRO = ( 1 << 5 ) , pEND = ( 1 << 7 ) , rIGN = ( 1 << 5 ) , rEND = ( 1 << 7 ) , ADMA_REGS_CONTROL = 0x0e , ADMA_REGS_SECTOR_COUNT = 0x12 , ADMA_REGS_LBA_LOW = 0x13 , ADMA_REGS_LBA_MID = 0x14 , ADMA_REGS_LBA_HIGH = 0x15 , ADMA_REGS_DEVICE = 0x16 , ADMA_REGS_COMMAND = 0x17 , board_1841_idx = 0 , } ;
typedef enum { adma_state_idle , adma_state_pkt , adma_state_mmio } adma_state_t ;

struct adma_port_priv { u8 * pkt ; dma_addr_t pkt_dma ; adma_state_t state ; } ;

struct ata_port_info ;
struct sis_chipset { u16 device ; const struct ata_port_info * info ; } ;

struct sis_laptop { u16 device ; u16 subvendor ; u16 subdevice ; } ;

struct pata_acpi { struct ata_acpi_gtm gtm ; void * last ; unsigned long mask [ 2 ] ; } ;

enum { ATA_GEN_CLASS_MATCH = ( 1 << 0 ) , ATA_GEN_FORCE_DMA = ( 1 << 1 ) , } ;
struct bus_type_private { struct kset subsys ; struct kset * drivers_kset ; struct kset * devices_kset ; struct klist klist_devices ; struct klist klist_drivers ; struct blocking_notifier_head bus_notifier ; unsigned int drivers_autoprobe : 1 ; struct bus_type * bus ; } ;
struct driver_private { struct kobject kobj ; struct klist klist_devices ; struct klist_node knode_bus ; struct module_kobject * mkobj ; struct device_driver * driver ; } ;
struct class_private { struct kset class_subsys ; struct klist class_devices ; struct list_head class_interfaces ; struct kset class_dirs ; struct mutex class_mutex ; struct class * class ; } ;
struct device_private { struct klist klist_children ; struct klist_node knode_parent ; struct klist_node knode_driver ; struct klist_node knode_bus ; void * driver_data ; struct device * device ; } ;
const char * dev_driver_string ( const struct device * dev ) ;

int device_create_file ( struct device * dev , struct device_attribute * attr ) ;

void device_remove_file ( struct device * dev , struct device_attribute * attr ) ;

int device_create_bin_file ( struct device * dev , struct bin_attribute * attr ) ;

void device_remove_bin_file ( struct device * dev , struct bin_attribute * attr ) ;

int device_schedule_callback_owner ( struct device * dev , void ( * func ) ( struct device * ) , struct module * owner ) ;

void device_initialize ( struct device * dev ) ;

int dev_set_name ( struct device * dev , const char * fmt , ... ) ;

int device_private_init ( struct device * dev ) ;

int device_add ( struct device * dev ) ;

int device_register ( struct device * dev ) ;

struct device * get_device ( struct device * dev ) ;

void put_device ( struct device * dev ) ;

void device_del ( struct device * dev ) ;

void device_unregister ( struct device * dev ) ;

const char * device_get_devnode ( struct device * dev , mode_t * mode , const char * * tmp ) ;

int device_for_each_child ( struct device * parent , void * data , int ( * fn ) ( struct device * dev , void * data ) ) ;

struct device * device_find_child ( struct device * parent , void * data , int ( * match ) ( struct device * dev , void * data ) ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) devices_init ( void ) ;

struct root_device { struct device dev ; struct module * owner ; } ;

struct device * __root_device_register ( const char * name , struct module * owner ) ;

void root_device_unregister ( struct device * dev ) ;

struct device * device_create_vargs ( struct class * class , struct device * parent , dev_t devt , void * drvdata , const char * fmt , va_list args ) ;

struct device * device_create ( struct class * class , struct device * parent , dev_t devt , void * drvdata , const char * fmt , ... ) ;

void device_destroy ( struct class * class , dev_t devt ) ;

int device_rename ( struct device * dev , char * new_name ) ;

int device_move ( struct device * dev , struct device * new_parent , enum dpm_order dpm_order ) ;

void device_shutdown ( void ) ;

int sysdev_create_file ( struct sys_device * s , struct sysdev_attribute * a ) ;

void sysdev_remove_file ( struct sys_device * s , struct sysdev_attribute * a ) ;

int sysdev_class_create_file ( struct sysdev_class * c , struct sysdev_class_attribute * a ) ;

void sysdev_class_remove_file ( struct sysdev_class * c , struct sysdev_class_attribute * a ) ;

int sysdev_class_register ( struct sysdev_class * cls ) ;

void sysdev_class_unregister ( struct sysdev_class * cls ) ;

int sysdev_driver_register ( struct sysdev_class * cls , struct sysdev_driver * drv ) ;

void sysdev_driver_unregister ( struct sysdev_class * cls , struct sysdev_driver * drv ) ;

int sysdev_register ( struct sys_device * sysdev ) ;

void sysdev_unregister ( struct sys_device * sysdev ) ;

void sysdev_shutdown ( void ) ;

int sysdev_suspend ( pm_message_t state ) ;

int sysdev_resume ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) system_bus_init ( void ) ;

ssize_t sysdev_store_ulong ( struct sys_device * sysdev , struct sysdev_attribute * attr , const char * buf , size_t size ) ;

ssize_t sysdev_show_ulong ( struct sys_device * sysdev , struct sysdev_attribute * attr , char * buf ) ;

ssize_t sysdev_store_int ( struct sys_device * sysdev , struct sysdev_attribute * attr , const char * buf , size_t size ) ;

ssize_t sysdev_show_int ( struct sys_device * sysdev , struct sysdev_attribute * attr , char * buf ) ;

int bus_create_file ( struct bus_type * bus , struct bus_attribute * attr ) ;

void bus_remove_file ( struct bus_type * bus , struct bus_attribute * attr ) ;

int bus_for_each_dev ( struct bus_type * bus , struct device * start , void * data , int ( * fn ) ( struct device * , void * ) ) ;

struct device * bus_find_device ( struct bus_type * bus , struct device * start , void * data , int ( * match ) ( struct device * dev , void * data ) ) ;

struct device * bus_find_device_by_name ( struct bus_type * bus , struct device * start , const char * name ) ;

int bus_for_each_drv ( struct bus_type * bus , struct device_driver * start , void * data , int ( * fn ) ( struct device_driver * , void * ) ) ;

int bus_add_device ( struct device * dev ) ;

void bus_probe_device ( struct device * dev ) ;

void bus_remove_device ( struct device * dev ) ;

int bus_add_driver ( struct device_driver * drv ) ;

void bus_remove_driver ( struct device_driver * drv ) ;

int bus_rescan_devices ( struct bus_type * bus ) ;

int device_reprobe ( struct device * dev ) ;

int bus_register ( struct bus_type * bus ) ;

void bus_unregister ( struct bus_type * bus ) ;

int bus_register_notifier ( struct bus_type * bus , struct notifier_block * nb ) ;

int bus_unregister_notifier ( struct bus_type * bus , struct notifier_block * nb ) ;

struct kset * bus_get_kset ( struct bus_type * bus ) ;

struct klist * bus_get_device_klist ( struct bus_type * bus ) ;

void bus_sort_breadthfirst ( struct bus_type * bus , int ( * compare ) ( const struct device * a , const struct device * b ) ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) buses_init ( void ) ;

int device_bind_driver ( struct device * dev ) ;

int driver_probe_done ( void ) ;

void wait_for_device_probe ( void ) ;

int driver_probe_device ( struct device_driver * drv , struct device * dev ) ;

int device_attach ( struct device * dev ) ;

int driver_attach ( struct device_driver * drv ) ;

void device_release_driver ( struct device * dev ) ;

void driver_detach ( struct device_driver * drv ) ;

void * dev_get_drvdata ( const struct device * dev ) ;

void dev_set_drvdata ( struct device * dev , void * data ) ;

int driver_for_each_device ( struct device_driver * drv , struct device * start , void * data , int ( * fn ) ( struct device * , void * ) ) ;

struct device * driver_find_device ( struct device_driver * drv , struct device * start , void * data , int ( * match ) ( struct device * dev , void * data ) ) ;

int driver_create_file ( struct device_driver * drv , struct driver_attribute * attr ) ;

void driver_remove_file ( struct device_driver * drv , struct driver_attribute * attr ) ;

int driver_add_kobj ( struct device_driver * drv , struct kobject * kobj , const char * fmt , ... ) ;

struct device_driver * get_driver ( struct device_driver * drv ) ;

void put_driver ( struct device_driver * drv ) ;

int driver_register ( struct device_driver * drv ) ;

void driver_unregister ( struct device_driver * drv ) ;

struct device_driver * driver_find ( const char * name , struct bus_type * bus ) ;

int class_create_file ( struct class * cls , const struct class_attribute * attr ) ;

void class_remove_file ( struct class * cls , const struct class_attribute * attr ) ;

int __class_register ( struct class * cls , struct lock_class_key * key ) ;

void class_unregister ( struct class * cls ) ;

struct class * __class_create ( struct module * owner , const char * name , struct lock_class_key * key ) ;

void class_destroy ( struct class * cls ) ;

void class_dev_iter_init ( struct class_dev_iter * iter , struct class * class , struct device * start , const struct device_type * type ) ;

struct device * class_dev_iter_next ( struct class_dev_iter * iter ) ;

void class_dev_iter_exit ( struct class_dev_iter * iter ) ;

int class_for_each_device ( struct class * class , struct device * start , void * data , int ( * fn ) ( struct device * , void * ) ) ;

struct device * class_find_device ( struct class * class , struct device * start , void * data , int ( * match ) ( struct device * , void * ) ) ;

int class_interface_register ( struct class_interface * class_intf ) ;

void class_interface_unregister ( struct class_interface * class_intf ) ;

struct class_compat { struct kobject * kobj ; } ;
struct class_compat * class_compat_register ( const char * name ) ;

void class_compat_unregister ( struct class_compat * cls ) ;

int class_compat_create_link ( struct class_compat * cls , struct device * dev , struct device * device_link ) ;

void class_compat_remove_link ( struct class_compat * cls , struct device * dev , struct device * device_link ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) classes_init ( void ) ;

struct resource * platform_get_resource ( struct platform_device * dev , unsigned int type , unsigned int num ) ;

int platform_get_irq ( struct platform_device * dev , unsigned int num ) ;

struct resource * platform_get_resource_byname ( struct platform_device * dev , unsigned int type , const char * name ) ;

int platform_get_irq_byname ( struct platform_device * dev , const char * name ) ;

int platform_add_devices ( struct platform_device * * devs , int num ) ;

struct platform_object { struct platform_device pdev ; char name [ 1 ] ; } ;

void platform_device_put ( struct platform_device * pdev ) ;

struct platform_device * platform_device_alloc ( const char * name , int id ) ;

int platform_device_add_resources ( struct platform_device * pdev , struct resource * res , unsigned int num ) ;

int platform_device_add_data ( struct platform_device * pdev , const void * data , size_t size ) ;

int platform_device_add ( struct platform_device * pdev ) ;

void platform_device_del ( struct platform_device * pdev ) ;

int platform_device_register ( struct platform_device * pdev ) ;

void platform_device_unregister ( struct platform_device * pdev ) ;

struct platform_device * platform_device_register_simple ( const char * name , int id , struct resource * res , unsigned int num ) ;

struct platform_device * platform_device_register_data ( struct device * parent , const char * name , int id , const void * data , size_t size ) ;

int platform_driver_register ( struct platform_driver * drv ) ;

void platform_driver_unregister ( struct platform_driver * drv ) ;

int platform_driver_probe ( struct platform_driver * drv , int ( * probe ) ( struct platform_device * ) ) ;

int __attribute__ ( ( weak ) ) platform_pm_runtime_suspend ( struct device * dev ) ;

int __attribute__ ( ( weak ) ) platform_pm_runtime_resume ( struct device * dev ) ;

int __attribute__ ( ( weak ) ) platform_pm_runtime_idle ( struct device * dev ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) platform_bus_init ( void ) ;

u64 dma_get_required_mask ( struct device * dev ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_platform_driver_register ( struct early_platform_driver * epdrv , char * buf ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_platform_add_devices ( struct platform_device * * devs , int num ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_platform_driver_register_all ( char * class_str ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_platform_driver_probe ( char * class_str , int nr_probe , int user_only ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_platform_cleanup ( void ) ;

void unregister_cpu ( struct cpu * cpu ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) register_cpu ( struct cpu * cpu , int num ) ;

struct sys_device * get_cpu_sysdev ( unsigned cpu ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) cpu_dev_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) firmware_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) driver_init ( void ) ;

struct kobj_map { struct probe { struct probe * next ; dev_t dev ; unsigned long range ; struct module * owner ; kobj_probe_t * get ; int ( * lock ) ( dev_t , void * ) ; void * data ; } * probes [ 255 ] ; struct mutex * lock ; } ;
int kobj_map ( struct kobj_map * domain , dev_t dev , unsigned long range , struct module * module , kobj_probe_t * probe , int ( * lock ) ( dev_t , void * ) , void * data ) ;
void kobj_unmap ( struct kobj_map * domain , dev_t dev , unsigned long range ) ;

struct kobject * kobj_lookup ( struct kobj_map * domain , dev_t dev , int * index ) ;

struct kobj_map * kobj_map_init ( kobj_probe_t * base_probe , struct mutex * lock ) ;

struct devres_node { struct list_head entry ; dr_release_t release ; } ;

struct devres { struct devres_node node ; unsigned long long data [ ] ; } ;

struct devres_group { struct devres_node node [ 2 ] ; void * id ; int color ; } ;

void * devres_alloc ( dr_release_t release , size_t size , gfp_t gfp ) ;

void devres_free ( void * res ) ;

void devres_add ( struct device * dev , void * res ) ;

void * devres_find ( struct device * dev , dr_release_t release , dr_match_t match , void * match_data ) ;

void * devres_get ( struct device * dev , void * new_res , dr_match_t match , void * match_data ) ;

void * devres_remove ( struct device * dev , dr_release_t release , dr_match_t match , void * match_data ) ;

int devres_destroy ( struct device * dev , dr_release_t release , dr_match_t match , void * match_data ) ;

int devres_release_all ( struct device * dev ) ;

void * devres_open_group ( struct device * dev , void * id , gfp_t gfp ) ;

void devres_close_group ( struct device * dev , void * id ) ;

void devres_remove_group ( struct device * dev , void * id ) ;

int devres_release_group ( struct device * dev , void * id ) ;

void * devm_kzalloc ( struct device * dev , size_t size , gfp_t gfp ) ;

void devm_kfree ( struct device * dev , void * p ) ;

struct internal_container { struct klist_node node ; struct attribute_container * cont ; struct device classdev ; } ;

struct attribute_container * attribute_container_classdev_to_container ( struct device * classdev ) ;

int attribute_container_register ( struct attribute_container * cont ) ;

int attribute_container_unregister ( struct attribute_container * cont ) ;

void attribute_container_add_device ( struct device * dev , int ( * fn ) ( struct attribute_container * , struct device * , struct device * ) ) ;

void attribute_container_remove_device ( struct device * dev , void ( * fn ) ( struct attribute_container * , struct device * , struct device * ) ) ;

void attribute_container_device_trigger ( struct device * dev , int ( * fn ) ( struct attribute_container * , struct device * , struct device * ) ) ;

void attribute_container_trigger ( struct device * dev , int ( * fn ) ( struct attribute_container * , struct device * ) ) ;

int attribute_container_add_attrs ( struct device * classdev ) ;

int attribute_container_add_class_device ( struct device * classdev ) ;

int attribute_container_add_class_device_adapter ( struct attribute_container * cont , struct device * dev , struct device * classdev ) ;

void attribute_container_remove_attrs ( struct device * classdev ) ;

void attribute_container_class_device_del ( struct device * classdev ) ;

struct device * attribute_container_find_class_device ( struct attribute_container * cont , struct device * dev ) ;

int transport_class_register ( struct transport_class * tclass ) ;

void transport_class_unregister ( struct transport_class * tclass ) ;

int anon_transport_class_register ( struct anon_transport_class * atc ) ;

void anon_transport_class_unregister ( struct anon_transport_class * atc ) ;

void transport_setup_device ( struct device * dev ) ;

void transport_add_device ( struct device * dev ) ;

void transport_configure_device ( struct device * dev ) ;

void transport_remove_device ( struct device * dev ) ;

void transport_destroy_device ( struct device * dev ) ;

int devtmpfs_create_node ( struct device * dev ) ;

int devtmpfs_delete_node ( struct device * dev ) ;

int devtmpfs_mount ( const char * mountpoint ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) devtmpfs_init ( void ) ;

int dpm_sysfs_add ( struct device * dev ) ;

void dpm_sysfs_remove ( struct device * dev ) ;

void device_pm_init ( struct device * dev ) ;

void device_pm_lock ( void ) ;

void device_pm_unlock ( void ) ;

void device_pm_add ( struct device * dev ) ;

void device_pm_remove ( struct device * dev ) ;

void device_pm_move_before ( struct device * deva , struct device * devb ) ;

void device_pm_move_after ( struct device * deva , struct device * devb ) ;

void device_pm_move_last ( struct device * dev ) ;

void dpm_resume_noirq ( pm_message_t state ) ;

void dpm_resume_end ( pm_message_t state ) ;

int dpm_suspend_noirq ( pm_message_t state ) ;

int dpm_suspend_start ( pm_message_t state ) ;

void __suspend_report_result ( const char * function , void * fn , int ret ) ;

int pm_runtime_idle ( struct device * dev ) ;

int __pm_runtime_suspend ( struct device * dev , bool from_wq ) ;

int pm_runtime_suspend ( struct device * dev ) ;

int __pm_runtime_resume ( struct device * dev , bool from_wq ) ;

int pm_runtime_resume ( struct device * dev ) ;

int pm_request_idle ( struct device * dev ) ;

int pm_schedule_suspend ( struct device * dev , unsigned int delay ) ;

int pm_request_resume ( struct device * dev ) ;

int __pm_runtime_get ( struct device * dev , bool sync ) ;

int __pm_runtime_put ( struct device * dev , bool sync ) ;

int __pm_runtime_set_status ( struct device * dev , unsigned int status ) ;

int pm_runtime_barrier ( struct device * dev ) ;

void __pm_runtime_disable ( struct device * dev , bool check_resume ) ;

void pm_runtime_enable ( struct device * dev ) ;

void pm_runtime_init ( struct device * dev ) ;

void pm_runtime_remove ( struct device * dev ) ;

void set_trace_device ( struct device * dev ) ;

void generate_resume_trace ( const void * tracedata , unsigned int user ) ;

struct dma_devres { size_t size ; void * vaddr ; dma_addr_t dma_handle ; } ;

void * dmam_alloc_coherent ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t gfp ) ;

void dmam_free_coherent ( struct device * dev , size_t size , void * vaddr , dma_addr_t dma_handle ) ;

void * dmam_alloc_noncoherent ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t gfp ) ;

void dmam_free_noncoherent ( struct device * dev , size_t size , void * vaddr , dma_addr_t dma_handle ) ;

struct firmware { size_t size ; const u8 * data ; struct page * * pages ; } ;

struct builtin_fw { char * name ; void * data ; unsigned long size ; } ;

; ; ; enum { FW_STATUS_LOADING , FW_STATUS_DONE , FW_STATUS_ABORT , } ;
struct firmware_priv { char * fw_id ; struct completion completion ; struct bin_attribute attr_data ; struct firmware * fw ; unsigned long status ; struct page * * pages ; int nr_pages ; int page_array_size ; const char * vdata ; struct timer_list timeout ; } ;

int request_firmware ( const struct firmware * * firmware_p , const char * name , struct device * device ) ;

void release_firmware ( const struct firmware * fw ) ;

struct firmware_work { struct work_struct work ; struct module * module ; const char * name ; struct device * device ; void * context ; void ( * cont ) ( const struct firmware * fw , void * context ) ; int uevent ; } ;

int request_firmware_nowait ( struct module * module , int uevent , const char * name , struct device * device , void * context , void ( * cont ) ( const struct firmware * fw , void * context ) ) ;

int register_node ( struct node * node , int num , struct node * parent ) ;

void unregister_node ( struct node * node ) ;

int register_cpu_under_node ( unsigned int cpu , unsigned int nid ) ;

int unregister_cpu_under_node ( unsigned int cpu , unsigned int nid ) ;

int register_mem_sect_under_node ( struct memory_block * mem_blk , int nid ) ;

int unregister_mem_sect_under_nodes ( struct memory_block * mem_blk ) ;

int register_one_node ( int nid ) ;

void unregister_one_node ( int nid ) ;

int register_memory_notifier ( struct notifier_block * nb ) ;

void unregister_memory_notifier ( struct notifier_block * nb ) ;

int memory_notify ( unsigned long val , void * v ) ;
struct memory_block * find_memory_block ( struct mem_section * section ) ;

int remove_memory_block ( unsigned long node_id , struct mem_section * section , int phys_device ) ;

int register_new_memory ( int nid , struct mem_section * section ) ;

int unregister_memory_section ( struct mem_section * section ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) memory_dev_init ( void ) ;

void register_iommu ( struct iommu_ops * ops ) ;

bool iommu_found ( void ) ;

struct iommu_domain * iommu_domain_alloc ( void ) ;

void iommu_domain_free ( struct iommu_domain * domain ) ;

int iommu_attach_device ( struct iommu_domain * domain , struct device * dev ) ;

void iommu_detach_device ( struct iommu_domain * domain , struct device * dev ) ;

int iommu_map_range ( struct iommu_domain * domain , unsigned long iova , phys_addr_t paddr , size_t size , int prot ) ;

void iommu_unmap_range ( struct iommu_domain * domain , unsigned long iova , size_t size ) ;

phys_addr_t iommu_iova_to_phys ( struct iommu_domain * domain , unsigned long iova ) ;

int iommu_domain_has_cap ( struct iommu_domain * domain , unsigned long cap ) ;

void module_add_driver ( struct module * mod , struct device_driver * drv ) ;

void module_remove_driver ( struct device_driver * drv ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) hypervisor_init ( void ) ;

struct brd_device { int brd_number ; int brd_refcnt ; loff_t brd_offset ; loff_t brd_sizelimit ; unsigned brd_blocksize ; struct request_queue * brd_queue ; struct gendisk * brd_disk ; struct list_head brd_list ; spinlock_t brd_lock ; struct radix_tree_root brd_pages ; } ;

struct lo_read_data { struct loop_device * lo ; struct page * page ; unsigned offset ; int bsize ; } ;

struct switch_request { struct file * file ; struct completion wait ; } ;

struct compat_loop_info { compat_int_t lo_number ; compat_dev_t lo_device ; compat_ulong_t lo_inode ; compat_dev_t lo_rdevice ; compat_int_t lo_offset ; compat_int_t lo_encrypt_type ; compat_int_t lo_encrypt_key_size ; compat_int_t lo_flags ; char lo_name [ 64 ] ; unsigned char lo_encrypt_key [ 32 ] ; compat_ulong_t lo_init [ 2 ] ; char reserved [ 4 ] ; } ;

int loop_register_transfer ( struct loop_func_table * funcs ) ;

int loop_unregister_transfer ( int number ) ;

struct virtqueue { struct list_head list ; void ( * callback ) ( struct virtqueue * vq ) ; const char * name ; struct virtio_device * vdev ; struct virtqueue_ops * vq_ops ; void * priv ; } ;

struct virtqueue_ops { int ( * add_buf ) ( struct virtqueue * vq , struct scatterlist sg [ ] , unsigned int out_num , unsigned int in_num , void * data ) ; void ( * kick ) ( struct virtqueue * vq ) ; void * ( * get_buf ) ( struct virtqueue * vq , unsigned int * len ) ; void ( * disable_cb ) ( struct virtqueue * vq ) ; bool ( * enable_cb ) ( struct virtqueue * vq ) ; } ;

struct virtio_device { int index ; struct device dev ; struct virtio_device_id id ; struct virtio_config_ops * config ; struct list_head vqs ; unsigned long features [ 1 ] ; void * priv ; } ;

struct virtio_driver { struct device_driver driver ; const struct virtio_device_id * id_table ; const unsigned int * feature_table ; unsigned int feature_table_size ; int ( * probe ) ( struct virtio_device * dev ) ; void ( * remove ) ( struct virtio_device * dev ) ; void ( * config_changed ) ( struct virtio_device * dev ) ; } ;

typedef void vq_callback_t ( struct virtqueue * ) ;

struct virtio_config_ops { void ( * get ) ( struct virtio_device * vdev , unsigned offset , void * buf , unsigned len ) ; void ( * set ) ( struct virtio_device * vdev , unsigned offset , const void * buf , unsigned len ) ; u8 ( * get_status ) ( struct virtio_device * vdev ) ; void ( * set_status ) ( struct virtio_device * vdev , u8 status ) ; void ( * reset ) ( struct virtio_device * vdev ) ; int ( * find_vqs ) ( struct virtio_device * , unsigned nvqs , struct virtqueue * vqs [ ] , vq_callback_t * callbacks [ ] , const char * names [ ] ) ; void ( * del_vqs ) ( struct virtio_device * ) ; u32 ( * get_features ) ( struct virtio_device * vdev ) ; void ( * finalize_features ) ( struct virtio_device * vdev ) ; } ;

struct virtio_blk_config { __u64 capacity ; __u32 size_max ; __u32 seg_max ; struct virtio_blk_geometry { __u16 cylinders ; __u8 heads ; __u8 sectors ; } geometry ; __u32 blk_size ; } __attribute__ ( ( packed ) ) ;
struct virtio_blk_outhdr { __u32 type ; __u32 ioprio ; __u64 sector ; } ;

struct virtio_scsi_inhdr { __u32 errors ; __u32 data_len ; __u32 sense_len ; __u32 residual ; } ;

struct virtio_blk { spinlock_t lock ; struct virtio_device * vdev ; struct virtqueue * vq ; struct gendisk * disk ; struct list_head reqs ; mempool_t * pool ; unsigned int sg_elems ; struct scatterlist sg [ ] ; } ;

struct virtblk_req { struct list_head list ; struct request * req ; struct virtio_blk_outhdr out_hdr ; struct virtio_scsi_inhdr in_hdr ; u8 status ; } ;


typedef void ( * done_f ) ( int ) ;

typedef void ( * timeout_fn ) ( unsigned long ) ;

irqreturn_t floppy_interrupt ( int irq , void * dev_id ) ;



int register_cdrom ( struct cdrom_device_info * cdi ) ;

void unregister_cdrom ( struct cdrom_device_info * cdi ) ;

int cdrom_get_media_event ( struct cdrom_device_info * cdi , struct media_event_desc * med ) ;

int cdrom_open ( struct cdrom_device_info * cdi , struct block_device * bdev , fmode_t mode ) ;

void cdrom_release ( struct cdrom_device_info * cdi , fmode_t mode ) ;

int cdrom_number_of_slots ( struct cdrom_device_info * cdi ) ;

int cdrom_media_changed ( struct cdrom_device_info * cdi ) ;

void init_cdrom_command ( struct packet_command * cgc , void * buf , int len , int type ) ;

int cdrom_mode_sense ( struct cdrom_device_info * cdi , struct packet_command * cgc , int page_code , int page_control ) ;

int cdrom_mode_select ( struct cdrom_device_info * cdi , struct packet_command * cgc ) ;

int cdrom_ioctl ( struct cdrom_device_info * cdi , struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) ;

int cdrom_get_last_written ( struct cdrom_device_info * cdi , long * last_written ) ;


enum cdrom_print_option { CTL_NAME , CTL_SPEED , CTL_SLOTS , CTL_CAPABILITY } ;

void __attribute__ ( ( weak ) ) unxlate_dev_mem_ptr ( unsigned long phys , void * addr ) ;
int __attribute__ ( ( weak ) ) phys_mem_access_prot_allowed ( struct file * file , unsigned long pfn , unsigned long size , pgprot_t * vma_prot ) ;


struct entropy_store ;

struct entropy_store { struct poolinfo * poolinfo ; __u32 * pool ; const char * name ; int limit ; struct entropy_store * pull ; spinlock_t lock ; unsigned add_ptr ; int entropy_count ; int input_rotate ; __u8 * last_data ; } ;
struct timer_rand_state { cycles_t last_time ; long last_delta , last_delta2 ; unsigned dont_count_entropy : 1 ; } ;
void add_input_randomness ( unsigned int type , unsigned int code , unsigned int value ) ;

void add_interrupt_randomness ( int irq ) ;

void add_disk_randomness ( struct gendisk * disk ) ;

void get_random_bytes ( void * buf , int nbytes ) ;

void rand_initialize_irq ( int irq ) ;

void rand_initialize_disk ( struct gendisk * disk ) ;

void generate_random_uuid ( unsigned char uuid_out [ 16 ] ) ;


__u32 secure_tcpv6_sequence_number ( __be32 * saddr , __be32 * daddr , __be16 sport , __be16 dport ) ;

__u32 secure_ip_id ( __be32 daddr ) ;

__u32 secure_tcp_sequence_number ( __be32 saddr , __be32 daddr , __be16 sport , __be16 dport ) ;

u32 secure_ipv4_port_ephemeral ( __be32 saddr , __be32 daddr , __be16 dport ) ;

u32 secure_ipv6_port_ephemeral ( const __be32 * saddr , const __be32 * daddr , __be16 dport ) ;

unsigned int get_random_int ( void ) ;

unsigned long randomize_range ( unsigned long start , unsigned long end , unsigned long len ) ;

struct tiocl_selection { unsigned short xs ; unsigned short ys ; unsigned short xe ; unsigned short ye ; unsigned short sel_mode ; } ;

struct tty_struct * alloc_tty_struct ( void ) ;

void free_tty_struct ( struct tty_struct * tty ) ;

char * tty_name ( struct tty_struct * tty , char * buf ) ;

int tty_paranoia_check ( struct tty_struct * tty , struct inode * inode , const char * routine ) ;

struct tty_driver * tty_find_polling_driver ( char * name , int * line ) ;

int tty_check_change ( struct tty_struct * tty ) ;

void tty_wakeup ( struct tty_struct * tty ) ;

void tty_hangup ( struct tty_struct * tty ) ;

void tty_vhangup ( struct tty_struct * tty ) ;

void tty_vhangup_self ( void ) ;

int tty_hung_up_p ( struct file * filp ) ;

void disassociate_ctty ( int on_exit ) ;

void no_tty ( void ) ;

void stop_tty ( struct tty_struct * tty ) ;

void start_tty ( struct tty_struct * tty ) ;

void tty_write_unlock ( struct tty_struct * tty ) ;

int tty_write_lock ( struct tty_struct * tty , int ndelay ) ;

void tty_write_message ( struct tty_struct * tty , char * msg ) ;

ssize_t redirected_tty_write ( struct file * file , const char * buf , size_t count , loff_t * ppos ) ;

int tty_init_termios ( struct tty_struct * tty ) ;

struct tty_struct * tty_init_dev ( struct tty_driver * driver , int idx , int first_ok ) ;

void tty_free_termios ( struct tty_struct * tty ) ;

void tty_shutdown ( struct tty_struct * tty ) ;

void tty_kref_put ( struct tty_struct * tty ) ;

void tty_release_dev ( struct file * filp ) ;

int tty_do_resize ( struct tty_struct * tty , struct winsize * ws ) ;

struct pid * tty_get_pgrp ( struct tty_struct * tty ) ;

struct tty_struct * tty_pair_get_tty ( struct tty_struct * tty ) ;

struct tty_struct * tty_pair_get_pty ( struct tty_struct * tty ) ;

long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) ;

void __do_SAK ( struct tty_struct * tty ) ;

void do_SAK ( struct tty_struct * tty ) ;

void initialize_tty_struct ( struct tty_struct * tty , struct tty_driver * driver , int idx ) ;

int tty_put_char ( struct tty_struct * tty , unsigned char ch ) ;

struct device * tty_register_device ( struct tty_driver * driver , unsigned index , struct device * device ) ;

void tty_unregister_device ( struct tty_driver * driver , unsigned index ) ;

struct tty_driver * alloc_tty_driver ( int lines ) ;

void tty_driver_kref_put ( struct tty_driver * driver ) ;

void tty_set_operations ( struct tty_driver * driver , const struct tty_operations * op ) ;

void put_tty_driver ( struct tty_driver * d ) ;

int tty_register_driver ( struct tty_driver * driver ) ;

int tty_unregister_driver ( struct tty_driver * driver ) ;

dev_t tty_devnum ( struct tty_struct * tty ) ;

void proc_clear_tty ( struct task_struct * p ) ;

struct tty_struct * get_current_tty ( void ) ;

void tty_default_fops ( struct file_operations * fops ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) console_init ( void ) ;

int is_ignored ( int sig ) ;

int tty_chars_in_buffer ( struct tty_struct * tty ) ;

int tty_write_room ( struct tty_struct * tty ) ;

void tty_driver_flush_buffer ( struct tty_struct * tty ) ;

void tty_throttle ( struct tty_struct * tty ) ;

void tty_unthrottle ( struct tty_struct * tty ) ;

void tty_wait_until_sent ( struct tty_struct * tty , long timeout ) ;

speed_t tty_termios_baud_rate ( struct ktermios * termios ) ;

speed_t tty_termios_input_baud_rate ( struct ktermios * termios ) ;

void tty_termios_encode_baud_rate ( struct ktermios * termios , speed_t ibaud , speed_t obaud ) ;

void tty_encode_baud_rate ( struct tty_struct * tty , speed_t ibaud , speed_t obaud ) ;

speed_t tty_get_baud_rate ( struct tty_struct * tty ) ;

void tty_termios_copy_hw ( struct ktermios * new , struct ktermios * old ) ;

int tty_termios_hw_change ( struct ktermios * a , struct ktermios * b ) ;

int tty_mode_ioctl ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) ;

int tty_perform_flush ( struct tty_struct * tty , unsigned long arg ) ;

int n_tty_ioctl_helper ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) ;

int tty_register_ldisc ( int disc , struct tty_ldisc_ops * new_ldisc ) ;

int tty_unregister_ldisc ( int disc ) ;

struct tty_ldisc * tty_ldisc_ref_wait ( struct tty_struct * tty ) ;

struct tty_ldisc * tty_ldisc_ref ( struct tty_struct * tty ) ;

void tty_ldisc_deref ( struct tty_ldisc * ld ) ;

void tty_ldisc_enable ( struct tty_struct * tty ) ;

void tty_ldisc_flush ( struct tty_struct * tty ) ;

int tty_set_ldisc ( struct tty_struct * tty , int ldisc ) ;

void tty_ldisc_hangup ( struct tty_struct * tty ) ;

int tty_ldisc_setup ( struct tty_struct * tty , struct tty_struct * o_tty ) ;

void tty_ldisc_release ( struct tty_struct * tty , struct tty_struct * o_tty ) ;

void tty_ldisc_init ( struct tty_struct * tty ) ;

void tty_ldisc_begin ( void ) ;

void tty_buffer_free_all ( struct tty_struct * tty ) ;

void tty_buffer_flush ( struct tty_struct * tty ) ;

int tty_buffer_request_room ( struct tty_struct * tty , size_t size ) ;

int tty_insert_flip_string ( struct tty_struct * tty , const unsigned char * chars , size_t size ) ;

int tty_insert_flip_string_flags ( struct tty_struct * tty , const unsigned char * chars , const char * flags , size_t size ) ;

void tty_schedule_flip ( struct tty_struct * tty ) ;

int tty_prepare_flip_string ( struct tty_struct * tty , unsigned char * * chars , size_t size ) ;

int tty_prepare_flip_string_flags ( struct tty_struct * tty , unsigned char * * chars , char * * flags , size_t size ) ;

void tty_flush_to_ldisc ( struct tty_struct * tty ) ;

void tty_flip_buffer_push ( struct tty_struct * tty ) ;

void tty_buffer_init ( struct tty_struct * tty ) ;

void tty_port_init ( struct tty_port * port ) ;

int tty_port_alloc_xmit_buf ( struct tty_port * port ) ;

void tty_port_free_xmit_buf ( struct tty_port * port ) ;

struct tty_struct * tty_port_tty_get ( struct tty_port * port ) ;

void tty_port_tty_set ( struct tty_port * port , struct tty_struct * tty ) ;

void tty_port_hangup ( struct tty_port * port ) ;

int tty_port_carrier_raised ( struct tty_port * port ) ;

void tty_port_raise_dtr_rts ( struct tty_port * port ) ;

void tty_port_lower_dtr_rts ( struct tty_port * port ) ;

int tty_port_block_til_ready ( struct tty_port * port , struct tty_struct * tty , struct file * filp ) ;

int tty_port_close_start ( struct tty_port * port , struct tty_struct * tty , struct file * filp ) ;

void tty_port_close_end ( struct tty_port * port , struct tty_struct * tty ) ;

void tty_port_close ( struct tty_port * port , struct tty_struct * tty , struct file * filp ) ;

int pty_resize ( struct tty_struct * tty , struct winsize * ws ) ;

int misc_register ( struct miscdevice * misc ) ;

int misc_deregister ( struct miscdevice * misc ) ;

struct vt_event_wait { struct list_head list ; struct vt_event event ; int done ; } ;

void vt_event_post ( unsigned int event , unsigned int old , unsigned int new ) ;

int vt_waitactive ( int n ) ;

int vt_ioctl ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) ;

void reset_vc ( struct vc_data * vc ) ;

void vc_SAK ( struct work_struct * work ) ;

struct compat_consolefontdesc { unsigned short charcount ; unsigned short charheight ; compat_caddr_t chardata ; } ;

struct compat_console_font_op { compat_uint_t op ; compat_uint_t flags ; compat_uint_t width , height ; compat_uint_t charcount ; compat_caddr_t data ; } ;

struct compat_unimapdesc { unsigned short entry_ct ; compat_caddr_t entries ; } ;

long vt_compat_ioctl ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) ;

void change_console ( struct vc_data * new_vc ) ;

int vt_move_to_console ( unsigned int vt , int alloc ) ;

void pm_set_vt_switch ( int do_switch ) ;

void vcs_make_sysfs ( int index ) ;

void vcs_remove_sysfs ( int index ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) vcs_init ( void ) ;

void clear_selection ( void ) ;

int sel_loadlut ( char * p ) ;

int set_selection ( const struct tiocl_selection * sel , struct tty_struct * tty ) ;

int paste_selection ( struct tty_struct * tty ) ;

typedef void ( k_handler_fn ) ( struct vc_data * vc , unsigned char value , char up_flag ) ;
typedef void ( fn_handler_fn ) ( struct vc_data * vc ) ;

int register_keyboard_notifier ( struct notifier_block * nb ) ;

int unregister_keyboard_notifier ( struct notifier_block * nb ) ;

int getkeycode ( unsigned int scancode ) ;

int setkeycode ( unsigned int scancode , unsigned int keycode ) ;

void kd_mksound ( unsigned int hz , unsigned int ticks ) ;

int kbd_rate ( struct kbd_repeat * rep ) ;

void compute_shiftstate ( void ) ;

unsigned char getledstate ( void ) ;

void setledstate ( struct kbd_struct * kbd , unsigned int led ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) kbd_init ( void ) ;

struct uni_pagedir { u16 * * uni_pgdir [ 32 ] ; unsigned long refcount ; unsigned long sum ; unsigned char * inverse_translations [ 4 ] ; u16 * inverse_trans_unicode ; int readonly ; } ;

unsigned short * set_translate ( int m , struct vc_data * vc ) ;

u16 inverse_translate ( struct vc_data * conp , int glyph , int use_unicode ) ;

int con_set_trans_old ( unsigned char * arg ) ;

int con_get_trans_old ( unsigned char * arg ) ;

int con_set_trans_new ( ushort * arg ) ;

int con_get_trans_new ( ushort * arg ) ;

void con_free_unimap ( struct vc_data * vc ) ;

int con_clear_unimap ( struct vc_data * vc , struct unimapinit * ui ) ;

int con_set_unimap ( struct vc_data * vc , ushort ct , struct unipair * list ) ;

int con_set_default_unimap ( struct vc_data * vc ) ;

int con_copy_unimap ( struct vc_data * dst_vc , struct vc_data * src_vc ) ;

int con_get_unimap ( struct vc_data * vc , ushort ct , ushort * uct , struct unipair * list ) ;

void con_protect_unimap ( struct vc_data * vc , int rdonly ) ;

u32 conv_8bit_to_uni ( unsigned char c ) ;

int conv_uni_to_8bit ( u32 uni ) ;

int conv_uni_to_pc ( struct vc_data * conp , long ucs ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) console_map_init ( void ) ;

struct font_desc { int idx ; const char * name ; int width , height ; const void * data ; int pref ; } ;

struct con_driver { const struct consw * con ; const char * desc ; struct device * dev ; int node ; int first ; int last ; int flag ; } ;

enum { blank_off = 0 , blank_normal_wait , blank_vesa_wait , } ;
int register_vt_notifier ( struct notifier_block * nb ) ;

int unregister_vt_notifier ( struct notifier_block * nb ) ;

void schedule_console_callback ( void ) ;

void update_region ( struct vc_data * vc , unsigned long start , int count ) ;

void invert_screen ( struct vc_data * vc , int offset , int count , int viewed ) ;

void complement_pos ( struct vc_data * vc , int offset ) ;

void redraw_screen ( struct vc_data * vc , int is_switch ) ;

int vc_cons_allocated ( unsigned int i ) ;

int vc_allocate ( unsigned int currcons ) ;

int vc_resize ( struct vc_data * vc , unsigned int cols , unsigned int rows ) ;

void vc_deallocate ( unsigned int currcons ) ;

void scrollback ( struct vc_data * vc , int lines ) ;

void scrollfront ( struct vc_data * vc , int lines ) ;

void mouse_report ( struct tty_struct * tty , int butt , int mrx , int mry ) ;

int mouse_reporting ( void ) ;

enum { ESnormal , ESesc , ESsquare , ESgetpars , ESgotpars , ESfunckey , EShash , ESsetG0 , ESsetG1 , ESpercent , ESignore , ESnonstd , ESpalette } ;
struct interval { uint32_t first ; uint32_t last ; } ;

int set_console ( int nr ) ;

int tioclinux ( struct tty_struct * tty , unsigned long arg ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) vty_init ( const struct file_operations * console_fops ) ;

int unbind_con_driver ( const struct consw * csw , int first , int last , int deflt ) ;

int con_is_bound ( const struct consw * csw ) ;

int register_con_driver ( const struct consw * csw , int first , int last ) ;

int unregister_con_driver ( const struct consw * csw ) ;

int take_over_console ( const struct consw * csw , int first , int last , int deflt ) ;

void give_up_console ( const struct consw * csw ) ;

void do_blank_screen ( int entering_gfx ) ;

void do_unblank_screen ( int leaving_gfx ) ;

void unblank_screen ( void ) ;

void poke_blanked_console ( void ) ;

int con_set_cmap ( unsigned char * arg ) ;

int con_get_cmap ( unsigned char * arg ) ;

void reset_palette ( struct vc_data * vc ) ;

int con_font_op ( struct vc_data * vc , struct console_font_op * op ) ;

u16 screen_glyph ( struct vc_data * vc , int offset ) ;

unsigned short * screen_pos ( struct vc_data * vc , int w_offset , int viewed ) ;

void getconsxy ( struct vc_data * vc , unsigned char * p ) ;

void putconsxy ( struct vc_data * vc , unsigned char * p ) ;

u16 vcs_scr_readw ( struct vc_data * vc , const u16 * org ) ;

void vcs_scr_writew ( struct vc_data * vc , u16 val , u16 * org ) ;

struct tty_audit_buf { atomic_t count ; struct mutex mutex ; int major , minor ; unsigned icanon : 1 ; size_t valid ; unsigned char * data ; } ;

void tty_audit_exit ( void ) ;

void tty_audit_fork ( struct signal_struct * sig ) ;

void tty_audit_tiocsti ( struct tty_struct * tty , char ch ) ;

void tty_audit_push_task ( struct task_struct * tsk , uid_t loginuid , u32 sessionid ) ;

void tty_audit_add_data ( struct tty_struct * tty , unsigned char * data , size_t size ) ;

void tty_audit_push ( struct tty_struct * tty ) ;

int sysrq_on ( void ) ;

struct sysrq_key_op * __sysrq_get_key_op ( int key ) ;

void __handle_sysrq ( int key , struct tty_struct * tty , int check_mask ) ;

void handle_sysrq ( int key , struct tty_struct * tty ) ;

int register_sysrq_key ( int key , struct sysrq_key_op * op_p ) ;

int unregister_sysrq_key ( int key , struct sysrq_key_op * op_p ) ;

struct hvc_struct { spinlock_t lock ; int index ; struct tty_struct * tty ; int count ; int do_wakeup ; char * outbuf ; int outbuf_size ; int n_outbuf ; uint32_t vtermno ; struct hv_ops * ops ; int irq_requested ; int data ; struct winsize ws ; struct work_struct tty_resize ; struct list_head next ; struct kref kref ; } ;

struct hv_ops { int ( * get_chars ) ( uint32_t vtermno , char * buf , int count ) ; int ( * put_chars ) ( uint32_t vtermno , const char * buf , int count ) ; int ( * notifier_add ) ( struct hvc_struct * hp , int irq ) ; void ( * notifier_del ) ( struct hvc_struct * hp , int irq ) ; void ( * notifier_hangup ) ( struct hvc_struct * hp , int irq ) ; } ;

int hvc_instantiate ( uint32_t vtermno , int index , struct hv_ops * ops ) ;

void hvc_kick ( void ) ;

int hvc_poll ( struct hvc_struct * hp ) ;

void __hvc_resize ( struct hvc_struct * hp , struct winsize ws ) ;

struct hvc_struct __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) * hvc_alloc ( uint32_t vtermno , int data , struct hv_ops * ops , int outbuf_size ) ;

int hvc_remove ( struct hvc_struct * hp ) ;

int notifier_add_irq ( struct hvc_struct * hp , int irq ) ;

void notifier_del_irq ( struct hvc_struct * hp , int irq ) ;

void notifier_hangup_irq ( struct hvc_struct * hp , int irq ) ;


typedef uint32_t XENCONS_RING_IDX ;

struct xencons_interface { char in [ 1024 ] ; char out [ 2048 ] ; XENCONS_RING_IDX in_cons , in_prod ; XENCONS_RING_IDX out_cons , out_prod ; } ;

void xen_console_resume ( void ) ;

void xen_raw_console_write ( const char * str ) ;

void xen_raw_printk ( const char * fmt , ... ) ;

struct hpet_dev { struct hpets * hd_hpets ; struct hpet * hd_hpet ; struct hpet_timer * hd_timer ; unsigned long hd_ireqfreq ; unsigned long hd_irqdata ; wait_queue_head_t hd_waitqueue ; struct fasync_struct * hd_async_queue ; unsigned int hd_flags ; unsigned int hd_irq ; unsigned int hd_hdwirq ; char hd_name [ ( 7 ) ] ; } ;
struct hpets { struct hpets * hp_next ; struct hpet * hp_hpet ; unsigned long hp_hpet_phys ; struct clocksource * hp_clocksource ; unsigned long long hp_tick_freq ; unsigned long hp_delta ; unsigned int hp_ntimer ; unsigned int hp_which ; struct hpet_dev hp_dev [ 1 ] ; } ;

int hpet_alloc ( struct hpet_data * hdp ) ;

struct agp_info { struct agp_version version ; u32 bridge_id ; u32 agp_mode ; unsigned long aper_base ; size_t aper_size ; size_t pg_total ; size_t pg_system ; size_t pg_used ; } ;

struct agp_setup { u32 agp_mode ; } ;

struct agp_segment { off_t pg_start ; size_t pg_count ; int prot ; } ;

struct agp_segment_priv { off_t pg_start ; size_t pg_count ; pgprot_t prot ; } ;

struct agp_region { pid_t pid ; size_t seg_count ; struct agp_segment * seg_list ; } ;

struct agp_allocate { int key ; size_t pg_count ; u32 type ; u32 physical ; } ;

struct agp_bind { int key ; off_t pg_start ; } ;

struct agp_unbind { int key ; u32 priority ; } ;

struct agp_client { struct agp_client * next ; struct agp_client * prev ; pid_t pid ; int num_segments ; struct agp_segment_priv * * segments ; } ;

struct agp_controller { struct agp_controller * next ; struct agp_controller * prev ; pid_t pid ; int num_clients ; struct agp_memory * pool ; struct agp_client * clients ; } ;

struct agp_file_private { struct agp_file_private * next ; struct agp_file_private * prev ; pid_t my_pid ; unsigned long access_flags ; } ;

struct agp_front_data { struct mutex agp_mutex ; struct agp_controller * current_controller ; struct agp_controller * controllers ; struct agp_file_private * file_priv_list ; bool used_by_controller ; bool backend_acquired ; } ;

enum aper_size_type { U8_APER_SIZE , U16_APER_SIZE , U32_APER_SIZE , LVL2_APER_SIZE , FIXED_APER_SIZE } ;

struct gatt_mask { unsigned long mask ; u32 type ; } ;

struct aper_size_info_8 { int size ; int num_entries ; int page_order ; u8 size_value ; } ;

struct aper_size_info_16 { int size ; int num_entries ; int page_order ; u16 size_value ; } ;

struct aper_size_info_32 { int size ; int num_entries ; int page_order ; u32 size_value ; } ;

struct aper_size_info_lvl2 { int size ; int num_entries ; u32 size_value ; } ;

struct aper_size_info_fixed { int size ; int num_entries ; int page_order ; } ;

struct agp_bridge_driver { struct module * owner ; const void * aperture_sizes ; int num_aperture_sizes ; enum aper_size_type size_type ; bool cant_use_aperture ; bool needs_scratch_page ; const struct gatt_mask * masks ; int ( * fetch_size ) ( void ) ; int ( * configure ) ( void ) ; void ( * agp_enable ) ( struct agp_bridge_data * , u32 ) ; void ( * cleanup ) ( void ) ; void ( * tlb_flush ) ( struct agp_memory * ) ; unsigned long ( * mask_memory ) ( struct agp_bridge_data * , dma_addr_t , int ) ; void ( * cache_flush ) ( void ) ; int ( * create_gatt_table ) ( struct agp_bridge_data * ) ; int ( * free_gatt_table ) ( struct agp_bridge_data * ) ; int ( * insert_memory ) ( struct agp_memory * , off_t , int ) ; int ( * remove_memory ) ( struct agp_memory * , off_t , int ) ; struct agp_memory * ( * alloc_by_type ) ( size_t , int ) ; void ( * free_by_type ) ( struct agp_memory * ) ; struct page * ( * agp_alloc_page ) ( struct agp_bridge_data * ) ; int ( * agp_alloc_pages ) ( struct agp_bridge_data * , struct agp_memory * , size_t ) ; void ( * agp_destroy_page ) ( struct page * , int flags ) ; void ( * agp_destroy_pages ) ( struct agp_memory * ) ; int ( * agp_type_to_mask_type ) ( struct agp_bridge_data * , int ) ; void ( * chipset_flush ) ( struct agp_bridge_data * ) ; int ( * agp_map_page ) ( struct page * page , dma_addr_t * ret ) ; void ( * agp_unmap_page ) ( struct page * page , dma_addr_t dma ) ; int ( * agp_map_memory ) ( struct agp_memory * mem ) ; void ( * agp_unmap_memory ) ( struct agp_memory * mem ) ; } ;

struct agp_bridge_data { const struct agp_version * version ; const struct agp_bridge_driver * driver ; const struct vm_operations_struct * vm_ops ; void * previous_size ; void * current_size ; void * dev_private_data ; struct pci_dev * dev ; u32 * gatt_table ; u32 * gatt_table_real ; unsigned long scratch_page ; struct page * scratch_page_page ; dma_addr_t scratch_page_dma ; unsigned long gart_bus_addr ; unsigned long gatt_bus_addr ; u32 mode ; enum chipset_type type ; unsigned long * key_list ; atomic_t current_memory_agp ; atomic_t agp_in_use ; int max_memory_agp ; int aperture_size_idx ; int capndx ; int flags ; char major_version ; char minor_version ; struct list_head list ; u32 apbase_config ; struct list_head mapped_list ; spinlock_t mapped_lock ; } ;
struct agp_device_ids { unsigned short device_id ; enum chipset_type chipset ; const char * chipset_name ; int ( * chipset_setup ) ( struct pci_dev * pdev ) ; } ;

struct agp_bridge_data * agp_backend_acquire ( struct pci_dev * pdev ) ;

void agp_backend_release ( struct agp_bridge_data * bridge ) ;

struct agp_bridge_data * agp_alloc_bridge ( void ) ;

void agp_put_bridge ( struct agp_bridge_data * bridge ) ;

int agp_add_bridge ( struct agp_bridge_data * bridge ) ;

void agp_remove_bridge ( struct agp_bridge_data * bridge ) ;

struct agp_memory * agp_find_mem_by_key ( int key ) ;

int agp_create_segment ( struct agp_client * client , struct agp_region * region ) ;

struct agp_file_private * agp_find_private ( pid_t pid ) ;

void agp_free_memory_wrap ( struct agp_memory * memory ) ;

struct agp_memory * agp_allocate_memory_wrap ( size_t pg_count , u32 type ) ;

struct agp_client * agp_find_client_by_pid ( pid_t id ) ;

struct agp_client * agp_create_client ( pid_t id ) ;

int agp_remove_client ( pid_t id ) ;

int agpioc_acquire_wrap ( struct agp_file_private * priv ) ;

int agpioc_release_wrap ( struct agp_file_private * priv ) ;

int agpioc_setup_wrap ( struct agp_file_private * priv , void * arg ) ;

int agpioc_protect_wrap ( struct agp_file_private * priv ) ;

int agpioc_deallocate_wrap ( struct agp_file_private * priv , int arg ) ;

int agpioc_chipset_flush_wrap ( struct agp_file_private * priv ) ;

int agp_frontend_initialize ( void ) ;

void agp_frontend_cleanup ( void ) ;

void agp_free_key ( int key ) ;

void agp_flush_chipset ( struct agp_bridge_data * bridge ) ;

void agp_alloc_page_array ( size_t size , struct agp_memory * mem ) ;

void agp_free_page_array ( struct agp_memory * mem ) ;

struct agp_memory * agp_create_memory ( int scratch_pages ) ;

void agp_free_memory ( struct agp_memory * curr ) ;

struct agp_memory * agp_allocate_memory ( struct agp_bridge_data * bridge , size_t page_count , u32 type ) ;

int agp_num_entries ( void ) ;

int agp_copy_info ( struct agp_bridge_data * bridge , struct agp_kern_info * info ) ;

int agp_bind_memory ( struct agp_memory * curr , off_t pg_start ) ;

int agp_unbind_memory ( struct agp_memory * curr ) ;

int agp_rebind_memory ( void ) ;

u32 agp_collect_device_status ( struct agp_bridge_data * bridge , u32 requested_mode , u32 bridge_agpstat ) ;

void agp_device_command ( u32 bridge_agpstat , bool agp_v3 ) ;

void get_agp_version ( struct agp_bridge_data * bridge ) ;

void agp_generic_enable ( struct agp_bridge_data * bridge , u32 requested_mode ) ;

int agp_generic_create_gatt_table ( struct agp_bridge_data * bridge ) ;

int agp_generic_free_gatt_table ( struct agp_bridge_data * bridge ) ;

int agp_generic_insert_memory ( struct agp_memory * mem , off_t pg_start , int type ) ;

int agp_generic_remove_memory ( struct agp_memory * mem , off_t pg_start , int type ) ;

struct agp_memory * agp_generic_alloc_by_type ( size_t page_count , int type ) ;

void agp_generic_free_by_type ( struct agp_memory * curr ) ;

struct agp_memory * agp_generic_alloc_user ( size_t page_count , int type ) ;

int agp_generic_alloc_pages ( struct agp_bridge_data * bridge , struct agp_memory * mem , size_t num_pages ) ;

struct page * agp_generic_alloc_page ( struct agp_bridge_data * bridge ) ;

void agp_generic_destroy_pages ( struct agp_memory * mem ) ;

void agp_generic_destroy_page ( struct page * page , int flags ) ;

void agp_enable ( struct agp_bridge_data * bridge , u32 mode ) ;

struct agp_bridge_data * agp_generic_find_bridge ( struct pci_dev * pdev ) ;

void global_cache_flush ( void ) ;

unsigned long agp_generic_mask_memory ( struct agp_bridge_data * bridge , dma_addr_t addr , int type ) ;

int agp_generic_type_to_mask_type ( struct agp_bridge_data * bridge , int type ) ;

int agp3_generic_fetch_size ( void ) ;

void agp3_generic_tlbflush ( struct agp_memory * mem ) ;

int agp3_generic_configure ( void ) ;

void agp3_generic_cleanup ( void ) ;

struct agp_3_5_dev { struct list_head list ; u8 capndx ; u32 maxbw ; struct pci_dev * dev ; } ;

int agp_3_5_enable ( struct agp_bridge_data * bridge ) ;

struct agp_info32 { struct agp_version version ; u32 bridge_id ; u32 agp_mode ; compat_long_t aper_base ; compat_size_t aper_size ; compat_size_t pg_total ; compat_size_t pg_system ; compat_size_t pg_used ; } ;

struct agp_segment32 { compat_off_t pg_start ; compat_size_t pg_count ; compat_int_t prot ; } ;

struct agp_region32 { compat_pid_t pid ; compat_size_t seg_count ; struct agp_segment32 * seg_list ; } ;

struct agp_allocate32 { compat_int_t key ; compat_size_t pg_count ; u32 type ; u32 physical ; } ;

struct agp_bind32 { compat_int_t key ; compat_off_t pg_start ; } ;

struct agp_unbind32 { compat_int_t key ; u32 priority ; } ;

long compat_agp_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) agp_amd64_init ( void ) ;



struct hwrng { const char * name ; int ( * init ) ( struct hwrng * rng ) ; void ( * cleanup ) ( struct hwrng * rng ) ; int ( * data_present ) ( struct hwrng * rng , int wait ) ; int ( * data_read ) ( struct hwrng * rng , u32 * data ) ; unsigned long priv ; struct list_head list ; } ;

int hwrng_register ( struct hwrng * rng ) ;

void hwrng_unregister ( struct hwrng * rng ) ;

typedef enum { PARPORT_CLASS_LEGACY = 0 , PARPORT_CLASS_PRINTER , PARPORT_CLASS_MODEM , PARPORT_CLASS_NET , PARPORT_CLASS_HDC , PARPORT_CLASS_PCMCIA , PARPORT_CLASS_MEDIA , PARPORT_CLASS_FDC , PARPORT_CLASS_PORTS , PARPORT_CLASS_SCANNER , PARPORT_CLASS_DIGCAM , PARPORT_CLASS_OTHER , PARPORT_CLASS_UNSPEC , PARPORT_CLASS_SCSIADAPTER } parport_device_class ;

struct parport ;

struct pardevice ;

struct pc_parport_state { unsigned int ctr ; unsigned int ecr ; } ;

struct ax_parport_state { unsigned int ctr ; unsigned int ecr ; unsigned int dcsr ; } ;

struct amiga_parport_state { unsigned char data ; unsigned char datadir ; unsigned char status ; unsigned char statusdir ; } ;

struct ax88796_parport_state { unsigned char cpr ; } ;

struct ip32_parport_state { unsigned int dcr ; unsigned int ecr ; } ;

struct parport_state { union { struct pc_parport_state pc ; struct ax_parport_state ax ; struct amiga_parport_state amiga ; struct ax88796_parport_state ax88796 ; struct ip32_parport_state ip32 ; void * misc ; } u ; } ;

struct parport_operations { void ( * write_data ) ( struct parport * , unsigned char ) ; unsigned char ( * read_data ) ( struct parport * ) ; void ( * write_control ) ( struct parport * , unsigned char ) ; unsigned char ( * read_control ) ( struct parport * ) ; unsigned char ( * frob_control ) ( struct parport * , unsigned char mask , unsigned char val ) ; unsigned char ( * read_status ) ( struct parport * ) ; void ( * enable_irq ) ( struct parport * ) ; void ( * disable_irq ) ( struct parport * ) ; void ( * data_forward ) ( struct parport * ) ; void ( * data_reverse ) ( struct parport * ) ; void ( * init_state ) ( struct pardevice * , struct parport_state * ) ; void ( * save_state ) ( struct parport * , struct parport_state * ) ; void ( * restore_state ) ( struct parport * , struct parport_state * ) ; size_t ( * epp_write_data ) ( struct parport * port , const void * buf , size_t len , int flags ) ; size_t ( * epp_read_data ) ( struct parport * port , void * buf , size_t len , int flags ) ; size_t ( * epp_write_addr ) ( struct parport * port , const void * buf , size_t len , int flags ) ; size_t ( * epp_read_addr ) ( struct parport * port , void * buf , size_t len , int flags ) ; size_t ( * ecp_write_data ) ( struct parport * port , const void * buf , size_t len , int flags ) ; size_t ( * ecp_read_data ) ( struct parport * port , void * buf , size_t len , int flags ) ; size_t ( * ecp_write_addr ) ( struct parport * port , const void * buf , size_t len , int flags ) ; size_t ( * compat_write_data ) ( struct parport * port , const void * buf , size_t len , int flags ) ; size_t ( * nibble_read_data ) ( struct parport * port , void * buf , size_t len , int flags ) ; size_t ( * byte_read_data ) ( struct parport * port , void * buf , size_t len , int flags ) ; struct module * owner ; } ;

struct parport_device_info { parport_device_class class ; const char * class_name ; const char * mfr ; const char * model ; const char * cmdset ; const char * description ; } ;

struct pardevice { const char * name ; struct parport * port ; int daisy ; int ( * preempt ) ( void * ) ; void ( * wakeup ) ( void * ) ; void * private ; void ( * irq_func ) ( void * ) ; unsigned int flags ; struct pardevice * next ; struct pardevice * prev ; struct parport_state * state ; wait_queue_head_t wait_q ; unsigned long int time ; unsigned long int timeslice ; volatile long int timeout ; unsigned long waiting ; struct pardevice * waitprev ; struct pardevice * waitnext ; void * sysctl_table ; } ;
enum ieee1284_phase { IEEE1284_PH_FWD_DATA , IEEE1284_PH_FWD_IDLE , IEEE1284_PH_TERMINATE , IEEE1284_PH_NEGOTIATION , IEEE1284_PH_HBUSY_DNA , IEEE1284_PH_REV_IDLE , IEEE1284_PH_HBUSY_DAVAIL , IEEE1284_PH_REV_DATA , IEEE1284_PH_ECP_SETUP , IEEE1284_PH_ECP_FWD_TO_REV , IEEE1284_PH_ECP_REV_TO_FWD , IEEE1284_PH_ECP_DIR_UNKNOWN , } ;

struct ieee1284_info { int mode ; volatile enum ieee1284_phase phase ; struct semaphore irq ; } ;

struct parport { unsigned long base ; unsigned long base_hi ; unsigned int size ; const char * name ; unsigned int modes ; int irq ; int dma ; int muxport ; int portnum ; struct device * dev ; struct parport * physport ; struct pardevice * devices ; struct pardevice * cad ; int daisy ; int muxsel ; struct pardevice * waithead ; struct pardevice * waittail ; struct list_head list ; unsigned int flags ; void * sysctl_table ; struct parport_device_info probe_info [ 5 ] ; struct ieee1284_info ieee1284 ; struct parport_operations * ops ; void * private_data ; int number ; spinlock_t pardevice_lock ; spinlock_t waitlist_lock ; rwlock_t cad_lock ; int spintime ; atomic_t ref_count ; unsigned long devflags ; struct pardevice * proc_device ; struct list_head full_list ; struct parport * slaves [ 3 ] ; } ;
struct parport_driver { const char * name ; void ( * attach ) ( struct parport * ) ; void ( * detach ) ( struct parport * ) ; struct list_head list ; } ;

struct parport_pc_private { unsigned char ctr ; unsigned char ctr_writable ; int ecr ; int fifo_depth ; int pword ; int readIntrThreshold ; int writeIntrThreshold ; char * dma_buf ; dma_addr_t dma_handle ; struct list_head list ; struct parport * port ; } ;

struct parport_pc_via_data { u8 via_pci_parport_irq_reg ; u8 via_pci_parport_dma_reg ; u8 via_pci_superio_config_reg ; u8 via_pci_superio_config_data ; u8 viacfg_function ; u8 viacfg_parport_control ; u8 viacfg_parport_base ; } ;

struct pp_struct { struct pardevice * pdev ; wait_queue_head_t irq_wait ; atomic_t irqc ; unsigned int flags ; int irqresponse ; unsigned char irqctl ; struct ieee1284_info state ; struct ieee1284_info saved_state ; long default_inactivity ; } ;

u32 acpi_pm_read_verified ( void ) ;

struct cb_id { __u32 idx ; __u32 val ; } ;

struct cn_msg { struct cb_id id ; __u32 seq ; __u32 ack ; __u16 len ; __u16 flags ; __u8 data [ 0 ] ; } ;

struct cn_queue_dev { atomic_t refcnt ; unsigned char name [ 32 ] ; struct workqueue_struct * cn_queue ; struct work_struct wq_creation ; atomic_t wq_requested ; wait_queue_head_t wq_created ; struct list_head queue_list ; spinlock_t queue_lock ; struct sock * nls ; } ;

struct cn_callback_id { unsigned char name [ 32 ] ; struct cb_id id ; } ;

struct cn_callback_data { struct sk_buff * skb ; void ( * callback ) ( struct cn_msg * , struct netlink_skb_parms * ) ; void * free ; } ;

struct cn_callback_entry { struct list_head callback_entry ; struct work_struct work ; struct cn_queue_dev * pdev ; struct cn_callback_id id ; struct cn_callback_data data ; u32 seq , group ; } ;

struct cn_dev { struct cb_id id ; u32 seq , groups ; struct sock * nls ; void ( * input ) ( struct sk_buff * skb ) ; struct cn_queue_dev * cbdev ; } ;

int queue_cn_work ( struct cn_callback_entry * cbq , struct work_struct * work ) ;

void cn_queue_wrapper ( struct work_struct * work ) ;

int cn_cb_equal ( struct cb_id * i1 , struct cb_id * i2 ) ;

int cn_queue_add_callback ( struct cn_queue_dev * dev , char * name , struct cb_id * id , void ( * callback ) ( struct cn_msg * , struct netlink_skb_parms * ) ) ;

void cn_queue_del_callback ( struct cn_queue_dev * dev , struct cb_id * id ) ;

struct cn_queue_dev * cn_queue_alloc_dev ( char * name , struct sock * nls ) ;

void cn_queue_free_dev ( struct cn_queue_dev * dev ) ;

int cn_netlink_send ( struct cn_msg * msg , u32 __group , gfp_t gfp_mask ) ;

int cn_add_callback ( struct cb_id * id , char * name , void ( * callback ) ( struct cn_msg * , struct netlink_skb_parms * ) ) ;

void cn_del_callback ( struct cb_id * id ) ;

void proc_fork_connector ( struct task_struct * task ) ;

void proc_exec_connector ( struct task_struct * task ) ;

void proc_id_connector ( struct task_struct * task , int which_id ) ;

void proc_sid_connector ( struct task_struct * task ) ;

void proc_exit_connector ( struct task_struct * task ) ;

int lock_policy_rwsem_read ( int cpu ) ;

int lock_policy_rwsem_write ( int cpu ) ;

void unlock_policy_rwsem_read ( int cpu ) ;

void unlock_policy_rwsem_write ( int cpu ) ;

struct cpufreq_policy * cpufreq_cpu_get ( unsigned int cpu ) ;

void cpufreq_cpu_put ( struct cpufreq_policy * data ) ;

void cpufreq_notify_transition ( struct cpufreq_freqs * freqs , unsigned int state ) ;

int cpufreq_add_dev_policy ( unsigned int cpu , struct cpufreq_policy * policy , struct sys_device * sys_dev ) ;

int cpufreq_add_dev_symlink ( unsigned int cpu , struct cpufreq_policy * policy ) ;

int cpufreq_add_dev_interface ( unsigned int cpu , struct cpufreq_policy * policy , struct sys_device * sys_dev ) ;

unsigned int cpufreq_quick_get ( unsigned int cpu ) ;

unsigned int cpufreq_get ( unsigned int cpu ) ;

int cpufreq_register_notifier ( struct notifier_block * nb , unsigned int list ) ;

int cpufreq_unregister_notifier ( struct notifier_block * nb , unsigned int list ) ;

int __cpufreq_driver_target ( struct cpufreq_policy * policy , unsigned int target_freq , unsigned int relation ) ;

int cpufreq_driver_target ( struct cpufreq_policy * policy , unsigned int target_freq , unsigned int relation ) ;

int __cpufreq_driver_getavg ( struct cpufreq_policy * policy , unsigned int cpu ) ;

int cpufreq_register_governor ( struct cpufreq_governor * governor ) ;

void cpufreq_unregister_governor ( struct cpufreq_governor * governor ) ;

int cpufreq_get_policy ( struct cpufreq_policy * policy , unsigned int cpu ) ;

int cpufreq_update_policy ( unsigned int cpu ) ;

int cpufreq_register_driver ( struct cpufreq_driver * driver_data ) ;

int cpufreq_unregister_driver ( struct cpufreq_driver * driver ) ;

struct cpufreq_stats { unsigned int cpu ; unsigned int total_trans ; unsigned long long last_time ; unsigned int max_state ; unsigned int state_num ; unsigned int last_index ; cputime64_t * time_in_state ; unsigned int * freq_table ; unsigned int * trans_table ; } ;

struct cpufreq_stats_attribute { struct attribute attr ; ssize_t ( * show ) ( struct cpufreq_stats * , char * ) ; } ;

enum { DBS_NORMAL_SAMPLE , DBS_SUB_SAMPLE } ;
struct cpu_dbs_info_s { cputime64_t prev_cpu_idle ; cputime64_t prev_cpu_wall ; cputime64_t prev_cpu_nice ; struct cpufreq_policy * cur_policy ; struct delayed_work work ; struct cpufreq_frequency_table * freq_table ; unsigned int freq_lo ; unsigned int freq_lo_jiffies ; unsigned int freq_hi_jiffies ; int cpu ; unsigned int sample_type : 1 ; struct mutex timer_mutex ; } ;


struct cpu_dbs_info_s { cputime64_t prev_cpu_idle ; cputime64_t prev_cpu_wall ; cputime64_t prev_cpu_nice ; struct cpufreq_policy * cur_policy ; struct delayed_work work ; unsigned int down_skip ; unsigned int requested_freq ; int cpu ; unsigned int enable : 1 ; struct mutex timer_mutex ; } ;
int cpufreq_frequency_table_cpuinfo ( struct cpufreq_policy * policy , struct cpufreq_frequency_table * table ) ;

int cpufreq_frequency_table_verify ( struct cpufreq_policy * policy , struct cpufreq_frequency_table * table ) ;

int cpufreq_frequency_table_target ( struct cpufreq_policy * policy , struct cpufreq_frequency_table * table , unsigned int target_freq , unsigned int relation , unsigned int * index ) ;

void cpufreq_frequency_table_get_attr ( struct cpufreq_frequency_table * table , unsigned int cpu ) ;

void cpufreq_frequency_table_put_attr ( unsigned int cpu ) ;

struct cpufreq_frequency_table * cpufreq_frequency_get_table ( unsigned int cpu ) ;

void cpuidle_install_idle_handler ( void ) ;

void cpuidle_uninstall_idle_handler ( void ) ;

void cpuidle_pause_and_lock ( void ) ;

void cpuidle_resume_and_unlock ( void ) ;

int cpuidle_enable_device ( struct cpuidle_device * dev ) ;

void cpuidle_disable_device ( struct cpuidle_device * dev ) ;

int cpuidle_register_device ( struct cpuidle_device * dev ) ;

void cpuidle_unregister_device ( struct cpuidle_device * dev ) ;

int cpuidle_register_driver ( struct cpuidle_driver * drv ) ;

void cpuidle_unregister_driver ( struct cpuidle_driver * drv ) ;

int cpuidle_switch_governor ( struct cpuidle_governor * gov ) ;

int cpuidle_register_governor ( struct cpuidle_governor * gov ) ;

void cpuidle_unregister_governor ( struct cpuidle_governor * gov ) ;

int cpuidle_add_class_sysfs ( struct sysdev_class * cls ) ;

void cpuidle_remove_class_sysfs ( struct sysdev_class * cls ) ;

struct cpuidle_attr { struct attribute attr ; ssize_t ( * show ) ( struct cpuidle_device * , char * ) ; ssize_t ( * store ) ( struct cpuidle_device * , const char * , size_t count ) ; } ;

struct cpuidle_state_attr { struct attribute attr ; ssize_t ( * show ) ( struct cpuidle_state * , char * ) ; ssize_t ( * store ) ( struct cpuidle_state * , const char * , size_t ) ; } ;

int cpuidle_add_state_sysfs ( struct cpuidle_device * device ) ;

void cpuidle_remove_state_sysfs ( struct cpuidle_device * device ) ;

int cpuidle_add_sysfs ( struct sys_device * sysdev ) ;

void cpuidle_remove_sysfs ( struct sys_device * sysdev ) ;

struct ladder_device_state { struct { u32 promotion_count ; u32 demotion_count ; u32 promotion_time ; u32 demotion_time ; } threshold ; struct { int promotion_count ; int demotion_count ; } stats ; } ;

struct ladder_device { struct ladder_device_state states [ 8 ] ; int last_state_idx ; } ;

struct menu_device { int last_state_idx ; int needs_update ; unsigned int expected_us ; u64 predicted_us ; unsigned int exit_us ; unsigned int bucket ; u64 correction_factor [ 12 ] ; } ;

int edac_handler_set ( void ) ;

void edac_atomic_assert_error ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dmi_scan_machine ( void ) ;

int dmi_check_system ( const struct dmi_system_id * list ) ;

const struct dmi_system_id * dmi_first_match ( const struct dmi_system_id * list ) ;

const char * dmi_get_system_info ( int field ) ;

int dmi_name_in_serial ( const char * str ) ;

int dmi_name_in_vendors ( const char * str ) ;

const struct dmi_device * dmi_find_device ( int type , const char * name , const struct dmi_device * from ) ;

bool dmi_get_date ( int field , int * yearp , int * monthp , int * dayp ) ;

int dmi_walk ( void ( * decode ) ( const struct dmi_header * , void * ) , void * private_data ) ;

bool dmi_match ( enum dmi_field f , const char * str ) ;

; ; ; ; struct edd_device { unsigned int index ; unsigned int mbr_signature ; struct edd_info * info ; struct kobject kobj ; } ;

struct edd_attribute { struct attribute attr ; ssize_t ( * show ) ( struct edd_device * edev , char * buf ) ; int ( * test ) ( struct edd_device * edev ) ; } ;

struct efi_variable { efi_char16_t VariableName [ 1024 / sizeof ( efi_char16_t ) ] ; efi_guid_t VendorGuid ; unsigned long DataSize ; __u8 Data [ 1024 ] ; efi_status_t Status ; __u32 Attributes ; } __attribute__ ( ( packed ) ) ;
struct efivar_entry { struct efi_variable var ; struct list_head list ; struct kobject kobj ; } ;

struct efivar_attribute { struct attribute attr ; ssize_t ( * show ) ( struct efivar_entry * entry , char * buf ) ; ssize_t ( * store ) ( struct efivar_entry * entry , const char * buf , size_t count ) ; } ;

struct dmi_device_attribute { struct device_attribute dev_attr ; int field ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) reserve_ibft_region ( void ) ;

struct firmware_map_entry { u64 start ; u64 end ; const char * type ; struct list_head list ; struct kobject kobj ; } ;

struct memmap_attribute { struct attribute attr ; ssize_t ( * show ) ( struct firmware_map_entry * entry , char * buf ) ; } ;

int firmware_map_add ( u64 start , u64 end , const char * type ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) firmware_map_add_early ( u64 start , u64 end , const char * type ) ;

struct gpio_chip { const char * label ; struct device * dev ; struct module * owner ; int ( * request ) ( struct gpio_chip * chip , unsigned offset ) ; void ( * free ) ( struct gpio_chip * chip , unsigned offset ) ; int ( * direction_input ) ( struct gpio_chip * chip , unsigned offset ) ; int ( * get ) ( struct gpio_chip * chip , unsigned offset ) ; int ( * direction_output ) ( struct gpio_chip * chip , unsigned offset , int value ) ; void ( * set ) ( struct gpio_chip * chip , unsigned offset , int value ) ; int ( * to_irq ) ( struct gpio_chip * chip , unsigned offset ) ; void ( * dbg_show ) ( struct seq_file * s , struct gpio_chip * chip ) ; int base ; u16 ngpio ; char * * names ; unsigned can_sleep : 1 ; unsigned exported : 1 ; } ;

struct gpio_desc { struct gpio_chip * chip ; unsigned long flags ; const char * label ; } ;

struct poll_desc { struct work_struct work ; struct sysfs_dirent * value_sd ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) gpiochip_reserve ( int start , int ngpio ) ;

int gpio_export ( unsigned gpio , bool direction_may_change ) ;

int gpio_export_link ( struct device * dev , const char * name , unsigned gpio ) ;

void gpio_unexport ( unsigned gpio ) ;

int gpiochip_add ( struct gpio_chip * chip ) ;

int gpiochip_remove ( struct gpio_chip * chip ) ;

int gpio_request ( unsigned gpio , const char * label ) ;

void gpio_free ( unsigned gpio ) ;

const char * gpiochip_is_requested ( struct gpio_chip * chip , unsigned offset ) ;

int gpio_direction_input ( unsigned gpio ) ;

int gpio_direction_output ( unsigned gpio , int value ) ;

int __gpio_get_value ( unsigned gpio ) ;

void __gpio_set_value ( unsigned gpio , int value ) ;

int __gpio_cansleep ( unsigned gpio ) ;

int __gpio_to_irq ( unsigned gpio ) ;

int gpio_get_value_cansleep ( unsigned gpio ) ;

void gpio_set_value_cansleep ( unsigned gpio , int value ) ;

struct lnw_gpio_register { u32 GPLR [ 2 ] ; u32 GPDR [ 2 ] ; u32 GPSR [ 2 ] ; u32 GPCR [ 2 ] ; u32 GRER [ 2 ] ; u32 GFER [ 2 ] ; u32 GEDR [ 2 ] ; } ;

struct lnw_gpio { struct gpio_chip chip ; struct lnw_gpio_register * reg_base ; spinlock_t lock ; unsigned irq_base ; } ;

typedef unsigned int drm_handle_t ;

typedef unsigned int drm_context_t ;

typedef unsigned int drm_drawable_t ;

typedef unsigned int drm_magic_t ;

struct drm_clip_rect { unsigned short x1 ; unsigned short y1 ; unsigned short x2 ; unsigned short y2 ; } ;

struct drm_drawable_info { unsigned int num_rects ; struct drm_clip_rect * rects ; } ;

struct drm_tex_region { unsigned char next ; unsigned char prev ; unsigned char in_use ; unsigned char padding ; unsigned int age ; } ;

struct drm_hw_lock { __volatile__ unsigned int lock ; char padding [ 60 ] ; } ;

struct drm_version { int version_major ; int version_minor ; int version_patchlevel ; size_t name_len ; char * name ; size_t date_len ; char * date ; size_t desc_len ; char * desc ; } ;

struct drm_unique { size_t unique_len ; char * unique ; } ;

struct drm_list { int count ; struct drm_version * version ; } ;

struct drm_block { int unused ; } ;

struct drm_control { enum { DRM_ADD_COMMAND , DRM_RM_COMMAND , DRM_INST_HANDLER , DRM_UNINST_HANDLER } func ; int irq ; } ;

enum drm_map_type { _DRM_FRAME_BUFFER = 0 , _DRM_REGISTERS = 1 , _DRM_SHM = 2 , _DRM_AGP = 3 , _DRM_SCATTER_GATHER = 4 , _DRM_CONSISTENT = 5 , _DRM_GEM = 6 , } ;

enum drm_map_flags { _DRM_RESTRICTED = 0x01 , _DRM_READ_ONLY = 0x02 , _DRM_LOCKED = 0x04 , _DRM_KERNEL = 0x08 , _DRM_WRITE_COMBINING = 0x10 , _DRM_CONTAINS_LOCK = 0x20 , _DRM_REMOVABLE = 0x40 , _DRM_DRIVER = 0x80 } ;

struct drm_ctx_priv_map { unsigned int ctx_id ; void * handle ; } ;

struct drm_map { unsigned long offset ; unsigned long size ; enum drm_map_type type ; enum drm_map_flags flags ; void * handle ; int mtrr ; } ;

struct drm_client { int idx ; int auth ; unsigned long pid ; unsigned long uid ; unsigned long magic ; unsigned long iocs ; } ;

enum drm_stat_type { _DRM_STAT_LOCK , _DRM_STAT_OPENS , _DRM_STAT_CLOSES , _DRM_STAT_IOCTLS , _DRM_STAT_LOCKS , _DRM_STAT_UNLOCKS , _DRM_STAT_VALUE , _DRM_STAT_BYTE , _DRM_STAT_COUNT , _DRM_STAT_IRQ , _DRM_STAT_PRIMARY , _DRM_STAT_SECONDARY , _DRM_STAT_DMA , _DRM_STAT_SPECIAL , _DRM_STAT_MISSED } ;

struct drm_stats { unsigned long count ; struct { unsigned long value ; enum drm_stat_type type ; } data [ 15 ] ; } ;

enum drm_lock_flags { _DRM_LOCK_READY = 0x01 , _DRM_LOCK_QUIESCENT = 0x02 , _DRM_LOCK_FLUSH = 0x04 , _DRM_LOCK_FLUSH_ALL = 0x08 , _DRM_HALT_ALL_QUEUES = 0x10 , _DRM_HALT_CUR_QUEUES = 0x20 } ;

struct drm_lock { int context ; enum drm_lock_flags flags ; } ;

enum drm_dma_flags { _DRM_DMA_BLOCK = 0x01 , _DRM_DMA_WHILE_LOCKED = 0x02 , _DRM_DMA_PRIORITY = 0x04 , _DRM_DMA_WAIT = 0x10 , _DRM_DMA_SMALLER_OK = 0x20 , _DRM_DMA_LARGER_OK = 0x40 } ;

struct drm_buf_desc { int count ; int size ; int low_mark ; int high_mark ; enum { _DRM_PAGE_ALIGN = 0x01 , _DRM_AGP_BUFFER = 0x02 , _DRM_SG_BUFFER = 0x04 , _DRM_FB_BUFFER = 0x08 , _DRM_PCI_BUFFER_RO = 0x10 } flags ; unsigned long agp_start ; } ;

struct drm_buf_info { int count ; struct drm_buf_desc * list ; } ;

struct drm_buf_free { int count ; int * list ; } ;

struct drm_buf_pub { int idx ; int total ; int used ; void * address ; } ;

struct drm_buf_map { int count ; void * virtual ; struct drm_buf_pub * list ; } ;

struct drm_dma { int context ; int send_count ; int * send_indices ; int * send_sizes ; enum drm_dma_flags flags ; int request_count ; int request_size ; int * request_indices ; int * request_sizes ; int granted_count ; } ;

enum drm_ctx_flags { _DRM_CONTEXT_PRESERVED = 0x01 , _DRM_CONTEXT_2DONLY = 0x02 } ;

struct drm_ctx { drm_context_t handle ; enum drm_ctx_flags flags ; } ;

struct drm_ctx_res { int count ; struct drm_ctx * contexts ; } ;

struct drm_draw { drm_drawable_t handle ; } ;

typedef enum { DRM_DRAWABLE_CLIPRECTS , } drm_drawable_info_type_t ;

struct drm_update_draw { drm_drawable_t handle ; unsigned int type ; unsigned int num ; unsigned long long data ; } ;

struct drm_auth { drm_magic_t magic ; } ;

struct drm_irq_busid { int irq ; int busnum ; int devnum ; int funcnum ; } ;

enum drm_vblank_seq_type { _DRM_VBLANK_ABSOLUTE = 0x0 , _DRM_VBLANK_RELATIVE = 0x1 , _DRM_VBLANK_EVENT = 0x4000000 , _DRM_VBLANK_FLIP = 0x8000000 , _DRM_VBLANK_NEXTONMISS = 0x10000000 , _DRM_VBLANK_SECONDARY = 0x20000000 , _DRM_VBLANK_SIGNAL = 0x40000000 } ;

struct drm_wait_vblank_request { enum drm_vblank_seq_type type ; unsigned int sequence ; unsigned long signal ; } ;

struct drm_wait_vblank_reply { enum drm_vblank_seq_type type ; unsigned int sequence ; long tval_sec ; long tval_usec ; } ;

union drm_wait_vblank { struct drm_wait_vblank_request request ; struct drm_wait_vblank_reply reply ; } ;

struct drm_modeset_ctl { __u32 crtc ; __u32 cmd ; } ;

struct drm_agp_mode { unsigned long mode ; } ;

struct drm_agp_buffer { unsigned long size ; unsigned long handle ; unsigned long type ; unsigned long physical ; } ;

struct drm_agp_binding { unsigned long handle ; unsigned long offset ; } ;

struct drm_agp_info { int agp_version_major ; int agp_version_minor ; unsigned long mode ; unsigned long aperture_base ; unsigned long aperture_size ; unsigned long memory_allowed ; unsigned long memory_used ; unsigned short id_vendor ; unsigned short id_device ; } ;

struct drm_scatter_gather { unsigned long size ; unsigned long handle ; } ;

struct drm_set_version { int drm_di_major ; int drm_di_minor ; int drm_dd_major ; int drm_dd_minor ; } ;

struct drm_gem_close { __u32 handle ; __u32 pad ; } ;

struct drm_gem_flink { __u32 handle ; __u32 name ; } ;

struct drm_gem_open { __u32 name ; __u32 handle ; __u64 size ; } ;

struct drm_mode_modeinfo { __u32 clock ; __u16 hdisplay , hsync_start , hsync_end , htotal , hskew ; __u16 vdisplay , vsync_start , vsync_end , vtotal , vscan ; __u32 vrefresh ; __u32 flags ; __u32 type ; char name [ 32 ] ; } ;

struct drm_mode_card_res { __u64 fb_id_ptr ; __u64 crtc_id_ptr ; __u64 connector_id_ptr ; __u64 encoder_id_ptr ; __u32 count_fbs ; __u32 count_crtcs ; __u32 count_connectors ; __u32 count_encoders ; __u32 min_width , max_width ; __u32 min_height , max_height ; } ;

struct drm_mode_crtc { __u64 set_connectors_ptr ; __u32 count_connectors ; __u32 crtc_id ; __u32 fb_id ; __u32 x , y ; __u32 gamma_size ; __u32 mode_valid ; struct drm_mode_modeinfo mode ; } ;

struct drm_mode_get_encoder { __u32 encoder_id ; __u32 encoder_type ; __u32 crtc_id ; __u32 possible_crtcs ; __u32 possible_clones ; } ;

struct drm_mode_get_connector { __u64 encoders_ptr ; __u64 modes_ptr ; __u64 props_ptr ; __u64 prop_values_ptr ; __u32 count_modes ; __u32 count_props ; __u32 count_encoders ; __u32 encoder_id ; __u32 connector_id ; __u32 connector_type ; __u32 connector_type_id ; __u32 connection ; __u32 mm_width , mm_height ; __u32 subpixel ; } ;

struct drm_mode_property_enum { __u64 value ; char name [ 32 ] ; } ;

struct drm_mode_get_property { __u64 values_ptr ; __u64 enum_blob_ptr ; __u32 prop_id ; __u32 flags ; char name [ 32 ] ; __u32 count_values ; __u32 count_enum_blobs ; } ;

struct drm_mode_connector_set_property { __u64 value ; __u32 prop_id ; __u32 connector_id ; } ;

struct drm_mode_get_blob { __u32 blob_id ; __u32 length ; __u64 data ; } ;

struct drm_mode_fb_cmd { __u32 fb_id ; __u32 width , height ; __u32 pitch ; __u32 bpp ; __u32 depth ; __u32 handle ; } ;

struct drm_mode_fb_dirty_cmd { __u32 fb_id ; __u32 flags ; __u32 color ; __u32 num_clips ; __u64 clips_ptr ; } ;

struct drm_mode_mode_cmd { __u32 connector_id ; struct drm_mode_modeinfo mode ; } ;

struct drm_mode_cursor { __u32 flags ; __u32 crtc_id ; __s32 x ; __s32 y ; __u32 width ; __u32 height ; __u32 handle ; } ;

struct drm_mode_crtc_lut { __u32 crtc_id ; __u32 gamma_size ; __u64 red ; __u64 green ; __u64 blue ; } ;

struct drm_mode_crtc_page_flip { __u32 crtc_id ; __u32 fb_id ; __u32 flags ; __u32 reserved ; __u64 user_data ; } ;

struct drm_event { __u32 type ; __u32 length ; } ;

struct drm_event_vblank { struct drm_event base ; __u64 user_data ; __u32 tv_sec ; __u32 tv_usec ; __u32 sequence ; __u32 reserved ; } ;

struct drm_file ;

struct drm_device ;

struct drm_hash_item { struct hlist_node head ; unsigned long key ; } ;

struct drm_open_hash { unsigned int size ; unsigned int order ; unsigned int fill ; struct hlist_head * table ; int use_vmalloc ; } ;

struct drm_mm_node { struct list_head fl_entry ; struct list_head ml_entry ; int free ; unsigned long start ; unsigned long size ; struct drm_mm * mm ; void * private ; } ;

struct drm_mm { struct list_head fl_entry ; struct list_head ml_entry ; struct list_head unused_nodes ; int num_unused ; spinlock_t unused_lock ; } ;

typedef int drm_ioctl_t ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

typedef int drm_ioctl_compat_t ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

struct drm_ioctl_desc { unsigned int cmd ; int flags ; drm_ioctl_t * func ; } ;

struct drm_magic_entry { struct list_head head ; struct drm_hash_item hash_item ; struct drm_file * priv ; } ;

struct drm_vma_entry { struct list_head head ; struct vm_area_struct * vma ; pid_t pid ; } ;

struct drm_buf { int idx ; int total ; int order ; int used ; unsigned long offset ; void * address ; unsigned long bus_address ; struct drm_buf * next ; __volatile__ int waiting ; __volatile__ int pending ; wait_queue_head_t dma_wait ; struct drm_file * file_priv ; int context ; int while_locked ; enum { DRM_LIST_NONE = 0 , DRM_LIST_FREE = 1 , DRM_LIST_WAIT = 2 , DRM_LIST_PEND = 3 , DRM_LIST_PRIO = 4 , DRM_LIST_RECLAIM = 5 } list ; int dev_priv_size ; void * dev_private ; } ;

struct drm_waitlist { int count ; struct drm_buf * * bufs ; struct drm_buf * * rp ; struct drm_buf * * wp ; struct drm_buf * * end ; spinlock_t read_lock ; spinlock_t write_lock ; } ;

struct drm_freelist { int initialized ; atomic_t count ; struct drm_buf * next ; wait_queue_head_t waiting ; int low_mark ; int high_mark ; atomic_t wfh ; spinlock_t lock ; } ;


typedef struct drm_dma_handle { dma_addr_t busaddr ; void * vaddr ; size_t size ; } drm_dma_handle_t ;

struct drm_buf_entry { int buf_size ; int buf_count ; struct drm_buf * buflist ; int seg_count ; int page_order ; struct drm_dma_handle * * seglist ; struct drm_freelist freelist ; } ;

struct drm_pending_event { struct drm_event * event ; struct list_head link ; struct drm_file * file_priv ; void ( * destroy ) ( struct drm_pending_event * event ) ; } ;

struct drm_file { int authenticated ; pid_t pid ; uid_t uid ; drm_magic_t magic ; unsigned long ioctl_count ; struct list_head lhead ; struct drm_minor * minor ; unsigned long lock_count ; struct idr object_idr ; spinlock_t table_lock ; struct file * filp ; void * driver_priv ; int is_master ; struct drm_master * master ; struct list_head fbs ; wait_queue_head_t event_wait ; struct list_head event_list ; int event_space ; } ;
struct drm_queue { atomic_t use_count ; atomic_t finalization ; atomic_t block_count ; atomic_t block_read ; wait_queue_head_t read_queue ; atomic_t block_write ; wait_queue_head_t write_queue ; atomic_t total_queued ; atomic_t total_flushed ; atomic_t total_locks ; enum drm_ctx_flags flags ; struct drm_waitlist waitlist ; wait_queue_head_t flush_queue ; } ;

struct drm_lock_data { struct drm_hw_lock * hw_lock ; struct drm_file * file_priv ; wait_queue_head_t lock_queue ; unsigned long lock_time ; spinlock_t spinlock ; uint32_t kernel_waiters ; uint32_t user_waiters ; int idle_has_lock ; } ;

struct drm_device_dma { struct drm_buf_entry bufs [ 22 + 1 ] ; int buf_count ; struct drm_buf * * buflist ; int seg_count ; int page_count ; unsigned long * pagelist ; unsigned long byte_count ; enum { _DRM_DMA_USE_AGP = 0x01 , _DRM_DMA_USE_SG = 0x02 , _DRM_DMA_USE_FB = 0x04 , _DRM_DMA_USE_PCI_RO = 0x08 } flags ; } ;

struct drm_agp_mem { unsigned long handle ; struct agp_memory * memory ; unsigned long bound ; int pages ; struct list_head head ; } ;

struct drm_agp_head { struct agp_kern_info agp_info ; struct list_head memory ; unsigned long mode ; struct agp_bridge_data * bridge ; int enabled ; int acquired ; unsigned long base ; int agp_mtrr ; int cant_use_aperture ; unsigned long page_mask ; } ;

struct drm_sg_mem { unsigned long handle ; void * virtual ; int pages ; struct page * * pagelist ; dma_addr_t * busaddr ; } ;

struct drm_sigdata { int context ; struct drm_hw_lock * lock ; } ;

struct drm_local_map { resource_size_t offset ; unsigned long size ; enum drm_map_type type ; enum drm_map_flags flags ; void * handle ; int mtrr ; } ;

typedef struct drm_local_map drm_local_map_t ;

struct drm_map_list { struct list_head head ; struct drm_hash_item hash ; struct drm_local_map * map ; uint64_t user_token ; struct drm_master * master ; struct drm_mm_node * file_offset_node ; } ;

struct drm_ctx_list { struct list_head head ; drm_context_t handle ; struct drm_file * tag ; } ;

struct drm_ati_pcigart_info { int gart_table_location ; int gart_reg_if ; void * addr ; dma_addr_t bus_addr ; dma_addr_t table_mask ; struct drm_dma_handle * table_handle ; struct drm_local_map mapping ; int table_size ; } ;

struct drm_gem_mm { struct drm_mm offset_manager ; struct drm_open_hash offset_hash ; } ;

struct drm_gem_object { struct kref refcount ; struct kref handlecount ; struct drm_device * dev ; struct file * filp ; struct drm_map_list map_list ; size_t size ; int name ; uint32_t read_domains ; uint32_t write_domain ; uint32_t pending_read_domains ; uint32_t pending_write_domain ; void * driver_private ; } ;

struct drm_mode_set ;

struct drm_framebuffer ;

struct drm_mode_object { uint32_t id ; uint32_t type ; } ;

enum drm_mode_status { MODE_OK = 0 , MODE_HSYNC , MODE_VSYNC , MODE_H_ILLEGAL , MODE_V_ILLEGAL , MODE_BAD_WIDTH , MODE_NOMODE , MODE_NO_INTERLACE , MODE_NO_DBLESCAN , MODE_NO_VSCAN , MODE_MEM , MODE_VIRTUAL_X , MODE_VIRTUAL_Y , MODE_MEM_VIRT , MODE_NOCLOCK , MODE_CLOCK_HIGH , MODE_CLOCK_LOW , MODE_CLOCK_RANGE , MODE_BAD_HVALUE , MODE_BAD_VVALUE , MODE_BAD_VSCAN , MODE_HSYNC_NARROW , MODE_HSYNC_WIDE , MODE_HBLANK_NARROW , MODE_HBLANK_WIDE , MODE_VSYNC_NARROW , MODE_VSYNC_WIDE , MODE_VBLANK_NARROW , MODE_VBLANK_WIDE , MODE_PANEL , MODE_INTERLACE_WIDTH , MODE_ONE_WIDTH , MODE_ONE_HEIGHT , MODE_ONE_SIZE , MODE_NO_REDUCED , MODE_UNVERIFIED = - 3 , MODE_BAD = - 2 , MODE_ERROR = - 1 } ;

struct drm_display_mode { struct list_head head ; struct drm_mode_object base ; char name [ 32 ] ; int connector_count ; enum drm_mode_status status ; int type ; int clock ; int hdisplay ; int hsync_start ; int hsync_end ; int htotal ; int hskew ; int vdisplay ; int vsync_start ; int vsync_end ; int vtotal ; int vscan ; unsigned int flags ; int width_mm ; int height_mm ; int clock_index ; int synth_clock ; int crtc_hdisplay ; int crtc_hblank_start ; int crtc_hblank_end ; int crtc_hsync_start ; int crtc_hsync_end ; int crtc_htotal ; int crtc_hskew ; int crtc_vdisplay ; int crtc_vblank_start ; int crtc_vblank_end ; int crtc_vsync_start ; int crtc_vsync_end ; int crtc_vtotal ; int crtc_hadjusted ; int crtc_vadjusted ; int private_size ; int * private ; int private_flags ; int vrefresh ; int hsync ; } ;

enum drm_connector_status { connector_status_connected = 1 , connector_status_disconnected = 2 , connector_status_unknown = 3 , } ;

enum subpixel_order { SubPixelUnknown = 0 , SubPixelHorizontalRGB , SubPixelHorizontalBGR , SubPixelVerticalRGB , SubPixelVerticalBGR , SubPixelNone , } ;

struct drm_display_info { char name [ 32 ] ; bool serration_vsync ; bool sync_on_green ; bool composite_sync ; bool separate_syncs ; bool blank_to_black ; unsigned char video_level ; bool digital ; unsigned int width_mm ; unsigned int height_mm ; unsigned char gamma ; bool gtf_supported ; bool standard_color ; enum { monochrome = 0 , rgb , other , unknown , } display_type ; bool active_off_supported ; bool suspend_supported ; bool standby_supported ; unsigned short redx , redy ; unsigned short greenx , greeny ; unsigned short bluex , bluey ; unsigned short whitex , whitey ; unsigned int min_vfreq , max_vfreq ; unsigned int min_hfreq , max_hfreq ; unsigned int pixel_clock ; unsigned int wpx1 , wpy1 ; unsigned int wpgamma1 ; unsigned int wpx2 , wpy2 ; unsigned int wpgamma2 ; enum subpixel_order subpixel_order ; char * raw_edid ; } ;

struct drm_framebuffer_funcs { void ( * destroy ) ( struct drm_framebuffer * framebuffer ) ; int ( * create_handle ) ( struct drm_framebuffer * fb , struct drm_file * file_priv , unsigned int * handle ) ; int ( * dirty ) ( struct drm_framebuffer * framebuffer , unsigned flags , unsigned color , struct drm_clip_rect * clips , unsigned num_clips ) ; } ;

struct drm_framebuffer { struct drm_device * dev ; struct list_head head ; struct drm_mode_object base ; const struct drm_framebuffer_funcs * funcs ; unsigned int pitch ; unsigned int width ; unsigned int height ; unsigned int depth ; int bits_per_pixel ; int flags ; struct fb_info * fbdev ; u32 pseudo_palette [ 17 ] ; struct list_head filp_head ; void * helper_private ; } ;
struct drm_property_blob { struct drm_mode_object base ; struct list_head head ; unsigned int length ; void * data ; } ;

struct drm_property_enum { uint64_t value ; struct list_head head ; char name [ 32 ] ; } ;

struct drm_property { struct list_head head ; struct drm_mode_object base ; uint32_t flags ; char name [ 32 ] ; uint32_t num_values ; uint64_t * values ; struct list_head enum_blob_list ; } ;

struct drm_crtc ;

struct drm_connector ;

struct drm_encoder ;

struct drm_pending_vblank_event ;

struct drm_crtc_funcs { void ( * save ) ( struct drm_crtc * crtc ) ; void ( * restore ) ( struct drm_crtc * crtc ) ; int ( * cursor_set ) ( struct drm_crtc * crtc , struct drm_file * file_priv , uint32_t handle , uint32_t width , uint32_t height ) ; int ( * cursor_move ) ( struct drm_crtc * crtc , int x , int y ) ; void ( * gamma_set ) ( struct drm_crtc * crtc , u16 * r , u16 * g , u16 * b , uint32_t size ) ; void ( * destroy ) ( struct drm_crtc * crtc ) ; int ( * set_config ) ( struct drm_mode_set * set ) ; int ( * page_flip ) ( struct drm_crtc * crtc , struct drm_framebuffer * fb , struct drm_pending_vblank_event * event ) ; } ;

struct drm_crtc { struct drm_device * dev ; struct list_head head ; struct drm_mode_object base ; struct drm_framebuffer * fb ; bool enabled ; struct drm_display_mode mode ; int x , y ; struct drm_display_mode * desired_mode ; int desired_x , desired_y ; const struct drm_crtc_funcs * funcs ; uint32_t gamma_size ; uint16_t * gamma_store ; void * helper_private ; } ;
struct drm_connector_funcs { void ( * dpms ) ( struct drm_connector * connector , int mode ) ; void ( * save ) ( struct drm_connector * connector ) ; void ( * restore ) ( struct drm_connector * connector ) ; enum drm_connector_status ( * detect ) ( struct drm_connector * connector ) ; int ( * fill_modes ) ( struct drm_connector * connector , uint32_t max_width , uint32_t max_height ) ; int ( * set_property ) ( struct drm_connector * connector , struct drm_property * property , uint64_t val ) ; void ( * destroy ) ( struct drm_connector * connector ) ; void ( * force ) ( struct drm_connector * connector ) ; } ;

struct drm_encoder_funcs { void ( * destroy ) ( struct drm_encoder * encoder ) ; } ;

struct drm_encoder { struct drm_device * dev ; struct list_head head ; struct drm_mode_object base ; int encoder_type ; uint32_t possible_crtcs ; uint32_t possible_clones ; struct drm_crtc * crtc ; const struct drm_encoder_funcs * funcs ; void * helper_private ; } ;
enum drm_connector_force { DRM_FORCE_UNSPECIFIED , DRM_FORCE_OFF , DRM_FORCE_ON , DRM_FORCE_ON_DIGITAL , } ;

struct drm_connector { struct drm_device * dev ; struct device kdev ; struct device_attribute * attr ; struct list_head head ; struct drm_mode_object base ; int connector_type ; int connector_type_id ; bool interlace_allowed ; bool doublescan_allowed ; struct list_head modes ; int initial_x , initial_y ; enum drm_connector_status status ; struct list_head probed_modes ; struct drm_display_info display_info ; const struct drm_connector_funcs * funcs ; struct list_head user_modes ; struct drm_property_blob * edid_blob_ptr ; u32 property_ids [ 16 ] ; uint64_t property_values [ 16 ] ; int dpms ; void * helper_private ; enum drm_connector_force force ; uint32_t encoder_ids [ 2 ] ; uint32_t force_encoder_id ; struct drm_encoder * encoder ; void * fb_helper_private ; } ;
struct drm_mode_set { struct list_head head ; struct drm_framebuffer * fb ; struct drm_crtc * crtc ; struct drm_display_mode * mode ; uint32_t x ; uint32_t y ; struct drm_connector * * connectors ; size_t num_connectors ; } ;
struct drm_mode_config_funcs { struct drm_framebuffer * ( * fb_create ) ( struct drm_device * dev , struct drm_file * file_priv , struct drm_mode_fb_cmd * mode_cmd ) ; int ( * fb_changed ) ( struct drm_device * dev ) ; } ;

struct drm_mode_group { uint32_t num_crtcs ; uint32_t num_encoders ; uint32_t num_connectors ; uint32_t * id_list ; } ;

struct drm_mode_config { struct mutex mutex ; struct mutex idr_mutex ; struct idr crtc_idr ; int num_fb ; struct list_head fb_list ; int num_connector ; struct list_head connector_list ; int num_encoder ; struct list_head encoder_list ; int num_crtc ; struct list_head crtc_list ; struct list_head property_list ; struct list_head fb_kernel_list ; int min_width , min_height ; int max_width , max_height ; struct drm_mode_config_funcs * funcs ; resource_size_t fb_base ; struct list_head property_blob_list ; struct drm_property * edid_property ; struct drm_property * dpms_property ; struct drm_property * dvi_i_subconnector_property ; struct drm_property * dvi_i_select_subconnector_property ; struct drm_property * tv_subconnector_property ; struct drm_property * tv_select_subconnector_property ; struct drm_property * tv_mode_property ; struct drm_property * tv_left_margin_property ; struct drm_property * tv_right_margin_property ; struct drm_property * tv_top_margin_property ; struct drm_property * tv_bottom_margin_property ; struct drm_property * tv_brightness_property ; struct drm_property * tv_contrast_property ; struct drm_property * tv_flicker_reduction_property ; struct drm_property * tv_overscan_property ; struct drm_property * tv_saturation_property ; struct drm_property * tv_hue_property ; struct drm_property * scaling_mode_property ; struct drm_property * dithering_mode_property ; struct drm_property * dirty_info_property ; } ;

struct drm_master { struct kref refcount ; struct list_head head ; struct drm_minor * minor ; char * unique ; int unique_len ; int unique_size ; int blocked ; struct drm_open_hash magiclist ; struct list_head magicfree ; struct drm_lock_data lock ; void * driver_priv ; } ;

struct drm_driver { int ( * load ) ( struct drm_device * , unsigned long flags ) ; int ( * firstopen ) ( struct drm_device * ) ; int ( * open ) ( struct drm_device * , struct drm_file * ) ; void ( * preclose ) ( struct drm_device * , struct drm_file * file_priv ) ; void ( * postclose ) ( struct drm_device * , struct drm_file * ) ; void ( * lastclose ) ( struct drm_device * ) ; int ( * unload ) ( struct drm_device * ) ; int ( * suspend ) ( struct drm_device * , pm_message_t state ) ; int ( * resume ) ( struct drm_device * ) ; int ( * dma_ioctl ) ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ; void ( * dma_ready ) ( struct drm_device * ) ; int ( * dma_quiescent ) ( struct drm_device * ) ; int ( * context_ctor ) ( struct drm_device * dev , int context ) ; int ( * context_dtor ) ( struct drm_device * dev , int context ) ; int ( * kernel_context_switch ) ( struct drm_device * dev , int old , int new ) ; void ( * kernel_context_switch_unlock ) ( struct drm_device * dev ) ; u32 ( * get_vblank_counter ) ( struct drm_device * dev , int crtc ) ; int ( * enable_vblank ) ( struct drm_device * dev , int crtc ) ; void ( * disable_vblank ) ( struct drm_device * dev , int crtc ) ; int ( * device_is_agp ) ( struct drm_device * dev ) ; irqreturn_t ( * irq_handler ) ( int irq , void * arg ) ; void ( * irq_preinstall ) ( struct drm_device * dev ) ; int ( * irq_postinstall ) ( struct drm_device * dev ) ; void ( * irq_uninstall ) ( struct drm_device * dev ) ; void ( * reclaim_buffers ) ( struct drm_device * dev , struct drm_file * file_priv ) ; void ( * reclaim_buffers_locked ) ( struct drm_device * dev , struct drm_file * file_priv ) ; void ( * reclaim_buffers_idlelocked ) ( struct drm_device * dev , struct drm_file * file_priv ) ; resource_size_t ( * get_map_ofs ) ( struct drm_local_map * map ) ; resource_size_t ( * get_reg_ofs ) ( struct drm_device * dev ) ; void ( * set_version ) ( struct drm_device * dev , struct drm_set_version * sv ) ; int ( * master_create ) ( struct drm_device * dev , struct drm_master * master ) ; void ( * master_destroy ) ( struct drm_device * dev , struct drm_master * master ) ; int ( * master_set ) ( struct drm_device * dev , struct drm_file * file_priv , bool from_open ) ; void ( * master_drop ) ( struct drm_device * dev , struct drm_file * file_priv , bool from_release ) ; int ( * proc_init ) ( struct drm_minor * minor ) ; void ( * proc_cleanup ) ( struct drm_minor * minor ) ; int ( * debugfs_init ) ( struct drm_minor * minor ) ; void ( * debugfs_cleanup ) ( struct drm_minor * minor ) ; int ( * gem_init_object ) ( struct drm_gem_object * obj ) ; void ( * gem_free_object ) ( struct drm_gem_object * obj ) ; void ( * vgaarb_irq ) ( struct drm_device * dev , bool state ) ; struct vm_operations_struct * gem_vm_ops ; int major ; int minor ; int patchlevel ; char * name ; char * desc ; char * date ; u32 driver_features ; int dev_priv_size ; struct drm_ioctl_desc * ioctls ; int num_ioctls ; struct file_operations fops ; struct pci_driver pci_driver ; struct list_head device_list ; } ;

struct drm_debugfs_list { const char * name ; int ( * show ) ( struct seq_file * , void * ) ; u32 driver_features ; } ;

struct drm_debugfs_node { struct list_head list ; struct drm_minor * minor ; struct drm_debugfs_list * debugfs_ent ; struct dentry * dent ; } ;

struct drm_info_list { const char * name ; int ( * show ) ( struct seq_file * , void * ) ; u32 driver_features ; void * data ; } ;

struct drm_info_node { struct list_head list ; struct drm_minor * minor ; struct drm_info_list * info_ent ; struct dentry * dent ; } ;

struct drm_minor { int index ; int type ; dev_t device ; struct device kdev ; struct drm_device * dev ; struct proc_dir_entry * proc_root ; struct drm_info_node proc_nodes ; struct dentry * debugfs_root ; struct drm_info_node debugfs_nodes ; struct drm_master * master ; struct list_head master_list ; struct drm_mode_group mode_group ; } ;

struct drm_pending_vblank_event { struct drm_pending_event base ; int pipe ; struct drm_event_vblank event ; } ;
struct drm_device { struct list_head driver_item ; char * devname ; int if_version ; spinlock_t count_lock ; struct mutex struct_mutex ; int open_count ; atomic_t ioctl_count ; atomic_t vma_count ; int buf_use ; atomic_t buf_alloc ; unsigned long counters ; enum drm_stat_type types [ 15 ] ; atomic_t counts [ 15 ] ; struct list_head filelist ; struct list_head maplist ; int map_count ; struct drm_open_hash map_hash ; struct list_head ctxlist ; int ctx_count ; struct mutex ctxlist_mutex ; struct idr ctx_idr ; struct list_head vmalist ; int queue_count ; int queue_reserved ; int queue_slots ; struct drm_queue * * queuelist ; struct drm_device_dma * dma ; int irq_enabled ; __volatile__ long context_flag ; __volatile__ long interrupt_flag ; __volatile__ long dma_flag ; struct timer_list timer ; wait_queue_head_t context_wait ; int last_checked ; int last_context ; unsigned long last_switch ; struct work_struct work ; int vblank_disable_allowed ; wait_queue_head_t * vbl_queue ; atomic_t * _vblank_count ; spinlock_t vbl_lock ; atomic_t * vblank_refcount ; u32 * last_vblank ; int * vblank_enabled ; int * vblank_inmodeset ; u32 * last_vblank_wait ; struct timer_list vblank_disable_timer ; u32 max_vblank_count ; struct list_head vblank_event_list ; spinlock_t event_lock ; cycles_t ctx_start ; cycles_t lck_start ; struct fasync_struct * buf_async ; wait_queue_head_t buf_readers ; wait_queue_head_t buf_writers ; struct drm_agp_head * agp ; struct pci_dev * pdev ; int pci_vendor ; int pci_device ; struct drm_sg_mem * sg ; int num_crtcs ; void * dev_private ; void * mm_private ; struct address_space * dev_mapping ; struct drm_sigdata sigdata ; sigset_t sigmask ; struct drm_driver * driver ; struct drm_local_map * agp_buffer_map ; unsigned int agp_buffer_token ; struct drm_minor * control ; struct drm_minor * primary ; spinlock_t drw_lock ; struct idr drw_idr ; struct drm_mode_config mode_config ; spinlock_t object_name_lock ; struct idr object_name_idr ; atomic_t object_count ; atomic_t object_memory ; atomic_t pin_count ; atomic_t pin_memory ; atomic_t gtt_count ; atomic_t gtt_memory ; uint32_t gtt_total ; uint32_t invalidate_domains ; uint32_t flush_domains ; } ;
struct drm_sysfs_class ;


typedef struct _drm_i915_init { enum { I915_INIT_DMA = 0x01 , I915_CLEANUP_DMA = 0x02 , I915_RESUME_DMA = 0x03 } func ; unsigned int mmio_offset ; int sarea_priv_offset ; unsigned int ring_start ; unsigned int ring_end ; unsigned int ring_size ; unsigned int front_offset ; unsigned int back_offset ; unsigned int depth_offset ; unsigned int w ; unsigned int h ; unsigned int pitch ; unsigned int pitch_bits ; unsigned int back_pitch ; unsigned int depth_pitch ; unsigned int cpp ; unsigned int chipset ; } drm_i915_init_t ;


typedef struct _drm_i915_sarea { struct drm_tex_region texList [ 255 + 1 ] ; int last_upload ; int last_enqueue ; int last_dispatch ; int ctxOwner ; int texAge ; int pf_enabled ; int pf_active ; int pf_current_page ; int perf_boxes ; int width , height ; drm_handle_t front_handle ; int front_offset ; int front_size ; drm_handle_t back_handle ; int back_offset ; int back_size ; drm_handle_t depth_handle ; int depth_offset ; int depth_size ; drm_handle_t tex_handle ; int tex_offset ; int tex_size ; int log_tex_granularity ; int pitch ; int rotation ; int rotated_offset ; int rotated_size ; int rotated_pitch ; int virtualX , virtualY ; unsigned int front_tiled ; unsigned int back_tiled ; unsigned int depth_tiled ; unsigned int rotated_tiled ; unsigned int rotated2_tiled ; int pipeA_x ; int pipeA_y ; int pipeA_w ; int pipeA_h ; int pipeB_x ; int pipeB_y ; int pipeB_w ; int pipeB_h ; drm_handle_t unused_handle ; __u32 unused1 , unused2 , unused3 ; __u32 front_bo_handle ; __u32 back_bo_handle ; __u32 unused_bo_handle ; __u32 depth_bo_handle ; } drm_i915_sarea_t ;


typedef struct drm_i915_batchbuffer { int start ; int used ; int DR1 ; int DR4 ; int num_cliprects ; struct drm_clip_rect * cliprects ; } drm_i915_batchbuffer_t ;


typedef struct _drm_i915_cmdbuffer { char * buf ; int sz ; int DR1 ; int DR4 ; int num_cliprects ; struct drm_clip_rect * cliprects ; } drm_i915_cmdbuffer_t ;


typedef struct drm_i915_irq_emit { int * irq_seq ; } drm_i915_irq_emit_t ;


typedef struct drm_i915_irq_wait { int irq_seq ; } drm_i915_irq_wait_t ;


typedef struct drm_i915_getparam { int param ; int * value ; } drm_i915_getparam_t ;


typedef struct drm_i915_setparam { int param ; int value ; } drm_i915_setparam_t ;


typedef struct drm_i915_mem_alloc { int region ; int alignment ; int size ; int * region_offset ; } drm_i915_mem_alloc_t ;


typedef struct drm_i915_mem_free { int region ; int region_offset ; } drm_i915_mem_free_t ;


typedef struct drm_i915_mem_init_heap { int region ; int size ; int start ; } drm_i915_mem_init_heap_t ;


typedef struct drm_i915_mem_destroy_heap { int region ; } drm_i915_mem_destroy_heap_t ;


typedef struct drm_i915_vblank_pipe { int pipe ; } drm_i915_vblank_pipe_t ;


typedef struct drm_i915_vblank_swap { drm_drawable_t drawable ; enum drm_vblank_seq_type seqtype ; unsigned int sequence ; } drm_i915_vblank_swap_t ;


typedef struct drm_i915_hws_addr { __u64 addr ; } drm_i915_hws_addr_t ;

struct drm_i915_gem_init { __u64 gtt_start ; __u64 gtt_end ; } ;

struct drm_i915_gem_create { __u64 size ; __u32 handle ; __u32 pad ; } ;

struct drm_i915_gem_pread { __u32 handle ; __u32 pad ; __u64 offset ; __u64 size ; __u64 data_ptr ; } ;

struct drm_i915_gem_pwrite { __u32 handle ; __u32 pad ; __u64 offset ; __u64 size ; __u64 data_ptr ; } ;

struct drm_i915_gem_mmap { __u32 handle ; __u32 pad ; __u64 offset ; __u64 size ; __u64 addr_ptr ; } ;

struct drm_i915_gem_mmap_gtt { __u32 handle ; __u32 pad ; __u64 offset ; } ;

struct drm_i915_gem_set_domain { __u32 handle ; __u32 read_domains ; __u32 write_domain ; } ;

struct drm_i915_gem_sw_finish { __u32 handle ; } ;

struct drm_i915_gem_relocation_entry { __u32 target_handle ; __u32 delta ; __u64 offset ; __u64 presumed_offset ; __u32 read_domains ; __u32 write_domain ; } ;

struct drm_i915_gem_exec_object { __u32 handle ; __u32 relocation_count ; __u64 relocs_ptr ; __u64 alignment ; __u64 offset ; } ;

struct drm_i915_gem_execbuffer { __u64 buffers_ptr ; __u32 buffer_count ; __u32 batch_start_offset ; __u32 batch_len ; __u32 DR1 ; __u32 DR4 ; __u32 num_cliprects ; __u64 cliprects_ptr ; } ;

struct drm_i915_gem_exec_object2 { __u32 handle ; __u32 relocation_count ; __u64 relocs_ptr ; __u64 alignment ; __u64 offset ; __u64 flags ; __u64 rsvd1 ; __u64 rsvd2 ; } ;

struct drm_i915_gem_execbuffer2 { __u64 buffers_ptr ; __u32 buffer_count ; __u32 batch_start_offset ; __u32 batch_len ; __u32 DR1 ; __u32 DR4 ; __u32 num_cliprects ; __u64 cliprects_ptr ; __u64 flags ; __u64 rsvd1 ; __u64 rsvd2 ; } ;

struct drm_i915_gem_pin { __u32 handle ; __u32 pad ; __u64 alignment ; __u64 offset ; } ;

struct drm_i915_gem_unpin { __u32 handle ; __u32 pad ; } ;

struct drm_i915_gem_busy { __u32 handle ; __u32 busy ; } ;

struct drm_i915_gem_set_tiling { __u32 handle ; __u32 tiling_mode ; __u32 stride ; __u32 swizzle_mode ; } ;

struct drm_i915_gem_get_tiling { __u32 handle ; __u32 tiling_mode ; __u32 swizzle_mode ; } ;

struct drm_i915_gem_get_aperture { __u64 aper_size ; __u64 aper_available_size ; } ;

struct drm_i915_get_pipe_from_crtc_id { __u32 crtc_id ; __u32 pipe ; } ;

struct drm_i915_gem_madvise { __u32 handle ; __u32 madv ; __u32 retained ; } ;

struct drm_intel_overlay_put_image { __u32 flags ; __u32 bo_handle ; __u16 stride_Y ; __u16 stride_UV ; __u32 offset_Y ; __u32 offset_U ; __u32 offset_V ; __u16 src_width ; __u16 src_height ; __u16 src_scan_width ; __u16 src_scan_height ; __u32 crtc_id ; __u16 dst_x ; __u16 dst_y ; __u16 dst_width ; __u16 dst_height ; } ;

struct drm_intel_overlay_attrs { __u32 flags ; __u32 color_key ; __s32 brightness ; __u32 contrast ; __u32 saturation ; __u32 gamma0 ; __u32 gamma1 ; __u32 gamma2 ; __u32 gamma3 ; __u32 gamma4 ; __u32 gamma5 ; } ;

struct vbt_header { u8 signature [ 20 ] ; u16 version ; u16 header_size ; u16 vbt_size ; u8 vbt_checksum ; u8 reserved0 ; u32 bdb_offset ; u32 aim_offset [ 4 ] ; } __attribute__ ( ( packed ) ) ;
struct bdb_header { u8 signature [ 16 ] ; u16 version ; u16 header_size ; u16 bdb_size ; } ;

struct vbios_data { u8 type ; u8 relstage ; u8 chipset ; u8 lvds_present : 1 ; u8 tv_present : 1 ; u8 rsvd2 : 6 ; u8 rsvd3 [ 4 ] ; u8 signon [ 155 ] ; u8 copyright [ 61 ] ; u16 code_segment ; u8 dos_boot_mode ; u8 bandwidth_percent ; u8 rsvd4 ; u8 resize_pci_bios ; u8 rsvd5 ; } __attribute__ ( ( packed ) ) ;
struct bdb_general_features { u8 panel_fitting : 2 ; u8 flexaim : 1 ; u8 msg_enable : 1 ; u8 clear_screen : 3 ; u8 color_flip : 1 ; u8 download_ext_vbt : 1 ; u8 enable_ssc : 1 ; u8 ssc_freq : 1 ; u8 enable_lfp_on_override : 1 ; u8 disable_ssc_ddt : 1 ; u8 rsvd8 : 3 ; u8 disable_smooth_vision : 1 ; u8 single_dvi : 1 ; u8 rsvd9 : 6 ; u8 legacy_monitor_detect ; u8 int_crt_support : 1 ; u8 int_tv_support : 1 ; u8 rsvd11 : 6 ; } __attribute__ ( ( packed ) ) ;
struct child_device_config { u16 handle ; u16 device_type ; u8 device_id [ 10 ] ; u16 addin_offset ; u8 dvo_port ; u8 i2c_pin ; u8 slave_addr ; u8 ddc_pin ; u16 edid_ptr ; u8 dvo_cfg ; u8 dvo2_port ; u8 i2c2_pin ; u8 slave2_addr ; u8 ddc2_pin ; u8 capabilities ; u8 dvo_wiring ; u8 dvo2_wiring ; u16 extended_type ; u8 dvo_function ; } __attribute__ ( ( packed ) ) ;
struct bdb_general_definitions { u8 crt_ddc_gmbus_pin ; u8 dpms_acpi : 1 ; u8 skip_boot_crt_detect : 1 ; u8 dpms_aim : 1 ; u8 rsvd1 : 5 ; u8 boot_display [ 2 ] ; u8 child_dev_size ; struct child_device_config devices [ 0 ] ; } __attribute__ ( ( packed ) ) ;
struct bdb_lvds_options { u8 panel_type ; u8 rsvd1 ; u8 pfit_mode : 2 ; u8 pfit_text_mode_enhanced : 1 ; u8 pfit_gfx_mode_enhanced : 1 ; u8 pfit_ratio_auto : 1 ; u8 pixel_dither : 1 ; u8 lvds_edid : 1 ; u8 rsvd2 : 1 ; u8 rsvd4 ; } __attribute__ ( ( packed ) ) ;
struct bdb_lvds_lfp_data_ptr { u16 fp_timing_offset ; u8 fp_table_size ; u16 dvo_timing_offset ; u8 dvo_table_size ; u16 panel_pnp_id_offset ; u8 pnp_table_size ; } __attribute__ ( ( packed ) ) ;
struct bdb_lvds_lfp_data_ptrs { u8 lvds_entries ; struct bdb_lvds_lfp_data_ptr ptr [ 16 ] ; } __attribute__ ( ( packed ) ) ;
struct lvds_fp_timing { u16 x_res ; u16 y_res ; u32 lvds_reg ; u32 lvds_reg_val ; u32 pp_on_reg ; u32 pp_on_reg_val ; u32 pp_off_reg ; u32 pp_off_reg_val ; u32 pp_cycle_reg ; u32 pp_cycle_reg_val ; u32 pfit_reg ; u32 pfit_reg_val ; u16 terminator ; } __attribute__ ( ( packed ) ) ;
struct lvds_dvo_timing { u16 clock ; u8 hactive_lo ; u8 hblank_lo ; u8 hblank_hi : 4 ; u8 hactive_hi : 4 ; u8 vactive_lo ; u8 vblank_lo ; u8 vblank_hi : 4 ; u8 vactive_hi : 4 ; u8 hsync_off_lo ; u8 hsync_pulse_width ; u8 vsync_pulse_width : 4 ; u8 vsync_off : 4 ; u8 rsvd0 : 6 ; u8 hsync_off_hi : 2 ; u8 h_image ; u8 v_image ; u8 max_hv ; u8 h_border ; u8 v_border ; u8 rsvd1 : 3 ; u8 digital : 2 ; u8 vsync_positive : 1 ; u8 hsync_positive : 1 ; u8 rsvd2 : 1 ; } __attribute__ ( ( packed ) ) ;
struct lvds_pnp_id { u16 mfg_name ; u16 product_code ; u32 serial ; u8 mfg_week ; u8 mfg_year ; } __attribute__ ( ( packed ) ) ;
struct bdb_lvds_lfp_data_entry { struct lvds_fp_timing fp_timing ; struct lvds_dvo_timing dvo_timing ; struct lvds_pnp_id pnp_id ; } __attribute__ ( ( packed ) ) ;
struct bdb_lvds_lfp_data { struct bdb_lvds_lfp_data_entry data [ 16 ] ; } __attribute__ ( ( packed ) ) ;
struct aimdb_header { char signature [ 16 ] ; char oem_device [ 20 ] ; u16 aimdb_version ; u16 aimdb_header_size ; u16 aimdb_size ; } __attribute__ ( ( packed ) ) ;
struct aimdb_block { u8 aimdb_id ; u16 aimdb_size ; } __attribute__ ( ( packed ) ) ;
struct vch_panel_data { u16 fp_timing_offset ; u8 fp_timing_size ; u16 dvo_timing_offset ; u8 dvo_timing_size ; u16 text_fitting_offset ; u8 text_fitting_size ; u16 graphics_fitting_offset ; u8 graphics_fitting_size ; } __attribute__ ( ( packed ) ) ;
struct vch_bdb_22 { struct aimdb_block aimdb_block ; struct vch_panel_data panels [ 16 ] ; } __attribute__ ( ( packed ) ) ;
struct bdb_sdvo_lvds_options { u8 panel_backlight ; u8 h40_set_panel_type ; u8 panel_type ; u8 ssc_clk_freq ; u16 als_low_trip ; u16 als_high_trip ; u8 sclalarcoeff_tab_row_num ; u8 sclalarcoeff_tab_row_size ; u8 coefficient [ 8 ] ; u8 panel_misc_bits_1 ; u8 panel_misc_bits_2 ; u8 panel_misc_bits_3 ; u8 panel_misc_bits_4 ; } __attribute__ ( ( packed ) ) ;
struct bdb_driver_features { u8 boot_dev_algorithm : 1 ; u8 block_display_switch : 1 ; u8 allow_display_switch : 1 ; u8 hotplug_dvo : 1 ; u8 dual_view_zoom : 1 ; u8 int15h_hook : 1 ; u8 sprite_in_clone : 1 ; u8 primary_lfp_id : 1 ; u16 boot_mode_x ; u16 boot_mode_y ; u8 boot_mode_bpp ; u8 boot_mode_refresh ; u16 enable_lfp_primary : 1 ; u16 selective_mode_pruning : 1 ; u16 dual_frequency : 1 ; u16 render_clock_freq : 1 ; u16 nt_clone_support : 1 ; u16 power_scheme_ui : 1 ; u16 sprite_display_assign : 1 ; u16 cui_aspect_scaling : 1 ; u16 preserve_aspect_ratio : 1 ; u16 sdvo_device_power_down : 1 ; u16 crt_hotplug : 1 ; u16 lvds_config : 2 ; u16 tv_hotplug : 1 ; u16 hdmi_config : 2 ; u8 static_display : 1 ; u8 reserved2 : 7 ; u16 legacy_crt_max_x ; u16 legacy_crt_max_y ; u8 legacy_crt_max_refresh ; u8 hdmi_termination ; u8 custom_vbt_version ; } __attribute__ ( ( packed ) ) ;
struct edp_power_seq { u16 t3 ; u16 t7 ; u16 t9 ; u16 t10 ; u16 t12 ; } __attribute__ ( ( packed ) ) ;
struct edp_link_params { u8 rate : 4 ; u8 lanes : 4 ; u8 preemphasis : 4 ; u8 vswing : 4 ; } __attribute__ ( ( packed ) ) ;
struct bdb_edp { struct edp_power_seq power_seqs [ 16 ] ; u32 color_depth ; u32 sdrrs_msa_timing_delay ; struct edp_link_params link_params [ 16 ] ; } __attribute__ ( ( packed ) ) ;
struct io_mapping ;

enum pipe { PIPE_A = 0 , PIPE_B , } ;

enum plane { PLANE_A = 0 , PLANE_B , } ;

struct drm_i915_gem_phys_object { int id ; struct page * * page_list ; drm_dma_handle_t * handle ; struct drm_gem_object * cur_obj ; } ;


typedef struct _drm_i915_ring_buffer { unsigned long Size ; u8 * virtual_start ; int head ; int tail ; int space ; drm_local_map_t map ; struct drm_gem_object * ring_obj ; } drm_i915_ring_buffer_t ;

struct mem_block { struct mem_block * next ; struct mem_block * prev ; int start ; int size ; struct drm_file * file_priv ; } ;

struct opregion_header ;

struct opregion_acpi ;

struct opregion_swsci ;

struct opregion_asle ;

struct intel_opregion { struct opregion_header * header ; struct opregion_acpi * acpi ; struct opregion_swsci * swsci ; struct opregion_asle * asle ; int enabled ; } ;

struct drm_i915_master_private { drm_local_map_t * sarea ; struct _drm_i915_sarea * sarea_priv ; } ;

struct drm_i915_fence_reg { struct drm_gem_object * obj ; } ;

struct sdvo_device_mapping { u8 dvo_port ; u8 slave_addr ; u8 dvo_wiring ; u8 initialized ; } ;

struct drm_i915_error_state { u32 eir ; u32 pgtbl_er ; u32 pipeastat ; u32 pipebstat ; u32 ipeir ; u32 ipehr ; u32 instdone ; u32 acthd ; u32 instpm ; u32 instps ; u32 instdone1 ; u32 seqno ; struct timeval time ; } ;

struct drm_i915_display_funcs { void ( * dpms ) ( struct drm_crtc * crtc , int mode ) ; bool ( * fbc_enabled ) ( struct drm_crtc * crtc ) ; void ( * enable_fbc ) ( struct drm_crtc * crtc , unsigned long interval ) ; void ( * disable_fbc ) ( struct drm_device * dev ) ; int ( * get_display_clock_speed ) ( struct drm_device * dev ) ; int ( * get_fifo_size ) ( struct drm_device * dev , int plane ) ; void ( * update_wm ) ( struct drm_device * dev , int planea_clock , int planeb_clock , int sr_hdisplay , int pixel_size ) ; } ;

struct intel_overlay ;

struct intel_device_info { u8 is_mobile : 1 ; u8 is_i8xx : 1 ; u8 is_i85x : 1 ; u8 is_i915g : 1 ; u8 is_i9xx : 1 ; u8 is_i945gm : 1 ; u8 is_i965g : 1 ; u8 is_i965gm : 1 ; u8 is_g33 : 1 ; u8 need_gfx_hws : 1 ; u8 is_g4x : 1 ; u8 is_pineview : 1 ; u8 is_ironlake : 1 ; u8 has_fbc : 1 ; u8 has_rc6 : 1 ; u8 has_pipe_cxsr : 1 ; u8 has_hotplug : 1 ; u8 cursor_needs_physical : 1 ; } ;


typedef struct drm_i915_private { struct drm_device * dev ; const struct intel_device_info * info ; int has_gem ; void * regs ; struct pci_dev * bridge_dev ; drm_i915_ring_buffer_t ring ; drm_dma_handle_t * status_page_dmah ; void * hw_status_page ; void * seqno_page ; dma_addr_t dma_status_page ; uint32_t counter ; unsigned int status_gfx_addr ; unsigned int seqno_gfx_addr ; drm_local_map_t hws_map ; struct drm_gem_object * hws_obj ; struct drm_gem_object * seqno_obj ; struct drm_gem_object * pwrctx ; struct resource mch_res ; unsigned int cpp ; int back_offset ; int front_offset ; int current_page ; int page_flipping ; wait_queue_head_t irq_queue ; atomic_t irq_received ; spinlock_t user_irq_lock ; int user_irq_refcount ; u32 trace_irq_seqno ; u32 irq_mask_reg ; u32 pipestat [ 2 ] ; u32 gt_irq_mask_reg ; u32 gt_irq_enable_reg ; u32 de_irq_enable_reg ; u32 pch_irq_mask_reg ; u32 pch_irq_enable_reg ; u32 hotplug_supported_mask ; struct work_struct hotplug_work ; int tex_lru_log_granularity ; int allow_batchbuffer ; struct mem_block * agp_heap ; unsigned int sr01 , adpa , ppcr , dvob , dvoc , lvds ; int vblank_pipe ; struct timer_list hangcheck_timer ; int hangcheck_count ; uint32_t last_acthd ; struct drm_mm vram ; unsigned long cfb_size ; unsigned long cfb_pitch ; int cfb_fence ; int cfb_plane ; int irq_enabled ; struct intel_opregion opregion ; struct intel_overlay * overlay ; int backlight_duty_cycle ; bool panel_wants_dither ; struct drm_display_mode * panel_fixed_mode ; struct drm_display_mode * lfp_lvds_vbt_mode ; struct drm_display_mode * sdvo_lvds_vbt_mode ; unsigned int int_tv_support : 1 ; unsigned int lvds_dither : 1 ; unsigned int lvds_vbt : 1 ; unsigned int int_crt_support : 1 ; unsigned int lvds_use_ssc : 1 ; unsigned int edp_support : 1 ; int lvds_ssc_freq ; int edp_bpp ; struct notifier_block lid_notifier ; int crt_ddc_bus ; struct drm_i915_fence_reg fence_regs [ 16 ] ; int fence_reg_start ; int num_fence_regs ; unsigned int fsb_freq , mem_freq ; spinlock_t error_lock ; struct drm_i915_error_state * first_error ; struct work_struct error_work ; struct workqueue_struct * wq ; struct drm_i915_display_funcs display ; bool modeset_on_lid ; u8 saveLBB ; u32 saveDSPACNTR ; u32 saveDSPBCNTR ; u32 saveDSPARB ; u32 saveHWS ; u32 savePIPEACONF ; u32 savePIPEBCONF ; u32 savePIPEASRC ; u32 savePIPEBSRC ; u32 saveFPA0 ; u32 saveFPA1 ; u32 saveDPLL_A ; u32 saveDPLL_A_MD ; u32 saveHTOTAL_A ; u32 saveHBLANK_A ; u32 saveHSYNC_A ; u32 saveVTOTAL_A ; u32 saveVBLANK_A ; u32 saveVSYNC_A ; u32 saveBCLRPAT_A ; u32 saveTRANSACONF ; u32 saveTRANS_HTOTAL_A ; u32 saveTRANS_HBLANK_A ; u32 saveTRANS_HSYNC_A ; u32 saveTRANS_VTOTAL_A ; u32 saveTRANS_VBLANK_A ; u32 saveTRANS_VSYNC_A ; u32 savePIPEASTAT ; u32 saveDSPASTRIDE ; u32 saveDSPASIZE ; u32 saveDSPAPOS ; u32 saveDSPAADDR ; u32 saveDSPASURF ; u32 saveDSPATILEOFF ; u32 savePFIT_PGM_RATIOS ; u32 saveBLC_HIST_CTL ; u32 saveBLC_PWM_CTL ; u32 saveBLC_PWM_CTL2 ; u32 saveBLC_CPU_PWM_CTL ; u32 saveBLC_CPU_PWM_CTL2 ; u32 saveFPB0 ; u32 saveFPB1 ; u32 saveDPLL_B ; u32 saveDPLL_B_MD ; u32 saveHTOTAL_B ; u32 saveHBLANK_B ; u32 saveHSYNC_B ; u32 saveVTOTAL_B ; u32 saveVBLANK_B ; u32 saveVSYNC_B ; u32 saveBCLRPAT_B ; u32 saveTRANSBCONF ; u32 saveTRANS_HTOTAL_B ; u32 saveTRANS_HBLANK_B ; u32 saveTRANS_HSYNC_B ; u32 saveTRANS_VTOTAL_B ; u32 saveTRANS_VBLANK_B ; u32 saveTRANS_VSYNC_B ; u32 savePIPEBSTAT ; u32 saveDSPBSTRIDE ; u32 saveDSPBSIZE ; u32 saveDSPBPOS ; u32 saveDSPBADDR ; u32 saveDSPBSURF ; u32 saveDSPBTILEOFF ; u32 saveVGA0 ; u32 saveVGA1 ; u32 saveVGA_PD ; u32 saveVGACNTRL ; u32 saveADPA ; u32 saveLVDS ; u32 savePP_ON_DELAYS ; u32 savePP_OFF_DELAYS ; u32 saveDVOA ; u32 saveDVOB ; u32 saveDVOC ; u32 savePP_ON ; u32 savePP_OFF ; u32 savePP_CONTROL ; u32 savePP_DIVISOR ; u32 savePFIT_CONTROL ; u32 save_palette_a [ 256 ] ; u32 save_palette_b [ 256 ] ; u32 saveDPFC_CB_BASE ; u32 saveFBC_CFB_BASE ; u32 saveFBC_LL_BASE ; u32 saveFBC_CONTROL ; u32 saveFBC_CONTROL2 ; u32 saveIER ; u32 saveIIR ; u32 saveIMR ; u32 saveDEIER ; u32 saveDEIMR ; u32 saveGTIER ; u32 saveGTIMR ; u32 saveFDI_RXA_IMR ; u32 saveFDI_RXB_IMR ; u32 saveCACHE_MODE_0 ; u32 saveMI_ARB_STATE ; u32 saveSWF0 [ 16 ] ; u32 saveSWF1 [ 16 ] ; u32 saveSWF2 [ 3 ] ; u8 saveMSR ; u8 saveSR [ 8 ] ; u8 saveGR [ 25 ] ; u8 saveAR_INDEX ; u8 saveAR [ 21 ] ; u8 saveDACMASK ; u8 saveCR [ 37 ] ; uint64_t saveFENCE [ 16 ] ; u32 saveCURACNTR ; u32 saveCURAPOS ; u32 saveCURABASE ; u32 saveCURBCNTR ; u32 saveCURBPOS ; u32 saveCURBBASE ; u32 saveCURSIZE ; u32 saveDP_B ; u32 saveDP_C ; u32 saveDP_D ; u32 savePIPEA_GMCH_DATA_M ; u32 savePIPEB_GMCH_DATA_M ; u32 savePIPEA_GMCH_DATA_N ; u32 savePIPEB_GMCH_DATA_N ; u32 savePIPEA_DP_LINK_M ; u32 savePIPEB_DP_LINK_M ; u32 savePIPEA_DP_LINK_N ; u32 savePIPEB_DP_LINK_N ; u32 saveFDI_RXA_CTL ; u32 saveFDI_TXA_CTL ; u32 saveFDI_RXB_CTL ; u32 saveFDI_TXB_CTL ; u32 savePFA_CTL_1 ; u32 savePFB_CTL_1 ; u32 savePFA_WIN_SZ ; u32 savePFB_WIN_SZ ; u32 savePFA_WIN_POS ; u32 savePFB_WIN_POS ; u32 savePCH_DREF_CONTROL ; u32 saveDISP_ARB_CTL ; u32 savePIPEA_DATA_M1 ; u32 savePIPEA_DATA_N1 ; u32 savePIPEA_LINK_M1 ; u32 savePIPEA_LINK_N1 ; u32 savePIPEB_DATA_M1 ; u32 savePIPEB_DATA_N1 ; u32 savePIPEB_LINK_M1 ; u32 savePIPEB_LINK_N1 ; struct { struct drm_mm gtt_space ; struct io_mapping * gtt_mapping ; int gtt_mtrr ; struct list_head shrink_list ; spinlock_t active_list_lock ; struct list_head active_list ; struct list_head flushing_list ; struct list_head gpu_write_list ; struct list_head inactive_list ; struct list_head fence_list ; struct list_head request_list ; struct delayed_work retire_work ; uint32_t next_gem_seqno ; uint32_t waiting_gem_seqno ; uint32_t irq_gem_seqno ; int suspended ; atomic_t wedged ; uint32_t bit_6_swizzle_x ; uint32_t bit_6_swizzle_y ; struct drm_i915_gem_phys_object * phys_objs [ ( 3 ) ] ; } mm ; struct sdvo_device_mapping sdvo_mappings [ 2 ] ; unsigned int lvds_border_bits ; struct drm_crtc * plane_to_crtc_mapping [ 2 ] ; struct drm_crtc * pipe_to_crtc_mapping [ 2 ] ; wait_queue_head_t pending_flip_queue ; bool render_reclock_avail ; bool lvds_downclock_avail ; int lvds_downclock ; struct work_struct idle_work ; struct timer_list idle_timer ; bool busy ; u16 orig_clock ; int child_dev_num ; struct child_device_config * child_dev ; struct drm_connector * int_lvds_connector ; } drm_i915_private_t ;

struct drm_i915_gem_object { struct drm_gem_object * obj ; struct drm_mm_node * gtt_space ; struct list_head list ; struct list_head gpu_write_list ; struct list_head fence_list ; int active ; int dirty ; struct agp_memory * agp_mem ; struct page * * pages ; int pages_refcount ; uint32_t gtt_offset ; uint64_t mmap_offset ; int fence_reg ; int pin_count ; uint32_t last_rendering_seqno ; uint32_t tiling_mode ; uint32_t stride ; long * bit_17 ; uint32_t agp_type ; uint8_t * page_cpu_valid ; uint32_t user_pin_count ; struct drm_file * pin_filp ; struct drm_i915_gem_phys_object * phys_obj ; int in_execbuffer ; int madv ; atomic_t pending_flip ; } ;

struct drm_i915_gem_request { uint32_t seqno ; unsigned long emitted_jiffies ; struct list_head list ; struct list_head client_list ; } ;

struct drm_i915_file_private { struct { struct list_head request_list ; } mm ; } ;

enum intel_chip_family { CHIP_I8XX = 0x01 , CHIP_I9XX = 0x02 , CHIP_I915 = 0x04 , CHIP_I965 = 0x08 , } ;

struct drm_fb_helper_crtc { uint32_t crtc_id ; struct drm_mode_set mode_set ; } ;

struct drm_fb_helper_funcs { void ( * gamma_set ) ( struct drm_crtc * crtc , u16 red , u16 green , u16 blue , int regno ) ; void ( * gamma_get ) ( struct drm_crtc * crtc , u16 * red , u16 * green , u16 * blue , int regno ) ; } ;

struct drm_fb_helper_cmdline_mode { bool specified ; bool refresh_specified ; bool bpp_specified ; int xres , yres ; int bpp ; int refresh ; bool rb ; bool interlace ; bool cvt ; bool margins ; } ;

struct drm_fb_helper_connector { struct drm_fb_helper_cmdline_mode cmdline_mode ; } ;

struct drm_fb_helper { struct drm_framebuffer * fb ; struct drm_device * dev ; struct drm_display_mode * mode ; int crtc_count ; struct drm_fb_helper_crtc * crtc_info ; struct drm_fb_helper_funcs * funcs ; int conn_limit ; struct list_head kernel_fb_list ; } ;

struct drm_crtc_helper_funcs { void ( * dpms ) ( struct drm_crtc * crtc , int mode ) ; void ( * prepare ) ( struct drm_crtc * crtc ) ; void ( * commit ) ( struct drm_crtc * crtc ) ; bool ( * mode_fixup ) ( struct drm_crtc * crtc , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ; int ( * mode_set ) ( struct drm_crtc * crtc , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode , int x , int y , struct drm_framebuffer * old_fb ) ; int ( * mode_set_base ) ( struct drm_crtc * crtc , int x , int y , struct drm_framebuffer * old_fb ) ; void ( * load_lut ) ( struct drm_crtc * crtc ) ; } ;

struct drm_encoder_helper_funcs { void ( * dpms ) ( struct drm_encoder * encoder , int mode ) ; void ( * save ) ( struct drm_encoder * encoder ) ; void ( * restore ) ( struct drm_encoder * encoder ) ; bool ( * mode_fixup ) ( struct drm_encoder * encoder , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ; void ( * prepare ) ( struct drm_encoder * encoder ) ; void ( * commit ) ( struct drm_encoder * encoder ) ; void ( * mode_set ) ( struct drm_encoder * encoder , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ; struct drm_crtc * ( * get_crtc ) ( struct drm_encoder * encoder ) ; enum drm_connector_status ( * detect ) ( struct drm_encoder * encoder , struct drm_connector * connector ) ; void ( * disable ) ( struct drm_encoder * encoder ) ; } ;

struct drm_connector_helper_funcs { int ( * get_modes ) ( struct drm_connector * connector ) ; int ( * mode_valid ) ( struct drm_connector * connector , struct drm_display_mode * mode ) ; struct drm_encoder * ( * best_encoder ) ( struct drm_connector * connector ) ; } ;

int i965_reset ( struct drm_device * dev , u8 flags ) ;

struct i2c_algo_bit_data { void * data ; void ( * setsda ) ( void * data , int state ) ; void ( * setscl ) ( void * data , int state ) ; int ( * getsda ) ( void * data ) ; int ( * getscl ) ( void * data ) ; int udelay ; int timeout ; } ;

struct intel_i2c_chan { struct drm_device * drm_dev ; u32 reg ; struct i2c_adapter adapter ; struct i2c_algo_bit_data algo ; } ;

struct intel_framebuffer { struct drm_framebuffer base ; struct drm_gem_object * obj ; } ;

struct intel_output { struct drm_connector base ; struct drm_encoder enc ; int type ; struct i2c_adapter * i2c_bus ; struct i2c_adapter * ddc_bus ; bool load_detect_temp ; bool needs_tv_clock ; void * dev_priv ; void ( * hot_plug ) ( struct intel_output * ) ; int crtc_mask ; int clone_mask ; } ;

struct intel_crtc ;

struct intel_overlay { struct drm_device * dev ; struct intel_crtc * crtc ; struct drm_i915_gem_object * vid_bo ; struct drm_i915_gem_object * old_vid_bo ; int active ; int pfit_active ; u32 pfit_vscale_ratio ; u32 color_key ; u32 brightness , contrast , saturation ; u32 old_xscale , old_yscale ; u32 flip_addr ; struct drm_i915_gem_object * reg_bo ; void * virt_addr ; uint32_t last_flip_req ; int hw_wedged ; } ;
struct intel_crtc { struct drm_crtc base ; enum pipe pipe ; enum plane plane ; struct drm_gem_object * cursor_bo ; uint32_t cursor_addr ; u8 lut_r [ 256 ] , lut_g [ 256 ] , lut_b [ 256 ] ; int dpms_mode ; bool busy ; struct timer_list idle_timer ; bool lowfreq_avail ; struct intel_overlay * overlay ; struct intel_unpin_work * unpin_work ; } ;
int i915_wait_ring ( struct drm_device * dev , int n , const char * caller ) ;

int i915_wrap_ring ( struct drm_device * dev ) ;

void i915_kernel_lost_context ( struct drm_device * dev ) ;

int i915_emit_box ( struct drm_device * dev , struct drm_clip_rect * boxes , int i , int DR1 , int DR4 ) ;

int i915_master_create ( struct drm_device * dev , struct drm_master * master ) ;

void i915_master_destroy ( struct drm_device * dev , struct drm_master * master ) ;

int i915_driver_load ( struct drm_device * dev , unsigned long flags ) ;

int i915_driver_unload ( struct drm_device * dev ) ;

int i915_driver_open ( struct drm_device * dev , struct drm_file * file_priv ) ;

void i915_driver_lastclose ( struct drm_device * dev ) ;

void i915_driver_preclose ( struct drm_device * dev , struct drm_file * file_priv ) ;

void i915_driver_postclose ( struct drm_device * dev , struct drm_file * file_priv ) ;

int i915_driver_device_is_agp ( struct drm_device * dev ) ;

void ironlake_enable_graphics_irq ( drm_i915_private_t * dev_priv , u32 mask ) ;

void ironlake_enable_display_irq ( drm_i915_private_t * dev_priv , u32 mask ) ;

void i915_enable_irq ( drm_i915_private_t * dev_priv , u32 mask ) ;

void i915_enable_pipestat ( drm_i915_private_t * dev_priv , int pipe , u32 mask ) ;

void i915_disable_pipestat ( drm_i915_private_t * dev_priv , int pipe , u32 mask ) ;

void intel_enable_asle ( struct drm_device * dev ) ;

u32 i915_get_vblank_counter ( struct drm_device * dev , int pipe ) ;

u32 gm45_get_vblank_counter ( struct drm_device * dev , int pipe ) ;

irqreturn_t ironlake_irq_handler ( struct drm_device * dev ) ;

irqreturn_t i915_driver_irq_handler ( int irq , void * arg ) ;

void i915_user_irq_get ( struct drm_device * dev ) ;

void i915_user_irq_put ( struct drm_device * dev ) ;

void i915_trace_irq_get ( struct drm_device * dev , u32 seqno ) ;

int i915_irq_emit ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_irq_wait ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_enable_vblank ( struct drm_device * dev , int pipe ) ;

void i915_disable_vblank ( struct drm_device * dev , int pipe ) ;

void i915_enable_interrupt ( struct drm_device * dev ) ;

int i915_vblank_pipe_set ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_vblank_pipe_get ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_vblank_swap ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

struct drm_i915_gem_request * i915_get_tail_request ( struct drm_device * dev ) ;

void i915_hangcheck_elapsed ( unsigned long data ) ;

void i915_driver_irq_preinstall ( struct drm_device * dev ) ;

int i915_driver_irq_postinstall ( struct drm_device * dev ) ;

void i915_driver_irq_uninstall ( struct drm_device * dev ) ;

void i915_mem_release ( struct drm_device * dev , struct drm_file * file_priv , struct mem_block * heap ) ;

void i915_mem_takedown ( struct mem_block * * heap ) ;

int i915_mem_alloc ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_mem_free ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_mem_init_heap ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_mem_destroy_heap ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_debugfs_init ( struct drm_minor * minor ) ;

void i915_debugfs_cleanup ( struct drm_minor * minor ) ;

void i915_save_display ( struct drm_device * dev ) ;

void i915_restore_display ( struct drm_device * dev ) ;

int i915_save_state ( struct drm_device * dev ) ;

int i915_restore_state ( struct drm_device * dev ) ;

int i915_gem_do_init ( struct drm_device * dev , unsigned long start , unsigned long end ) ;

int i915_gem_init_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_get_aperture_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_create_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_pread_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_pwrite_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_set_domain_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_sw_finish_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_mmap_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_fault ( struct vm_area_struct * vma , struct vm_fault * vmf ) ;

void i915_gem_release_mmap ( struct drm_gem_object * obj ) ;

int i915_gem_mmap_gtt_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void i915_gem_object_put_pages ( struct drm_gem_object * obj ) ;

uint32_t i915_add_request ( struct drm_device * dev , struct drm_file * file_priv , uint32_t flush_domains ) ;

bool i915_seqno_passed ( uint32_t seq1 , uint32_t seq2 ) ;

uint32_t i915_get_gem_seqno ( struct drm_device * dev ) ;

void i915_gem_retire_requests ( struct drm_device * dev ) ;

void i915_gem_retire_work_handler ( struct work_struct * work ) ;

int i915_do_wait_request ( struct drm_device * dev , uint32_t seqno , int interruptible ) ;

int i915_gem_object_unbind ( struct drm_gem_object * obj ) ;

int i915_gem_object_get_pages ( struct drm_gem_object * obj , gfp_t gfpmask ) ;

int i915_gem_object_get_fence_reg ( struct drm_gem_object * obj ) ;

int i915_gem_object_put_fence_reg ( struct drm_gem_object * obj ) ;

void i915_gem_clflush_object ( struct drm_gem_object * obj ) ;

void i915_gem_object_flush_write_domain ( struct drm_gem_object * obj ) ;

int i915_gem_object_set_to_gtt_domain ( struct drm_gem_object * obj , int write ) ;

int i915_gem_object_set_to_display_plane ( struct drm_gem_object * obj ) ;

int i915_gem_do_execbuffer ( struct drm_device * dev , void * data , struct drm_file * file_priv , struct drm_i915_gem_execbuffer2 * args , struct drm_i915_gem_exec_object2 * exec_list ) ;

int i915_gem_execbuffer ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_execbuffer2 ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_object_pin ( struct drm_gem_object * obj , uint32_t alignment ) ;

void i915_gem_object_unpin ( struct drm_gem_object * obj ) ;

int i915_gem_pin_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_unpin_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_busy_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_throttle_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_madvise_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_init_object ( struct drm_gem_object * obj ) ;

void i915_gem_free_object ( struct drm_gem_object * obj ) ;

int i915_gem_idle ( struct drm_device * dev ) ;

int i915_gem_init_ringbuffer ( struct drm_device * dev ) ;

void i915_gem_cleanup_ringbuffer ( struct drm_device * dev ) ;

int i915_gem_entervt_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_leavevt_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void i915_gem_lastclose ( struct drm_device * dev ) ;

void i915_gem_load ( struct drm_device * dev ) ;

int i915_gem_init_phys_object ( struct drm_device * dev , int id , int size ) ;

void i915_gem_free_phys_object ( struct drm_device * dev , int id ) ;

void i915_gem_free_all_phys_object ( struct drm_device * dev ) ;

void i915_gem_detach_phys_object ( struct drm_device * dev , struct drm_gem_object * obj ) ;

int i915_gem_attach_phys_object ( struct drm_device * dev , struct drm_gem_object * obj , int id ) ;

void i915_gem_release ( struct drm_device * dev , struct drm_file * file_priv ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) void i915_gem_shrinker_init ( void ) ;

__attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) void i915_gem_shrinker_exit ( void ) ;

void i915_gem_detect_bit_6_swizzle ( struct drm_device * dev ) ;

bool i915_obj_fenceable ( struct drm_device * dev , struct drm_gem_object * obj ) ;

bool i915_tiling_ok ( struct drm_device * dev , int stride , int size , int tiling_mode ) ;

int i915_gem_set_tiling ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int i915_gem_get_tiling ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void i915_gem_object_do_bit_17_swizzle ( struct drm_gem_object * obj ) ;

void i915_gem_object_save_bit_17_swizzle ( struct drm_gem_object * obj ) ;

struct ftrace_raw_i915_gem_object_create { struct trace_entry ent ; struct drm_gem_object * obj ; u32 size ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_object_bind { struct trace_entry ent ; struct drm_gem_object * obj ; u32 gtt_offset ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_object_clflush { struct trace_entry ent ; struct drm_gem_object * obj ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_object_change_domain { struct trace_entry ent ; struct drm_gem_object * obj ; u32 read_domains ; u32 write_domain ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_object_get_fence { struct trace_entry ent ; struct drm_gem_object * obj ; int fence ; int tiling_mode ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_object_unbind { struct trace_entry ent ; struct drm_gem_object * obj ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_object_destroy { struct trace_entry ent ; struct drm_gem_object * obj ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_request_submit { struct trace_entry ent ; u32 dev ; u32 seqno ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_request_flush { struct trace_entry ent ; u32 dev ; u32 seqno ; u32 flush_domains ; u32 invalidate_domains ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_request_complete { struct trace_entry ent ; u32 dev ; u32 seqno ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_request_retire { struct trace_entry ent ; u32 dev ; u32 seqno ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_request_wait_begin { struct trace_entry ent ; u32 dev ; u32 seqno ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_gem_request_wait_end { struct trace_entry ent ; u32 dev ; u32 seqno ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_ring_wait_begin { struct trace_entry ent ; u32 dev ; char __data [ 0 ] ; } ;

struct ftrace_raw_i915_ring_wait_end { struct trace_entry ent ; u32 dev ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_i915_gem_object_create { ; } ;

struct ftrace_data_offsets_i915_gem_object_bind { ; } ;

struct ftrace_data_offsets_i915_gem_object_clflush { ; } ;

struct ftrace_data_offsets_i915_gem_object_change_domain { ; } ;

struct ftrace_data_offsets_i915_gem_object_get_fence { ; } ;

struct ftrace_data_offsets_i915_gem_object_unbind { ; } ;

struct ftrace_data_offsets_i915_gem_object_destroy { ; } ;

struct ftrace_data_offsets_i915_gem_request_submit { ; } ;

struct ftrace_data_offsets_i915_gem_request_flush { ; } ;

struct ftrace_data_offsets_i915_gem_request_complete { ; } ;

struct ftrace_data_offsets_i915_gem_request_retire { ; } ;

struct ftrace_data_offsets_i915_gem_request_wait_begin { ; } ;

struct ftrace_data_offsets_i915_gem_request_wait_end { ; } ;

struct ftrace_data_offsets_i915_ring_wait_begin { ; } ;

struct ftrace_data_offsets_i915_ring_wait_end { ; } ;

struct i2c_algo_dp_aux_data { bool running ; u16 address ; int ( * aux_ch ) ( struct i2c_adapter * adapter , int mode , uint8_t write_byte , uint8_t * read_byte ) ; } ;

typedef struct { int n ; int m1 , m2 ; int p1 , p2 ; int dot ; int vco ; int m ; int p ; } intel_clock_t ;

typedef struct { int min , max ; } intel_range_t ;

typedef struct { int dot_limit ; int p2_slow , p2_fast ; } intel_p2_t ;

typedef struct intel_limit intel_limit_t ;

struct intel_limit { intel_range_t dot , vco , n , m , m1 , m2 , p , p1 ; intel_p2_t p2 ; bool ( * find_pll ) ( const intel_limit_t * , struct drm_crtc * , int , int , intel_clock_t * ) ; } ;

bool intel_pipe_has_type ( struct drm_crtc * crtc , int type ) ;

struct drm_connector * intel_pipe_get_output ( struct drm_crtc * crtc ) ;

void intel_wait_for_vblank ( struct drm_device * dev ) ;

void i8xx_disable_fbc ( struct drm_device * dev ) ;

void g4x_disable_fbc ( struct drm_device * dev ) ;

void intel_encoder_prepare ( struct drm_encoder * encoder ) ;

void intel_encoder_commit ( struct drm_encoder * encoder ) ;

int intel_panel_fitter_pipe ( struct drm_device * dev ) ;

struct fdi_m_n { u32 tu ; u32 gmch_m ; u32 gmch_n ; u32 link_m ; u32 link_n ; } ;

struct intel_watermark_params { unsigned long fifo_size ; unsigned long max_wm ; unsigned long default_wm ; unsigned long guard_size ; unsigned long cacheline_size ; } ;

struct cxsr_latency { int is_desktop ; unsigned long fsb_freq ; unsigned long mem_freq ; unsigned long display_sr ; unsigned long display_hpll_disable ; unsigned long cursor_sr ; unsigned long cursor_hpll_disable ; } ;

void intel_crtc_load_lut ( struct drm_crtc * crtc ) ;

void intel_crtc_fb_gamma_set ( struct drm_crtc * crtc , u16 red , u16 green , u16 blue , int regno ) ;

void intel_crtc_fb_gamma_get ( struct drm_crtc * crtc , u16 * red , u16 * green , u16 * blue , int regno ) ;

struct drm_crtc * intel_get_load_detect_pipe ( struct intel_output * intel_output , struct drm_display_mode * mode , int * dpms_mode ) ;

void intel_release_load_detect_pipe ( struct intel_output * intel_output , int dpms_mode ) ;

struct drm_display_mode * intel_crtc_mode_get ( struct drm_device * dev , struct drm_crtc * crtc ) ;

void intel_mark_busy ( struct drm_device * dev , struct drm_gem_object * obj ) ;

struct intel_unpin_work { struct work_struct work ; struct drm_device * dev ; struct drm_gem_object * old_fb_obj ; struct drm_gem_object * pending_flip_obj ; struct drm_pending_vblank_event * event ; int pending ; } ;

void intel_finish_page_flip ( struct drm_device * dev , int pipe ) ;

void intel_prepare_page_flip ( struct drm_device * dev , int plane ) ;

int intel_get_pipe_from_crtc_id ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

struct drm_crtc * intel_get_crtc_from_pipe ( struct drm_device * dev , int pipe ) ;

int intel_framebuffer_create ( struct drm_device * dev , struct drm_mode_fb_cmd * mode_cmd , struct drm_framebuffer * * fb , struct drm_gem_object * obj ) ;

void intel_init_clock_gating ( struct drm_device * dev ) ;

void intel_modeset_init ( struct drm_device * dev ) ;

void intel_modeset_cleanup ( struct drm_device * dev ) ;

struct drm_encoder * intel_best_encoder ( struct drm_connector * connector ) ;

int intel_modeset_vga_set_state ( struct drm_device * dev , bool state ) ;

void intel_crt_init ( struct drm_device * dev ) ;

struct est_timings { u8 t1 ; u8 t2 ; u8 mfg_rsvd ; } __attribute__ ( ( packed ) ) ;
struct std_timing { u8 hsize ; u8 vfreq_aspect ; } __attribute__ ( ( packed ) ) ;
struct detailed_pixel_timing { u8 hactive_lo ; u8 hblank_lo ; u8 hactive_hblank_hi ; u8 vactive_lo ; u8 vblank_lo ; u8 vactive_vblank_hi ; u8 hsync_offset_lo ; u8 hsync_pulse_width_lo ; u8 vsync_offset_pulse_width_lo ; u8 hsync_vsync_offset_pulse_width_hi ; u8 width_mm_lo ; u8 height_mm_lo ; u8 width_height_mm_hi ; u8 hborder ; u8 vborder ; u8 misc ; } __attribute__ ( ( packed ) ) ;
struct detailed_data_string { u8 str [ 13 ] ; } __attribute__ ( ( packed ) ) ;
struct detailed_data_monitor_range { u8 min_vfreq ; u8 max_vfreq ; u8 min_hfreq_khz ; u8 max_hfreq_khz ; u8 pixel_clock_mhz ; __le16 sec_gtf_toggle ; u8 hfreq_start_khz ; u8 c ; __le16 m ; u8 k ; u8 j ; } __attribute__ ( ( packed ) ) ;
struct detailed_data_wpindex { u8 white_yx_lo ; u8 white_x_hi ; u8 white_y_hi ; u8 gamma ; } __attribute__ ( ( packed ) ) ;
struct detailed_data_color_point { u8 windex1 ; u8 wpindex1 [ 3 ] ; u8 windex2 ; u8 wpindex2 [ 3 ] ; } __attribute__ ( ( packed ) ) ;
struct cvt_timing { u8 code [ 3 ] ; } __attribute__ ( ( packed ) ) ;
struct detailed_non_pixel { u8 pad1 ; u8 type ; u8 pad2 ; union { struct detailed_data_string str ; struct detailed_data_monitor_range range ; struct detailed_data_wpindex color ; struct std_timing timings [ 5 ] ; struct cvt_timing cvt [ 4 ] ; } data ; } __attribute__ ( ( packed ) ) ;
struct detailed_timing { __le16 pixel_clock ; union { struct detailed_pixel_timing pixel_data ; struct detailed_non_pixel other_data ; } data ; } __attribute__ ( ( packed ) ) ;
struct edid { u8 header [ 8 ] ; u8 mfg_id [ 2 ] ; u8 prod_code [ 2 ] ; u32 serial ; u8 mfg_week ; u8 mfg_year ; u8 version ; u8 revision ; u8 input ; u8 width_cm ; u8 height_cm ; u8 gamma ; u8 features ; u8 red_green_lo ; u8 black_white_lo ; u8 red_x ; u8 red_y ; u8 green_x ; u8 green_y ; u8 blue_x ; u8 blue_y ; u8 white_x ; u8 white_y ; struct est_timings established_timings ; struct std_timing standard_timings [ 8 ] ; struct detailed_timing detailed_timings [ 4 ] ; u8 extensions ; u8 checksum ; } __attribute__ ( ( packed ) ) ;
struct intel_lvds_priv { int fitting_mode ; u32 pfit_control ; u32 pfit_pgm_ratios ; } ;

void intel_lvds_init ( struct drm_device * dev ) ;

bool intel_init_bios ( struct drm_device * dev ) ;

struct intel_dp_priv { uint32_t output_reg ; uint32_t DP ; uint8_t link_configuration [ 9 ] ; uint32_t save_DP ; uint8_t save_link_configuration [ 9 ] ; bool has_audio ; int dpms_mode ; uint8_t link_bw ; uint8_t lane_count ; uint8_t dpcd [ 4 ] ; struct intel_output * intel_output ; struct i2c_adapter adapter ; struct i2c_algo_dp_aux_data algo ; } ;

void intel_edp_link_config ( struct intel_output * intel_output , int * lane_num , int * link_bw ) ;

struct intel_dp_m_n { uint32_t tu ; uint32_t gmch_m ; uint32_t gmch_n ; uint32_t link_m ; uint32_t link_n ; } ;

void intel_dp_set_m_n ( struct drm_crtc * crtc , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ;

void intel_dp_hot_plug ( struct intel_output * intel_output ) ;

void intel_dp_init ( struct drm_device * dev , int output_reg ) ;

struct intel_hdmi_priv { u32 sdvox_reg ; u32 save_SDVOX ; bool has_hdmi_sink ; } ;

void intel_hdmi_init ( struct drm_device * dev , int sdvox_reg ) ;

struct intel_sdvo_caps { u8 vendor_id ; u8 device_id ; u8 device_rev_id ; u8 sdvo_version_major ; u8 sdvo_version_minor ; unsigned int sdvo_inputs_mask : 2 ; unsigned int smooth_scaling : 1 ; unsigned int sharp_scaling : 1 ; unsigned int up_scaling : 1 ; unsigned int down_scaling : 1 ; unsigned int stall_support : 1 ; unsigned int pad : 1 ; u16 output_flags ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_dtd { struct { u16 clock ; u8 h_active ; u8 h_blank ; u8 h_high ; u8 v_active ; u8 v_blank ; u8 v_high ; } part1 ; struct { u8 h_sync_off ; u8 h_sync_width ; u8 v_sync_off_width ; u8 sync_off_width_high ; u8 dtd_flags ; u8 sdvo_flags ; u8 v_sync_off_high ; u8 reserved ; } part2 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_pixel_clock_range { u16 min ; u16 max ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_preferred_input_timing_args { u16 clock ; u16 width ; u16 height ; u8 interlace : 1 ; u8 scaled : 1 ; u8 pad : 6 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_get_trained_inputs_response { unsigned int input0_trained : 1 ; unsigned int input1_trained : 1 ; unsigned int pad : 6 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_in_out_map { u16 in0 , in1 ; } ;

struct intel_sdvo_get_interrupt_event_source_response { u16 interrupt_status ; unsigned int ambient_light_interrupt : 1 ; unsigned int hdmi_audio_encrypt_change : 1 ; unsigned int pad : 6 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_set_target_input_args { unsigned int target_1 : 1 ; unsigned int pad : 7 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_tv_format { unsigned int ntsc_m : 1 ; unsigned int ntsc_j : 1 ; unsigned int ntsc_443 : 1 ; unsigned int pal_b : 1 ; unsigned int pal_d : 1 ; unsigned int pal_g : 1 ; unsigned int pal_h : 1 ; unsigned int pal_i : 1 ; unsigned int pal_m : 1 ; unsigned int pal_n : 1 ; unsigned int pal_nc : 1 ; unsigned int pal_60 : 1 ; unsigned int secam_b : 1 ; unsigned int secam_d : 1 ; unsigned int secam_g : 1 ; unsigned int secam_k : 1 ; unsigned int secam_k1 : 1 ; unsigned int secam_l : 1 ; unsigned int secam_60 : 1 ; unsigned int hdtv_std_smpte_240m_1080i_59 : 1 ; unsigned int hdtv_std_smpte_240m_1080i_60 : 1 ; unsigned int hdtv_std_smpte_260m_1080i_59 : 1 ; unsigned int hdtv_std_smpte_260m_1080i_60 : 1 ; unsigned int hdtv_std_smpte_274m_1080i_50 : 1 ; unsigned int hdtv_std_smpte_274m_1080i_59 : 1 ; unsigned int hdtv_std_smpte_274m_1080i_60 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_23 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_24 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_25 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_29 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_30 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_50 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_59 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_60 : 1 ; unsigned int hdtv_std_smpte_295m_1080i_50 : 1 ; unsigned int hdtv_std_smpte_295m_1080p_50 : 1 ; unsigned int hdtv_std_smpte_296m_720p_59 : 1 ; unsigned int hdtv_std_smpte_296m_720p_60 : 1 ; unsigned int hdtv_std_smpte_296m_720p_50 : 1 ; unsigned int hdtv_std_smpte_293m_480p_59 : 1 ; unsigned int hdtv_std_smpte_170m_480i_59 : 1 ; unsigned int hdtv_std_iturbt601_576i_50 : 1 ; unsigned int hdtv_std_iturbt601_576p_50 : 1 ; unsigned int hdtv_std_eia_7702a_480i_60 : 1 ; unsigned int hdtv_std_eia_7702a_480p_60 : 1 ; unsigned int pad : 3 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_sdtv_resolution_request { unsigned int ntsc_m : 1 ; unsigned int ntsc_j : 1 ; unsigned int ntsc_443 : 1 ; unsigned int pal_b : 1 ; unsigned int pal_d : 1 ; unsigned int pal_g : 1 ; unsigned int pal_h : 1 ; unsigned int pal_i : 1 ; unsigned int pal_m : 1 ; unsigned int pal_n : 1 ; unsigned int pal_nc : 1 ; unsigned int pal_60 : 1 ; unsigned int secam_b : 1 ; unsigned int secam_d : 1 ; unsigned int secam_g : 1 ; unsigned int secam_k : 1 ; unsigned int secam_k1 : 1 ; unsigned int secam_l : 1 ; unsigned int secam_60 : 1 ; unsigned int pad : 5 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_sdtv_resolution_reply { unsigned int res_320x200 : 1 ; unsigned int res_320x240 : 1 ; unsigned int res_400x300 : 1 ; unsigned int res_640x350 : 1 ; unsigned int res_640x400 : 1 ; unsigned int res_640x480 : 1 ; unsigned int res_704x480 : 1 ; unsigned int res_704x576 : 1 ; unsigned int res_720x350 : 1 ; unsigned int res_720x400 : 1 ; unsigned int res_720x480 : 1 ; unsigned int res_720x540 : 1 ; unsigned int res_720x576 : 1 ; unsigned int res_768x576 : 1 ; unsigned int res_800x600 : 1 ; unsigned int res_832x624 : 1 ; unsigned int res_920x766 : 1 ; unsigned int res_1024x768 : 1 ; unsigned int res_1280x1024 : 1 ; unsigned int pad : 5 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_hdtv_resolution_request { unsigned int hdtv_std_smpte_240m_1080i_59 : 1 ; unsigned int hdtv_std_smpte_240m_1080i_60 : 1 ; unsigned int hdtv_std_smpte_260m_1080i_59 : 1 ; unsigned int hdtv_std_smpte_260m_1080i_60 : 1 ; unsigned int hdtv_std_smpte_274m_1080i_50 : 1 ; unsigned int hdtv_std_smpte_274m_1080i_59 : 1 ; unsigned int hdtv_std_smpte_274m_1080i_60 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_23 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_24 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_25 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_29 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_30 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_50 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_59 : 1 ; unsigned int hdtv_std_smpte_274m_1080p_60 : 1 ; unsigned int hdtv_std_smpte_295m_1080i_50 : 1 ; unsigned int hdtv_std_smpte_295m_1080p_50 : 1 ; unsigned int hdtv_std_smpte_296m_720p_59 : 1 ; unsigned int hdtv_std_smpte_296m_720p_60 : 1 ; unsigned int hdtv_std_smpte_296m_720p_50 : 1 ; unsigned int hdtv_std_smpte_293m_480p_59 : 1 ; unsigned int hdtv_std_smpte_170m_480i_59 : 1 ; unsigned int hdtv_std_iturbt601_576i_50 : 1 ; unsigned int hdtv_std_iturbt601_576p_50 : 1 ; unsigned int hdtv_std_eia_7702a_480i_60 : 1 ; unsigned int hdtv_std_eia_7702a_480p_60 : 1 ; unsigned int pad : 6 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_hdtv_resolution_reply { unsigned int res_640x480 : 1 ; unsigned int res_800x600 : 1 ; unsigned int res_1024x768 : 1 ; unsigned int res_1280x960 : 1 ; unsigned int res_1400x1050 : 1 ; unsigned int res_1600x1200 : 1 ; unsigned int res_1920x1440 : 1 ; unsigned int res_2048x1536 : 1 ; unsigned int res_2560x1920 : 1 ; unsigned int res_3200x2400 : 1 ; unsigned int res_3840x2880 : 1 ; unsigned int pad1 : 5 ; unsigned int res_848x480 : 1 ; unsigned int res_1064x600 : 1 ; unsigned int res_1280x720 : 1 ; unsigned int res_1360x768 : 1 ; unsigned int res_1704x960 : 1 ; unsigned int res_1864x1050 : 1 ; unsigned int res_1920x1080 : 1 ; unsigned int res_2128x1200 : 1 ; unsigned int res_2560x1400 : 1 ; unsigned int res_2728x1536 : 1 ; unsigned int res_3408x1920 : 1 ; unsigned int res_4264x2400 : 1 ; unsigned int res_5120x2880 : 1 ; unsigned int pad2 : 3 ; unsigned int res_768x480 : 1 ; unsigned int res_960x600 : 1 ; unsigned int res_1152x720 : 1 ; unsigned int res_1124x768 : 1 ; unsigned int res_1536x960 : 1 ; unsigned int res_1680x1050 : 1 ; unsigned int res_1728x1080 : 1 ; unsigned int res_1920x1200 : 1 ; unsigned int res_2304x1440 : 1 ; unsigned int res_2456x1536 : 1 ; unsigned int res_3072x1920 : 1 ; unsigned int res_3840x2400 : 1 ; unsigned int res_4608x2880 : 1 ; unsigned int pad3 : 3 ; unsigned int res_1280x1024 : 1 ; unsigned int pad4 : 7 ; unsigned int res_1280x768 : 1 ; unsigned int pad5 : 7 ; } __attribute__ ( ( packed ) ) ;
struct sdvo_panel_power_sequencing { u8 t0 ; u8 t1 ; u8 t2 ; u8 t3 ; u8 t4 ; unsigned int t0_high : 2 ; unsigned int t1_high : 2 ; unsigned int t2_high : 2 ; unsigned int t3_high : 2 ; unsigned int t4_high : 2 ; unsigned int pad : 6 ; } __attribute__ ( ( packed ) ) ;
struct sdvo_max_backlight_reply { u8 max_value ; u8 default_value ; } __attribute__ ( ( packed ) ) ;
struct sdvo_get_ambient_light_reply { u16 trip_low ; u16 trip_high ; u16 value ; } __attribute__ ( ( packed ) ) ;
struct sdvo_set_ambient_light_reply { u16 trip_low ; u16 trip_high ; unsigned int enable : 1 ; unsigned int pad : 7 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_enhancements_reply { unsigned int flicker_filter : 1 ; unsigned int flicker_filter_adaptive : 1 ; unsigned int flicker_filter_2d : 1 ; unsigned int saturation : 1 ; unsigned int hue : 1 ; unsigned int brightness : 1 ; unsigned int contrast : 1 ; unsigned int overscan_h : 1 ; unsigned int overscan_v : 1 ; unsigned int position_h : 1 ; unsigned int position_v : 1 ; unsigned int sharpness : 1 ; unsigned int dot_crawl : 1 ; unsigned int dither : 1 ; unsigned int max_tv_chroma_filter : 1 ; unsigned int max_tv_luma_filter : 1 ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_enhancement_limits_reply { u16 max_value ; u16 default_value ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_enhancements_arg { u16 value ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_encode { u8 dvi_rev ; u8 hdmi_rev ; } __attribute__ ( ( packed ) ) ;
struct intel_sdvo_priv { u8 slave_addr ; int output_device ; uint16_t controlled_output ; struct intel_sdvo_caps caps ; int pixel_clock_min , pixel_clock_max ; uint16_t attached_output ; bool is_tv ; char * tv_format_name ; char * tv_format_supported [ ( sizeof ( tv_format_names ) / sizeof ( * tv_format_names ) ) ] ; int format_supported_num ; struct drm_property * tv_format_property ; struct drm_property * tv_format_name_property [ ( sizeof ( tv_format_names ) / sizeof ( * tv_format_names ) ) ] ; bool is_hdmi ; bool is_lvds ; uint8_t sdvo_flags ; struct drm_display_mode * sdvo_lvds_fixed_mode ; struct intel_sdvo_sdtv_resolution_reply sdtv_resolutions ; struct intel_sdvo_encode encode ; uint8_t ddc_bus ; struct i2c_adapter * analog_ddc_bus ; int save_sdvo_mult ; u16 save_active_outputs ; struct intel_sdvo_dtd save_input_dtd_1 , save_input_dtd_2 ; struct intel_sdvo_dtd save_output_dtd [ 16 ] ; u32 save_SDVOX ; struct drm_property * left_property ; struct drm_property * right_property ; struct drm_property * top_property ; struct drm_property * bottom_property ; struct drm_property * hpos_property ; struct drm_property * vpos_property ; struct drm_property * brightness_property ; struct drm_property * contrast_property ; struct drm_property * saturation_property ; struct drm_property * hue_property ; u32 left_margin , right_margin , top_margin , bottom_margin ; u32 max_hscan , max_vscan ; u32 max_hpos , cur_hpos ; u32 max_vpos , cur_vpos ; u32 cur_brightness , max_brightness ; u32 cur_contrast , max_contrast ; u32 cur_saturation , max_saturation ; u32 cur_hue , max_hue ; } ;


struct dip_infoframe { uint8_t type ; uint8_t version ; uint8_t len ; uint8_t checksum ; union { struct { uint8_t S : 2 ; uint8_t B : 2 ; uint8_t A : 1 ; uint8_t Y : 2 ; uint8_t rsvd1 : 1 ; uint8_t R : 4 ; uint8_t M : 2 ; uint8_t C : 2 ; uint8_t SC : 2 ; uint8_t Q : 2 ; uint8_t EC : 3 ; uint8_t ITC : 1 ; uint8_t VIC : 7 ; uint8_t rsvd2 : 1 ; uint8_t PR : 4 ; uint8_t rsvd3 : 4 ; uint16_t top_bar_end ; uint16_t bottom_bar_start ; uint16_t left_bar_end ; uint16_t right_bar_start ; } avi ; struct { uint8_t channel_count : 3 ; uint8_t rsvd1 : 1 ; uint8_t coding_type : 4 ; uint8_t sample_size : 2 ; uint8_t sample_frequency : 3 ; uint8_t rsvd2 : 3 ; uint8_t coding_type_private : 5 ; uint8_t rsvd3 : 3 ; uint8_t channel_allocation ; uint8_t rsvd4 : 3 ; uint8_t level_shift : 4 ; uint8_t downmix_inhibit : 1 ; } audio ; uint8_t payload [ 28 ] ; } __attribute__ ( ( packed ) ) u ; } __attribute__ ( ( packed ) ) ;
struct drm_connector * intel_sdvo_find ( struct drm_device * dev , int sdvoB ) ;

int intel_sdvo_supports_hotplug ( struct drm_connector * connector ) ;

void intel_sdvo_set_hotplug ( struct drm_connector * connector , int on ) ;

enum drm_connector_status intel_sdvo_hdmi_sink_detect ( struct drm_connector * connector , u16 response ) ;

bool intel_sdvo_init ( struct drm_device * dev , int output_device ) ;

bool intel_ddc_probe ( struct intel_output * intel_output ) ;

int intel_ddc_get_modes ( struct intel_output * intel_output ) ;

void intel_i2c_quirk_set ( struct drm_device * dev , bool enable ) ;

void intel_i2c_reset_gmbus ( struct drm_device * dev ) ;

struct i2c_adapter * intel_i2c_create ( struct drm_device * dev , const u32 reg , const char * name ) ;

void intel_i2c_destroy ( struct i2c_adapter * adapter ) ;

struct intelfb_par { struct drm_fb_helper helper ; struct intel_framebuffer * intel_fb ; struct drm_display_mode * our_mode ; } ;

int intelfb_resize ( struct drm_device * dev , struct drm_crtc * crtc ) ;

int intelfb_probe ( struct drm_device * dev ) ;

int intelfb_remove ( struct drm_device * dev , struct drm_framebuffer * fb ) ;

enum tv_margin { TV_MARGIN_LEFT , TV_MARGIN_TOP , TV_MARGIN_RIGHT , TV_MARGIN_BOTTOM } ;

struct intel_tv_priv { int type ; char * tv_format ; int margin [ 4 ] ; u32 save_TV_H_CTL_1 ; u32 save_TV_H_CTL_2 ; u32 save_TV_H_CTL_3 ; u32 save_TV_V_CTL_1 ; u32 save_TV_V_CTL_2 ; u32 save_TV_V_CTL_3 ; u32 save_TV_V_CTL_4 ; u32 save_TV_V_CTL_5 ; u32 save_TV_V_CTL_6 ; u32 save_TV_V_CTL_7 ; u32 save_TV_SC_CTL_1 , save_TV_SC_CTL_2 , save_TV_SC_CTL_3 ; u32 save_TV_CSC_Y ; u32 save_TV_CSC_Y2 ; u32 save_TV_CSC_U ; u32 save_TV_CSC_U2 ; u32 save_TV_CSC_V ; u32 save_TV_CSC_V2 ; u32 save_TV_CLR_KNOBS ; u32 save_TV_CLR_LEVEL ; u32 save_TV_WIN_POS ; u32 save_TV_WIN_SIZE ; u32 save_TV_FILTER_CTL_1 ; u32 save_TV_FILTER_CTL_2 ; u32 save_TV_FILTER_CTL_3 ; u32 save_TV_H_LUMA [ 60 ] ; u32 save_TV_H_CHROMA [ 60 ] ; u32 save_TV_V_LUMA [ 43 ] ; u32 save_TV_V_CHROMA [ 43 ] ; u32 save_TV_DAC ; u32 save_TV_CTL ; } ;

struct video_levels { int blank , black , burst ; } ;

struct color_conversion { u16 ry , gy , by , ay ; u16 ru , gu , bu , au ; u16 rv , gv , bv , av ; } ;

struct tv_mode { char * name ; int clock ; int refresh ; u32 oversample ; int hsync_end , hblank_start , hblank_end , htotal ; bool progressive , trilevel_sync , component_only ; int vsync_start_f1 , vsync_start_f2 , vsync_len ; bool veq_ena ; int veq_start_f1 , veq_start_f2 , veq_len ; int vi_end_f1 , vi_end_f2 , nbr_end ; bool burst_ena ; int hburst_start , hburst_len ; int vburst_start_f1 , vburst_end_f1 ; int vburst_start_f2 , vburst_end_f2 ; int vburst_start_f3 , vburst_end_f3 ; int vburst_start_f4 , vburst_end_f4 ; int dda2_size , dda3_size , dda1_inc , dda2_inc , dda3_inc ; u32 sc_reset ; bool pal_burst ; const struct video_levels * composite_levels , * svideo_levels ; const struct color_conversion * composite_color , * svideo_color ; const u32 * filter_table ; int max_srcw ; } ;


void intel_tv_init ( struct drm_device * dev ) ;

struct intel_dvo_device { char * name ; int type ; u32 dvo_reg ; u32 gpio ; int slave_addr ; struct i2c_adapter * i2c_bus ; const struct intel_dvo_dev_ops * dev_ops ; void * dev_priv ; struct drm_display_mode * panel_fixed_mode ; bool panel_wants_dither ; } ;

struct intel_dvo_dev_ops { bool ( * init ) ( struct intel_dvo_device * dvo , struct i2c_adapter * i2cbus ) ; void ( * create_resources ) ( struct intel_dvo_device * dvo ) ; void ( * dpms ) ( struct intel_dvo_device * dvo , int mode ) ; void ( * save ) ( struct intel_dvo_device * dvo ) ; void ( * restore ) ( struct intel_dvo_device * dvo ) ; int ( * mode_valid ) ( struct intel_dvo_device * dvo , struct drm_display_mode * mode ) ; bool ( * mode_fixup ) ( struct intel_dvo_device * dvo , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ; void ( * prepare ) ( struct intel_dvo_device * dvo ) ; void ( * commit ) ( struct intel_dvo_device * dvo ) ; void ( * mode_set ) ( struct intel_dvo_device * dvo , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ; enum drm_connector_status ( * detect ) ( struct intel_dvo_device * dvo ) ; struct drm_display_mode * ( * get_modes ) ( struct intel_dvo_device * dvo ) ; void ( * destroy ) ( struct intel_dvo_device * dvo ) ; void ( * dump_regs ) ( struct intel_dvo_device * dvo ) ; } ;

void intel_dvo_init ( struct drm_device * dev ) ;

struct overlay_registers { u32 OBUF_0Y ; u32 OBUF_1Y ; u32 OBUF_0U ; u32 OBUF_0V ; u32 OBUF_1U ; u32 OBUF_1V ; u32 OSTRIDE ; u32 YRGB_VPH ; u32 UV_VPH ; u32 HORZ_PH ; u32 INIT_PHS ; u32 DWINPOS ; u32 DWINSZ ; u32 SWIDTH ; u32 SWIDTHSW ; u32 SHEIGHT ; u32 YRGBSCALE ; u32 UVSCALE ; u32 OCLRC0 ; u32 OCLRC1 ; u32 DCLRKV ; u32 DCLRKM ; u32 SCLRKVH ; u32 SCLRKVL ; u32 SCLRKEN ; u32 OCONFIG ; u32 OCMD ; u32 RESERVED1 ; u32 OSTART_0Y ; u32 OSTART_1Y ; u32 OSTART_0U ; u32 OSTART_0V ; u32 OSTART_1U ; u32 OSTART_1V ; u32 OTILEOFF_0Y ; u32 OTILEOFF_1Y ; u32 OTILEOFF_0U ; u32 OTILEOFF_0V ; u32 OTILEOFF_1U ; u32 OTILEOFF_1V ; u32 FASTHSCALE ; u32 UVSCALEV ; u32 RESERVEDC [ ( 0x200 - 0xA8 ) / 4 ] ; u16 Y_VCOEFS [ 3 * 17 ] ; u16 RESERVEDD [ 0x100 / 2 - 3 * 17 ] ; u16 Y_HCOEFS [ 5 * 17 ] ; u16 RESERVEDE [ 0x200 / 2 - 5 * 17 ] ; u16 UV_VCOEFS [ 3 * 17 ] ; u16 RESERVEDF [ 0x100 / 2 - 3 * 17 ] ; u16 UV_HCOEFS [ 3 * 17 ] ; u16 RESERVEDG [ 0x100 / 2 - 3 * 17 ] ; } ;

int intel_overlay_recover_from_interrupt ( struct intel_overlay * overlay , int interruptible ) ;

struct put_image_params { int format ; short dst_x ; short dst_y ; short dst_w ; short dst_h ; short src_w ; short src_scan_h ; short src_scan_w ; short src_h ; short stride_Y ; short stride_UV ; int offset_Y ; int offset_U ; int offset_V ; } ;

int intel_overlay_do_put_image ( struct intel_overlay * overlay , struct drm_gem_object * new_bo , struct put_image_params * params ) ;

int intel_overlay_switch_off ( struct intel_overlay * overlay ) ;

int intel_overlay_put_image ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int intel_overlay_attrs ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void intel_setup_overlay ( struct drm_device * dev ) ;

void intel_cleanup_overlay ( struct drm_device * dev ) ;


struct ch7xxx_reg_state { uint8_t regs [ 0x4c ] ; } ;

struct ch7xxx_priv { bool quiet ; struct ch7xxx_reg_state save_reg ; struct ch7xxx_reg_state mode_reg ; uint8_t save_TCTL , save_TPCP , save_TPD , save_TPVT ; uint8_t save_TLPF , save_TCT , save_PM , save_IDF ; } ;

struct ch7017_priv { uint8_t save_hapi ; uint8_t save_vali ; uint8_t save_valo ; uint8_t save_ailo ; uint8_t save_lvds_pll_vco ; uint8_t save_feedback_div ; uint8_t save_lvds_control_2 ; uint8_t save_outputs_enable ; uint8_t save_lvds_power_down ; uint8_t save_power_management ; } ;

struct ivch_priv { bool quiet ; uint16_t width , height ; uint16_t save_VR01 ; uint16_t save_VR40 ; } ;

struct tfp410_save_rec { uint8_t ctl1 ; uint8_t ctl2 ; } ;

struct tfp410_priv { bool quiet ; struct tfp410_save_rec saved_reg ; struct tfp410_save_rec mode_reg ; } ;

struct sil164_save_rec { uint8_t reg8 ; uint8_t reg9 ; uint8_t regc ; } ;

struct sil164_priv { bool quiet ; struct sil164_save_rec save_regs ; struct sil164_save_rec mode_regs ; } ;

struct opregion_header { u8 signature [ 16 ] ; u32 size ; u32 opregion_ver ; u8 bios_ver [ 32 ] ; u8 vbios_ver [ 16 ] ; u8 driver_ver [ 16 ] ; u32 mboxes ; u8 reserved [ 164 ] ; } __attribute__ ( ( packed ) ) ;
struct opregion_acpi { u32 drdy ; u32 csts ; u32 cevt ; u8 rsvd1 [ 20 ] ; u32 didl [ 8 ] ; u32 cpdl [ 8 ] ; u32 cadl [ 8 ] ; u32 nadl [ 8 ] ; u32 aslp ; u32 tidx ; u32 chpd ; u32 clid ; u32 cdck ; u32 sxsw ; u32 evts ; u32 cnot ; u32 nrdy ; u8 rsvd2 [ 60 ] ; } __attribute__ ( ( packed ) ) ;
struct opregion_swsci { u32 scic ; u32 parm ; u32 dslp ; u8 rsvd [ 244 ] ; } __attribute__ ( ( packed ) ) ;
struct opregion_asle { u32 ardy ; u32 aslc ; u32 tche ; u32 alsi ; u32 bclp ; u32 pfit ; u32 cblv ; u16 bclm [ 20 ] ; u32 cpfm ; u32 epfm ; u8 plut [ 74 ] ; u32 pfmb ; u8 rsvd [ 102 ] ; } __attribute__ ( ( packed ) ) ;
void opregion_asle_intr ( struct drm_device * dev ) ;

void ironlake_opregion_gse_intr ( struct drm_device * dev ) ;

void opregion_enable_asle ( struct drm_device * dev ) ;

int intel_opregion_init ( struct drm_device * dev , int resume ) ;

void intel_opregion_free ( struct drm_device * dev , int suspend ) ;


typedef struct _drm_i915_batchbuffer32 { int start ; int used ; int DR1 ; int DR4 ; int num_cliprects ; u32 cliprects ; } drm_i915_batchbuffer32_t ;


typedef struct _drm_i915_cmdbuffer32 { u32 buf ; int sz ; int DR1 ; int DR4 ; int num_cliprects ; u32 cliprects ; } drm_i915_cmdbuffer32_t ;


typedef struct drm_i915_irq_emit32 { u32 irq_seq ; } drm_i915_irq_emit32_t ;


typedef struct drm_i915_getparam32 { int param ; u32 value ; } drm_i915_getparam32_t ;


typedef struct drm_i915_mem_alloc32 { int region ; int alignment ; int size ; u32 region_offset ; } drm_i915_mem_alloc32_t ;

long i915_compat_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

struct ttm_bo_device ;

struct drm_mm_node ;
struct ttm_placement { unsigned fpfn ; unsigned lpfn ; unsigned num_placement ; const uint32_t * placement ; unsigned num_busy_placement ; const uint32_t * busy_placement ; } ;

struct ttm_mem_reg { struct drm_mm_node * mm_node ; unsigned long size ; unsigned long num_pages ; uint32_t page_alignment ; uint32_t mem_type ; uint32_t placement ; } ;

enum ttm_bo_type { ttm_bo_type_device , ttm_bo_type_user , ttm_bo_type_kernel } ;

struct ttm_tt ;

struct ttm_buffer_object { struct ttm_bo_global * glob ; struct ttm_bo_device * bdev ; unsigned long buffer_start ; enum ttm_bo_type type ; void ( * destroy ) ( struct ttm_buffer_object * ) ; unsigned long num_pages ; uint64_t addr_space_offset ; size_t acc_size ; struct kref kref ; struct kref list_kref ; wait_queue_head_t event_queue ; spinlock_t lock ; struct ttm_mem_reg mem ; struct file * persistant_swap_storage ; struct ttm_tt * ttm ; bool evicted ; atomic_t cpu_writers ; struct list_head lru ; struct list_head ddestroy ; struct list_head swap ; uint32_t val_seq ; bool seq_valid ; atomic_t reserved ; void * sync_obj_arg ; void * sync_obj ; unsigned long priv_flags ; struct rb_node vm_rb ; struct drm_mm_node * vm_node ; unsigned long offset ; uint32_t cur_placement ; } ;

struct ttm_bo_kmap_obj { void * virtual ; struct page * page ; enum { ttm_bo_map_iomap = 1 | 0x80 , ttm_bo_map_vmap = 2 , ttm_bo_map_kmap = 3 , ttm_bo_map_premapped = 4 | 0x80 , } bo_kmap_type ; } ;

struct ttm_mem_shrink { int ( * do_shrink ) ( struct ttm_mem_shrink * ) ; } ;

struct ttm_mem_zone ;

struct ttm_mem_global { struct kobject kobj ; struct ttm_mem_shrink * shrink ; struct workqueue_struct * swap_queue ; struct work_struct work ; wait_queue_head_t queue ; spinlock_t lock ; struct ttm_mem_zone * zones [ 2 ] ; unsigned int num_zones ; struct ttm_mem_zone * zone_kernel ; struct ttm_mem_zone * zone_dma32 ; } ;

enum ttm_global_types { TTM_GLOBAL_TTM_MEM = 0 , TTM_GLOBAL_TTM_BO , TTM_GLOBAL_TTM_OBJECT , TTM_GLOBAL_NUM } ;

struct ttm_global_reference { enum ttm_global_types global_type ; size_t size ; void * object ; int ( * init ) ( struct ttm_global_reference * ) ; void ( * release ) ( struct ttm_global_reference * ) ; } ;

struct ttm_backend ;

struct ttm_backend_func { int ( * populate ) ( struct ttm_backend * backend , unsigned long num_pages , struct page * * pages , struct page * dummy_read_page ) ; void ( * clear ) ( struct ttm_backend * backend ) ; int ( * bind ) ( struct ttm_backend * backend , struct ttm_mem_reg * bo_mem ) ; int ( * unbind ) ( struct ttm_backend * backend ) ; void ( * destroy ) ( struct ttm_backend * backend ) ; } ;

struct ttm_backend { struct ttm_bo_device * bdev ; uint32_t flags ; struct ttm_backend_func * func ; } ;
enum ttm_caching_state { tt_uncached , tt_wc , tt_cached } ;

struct ttm_tt { struct page * dummy_read_page ; struct page * * pages ; long first_himem_page ; long last_lomem_page ; uint32_t page_flags ; unsigned long num_pages ; struct ttm_bo_global * glob ; struct ttm_backend * be ; struct task_struct * tsk ; unsigned long start ; struct file * swap_storage ; enum ttm_caching_state caching_state ; enum { tt_bound , tt_unbound , tt_unpopulated , } state ; } ;
struct ttm_mem_type_manager { bool has_type ; bool use_type ; uint32_t flags ; unsigned long gpu_offset ; unsigned long io_offset ; unsigned long io_size ; void * io_addr ; uint64_t size ; uint32_t available_caching ; uint32_t default_caching ; struct drm_mm manager ; struct list_head lru ; } ;

struct ttm_bo_driver { struct ttm_backend * ( * create_ttm_backend_entry ) ( struct ttm_bo_device * bdev ) ; int ( * invalidate_caches ) ( struct ttm_bo_device * bdev , uint32_t flags ) ; int ( * init_mem_type ) ( struct ttm_bo_device * bdev , uint32_t type , struct ttm_mem_type_manager * man ) ; void ( * evict_flags ) ( struct ttm_buffer_object * bo , struct ttm_placement * placement ) ; int ( * move ) ( struct ttm_buffer_object * bo , bool evict , bool interruptible , bool no_wait , struct ttm_mem_reg * new_mem ) ; int ( * verify_access ) ( struct ttm_buffer_object * bo , struct file * filp ) ; bool ( * sync_obj_signaled ) ( void * sync_obj , void * sync_arg ) ; int ( * sync_obj_wait ) ( void * sync_obj , void * sync_arg , bool lazy , bool interruptible ) ; int ( * sync_obj_flush ) ( void * sync_obj , void * sync_arg ) ; void ( * sync_obj_unref ) ( void * * sync_obj ) ; void * ( * sync_obj_ref ) ( void * sync_obj ) ; void ( * move_notify ) ( struct ttm_buffer_object * bo , struct ttm_mem_reg * new_mem ) ; void ( * fault_reserve_notify ) ( struct ttm_buffer_object * bo ) ; void ( * swap_notify ) ( struct ttm_buffer_object * bo ) ; } ;

struct ttm_bo_global_ref { struct ttm_global_reference ref ; struct ttm_mem_global * mem_glob ; } ;

struct ttm_bo_global { struct kobject kobj ; struct ttm_mem_global * mem_glob ; struct page * dummy_read_page ; struct ttm_mem_shrink shrink ; size_t ttm_bo_extra_size ; size_t ttm_bo_size ; struct mutex device_list_mutex ; spinlock_t lru_lock ; struct list_head device_list ; struct list_head swap_lru ; atomic_t bo_count ; } ;

struct ttm_bo_device { struct list_head device_list ; struct ttm_bo_global * glob ; struct ttm_bo_driver * driver ; rwlock_t vm_lock ; struct ttm_mem_type_manager man [ 8 ] ; struct rb_root addr_space_rb ; struct drm_mm addr_space_mm ; struct list_head ddestroy ; bool nice_mode ; struct address_space * dev_mapping ; struct delayed_work wq ; bool need_dma32 ; } ;
struct nouveau_fpriv { struct ttm_object_file * tfile ; } ;

struct drm_nouveau_channel_alloc { uint32_t fb_ctxdma_handle ; uint32_t tt_ctxdma_handle ; int channel ; uint32_t notifier_handle ; struct { uint32_t handle ; uint32_t grclass ; } subchan [ 8 ] ; uint32_t nr_subchan ; } ;

struct drm_nouveau_channel_free { int channel ; } ;

struct drm_nouveau_grobj_alloc { int channel ; uint32_t handle ; int class ; } ;

struct drm_nouveau_notifierobj_alloc { uint32_t channel ; uint32_t handle ; uint32_t size ; uint32_t offset ; } ;

struct drm_nouveau_gpuobj_free { int channel ; uint32_t handle ; } ;

struct drm_nouveau_getparam { uint64_t param ; uint64_t value ; } ;

struct drm_nouveau_setparam { uint64_t param ; uint64_t value ; } ;

struct drm_nouveau_gem_info { uint32_t handle ; uint32_t domain ; uint64_t size ; uint64_t offset ; uint64_t map_handle ; uint32_t tile_mode ; uint32_t tile_flags ; } ;

struct drm_nouveau_gem_new { struct drm_nouveau_gem_info info ; uint32_t channel_hint ; uint32_t align ; } ;

struct drm_nouveau_gem_pushbuf_bo { uint64_t user_priv ; uint32_t handle ; uint32_t read_domains ; uint32_t write_domains ; uint32_t valid_domains ; uint32_t presumed_ok ; uint32_t presumed_domain ; uint64_t presumed_offset ; } ;

struct drm_nouveau_gem_pushbuf_reloc { uint32_t bo_index ; uint32_t reloc_index ; uint32_t flags ; uint32_t data ; uint32_t vor ; uint32_t tor ; } ;

struct drm_nouveau_gem_pushbuf { uint32_t channel ; uint32_t nr_dwords ; uint32_t nr_buffers ; uint32_t nr_relocs ; uint64_t dwords ; uint64_t buffers ; uint64_t relocs ; } ;

struct drm_nouveau_gem_pushbuf_call { uint32_t channel ; uint32_t handle ; uint32_t offset ; uint32_t nr_buffers ; uint32_t nr_relocs ; uint32_t nr_dwords ; uint64_t buffers ; uint64_t relocs ; uint32_t suffix0 ; uint32_t suffix1 ; uint64_t vram_available ; uint64_t gart_available ; } ;

struct drm_nouveau_gem_pin { uint32_t handle ; uint32_t domain ; uint64_t offset ; } ;

struct drm_nouveau_gem_unpin { uint32_t handle ; } ;

struct drm_nouveau_gem_cpu_prep { uint32_t handle ; uint32_t flags ; } ;

struct drm_nouveau_gem_cpu_fini { uint32_t handle ; } ;

struct drm_nouveau_gem_tile { uint32_t handle ; uint32_t offset ; uint32_t size ; uint32_t tile_mode ; uint32_t tile_flags ; } ;

enum nouveau_bus_type { NV_AGP = 0 , NV_PCI = 1 , NV_PCIE = 2 , } ;

struct drm_nouveau_sarea { } ;

struct dcb_i2c_entry ;

struct nouveau_i2c_chan { struct i2c_adapter adapter ; struct drm_device * dev ; union { struct i2c_algo_bit_data bit ; struct i2c_algo_dp_aux_data dp ; } algo ; unsigned rd ; unsigned wr ; unsigned data ; } ;

struct dcb_entry { int index ; uint8_t type ; uint8_t i2c_index ; uint8_t heads ; uint8_t connector ; uint8_t bus ; uint8_t location ; uint8_t or ; bool duallink_possible ; union { struct sor_conf { int link ; } sorconf ; struct { int maxfreq ; } crtconf ; struct { struct sor_conf sor ; bool use_straps_for_mode ; bool use_power_scripts ; } lvdsconf ; struct { bool has_component_output ; } tvconf ; struct { struct sor_conf sor ; int link_nr ; int link_bw ; } dpconf ; struct { struct sor_conf sor ; } tmdsconf ; } ; bool i2c_upper_default ; } ;

struct dcb_i2c_entry { uint8_t port_type ; uint8_t read , write ; struct nouveau_i2c_chan * chan ; } ;
struct parsed_dcb { int entries ; struct dcb_entry entry [ 16 ] ; struct dcb_i2c_entry i2c [ 16 ] ; } ;

enum dcb_gpio_tag { DCB_GPIO_TVDAC0 = 0xc , DCB_GPIO_TVDAC1 = 0x2d , } ;

struct dcb_gpio_entry { enum dcb_gpio_tag tag ; int line ; bool invert ; } ;

struct parsed_dcb_gpio { int entries ; struct dcb_gpio_entry entry [ 32 ] ; } ;

struct dcb_connector_table_entry { uint32_t entry ; uint8_t type ; uint8_t index ; uint8_t gpio_tag ; } ;

struct dcb_connector_table { int entries ; struct dcb_connector_table_entry entry [ 16 ] ; } ;

struct bios_parsed_dcb { uint8_t version ; struct parsed_dcb dcb ; uint8_t * i2c_table ; uint8_t i2c_default_indices ; uint16_t gpio_table_ptr ; struct parsed_dcb_gpio gpio ; uint16_t connector_table_ptr ; struct dcb_connector_table connector ; } ;

enum nouveau_encoder_type { OUTPUT_ANALOG = 0 , OUTPUT_TV = 1 , OUTPUT_TMDS = 2 , OUTPUT_LVDS = 3 , OUTPUT_DP = 6 , OUTPUT_ANY = - 1 } ;

enum nouveau_or { OUTPUT_A = ( 1 << 0 ) , OUTPUT_B = ( 1 << 1 ) , OUTPUT_C = ( 1 << 2 ) } ;

enum LVDS_script { LVDS_INIT = 1 , LVDS_RESET , LVDS_BACKLIGHT_ON , LVDS_BACKLIGHT_OFF , LVDS_PANEL_ON , LVDS_PANEL_OFF } ;

enum pll_types { NVPLL , MPLL , VPLL1 , VPLL2 } ;

struct pll_lims { struct { int minfreq ; int maxfreq ; int min_inputfreq ; int max_inputfreq ; uint8_t min_m ; uint8_t max_m ; uint8_t min_n ; uint8_t max_n ; } vco1 , vco2 ; uint8_t max_log2p ; uint8_t max_usable_log2p ; uint8_t log2p_bias ; uint8_t min_p ; uint8_t max_p ; int refclk ; } ;

struct nouveau_bios_info { struct parsed_dcb * dcb ; uint8_t chip_version ; uint32_t dactestval ; uint32_t tvdactestval ; uint8_t digital_min_front_porch ; bool fp_no_ddc ; } ;

struct nvbios { struct drm_device * dev ; struct nouveau_bios_info pub ; struct mutex lock ; uint8_t data [ 0x00010000 ] ; unsigned int length ; bool execute ; uint8_t major_version ; uint8_t feature_byte ; bool is_mobile ; uint32_t fmaxvco , fminvco ; bool old_style_init ; uint16_t init_script_tbls_ptr ; uint16_t extra_init_script_tbl_ptr ; uint16_t macro_index_tbl_ptr ; uint16_t macro_tbl_ptr ; uint16_t condition_tbl_ptr ; uint16_t io_condition_tbl_ptr ; uint16_t io_flag_condition_tbl_ptr ; uint16_t init_function_tbl_ptr ; uint16_t pll_limit_tbl_ptr ; uint16_t ram_restrict_tbl_ptr ; uint8_t ram_restrict_group_count ; uint16_t some_script_ptr ; uint16_t init96_tbl_ptr ; struct bios_parsed_dcb bdcb ; struct { int crtchead ; uint32_t saved_nv_pfb_cfg0 ; } state ; struct { struct dcb_entry * output ; uint16_t script_table_ptr ; uint16_t dp_table_ptr ; } display ; struct { uint16_t fptablepointer ; uint16_t fpxlatetableptr ; int xlatwidth ; uint16_t lvdsmanufacturerpointer ; uint16_t fpxlatemanufacturertableptr ; uint16_t mode_ptr ; uint16_t xlated_entry ; bool power_off_for_reset ; bool reset_after_pclk_change ; bool dual_link ; bool link_c_increment ; bool BITbit1 ; bool if_is_24bit ; int duallink_transition_clk ; uint8_t strapless_is_24bit ; uint8_t * edid ; int last_script_invoc ; bool lvds_init_run ; } fp ; struct { uint16_t output0_script_ptr ; uint16_t output1_script_ptr ; } tmds ; struct { uint16_t mem_init_tbl_ptr ; uint16_t sdr_seq_tbl_ptr ; uint16_t ddr_seq_tbl_ptr ; struct { uint8_t crt , tv , panel ; } i2c_indices ; uint16_t lvds_single_a_script_ptr ; } legacy ; } ;

struct nouveau_grctx ;

struct nouveau_tile_reg { struct nouveau_fence * fence ; uint32_t addr ; uint32_t size ; bool used ; } ;

struct nouveau_bo { struct ttm_buffer_object bo ; struct ttm_placement placement ; u32 placements [ 3 ] ; struct ttm_bo_kmap_obj kmap ; struct list_head head ; struct drm_file * reserved_by ; struct list_head entry ; int pbbo_index ; struct nouveau_channel * channel ; bool mappable ; bool no_vm ; uint32_t tile_mode ; uint32_t tile_flags ; struct nouveau_tile_reg * tile ; struct drm_gem_object * gem ; struct drm_file * cpu_filp ; int pin_refcnt ; } ;

struct mem_block { struct mem_block * next ; struct mem_block * prev ; uint64_t start ; uint64_t size ; struct drm_file * file_priv ; } ;
enum nouveau_flags { NV_NFORCE = 0x10000000 , NV_NFORCE2 = 0x20000000 } ;

struct nouveau_gpuobj { struct list_head list ; struct nouveau_channel * im_channel ; struct mem_block * im_pramin ; struct nouveau_bo * im_backing ; uint32_t im_backing_start ; uint32_t * im_backing_suspend ; int im_bound ; uint32_t flags ; int refcount ; uint32_t engine ; uint32_t class ; void ( * dtor ) ( struct drm_device * , struct nouveau_gpuobj * ) ; void * priv ; } ;

struct nouveau_gpuobj_ref { struct list_head list ; struct nouveau_gpuobj * gpuobj ; uint32_t instance ; struct nouveau_channel * channel ; int handle ; } ;

struct nouveau_channel { struct drm_device * dev ; int id ; struct drm_file * file_priv ; struct drm_local_map * map ; void * user ; uint32_t user_get ; uint32_t user_put ; struct { spinlock_t lock ; struct list_head pending ; uint32_t sequence ; uint32_t sequence_ack ; uint32_t last_sequence_irq ; } fence ; struct nouveau_gpuobj_ref * pushbuf ; struct nouveau_bo * pushbuf_bo ; uint32_t pushbuf_base ; struct nouveau_bo * notifier_bo ; struct mem_block * notifier_heap ; struct nouveau_gpuobj_ref * ramfc ; struct nouveau_gpuobj_ref * cache ; struct nouveau_gpuobj_ref * ramin_grctx ; void * pgraph_ctx ; struct nouveau_gpuobj * vm_pd ; struct nouveau_gpuobj_ref * vm_gart_pt ; struct nouveau_gpuobj_ref * vm_vram_pt [ ( ( 2 * 1024 * 1024 * 1024ULL ) / ( 512 * 1024 * 1024ULL ) ) ] ; struct nouveau_gpuobj_ref * ramin ; struct mem_block * ramin_heap ; struct nouveau_gpuobj_ref * ramht ; struct list_head ramht_refs ; uint32_t m2mf_ntfy ; uint32_t vram_handle ; uint32_t gart_handle ; bool accel_done ; struct { int max ; int free ; int cur ; int put ; } dma ; uint32_t sw_subchannel [ 8 ] ; struct { struct nouveau_gpuobj * vblsem ; uint32_t vblsem_offset ; uint32_t vblsem_rval ; struct list_head vbl_wait ; } nvsw ; struct { bool active ; char name [ 32 ] ; struct drm_info_list info ; } debugfs ; } ;

struct nouveau_instmem_engine { void * priv ; int ( * init ) ( struct drm_device * dev ) ; void ( * takedown ) ( struct drm_device * dev ) ; int ( * suspend ) ( struct drm_device * dev ) ; void ( * resume ) ( struct drm_device * dev ) ; int ( * populate ) ( struct drm_device * , struct nouveau_gpuobj * , uint32_t * size ) ; void ( * clear ) ( struct drm_device * , struct nouveau_gpuobj * ) ; int ( * bind ) ( struct drm_device * , struct nouveau_gpuobj * ) ; int ( * unbind ) ( struct drm_device * , struct nouveau_gpuobj * ) ; void ( * prepare_access ) ( struct drm_device * , bool write ) ; void ( * finish_access ) ( struct drm_device * ) ; } ;

struct nouveau_mc_engine { int ( * init ) ( struct drm_device * dev ) ; void ( * takedown ) ( struct drm_device * dev ) ; } ;

struct nouveau_timer_engine { int ( * init ) ( struct drm_device * dev ) ; void ( * takedown ) ( struct drm_device * dev ) ; uint64_t ( * read ) ( struct drm_device * dev ) ; } ;

struct nouveau_fb_engine { int num_tiles ; int ( * init ) ( struct drm_device * dev ) ; void ( * takedown ) ( struct drm_device * dev ) ; void ( * set_region_tiling ) ( struct drm_device * dev , int i , uint32_t addr , uint32_t size , uint32_t pitch ) ; } ;

struct nouveau_fifo_engine { void * priv ; int channels ; int ( * init ) ( struct drm_device * ) ; void ( * takedown ) ( struct drm_device * ) ; void ( * disable ) ( struct drm_device * ) ; void ( * enable ) ( struct drm_device * ) ; bool ( * reassign ) ( struct drm_device * , bool enable ) ; bool ( * cache_flush ) ( struct drm_device * dev ) ; bool ( * cache_pull ) ( struct drm_device * dev , bool enable ) ; int ( * channel_id ) ( struct drm_device * ) ; int ( * create_context ) ( struct nouveau_channel * ) ; void ( * destroy_context ) ( struct nouveau_channel * ) ; int ( * load_context ) ( struct nouveau_channel * ) ; int ( * unload_context ) ( struct drm_device * ) ; } ;

struct nouveau_pgraph_object_method { int id ; int ( * exec ) ( struct nouveau_channel * chan , int grclass , int mthd , uint32_t data ) ; } ;

struct nouveau_pgraph_object_class { int id ; bool software ; struct nouveau_pgraph_object_method * methods ; } ;

struct nouveau_pgraph_engine { struct nouveau_pgraph_object_class * grclass ; bool accel_blocked ; void * ctxprog ; void * ctxvals ; int grctx_size ; int ( * init ) ( struct drm_device * ) ; void ( * takedown ) ( struct drm_device * ) ; void ( * fifo_access ) ( struct drm_device * , bool ) ; struct nouveau_channel * ( * channel ) ( struct drm_device * ) ; int ( * create_context ) ( struct nouveau_channel * ) ; void ( * destroy_context ) ( struct nouveau_channel * ) ; int ( * load_context ) ( struct nouveau_channel * ) ; int ( * unload_context ) ( struct drm_device * ) ; void ( * set_region_tiling ) ( struct drm_device * dev , int i , uint32_t addr , uint32_t size , uint32_t pitch ) ; } ;

struct nouveau_engine { struct nouveau_instmem_engine instmem ; struct nouveau_mc_engine mc ; struct nouveau_timer_engine timer ; struct nouveau_fb_engine fb ; struct nouveau_pgraph_engine graph ; struct nouveau_fifo_engine fifo ; } ;

struct nouveau_pll_vals { union { struct { uint8_t M1 , N1 , M2 , N2 ; } ; struct { uint16_t NM1 , NM2 ; } __attribute__ ( ( packed ) ) ; } ; int log2P ; int refclk ; } ;

enum nv04_fp_display_regs { FP_DISPLAY_END , FP_TOTAL , FP_CRTC , FP_SYNC_START , FP_SYNC_END , FP_VALID_START , FP_VALID_END } ;

struct nv04_crtc_reg { unsigned char MiscOutReg ; uint8_t CRTC [ 0x9f ] ; uint8_t CR58 [ 0x10 ] ; uint8_t Sequencer [ 5 ] ; uint8_t Graphics [ 9 ] ; uint8_t Attribute [ 21 ] ; unsigned char DAC [ 768 ] ; uint32_t fb_start ; uint32_t crtc_cfg ; uint32_t cursor_cfg ; uint32_t gpio_ext ; uint32_t crtc_830 ; uint32_t crtc_834 ; uint32_t crtc_850 ; uint32_t crtc_eng_ctrl ; uint32_t nv10_cursync ; struct nouveau_pll_vals pllvals ; uint32_t ramdac_gen_ctrl ; uint32_t ramdac_630 ; uint32_t ramdac_634 ; uint32_t tv_setup ; uint32_t tv_vtotal ; uint32_t tv_vskew ; uint32_t tv_vsync_delay ; uint32_t tv_htotal ; uint32_t tv_hskew ; uint32_t tv_hsync_delay ; uint32_t tv_hsync_delay2 ; uint32_t fp_horiz_regs [ 7 ] ; uint32_t fp_vert_regs [ 7 ] ; uint32_t dither ; uint32_t fp_control ; uint32_t dither_regs [ 6 ] ; uint32_t fp_debug_0 ; uint32_t fp_debug_1 ; uint32_t fp_debug_2 ; uint32_t fp_margin_color ; uint32_t ramdac_8c0 ; uint32_t ramdac_a20 ; uint32_t ramdac_a24 ; uint32_t ramdac_a34 ; uint32_t ctv_regs [ 38 ] ; } ;

struct nv04_output_reg { uint32_t output ; int head ; } ;

struct nv04_mode_state { uint32_t bpp ; uint32_t width ; uint32_t height ; uint32_t interlace ; uint32_t repaint0 ; uint32_t repaint1 ; uint32_t screen ; uint32_t scale ; uint32_t dither ; uint32_t extra ; uint32_t fifo ; uint32_t pixel ; uint32_t horiz ; int arbitration0 ; int arbitration1 ; uint32_t pll ; uint32_t pllB ; uint32_t vpll ; uint32_t vpll2 ; uint32_t vpllB ; uint32_t vpll2B ; uint32_t pllsel ; uint32_t sel_clk ; uint32_t general ; uint32_t crtcOwner ; uint32_t head ; uint32_t head2 ; uint32_t cursorConfig ; uint32_t cursor0 ; uint32_t cursor1 ; uint32_t cursor2 ; uint32_t timingH ; uint32_t timingV ; uint32_t displayV ; uint32_t crtcSync ; struct nv04_crtc_reg crtc_reg [ 2 ] ; } ;

enum nouveau_card_type { NV_04 = 0x00 , NV_10 = 0x10 , NV_20 = 0x20 , NV_30 = 0x30 , NV_40 = 0x40 , NV_50 = 0x50 , } ;

struct drm_nouveau_private { struct drm_device * dev ; enum { NOUVEAU_CARD_INIT_DOWN , NOUVEAU_CARD_INIT_DONE , NOUVEAU_CARD_INIT_FAILED } init_state ; enum nouveau_card_type card_type ; int chipset ; int flags ; void * mmio ; void * ramin ; uint32_t ramin_size ; struct nouveau_bo * vga_ram ; struct workqueue_struct * wq ; struct work_struct irq_work ; struct list_head vbl_waiting ; struct { struct ttm_global_reference mem_global_ref ; struct ttm_bo_global_ref bo_global_ref ; struct ttm_bo_device bdev ; spinlock_t bo_list_lock ; struct list_head bo_list ; atomic_t validate_sequence ; } ttm ; struct fb_info * fbdev_info ; int fifo_alloc_count ; struct nouveau_channel * fifos [ 128 ] ; struct nouveau_engine engine ; struct nouveau_channel * channel ; struct nouveau_gpuobj * ramht ; uint32_t ramin_rsvd_vram ; uint32_t ramht_offset ; uint32_t ramht_size ; uint32_t ramht_bits ; uint32_t ramfc_offset ; uint32_t ramfc_size ; uint32_t ramro_offset ; uint32_t ramro_size ; uint64_t fb_phys ; uint64_t fb_available_size ; uint64_t fb_mappable_pages ; uint64_t fb_aper_free ; struct { enum { NOUVEAU_GART_NONE = 0 , NOUVEAU_GART_AGP , NOUVEAU_GART_SGDMA } type ; uint64_t aper_base ; uint64_t aper_size ; uint64_t aper_free ; struct nouveau_gpuobj * sg_ctxdma ; struct page * sg_dummy_page ; dma_addr_t sg_dummy_bus ; struct drm_ttm_backend * sg_be ; unsigned long sg_handle ; } gart_info ; struct { struct nouveau_tile_reg reg [ 15 ] ; spinlock_t lock ; } tile ; uint64_t vm_gart_base ; uint64_t vm_gart_size ; uint64_t vm_vram_base ; uint64_t vm_vram_size ; uint64_t vm_end ; struct nouveau_gpuobj * vm_vram_pt [ ( ( 2 * 1024 * 1024 * 1024ULL ) / ( 512 * 1024 * 1024ULL ) ) ] ; int vm_vram_pt_nr ; uint64_t vram_sys_base ; int fb_mtrr ; struct mem_block * ramin_heap ; uint32_t ctx_table_size ; struct nouveau_gpuobj_ref * ctx_table ; struct list_head gpuobj_list ; struct nvbios VBIOS ; struct nouveau_bios_info * vbios ; struct nv04_mode_state mode_reg ; struct nv04_mode_state saved_reg ; uint32_t saved_vga_font [ 4 ] [ 16384 ] ; uint32_t crtc_owner ; uint32_t dac_users [ 4 ] ; struct nouveau_suspend_resume { uint32_t fifo_mode ; uint32_t graph_ctx_control ; uint32_t graph_state ; uint32_t * ramin_copy ; uint64_t ramin_size ; } susres ; struct backlight_device * backlight ; bool acpi_dsm ; struct nouveau_channel * evo ; struct { struct dentry * channel_root ; } debugfs ; } ;

struct nouveau_fence ;

enum { NOUVEAU_REG_DEBUG_MC = 0x1 , NOUVEAU_REG_DEBUG_VIDEO = 0x2 , NOUVEAU_REG_DEBUG_FB = 0x4 , NOUVEAU_REG_DEBUG_EXTDEV = 0x8 , NOUVEAU_REG_DEBUG_CRTC = 0x10 , NOUVEAU_REG_DEBUG_RAMDAC = 0x20 , NOUVEAU_REG_DEBUG_VGACRTC = 0x40 , NOUVEAU_REG_DEBUG_RMVIO = 0x80 , NOUVEAU_REG_DEBUG_VGAATTR = 0x100 , NOUVEAU_REG_DEBUG_EVO = 0x200 , } ;
struct nouveau_framebuffer { struct drm_framebuffer base ; struct nouveau_bo * nvbo ; } ;

struct nouveau_fbcon_par { struct drm_fb_helper helper ; struct drm_device * dev ; struct nouveau_framebuffer * nouveau_fb ; } ;

enum { NvSubM2MF = 0 , NvSubSw = 1 , NvSub2D = 2 , NvSubCtxSurf2D = 2 , NvSubGdiRect = 3 , NvSubImageBlit = 4 } ;
enum { NvM2MF = 0x80000001 , NvDmaFB = 0x80000002 , NvDmaTT = 0x80000003 , NvDmaVRAM = 0x80000004 , NvDmaGART = 0x80000005 , NvNotify0 = 0x80000006 , Nv2D = 0x80000007 , NvCtxSurf2D = 0x80000008 , NvRop = 0x80000009 , NvImagePatt = 0x8000000a , NvClipRect = 0x8000000b , NvGdiRect = 0x8000000c , NvImageBlit = 0x8000000d , NvSw = 0x8000000e , NvEvoVRAM = 0x01000000 , NvEvoFB16 = 0x01000001 , NvEvoFB32 = 0x01000002 } ;
struct nouveau_crtc { struct drm_crtc base ; int index ; struct drm_display_mode * mode ; uint32_t dpms_saved_fp_control ; uint32_t fp_users ; int saturation ; int sharpness ; int last_dpms ; struct { int cpp ; bool blanked ; uint32_t offset ; uint32_t tile_flags ; } fb ; struct { struct nouveau_bo * nvbo ; bool visible ; uint32_t offset ; void ( * set_offset ) ( struct nouveau_crtc * , uint32_t offset ) ; void ( * set_pos ) ( struct nouveau_crtc * , int x , int y ) ; void ( * hide ) ( struct nouveau_crtc * , bool update ) ; void ( * show ) ( struct nouveau_crtc * , bool update ) ; } cursor ; struct { struct nouveau_bo * nvbo ; uint16_t r [ 256 ] ; uint16_t g [ 256 ] ; uint16_t b [ 256 ] ; int depth ; } lut ; int ( * set_dither ) ( struct nouveau_crtc * crtc , bool on , bool update ) ; int ( * set_scale ) ( struct nouveau_crtc * crtc , int mode , bool update ) ; } ;

struct drm_sarea_drawable { unsigned int stamp ; unsigned int flags ; } ;

struct drm_sarea_frame { unsigned int x ; unsigned int y ; unsigned int width ; unsigned int height ; unsigned int fullscreen ; } ;

struct drm_sarea { struct drm_hw_lock lock ; struct drm_hw_lock drawable_lock ; struct drm_sarea_drawable drawableTable [ 256 ] ; struct drm_sarea_frame frame ; drm_context_t dummy_context ; } ;

int nouveau_card_init ( struct drm_device * dev ) ;

void nouveau_preclose ( struct drm_device * dev , struct drm_file * file_priv ) ;

int nouveau_firstopen ( struct drm_device * dev ) ;

int nouveau_load ( struct drm_device * dev , unsigned long flags ) ;

void nouveau_lastclose ( struct drm_device * dev ) ;

int nouveau_unload ( struct drm_device * dev ) ;

int nouveau_ioctl_card_init ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_ioctl_getparam ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_ioctl_setparam ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

bool nouveau_wait_until ( struct drm_device * dev , uint64_t timeout , uint32_t reg , uint32_t mask , uint32_t val ) ;

bool nouveau_wait_for_idle ( struct drm_device * dev ) ;

int nouveau_channel_alloc ( struct drm_device * dev , struct nouveau_channel * * chan_ret , struct drm_file * file_priv , uint32_t vram_handle , uint32_t tt_handle ) ;

void nouveau_channel_free ( struct nouveau_channel * chan ) ;

void nouveau_channel_cleanup ( struct drm_device * dev , struct drm_file * file_priv ) ;

int nouveau_channel_owner ( struct drm_device * dev , struct drm_file * file_priv , int channel ) ;

struct mem_block * nouveau_mem_alloc_block ( struct mem_block * heap , uint64_t size , int align2 , struct drm_file * file_priv , int tail ) ;

void nouveau_mem_free_block ( struct mem_block * p ) ;

int nouveau_mem_init_heap ( struct mem_block * * heap , uint64_t start , uint64_t size ) ;

void nouveau_mem_release ( struct drm_file * file_priv , struct mem_block * heap ) ;

struct nouveau_tile_reg * nv10_mem_set_tiling ( struct drm_device * dev , uint32_t addr , uint32_t size , uint32_t pitch ) ;

void nv10_mem_expire_tiling ( struct drm_device * dev , struct nouveau_tile_reg * tile , struct nouveau_fence * fence ) ;

int nv50_mem_vm_bind_linear ( struct drm_device * dev , uint64_t virt , uint32_t size , uint32_t flags , uint64_t phys ) ;

void nv50_mem_vm_unbind ( struct drm_device * dev , uint64_t virt , uint32_t size ) ;

void nouveau_mem_takedown ( struct mem_block * * heap ) ;

void nouveau_mem_close ( struct drm_device * dev ) ;

uint64_t nouveau_mem_fb_amount ( struct drm_device * dev ) ;

int nouveau_mem_init_agp ( struct drm_device * dev ) ;

int nouveau_mem_init ( struct drm_device * dev ) ;

int nouveau_gpuobj_new ( struct drm_device * dev , struct nouveau_channel * chan , uint32_t size , int align , uint32_t flags , struct nouveau_gpuobj * * gpuobj_ret ) ;

int nouveau_gpuobj_early_init ( struct drm_device * dev ) ;

int nouveau_gpuobj_init ( struct drm_device * dev ) ;

void nouveau_gpuobj_takedown ( struct drm_device * dev ) ;

void nouveau_gpuobj_late_takedown ( struct drm_device * dev ) ;

int nouveau_gpuobj_del ( struct drm_device * dev , struct nouveau_gpuobj * * pgpuobj ) ;

int nouveau_gpuobj_ref_add ( struct drm_device * dev , struct nouveau_channel * chan , uint32_t handle , struct nouveau_gpuobj * gpuobj , struct nouveau_gpuobj_ref * * ref_ret ) ;

int nouveau_gpuobj_ref_del ( struct drm_device * dev , struct nouveau_gpuobj_ref * * pref ) ;

int nouveau_gpuobj_new_ref ( struct drm_device * dev , struct nouveau_channel * oc , struct nouveau_channel * rc , uint32_t handle , uint32_t size , int align , uint32_t flags , struct nouveau_gpuobj_ref * * ref ) ;

int nouveau_gpuobj_ref_find ( struct nouveau_channel * chan , uint32_t handle , struct nouveau_gpuobj_ref * * ref_ret ) ;

int nouveau_gpuobj_new_fake ( struct drm_device * dev , uint32_t p_offset , uint32_t b_offset , uint32_t size , uint32_t flags , struct nouveau_gpuobj * * pgpuobj , struct nouveau_gpuobj_ref * * pref ) ;

int nouveau_gpuobj_dma_new ( struct nouveau_channel * chan , int class , uint64_t offset , uint64_t size , int access , int target , struct nouveau_gpuobj * * gpuobj ) ;

int nouveau_gpuobj_gart_dma_new ( struct nouveau_channel * chan , uint64_t offset , uint64_t size , int access , struct nouveau_gpuobj * * gpuobj , uint32_t * o_ret ) ;

int nouveau_gpuobj_gr_new ( struct nouveau_channel * chan , int class , struct nouveau_gpuobj * * gpuobj ) ;

int nouveau_gpuobj_sw_new ( struct nouveau_channel * chan , int class , struct nouveau_gpuobj * * gpuobj_ret ) ;

int nouveau_gpuobj_channel_init ( struct nouveau_channel * chan , uint32_t vram_h , uint32_t tt_h ) ;

void nouveau_gpuobj_channel_takedown ( struct nouveau_channel * chan ) ;

int nouveau_gpuobj_suspend ( struct drm_device * dev ) ;

void nouveau_gpuobj_suspend_cleanup ( struct drm_device * dev ) ;

void nouveau_gpuobj_resume ( struct drm_device * dev ) ;

int nouveau_ioctl_grobj_alloc ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_ioctl_gpuobj_free ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

struct nouveau_connector { struct drm_connector base ; struct dcb_connector_table_entry * dcb ; int scaling_mode ; bool use_dithering ; struct nouveau_encoder * detected_encoder ; struct edid * edid ; struct drm_display_mode * native_mode ; } ;

void nouveau_irq_preinstall ( struct drm_device * dev ) ;

int nouveau_irq_postinstall ( struct drm_device * dev ) ;

void nouveau_irq_uninstall ( struct drm_device * dev ) ;

struct nouveau_bitfield_names { uint32_t mask ; const char * name ; } ;

struct nouveau_pgraph_trap { int channel ; int class ; int subc , mthd , size ; uint32_t data , data2 ; uint32_t nsource , nstatus ; } ;

irqreturn_t nouveau_irq_handler ( int irq , void * arg ) ;

int nouveau_notifier_init_channel ( struct nouveau_channel * chan ) ;

void nouveau_notifier_takedown_channel ( struct nouveau_channel * chan ) ;

int nouveau_notifier_alloc ( struct nouveau_channel * chan , uint32_t handle , int size , uint32_t * b_offset ) ;

int nouveau_notifier_offset ( struct nouveau_gpuobj * nobj , uint32_t * poffset ) ;

int nouveau_ioctl_notifier_alloc ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

struct nouveau_sgdma_be { struct ttm_backend backend ; struct drm_device * dev ; dma_addr_t * pages ; unsigned nr_pages ; unsigned pte_start ; bool bound ; } ;

struct ttm_backend * nouveau_sgdma_init_ttm ( struct drm_device * dev ) ;

int nouveau_sgdma_init ( struct drm_device * dev ) ;

void nouveau_sgdma_takedown ( struct drm_device * dev ) ;

int nouveau_sgdma_get_page ( struct drm_device * dev , uint32_t offset , uint32_t * page ) ;

void nouveau_dma_pre_init ( struct nouveau_channel * chan ) ;

int nouveau_dma_init ( struct nouveau_channel * chan ) ;

void OUT_RINGp ( struct nouveau_channel * chan , const void * data , unsigned nr_dwords ) ;

int nouveau_dma_wait ( struct nouveau_channel * chan , int size ) ;

int nouveau_bo_new ( struct drm_device * dev , struct nouveau_channel * chan , int size , int align , uint32_t flags , uint32_t tile_mode , uint32_t tile_flags , bool no_vm , bool mappable , struct nouveau_bo * * pnvbo ) ;

void nouveau_bo_placement_set ( struct nouveau_bo * nvbo , uint32_t memtype ) ;

int nouveau_bo_pin ( struct nouveau_bo * nvbo , uint32_t memtype ) ;

int nouveau_bo_unpin ( struct nouveau_bo * nvbo ) ;

int nouveau_bo_map ( struct nouveau_bo * nvbo ) ;

void nouveau_bo_unmap ( struct nouveau_bo * nvbo ) ;

u16 nouveau_bo_rd16 ( struct nouveau_bo * nvbo , unsigned index ) ;

void nouveau_bo_wr16 ( struct nouveau_bo * nvbo , unsigned index , u16 val ) ;

u32 nouveau_bo_rd32 ( struct nouveau_bo * nvbo , unsigned index ) ;

void nouveau_bo_wr32 ( struct nouveau_bo * nvbo , unsigned index , u32 val ) ;

struct nouveau_fence { struct nouveau_channel * channel ; struct kref refcount ; struct list_head entry ; uint32_t sequence ; bool signalled ; } ;
void nouveau_fence_update ( struct nouveau_channel * chan ) ;

int nouveau_fence_new ( struct nouveau_channel * chan , struct nouveau_fence * * pfence , bool emit ) ;

struct nouveau_channel * nouveau_fence_channel ( struct nouveau_fence * fence ) ;

int nouveau_fence_emit ( struct nouveau_fence * fence ) ;

void nouveau_fence_unref ( void * * sync_obj ) ;

void * nouveau_fence_ref ( void * sync_obj ) ;

bool nouveau_fence_signalled ( void * sync_obj , void * sync_arg ) ;

int nouveau_fence_wait ( void * sync_obj , void * sync_arg , bool lazy , bool intr ) ;

int nouveau_fence_flush ( void * sync_obj , void * sync_arg ) ;

void nouveau_fence_handler ( struct drm_device * dev , int channel ) ;

int nouveau_fence_init ( struct nouveau_channel * chan ) ;

void nouveau_fence_fini ( struct nouveau_channel * chan ) ;

int nouveau_gem_object_new ( struct drm_gem_object * gem ) ;

void nouveau_gem_object_del ( struct drm_gem_object * gem ) ;

int nouveau_gem_new ( struct drm_device * dev , struct nouveau_channel * chan , int size , int align , uint32_t flags , uint32_t tile_mode , uint32_t tile_flags , bool no_vm , bool mappable , struct nouveau_bo * * pnvbo ) ;

int nouveau_gem_ioctl_new ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

struct validate_op { struct list_head vram_list ; struct list_head gart_list ; struct list_head both_list ; } ;

int nouveau_gem_ioctl_pushbuf ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_gem_ioctl_pushbuf_call ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_gem_ioctl_pushbuf_call2 ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_gem_ioctl_pin ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_gem_ioctl_unpin ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_gem_ioctl_cpu_prep ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_gem_ioctl_cpu_fini ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_gem_ioctl_info ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int nouveau_ttm_mmap ( struct file * filp , struct vm_area_struct * vma ) ;

int nouveau_ttm_global_init ( struct drm_nouveau_private * dev_priv ) ;

void nouveau_ttm_global_release ( struct drm_nouveau_private * dev_priv ) ;

void NVWriteVgaSeq ( struct drm_device * dev , int head , uint8_t index , uint8_t value ) ;

uint8_t NVReadVgaSeq ( struct drm_device * dev , int head , uint8_t index ) ;

void NVWriteVgaGr ( struct drm_device * dev , int head , uint8_t index , uint8_t value ) ;

uint8_t NVReadVgaGr ( struct drm_device * dev , int head , uint8_t index ) ;

void NVSetOwner ( struct drm_device * dev , int owner ) ;

void NVBlankScreen ( struct drm_device * dev , int head , bool blank ) ;

void nouveau_hw_setpll ( struct drm_device * dev , uint32_t reg1 , struct nouveau_pll_vals * pv ) ;

int nouveau_hw_get_pllvals ( struct drm_device * dev , enum pll_types plltype , struct nouveau_pll_vals * pllvals ) ;

int nouveau_hw_pllvals_to_clk ( struct nouveau_pll_vals * pv ) ;

int nouveau_hw_get_clock ( struct drm_device * dev , enum pll_types plltype ) ;

void nouveau_hw_save_vga_fonts ( struct drm_device * dev , bool save ) ;

void nouveau_hw_load_state_palette ( struct drm_device * dev , int head , struct nv04_mode_state * state ) ;

void nouveau_hw_save_state ( struct drm_device * dev , int head , struct nv04_mode_state * state ) ;

void nouveau_hw_load_state ( struct drm_device * dev , int head , struct nv04_mode_state * state ) ;

struct nv_fifo_info { int lwm ; int burst ; } ;

struct nv_sim_state { int pclk_khz ; int mclk_khz ; int nvclk_khz ; int bpp ; int mem_page_miss ; int mem_latency ; int memory_type ; int memory_width ; int two_heads ; } ;

void nouveau_calc_arb ( struct drm_device * dev , int vclk , int bpp , int * burst , int * lwm ) ;

int nouveau_calc_pll_mnp ( struct drm_device * dev , struct pll_lims * pll_lim , int clk , struct nouveau_pll_vals * pv ) ;

struct init_exec { bool execute ; bool repeat ; } ;

struct methods { const char desc [ 8 ] ; void ( * loadbios ) ( struct drm_device * , uint8_t * ) ; const bool rw ; } ;

struct init_tbl_entry { char * name ; uint8_t id ; int ( * handler ) ( struct nvbios * , uint16_t , struct init_exec * ) ; } ;

struct bit_entry { uint8_t id [ 2 ] ; uint16_t length ; uint16_t offset ; } ;

int call_lvds_script ( struct drm_device * dev , struct dcb_entry * dcbent , int head , enum LVDS_script script , int pxclk ) ;

struct lvdstableheader { uint8_t lvds_ver , headerlen , recordlen ; } ;

bool nouveau_bios_fp_mode ( struct drm_device * dev , struct drm_display_mode * mode ) ;

int nouveau_bios_parse_lvds_table ( struct drm_device * dev , int pxclk , bool * dl , bool * if_is_24bit ) ;

void * nouveau_bios_dp_table ( struct drm_device * dev , struct dcb_entry * dcbent , int * length ) ;

int nouveau_bios_run_display_table ( struct drm_device * dev , struct dcb_entry * dcbent , uint32_t sub , int pxclk ) ;

int run_tmds_table ( struct drm_device * dev , struct dcb_entry * dcbent , int head , int pxclk ) ;

int get_pll_limits ( struct drm_device * dev , uint32_t limit_match , struct pll_lims * pll_lim ) ;

struct bit_table { const char id ; int ( * const parse_fn ) ( struct drm_device * , struct nvbios * , struct bit_entry * ) ; } ;

struct dcb_gpio_entry * nouveau_bios_gpio_entry ( struct drm_device * dev , enum dcb_gpio_tag tag ) ;

struct dcb_connector_table_entry * nouveau_bios_connector_entry ( struct drm_device * dev , int index ) ;

uint8_t * nouveau_bios_embedded_edid ( struct drm_device * dev ) ;

void nouveau_bios_run_init_table ( struct drm_device * dev , uint16_t table , struct dcb_entry * dcbent ) ;

int nouveau_run_vbios_init ( struct drm_device * dev ) ;

int nouveau_bios_init ( struct drm_device * dev ) ;

void nouveau_bios_takedown ( struct drm_device * dev ) ;

int nouveau_i2c_init ( struct drm_device * dev , struct dcb_i2c_entry * entry , int index ) ;

void nouveau_i2c_fini ( struct drm_device * dev , struct dcb_i2c_entry * entry ) ;

struct nouveau_i2c_chan * nouveau_i2c_find ( struct drm_device * dev , int index ) ;

struct drm_framebuffer * nouveau_framebuffer_create ( struct drm_device * dev , struct nouveau_bo * nvbo , struct drm_mode_fb_cmd * mode_cmd ) ;

struct drm_encoder_slave_funcs { void ( * set_config ) ( struct drm_encoder * encoder , void * params ) ; void ( * destroy ) ( struct drm_encoder * encoder ) ; void ( * dpms ) ( struct drm_encoder * encoder , int mode ) ; void ( * save ) ( struct drm_encoder * encoder ) ; void ( * restore ) ( struct drm_encoder * encoder ) ; bool ( * mode_fixup ) ( struct drm_encoder * encoder , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ; int ( * mode_valid ) ( struct drm_encoder * encoder , struct drm_display_mode * mode ) ; void ( * mode_set ) ( struct drm_encoder * encoder , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ; enum drm_connector_status ( * detect ) ( struct drm_encoder * encoder , struct drm_connector * connector ) ; int ( * get_modes ) ( struct drm_encoder * encoder , struct drm_connector * connector ) ; int ( * create_resources ) ( struct drm_encoder * encoder , struct drm_connector * connector ) ; int ( * set_property ) ( struct drm_encoder * encoder , struct drm_connector * connector , struct drm_property * property , uint64_t val ) ; } ;

struct drm_encoder_slave { struct drm_encoder base ; struct drm_encoder_slave_funcs * slave_funcs ; void * slave_priv ; void * bus_priv ; } ;

struct drm_i2c_encoder_driver { struct i2c_driver i2c_driver ; int ( * encoder_init ) ( struct i2c_client * client , struct drm_device * dev , struct drm_encoder_slave * encoder ) ; } ;

struct nouveau_encoder { struct drm_encoder_slave base ; struct dcb_entry * dcb ; int or ; struct drm_display_mode mode ; int last_dpms ; struct nv04_output_reg restore ; void ( * disconnect ) ( struct nouveau_encoder * encoder ) ; union { struct { int dpcd_version ; int link_nr ; int link_bw ; } dp ; } ; } ;

struct bit_displayport_encoder_table { uint32_t match ; uint8_t record_nr ; uint8_t unknown ; uint16_t script0 ; uint16_t script1 ; uint16_t unknown_table ; } __attribute__ ( ( packed ) ) ;
struct bit_displayport_encoder_table_entry { uint8_t vs_level ; uint8_t pre_level ; uint8_t reg0 ; uint8_t reg1 ; uint8_t reg2 ; } __attribute__ ( ( packed ) ) ;
struct nouveau_connector * nouveau_encoder_connector_get ( struct nouveau_encoder * encoder ) ;

struct moderec { int hdisplay ; int vdisplay ; } ;

int nouveau_connector_create ( struct drm_device * dev , int index , int type ) ;

void nouveau_fbcon_zfill ( struct drm_device * dev ) ;

int nouveau_fbcon_probe ( struct drm_device * dev ) ;

int nouveau_fbcon_remove ( struct drm_device * dev , struct drm_framebuffer * fb ) ;

void nouveau_fbcon_gpu_lockup ( struct fb_info * info ) ;

bool nouveau_dp_link_train ( struct drm_encoder * encoder ) ;

bool nouveau_dp_detect ( struct drm_encoder * encoder ) ;

int nouveau_dp_auxch ( struct nouveau_i2c_chan * auxch , int cmd , int addr , uint8_t * data , int data_nr ) ;

int nouveau_dp_i2c_aux_ch ( struct i2c_adapter * adapter , int mode , uint8_t write_byte , uint8_t * read_byte ) ;

struct nouveau_ctxprog { uint32_t signature ; uint8_t version ; uint16_t length ; uint32_t data [ ] ; } __attribute__ ( ( packed ) ) ;
struct nouveau_ctxvals { uint32_t signature ; uint8_t version ; uint32_t length ; struct { uint32_t offset ; uint32_t value ; } data [ ] ; } __attribute__ ( ( packed ) ) ;
int nouveau_grctx_prog_load ( struct drm_device * dev ) ;

void nouveau_grctx_fini ( struct drm_device * dev ) ;

void nouveau_grctx_vals_load ( struct drm_device * dev , struct nouveau_gpuobj * ctx ) ;

int nv04_timer_init ( struct drm_device * dev ) ;

uint64_t nv04_timer_read ( struct drm_device * dev ) ;

void nv04_timer_takedown ( struct drm_device * dev ) ;

int nv04_mc_init ( struct drm_device * dev ) ;

void nv04_mc_takedown ( struct drm_device * dev ) ;

int nv40_mc_init ( struct drm_device * dev ) ;

void nv40_mc_takedown ( struct drm_device * dev ) ;

int nv50_mc_init ( struct drm_device * dev ) ;

void nv50_mc_takedown ( struct drm_device * dev ) ;

int nv04_fb_init ( struct drm_device * dev ) ;

void nv04_fb_takedown ( struct drm_device * dev ) ;

void nv10_fb_set_region_tiling ( struct drm_device * dev , int i , uint32_t addr , uint32_t size , uint32_t pitch ) ;

int nv10_fb_init ( struct drm_device * dev ) ;

void nv10_fb_takedown ( struct drm_device * dev ) ;

void nv40_fb_set_region_tiling ( struct drm_device * dev , int i , uint32_t addr , uint32_t size , uint32_t pitch ) ;

int nv40_fb_init ( struct drm_device * dev ) ;

void nv40_fb_takedown ( struct drm_device * dev ) ;

void nv04_fifo_disable ( struct drm_device * dev ) ;

void nv04_fifo_enable ( struct drm_device * dev ) ;

bool nv04_fifo_reassign ( struct drm_device * dev , bool enable ) ;

bool nv04_fifo_cache_flush ( struct drm_device * dev ) ;

bool nv04_fifo_cache_pull ( struct drm_device * dev , bool enable ) ;

int nv04_fifo_channel_id ( struct drm_device * dev ) ;

int nv04_fifo_create_context ( struct nouveau_channel * chan ) ;

void nv04_fifo_destroy_context ( struct nouveau_channel * chan ) ;

int nv04_fifo_load_context ( struct nouveau_channel * chan ) ;

int nv04_fifo_unload_context ( struct drm_device * dev ) ;

int nv04_fifo_init ( struct drm_device * dev ) ;

int nv10_fifo_channel_id ( struct drm_device * dev ) ;

int nv10_fifo_create_context ( struct nouveau_channel * chan ) ;

void nv10_fifo_destroy_context ( struct nouveau_channel * chan ) ;

int nv10_fifo_load_context ( struct nouveau_channel * chan ) ;

int nv10_fifo_unload_context ( struct drm_device * dev ) ;

int nv10_fifo_init ( struct drm_device * dev ) ;

int nv40_fifo_create_context ( struct nouveau_channel * chan ) ;

void nv40_fifo_destroy_context ( struct nouveau_channel * chan ) ;

int nv40_fifo_load_context ( struct nouveau_channel * chan ) ;

int nv40_fifo_unload_context ( struct drm_device * dev ) ;

int nv40_fifo_init ( struct drm_device * dev ) ;

struct nv50_fifo_priv { struct nouveau_gpuobj_ref * thingo [ 2 ] ; int cur_thingo ; } ;

int nv50_fifo_init ( struct drm_device * dev ) ;

void nv50_fifo_takedown ( struct drm_device * dev ) ;

int nv50_fifo_channel_id ( struct drm_device * dev ) ;

int nv50_fifo_create_context ( struct nouveau_channel * chan ) ;

void nv50_fifo_destroy_context ( struct nouveau_channel * chan ) ;

int nv50_fifo_load_context ( struct nouveau_channel * chan ) ;

int nv50_fifo_unload_context ( struct drm_device * dev ) ;

struct graph_state { int nv04 [ ( sizeof ( nv04_graph_ctx_regs ) / sizeof ( ( nv04_graph_ctx_regs ) [ 0 ] ) + ( sizeof ( struct { int : - ! ! ( __builtin_types_compatible_p ( typeof ( nv04_graph_ctx_regs ) , typeof ( & nv04_graph_ctx_regs [ 0 ] ) ) ) ; } ) ) ) ] ; } ;

struct nouveau_channel * nv04_graph_channel ( struct drm_device * dev ) ;

void nv04_graph_context_switch ( struct drm_device * dev ) ;

int nv04_graph_create_context ( struct nouveau_channel * chan ) ;

void nv04_graph_destroy_context ( struct nouveau_channel * chan ) ;

int nv04_graph_load_context ( struct nouveau_channel * chan ) ;

int nv04_graph_unload_context ( struct drm_device * dev ) ;

int nv04_graph_init ( struct drm_device * dev ) ;

void nv04_graph_takedown ( struct drm_device * dev ) ;

void nv04_graph_fifo_access ( struct drm_device * dev , bool enabled ) ;

struct pipe_state { uint32_t pipe_0x0000 [ 0x040 / 4 ] ; uint32_t pipe_0x0040 [ 0x010 / 4 ] ; uint32_t pipe_0x0200 [ 0x0c0 / 4 ] ; uint32_t pipe_0x4400 [ 0x080 / 4 ] ; uint32_t pipe_0x6400 [ 0x3b0 / 4 ] ; uint32_t pipe_0x6800 [ 0x2f0 / 4 ] ; uint32_t pipe_0x6c00 [ 0x030 / 4 ] ; uint32_t pipe_0x7000 [ 0x130 / 4 ] ; uint32_t pipe_0x7400 [ 0x0c0 / 4 ] ; uint32_t pipe_0x7800 [ 0x0c0 / 4 ] ; } ;

struct graph_state { int nv10 [ ( sizeof ( nv10_graph_ctx_regs ) / sizeof ( ( nv10_graph_ctx_regs ) [ 0 ] ) + ( sizeof ( struct { int : - ! ! ( __builtin_types_compatible_p ( typeof ( nv10_graph_ctx_regs ) , typeof ( & nv10_graph_ctx_regs [ 0 ] ) ) ) ; } ) ) ) ] ; int nv17 [ ( sizeof ( nv17_graph_ctx_regs ) / sizeof ( ( nv17_graph_ctx_regs ) [ 0 ] ) + ( sizeof ( struct { int : - ! ! ( __builtin_types_compatible_p ( typeof ( nv17_graph_ctx_regs ) , typeof ( & nv17_graph_ctx_regs [ 0 ] ) ) ) ; } ) ) ) ] ; struct pipe_state pipe_state ; uint32_t lma_window [ 4 ] ; } ;
int nv10_graph_load_context ( struct nouveau_channel * chan ) ;

int nv10_graph_unload_context ( struct drm_device * dev ) ;

void nv10_graph_context_switch ( struct drm_device * dev ) ;

struct nouveau_channel * nv10_graph_channel ( struct drm_device * dev ) ;

int nv10_graph_create_context ( struct nouveau_channel * chan ) ;

void nv10_graph_destroy_context ( struct nouveau_channel * chan ) ;

void nv10_graph_set_region_tiling ( struct drm_device * dev , int i , uint32_t addr , uint32_t size , uint32_t pitch ) ;

int nv10_graph_init ( struct drm_device * dev ) ;

void nv10_graph_takedown ( struct drm_device * dev ) ;

int nv20_graph_create_context ( struct nouveau_channel * chan ) ;

void nv20_graph_destroy_context ( struct nouveau_channel * chan ) ;

int nv20_graph_load_context ( struct nouveau_channel * chan ) ;

int nv20_graph_unload_context ( struct drm_device * dev ) ;

void nv20_graph_set_region_tiling ( struct drm_device * dev , int i , uint32_t addr , uint32_t size , uint32_t pitch ) ;

int nv20_graph_init ( struct drm_device * dev ) ;

void nv20_graph_takedown ( struct drm_device * dev ) ;

int nv30_graph_init ( struct drm_device * dev ) ;

struct nouveau_grctx { struct drm_device * dev ; enum { NOUVEAU_GRCTX_PROG , NOUVEAU_GRCTX_VALS } mode ; void * data ; uint32_t ctxprog_max ; uint32_t ctxprog_len ; uint32_t ctxprog_reg ; int ctxprog_label [ 32 ] ; uint32_t ctxvals_pos ; uint32_t ctxvals_base ; } ;
struct nouveau_channel * nv40_graph_channel ( struct drm_device * dev ) ;

int nv40_graph_create_context ( struct nouveau_channel * chan ) ;

void nv40_graph_destroy_context ( struct nouveau_channel * chan ) ;

int nv40_graph_load_context ( struct nouveau_channel * chan ) ;

int nv40_graph_unload_context ( struct drm_device * dev ) ;

void nv40_graph_set_region_tiling ( struct drm_device * dev , int i , uint32_t addr , uint32_t size , uint32_t pitch ) ;

int nv40_graph_init ( struct drm_device * dev ) ;

void nv40_graph_takedown ( struct drm_device * dev ) ;

int nv50_graph_init ( struct drm_device * dev ) ;

void nv50_graph_takedown ( struct drm_device * dev ) ;

void nv50_graph_fifo_access ( struct drm_device * dev , bool enabled ) ;

struct nouveau_channel * nv50_graph_channel ( struct drm_device * dev ) ;

int nv50_graph_create_context ( struct nouveau_channel * chan ) ;

void nv50_graph_destroy_context ( struct nouveau_channel * chan ) ;

int nv50_graph_load_context ( struct nouveau_channel * chan ) ;

int nv50_graph_unload_context ( struct drm_device * dev ) ;

void nv50_graph_context_switch ( struct drm_device * dev ) ;

enum cp_label { cp_check_load = 1 , cp_setup_auto_load , cp_setup_load , cp_setup_save , cp_swap_state , cp_swap_state3d_3_is_save , cp_prepare_exit , cp_exit , } ;

void nv40_grctx_init ( struct nouveau_grctx * ctx ) ;

enum cp_label { cp_check_load = 1 , cp_setup_auto_load , cp_setup_load , cp_setup_save , cp_swap_state , cp_prepare_exit , cp_exit , } ;
int nv50_grctx_init ( struct nouveau_grctx * ctx ) ;

int nv04_instmem_init ( struct drm_device * dev ) ;

void nv04_instmem_takedown ( struct drm_device * dev ) ;

int nv04_instmem_populate ( struct drm_device * dev , struct nouveau_gpuobj * gpuobj , uint32_t * sz ) ;

void nv04_instmem_clear ( struct drm_device * dev , struct nouveau_gpuobj * gpuobj ) ;

int nv04_instmem_bind ( struct drm_device * dev , struct nouveau_gpuobj * gpuobj ) ;

int nv04_instmem_unbind ( struct drm_device * dev , struct nouveau_gpuobj * gpuobj ) ;

void nv04_instmem_prepare_access ( struct drm_device * dev , bool write ) ;

void nv04_instmem_finish_access ( struct drm_device * dev ) ;

int nv04_instmem_suspend ( struct drm_device * dev ) ;

void nv04_instmem_resume ( struct drm_device * dev ) ;

struct nv50_instmem_priv { uint32_t save1700 [ 5 ] ; struct nouveau_gpuobj_ref * pramin_pt ; struct nouveau_gpuobj_ref * pramin_bar ; struct nouveau_gpuobj_ref * fb_bar ; bool last_access_wr ; } ;

int nv50_instmem_init ( struct drm_device * dev ) ;

void nv50_instmem_takedown ( struct drm_device * dev ) ;

int nv50_instmem_suspend ( struct drm_device * dev ) ;

void nv50_instmem_resume ( struct drm_device * dev ) ;

int nv50_instmem_populate ( struct drm_device * dev , struct nouveau_gpuobj * gpuobj , uint32_t * sz ) ;

void nv50_instmem_clear ( struct drm_device * dev , struct nouveau_gpuobj * gpuobj ) ;

int nv50_instmem_bind ( struct drm_device * dev , struct nouveau_gpuobj * gpuobj ) ;

int nv50_instmem_unbind ( struct drm_device * dev , struct nouveau_gpuobj * gpuobj ) ;

void nv50_instmem_prepare_access ( struct drm_device * dev , bool write ) ;

void nv50_instmem_finish_access ( struct drm_device * dev ) ;

int nv50_crtc_blank ( struct nouveau_crtc * nv_crtc , bool blanked ) ;

struct nouveau_connector * nouveau_crtc_connector_get ( struct nouveau_crtc * nv_crtc ) ;

int nv50_crtc_set_clock ( struct drm_device * dev , int head , int pclk ) ;

int nv50_crtc_cursor_set ( struct drm_crtc * crtc , struct drm_file * file_priv , uint32_t buffer_handle , uint32_t width , uint32_t height ) ;

int nv50_crtc_cursor_move ( struct drm_crtc * crtc , int x , int y ) ;

int nv50_crtc_create ( struct drm_device * dev , int index ) ;

int nv50_dac_create ( struct drm_device * dev , struct dcb_entry * entry ) ;

int nv50_sor_create ( struct drm_device * dev , struct dcb_entry * entry ) ;

int nv50_cursor_init ( struct nouveau_crtc * nv_crtc ) ;

void nv50_cursor_fini ( struct nouveau_crtc * nv_crtc ) ;

int nv50_display_init ( struct drm_device * dev ) ;

int nv50_display_create ( struct drm_device * dev ) ;

int nv50_display_destroy ( struct drm_device * dev ) ;

void nv50_display_irq_handler_bh ( struct work_struct * work ) ;

void nv50_display_irq_handler ( struct drm_device * dev ) ;

void nv50_fbcon_fillrect ( struct fb_info * info , const struct fb_fillrect * rect ) ;

void nv50_fbcon_copyarea ( struct fb_info * info , const struct fb_copyarea * region ) ;

void nv50_fbcon_imageblit ( struct fb_info * info , const struct fb_image * image ) ;

int nv50_fbcon_accel_init ( struct fb_info * info ) ;

int nv04_dac_output_offset ( struct drm_encoder * encoder ) ;

uint32_t nv17_dac_sample_load ( struct drm_encoder * encoder ) ;

void nv04_dac_update_dacclk ( struct drm_encoder * encoder , bool enable ) ;

int nv04_dac_create ( struct drm_device * dev , struct dcb_entry * entry ) ;

int nv04_dfp_get_bound_head ( struct drm_device * dev , struct dcb_entry * dcbent ) ;

void nv04_dfp_bind_head ( struct drm_device * dev , struct dcb_entry * dcbent , int head , bool dl ) ;

void nv04_dfp_disable ( struct drm_device * dev , int head ) ;

void nv04_dfp_update_fp_control ( struct drm_encoder * encoder , int mode ) ;

int nv04_dfp_create ( struct drm_device * dev , struct dcb_entry * entry ) ;

struct ch7006_encoder_params { enum { CH7006_FORMAT_RGB16 = 0 , CH7006_FORMAT_YCrCb24m16 , CH7006_FORMAT_RGB24m16 , CH7006_FORMAT_RGB15 , CH7006_FORMAT_RGB24m12C , CH7006_FORMAT_RGB24m12I , CH7006_FORMAT_RGB24m8 , CH7006_FORMAT_RGB16m8 , CH7006_FORMAT_RGB15m8 , CH7006_FORMAT_YCrCb24m8 , } input_format ; enum { CH7006_CLOCK_SLAVE = 0 , CH7006_CLOCK_MASTER , } clock_mode ; enum { CH7006_CLOCK_EDGE_NEG = 0 , CH7006_CLOCK_EDGE_POS , } clock_edge ; int xcm , pcm ; enum { CH7006_SYNC_SLAVE = 0 , CH7006_SYNC_MASTER , } sync_direction ; enum { CH7006_SYNC_SEPARATED = 0 , CH7006_SYNC_EMBEDDED , } sync_encoding ; enum { CH7006_POUT_1_8V = 0 , CH7006_POUT_3_3V , } pout_level ; enum { CH7006_ACTIVE_HSYNC = 0 , CH7006_ACTIVE_DSTART , } active_detect ; } ;

int nv04_tv_identify ( struct drm_device * dev , int i2c_index ) ;

int nv04_tv_create ( struct drm_device * dev , struct dcb_entry * entry ) ;

struct nv17_tv_state { uint8_t tv_enc [ 0x40 ] ; uint32_t hfilter [ 4 ] [ 7 ] ; uint32_t hfilter2 [ 4 ] [ 7 ] ; uint32_t vfilter [ 4 ] [ 7 ] ; uint32_t ptv_200 ; uint32_t ptv_204 ; uint32_t ptv_208 ; uint32_t ptv_20c ; uint32_t ptv_304 ; uint32_t ptv_500 ; uint32_t ptv_504 ; uint32_t ptv_508 ; uint32_t ptv_600 ; uint32_t ptv_604 ; uint32_t ptv_608 ; uint32_t ptv_60c ; uint32_t ptv_610 ; uint32_t ptv_614 ; } ;

enum nv17_tv_norm { TV_NORM_PAL , TV_NORM_PAL_M , TV_NORM_PAL_N , TV_NORM_PAL_NC , TV_NORM_NTSC_M , TV_NORM_NTSC_J , NUM_LD_TV_NORMS , TV_NORM_HD480I = NUM_LD_TV_NORMS , TV_NORM_HD480P , TV_NORM_HD576I , TV_NORM_HD576P , TV_NORM_HD720P , TV_NORM_HD1080I , NUM_TV_NORMS } ;

struct nv17_tv_encoder { struct nouveau_encoder base ; struct nv17_tv_state state ; struct nv17_tv_state saved_state ; int overscan ; int flicker ; int saturation ; int hue ; enum nv17_tv_norm tv_norm ; int subconnector ; int select_subconnector ; uint32_t pin_mask ; } ;


int nv17_tv_create ( struct drm_device * dev , struct dcb_entry * entry ) ;


void nv17_tv_state_save ( struct drm_device * dev , struct nv17_tv_state * state ) ;

void nv17_tv_state_load ( struct drm_device * dev , struct nv17_tv_state * state ) ;

void nv17_tv_update_properties ( struct drm_encoder * encoder ) ;

void nv17_tv_update_rescaler ( struct drm_encoder * encoder ) ;

void nv17_ctv_update_rescaler ( struct drm_encoder * encoder ) ;

int nv04_crtc_create ( struct drm_device * dev , int crtc_num ) ;

int nv04_display_create ( struct drm_device * dev ) ;

void nv04_display_destroy ( struct drm_device * dev ) ;

void nv04_display_restore ( struct drm_device * dev ) ;

int nv04_cursor_init ( struct nouveau_crtc * crtc ) ;

void nv04_fbcon_copyarea ( struct fb_info * info , const struct fb_copyarea * region ) ;

void nv04_fbcon_fillrect ( struct fb_info * info , const struct fb_fillrect * rect ) ;

void nv04_fbcon_imageblit ( struct fb_info * info , const struct fb_image * image ) ;

int nv04_fbcon_accel_init ( struct fb_info * info ) ;

int nv17_gpio_get ( struct drm_device * dev , enum dcb_gpio_tag tag ) ;

int nv17_gpio_set ( struct drm_device * dev , enum dcb_gpio_tag tag , int state ) ;

int nouveau_debugfs_channel_init ( struct nouveau_channel * chan ) ;

void nouveau_debugfs_channel_fini ( struct nouveau_channel * chan ) ;

int nouveau_debugfs_init ( struct drm_minor * minor ) ;

void nouveau_debugfs_takedown ( struct drm_minor * minor ) ;

long nouveau_compat_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

int nouveau_backlight_init ( struct drm_device * dev ) ;

void nouveau_backlight_exit ( struct drm_device * dev ) ;

int nouveau_hybrid_setup ( struct drm_device * dev ) ;

bool nouveau_dsm_probe ( struct drm_device * dev ) ;

typedef union { int i ; struct { unsigned char cmd_type , pad0 , pad1 , pad2 ; } header ; struct { unsigned char cmd_type , packet_id , pad0 , pad1 ; } packet ; struct { unsigned char cmd_type , offset , stride , count ; } scalars ; struct { unsigned char cmd_type , offset , stride , count ; } vectors ; struct { unsigned char cmd_type , addr_lo , addr_hi , count ; } veclinear ; struct { unsigned char cmd_type , buf_idx , pad0 , pad1 ; } dma ; struct { unsigned char cmd_type , flags , pad0 , pad1 ; } wait ; } drm_radeon_cmd_header_t ;

typedef union { unsigned int u ; struct { unsigned char cmd_type , pad0 , pad1 , pad2 ; } header ; struct { unsigned char cmd_type , count , reglo , reghi ; } packet0 ; struct { unsigned char cmd_type , count , adrlo , adrhi ; } vpu ; struct { unsigned char cmd_type , packet , pad0 , pad1 ; } packet3 ; struct { unsigned char cmd_type , packet ; unsigned short count ; } delay ; struct { unsigned char cmd_type , buf_idx , pad0 , pad1 ; } dma ; struct { unsigned char cmd_type , flags , pad0 , pad1 ; } wait ; struct { unsigned char cmd_type , reg , n_bufs , flags ; } scratch ; struct { unsigned char cmd_type , count , adrlo , adrhi_flags ; } r500fp ; } drm_r300_cmd_header_t ;

typedef struct { unsigned int red ; unsigned int green ; unsigned int blue ; unsigned int alpha ; } radeon_color_regs_t ;

typedef struct { unsigned int pp_misc ; unsigned int pp_fog_color ; unsigned int re_solid_color ; unsigned int rb3d_blendcntl ; unsigned int rb3d_depthoffset ; unsigned int rb3d_depthpitch ; unsigned int rb3d_zstencilcntl ; unsigned int pp_cntl ; unsigned int rb3d_cntl ; unsigned int rb3d_coloroffset ; unsigned int re_width_height ; unsigned int rb3d_colorpitch ; unsigned int se_cntl ; unsigned int se_coord_fmt ; unsigned int re_line_pattern ; unsigned int re_line_state ; unsigned int se_line_width ; unsigned int pp_lum_matrix ; unsigned int pp_rot_matrix_0 ; unsigned int pp_rot_matrix_1 ; unsigned int rb3d_stencilrefmask ; unsigned int rb3d_ropcntl ; unsigned int rb3d_planemask ; unsigned int se_vport_xscale ; unsigned int se_vport_xoffset ; unsigned int se_vport_yscale ; unsigned int se_vport_yoffset ; unsigned int se_vport_zscale ; unsigned int se_vport_zoffset ; unsigned int se_cntl_status ; unsigned int re_top_left ; unsigned int re_misc ; } drm_radeon_context_regs_t ;

typedef struct { unsigned int se_zbias_factor ; unsigned int se_zbias_constant ; } drm_radeon_context2_regs_t ;

typedef struct { unsigned int pp_txfilter ; unsigned int pp_txformat ; unsigned int pp_txoffset ; unsigned int pp_txcblend ; unsigned int pp_txablend ; unsigned int pp_tfactor ; unsigned int pp_border_color ; } drm_radeon_texture_regs_t ;

typedef struct { unsigned int start ; unsigned int finish ; unsigned int prim : 8 ; unsigned int stateidx : 8 ; unsigned int numverts : 16 ; unsigned int vc_format ; } drm_radeon_prim_t ;

typedef struct { drm_radeon_context_regs_t context ; drm_radeon_texture_regs_t tex [ 3 ] ; drm_radeon_context2_regs_t context2 ; unsigned int dirty ; } drm_radeon_state_t ;

typedef struct { drm_radeon_context_regs_t context_state ; drm_radeon_texture_regs_t tex_state [ 3 ] ; unsigned int dirty ; unsigned int vertsize ; unsigned int vc_format ; struct drm_clip_rect boxes [ 12 ] ; unsigned int nbox ; unsigned int last_frame ; unsigned int last_dispatch ; unsigned int last_clear ; struct drm_tex_region tex_list [ 2 ] [ 64 + 1 ] ; unsigned int tex_age [ 2 ] ; int ctx_owner ; int pfState ; int pfCurrentPage ; int crtc2_base ; int tiling_enabled ; } drm_radeon_sarea_t ;


typedef struct drm_radeon_init { enum { RADEON_INIT_CP = 0x01 , RADEON_CLEANUP_CP = 0x02 , RADEON_INIT_R200_CP = 0x03 , RADEON_INIT_R300_CP = 0x04 , RADEON_INIT_R600_CP = 0x05 } func ; unsigned long sarea_priv_offset ; int is_pci ; int cp_mode ; int gart_size ; int ring_size ; int usec_timeout ; unsigned int fb_bpp ; unsigned int front_offset , front_pitch ; unsigned int back_offset , back_pitch ; unsigned int depth_bpp ; unsigned int depth_offset , depth_pitch ; unsigned long fb_offset ; unsigned long mmio_offset ; unsigned long ring_offset ; unsigned long ring_rptr_offset ; unsigned long buffers_offset ; unsigned long gart_textures_offset ; } drm_radeon_init_t ;


typedef struct drm_radeon_cp_stop { int flush ; int idle ; } drm_radeon_cp_stop_t ;


typedef struct drm_radeon_fullscreen { enum { RADEON_INIT_FULLSCREEN = 0x01 , RADEON_CLEANUP_FULLSCREEN = 0x02 } func ; } drm_radeon_fullscreen_t ;


typedef union drm_radeon_clear_rect { float f [ 5 ] ; unsigned int ui [ 5 ] ; } drm_radeon_clear_rect_t ;


typedef struct drm_radeon_clear { unsigned int flags ; unsigned int clear_color ; unsigned int clear_depth ; unsigned int color_mask ; unsigned int depth_mask ; drm_radeon_clear_rect_t * depth_boxes ; } drm_radeon_clear_t ;


typedef struct drm_radeon_vertex { int prim ; int idx ; int count ; int discard ; } drm_radeon_vertex_t ;


typedef struct drm_radeon_indices { int prim ; int idx ; int start ; int end ; int discard ; } drm_radeon_indices_t ;


typedef struct drm_radeon_vertex2 { int idx ; int discard ; int nr_states ; drm_radeon_state_t * state ; int nr_prims ; drm_radeon_prim_t * prim ; } drm_radeon_vertex2_t ;


typedef struct drm_radeon_cmd_buffer { int bufsz ; char * buf ; int nbox ; struct drm_clip_rect * boxes ; } drm_radeon_cmd_buffer_t ;


typedef struct drm_radeon_tex_image { unsigned int x , y ; unsigned int width , height ; const void * data ; } drm_radeon_tex_image_t ;


typedef struct drm_radeon_texture { unsigned int offset ; int pitch ; int format ; int width ; int height ; drm_radeon_tex_image_t * image ; } drm_radeon_texture_t ;


typedef struct drm_radeon_stipple { unsigned int * mask ; } drm_radeon_stipple_t ;


typedef struct drm_radeon_indirect { int idx ; int start ; int end ; int discard ; } drm_radeon_indirect_t ;


typedef struct drm_radeon_getparam { int param ; void * value ; } drm_radeon_getparam_t ;


typedef struct drm_radeon_mem_alloc { int region ; int alignment ; int size ; int * region_offset ; } drm_radeon_mem_alloc_t ;


typedef struct drm_radeon_mem_free { int region ; int region_offset ; } drm_radeon_mem_free_t ;


typedef struct drm_radeon_mem_init_heap { int region ; int size ; int start ; } drm_radeon_mem_init_heap_t ;


typedef struct drm_radeon_irq_emit { int * irq_seq ; } drm_radeon_irq_emit_t ;


typedef struct drm_radeon_irq_wait { int irq_seq ; } drm_radeon_irq_wait_t ;


typedef struct drm_radeon_setparam { unsigned int param ; __s64 value ; } drm_radeon_setparam_t ;


typedef struct drm_radeon_surface_alloc { unsigned int address ; unsigned int size ; unsigned int flags ; } drm_radeon_surface_alloc_t ;


typedef struct drm_radeon_surface_free { unsigned int address ; } drm_radeon_surface_free_t ;

struct drm_radeon_gem_info { uint64_t gart_size ; uint64_t vram_size ; uint64_t vram_visible ; } ;

struct drm_radeon_gem_create { uint64_t size ; uint64_t alignment ; uint32_t handle ; uint32_t initial_domain ; uint32_t flags ; } ;

struct drm_radeon_gem_set_tiling { uint32_t handle ; uint32_t tiling_flags ; uint32_t pitch ; } ;

struct drm_radeon_gem_get_tiling { uint32_t handle ; uint32_t tiling_flags ; uint32_t pitch ; } ;

struct drm_radeon_gem_mmap { uint32_t handle ; uint32_t pad ; uint64_t offset ; uint64_t size ; uint64_t addr_ptr ; } ;

struct drm_radeon_gem_set_domain { uint32_t handle ; uint32_t read_domains ; uint32_t write_domain ; } ;

struct drm_radeon_gem_wait_idle { uint32_t handle ; uint32_t pad ; } ;

struct drm_radeon_gem_busy { uint32_t handle ; uint32_t domain ; } ;

struct drm_radeon_gem_pread { uint32_t handle ; uint32_t pad ; uint64_t offset ; uint64_t size ; uint64_t data_ptr ; } ;

struct drm_radeon_gem_pwrite { uint32_t handle ; uint32_t pad ; uint64_t offset ; uint64_t size ; uint64_t data_ptr ; } ;

struct drm_radeon_cs_chunk { uint32_t chunk_id ; uint32_t length_dw ; uint64_t chunk_data ; } ;

struct drm_radeon_cs_reloc { uint32_t handle ; uint32_t read_domains ; uint32_t write_domain ; uint32_t flags ; } ;

struct drm_radeon_cs { uint32_t num_chunks ; uint32_t cs_id ; uint64_t chunks ; uint64_t gart_limit ; uint64_t vram_limit ; } ;

struct drm_radeon_info { uint32_t request ; uint32_t pad ; uint64_t value ; } ;

enum radeon_family { CHIP_R100 , CHIP_RV100 , CHIP_RS100 , CHIP_RV200 , CHIP_RS200 , CHIP_R200 , CHIP_RV250 , CHIP_RS300 , CHIP_RV280 , CHIP_R300 , CHIP_R350 , CHIP_RV350 , CHIP_RV380 , CHIP_R420 , CHIP_R423 , CHIP_RV410 , CHIP_RS400 , CHIP_RS480 , CHIP_RS600 , CHIP_RS690 , CHIP_RS740 , CHIP_RV515 , CHIP_R520 , CHIP_RV530 , CHIP_RV560 , CHIP_RV570 , CHIP_R580 , CHIP_R600 , CHIP_RV610 , CHIP_RV630 , CHIP_RV670 , CHIP_RV620 , CHIP_RV635 , CHIP_RS780 , CHIP_RS880 , CHIP_RV770 , CHIP_RV730 , CHIP_RV710 , CHIP_RV740 , CHIP_LAST , } ;

enum radeon_chip_flags { RADEON_FAMILY_MASK = 0x0000ffffUL , RADEON_FLAGS_MASK = 0xffff0000UL , RADEON_IS_MOBILITY = 0x00010000UL , RADEON_IS_IGP = 0x00020000UL , RADEON_SINGLE_CRTC = 0x00040000UL , RADEON_IS_AGP = 0x00080000UL , RADEON_HAS_HIERZ = 0x00100000UL , RADEON_IS_PCIE = 0x00200000UL , RADEON_NEW_MEMMAP = 0x00400000UL , RADEON_IS_PCI = 0x00800000UL , RADEON_IS_IGPGART = 0x01000000UL , } ;

enum radeon_cp_microcode_version { UCODE_R100 , UCODE_R200 , UCODE_R300 , } ;


typedef struct drm_radeon_freelist { unsigned int age ; struct drm_buf * buf ; struct drm_radeon_freelist * next ; struct drm_radeon_freelist * prev ; } drm_radeon_freelist_t ;


typedef struct drm_radeon_ring_buffer { u32 * start ; u32 * end ; int size ; int size_l2qw ; int rptr_update ; int rptr_update_l2qw ; int fetch_size ; int fetch_size_l2ow ; u32 tail ; u32 tail_mask ; int space ; int high_mark ; } drm_radeon_ring_buffer_t ;


typedef struct drm_radeon_depth_clear_t { u32 rb3d_cntl ; u32 rb3d_zstencilcntl ; u32 se_cntl ; } drm_radeon_depth_clear_t ;

struct drm_radeon_driver_file_fields { int64_t radeon_fb_delta ; } ;

struct radeon_surface { int refcount ; u32 lower ; u32 upper ; u32 flags ; } ;

struct radeon_virt_surface { int surface_index ; u32 lower ; u32 upper ; u32 flags ; struct drm_file * file_priv ; } ;

struct drm_radeon_master_private { drm_local_map_t * sarea ; drm_radeon_sarea_t * sarea_priv ; } ;


typedef struct drm_radeon_private { drm_radeon_ring_buffer_t ring ; u32 fb_location ; u32 fb_size ; int new_memmap ; int gart_size ; u32 gart_vm_start ; unsigned long gart_buffers_offset ; int cp_mode ; int cp_running ; drm_radeon_freelist_t * head ; drm_radeon_freelist_t * tail ; int last_buf ; int writeback_works ; int usec_timeout ; int microcode_version ; struct { u32 boxes ; int freelist_timeouts ; int freelist_loops ; int requested_bufs ; int last_frame_reads ; int last_clear_reads ; int clears ; int texture_uploads ; } stats ; int do_boxes ; int page_flipping ; u32 color_fmt ; unsigned int front_offset ; unsigned int front_pitch ; unsigned int back_offset ; unsigned int back_pitch ; u32 depth_fmt ; unsigned int depth_offset ; unsigned int depth_pitch ; u32 front_pitch_offset ; u32 back_pitch_offset ; u32 depth_pitch_offset ; drm_radeon_depth_clear_t depth_clear ; unsigned long ring_offset ; unsigned long ring_rptr_offset ; unsigned long buffers_offset ; unsigned long gart_textures_offset ; drm_local_map_t * sarea ; drm_local_map_t * cp_ring ; drm_local_map_t * ring_rptr ; drm_local_map_t * gart_textures ; struct mem_block * gart_heap ; struct mem_block * fb_heap ; wait_queue_head_t swi_queue ; atomic_t swi_emitted ; int vblank_crtc ; uint32_t irq_enable_reg ; uint32_t r500_disp_irq_reg ; struct radeon_surface surfaces [ 8 ] ; struct radeon_virt_surface virt_surfaces [ 2 * 8 ] ; unsigned long pcigart_offset ; unsigned int pcigart_offset_set ; struct drm_ati_pcigart_info gart_info ; u32 scratch_ages [ 5 ] ; int have_z_offset ; uint32_t flags ; resource_size_t fb_aper_offset ; int num_gb_pipes ; int num_z_pipes ; int track_flush ; drm_local_map_t * mmio ; int r600_max_pipes ; int r600_max_tile_pipes ; int r600_max_simds ; int r600_max_backends ; int r600_max_gprs ; int r600_max_threads ; int r600_max_stack_entries ; int r600_max_hw_contexts ; int r600_max_gs_threads ; int r600_sx_max_export_size ; int r600_sx_max_export_pos_size ; int r600_sx_max_export_smx_size ; int r600_sq_num_cf_insts ; int r700_sx_num_of_sets ; int r700_sc_prim_fifo_size ; int r700_sc_hiz_tile_fifo_size ; int r700_sc_earlyz_tile_fifo_fize ; struct mutex cs_mutex ; u32 cs_id_scnt ; u32 cs_id_wcnt ; struct drm_buf * blit_vb ; const struct firmware * me_fw , * pfp_fw ; } drm_radeon_private_t ;


typedef struct drm_radeon_buf_priv { u32 age ; } drm_radeon_buf_priv_t ;


typedef struct drm_radeon_kcmd_buffer { int bufsz ; char * buf ; int nbox ; struct drm_clip_rect * boxes ; } drm_radeon_kcmd_buffer_t ;

u32 radeon_read_ring_rptr ( drm_radeon_private_t * dev_priv , u32 off ) ;

u32 radeon_get_ring_head ( drm_radeon_private_t * dev_priv ) ;

void radeon_write_ring_rptr ( drm_radeon_private_t * dev_priv , u32 off , u32 val ) ;

void radeon_set_ring_head ( drm_radeon_private_t * dev_priv , u32 val ) ;

u32 radeon_get_scratch ( drm_radeon_private_t * dev_priv , int index ) ;

u32 RADEON_READ_MM ( drm_radeon_private_t * dev_priv , int addr ) ;

u32 radeon_read_fb_location ( drm_radeon_private_t * dev_priv ) ;

void radeon_write_agp_location ( drm_radeon_private_t * dev_priv , u32 agp_loc ) ;

void radeon_write_agp_base ( drm_radeon_private_t * dev_priv , u64 agp_base ) ;

void radeon_enable_bm ( struct drm_radeon_private * dev_priv ) ;

int radeon_do_cp_idle ( drm_radeon_private_t * dev_priv ) ;

int radeon_cp_init ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_start ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_stop ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void radeon_do_release ( struct drm_device * dev ) ;

int radeon_cp_reset ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_idle ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_resume ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_engine_reset ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_fullscreen ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

struct drm_buf * radeon_freelist_get ( struct drm_device * dev ) ;

void radeon_freelist_reset ( struct drm_device * dev ) ;

int radeon_wait_ring ( drm_radeon_private_t * dev_priv , int n ) ;

int radeon_cp_buffers ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_driver_load ( struct drm_device * dev , unsigned long flags ) ;

int radeon_master_create ( struct drm_device * dev , struct drm_master * master ) ;

void radeon_master_destroy ( struct drm_device * dev , struct drm_master * master ) ;

int radeon_driver_firstopen ( struct drm_device * dev ) ;

int radeon_driver_unload ( struct drm_device * dev ) ;

void radeon_commit_ring ( drm_radeon_private_t * dev_priv ) ;

void radeon_cp_dispatch_flip ( struct drm_device * dev , struct drm_master * master ) ;

typedef struct { unsigned int start ; unsigned int finish ; unsigned int prim ; unsigned int numverts ; unsigned int offset ; unsigned int vc_format ; } drm_radeon_tcl_prim_t ;

void radeon_cp_discard_buffer ( struct drm_device * dev , struct drm_master * master , struct drm_buf * buf ) ;

void radeon_driver_preclose ( struct drm_device * dev , struct drm_file * file_priv ) ;

void radeon_driver_lastclose ( struct drm_device * dev ) ;

int radeon_driver_open ( struct drm_device * dev , struct drm_file * file_priv ) ;

void radeon_driver_postclose ( struct drm_device * dev , struct drm_file * file_priv ) ;

void radeon_mem_release ( struct drm_file * file_priv , struct mem_block * heap ) ;

void radeon_mem_takedown ( struct mem_block * * heap ) ;

int radeon_mem_alloc ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_mem_free ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_mem_init_heap ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void radeon_irq_set_state ( struct drm_device * dev , u32 mask , int state ) ;

int radeon_enable_vblank ( struct drm_device * dev , int crtc ) ;

void radeon_disable_vblank ( struct drm_device * dev , int crtc ) ;

irqreturn_t radeon_driver_irq_handler ( int irq , void * arg ) ;

u32 radeon_get_vblank_counter ( struct drm_device * dev , int crtc ) ;

int radeon_irq_emit ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_irq_wait ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void radeon_driver_irq_preinstall ( struct drm_device * dev ) ;

int radeon_driver_irq_postinstall ( struct drm_device * dev ) ;

void radeon_driver_irq_uninstall ( struct drm_device * dev ) ;

int radeon_vblank_crtc_get ( struct drm_device * dev ) ;

int radeon_vblank_crtc_set ( struct drm_device * dev , int64_t value ) ;

void r300_init_reg_flags ( struct drm_device * dev ) ;

int r300_do_cp_cmdbuf ( struct drm_device * dev , struct drm_file * file_priv , drm_radeon_kcmd_buffer_t * cmdbuf ) ;

void r600_page_table_cleanup ( struct drm_device * dev , struct drm_ati_pcigart_info * gart_info ) ;

int r600_page_table_init ( struct drm_device * dev ) ;

int r600_do_engine_reset ( struct drm_device * dev ) ;

int r600_do_cleanup_cp ( struct drm_device * dev ) ;

int r600_do_init_cp ( struct drm_device * dev , drm_radeon_init_t * init , struct drm_file * file_priv ) ;

int r600_do_resume_cp ( struct drm_device * dev , struct drm_file * file_priv ) ;

int r600_do_cp_idle ( drm_radeon_private_t * dev_priv ) ;

void r600_do_cp_start ( drm_radeon_private_t * dev_priv ) ;

void r600_do_cp_reset ( drm_radeon_private_t * dev_priv ) ;

void r600_do_cp_stop ( drm_radeon_private_t * dev_priv ) ;

int r600_cp_dispatch_indirect ( struct drm_device * dev , struct drm_buf * buf , int start , int end ) ;

void r600_cp_dispatch_swap ( struct drm_device * dev , struct drm_file * file_priv ) ;

int r600_cp_dispatch_texture ( struct drm_device * dev , struct drm_file * file_priv , drm_radeon_texture_t * tex , drm_radeon_tex_image_t * image ) ;

int r600_cs_legacy_ioctl ( struct drm_device * dev , void * data , struct drm_file * fpriv ) ;


typedef union rfixed { u32 full ; } fixed20_12 ;

struct radeon_device ;

enum radeon_rmx_type { RMX_OFF , RMX_FULL , RMX_CENTER , RMX_ASPECT } ;

enum radeon_tv_std { TV_STD_NTSC , TV_STD_PAL , TV_STD_PAL_M , TV_STD_PAL_60 , TV_STD_NTSC_J , TV_STD_SCART_PAL , TV_STD_SECAM , TV_STD_PAL_CN , TV_STD_PAL_N , } ;

struct radeon_i2c_bus_rec { bool valid ; uint8_t i2c_id ; bool hw_capable ; bool mm_i2c ; uint32_t mask_clk_reg ; uint32_t mask_data_reg ; uint32_t a_clk_reg ; uint32_t a_data_reg ; uint32_t en_clk_reg ; uint32_t en_data_reg ; uint32_t y_clk_reg ; uint32_t y_data_reg ; uint32_t mask_clk_mask ; uint32_t mask_data_mask ; uint32_t a_clk_mask ; uint32_t a_data_mask ; uint32_t en_clk_mask ; uint32_t en_data_mask ; uint32_t y_clk_mask ; uint32_t y_data_mask ; } ;

struct radeon_tmds_pll { uint32_t freq ; uint32_t value ; } ;

enum radeon_pll_algo { PLL_ALGO_LEGACY , PLL_ALGO_NEW } ;

struct radeon_pll { uint32_t reference_freq ; uint32_t reference_div ; uint32_t post_div ; uint32_t pll_in_min ; uint32_t pll_in_max ; uint32_t pll_out_min ; uint32_t pll_out_max ; uint32_t best_vco ; uint32_t min_ref_div ; uint32_t max_ref_div ; uint32_t min_post_div ; uint32_t max_post_div ; uint32_t min_feedback_div ; uint32_t max_feedback_div ; uint32_t min_frac_feedback_div ; uint32_t max_frac_feedback_div ; uint32_t flags ; uint32_t id ; enum radeon_pll_algo algo ; } ;

struct radeon_i2c_chan { struct i2c_adapter adapter ; struct drm_device * dev ; union { struct i2c_algo_dp_aux_data dp ; struct i2c_algo_bit_data bit ; } algo ; struct radeon_i2c_bus_rec rec ; } ;

enum radeon_connector_table { CT_NONE , CT_GENERIC , CT_IBOOK , CT_POWERBOOK_EXTERNAL , CT_POWERBOOK_INTERNAL , CT_POWERBOOK_VGA , CT_MINI_EXTERNAL , CT_MINI_INTERNAL , CT_IMAC_G5_ISIGHT , CT_EMAC , } ;

enum radeon_dvo_chip { DVO_SIL164 , DVO_SIL1178 , } ;

struct radeon_mode_info { struct atom_context * atom_context ; struct card_info * atom_card_info ; enum radeon_connector_table connector_table ; bool mode_config_initialized ; struct radeon_crtc * crtcs [ 2 ] ; struct drm_property * coherent_mode_property ; struct drm_property * load_detect_property ; struct drm_property * tv_std_property ; struct drm_property * tmds_pll_property ; } ;

struct radeon_tv_regs { uint32_t tv_uv_adr ; uint32_t timing_cntl ; uint32_t hrestart ; uint32_t vrestart ; uint32_t frestart ; uint16_t h_code_timing [ 32 ] ; uint16_t v_code_timing [ 32 ] ; } ;

struct radeon_crtc { struct drm_crtc base ; int crtc_id ; u16 lut_r [ 256 ] , lut_g [ 256 ] , lut_b [ 256 ] ; bool enabled ; bool can_tile ; uint32_t crtc_offset ; struct drm_gem_object * cursor_bo ; uint64_t cursor_addr ; int cursor_width ; int cursor_height ; uint32_t legacy_display_base_addr ; uint32_t legacy_cursor_offset ; enum radeon_rmx_type rmx_type ; fixed20_12 vsc ; fixed20_12 hsc ; struct drm_display_mode native_mode ; } ;

struct radeon_encoder_primary_dac { uint32_t ps2_pdac_adj ; } ;

struct radeon_encoder_lvds { uint16_t panel_vcc_delay ; uint8_t panel_pwr_delay ; uint8_t panel_digon_delay ; uint8_t panel_blon_delay ; uint16_t panel_ref_divider ; uint8_t panel_post_divider ; uint16_t panel_fb_divider ; bool use_bios_dividers ; uint32_t lvds_gen_cntl ; struct drm_display_mode native_mode ; } ;

struct radeon_encoder_tv_dac { uint32_t ps2_tvdac_adj ; uint32_t ntsc_tvdac_adj ; uint32_t pal_tvdac_adj ; int h_pos ; int v_pos ; int h_size ; int supported_tv_stds ; bool tv_on ; enum radeon_tv_std tv_std ; struct radeon_tv_regs tv ; } ;

struct radeon_encoder_int_tmds { struct radeon_tmds_pll tmds_pll [ 4 ] ; } ;

struct radeon_encoder_ext_tmds { struct radeon_i2c_chan * i2c_bus ; uint8_t slave_addr ; enum radeon_dvo_chip dvo_chip ; } ;

struct radeon_atom_ss { uint16_t percentage ; uint8_t type ; uint8_t step ; uint8_t delay ; uint8_t range ; uint8_t refdiv ; } ;

struct radeon_encoder_atom_dig { bool coherent_mode ; int dig_encoder ; uint32_t lvds_misc ; uint16_t panel_pwr_delay ; enum radeon_pll_algo pll_algo ; struct radeon_atom_ss * ss ; struct drm_display_mode native_mode ; } ;

struct radeon_encoder_atom_dac { enum radeon_tv_std tv_std ; } ;

struct radeon_encoder { struct drm_encoder base ; uint32_t encoder_id ; uint32_t devices ; uint32_t active_device ; uint32_t flags ; uint32_t pixel_clock ; enum radeon_rmx_type rmx_type ; struct drm_display_mode native_mode ; void * enc_priv ; int hdmi_offset ; int hdmi_audio_workaround ; int hdmi_buffer_status ; } ;

struct radeon_connector_atom_dig { uint32_t igp_lane_info ; bool linkb ; struct radeon_i2c_chan * dp_i2c_bus ; u8 dpcd [ 8 ] ; u8 dp_sink_type ; int dp_clock ; int dp_lane_count ; } ;

struct radeon_gpio_rec { bool valid ; u8 id ; u32 reg ; u32 mask ; } ;

enum radeon_hpd_id { RADEON_HPD_NONE = 0 , RADEON_HPD_1 , RADEON_HPD_2 , RADEON_HPD_3 , RADEON_HPD_4 , RADEON_HPD_5 , RADEON_HPD_6 , } ;

struct radeon_hpd { enum radeon_hpd_id hpd ; u8 plugged_state ; struct radeon_gpio_rec gpio ; } ;

struct radeon_connector { struct drm_connector base ; uint32_t connector_id ; uint32_t devices ; struct radeon_i2c_chan * ddc_bus ; bool shared_ddc ; bool use_digital ; struct edid * edid ; void * con_priv ; bool dac_load_detect ; uint16_t connector_object_id ; struct radeon_hpd hpd ; } ;

struct radeon_framebuffer { struct drm_framebuffer base ; struct drm_gem_object * obj ; } ;

enum radeon_pll_errata { CHIP_ERRATA_R300_CG = 0x00000001 , CHIP_ERRATA_PLL_DUMMYREADS = 0x00000002 , CHIP_ERRATA_PLL_DELAY = 0x00000004 } ;

struct radeon_dummy_page { struct page * page ; dma_addr_t addr ; } ;

struct radeon_clock { struct radeon_pll p1pll ; struct radeon_pll p2pll ; struct radeon_pll spll ; struct radeon_pll mpll ; uint32_t default_mclk ; uint32_t default_sclk ; } ;

struct radeon_fence_driver { uint32_t scratch_reg ; atomic_t seq ; uint32_t last_seq ; unsigned long count_timeout ; wait_queue_head_t queue ; rwlock_t lock ; struct list_head created ; struct list_head emited ; struct list_head signaled ; bool initialized ; } ;

struct radeon_fence { struct radeon_device * rdev ; struct kref kref ; struct list_head list ; uint32_t seq ; unsigned long timeout ; bool emited ; bool signaled ; } ;

struct radeon_surface_reg { struct radeon_bo * bo ; } ;

struct radeon_mman { struct ttm_bo_global_ref bo_global_ref ; struct ttm_global_reference mem_global_ref ; struct ttm_bo_device bdev ; bool mem_global_referenced ; bool initialized ; } ;

struct radeon_bo { struct list_head list ; u32 placements [ 3 ] ; u32 busy_placements [ 3 ] ; struct ttm_placement placement ; struct ttm_placement busy_placement ; struct ttm_buffer_object tbo ; struct ttm_bo_kmap_obj kmap ; unsigned pin_count ; void * kptr ; u32 tiling_flags ; u32 pitch ; int surface_reg ; struct radeon_device * rdev ; struct drm_gem_object * gobj ; } ;

struct radeon_bo_list { struct list_head list ; struct radeon_bo * bo ; uint64_t gpu_offset ; unsigned rdomain ; unsigned wdomain ; u32 tiling_flags ; } ;

struct radeon_gem { struct mutex mutex ; struct list_head objects ; } ;

struct radeon_mc ;

struct radeon_gart_table_ram { volatile uint32_t * ptr ; } ;

struct radeon_gart_table_vram { struct radeon_bo * robj ; volatile uint32_t * ptr ; } ;

union radeon_gart_table { struct radeon_gart_table_ram ram ; struct radeon_gart_table_vram vram ; } ;

struct radeon_gart { dma_addr_t table_addr ; unsigned num_gpu_pages ; unsigned num_cpu_pages ; unsigned table_size ; union radeon_gart_table table ; struct page * * pages ; dma_addr_t * pages_addr ; bool ready ; } ;

struct radeon_mc { resource_size_t aper_size ; resource_size_t aper_base ; resource_size_t agp_base ; u64 mc_vram_size ; u64 gtt_location ; u64 gtt_size ; u64 gtt_start ; u64 gtt_end ; u64 vram_location ; u64 vram_start ; u64 vram_end ; unsigned vram_width ; u64 real_vram_size ; int vram_mtrr ; bool vram_is_ddr ; bool igp_sideport_enabled ; } ;
struct radeon_scratch { unsigned num_reg ; bool free [ 32 ] ; uint32_t reg [ 32 ] ; } ;

struct radeon_irq { bool installed ; bool sw_int ; bool crtc_vblank_int [ 2 ] ; bool hpd [ 6 ] ; spinlock_t sw_lock ; int sw_refcount ; } ;

struct radeon_ib { struct list_head list ; unsigned idx ; uint64_t gpu_addr ; struct radeon_fence * fence ; uint32_t * ptr ; uint32_t length_dw ; bool free ; } ;

struct radeon_ib_pool { struct mutex mutex ; struct radeon_bo * robj ; struct radeon_ib ibs [ 16 ] ; bool ready ; unsigned head_id ; } ;

struct radeon_cp { struct radeon_bo * ring_obj ; volatile uint32_t * ring ; unsigned rptr ; unsigned wptr ; unsigned wptr_old ; unsigned ring_size ; unsigned ring_free_dw ; int count_dw ; uint64_t gpu_addr ; uint32_t align_mask ; uint32_t ptr_mask ; struct mutex mutex ; bool ready ; } ;

struct r600_ih { struct radeon_bo * ring_obj ; volatile uint32_t * ring ; unsigned rptr ; unsigned wptr ; unsigned wptr_old ; unsigned ring_size ; uint64_t gpu_addr ; uint32_t ptr_mask ; spinlock_t lock ; bool enabled ; } ;

struct r600_blit { struct mutex mutex ; struct radeon_bo * shader_obj ; u64 shader_gpu_addr ; u32 vs_offset , ps_offset ; u32 state_offset ; u32 state_len ; u32 vb_used , vb_total ; struct radeon_ib * vb_ib ; } ;

struct radeon_cs_reloc { struct drm_gem_object * gobj ; struct radeon_bo * robj ; struct radeon_bo_list lobj ; uint32_t handle ; uint32_t flags ; } ;

struct radeon_cs_chunk { uint32_t chunk_id ; uint32_t length_dw ; int kpage_idx [ 2 ] ; uint32_t * kpage [ 2 ] ; uint32_t * kdata ; void * user_ptr ; int last_copied_page ; int last_page_index ; } ;

struct radeon_cs_parser { struct device * dev ; struct radeon_device * rdev ; struct drm_file * filp ; unsigned nchunks ; struct radeon_cs_chunk * chunks ; uint64_t * chunks_array ; unsigned idx ; unsigned nrelocs ; struct radeon_cs_reloc * relocs ; struct radeon_cs_reloc * * relocs_ptr ; struct list_head validated ; int chunk_ib_idx ; int chunk_relocs_idx ; struct radeon_ib * ib ; void * track ; unsigned family ; int parser_error ; } ;

struct radeon_cs_packet { unsigned idx ; unsigned type ; unsigned reg ; unsigned opcode ; int count ; unsigned one_reg_wr ; } ;

typedef int ( * radeon_packet0_check_t ) ( struct radeon_cs_parser * p , struct radeon_cs_packet * pkt , unsigned idx , unsigned reg ) ;
typedef int ( * radeon_packet3_check_t ) ( struct radeon_cs_parser * p , struct radeon_cs_packet * pkt ) ;
struct radeon_wb { struct radeon_bo * wb_obj ; volatile uint32_t * wb ; uint64_t gpu_addr ; } ;

struct radeon_pm { fixed20_12 max_bandwidth ; fixed20_12 igp_sideport_mclk ; fixed20_12 igp_system_mclk ; fixed20_12 igp_ht_link_clk ; fixed20_12 igp_ht_link_width ; fixed20_12 k8_bandwidth ; fixed20_12 sideport_bandwidth ; fixed20_12 ht_bandwidth ; fixed20_12 core_bandwidth ; fixed20_12 sclk ; fixed20_12 needed_bandwidth ; } ;

struct radeon_asic { int ( * init ) ( struct radeon_device * rdev ) ; void ( * fini ) ( struct radeon_device * rdev ) ; int ( * resume ) ( struct radeon_device * rdev ) ; int ( * suspend ) ( struct radeon_device * rdev ) ; void ( * vga_set_state ) ( struct radeon_device * rdev , bool state ) ; int ( * gpu_reset ) ( struct radeon_device * rdev ) ; void ( * gart_tlb_flush ) ( struct radeon_device * rdev ) ; int ( * gart_set_page ) ( struct radeon_device * rdev , int i , uint64_t addr ) ; int ( * cp_init ) ( struct radeon_device * rdev , unsigned ring_size ) ; void ( * cp_fini ) ( struct radeon_device * rdev ) ; void ( * cp_disable ) ( struct radeon_device * rdev ) ; void ( * cp_commit ) ( struct radeon_device * rdev ) ; void ( * ring_start ) ( struct radeon_device * rdev ) ; int ( * ring_test ) ( struct radeon_device * rdev ) ; void ( * ring_ib_execute ) ( struct radeon_device * rdev , struct radeon_ib * ib ) ; int ( * irq_set ) ( struct radeon_device * rdev ) ; int ( * irq_process ) ( struct radeon_device * rdev ) ; u32 ( * get_vblank_counter ) ( struct radeon_device * rdev , int crtc ) ; void ( * fence_ring_emit ) ( struct radeon_device * rdev , struct radeon_fence * fence ) ; int ( * cs_parse ) ( struct radeon_cs_parser * p ) ; int ( * copy_blit ) ( struct radeon_device * rdev , uint64_t src_offset , uint64_t dst_offset , unsigned num_pages , struct radeon_fence * fence ) ; int ( * copy_dma ) ( struct radeon_device * rdev , uint64_t src_offset , uint64_t dst_offset , unsigned num_pages , struct radeon_fence * fence ) ; int ( * copy ) ( struct radeon_device * rdev , uint64_t src_offset , uint64_t dst_offset , unsigned num_pages , struct radeon_fence * fence ) ; uint32_t ( * get_engine_clock ) ( struct radeon_device * rdev ) ; void ( * set_engine_clock ) ( struct radeon_device * rdev , uint32_t eng_clock ) ; uint32_t ( * get_memory_clock ) ( struct radeon_device * rdev ) ; void ( * set_memory_clock ) ( struct radeon_device * rdev , uint32_t mem_clock ) ; void ( * set_pcie_lanes ) ( struct radeon_device * rdev , int lanes ) ; void ( * set_clock_gating ) ( struct radeon_device * rdev , int enable ) ; int ( * set_surface_reg ) ( struct radeon_device * rdev , int reg , uint32_t tiling_flags , uint32_t pitch , uint32_t offset , uint32_t obj_size ) ; int ( * clear_surface_reg ) ( struct radeon_device * rdev , int reg ) ; void ( * bandwidth_update ) ( struct radeon_device * rdev ) ; void ( * hpd_init ) ( struct radeon_device * rdev ) ; void ( * hpd_fini ) ( struct radeon_device * rdev ) ; bool ( * hpd_sense ) ( struct radeon_device * rdev , enum radeon_hpd_id hpd ) ; void ( * hpd_set_polarity ) ( struct radeon_device * rdev , enum radeon_hpd_id hpd ) ; void ( * ioctl_wait_idle ) ( struct radeon_device * rdev , struct radeon_bo * bo ) ; } ;

struct r100_asic { const unsigned * reg_safe_bm ; unsigned reg_safe_bm_size ; u32 hdp_cntl ; } ;

struct r300_asic { const unsigned * reg_safe_bm ; unsigned reg_safe_bm_size ; u32 resync_scratch ; u32 hdp_cntl ; } ;

struct r600_asic { unsigned max_pipes ; unsigned max_tile_pipes ; unsigned max_simds ; unsigned max_backends ; unsigned max_gprs ; unsigned max_threads ; unsigned max_stack_entries ; unsigned max_hw_contexts ; unsigned max_gs_threads ; unsigned sx_max_export_size ; unsigned sx_max_export_pos_size ; unsigned sx_max_export_smx_size ; unsigned sq_num_cf_insts ; } ;

struct rv770_asic { unsigned max_pipes ; unsigned max_tile_pipes ; unsigned max_simds ; unsigned max_backends ; unsigned max_gprs ; unsigned max_threads ; unsigned max_stack_entries ; unsigned max_hw_contexts ; unsigned max_gs_threads ; unsigned sx_max_export_size ; unsigned sx_max_export_pos_size ; unsigned sx_max_export_smx_size ; unsigned sq_num_cf_insts ; unsigned sx_num_of_sets ; unsigned sc_prim_fifo_size ; unsigned sc_hiz_tile_fifo_size ; unsigned sc_earlyz_tile_fifo_fize ; } ;

union radeon_asic_config { struct r300_asic r300 ; struct r100_asic r100 ; struct r600_asic r600 ; struct rv770_asic rv770 ; } ;

typedef uint32_t ( * radeon_rreg_t ) ( struct radeon_device * , uint32_t ) ;

typedef void ( * radeon_wreg_t ) ( struct radeon_device * , uint32_t , uint32_t ) ;
struct radeon_device { struct device * dev ; struct drm_device * ddev ; struct pci_dev * pdev ; union radeon_asic_config config ; enum radeon_family family ; unsigned long flags ; int usec_timeout ; enum radeon_pll_errata pll_errata ; int num_gb_pipes ; int num_z_pipes ; int disp_priority ; uint8_t * bios ; bool is_atom_bios ; uint16_t bios_header_start ; struct radeon_bo * stollen_vga_memory ; struct fb_info * fbdev_info ; struct radeon_bo * fbdev_rbo ; struct radeon_framebuffer * fbdev_rfb ; resource_size_t rmmio_base ; resource_size_t rmmio_size ; void * rmmio ; radeon_rreg_t mc_rreg ; radeon_wreg_t mc_wreg ; radeon_rreg_t pll_rreg ; radeon_wreg_t pll_wreg ; uint32_t pcie_reg_mask ; radeon_rreg_t pciep_rreg ; radeon_wreg_t pciep_wreg ; struct radeon_clock clock ; struct radeon_mc mc ; struct radeon_gart gart ; struct radeon_mode_info mode_info ; struct radeon_scratch scratch ; struct radeon_mman mman ; struct radeon_fence_driver fence_drv ; struct radeon_cp cp ; struct radeon_ib_pool ib_pool ; struct radeon_irq irq ; struct radeon_asic * asic ; struct radeon_gem gem ; struct radeon_pm pm ; uint32_t bios_scratch [ 8 ] ; struct mutex cs_mutex ; struct radeon_wb wb ; struct radeon_dummy_page dummy_page ; bool gpu_lockup ; bool shutdown ; bool suspend ; bool need_dma32 ; bool accel_working ; struct radeon_surface_reg surface_regs [ 8 ] ; const struct firmware * me_fw ; const struct firmware * pfp_fw ; const struct firmware * rlc_fw ; struct r600_blit r600_blit ; int msi_enabled ; struct r600_ih ih ; struct workqueue_struct * wq ; struct work_struct hotplug_work ; struct timer_list audio_timer ; int audio_channels ; int audio_rate ; int audio_bits_per_sample ; uint8_t audio_status_bits ; uint8_t audio_category_code ; } ;
struct r100_mc_save { u32 GENMO_WT ; u32 CRTC_EXT_CNTL ; u32 CRTC_GEN_CNTL ; u32 CRTC2_GEN_CNTL ; u32 CUR_OFFSET ; u32 CUR2_OFFSET ; } ;

struct rv515_mc_save { u32 d1vga_control ; u32 d2vga_control ; u32 vga_render_control ; u32 vga_hdp_control ; u32 d1crtc_control ; u32 d2crtc_control ; } ;

struct card_info { struct drm_device * dev ; void ( * reg_write ) ( struct card_info * , uint32_t , uint32_t ) ; uint32_t ( * reg_read ) ( struct card_info * , uint32_t ) ; void ( * mc_write ) ( struct card_info * , uint32_t , uint32_t ) ; uint32_t ( * mc_read ) ( struct card_info * , uint32_t ) ; void ( * pll_write ) ( struct card_info * , uint32_t , uint32_t ) ; uint32_t ( * pll_read ) ( struct card_info * , uint32_t ) ; } ;
struct atom_context { struct card_info * card ; struct mutex mutex ; void * bios ; uint32_t cmd_table , data_table ; uint16_t * iio ; uint16_t data_block ; uint32_t fb_base ; uint32_t divmul [ 2 ] ; uint16_t io_attr ; uint16_t reg_block ; uint8_t shift ; int cs_equal , cs_above ; int io_mode ; uint32_t * scratch ; } ;

typedef uint16_t USHORT ;

typedef uint32_t ULONG ;

typedef uint8_t UCHAR ;


typedef struct _ATOM_COMMON_TABLE_HEADER { USHORT usStructureSize ; UCHAR ucTableFormatRevision ; UCHAR ucTableContentRevision ; } ATOM_COMMON_TABLE_HEADER ;


typedef struct _ATOM_ROM_HEADER { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR uaFirmWareSignature [ 4 ] ; USHORT usBiosRuntimeSegmentAddress ; USHORT usProtectedModeInfoOffset ; USHORT usConfigFilenameOffset ; USHORT usCRC_BlockOffset ; USHORT usBIOS_BootupMessageOffset ; USHORT usInt10Offset ; USHORT usPciBusDevInitCode ; USHORT usIoBaseAddress ; USHORT usSubsystemVendorID ; USHORT usSubsystemID ; USHORT usPCI_InfoOffset ; USHORT usMasterCommandTableOffset ; USHORT usMasterDataTableOffset ; UCHAR ucExtendedFunctionCode ; UCHAR ucReserved ; } ATOM_ROM_HEADER ;


typedef struct _ATOM_MASTER_LIST_OF_COMMAND_TABLES { USHORT ASIC_Init ; USHORT GetDisplaySurfaceSize ; USHORT ASIC_RegistersInit ; USHORT VRAM_BlockVenderDetection ; USHORT DIGxEncoderControl ; USHORT MemoryControllerInit ; USHORT EnableCRTCMemReq ; USHORT MemoryParamAdjust ; USHORT DVOEncoderControl ; USHORT GPIOPinControl ; USHORT SetEngineClock ; USHORT SetMemoryClock ; USHORT SetPixelClock ; USHORT DynamicClockGating ; USHORT ResetMemoryDLL ; USHORT ResetMemoryDevice ; USHORT MemoryPLLInit ; USHORT AdjustDisplayPll ; USHORT AdjustMemoryController ; USHORT EnableASIC_StaticPwrMgt ; USHORT ASIC_StaticPwrMgtStatusChange ; USHORT DAC_LoadDetection ; USHORT LVTMAEncoderControl ; USHORT LCD1OutputControl ; USHORT DAC1EncoderControl ; USHORT DAC2EncoderControl ; USHORT DVOOutputControl ; USHORT CV1OutputControl ; USHORT GetConditionalGoldenSetting ; USHORT TVEncoderControl ; USHORT TMDSAEncoderControl ; USHORT LVDSEncoderControl ; USHORT TV1OutputControl ; USHORT EnableScaler ; USHORT BlankCRTC ; USHORT EnableCRTC ; USHORT GetPixelClock ; USHORT EnableVGA_Render ; USHORT EnableVGA_Access ; USHORT SetCRTC_Timing ; USHORT SetCRTC_OverScan ; USHORT SetCRTC_Replication ; USHORT SelectCRTC_Source ; USHORT EnableGraphSurfaces ; USHORT UpdateCRTC_DoubleBufferRegisters ; USHORT LUT_AutoFill ; USHORT EnableHW_IconCursor ; USHORT GetMemoryClock ; USHORT GetEngineClock ; USHORT SetCRTC_UsingDTDTiming ; USHORT ExternalEncoderControl ; USHORT LVTMAOutputControl ; USHORT VRAM_BlockDetectionByStrap ; USHORT MemoryCleanUp ; USHORT ProcessI2cChannelTransaction ; USHORT WriteOneByteToHWAssistedI2C ; USHORT ReadHWAssistedI2CStatus ; USHORT SpeedFanControl ; USHORT PowerConnectorDetection ; USHORT MC_Synchronization ; USHORT ComputeMemoryEnginePLL ; USHORT MemoryRefreshConversion ; USHORT VRAM_GetCurrentInfoBlock ; USHORT DynamicMemorySettings ; USHORT MemoryTraining ; USHORT EnableSpreadSpectrumOnPPLL ; USHORT TMDSAOutputControl ; USHORT SetVoltage ; USHORT DAC1OutputControl ; USHORT DAC2OutputControl ; USHORT SetupHWAssistedI2CStatus ; USHORT ClockSource ; USHORT MemoryDeviceInit ; USHORT EnableYUV ; USHORT DIG1EncoderControl ; USHORT DIG2EncoderControl ; USHORT DIG1TransmitterControl ; USHORT DIG2TransmitterControl ; USHORT ProcessAuxChannelTransaction ; USHORT DPEncoderService ; } ATOM_MASTER_LIST_OF_COMMAND_TABLES ;


typedef struct _ATOM_MASTER_COMMAND_TABLE { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_MASTER_LIST_OF_COMMAND_TABLES ListOfCommandTables ; } ATOM_MASTER_COMMAND_TABLE ;


typedef struct _ATOM_TABLE_ATTRIBUTE { USHORT WS_SizeInBytes : 8 ; USHORT PS_SizeInBytes : 7 ; USHORT UpdatedByUtility : 1 ; } ATOM_TABLE_ATTRIBUTE ;


typedef union _ATOM_TABLE_ATTRIBUTE_ACCESS { ATOM_TABLE_ATTRIBUTE sbfAccess ; USHORT susAccess ; } ATOM_TABLE_ATTRIBUTE_ACCESS ;


typedef struct _ATOM_COMMON_ROM_COMMAND_TABLE_HEADER { ATOM_COMMON_TABLE_HEADER CommonHeader ; ATOM_TABLE_ATTRIBUTE TableAttribute ; } ATOM_COMMON_ROM_COMMAND_TABLE_HEADER ;


typedef struct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS { ULONG ulClock ; UCHAR ucAction ; UCHAR ucReserved ; UCHAR ucFbDiv ; UCHAR ucPostDiv ; } COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS ;


typedef struct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V2 { ULONG ulClock ; UCHAR ucAction ; USHORT usFbDiv ; UCHAR ucPostDiv ; } COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V2 ;


typedef struct _ATOM_COMPUTE_CLOCK_FREQ { ULONG ulClockFreq : 24 ; ULONG ulComputeClockFlag : 8 ; } ATOM_COMPUTE_CLOCK_FREQ ;


typedef struct _ATOM_S_MPLL_FB_DIVIDER { USHORT usFbDivFrac ; USHORT usFbDiv ; } ATOM_S_MPLL_FB_DIVIDER ;


typedef struct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V3 { union { ATOM_COMPUTE_CLOCK_FREQ ulClock ; ATOM_S_MPLL_FB_DIVIDER ulFbDiv ; } ; UCHAR ucRefDiv ; UCHAR ucPostDiv ; UCHAR ucCntlFlag ; UCHAR ucReserved ; } COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V3 ;


typedef struct _DYNAMICE_MEMORY_SETTINGS_PARAMETER { ATOM_COMPUTE_CLOCK_FREQ ulClock ; ULONG ulReserved [ 2 ] ; } DYNAMICE_MEMORY_SETTINGS_PARAMETER ;


typedef struct _DYNAMICE_ENGINE_SETTINGS_PARAMETER { ATOM_COMPUTE_CLOCK_FREQ ulClock ; ULONG ulMemoryClock ; ULONG ulReserved ; } DYNAMICE_ENGINE_SETTINGS_PARAMETER ;


typedef struct _SET_ENGINE_CLOCK_PARAMETERS { ULONG ulTargetEngineClock ; } SET_ENGINE_CLOCK_PARAMETERS ;


typedef struct _SET_ENGINE_CLOCK_PS_ALLOCATION { ULONG ulTargetEngineClock ; COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS sReserved ; } SET_ENGINE_CLOCK_PS_ALLOCATION ;


typedef struct _SET_MEMORY_CLOCK_PARAMETERS { ULONG ulTargetMemoryClock ; } SET_MEMORY_CLOCK_PARAMETERS ;


typedef struct _SET_MEMORY_CLOCK_PS_ALLOCATION { ULONG ulTargetMemoryClock ; COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS sReserved ; } SET_MEMORY_CLOCK_PS_ALLOCATION ;


typedef struct _ASIC_INIT_PARAMETERS { ULONG ulDefaultEngineClock ; ULONG ulDefaultMemoryClock ; } ASIC_INIT_PARAMETERS ;


typedef struct _ASIC_INIT_PS_ALLOCATION { ASIC_INIT_PARAMETERS sASICInitClocks ; SET_ENGINE_CLOCK_PS_ALLOCATION sReserved ; } ASIC_INIT_PS_ALLOCATION ;


typedef struct _DYNAMIC_CLOCK_GATING_PARAMETERS { UCHAR ucEnable ; UCHAR ucPadding [ 3 ] ; } DYNAMIC_CLOCK_GATING_PARAMETERS ;


typedef struct _ENABLE_ASIC_STATIC_PWR_MGT_PARAMETERS { UCHAR ucEnable ; UCHAR ucPadding [ 3 ] ; } ENABLE_ASIC_STATIC_PWR_MGT_PARAMETERS ;


typedef struct _DAC_LOAD_DETECTION_PARAMETERS { USHORT usDeviceID ; UCHAR ucDacType ; UCHAR ucMisc ; } DAC_LOAD_DETECTION_PARAMETERS ;


typedef struct _DAC_LOAD_DETECTION_PS_ALLOCATION { DAC_LOAD_DETECTION_PARAMETERS sDacload ; ULONG Reserved [ 2 ] ; } DAC_LOAD_DETECTION_PS_ALLOCATION ;


typedef struct _DAC_ENCODER_CONTROL_PARAMETERS { USHORT usPixelClock ; UCHAR ucDacStandard ; UCHAR ucAction ; } DAC_ENCODER_CONTROL_PARAMETERS ;


typedef struct _DIG_ENCODER_CONTROL_PARAMETERS { USHORT usPixelClock ; UCHAR ucConfig ; UCHAR ucAction ; UCHAR ucEncoderMode ; UCHAR ucLaneNum ; UCHAR ucReserved [ 2 ] ; } DIG_ENCODER_CONTROL_PARAMETERS ;


typedef struct _ATOM_DIG_ENCODER_CONFIG_V2 { UCHAR ucDPLinkRate : 1 ; UCHAR ucReserved : 1 ; UCHAR ucLinkSel : 1 ; UCHAR ucTransmitterSel : 2 ; UCHAR ucReserved1 : 2 ; } ATOM_DIG_ENCODER_CONFIG_V2 ;


typedef struct _DIG_ENCODER_CONTROL_PARAMETERS_V2 { USHORT usPixelClock ; ATOM_DIG_ENCODER_CONFIG_V2 acConfig ; UCHAR ucAction ; UCHAR ucEncoderMode ; UCHAR ucLaneNum ; UCHAR ucReserved [ 2 ] ; } DIG_ENCODER_CONTROL_PARAMETERS_V2 ;


typedef struct _ATOM_DP_VS_MODE { UCHAR ucLaneSel ; UCHAR ucLaneSet ; } ATOM_DP_VS_MODE ;


typedef struct _DIG_TRANSMITTER_CONTROL_PARAMETERS { union { USHORT usPixelClock ; USHORT usInitInfo ; ATOM_DP_VS_MODE asMode ; } ; UCHAR ucConfig ; UCHAR ucAction ; UCHAR ucReserved [ 4 ] ; } DIG_TRANSMITTER_CONTROL_PARAMETERS ;


typedef struct _ATOM_DIG_TRANSMITTER_CONFIG_V2 { UCHAR fDualLinkConnector : 1 ; UCHAR fCoherentMode : 1 ; UCHAR ucLinkSel : 1 ; UCHAR ucEncoderSel : 1 ; UCHAR fDPConnector : 1 ; UCHAR ucReserved : 1 ; UCHAR ucTransmitterSel : 2 ; } ATOM_DIG_TRANSMITTER_CONFIG_V2 ;


typedef struct _DIG_TRANSMITTER_CONTROL_PARAMETERS_V2 { union { USHORT usPixelClock ; USHORT usInitInfo ; ATOM_DP_VS_MODE asMode ; } ; ATOM_DIG_TRANSMITTER_CONFIG_V2 acConfig ; UCHAR ucAction ; UCHAR ucReserved [ 4 ] ; } DIG_TRANSMITTER_CONTROL_PARAMETERS_V2 ;


typedef struct _DISPLAY_DEVICE_OUTPUT_CONTROL_PARAMETERS { UCHAR ucAction ; UCHAR aucPadding [ 3 ] ; } DISPLAY_DEVICE_OUTPUT_CONTROL_PARAMETERS ;


typedef struct _BLANK_CRTC_PARAMETERS { UCHAR ucCRTC ; UCHAR ucBlanking ; USHORT usBlackColorRCr ; USHORT usBlackColorGY ; USHORT usBlackColorBCb ; } BLANK_CRTC_PARAMETERS ;


typedef struct _ENABLE_CRTC_PARAMETERS { UCHAR ucCRTC ; UCHAR ucEnable ; UCHAR ucPadding [ 2 ] ; } ENABLE_CRTC_PARAMETERS ;


typedef struct _SET_CRTC_OVERSCAN_PARAMETERS { USHORT usOverscanRight ; USHORT usOverscanLeft ; USHORT usOverscanBottom ; USHORT usOverscanTop ; UCHAR ucCRTC ; UCHAR ucPadding [ 3 ] ; } SET_CRTC_OVERSCAN_PARAMETERS ;


typedef struct _SET_CRTC_REPLICATION_PARAMETERS { UCHAR ucH_Replication ; UCHAR ucV_Replication ; UCHAR usCRTC ; UCHAR ucPadding ; } SET_CRTC_REPLICATION_PARAMETERS ;


typedef struct _SELECT_CRTC_SOURCE_PARAMETERS { UCHAR ucCRTC ; UCHAR ucDevice ; UCHAR ucPadding [ 2 ] ; } SELECT_CRTC_SOURCE_PARAMETERS ;


typedef struct _SELECT_CRTC_SOURCE_PARAMETERS_V2 { UCHAR ucCRTC ; UCHAR ucEncoderID ; UCHAR ucEncodeMode ; UCHAR ucPadding ; } SELECT_CRTC_SOURCE_PARAMETERS_V2 ;


typedef struct _PIXEL_CLOCK_PARAMETERS { USHORT usPixelClock ; USHORT usRefDiv ; USHORT usFbDiv ; UCHAR ucPostDiv ; UCHAR ucFracFbDiv ; UCHAR ucPpll ; UCHAR ucRefDivSrc ; UCHAR ucCRTC ; UCHAR ucPadding ; } PIXEL_CLOCK_PARAMETERS ;


typedef struct _PIXEL_CLOCK_PARAMETERS_V2 { USHORT usPixelClock ; USHORT usRefDiv ; USHORT usFbDiv ; UCHAR ucPostDiv ; UCHAR ucFracFbDiv ; UCHAR ucPpll ; UCHAR ucRefDivSrc ; UCHAR ucCRTC ; UCHAR ucMiscInfo ; } PIXEL_CLOCK_PARAMETERS_V2 ;


typedef struct _PIXEL_CLOCK_PARAMETERS_V3 { USHORT usPixelClock ; USHORT usRefDiv ; USHORT usFbDiv ; UCHAR ucPostDiv ; UCHAR ucFracFbDiv ; UCHAR ucPpll ; UCHAR ucTransmitterId ; union { UCHAR ucEncoderMode ; UCHAR ucDVOConfig ; } ; UCHAR ucMiscInfo ; } PIXEL_CLOCK_PARAMETERS_V3 ;


typedef struct _ADJUST_DISPLAY_PLL_PARAMETERS { USHORT usPixelClock ; UCHAR ucTransmitterID ; UCHAR ucEncodeMode ; union { UCHAR ucDVOConfig ; UCHAR ucConfig ; } ; UCHAR ucReserved [ 3 ] ; } ADJUST_DISPLAY_PLL_PARAMETERS ;


typedef struct _ENABLE_YUV_PARAMETERS { UCHAR ucEnable ; UCHAR ucCRTC ; UCHAR ucPadding [ 2 ] ; } ENABLE_YUV_PARAMETERS ;


typedef struct _GET_MEMORY_CLOCK_PARAMETERS { ULONG ulReturnMemoryClock ; } GET_MEMORY_CLOCK_PARAMETERS ;


typedef struct _GET_ENGINE_CLOCK_PARAMETERS { ULONG ulReturnEngineClock ; } GET_ENGINE_CLOCK_PARAMETERS ;


typedef struct _READ_EDID_FROM_HW_I2C_DATA_PARAMETERS { USHORT usPrescale ; USHORT usVRAMAddress ; USHORT usStatus ; UCHAR ucSlaveAddr ; UCHAR ucLineNumber ; } READ_EDID_FROM_HW_I2C_DATA_PARAMETERS ;


typedef struct _WRITE_ONE_BYTE_HW_I2C_DATA_PARAMETERS { USHORT usPrescale ; USHORT usByteOffset ; UCHAR ucData ; UCHAR ucStatus ; UCHAR ucSlaveAddr ; UCHAR ucLineNumber ; } WRITE_ONE_BYTE_HW_I2C_DATA_PARAMETERS ;


typedef struct _SET_UP_HW_I2C_DATA_PARAMETERS { USHORT usPrescale ; UCHAR ucSlaveAddr ; UCHAR ucLineNumber ; } SET_UP_HW_I2C_DATA_PARAMETERS ;


typedef struct _POWER_CONNECTOR_DETECTION_PARAMETERS { UCHAR ucPowerConnectorStatus ; UCHAR ucPwrBehaviorId ; USHORT usPwrBudget ; } POWER_CONNECTOR_DETECTION_PARAMETERS ;


typedef struct POWER_CONNECTOR_DETECTION_PS_ALLOCATION { UCHAR ucPowerConnectorStatus ; UCHAR ucReserved ; USHORT usPwrBudget ; WRITE_ONE_BYTE_HW_I2C_DATA_PARAMETERS sReserved ; } POWER_CONNECTOR_DETECTION_PS_ALLOCATION ;


typedef struct _ENABLE_LVDS_SS_PARAMETERS { USHORT usSpreadSpectrumPercentage ; UCHAR ucSpreadSpectrumType ; UCHAR ucSpreadSpectrumStepSize_Delay ; UCHAR ucEnable ; UCHAR ucPadding [ 3 ] ; } ENABLE_LVDS_SS_PARAMETERS ;


typedef struct _ENABLE_LVDS_SS_PARAMETERS_V2 { USHORT usSpreadSpectrumPercentage ; UCHAR ucSpreadSpectrumType ; UCHAR ucSpreadSpectrumStep ; UCHAR ucEnable ; UCHAR ucSpreadSpectrumDelay ; UCHAR ucSpreadSpectrumRange ; UCHAR ucPadding ; } ENABLE_LVDS_SS_PARAMETERS_V2 ;


typedef struct _ENABLE_SPREAD_SPECTRUM_ON_PPLL { USHORT usSpreadSpectrumPercentage ; UCHAR ucSpreadSpectrumType ; UCHAR ucSpreadSpectrumStep ; UCHAR ucEnable ; UCHAR ucSpreadSpectrumDelay ; UCHAR ucSpreadSpectrumRange ; UCHAR ucPpll ; } ENABLE_SPREAD_SPECTRUM_ON_PPLL ;


typedef struct _SET_PIXEL_CLOCK_PS_ALLOCATION { PIXEL_CLOCK_PARAMETERS sPCLKInput ; ENABLE_SPREAD_SPECTRUM_ON_PPLL sReserved ; } SET_PIXEL_CLOCK_PS_ALLOCATION ;


typedef struct _MEMORY_TRAINING_PARAMETERS { ULONG ulTargetMemoryClock ; } MEMORY_TRAINING_PARAMETERS ;


typedef struct _LVDS_ENCODER_CONTROL_PARAMETERS { USHORT usPixelClock ; UCHAR ucMisc ; UCHAR ucAction ; } LVDS_ENCODER_CONTROL_PARAMETERS ;


typedef struct _LVDS_ENCODER_CONTROL_PARAMETERS_V2 { USHORT usPixelClock ; UCHAR ucMisc ; UCHAR ucAction ; UCHAR ucTruncate ; UCHAR ucSpatial ; UCHAR ucTemporal ; UCHAR ucFRC ; } LVDS_ENCODER_CONTROL_PARAMETERS_V2 ;


typedef struct _ENABLE_EXTERNAL_TMDS_ENCODER_PARAMETERS { UCHAR ucEnable ; UCHAR ucMisc ; UCHAR ucPadding [ 2 ] ; } ENABLE_EXTERNAL_TMDS_ENCODER_PARAMETERS ;


typedef struct _ENABLE_EXTERNAL_TMDS_ENCODER_PS_ALLOCATION { ENABLE_EXTERNAL_TMDS_ENCODER_PARAMETERS sXTmdsEncoder ; WRITE_ONE_BYTE_HW_I2C_DATA_PARAMETERS sReserved ; } ENABLE_EXTERNAL_TMDS_ENCODER_PS_ALLOCATION ;


typedef struct _ENABLE_EXTERNAL_TMDS_ENCODER_PS_ALLOCATION_V2 { LVDS_ENCODER_CONTROL_PARAMETERS_V2 sXTmdsEncoder ; WRITE_ONE_BYTE_HW_I2C_DATA_PARAMETERS sReserved ; } ENABLE_EXTERNAL_TMDS_ENCODER_PS_ALLOCATION_V2 ;


typedef struct _EXTERNAL_ENCODER_CONTROL_PS_ALLOCATION { DIG_ENCODER_CONTROL_PARAMETERS sDigEncoder ; WRITE_ONE_BYTE_HW_I2C_DATA_PARAMETERS sReserved ; } EXTERNAL_ENCODER_CONTROL_PS_ALLOCATION ;


typedef struct _DVO_ENCODER_CONTROL_PARAMETERS_V3 { USHORT usPixelClock ; UCHAR ucDVOConfig ; UCHAR ucAction ; UCHAR ucReseved [ 4 ] ; } DVO_ENCODER_CONTROL_PARAMETERS_V3 ;


typedef struct _SET_VOLTAGE_PARAMETERS { UCHAR ucVoltageType ; UCHAR ucVoltageMode ; UCHAR ucVoltageIndex ; UCHAR ucReserved ; } SET_VOLTAGE_PARAMETERS ;


typedef struct _SET_VOLTAGE_PARAMETERS_V2 { UCHAR ucVoltageType ; UCHAR ucVoltageMode ; USHORT usVoltageLevel ; } SET_VOLTAGE_PARAMETERS_V2 ;


typedef struct _SET_VOLTAGE_PS_ALLOCATION { SET_VOLTAGE_PARAMETERS sASICSetVoltage ; WRITE_ONE_BYTE_HW_I2C_DATA_PARAMETERS sReserved ; } SET_VOLTAGE_PS_ALLOCATION ;


typedef struct _TV_ENCODER_CONTROL_PARAMETERS { USHORT usPixelClock ; UCHAR ucTvStandard ; UCHAR ucAction ; } TV_ENCODER_CONTROL_PARAMETERS ;


typedef struct _TV_ENCODER_CONTROL_PS_ALLOCATION { TV_ENCODER_CONTROL_PARAMETERS sTVEncoder ; WRITE_ONE_BYTE_HW_I2C_DATA_PARAMETERS sReserved ; } TV_ENCODER_CONTROL_PS_ALLOCATION ;


typedef struct _ATOM_MASTER_LIST_OF_DATA_TABLES { USHORT UtilityPipeLine ; USHORT MultimediaCapabilityInfo ; USHORT MultimediaConfigInfo ; USHORT StandardVESA_Timing ; USHORT FirmwareInfo ; USHORT DAC_Info ; USHORT LVDS_Info ; USHORT TMDS_Info ; USHORT AnalogTV_Info ; USHORT SupportedDevicesInfo ; USHORT GPIO_I2C_Info ; USHORT VRAM_UsageByFirmware ; USHORT GPIO_Pin_LUT ; USHORT VESA_ToInternalModeLUT ; USHORT ComponentVideoInfo ; USHORT PowerPlayInfo ; USHORT CompassionateData ; USHORT SaveRestoreInfo ; USHORT PPLL_SS_Info ; USHORT OemInfo ; USHORT XTMDS_Info ; USHORT MclkSS_Info ; USHORT Object_Header ; USHORT IndirectIOAccess ; USHORT MC_InitParameter ; USHORT ASIC_VDDC_Info ; USHORT ASIC_InternalSS_Info ; USHORT TV_VideoMode ; USHORT VRAM_Info ; USHORT MemoryTrainingInfo ; USHORT IntegratedSystemInfo ; USHORT ASIC_ProfilingInfo ; USHORT VoltageObjectInfo ; USHORT PowerSourceInfo ; } ATOM_MASTER_LIST_OF_DATA_TABLES ;


typedef struct _ATOM_MASTER_DATA_TABLE { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_MASTER_LIST_OF_DATA_TABLES ListOfDataTables ; } ATOM_MASTER_DATA_TABLE ;


typedef struct _ATOM_MULTIMEDIA_CAPABILITY_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ULONG ulSignature ; UCHAR ucI2C_Type ; UCHAR ucTV_OutInfo ; UCHAR ucVideoPortInfo ; UCHAR ucHostPortInfo ; } ATOM_MULTIMEDIA_CAPABILITY_INFO ;


typedef struct _ATOM_MULTIMEDIA_CONFIG_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ULONG ulSignature ; UCHAR ucTunerInfo ; UCHAR ucAudioChipInfo ; UCHAR ucProductID ; UCHAR ucMiscInfo1 ; UCHAR ucMiscInfo2 ; UCHAR ucMiscInfo3 ; UCHAR ucMiscInfo4 ; UCHAR ucVideoInput0Info ; UCHAR ucVideoInput1Info ; UCHAR ucVideoInput2Info ; UCHAR ucVideoInput3Info ; UCHAR ucVideoInput4Info ; } ATOM_MULTIMEDIA_CONFIG_INFO ;


typedef struct _ATOM_FIRMWARE_CAPABILITY { USHORT FirmwarePosted : 1 ; USHORT DualCRTC_Support : 1 ; USHORT ExtendedDesktopSupport : 1 ; USHORT MemoryClockSS_Support : 1 ; USHORT EngineClockSS_Support : 1 ; USHORT GPUControlsBL : 1 ; USHORT WMI_SUPPORT : 1 ; USHORT PPMode_Assigned : 1 ; USHORT HyperMemory_Support : 1 ; USHORT HyperMemory_Size : 4 ; USHORT Reserved : 3 ; } ATOM_FIRMWARE_CAPABILITY ;


typedef union _ATOM_FIRMWARE_CAPABILITY_ACCESS { ATOM_FIRMWARE_CAPABILITY sbfAccess ; USHORT susAccess ; } ATOM_FIRMWARE_CAPABILITY_ACCESS ;


typedef struct _ATOM_FIRMWARE_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ULONG ulFirmwareRevision ; ULONG ulDefaultEngineClock ; ULONG ulDefaultMemoryClock ; ULONG ulDriverTargetEngineClock ; ULONG ulDriverTargetMemoryClock ; ULONG ulMaxEngineClockPLL_Output ; ULONG ulMaxMemoryClockPLL_Output ; ULONG ulMaxPixelClockPLL_Output ; ULONG ulASICMaxEngineClock ; ULONG ulASICMaxMemoryClock ; UCHAR ucASICMaxTemperature ; UCHAR ucPadding [ 3 ] ; ULONG aulReservedForBIOS [ 3 ] ; USHORT usMinEngineClockPLL_Input ; USHORT usMaxEngineClockPLL_Input ; USHORT usMinEngineClockPLL_Output ; USHORT usMinMemoryClockPLL_Input ; USHORT usMaxMemoryClockPLL_Input ; USHORT usMinMemoryClockPLL_Output ; USHORT usMaxPixelClock ; USHORT usMinPixelClockPLL_Input ; USHORT usMaxPixelClockPLL_Input ; USHORT usMinPixelClockPLL_Output ; ATOM_FIRMWARE_CAPABILITY_ACCESS usFirmwareCapability ; USHORT usReferenceClock ; USHORT usPM_RTS_Location ; UCHAR ucPM_RTS_StreamSize ; UCHAR ucDesign_ID ; UCHAR ucMemoryModule_ID ; } ATOM_FIRMWARE_INFO ;


typedef struct _ATOM_FIRMWARE_INFO_V1_2 { ATOM_COMMON_TABLE_HEADER sHeader ; ULONG ulFirmwareRevision ; ULONG ulDefaultEngineClock ; ULONG ulDefaultMemoryClock ; ULONG ulDriverTargetEngineClock ; ULONG ulDriverTargetMemoryClock ; ULONG ulMaxEngineClockPLL_Output ; ULONG ulMaxMemoryClockPLL_Output ; ULONG ulMaxPixelClockPLL_Output ; ULONG ulASICMaxEngineClock ; ULONG ulASICMaxMemoryClock ; UCHAR ucASICMaxTemperature ; UCHAR ucMinAllowedBL_Level ; UCHAR ucPadding [ 2 ] ; ULONG aulReservedForBIOS [ 2 ] ; ULONG ulMinPixelClockPLL_Output ; USHORT usMinEngineClockPLL_Input ; USHORT usMaxEngineClockPLL_Input ; USHORT usMinEngineClockPLL_Output ; USHORT usMinMemoryClockPLL_Input ; USHORT usMaxMemoryClockPLL_Input ; USHORT usMinMemoryClockPLL_Output ; USHORT usMaxPixelClock ; USHORT usMinPixelClockPLL_Input ; USHORT usMaxPixelClockPLL_Input ; USHORT usMinPixelClockPLL_Output ; ATOM_FIRMWARE_CAPABILITY_ACCESS usFirmwareCapability ; USHORT usReferenceClock ; USHORT usPM_RTS_Location ; UCHAR ucPM_RTS_StreamSize ; UCHAR ucDesign_ID ; UCHAR ucMemoryModule_ID ; } ATOM_FIRMWARE_INFO_V1_2 ;


typedef struct _ATOM_FIRMWARE_INFO_V1_3 { ATOM_COMMON_TABLE_HEADER sHeader ; ULONG ulFirmwareRevision ; ULONG ulDefaultEngineClock ; ULONG ulDefaultMemoryClock ; ULONG ulDriverTargetEngineClock ; ULONG ulDriverTargetMemoryClock ; ULONG ulMaxEngineClockPLL_Output ; ULONG ulMaxMemoryClockPLL_Output ; ULONG ulMaxPixelClockPLL_Output ; ULONG ulASICMaxEngineClock ; ULONG ulASICMaxMemoryClock ; UCHAR ucASICMaxTemperature ; UCHAR ucMinAllowedBL_Level ; UCHAR ucPadding [ 2 ] ; ULONG aulReservedForBIOS ; ULONG ul3DAccelerationEngineClock ; ULONG ulMinPixelClockPLL_Output ; USHORT usMinEngineClockPLL_Input ; USHORT usMaxEngineClockPLL_Input ; USHORT usMinEngineClockPLL_Output ; USHORT usMinMemoryClockPLL_Input ; USHORT usMaxMemoryClockPLL_Input ; USHORT usMinMemoryClockPLL_Output ; USHORT usMaxPixelClock ; USHORT usMinPixelClockPLL_Input ; USHORT usMaxPixelClockPLL_Input ; USHORT usMinPixelClockPLL_Output ; ATOM_FIRMWARE_CAPABILITY_ACCESS usFirmwareCapability ; USHORT usReferenceClock ; USHORT usPM_RTS_Location ; UCHAR ucPM_RTS_StreamSize ; UCHAR ucDesign_ID ; UCHAR ucMemoryModule_ID ; } ATOM_FIRMWARE_INFO_V1_3 ;


typedef struct _ATOM_FIRMWARE_INFO_V1_4 { ATOM_COMMON_TABLE_HEADER sHeader ; ULONG ulFirmwareRevision ; ULONG ulDefaultEngineClock ; ULONG ulDefaultMemoryClock ; ULONG ulDriverTargetEngineClock ; ULONG ulDriverTargetMemoryClock ; ULONG ulMaxEngineClockPLL_Output ; ULONG ulMaxMemoryClockPLL_Output ; ULONG ulMaxPixelClockPLL_Output ; ULONG ulASICMaxEngineClock ; ULONG ulASICMaxMemoryClock ; UCHAR ucASICMaxTemperature ; UCHAR ucMinAllowedBL_Level ; USHORT usBootUpVDDCVoltage ; USHORT usLcdMinPixelClockPLL_Output ; USHORT usLcdMaxPixelClockPLL_Output ; ULONG ul3DAccelerationEngineClock ; ULONG ulMinPixelClockPLL_Output ; USHORT usMinEngineClockPLL_Input ; USHORT usMaxEngineClockPLL_Input ; USHORT usMinEngineClockPLL_Output ; USHORT usMinMemoryClockPLL_Input ; USHORT usMaxMemoryClockPLL_Input ; USHORT usMinMemoryClockPLL_Output ; USHORT usMaxPixelClock ; USHORT usMinPixelClockPLL_Input ; USHORT usMaxPixelClockPLL_Input ; USHORT usMinPixelClockPLL_Output ; ATOM_FIRMWARE_CAPABILITY_ACCESS usFirmwareCapability ; USHORT usReferenceClock ; USHORT usPM_RTS_Location ; UCHAR ucPM_RTS_StreamSize ; UCHAR ucDesign_ID ; UCHAR ucMemoryModule_ID ; } ATOM_FIRMWARE_INFO_V1_4 ;


typedef struct _ATOM_INTEGRATED_SYSTEM_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ULONG ulBootUpEngineClock ; ULONG ulBootUpMemoryClock ; ULONG ulMaxSystemMemoryClock ; ULONG ulMinSystemMemoryClock ; UCHAR ucNumberOfCyclesInPeriodHi ; UCHAR ucLCDTimingSel ; USHORT usReserved1 ; USHORT usInterNBVoltageLow ; USHORT usInterNBVoltageHigh ; ULONG ulReserved [ 2 ] ; USHORT usFSBClock ; USHORT usCapabilityFlag ; USHORT usPCIENBCfgReg7 ; USHORT usK8MemoryClock ; USHORT usK8SyncStartDelay ; USHORT usK8DataReturnTime ; UCHAR ucMaxNBVoltage ; UCHAR ucMinNBVoltage ; UCHAR ucMemoryType ; UCHAR ucNumberOfCyclesInPeriod ; UCHAR ucStartingPWM_HighTime ; UCHAR ucHTLinkWidth ; UCHAR ucMaxNBVoltageHigh ; UCHAR ucMinNBVoltageHigh ; } ATOM_INTEGRATED_SYSTEM_INFO ;


typedef struct _ATOM_INTEGRATED_SYSTEM_INFO_V2 { ATOM_COMMON_TABLE_HEADER sHeader ; ULONG ulBootUpEngineClock ; ULONG ulReserved1 [ 2 ] ; ULONG ulBootUpUMAClock ; ULONG ulBootUpSidePortClock ; ULONG ulMinSidePortClock ; ULONG ulReserved2 [ 6 ] ; ULONG ulSystemConfig ; ULONG ulBootUpReqDisplayVector ; ULONG ulOtherDisplayMisc ; ULONG ulDDISlot1Config ; ULONG ulDDISlot2Config ; UCHAR ucMemoryType ; UCHAR ucUMAChannelNumber ; UCHAR ucDockingPinBit ; UCHAR ucDockingPinPolarity ; ULONG ulDockingPinCFGInfo ; ULONG ulCPUCapInfo ; USHORT usNumberOfCyclesInPeriod ; USHORT usMaxNBVoltage ; USHORT usMinNBVoltage ; USHORT usBootUpNBVoltage ; ULONG ulHTLinkFreq ; USHORT usMinHTLinkWidth ; USHORT usMaxHTLinkWidth ; USHORT usUMASyncStartDelay ; USHORT usUMADataReturnTime ; USHORT usLinkStatusZeroTime ; USHORT usReserved ; ULONG ulHighVoltageHTLinkFreq ; ULONG ulLowVoltageHTLinkFreq ; USHORT usMaxUpStreamHTLinkWidth ; USHORT usMaxDownStreamHTLinkWidth ; USHORT usMinUpStreamHTLinkWidth ; USHORT usMinDownStreamHTLinkWidth ; ULONG ulReserved3 [ 97 ] ; } ATOM_INTEGRATED_SYSTEM_INFO_V2 ;


typedef struct _ATOM_I2C_ID_CONFIG { UCHAR bfI2C_LineMux : 4 ; UCHAR bfHW_EngineID : 3 ; UCHAR bfHW_Capable : 1 ; } ATOM_I2C_ID_CONFIG ;


typedef union _ATOM_I2C_ID_CONFIG_ACCESS { ATOM_I2C_ID_CONFIG sbfAccess ; UCHAR ucAccess ; } ATOM_I2C_ID_CONFIG_ACCESS ;


typedef struct _ATOM_GPIO_I2C_ASSIGMENT { USHORT usClkMaskRegisterIndex ; USHORT usClkEnRegisterIndex ; USHORT usClkY_RegisterIndex ; USHORT usClkA_RegisterIndex ; USHORT usDataMaskRegisterIndex ; USHORT usDataEnRegisterIndex ; USHORT usDataY_RegisterIndex ; USHORT usDataA_RegisterIndex ; ATOM_I2C_ID_CONFIG_ACCESS sucI2cId ; UCHAR ucClkMaskShift ; UCHAR ucClkEnShift ; UCHAR ucClkY_Shift ; UCHAR ucClkA_Shift ; UCHAR ucDataMaskShift ; UCHAR ucDataEnShift ; UCHAR ucDataY_Shift ; UCHAR ucDataA_Shift ; UCHAR ucReserved1 ; UCHAR ucReserved2 ; } ATOM_GPIO_I2C_ASSIGMENT ;


typedef struct _ATOM_GPIO_I2C_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_GPIO_I2C_ASSIGMENT asGPIO_Info [ ( 0x0000000F + 1 ) ] ; } ATOM_GPIO_I2C_INFO ;


typedef struct _ATOM_MODE_MISC_INFO { USHORT HorizontalCutOff : 1 ; USHORT HSyncPolarity : 1 ; USHORT VSyncPolarity : 1 ; USHORT VerticalCutOff : 1 ; USHORT H_ReplicationBy2 : 1 ; USHORT V_ReplicationBy2 : 1 ; USHORT CompositeSync : 1 ; USHORT Interlace : 1 ; USHORT DoubleClock : 1 ; USHORT RGB888 : 1 ; USHORT Reserved : 6 ; } ATOM_MODE_MISC_INFO ;


typedef union _ATOM_MODE_MISC_INFO_ACCESS { ATOM_MODE_MISC_INFO sbfAccess ; USHORT usAccess ; } ATOM_MODE_MISC_INFO_ACCESS ;


typedef struct _SET_CRTC_USING_DTD_TIMING_PARAMETERS { USHORT usH_Size ; USHORT usH_Blanking_Time ; USHORT usV_Size ; USHORT usV_Blanking_Time ; USHORT usH_SyncOffset ; USHORT usH_SyncWidth ; USHORT usV_SyncOffset ; USHORT usV_SyncWidth ; ATOM_MODE_MISC_INFO_ACCESS susModeMiscInfo ; UCHAR ucH_Border ; UCHAR ucV_Border ; UCHAR ucCRTC ; UCHAR ucPadding [ 3 ] ; } SET_CRTC_USING_DTD_TIMING_PARAMETERS ;


typedef struct _SET_CRTC_TIMING_PARAMETERS { USHORT usH_Total ; USHORT usH_Disp ; USHORT usH_SyncStart ; USHORT usH_SyncWidth ; USHORT usV_Total ; USHORT usV_Disp ; USHORT usV_SyncStart ; USHORT usV_SyncWidth ; ATOM_MODE_MISC_INFO_ACCESS susModeMiscInfo ; UCHAR ucCRTC ; UCHAR ucOverscanRight ; UCHAR ucOverscanLeft ; UCHAR ucOverscanBottom ; UCHAR ucOverscanTop ; UCHAR ucReserved ; } SET_CRTC_TIMING_PARAMETERS ;


typedef struct _ATOM_MODE_TIMING { USHORT usCRTC_H_Total ; USHORT usCRTC_H_Disp ; USHORT usCRTC_H_SyncStart ; USHORT usCRTC_H_SyncWidth ; USHORT usCRTC_V_Total ; USHORT usCRTC_V_Disp ; USHORT usCRTC_V_SyncStart ; USHORT usCRTC_V_SyncWidth ; USHORT usPixelClock ; ATOM_MODE_MISC_INFO_ACCESS susModeMiscInfo ; USHORT usCRTC_OverscanRight ; USHORT usCRTC_OverscanLeft ; USHORT usCRTC_OverscanBottom ; USHORT usCRTC_OverscanTop ; USHORT usReserve ; UCHAR ucInternalModeNumber ; UCHAR ucRefreshRate ; } ATOM_MODE_TIMING ;


typedef struct _ATOM_DTD_FORMAT { USHORT usPixClk ; USHORT usHActive ; USHORT usHBlanking_Time ; USHORT usVActive ; USHORT usVBlanking_Time ; USHORT usHSyncOffset ; USHORT usHSyncWidth ; USHORT usVSyncOffset ; USHORT usVSyncWidth ; USHORT usImageHSize ; USHORT usImageVSize ; UCHAR ucHBorder ; UCHAR ucVBorder ; ATOM_MODE_MISC_INFO_ACCESS susModeMiscInfo ; UCHAR ucInternalModeNumber ; UCHAR ucRefreshRate ; } ATOM_DTD_FORMAT ;


typedef struct _ATOM_LVDS_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_DTD_FORMAT sLCDTiming ; USHORT usModePatchTableOffset ; USHORT usSupportedRefreshRate ; USHORT usOffDelayInMs ; UCHAR ucPowerSequenceDigOntoDEin10Ms ; UCHAR ucPowerSequenceDEtoBLOnin10Ms ; UCHAR ucLVDS_Misc ; UCHAR ucPanelDefaultRefreshRate ; UCHAR ucPanelIdentification ; UCHAR ucSS_Id ; } ATOM_LVDS_INFO ;


typedef struct _ATOM_LVDS_INFO_V12 { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_DTD_FORMAT sLCDTiming ; USHORT usExtInfoTableOffset ; USHORT usSupportedRefreshRate ; USHORT usOffDelayInMs ; UCHAR ucPowerSequenceDigOntoDEin10Ms ; UCHAR ucPowerSequenceDEtoBLOnin10Ms ; UCHAR ucLVDS_Misc ; UCHAR ucPanelDefaultRefreshRate ; UCHAR ucPanelIdentification ; UCHAR ucSS_Id ; USHORT usLCDVenderID ; USHORT usLCDProductID ; UCHAR ucLCDPanel_SpecialHandlingCap ; UCHAR ucPanelInfoSize ; UCHAR ucReserved [ 2 ] ; } ATOM_LVDS_INFO_V12 ;


typedef struct _ATOM_PATCH_RECORD_MODE { UCHAR ucRecordType ; USHORT usHDisp ; USHORT usVDisp ; } ATOM_PATCH_RECORD_MODE ;


typedef struct _ATOM_LCD_RTS_RECORD { UCHAR ucRecordType ; UCHAR ucRTSValue ; } ATOM_LCD_RTS_RECORD ;


typedef struct _ATOM_LCD_MODE_CONTROL_CAP { UCHAR ucRecordType ; USHORT usLCDCap ; } ATOM_LCD_MODE_CONTROL_CAP ;


typedef struct _ATOM_FAKE_EDID_PATCH_RECORD { UCHAR ucRecordType ; UCHAR ucFakeEDIDLength ; UCHAR ucFakeEDIDString [ 1 ] ; } ATOM_FAKE_EDID_PATCH_RECORD ;


typedef struct _ATOM_PANEL_RESOLUTION_PATCH_RECORD { UCHAR ucRecordType ; USHORT usHSize ; USHORT usVSize ; } ATOM_PANEL_RESOLUTION_PATCH_RECORD ;


typedef struct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT { USHORT usSpreadSpectrumPercentage ; UCHAR ucSpreadSpectrumType ; UCHAR ucSS_Step ; UCHAR ucSS_Delay ; UCHAR ucSS_Id ; UCHAR ucRecommendedRef_Div ; UCHAR ucSS_Range ; } ATOM_SPREAD_SPECTRUM_ASSIGNMENT ;


typedef struct _ATOM_SPREAD_SPECTRUM_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_SPREAD_SPECTRUM_ASSIGNMENT asSS_Info [ 16 ] ; } ATOM_SPREAD_SPECTRUM_INFO ;


typedef struct _ATOM_ANALOG_TV_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucTV_SupportedStandard ; UCHAR ucTV_BootUpDefaultStandard ; UCHAR ucExt_TV_ASIC_ID ; UCHAR ucExt_TV_ASIC_SlaveAddr ; ATOM_MODE_TIMING aModeTimings [ 2 ] ; } ATOM_ANALOG_TV_INFO ;


typedef struct _ATOM_ANALOG_TV_INFO_V1_2 { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucTV_SupportedStandard ; UCHAR ucTV_BootUpDefaultStandard ; UCHAR ucExt_TV_ASIC_ID ; UCHAR ucExt_TV_ASIC_SlaveAddr ; ATOM_DTD_FORMAT aModeTimings [ 2 ] ; } ATOM_ANALOG_TV_INFO_V1_2 ;


typedef struct _ATOM_FIRMWARE_VRAM_RESERVE_INFO { ULONG ulStartAddrUsedByFirmware ; USHORT usFirmwareUseInKb ; USHORT usReserved ; } ATOM_FIRMWARE_VRAM_RESERVE_INFO ;


typedef struct _ATOM_VRAM_USAGE_BY_FIRMWARE { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_FIRMWARE_VRAM_RESERVE_INFO asFirmwareVramReserveInfo [ 1 ] ; } ATOM_VRAM_USAGE_BY_FIRMWARE ;


typedef struct _ATOM_GPIO_PIN_ASSIGNMENT { USHORT usGpioPin_AIndex ; UCHAR ucGpioPinBitShift ; UCHAR ucGPIO_ID ; } ATOM_GPIO_PIN_ASSIGNMENT ;


typedef struct _ATOM_GPIO_PIN_LUT { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_GPIO_PIN_ASSIGNMENT asGPIO_Pin [ 1 ] ; } ATOM_GPIO_PIN_LUT ;


typedef struct _ATOM_GPIO_INFO { USHORT usAOffset ; UCHAR ucSettings ; UCHAR ucReserved ; } ATOM_GPIO_INFO ;


typedef struct _ATOM_COMPONENT_VIDEO_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usMask_PinRegisterIndex ; USHORT usEN_PinRegisterIndex ; USHORT usY_PinRegisterIndex ; USHORT usA_PinRegisterIndex ; UCHAR ucBitShift ; UCHAR ucPinActiveState ; ATOM_DTD_FORMAT sReserved ; UCHAR ucMiscInfo ; UCHAR uc480i ; UCHAR uc480p ; UCHAR uc720p ; UCHAR uc1080i ; UCHAR ucLetterBoxMode ; UCHAR ucReserved [ 3 ] ; UCHAR ucNumOfWbGpioBlocks ; ATOM_GPIO_INFO aWbGpioStateBlock [ 5 ] ; ATOM_DTD_FORMAT aModeTimings [ 5 ] ; } ATOM_COMPONENT_VIDEO_INFO ;


typedef struct _ATOM_COMPONENT_VIDEO_INFO_V21 { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucMiscInfo ; UCHAR uc480i ; UCHAR uc480p ; UCHAR uc720p ; UCHAR uc1080i ; UCHAR ucReserved ; UCHAR ucLetterBoxMode ; UCHAR ucNumOfWbGpioBlocks ; ATOM_GPIO_INFO aWbGpioStateBlock [ 5 ] ; ATOM_DTD_FORMAT aModeTimings [ 5 ] ; } ATOM_COMPONENT_VIDEO_INFO_V21 ;


typedef struct _ATOM_OBJECT_HEADER { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usDeviceSupport ; USHORT usConnectorObjectTableOffset ; USHORT usRouterObjectTableOffset ; USHORT usEncoderObjectTableOffset ; USHORT usProtectionObjectTableOffset ; USHORT usDisplayPathTableOffset ; } ATOM_OBJECT_HEADER ;


typedef struct _ATOM_DISPLAY_OBJECT_PATH { USHORT usDeviceTag ; USHORT usSize ; USHORT usConnObjectId ; USHORT usGPUObjectId ; USHORT usGraphicObjIds [ 1 ] ; } ATOM_DISPLAY_OBJECT_PATH ;


typedef struct _ATOM_DISPLAY_OBJECT_PATH_TABLE { UCHAR ucNumOfDispPath ; UCHAR ucVersion ; UCHAR ucPadding [ 2 ] ; ATOM_DISPLAY_OBJECT_PATH asDispPath [ 1 ] ; } ATOM_DISPLAY_OBJECT_PATH_TABLE ;


typedef struct _ATOM_OBJECT { USHORT usObjectID ; USHORT usSrcDstTableOffset ; USHORT usRecordOffset ; USHORT usReserved ; } ATOM_OBJECT ;


typedef struct _ATOM_OBJECT_TABLE { UCHAR ucNumberOfObjects ; UCHAR ucPadding [ 3 ] ; ATOM_OBJECT asObjects [ 1 ] ; } ATOM_OBJECT_TABLE ;


typedef struct _ATOM_SRC_DST_TABLE_FOR_ONE_OBJECT { UCHAR ucNumberOfSrc ; USHORT usSrcObjectID [ 1 ] ; UCHAR ucNumberOfDst ; USHORT usDstObjectID [ 1 ] ; } ATOM_SRC_DST_TABLE_FOR_ONE_OBJECT ;


typedef struct _ATOM_COMMON_RECORD_HEADER { UCHAR ucRecordType ; UCHAR ucRecordSize ; } ATOM_COMMON_RECORD_HEADER ;


typedef struct _ATOM_I2C_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; ATOM_I2C_ID_CONFIG sucI2cId ; UCHAR ucI2CAddr ; } ATOM_I2C_RECORD ;


typedef struct _ATOM_HPD_INT_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucHPDIntGPIOID ; UCHAR ucPlugged_PinState ; } ATOM_HPD_INT_RECORD ;


typedef struct _ATOM_OUTPUT_PROTECTION_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucProtectionFlag ; UCHAR ucReserved ; } ATOM_OUTPUT_PROTECTION_RECORD ;


typedef struct _ATOM_CONNECTOR_DEVICE_TAG { ULONG ulACPIDeviceEnum ; USHORT usDeviceID ; USHORT usPadding ; } ATOM_CONNECTOR_DEVICE_TAG ;


typedef struct _ATOM_CONNECTOR_DEVICE_TAG_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucNumberOfDevice ; UCHAR ucReserved ; ATOM_CONNECTOR_DEVICE_TAG asDeviceTag [ 1 ] ; } ATOM_CONNECTOR_DEVICE_TAG_RECORD ;


typedef struct _ATOM_CONNECTOR_DVI_EXT_INPUT_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucConfigGPIOID ; UCHAR ucConfigGPIOState ; UCHAR ucFlowinGPIPID ; UCHAR ucExtInGPIPID ; } ATOM_CONNECTOR_DVI_EXT_INPUT_RECORD ;


typedef struct _ATOM_ENCODER_FPGA_CONTROL_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucCTL1GPIO_ID ; UCHAR ucCTL1GPIOState ; UCHAR ucCTL2GPIO_ID ; UCHAR ucCTL2GPIOState ; UCHAR ucCTL3GPIO_ID ; UCHAR ucCTL3GPIOState ; UCHAR ucCTLFPGA_IN_ID ; UCHAR ucPadding [ 3 ] ; } ATOM_ENCODER_FPGA_CONTROL_RECORD ;


typedef struct _ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucGPIOID ; UCHAR ucTVActiveState ; } ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD ;


typedef struct _ATOM_JTAG_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucTMSGPIO_ID ; UCHAR ucTMSGPIOState ; UCHAR ucTCKGPIO_ID ; UCHAR ucTCKGPIOState ; UCHAR ucTDOGPIO_ID ; UCHAR ucTDOGPIOState ; UCHAR ucTDIGPIO_ID ; UCHAR ucTDIGPIOState ; UCHAR ucPadding [ 2 ] ; } ATOM_JTAG_RECORD ;


typedef struct _ATOM_GPIO_PIN_CONTROL_PAIR { UCHAR ucGPIOID ; UCHAR ucGPIO_PinState ; } ATOM_GPIO_PIN_CONTROL_PAIR ;


typedef struct _ATOM_OBJECT_GPIO_CNTL_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucFlags ; UCHAR ucNumberOfPins ; ATOM_GPIO_PIN_CONTROL_PAIR asGpio [ 1 ] ; } ATOM_OBJECT_GPIO_CNTL_RECORD ;


typedef struct _ATOM_ENCODER_DVO_CF_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; ULONG ulStrengthControl ; UCHAR ucPadding [ 2 ] ; } ATOM_ENCODER_DVO_CF_RECORD ;


typedef struct _ATOM_CONNECTOR_CF_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; USHORT usMaxPixClk ; UCHAR ucFlowCntlGpioId ; UCHAR ucSwapCntlGpioId ; UCHAR ucConnectedDvoBundle ; UCHAR ucPadding ; } ATOM_CONNECTOR_CF_RECORD ;


typedef struct _ATOM_CONNECTOR_HARDCODE_DTD_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; ATOM_DTD_FORMAT asTiming ; } ATOM_CONNECTOR_HARDCODE_DTD_RECORD ;


typedef struct _ATOM_CONNECTOR_PCIE_SUBCONNECTOR_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucSubConnectorType ; UCHAR ucReserved ; } ATOM_CONNECTOR_PCIE_SUBCONNECTOR_RECORD ;


typedef struct _ATOM_ROUTER_DDC_PATH_SELECT_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucMuxType ; UCHAR ucMuxControlPin ; UCHAR ucMuxState [ 2 ] ; } ATOM_ROUTER_DDC_PATH_SELECT_RECORD ;


typedef struct _ATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD { ATOM_COMMON_RECORD_HEADER sheader ; UCHAR ucMuxType ; UCHAR ucMuxControlPin ; UCHAR ucMuxState [ 2 ] ; } ATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD ;


typedef struct _ATOM_VOLTAGE_INFO_HEADER { USHORT usVDDCBaseLevel ; USHORT usReserved ; UCHAR ucNumOfVoltageEntries ; UCHAR ucBytesPerVoltageEntry ; UCHAR ucVoltageStep ; UCHAR ucDefaultVoltageEntry ; UCHAR ucVoltageControlI2cLine ; UCHAR ucVoltageControlAddress ; UCHAR ucVoltageControlOffset ; } ATOM_VOLTAGE_INFO_HEADER ;


typedef struct _ATOM_VOLTAGE_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_VOLTAGE_INFO_HEADER viHeader ; UCHAR ucVoltageEntries [ 64 ] ; } ATOM_VOLTAGE_INFO ;


typedef struct _ATOM_VOLTAGE_FORMULA { USHORT usVoltageBaseLevel ; USHORT usVoltageStep ; UCHAR ucNumOfVoltageEntries ; UCHAR ucFlag ; UCHAR ucBaseVID ; UCHAR ucReserved ; UCHAR ucVIDAdjustEntries [ 32 ] ; } ATOM_VOLTAGE_FORMULA ;


typedef struct _ATOM_VOLTAGE_CONTROL { UCHAR ucVoltageControlId ; UCHAR ucVoltageControlI2cLine ; UCHAR ucVoltageControlAddress ; UCHAR ucVoltageControlOffset ; USHORT usGpioPin_AIndex ; UCHAR ucGpioPinBitShift [ 9 ] ; UCHAR ucReserved ; } ATOM_VOLTAGE_CONTROL ;


typedef struct _ATOM_VOLTAGE_OBJECT { UCHAR ucVoltageType ; UCHAR ucSize ; ATOM_VOLTAGE_CONTROL asControl ; ATOM_VOLTAGE_FORMULA asFormula ; } ATOM_VOLTAGE_OBJECT ;


typedef struct _ATOM_VOLTAGE_OBJECT_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_VOLTAGE_OBJECT asVoltageObj [ 3 ] ; } ATOM_VOLTAGE_OBJECT_INFO ;


typedef struct _ATOM_LEAKID_VOLTAGE { UCHAR ucLeakageId ; UCHAR ucReserved ; USHORT usVoltage ; } ATOM_LEAKID_VOLTAGE ;


typedef struct _ATOM_ASIC_PROFILE_VOLTAGE { UCHAR ucProfileId ; UCHAR ucReserved ; USHORT usSize ; USHORT usEfuseSpareStartAddr ; USHORT usFuseIndex [ 8 ] ; ATOM_LEAKID_VOLTAGE asLeakVol [ 2 ] ; } ATOM_ASIC_PROFILE_VOLTAGE ;


typedef struct _ATOM_ASIC_PROFILING_INFO { ATOM_COMMON_TABLE_HEADER asHeader ; ATOM_ASIC_PROFILE_VOLTAGE asVoltage ; } ATOM_ASIC_PROFILING_INFO ;


typedef struct _ATOM_POWER_SOURCE_OBJECT { UCHAR ucPwrSrcId ; UCHAR ucPwrSensorType ; UCHAR ucPwrSensId ; UCHAR ucPwrSensSlaveAddr ; UCHAR ucPwrSensRegIndex ; UCHAR ucPwrSensRegBitMask ; UCHAR ucPwrSensActiveState ; UCHAR ucReserve [ 3 ] ; USHORT usSensPwr ; } ATOM_POWER_SOURCE_OBJECT ;


typedef struct _ATOM_POWER_SOURCE_INFO { ATOM_COMMON_TABLE_HEADER asHeader ; UCHAR asPwrbehave [ 16 ] ; ATOM_POWER_SOURCE_OBJECT asPwrObj [ 1 ] ; } ATOM_POWER_SOURCE_INFO ;


typedef struct _ATOM_I2C_DATA_RECORD { UCHAR ucNunberOfBytes ; UCHAR ucI2CData [ 1 ] ; } ATOM_I2C_DATA_RECORD ;


typedef struct _ATOM_I2C_DEVICE_SETUP_INFO { ATOM_I2C_ID_CONFIG_ACCESS sucI2cId ; UCHAR ucSSChipID ; UCHAR ucSSChipSlaveAddr ; UCHAR ucNumOfI2CDataRecords ; ATOM_I2C_DATA_RECORD asI2CData [ 1 ] ; } ATOM_I2C_DEVICE_SETUP_INFO ;


typedef struct _ATOM_ASIC_MVDD_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_I2C_DEVICE_SETUP_INFO asI2CSetup [ 1 ] ; } ATOM_ASIC_MVDD_INFO ;


typedef struct _ATOM_ASIC_SS_ASSIGNMENT { ULONG ulTargetClockRange ; USHORT usSpreadSpectrumPercentage ; USHORT usSpreadRateInKhz ; UCHAR ucClockIndication ; UCHAR ucSpreadSpectrumMode ; UCHAR ucReserved [ 2 ] ; } ATOM_ASIC_SS_ASSIGNMENT ;


typedef struct _ATOM_ASIC_INTERNAL_SS_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_ASIC_SS_ASSIGNMENT asSpreadSpectrum [ 4 ] ; } ATOM_ASIC_INTERNAL_SS_INFO ;


typedef struct _MEMORY_PLLINIT_PARAMETERS { ULONG ulTargetMemoryClock ; UCHAR ucAction ; UCHAR ucFbDiv_Hi ; UCHAR ucFbDiv ; UCHAR ucPostDiv ; } MEMORY_PLLINIT_PARAMETERS ;


typedef struct _GPIO_PIN_CONTROL_PARAMETERS { UCHAR ucGPIO_ID ; UCHAR ucGPIOBitShift ; UCHAR ucGPIOBitVal ; UCHAR ucAction ; } GPIO_PIN_CONTROL_PARAMETERS ;


typedef struct _ENABLE_SCALER_PARAMETERS { UCHAR ucScaler ; UCHAR ucEnable ; UCHAR ucTVStandard ; UCHAR ucPadding [ 1 ] ; } ENABLE_SCALER_PARAMETERS ;


typedef struct _ENABLE_HARDWARE_ICON_CURSOR_PARAMETERS { ULONG usHWIconHorzVertPosn ; UCHAR ucHWIconVertOffset ; UCHAR ucHWIconHorzOffset ; UCHAR ucSelection ; UCHAR ucEnable ; } ENABLE_HARDWARE_ICON_CURSOR_PARAMETERS ;


typedef struct _ENABLE_HARDWARE_ICON_CURSOR_PS_ALLOCATION { ENABLE_HARDWARE_ICON_CURSOR_PARAMETERS sEnableIcon ; ENABLE_CRTC_PARAMETERS sReserved ; } ENABLE_HARDWARE_ICON_CURSOR_PS_ALLOCATION ;


typedef struct _ENABLE_GRAPH_SURFACE_PARAMETERS { USHORT usHight ; USHORT usWidth ; UCHAR ucSurface ; UCHAR ucPadding [ 3 ] ; } ENABLE_GRAPH_SURFACE_PARAMETERS ;


typedef struct _ENABLE_GRAPH_SURFACE_PARAMETERS_V1_2 { USHORT usHight ; USHORT usWidth ; UCHAR ucSurface ; UCHAR ucEnable ; UCHAR ucPadding [ 2 ] ; } ENABLE_GRAPH_SURFACE_PARAMETERS_V1_2 ;


typedef struct _ENABLE_GRAPH_SURFACE_PS_ALLOCATION { ENABLE_GRAPH_SURFACE_PARAMETERS sSetSurface ; ENABLE_YUV_PARAMETERS sReserved ; } ENABLE_GRAPH_SURFACE_PS_ALLOCATION ;


typedef struct _MEMORY_CLEAN_UP_PARAMETERS { USHORT usMemoryStart ; USHORT usMemorySize ; } MEMORY_CLEAN_UP_PARAMETERS ;


typedef struct _GET_DISPLAY_SURFACE_SIZE_PARAMETERS { USHORT usX_Size ; USHORT usY_Size ; } GET_DISPLAY_SURFACE_SIZE_PARAMETERS ;


typedef struct _INDIRECT_IO_ACCESS { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR IOAccessSequence [ 256 ] ; } INDIRECT_IO_ACCESS ;


typedef struct _ATOM_OEM_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_I2C_ID_CONFIG_ACCESS sucI2cId ; } ATOM_OEM_INFO ;


typedef struct _ATOM_TV_MODE { UCHAR ucVMode_Num ; UCHAR ucTV_Mode_Num ; } ATOM_TV_MODE ;


typedef struct _ATOM_BIOS_INT_TVSTD_MODE { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usTV_Mode_LUT_Offset ; USHORT usTV_FIFO_Offset ; USHORT usNTSC_Tbl_Offset ; USHORT usPAL_Tbl_Offset ; USHORT usCV_Tbl_Offset ; } ATOM_BIOS_INT_TVSTD_MODE ;


typedef struct _ATOM_TV_MODE_SCALER_PTR { USHORT ucFilter0_Offset ; USHORT usFilter1_Offset ; UCHAR ucTV_Mode_Num ; } ATOM_TV_MODE_SCALER_PTR ;


typedef struct _ATOM_STANDARD_VESA_TIMING { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_DTD_FORMAT aModeTimings [ 16 ] ; } ATOM_STANDARD_VESA_TIMING ;


typedef struct _ATOM_STD_FORMAT { USHORT usSTD_HDisp ; USHORT usSTD_VDisp ; USHORT usSTD_RefreshRate ; USHORT usReserved ; } ATOM_STD_FORMAT ;


typedef struct _ATOM_VESA_TO_EXTENDED_MODE { USHORT usVESA_ModeNumber ; USHORT usExtendedModeNumber ; } ATOM_VESA_TO_EXTENDED_MODE ;


typedef struct _ATOM_VESA_TO_INTENAL_MODE_LUT { ATOM_COMMON_TABLE_HEADER sHeader ; ATOM_VESA_TO_EXTENDED_MODE asVESA_ToExtendedModeInfo [ 76 ] ; } ATOM_VESA_TO_INTENAL_MODE_LUT ;


typedef struct _ATOM_MEMORY_VENDOR_BLOCK { UCHAR ucMemoryType ; UCHAR ucMemoryVendor ; UCHAR ucAdjMCId ; UCHAR ucDynClkId ; ULONG ulDllResetClkRange ; } ATOM_MEMORY_VENDOR_BLOCK ;


typedef struct _ATOM_MEMORY_SETTING_ID_CONFIG { ULONG ulMemClockRange : 24 ; ULONG ucMemBlkId : 8 ; } ATOM_MEMORY_SETTING_ID_CONFIG ;


typedef union _ATOM_MEMORY_SETTING_ID_CONFIG_ACCESS { ATOM_MEMORY_SETTING_ID_CONFIG slAccess ; ULONG ulAccess ; } ATOM_MEMORY_SETTING_ID_CONFIG_ACCESS ;


typedef struct _ATOM_MEMORY_SETTING_DATA_BLOCK { ATOM_MEMORY_SETTING_ID_CONFIG_ACCESS ulMemoryID ; ULONG aulMemData [ 1 ] ; } ATOM_MEMORY_SETTING_DATA_BLOCK ;


typedef struct _ATOM_INIT_REG_INDEX_FORMAT { USHORT usRegIndex ; UCHAR ucPreRegDataLength ; } ATOM_INIT_REG_INDEX_FORMAT ;


typedef struct _ATOM_INIT_REG_BLOCK { USHORT usRegIndexTblSize ; USHORT usRegDataBlkSize ; ATOM_INIT_REG_INDEX_FORMAT asRegIndexBuf [ 1 ] ; ATOM_MEMORY_SETTING_DATA_BLOCK asRegDataBuf [ 1 ] ; } ATOM_INIT_REG_BLOCK ;


typedef struct _ATOM_MC_INIT_PARAM_TABLE { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usAdjustARB_SEQDataOffset ; USHORT usMCInitMemTypeTblOffset ; USHORT usMCInitCommonTblOffset ; USHORT usMCInitPowerDownTblOffset ; ULONG ulARB_SEQDataBuf [ 32 ] ; ATOM_INIT_REG_BLOCK asMCInitMemType ; ATOM_INIT_REG_BLOCK asMCInitCommon ; } ATOM_MC_INIT_PARAM_TABLE ;


typedef struct _MCuCodeHeader { ULONG ulSignature ; UCHAR ucRevision ; UCHAR ucChecksum ; UCHAR ucReserved1 ; UCHAR ucReserved2 ; USHORT usParametersLength ; USHORT usUCodeLength ; USHORT usReserved1 ; USHORT usReserved2 ; } MCuCodeHeader ;


typedef struct _ATOM_VRAM_MODULE_V1 { ULONG ulReserved ; USHORT usEMRSValue ; USHORT usMRSValue ; USHORT usReserved ; UCHAR ucExtMemoryID ; UCHAR ucMemoryType ; UCHAR ucMemoryVenderID ; UCHAR ucMemoryDeviceCfg ; UCHAR ucRow ; UCHAR ucColumn ; UCHAR ucBank ; UCHAR ucRank ; UCHAR ucChannelNum ; UCHAR ucChannelConfig ; UCHAR ucDefaultMVDDQ_ID ; UCHAR ucDefaultMVDDC_ID ; UCHAR ucReserved [ 2 ] ; } ATOM_VRAM_MODULE_V1 ;


typedef struct _ATOM_VRAM_MODULE_V2 { ULONG ulReserved ; ULONG ulFlags ; ULONG ulEngineClock ; ULONG ulMemoryClock ; USHORT usEMRS2Value ; USHORT usEMRS3Value ; USHORT usEMRSValue ; USHORT usMRSValue ; USHORT usReserved ; UCHAR ucExtMemoryID ; UCHAR ucMemoryType ; UCHAR ucMemoryVenderID ; UCHAR ucMemoryDeviceCfg ; UCHAR ucRow ; UCHAR ucColumn ; UCHAR ucBank ; UCHAR ucRank ; UCHAR ucChannelNum ; UCHAR ucChannelConfig ; UCHAR ucDefaultMVDDQ_ID ; UCHAR ucDefaultMVDDC_ID ; UCHAR ucRefreshRateFactor ; UCHAR ucReserved [ 3 ] ; } ATOM_VRAM_MODULE_V2 ;


typedef struct _ATOM_MEMORY_TIMING_FORMAT { ULONG ulClkRange ; union { USHORT usMRS ; USHORT usDDR3_MR0 ; } ; union { USHORT usEMRS ; USHORT usDDR3_MR1 ; } ; UCHAR ucCL ; UCHAR ucWL ; UCHAR uctRAS ; UCHAR uctRC ; UCHAR uctRFC ; UCHAR uctRCDR ; UCHAR uctRCDW ; UCHAR uctRP ; UCHAR uctRRD ; UCHAR uctWR ; UCHAR uctWTR ; UCHAR uctPDIX ; UCHAR uctFAW ; UCHAR uctAOND ; union { struct { UCHAR ucflag ; UCHAR ucReserved ; } ; USHORT usDDR3_MR2 ; } ; } ATOM_MEMORY_TIMING_FORMAT ;


typedef struct _ATOM_MEMORY_TIMING_FORMAT_V1 { ULONG ulClkRange ; USHORT usMRS ; USHORT usEMRS ; UCHAR ucCL ; UCHAR ucWL ; UCHAR uctRAS ; UCHAR uctRC ; UCHAR uctRFC ; UCHAR uctRCDR ; UCHAR uctRCDW ; UCHAR uctRP ; UCHAR uctRRD ; UCHAR uctWR ; UCHAR uctWTR ; UCHAR uctPDIX ; UCHAR uctFAW ; UCHAR uctAOND ; UCHAR ucflag ; UCHAR uctCCDL ; UCHAR uctCRCRL ; UCHAR uctCRCWL ; UCHAR uctCKE ; UCHAR uctCKRSE ; UCHAR uctCKRSX ; UCHAR uctFAW32 ; UCHAR ucReserved1 ; UCHAR ucReserved2 ; UCHAR ucTerminator ; } ATOM_MEMORY_TIMING_FORMAT_V1 ;


typedef struct _ATOM_MEMORY_FORMAT { ULONG ulDllDisClock ; union { USHORT usEMRS2Value ; USHORT usDDR3_Reserved ; } ; union { USHORT usEMRS3Value ; USHORT usDDR3_MR3 ; } ; UCHAR ucMemoryType ; UCHAR ucMemoryVenderID ; UCHAR ucRow ; UCHAR ucColumn ; UCHAR ucBank ; UCHAR ucRank ; UCHAR ucBurstSize ; UCHAR ucDllDisBit ; UCHAR ucRefreshRateFactor ; UCHAR ucDensity ; UCHAR ucPreamble ; UCHAR ucMemAttrib ; ATOM_MEMORY_TIMING_FORMAT asMemTiming [ 5 ] ; } ATOM_MEMORY_FORMAT ;


typedef struct _ATOM_VRAM_MODULE_V3 { ULONG ulChannelMapCfg ; USHORT usSize ; USHORT usDefaultMVDDQ ; USHORT usDefaultMVDDC ; UCHAR ucExtMemoryID ; UCHAR ucChannelNum ; UCHAR ucChannelSize ; UCHAR ucVREFI ; UCHAR ucNPL_RT ; UCHAR ucFlag ; ATOM_MEMORY_FORMAT asMemory ; } ATOM_VRAM_MODULE_V3 ;


typedef struct _ATOM_VRAM_MODULE_V4 { ULONG ulChannelMapCfg ; USHORT usModuleSize ; USHORT usPrivateReserved ; USHORT usReserved ; UCHAR ucExtMemoryID ; UCHAR ucMemoryType ; UCHAR ucChannelNum ; UCHAR ucChannelWidth ; UCHAR ucDensity ; UCHAR ucFlag ; UCHAR ucMisc ; UCHAR ucVREFI ; UCHAR ucNPL_RT ; UCHAR ucPreamble ; UCHAR ucMemorySize ; UCHAR ucReserved [ 3 ] ; union { USHORT usEMRS2Value ; USHORT usDDR3_Reserved ; } ; union { USHORT usEMRS3Value ; USHORT usDDR3_MR3 ; } ; UCHAR ucMemoryVenderID ; UCHAR ucRefreshRateFactor ; UCHAR ucReserved2 [ 2 ] ; ATOM_MEMORY_TIMING_FORMAT asMemTiming [ 5 ] ; } ATOM_VRAM_MODULE_V4 ;


typedef struct _ATOM_VRAM_MODULE_V5 { ULONG ulChannelMapCfg ; USHORT usModuleSize ; USHORT usPrivateReserved ; USHORT usReserved ; UCHAR ucExtMemoryID ; UCHAR ucMemoryType ; UCHAR ucChannelNum ; UCHAR ucChannelWidth ; UCHAR ucDensity ; UCHAR ucFlag ; UCHAR ucMisc ; UCHAR ucVREFI ; UCHAR ucNPL_RT ; UCHAR ucPreamble ; UCHAR ucMemorySize ; UCHAR ucReserved [ 3 ] ; USHORT usEMRS2Value ; USHORT usEMRS3Value ; UCHAR ucMemoryVenderID ; UCHAR ucRefreshRateFactor ; UCHAR ucFIFODepth ; UCHAR ucCDR_Bandwidth ; ATOM_MEMORY_TIMING_FORMAT_V1 asMemTiming [ 5 ] ; } ATOM_VRAM_MODULE_V5 ;


typedef struct _ATOM_VRAM_INFO_V2 { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucNumOfVRAMModule ; ATOM_VRAM_MODULE_V3 aVramInfo [ 16 ] ; } ATOM_VRAM_INFO_V2 ;


typedef struct _ATOM_VRAM_INFO_V3 { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usMemAdjustTblOffset ; USHORT usMemClkPatchTblOffset ; USHORT usRerseved ; UCHAR aVID_PinsShift [ 9 ] ; UCHAR ucNumOfVRAMModule ; ATOM_VRAM_MODULE_V3 aVramInfo [ 16 ] ; ATOM_INIT_REG_BLOCK asMemPatch ; } ATOM_VRAM_INFO_V3 ;


typedef struct _ATOM_VRAM_INFO_V4 { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usMemAdjustTblOffset ; USHORT usMemClkPatchTblOffset ; USHORT usRerseved ; UCHAR ucMemDQ7_0ByteRemap ; ULONG ulMemDQ7_0BitRemap ; UCHAR ucReservde [ 4 ] ; UCHAR ucNumOfVRAMModule ; ATOM_VRAM_MODULE_V4 aVramInfo [ 16 ] ; ATOM_INIT_REG_BLOCK asMemPatch ; } ATOM_VRAM_INFO_V4 ;


typedef struct _ATOM_VRAM_GPIO_DETECTION_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR aVID_PinsShift [ 9 ] ; } ATOM_VRAM_GPIO_DETECTION_INFO ;


typedef struct _ATOM_MEMORY_TRAINING_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucTrainingLoop ; UCHAR ucReserved [ 3 ] ; ATOM_INIT_REG_BLOCK asMemTrainingSetting ; } ATOM_MEMORY_TRAINING_INFO ;


typedef struct SW_I2C_CNTL_DATA_PARAMETERS { UCHAR ucControl ; UCHAR ucData ; UCHAR ucSatus ; UCHAR ucTemp ; } SW_I2C_CNTL_DATA_PARAMETERS ;


typedef struct _SW_I2C_IO_DATA_PARAMETERS { USHORT GPIO_Info ; UCHAR ucAct ; UCHAR ucData ; } SW_I2C_IO_DATA_PARAMETERS ;


typedef struct _PTR_32_BIT_STRUCTURE { USHORT Offset16 ; USHORT Segment16 ; } PTR_32_BIT_STRUCTURE ;


typedef union _PTR_32_BIT_UNION { PTR_32_BIT_STRUCTURE SegmentOffset ; ULONG Ptr32_Bit ; } PTR_32_BIT_UNION ;


typedef struct _VBE_1_2_INFO_BLOCK_UPDATABLE { UCHAR VbeSignature [ 4 ] ; USHORT VbeVersion ; PTR_32_BIT_UNION OemStringPtr ; UCHAR Capabilities [ 4 ] ; PTR_32_BIT_UNION VideoModePtr ; USHORT TotalMemory ; } VBE_1_2_INFO_BLOCK_UPDATABLE ;


typedef struct _VBE_2_0_INFO_BLOCK_UPDATABLE { VBE_1_2_INFO_BLOCK_UPDATABLE CommonBlock ; USHORT OemSoftRev ; PTR_32_BIT_UNION OemVendorNamePtr ; PTR_32_BIT_UNION OemProductNamePtr ; PTR_32_BIT_UNION OemProductRevPtr ; } VBE_2_0_INFO_BLOCK_UPDATABLE ;


typedef union _VBE_VERSION_UNION { VBE_2_0_INFO_BLOCK_UPDATABLE VBE_2_0_InfoBlock ; VBE_1_2_INFO_BLOCK_UPDATABLE VBE_1_2_InfoBlock ; } VBE_VERSION_UNION ;


typedef struct _VBE_INFO_BLOCK { VBE_VERSION_UNION UpdatableVBE_Info ; UCHAR Reserved [ 222 ] ; UCHAR OemData [ 256 ] ; } VBE_INFO_BLOCK ;


typedef struct _VBE_FP_INFO { USHORT HSize ; USHORT VSize ; USHORT FPType ; UCHAR RedBPP ; UCHAR GreenBPP ; UCHAR BlueBPP ; UCHAR ReservedBPP ; ULONG RsvdOffScrnMemSize ; ULONG RsvdOffScrnMEmPtr ; UCHAR Reserved [ 14 ] ; } VBE_FP_INFO ;


typedef struct _VESA_MODE_INFO_BLOCK { USHORT ModeAttributes ; UCHAR WinAAttributes ; UCHAR WinBAttributes ; USHORT WinGranularity ; USHORT WinSize ; USHORT WinASegment ; USHORT WinBSegment ; ULONG WinFuncPtr ; USHORT BytesPerScanLine ; USHORT XResolution ; USHORT YResolution ; UCHAR XCharSize ; UCHAR YCharSize ; UCHAR NumberOfPlanes ; UCHAR BitsPerPixel ; UCHAR NumberOfBanks ; UCHAR MemoryModel ; UCHAR BankSize ; UCHAR NumberOfImagePages ; UCHAR ReservedForPageFunction ; UCHAR RedMaskSize ; UCHAR RedFieldPosition ; UCHAR GreenMaskSize ; UCHAR GreenFieldPosition ; UCHAR BlueMaskSize ; UCHAR BlueFieldPosition ; UCHAR RsvdMaskSize ; UCHAR RsvdFieldPosition ; UCHAR DirectColorModeInfo ; ULONG PhysBasePtr ; ULONG Reserved_1 ; USHORT Reserved_2 ; USHORT LinBytesPerScanLine ; UCHAR BnkNumberOfImagePages ; UCHAR LinNumberOfImagPages ; UCHAR LinRedMaskSize ; UCHAR LinRedFieldPosition ; UCHAR LinGreenMaskSize ; UCHAR LinGreenFieldPosition ; UCHAR LinBlueMaskSize ; UCHAR LinBlueFieldPosition ; UCHAR LinRsvdMaskSize ; UCHAR LinRsvdFieldPosition ; ULONG MaxPixelClock ; UCHAR Reserved ; } VESA_MODE_INFO_BLOCK ;


typedef struct _ASIC_TRANSMITTER_INFO { USHORT usTransmitterObjId ; USHORT usSupportDevice ; UCHAR ucTransmitterCmdTblId ; UCHAR ucConfig ; UCHAR ucEncoderID ; UCHAR ucOptionEncoderID ; UCHAR uc2ndEncoderID ; UCHAR ucReserved ; } ASIC_TRANSMITTER_INFO ;


typedef struct _ASIC_ENCODER_INFO { UCHAR ucEncoderID ; UCHAR ucEncoderConfig ; USHORT usEncoderCmdTblId ; } ASIC_ENCODER_INFO ;


typedef struct _ATOM_DISP_OUT_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT ptrTransmitterInfo ; USHORT ptrEncoderInfo ; ASIC_TRANSMITTER_INFO asTransmitterInfo [ 1 ] ; ASIC_ENCODER_INFO asEncoderInfo [ 1 ] ; } ATOM_DISP_OUT_INFO ;


typedef struct _ATOM_DISPLAY_DEVICE_PRIORITY_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT asDevicePriority [ 16 ] ; } ATOM_DISPLAY_DEVICE_PRIORITY_INFO ;


typedef struct _PROCESS_AUX_CHANNEL_TRANSACTION_PARAMETERS { USHORT lpAuxRequest ; USHORT lpDataOut ; UCHAR ucChannelID ; union { UCHAR ucReplyStatus ; UCHAR ucDelay ; } ; UCHAR ucDataOutLen ; UCHAR ucReserved ; } PROCESS_AUX_CHANNEL_TRANSACTION_PARAMETERS ;


typedef struct _DP_ENCODER_SERVICE_PARAMETERS { USHORT ucLinkClock ; union { UCHAR ucConfig ; UCHAR ucI2cId ; } ; UCHAR ucAction ; UCHAR ucStatus ; UCHAR ucLaneNum ; UCHAR ucReserved [ 2 ] ; } DP_ENCODER_SERVICE_PARAMETERS ;


typedef struct _PROCESS_I2C_CHANNEL_TRANSACTION_PARAMETERS { UCHAR ucI2CSpeed ; union { UCHAR ucRegIndex ; UCHAR ucStatus ; } ; USHORT lpI2CDataOut ; UCHAR ucFlag ; UCHAR ucTransBytes ; UCHAR ucSlaveAddr ; UCHAR ucLineNumber ; } PROCESS_I2C_CHANNEL_TRANSACTION_PARAMETERS ;


typedef struct _ATOM_DAC_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usMaxFrequency ; USHORT usReserved ; } ATOM_DAC_INFO ;


typedef struct _COMPASSIONATE_DATA { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucDAC1_BG_Adjustment ; UCHAR ucDAC1_DAC_Adjustment ; USHORT usDAC1_FORCE_Data ; UCHAR ucDAC2_CRT2_BG_Adjustment ; UCHAR ucDAC2_CRT2_DAC_Adjustment ; USHORT usDAC2_CRT2_FORCE_Data ; USHORT usDAC2_CRT2_MUX_RegisterIndex ; UCHAR ucDAC2_CRT2_MUX_RegisterInfo ; UCHAR ucDAC2_NTSC_BG_Adjustment ; UCHAR ucDAC2_NTSC_DAC_Adjustment ; USHORT usDAC2_TV1_FORCE_Data ; USHORT usDAC2_TV1_MUX_RegisterIndex ; UCHAR ucDAC2_TV1_MUX_RegisterInfo ; UCHAR ucDAC2_CV_BG_Adjustment ; UCHAR ucDAC2_CV_DAC_Adjustment ; USHORT usDAC2_CV_FORCE_Data ; USHORT usDAC2_CV_MUX_RegisterIndex ; UCHAR ucDAC2_CV_MUX_RegisterInfo ; UCHAR ucDAC2_PAL_BG_Adjustment ; UCHAR ucDAC2_PAL_DAC_Adjustment ; USHORT usDAC2_TV2_FORCE_Data ; } COMPASSIONATE_DATA ;


typedef struct _ATOM_CONNECTOR_INFO { UCHAR bfAssociatedDAC : 4 ; UCHAR bfConnectorType : 4 ; } ATOM_CONNECTOR_INFO ;


typedef union _ATOM_CONNECTOR_INFO_ACCESS { ATOM_CONNECTOR_INFO sbfAccess ; UCHAR ucAccess ; } ATOM_CONNECTOR_INFO_ACCESS ;


typedef struct _ATOM_CONNECTOR_INFO_I2C { ATOM_CONNECTOR_INFO_ACCESS sucConnectorInfo ; ATOM_I2C_ID_CONFIG_ACCESS sucI2cId ; } ATOM_CONNECTOR_INFO_I2C ;


typedef struct _ATOM_SUPPORTED_DEVICES_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usDeviceSupport ; ATOM_CONNECTOR_INFO_I2C asConnInfo [ ( 0x00000009 + 1 ) ] ; } ATOM_SUPPORTED_DEVICES_INFO ;


typedef struct _ATOM_CONNECTOR_INC_SRC_BITMAP { UCHAR ucIntSrcBitmap ; } ATOM_CONNECTOR_INC_SRC_BITMAP ;


typedef struct _ATOM_SUPPORTED_DEVICES_INFO_2 { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usDeviceSupport ; ATOM_CONNECTOR_INFO_I2C asConnInfo [ ( 0x00000009 + 1 ) ] ; ATOM_CONNECTOR_INC_SRC_BITMAP asIntSrcInfo [ ( 0x00000009 + 1 ) ] ; } ATOM_SUPPORTED_DEVICES_INFO_2 ;


typedef struct _ATOM_SUPPORTED_DEVICES_INFO_2d1 { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usDeviceSupport ; ATOM_CONNECTOR_INFO_I2C asConnInfo [ ( 0x0000000F + 1 ) ] ; ATOM_CONNECTOR_INC_SRC_BITMAP asIntSrcInfo [ ( 0x0000000F + 1 ) ] ; } ATOM_SUPPORTED_DEVICES_INFO_2d1 ;


typedef struct _ATOM_MISC_CONTROL_INFO { USHORT usFrequency ; UCHAR ucPLL_ChargePump ; UCHAR ucPLL_DutyCycle ; UCHAR ucPLL_VCO_Gain ; UCHAR ucPLL_VoltageSwing ; } ATOM_MISC_CONTROL_INFO ;


typedef struct _ATOM_TMDS_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usMaxFrequency ; ATOM_MISC_CONTROL_INFO asMiscInfo [ 4 ] ; } ATOM_TMDS_INFO ;


typedef struct _ATOM_ENCODER_ANALOG_ATTRIBUTE { UCHAR ucTVStandard ; UCHAR ucPadding [ 1 ] ; } ATOM_ENCODER_ANALOG_ATTRIBUTE ;


typedef struct _ATOM_ENCODER_DIGITAL_ATTRIBUTE { UCHAR ucAttribute ; UCHAR ucPadding [ 1 ] ; } ATOM_ENCODER_DIGITAL_ATTRIBUTE ;


typedef union _ATOM_ENCODER_ATTRIBUTE { ATOM_ENCODER_ANALOG_ATTRIBUTE sAlgAttrib ; ATOM_ENCODER_DIGITAL_ATTRIBUTE sDigAttrib ; } ATOM_ENCODER_ATTRIBUTE ;


typedef struct _DVO_ENCODER_CONTROL_PARAMETERS { USHORT usPixelClock ; USHORT usEncoderID ; UCHAR ucDeviceType ; UCHAR ucAction ; ATOM_ENCODER_ATTRIBUTE usDevAttr ; } DVO_ENCODER_CONTROL_PARAMETERS ;


typedef struct _DVO_ENCODER_CONTROL_PS_ALLOCATION { DVO_ENCODER_CONTROL_PARAMETERS sDVOEncoder ; WRITE_ONE_BYTE_HW_I2C_DATA_PARAMETERS sReserved ; } DVO_ENCODER_CONTROL_PS_ALLOCATION ;


typedef struct _ATOM_XTMDS_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; USHORT usSingleLinkMaxFrequency ; ATOM_I2C_ID_CONFIG_ACCESS sucI2cId ; UCHAR ucXtransimitterID ; UCHAR ucSupportedLink ; UCHAR ucSequnceAlterID ; UCHAR ucMasterAddress ; UCHAR ucSlaveAddress ; } ATOM_XTMDS_INFO ;


typedef struct _DFP_DPMS_STATUS_CHANGE_PARAMETERS { UCHAR ucEnable ; UCHAR ucDevice ; UCHAR ucPadding [ 2 ] ; } DFP_DPMS_STATUS_CHANGE_PARAMETERS ;


typedef struct _ATOM_POWERMODE_INFO { ULONG ulMiscInfo ; ULONG ulReserved1 ; ULONG ulReserved2 ; USHORT usEngineClock ; USHORT usMemoryClock ; UCHAR ucVoltageDropIndex ; UCHAR ucSelectedPanel_RefreshRate ; UCHAR ucMinTemperature ; UCHAR ucMaxTemperature ; UCHAR ucNumPciELanes ; } ATOM_POWERMODE_INFO ;


typedef struct _ATOM_POWERMODE_INFO_V2 { ULONG ulMiscInfo ; ULONG ulMiscInfo2 ; ULONG ulEngineClock ; ULONG ulMemoryClock ; UCHAR ucVoltageDropIndex ; UCHAR ucSelectedPanel_RefreshRate ; UCHAR ucMinTemperature ; UCHAR ucMaxTemperature ; UCHAR ucNumPciELanes ; } ATOM_POWERMODE_INFO_V2 ;


typedef struct _ATOM_POWERMODE_INFO_V3 { ULONG ulMiscInfo ; ULONG ulMiscInfo2 ; ULONG ulEngineClock ; ULONG ulMemoryClock ; UCHAR ucVoltageDropIndex ; UCHAR ucSelectedPanel_RefreshRate ; UCHAR ucMinTemperature ; UCHAR ucMaxTemperature ; UCHAR ucNumPciELanes ; UCHAR ucVDDCI_VoltageDropIndex ; } ATOM_POWERMODE_INFO_V3 ;


typedef struct _ATOM_POWERPLAY_INFO { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucOverdriveThermalController ; UCHAR ucOverdriveI2cLine ; UCHAR ucOverdriveIntBitmap ; UCHAR ucOverdriveControllerAddress ; UCHAR ucSizeOfPowerModeEntry ; UCHAR ucNumOfPowerModeEntries ; ATOM_POWERMODE_INFO asPowerPlayInfo [ 8 ] ; } ATOM_POWERPLAY_INFO ;


typedef struct _ATOM_POWERPLAY_INFO_V2 { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucOverdriveThermalController ; UCHAR ucOverdriveI2cLine ; UCHAR ucOverdriveIntBitmap ; UCHAR ucOverdriveControllerAddress ; UCHAR ucSizeOfPowerModeEntry ; UCHAR ucNumOfPowerModeEntries ; ATOM_POWERMODE_INFO_V2 asPowerPlayInfo [ 8 ] ; } ATOM_POWERPLAY_INFO_V2 ;


typedef struct _ATOM_POWERPLAY_INFO_V3 { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucOverdriveThermalController ; UCHAR ucOverdriveI2cLine ; UCHAR ucOverdriveIntBitmap ; UCHAR ucOverdriveControllerAddress ; UCHAR ucSizeOfPowerModeEntry ; UCHAR ucNumOfPowerModeEntries ; ATOM_POWERMODE_INFO_V3 asPowerPlayInfo [ 8 ] ; } ATOM_POWERPLAY_INFO_V3 ;


typedef struct _ATOM_PPLIB_THERMALCONTROLLER { UCHAR ucType ; UCHAR ucI2cLine ; UCHAR ucI2cAddress ; UCHAR ucFanParameters ; UCHAR ucFanMinRPM ; UCHAR ucFanMaxRPM ; UCHAR ucReserved ; UCHAR ucFlags ; } ATOM_PPLIB_THERMALCONTROLLER ;


typedef struct _ATOM_PPLIB_STATE { UCHAR ucNonClockStateIndex ; UCHAR ucClockStateIndices [ 1 ] ; } ATOM_PPLIB_STATE ;


typedef struct _ATOM_PPLIB_POWERPLAYTABLE { ATOM_COMMON_TABLE_HEADER sHeader ; UCHAR ucDataRevision ; UCHAR ucNumStates ; UCHAR ucStateEntrySize ; UCHAR ucClockInfoSize ; UCHAR ucNonClockSize ; USHORT usStateArrayOffset ; USHORT usClockInfoArrayOffset ; USHORT usNonClockInfoArrayOffset ; USHORT usBackbiasTime ; USHORT usVoltageTime ; USHORT usTableSize ; ULONG ulPlatformCaps ; ATOM_PPLIB_THERMALCONTROLLER sThermalController ; USHORT usBootClockInfoOffset ; USHORT usBootNonClockInfoOffset ; } ATOM_PPLIB_POWERPLAYTABLE ;


typedef struct _ATOM_PPLIB_NONCLOCK_INFO { USHORT usClassification ; UCHAR ucMinTemperature ; UCHAR ucMaxTemperature ; ULONG ulCapsAndSettings ; UCHAR ucRequiredPower ; UCHAR ucUnused1 [ 3 ] ; } ATOM_PPLIB_NONCLOCK_INFO ;


typedef struct _ATOM_PPLIB_R600_CLOCK_INFO { USHORT usEngineClockLow ; UCHAR ucEngineClockHigh ; USHORT usMemoryClockLow ; UCHAR ucMemoryClockHigh ; USHORT usVDDC ; USHORT usUnused1 ; USHORT usUnused2 ; ULONG ulFlags ; } ATOM_PPLIB_R600_CLOCK_INFO ;


typedef struct _ATOM_PPLIB_RS780_CLOCK_INFO { USHORT usLowEngineClockLow ; UCHAR ucLowEngineClockHigh ; USHORT usHighEngineClockLow ; UCHAR ucHighEngineClockHigh ; USHORT usMemoryClockLow ; UCHAR ucMemoryClockHigh ; UCHAR ucPadding ; USHORT usVDDC ; UCHAR ucMaxHTLinkWidth ; UCHAR ucMinHTLinkWidth ; USHORT usHTLinkFreq ; ULONG ulFlags ; } ATOM_PPLIB_RS780_CLOCK_INFO ;

void radeon_surface_init ( struct radeon_device * rdev ) ;

void radeon_scratch_init ( struct radeon_device * rdev ) ;

int radeon_scratch_get ( struct radeon_device * rdev , uint32_t * reg ) ;

void radeon_scratch_free ( struct radeon_device * rdev , uint32_t reg ) ;

int radeon_mc_setup ( struct radeon_device * rdev ) ;

bool radeon_card_posted ( struct radeon_device * rdev ) ;

bool radeon_boot_test_post_card ( struct radeon_device * rdev ) ;

int radeon_dummy_page_init ( struct radeon_device * rdev ) ;

void radeon_dummy_page_fini ( struct radeon_device * rdev ) ;

uint32_t radeon_invalid_rreg ( struct radeon_device * rdev , uint32_t reg ) ;

void radeon_invalid_wreg ( struct radeon_device * rdev , uint32_t reg , uint32_t v ) ;

void radeon_register_accessor_init ( struct radeon_device * rdev ) ;

int radeon_asic_init ( struct radeon_device * rdev ) ;

int radeon_clocks_init ( struct radeon_device * rdev ) ;

void radeon_clocks_fini ( struct radeon_device * rdev ) ;

int radeon_atombios_init ( struct radeon_device * rdev ) ;

void radeon_atombios_fini ( struct radeon_device * rdev ) ;

int radeon_combios_init ( struct radeon_device * rdev ) ;

void radeon_combios_fini ( struct radeon_device * rdev ) ;

void radeon_agp_disable ( struct radeon_device * rdev ) ;

void radeon_check_arguments ( struct radeon_device * rdev ) ;

int radeon_device_init ( struct radeon_device * rdev , struct drm_device * ddev , struct pci_dev * pdev , uint32_t flags ) ;

void radeon_device_fini ( struct radeon_device * rdev ) ;

int radeon_suspend_kms ( struct drm_device * dev , pm_message_t state ) ;

int radeon_resume_kms ( struct drm_device * dev ) ;

struct radeon_debugfs { struct drm_info_list * files ; unsigned num_files ; } ;

int radeon_debugfs_add_files ( struct radeon_device * rdev , struct drm_info_list * files , unsigned nfiles ) ;

int radeon_debugfs_init ( struct drm_minor * minor ) ;

void radeon_debugfs_cleanup ( struct drm_minor * minor ) ;

int radeon_driver_unload_kms ( struct drm_device * dev ) ;

int radeon_driver_load_kms ( struct drm_device * dev , unsigned long flags ) ;

int radeon_info_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_driver_firstopen_kms ( struct drm_device * dev ) ;

void radeon_driver_lastclose_kms ( struct drm_device * dev ) ;

int radeon_driver_open_kms ( struct drm_device * dev , struct drm_file * file_priv ) ;

void radeon_driver_postclose_kms ( struct drm_device * dev , struct drm_file * file_priv ) ;

void radeon_driver_preclose_kms ( struct drm_device * dev , struct drm_file * file_priv ) ;

u32 radeon_get_vblank_counter_kms ( struct drm_device * dev , int crtc ) ;

int radeon_enable_vblank_kms ( struct drm_device * dev , int crtc ) ;

void radeon_disable_vblank_kms ( struct drm_device * dev , int crtc ) ;

int radeon_dma_ioctl_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_init_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_start_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_stop_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_reset_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_idle_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_resume_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_engine_reset_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_fullscreen_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_swap_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_clear_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_vertex_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_indices_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_texture_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_stipple_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_indirect_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_vertex2_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_cmdbuf_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_getparam_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_flip_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_mem_alloc_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_mem_free_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_mem_init_heap_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_irq_emit_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_irq_wait_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_cp_setparam_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_surface_alloc_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int radeon_surface_free_kms ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

union atom_supported_devices { struct _ATOM_SUPPORTED_DEVICES_INFO info ; struct _ATOM_SUPPORTED_DEVICES_INFO_2 info_2 ; struct _ATOM_SUPPORTED_DEVICES_INFO_2d1 info_2d1 ; } ;

bool radeon_get_atom_connector_info_from_object_table ( struct drm_device * dev ) ;

struct bios_connector { bool valid ; uint16_t line_mux ; uint16_t devices ; int connector_type ; struct radeon_i2c_bus_rec ddc_bus ; struct radeon_hpd hpd ; } ;

bool radeon_get_atom_connector_info_from_supported_devices_table ( struct drm_device * dev ) ;

union firmware_info { ATOM_FIRMWARE_INFO info ; ATOM_FIRMWARE_INFO_V1_2 info_12 ; ATOM_FIRMWARE_INFO_V1_3 info_13 ; ATOM_FIRMWARE_INFO_V1_4 info_14 ; } ;

bool radeon_atom_get_clock_info ( struct drm_device * dev ) ;

union igp_info { struct _ATOM_INTEGRATED_SYSTEM_INFO info ; struct _ATOM_INTEGRATED_SYSTEM_INFO_V2 info_2 ; } ;

bool radeon_atombios_sideport_present ( struct radeon_device * rdev ) ;

bool radeon_atombios_get_tmds_info ( struct radeon_encoder * encoder , struct radeon_encoder_int_tmds * tmds ) ;

union lvds_info { struct _ATOM_LVDS_INFO info ; struct _ATOM_LVDS_INFO_V12 info_12 ; } ;

struct radeon_encoder_atom_dig * radeon_atombios_get_lvds_info ( struct radeon_encoder * encoder ) ;

struct radeon_encoder_primary_dac * radeon_atombios_get_primary_dac_info ( struct radeon_encoder * encoder ) ;

bool radeon_atom_get_tv_timings ( struct radeon_device * rdev , int index , struct drm_display_mode * mode ) ;

enum radeon_tv_std radeon_atombios_get_tv_info ( struct radeon_device * rdev ) ;

struct radeon_encoder_tv_dac * radeon_atombios_get_tv_dac_info ( struct radeon_encoder * encoder ) ;

void radeon_atom_set_clock_gating ( struct radeon_device * rdev , int enable ) ;

void radeon_atom_static_pwrmgt_setup ( struct radeon_device * rdev , int enable ) ;

uint32_t radeon_atom_get_engine_clock ( struct radeon_device * rdev ) ;

uint32_t radeon_atom_get_memory_clock ( struct radeon_device * rdev ) ;

void radeon_atom_set_engine_clock ( struct radeon_device * rdev , uint32_t eng_clock ) ;

void radeon_atom_set_memory_clock ( struct radeon_device * rdev , uint32_t mem_clock ) ;

void radeon_atom_initialize_bios_scratch_regs ( struct drm_device * dev ) ;

void radeon_save_bios_scratch_regs ( struct radeon_device * rdev ) ;

void radeon_restore_bios_scratch_regs ( struct radeon_device * rdev ) ;

void radeon_atom_output_lock ( struct drm_encoder * encoder , bool lock ) ;

void radeon_atombios_connected_scratch_regs ( struct drm_connector * connector , struct drm_encoder * encoder , bool connected ) ;

void radeon_atombios_encoder_crtc_scratch_regs ( struct drm_encoder * encoder , int crtc ) ;

void radeon_atombios_encoder_dpms_scratch_regs ( struct drm_encoder * encoder , bool on ) ;

struct radeon_agpmode_quirk { u32 hostbridge_vendor ; u32 hostbridge_device ; u32 chip_vendor ; u32 chip_device ; u32 subsys_vendor ; u32 subsys_device ; u32 default_mode ; } ;

int radeon_agp_init ( struct radeon_device * rdev ) ;

void radeon_agp_resume ( struct radeon_device * rdev ) ;

void radeon_agp_fini ( struct radeon_device * rdev ) ;

void atombios_crtc_dpms ( struct drm_crtc * crtc , int mode ) ;

union adjust_pixel_clock { ADJUST_DISPLAY_PLL_PARAMETERS v1 ; } ;

union set_pixel_clock { SET_PIXEL_CLOCK_PS_ALLOCATION base ; PIXEL_CLOCK_PARAMETERS v1 ; PIXEL_CLOCK_PARAMETERS_V2 v2 ; PIXEL_CLOCK_PARAMETERS_V3 v3 ; } ;

void atombios_crtc_set_pll ( struct drm_crtc * crtc , struct drm_display_mode * mode ) ;

int atombios_crtc_set_base ( struct drm_crtc * crtc , int x , int y , struct drm_framebuffer * old_fb ) ;

int atombios_crtc_mode_set ( struct drm_crtc * crtc , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode , int x , int y , struct drm_framebuffer * old_fb ) ;

void radeon_atombios_init_crtc ( struct drm_device * dev , struct radeon_crtc * radeon_crtc ) ;

enum radeon_combios_table_offset { COMBIOS_ASIC_INIT_1_TABLE , COMBIOS_BIOS_SUPPORT_TABLE , COMBIOS_DAC_PROGRAMMING_TABLE , COMBIOS_MAX_COLOR_DEPTH_TABLE , COMBIOS_CRTC_INFO_TABLE , COMBIOS_PLL_INFO_TABLE , COMBIOS_TV_INFO_TABLE , COMBIOS_DFP_INFO_TABLE , COMBIOS_HW_CONFIG_INFO_TABLE , COMBIOS_MULTIMEDIA_INFO_TABLE , COMBIOS_TV_STD_PATCH_TABLE , COMBIOS_LCD_INFO_TABLE , COMBIOS_MOBILE_INFO_TABLE , COMBIOS_PLL_INIT_TABLE , COMBIOS_MEM_CONFIG_TABLE , COMBIOS_SAVE_MASK_TABLE , COMBIOS_HARDCODED_EDID_TABLE , COMBIOS_ASIC_INIT_2_TABLE , COMBIOS_CONNECTOR_INFO_TABLE , COMBIOS_DYN_CLK_1_TABLE , COMBIOS_RESERVED_MEM_TABLE , COMBIOS_EXT_TMDS_INFO_TABLE , COMBIOS_MEM_CLK_INFO_TABLE , COMBIOS_EXT_DAC_INFO_TABLE , COMBIOS_MISC_INFO_TABLE , COMBIOS_CRT_INFO_TABLE , COMBIOS_INTEGRATED_SYSTEM_INFO_TABLE , COMBIOS_COMPONENT_VIDEO_INFO_TABLE , COMBIOS_FAN_SPEED_INFO_TABLE , COMBIOS_OVERDRIVE_INFO_TABLE , COMBIOS_OEM_INFO_TABLE , COMBIOS_DYN_CLK_2_TABLE , COMBIOS_POWER_CONNECTOR_INFO_TABLE , COMBIOS_I2C_INFO_TABLE , COMBIOS_ASIC_INIT_3_TABLE , COMBIOS_ASIC_INIT_4_TABLE , COMBIOS_DETECTED_MEM_TABLE , COMBIOS_ASIC_INIT_5_TABLE , COMBIOS_RAM_RESET_TABLE , COMBIOS_POWERPLAY_INFO_TABLE , COMBIOS_GPIO_INFO_TABLE , COMBIOS_LCD_DDC_INFO_TABLE , COMBIOS_TMDS_POWER_TABLE , COMBIOS_TMDS_POWER_ON_TABLE , COMBIOS_TMDS_POWER_OFF_TABLE , } ;

enum radeon_combios_ddc { DDC_NONE_DETECTED , DDC_MONID , DDC_DVI , DDC_VGA , DDC_CRT2 , DDC_LCD , DDC_GPIO , } ;

enum radeon_combios_connector { CONNECTOR_NONE_LEGACY , CONNECTOR_PROPRIETARY_LEGACY , CONNECTOR_CRT_LEGACY , CONNECTOR_DVI_I_LEGACY , CONNECTOR_DVI_D_LEGACY , CONNECTOR_CTV_LEGACY , CONNECTOR_STV_LEGACY , CONNECTOR_UNSUPPORTED_LEGACY } ;

bool radeon_combios_get_clock_info ( struct drm_device * dev ) ;

bool radeon_combios_sideport_present ( struct radeon_device * rdev ) ;

struct radeon_encoder_primary_dac * radeon_combios_get_primary_dac_info ( struct radeon_encoder * encoder ) ;

enum radeon_tv_std radeon_combios_get_tv_info ( struct radeon_device * rdev ) ;

struct radeon_encoder_tv_dac * radeon_combios_get_tv_dac_info ( struct radeon_encoder * encoder ) ;

struct radeon_encoder_lvds * radeon_combios_get_lvds_info ( struct radeon_encoder * encoder ) ;

bool radeon_legacy_get_tmds_info_from_table ( struct radeon_encoder * encoder , struct radeon_encoder_int_tmds * tmds ) ;

bool radeon_legacy_get_tmds_info_from_combios ( struct radeon_encoder * encoder , struct radeon_encoder_int_tmds * tmds ) ;

bool radeon_legacy_get_ext_tmds_info_from_table ( struct radeon_encoder * encoder , struct radeon_encoder_ext_tmds * tmds ) ;

bool radeon_legacy_get_ext_tmds_info_from_combios ( struct radeon_encoder * encoder , struct radeon_encoder_ext_tmds * tmds ) ;

bool radeon_get_legacy_connector_info_from_table ( struct drm_device * dev ) ;

bool radeon_get_legacy_connector_info_from_bios ( struct drm_device * dev ) ;

void radeon_external_tmds_setup ( struct drm_encoder * encoder ) ;

bool radeon_combios_external_tmds_setup ( struct drm_encoder * encoder ) ;

void radeon_combios_dyn_clk_setup ( struct drm_device * dev , int enable ) ;

void radeon_combios_asic_init ( struct drm_device * dev ) ;

void radeon_combios_initialize_bios_scratch_regs ( struct drm_device * dev ) ;

void radeon_combios_output_lock ( struct drm_encoder * encoder , bool lock ) ;

void radeon_combios_connected_scratch_regs ( struct drm_connector * connector , struct drm_encoder * encoder , bool connected ) ;

void radeon_combios_encoder_crtc_scratch_regs ( struct drm_encoder * encoder , int crtc ) ;

void radeon_combios_encoder_dpms_scratch_regs ( struct drm_encoder * encoder , bool on ) ;

typedef struct { struct atom_context * ctx ; uint32_t * ps , * ws ; int ps_shift ; uint16_t start ; } atom_exec_context ;

void atom_execute_table ( struct atom_context * ctx , int index , uint32_t * params ) ;

struct atom_context * atom_parse ( struct card_info * card , void * bios ) ;

int atom_asic_init ( struct atom_context * ctx ) ;

void atom_destroy ( struct atom_context * ctx ) ;

void atom_parse_data_header ( struct atom_context * ctx , int index , uint16_t * size , uint8_t * frev , uint8_t * crev , uint16_t * data_start ) ;

void atom_parse_cmd_header ( struct atom_context * ctx , int index , uint8_t * frev , uint8_t * crev ) ;

int atom_allocate_fb_scratch ( struct atom_context * ctx ) ;

int radeon_fence_emit ( struct radeon_device * rdev , struct radeon_fence * fence ) ;

int radeon_fence_create ( struct radeon_device * rdev , struct radeon_fence * * fence ) ;

bool radeon_fence_signaled ( struct radeon_fence * fence ) ;

int radeon_fence_wait ( struct radeon_fence * fence , bool intr ) ;

int radeon_fence_wait_next ( struct radeon_device * rdev ) ;

int radeon_fence_wait_last ( struct radeon_device * rdev ) ;

struct radeon_fence * radeon_fence_ref ( struct radeon_fence * fence ) ;

void radeon_fence_unref ( struct radeon_fence * * fence ) ;

void radeon_fence_process ( struct radeon_device * rdev ) ;

int radeon_fence_driver_init ( struct radeon_device * rdev ) ;

void radeon_fence_driver_fini ( struct radeon_device * rdev ) ;

int radeon_debugfs_fence_init ( struct radeon_device * rdev ) ;

int radeon_ttm_init ( struct radeon_device * rdev ) ;

void radeon_ttm_fini ( struct radeon_device * rdev ) ;

int radeon_mmap ( struct file * filp , struct vm_area_struct * vma ) ;

struct radeon_ttm_backend { struct ttm_backend backend ; struct radeon_device * rdev ; unsigned long num_pages ; struct page * * pages ; struct page * dummy_read_page ; bool populated ; bool bound ; unsigned offset ; } ;

struct ttm_backend * radeon_ttm_backend_create ( struct radeon_device * rdev ) ;

bool radeon_ttm_bo_is_radeon_bo ( struct ttm_buffer_object * bo ) ;

void radeon_ttm_placement_from_domain ( struct radeon_bo * rbo , u32 domain ) ;

int radeon_bo_create ( struct radeon_device * rdev , struct drm_gem_object * gobj , unsigned long size , bool kernel , u32 domain , struct radeon_bo * * bo_ptr ) ;

int radeon_bo_kmap ( struct radeon_bo * bo , void * * ptr ) ;

void radeon_bo_kunmap ( struct radeon_bo * bo ) ;

void radeon_bo_unref ( struct radeon_bo * * bo ) ;

int radeon_bo_pin ( struct radeon_bo * bo , u32 domain , u64 * gpu_addr ) ;

int radeon_bo_unpin ( struct radeon_bo * bo ) ;

int radeon_bo_evict_vram ( struct radeon_device * rdev ) ;

void radeon_bo_force_delete ( struct radeon_device * rdev ) ;

int radeon_bo_init ( struct radeon_device * rdev ) ;

void radeon_bo_fini ( struct radeon_device * rdev ) ;

void radeon_bo_list_add_object ( struct radeon_bo_list * lobj , struct list_head * head ) ;

int radeon_bo_list_reserve ( struct list_head * head ) ;

void radeon_bo_list_unreserve ( struct list_head * head ) ;

int radeon_bo_list_validate ( struct list_head * head ) ;

void radeon_bo_list_fence ( struct list_head * head , void * fence ) ;

int radeon_bo_fbdev_mmap ( struct radeon_bo * bo , struct vm_area_struct * vma ) ;

int radeon_bo_get_surface_reg ( struct radeon_bo * bo ) ;

int radeon_bo_set_tiling_flags ( struct radeon_bo * bo , uint32_t tiling_flags , uint32_t pitch ) ;

void radeon_bo_get_tiling_flags ( struct radeon_bo * bo , uint32_t * tiling_flags , uint32_t * pitch ) ;

int radeon_bo_check_tiling ( struct radeon_bo * bo , bool has_moved , bool force_drop ) ;

void radeon_bo_move_notify ( struct ttm_buffer_object * bo , struct ttm_mem_reg * mem ) ;

void radeon_bo_fault_reserve_notify ( struct ttm_buffer_object * bo ) ;

int radeon_gart_table_ram_alloc ( struct radeon_device * rdev ) ;

void radeon_gart_table_ram_free ( struct radeon_device * rdev ) ;

int radeon_gart_table_vram_alloc ( struct radeon_device * rdev ) ;

int radeon_gart_table_vram_pin ( struct radeon_device * rdev ) ;

void radeon_gart_table_vram_free ( struct radeon_device * rdev ) ;

void radeon_gart_unbind ( struct radeon_device * rdev , unsigned offset , int pages ) ;

int radeon_gart_bind ( struct radeon_device * rdev , unsigned offset , int pages , struct page * * pagelist ) ;

int radeon_gart_init ( struct radeon_device * rdev ) ;

void radeon_gart_fini ( struct radeon_device * rdev ) ;

void radeon_restore_common_regs ( struct drm_device * dev ) ;

void radeon_crtc_dpms ( struct drm_crtc * crtc , int mode ) ;

int radeon_crtc_set_base ( struct drm_crtc * crtc , int x , int y , struct drm_framebuffer * old_fb ) ;

void radeon_legacy_init_crtc ( struct drm_device * dev , struct radeon_crtc * radeon_crtc ) ;

void radeon_add_legacy_encoder ( struct drm_device * dev , uint32_t encoder_id , uint32_t supported_device ) ;

void radeon_connector_hotplug ( struct drm_connector * connector ) ;

struct drm_encoder * radeon_find_encoder ( struct drm_connector * connector , int encoder_type ) ;

struct drm_encoder * radeon_best_single_encoder ( struct drm_connector * connector ) ;

int radeon_connector_set_property ( struct drm_connector * connector , struct drm_property * property , uint64_t val ) ;

struct drm_encoder * radeon_dvi_encoder ( struct drm_connector * connector ) ;

void radeon_add_atom_connector ( struct drm_device * dev , uint32_t connector_id , uint32_t supported_device , int connector_type , struct radeon_i2c_bus_rec * i2c_bus , bool linkb , uint32_t igp_lane_info , uint16_t connector_object_id , struct radeon_hpd * hpd ) ;

void radeon_add_legacy_connector ( struct drm_device * dev , uint32_t connector_id , uint32_t supported_device , int connector_type , struct radeon_i2c_bus_rec * i2c_bus , uint16_t connector_object_id , struct radeon_hpd * hpd ) ;

void radeon_setup_encoder_clones ( struct drm_device * dev ) ;

uint32_t radeon_get_encoder_id ( struct drm_device * dev , uint32_t supported_device , uint8_t dac ) ;

void radeon_link_encoder_connector ( struct drm_device * dev ) ;

void radeon_encoder_set_active_device ( struct drm_encoder * encoder ) ;

void atombios_external_tmds_setup ( struct drm_encoder * encoder , int action ) ;

union lvds_encoder_control { LVDS_ENCODER_CONTROL_PARAMETERS v1 ; LVDS_ENCODER_CONTROL_PARAMETERS_V2 v2 ; } ;

void atombios_digital_setup ( struct drm_encoder * encoder , int action ) ;

int atombios_get_encoder_mode ( struct drm_encoder * encoder ) ;

union dig_transmitter_control { DIG_TRANSMITTER_CONTROL_PARAMETERS v1 ; DIG_TRANSMITTER_CONTROL_PARAMETERS_V2 v2 ; } ;

void atombios_dig_transmitter_setup ( struct drm_encoder * encoder , int action , uint8_t lane_num , uint8_t lane_set ) ;

union crtc_sourc_param { SELECT_CRTC_SOURCE_PARAMETERS v1 ; SELECT_CRTC_SOURCE_PARAMETERS_V2 v2 ; } ;

void radeon_enc_destroy ( struct drm_encoder * encoder ) ;

struct radeon_encoder_atom_dac * radeon_atombios_set_dac_info ( struct radeon_encoder * radeon_encoder ) ;

struct radeon_encoder_atom_dig * radeon_atombios_set_dig_info ( struct radeon_encoder * radeon_encoder ) ;

void radeon_add_atom_encoder ( struct drm_device * dev , uint32_t encoder_id , uint32_t supported_device ) ;

void radeon_crtc_load_lut ( struct drm_crtc * crtc ) ;

void radeon_crtc_fb_gamma_set ( struct drm_crtc * crtc , u16 red , u16 green , u16 blue , int regno ) ;

void radeon_crtc_fb_gamma_get ( struct drm_crtc * crtc , u16 * red , u16 * green , u16 * blue , int regno ) ;

int radeon_ddc_get_modes ( struct radeon_connector * radeon_connector ) ;

void radeon_compute_pll ( struct radeon_pll * pll , uint64_t freq , uint32_t * dot_clock_p , uint32_t * fb_div_p , uint32_t * frac_fb_div_p , uint32_t * ref_div_p , uint32_t * post_div_p ) ;

struct drm_framebuffer * radeon_framebuffer_create ( struct drm_device * dev , struct drm_mode_fb_cmd * mode_cmd , struct drm_gem_object * obj ) ;

struct drm_prop_enum_list { int type ; char * name ; } ;

int radeon_modeset_init ( struct radeon_device * rdev ) ;

void radeon_modeset_fini ( struct radeon_device * rdev ) ;

bool radeon_crtc_scaling_mode_fixup ( struct drm_crtc * crtc , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ;

int radeon_crtc_cursor_set ( struct drm_crtc * crtc , struct drm_file * file_priv , uint32_t handle , uint32_t width , uint32_t height ) ;

int radeon_crtc_cursor_move ( struct drm_crtc * crtc , int x , int y ) ;

bool radeon_ddc_probe ( struct radeon_connector * radeon_connector ) ;

void radeon_i2c_do_lock ( struct radeon_i2c_chan * i2c , int lock_state ) ;

struct radeon_i2c_chan * radeon_i2c_create ( struct drm_device * dev , struct radeon_i2c_bus_rec * rec , const char * name ) ;

struct radeon_i2c_chan * radeon_i2c_create_dp ( struct drm_device * dev , struct radeon_i2c_bus_rec * rec , const char * name ) ;

void radeon_i2c_destroy ( struct radeon_i2c_chan * i2c ) ;

struct drm_encoder * radeon_best_encoder ( struct drm_connector * connector ) ;

void radeon_i2c_sw_get_byte ( struct radeon_i2c_chan * i2c_bus , u8 slave_addr , u8 addr , u8 * val ) ;

void radeon_i2c_sw_put_byte ( struct radeon_i2c_chan * i2c_bus , u8 slave_addr , u8 addr , u8 val ) ;

uint32_t radeon_legacy_get_engine_clock ( struct radeon_device * rdev ) ;

uint32_t radeon_legacy_get_memory_clock ( struct radeon_device * rdev ) ;

void radeon_get_clock_info ( struct drm_device * dev ) ;

void radeon_legacy_set_engine_clock ( struct radeon_device * rdev , uint32_t eng_clock ) ;

void radeon_legacy_set_clock_gating ( struct radeon_device * rdev , int enable ) ;

int radeon_static_clocks_init ( struct drm_device * dev ) ;

struct radeon_fb_device { struct drm_fb_helper helper ; struct radeon_framebuffer * rfb ; struct radeon_device * rdev ; } ;

int radeonfb_resize ( struct drm_device * dev , struct drm_crtc * crtc ) ;

int radeonfb_create ( struct drm_device * dev , uint32_t fb_width , uint32_t fb_height , uint32_t surface_width , uint32_t surface_height , uint32_t surface_depth , uint32_t surface_bpp , struct drm_framebuffer * * fb_p ) ;

int radeon_parse_options ( char * options ) ;

int radeonfb_probe ( struct drm_device * dev ) ;

int radeonfb_remove ( struct drm_device * dev , struct drm_framebuffer * fb ) ;

int radeon_gem_object_init ( struct drm_gem_object * obj ) ;

void radeon_gem_object_free ( struct drm_gem_object * gobj ) ;

int radeon_gem_object_create ( struct radeon_device * rdev , int size , int alignment , int initial_domain , bool discardable , bool kernel , struct drm_gem_object * * obj ) ;

int radeon_gem_object_pin ( struct drm_gem_object * obj , uint32_t pin_domain , uint64_t * gpu_addr ) ;

void radeon_gem_object_unpin ( struct drm_gem_object * obj ) ;

int radeon_gem_set_domain ( struct drm_gem_object * gobj , uint32_t rdomain , uint32_t wdomain ) ;

int radeon_gem_init ( struct radeon_device * rdev ) ;

void radeon_gem_fini ( struct radeon_device * rdev ) ;

int radeon_gem_info_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_gem_pread_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_gem_pwrite_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_gem_create_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_gem_set_domain_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_gem_mmap_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_gem_busy_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_gem_wait_idle_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_gem_set_tiling_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_gem_get_tiling_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_ib_get ( struct radeon_device * rdev , struct radeon_ib * * ib ) ;

void radeon_ib_free ( struct radeon_device * rdev , struct radeon_ib * * ib ) ;

int radeon_ib_schedule ( struct radeon_device * rdev , struct radeon_ib * ib ) ;

int radeon_ib_pool_init ( struct radeon_device * rdev ) ;

void radeon_ib_pool_fini ( struct radeon_device * rdev ) ;

void radeon_ring_free_size ( struct radeon_device * rdev ) ;

int radeon_ring_lock ( struct radeon_device * rdev , unsigned ndw ) ;

void radeon_ring_unlock_commit ( struct radeon_device * rdev ) ;

void radeon_ring_unlock_undo ( struct radeon_device * rdev ) ;

int radeon_ring_init ( struct radeon_device * rdev , unsigned ring_size ) ;

void radeon_ring_fini ( struct radeon_device * rdev ) ;

int radeon_debugfs_ib_init ( struct radeon_device * rdev ) ;

irqreturn_t radeon_driver_irq_handler_kms ( int irq , void * arg ) ;

void radeon_driver_irq_preinstall_kms ( struct drm_device * dev ) ;

int radeon_driver_irq_postinstall_kms ( struct drm_device * dev ) ;

void radeon_driver_irq_uninstall_kms ( struct drm_device * dev ) ;

int radeon_irq_kms_init ( struct radeon_device * rdev ) ;

void radeon_irq_kms_fini ( struct radeon_device * rdev ) ;

void radeon_irq_kms_sw_irq_get ( struct radeon_device * rdev ) ;

void radeon_irq_kms_sw_irq_put ( struct radeon_device * rdev ) ;

int radeon_cs_parser_relocs ( struct radeon_cs_parser * p ) ;

int radeon_cs_parser_init ( struct radeon_cs_parser * p , void * data ) ;

int radeon_cs_ioctl ( struct drm_device * dev , void * data , struct drm_file * filp ) ;

int radeon_cs_finish_pages ( struct radeon_cs_parser * p ) ;

int radeon_cs_update_pages ( struct radeon_cs_parser * p , int pg_idx ) ;

bool radeon_get_bios ( struct radeon_device * rdev ) ;

void radeon_benchmark_move ( struct radeon_device * rdev , unsigned bsize , unsigned sdomain , unsigned ddomain ) ;

void radeon_benchmark ( struct radeon_device * rdev ) ;

struct offset { struct list_head list ; unsigned offset ; } ;

struct table { struct list_head offsets ; unsigned offset_max ; unsigned nentry ; unsigned * table ; char * gpu_prefix ; } ;

struct r100_cs_track_cb { struct radeon_bo * robj ; unsigned pitch ; unsigned cpp ; unsigned offset ; } ;

struct r100_cs_track_array { struct radeon_bo * robj ; unsigned esize ; } ;

struct r100_cs_cube_info { struct radeon_bo * robj ; unsigned offset ; unsigned width ; unsigned height ; } ;

struct r100_cs_track_texture { struct radeon_bo * robj ; struct r100_cs_cube_info cube_info [ 5 ] ; unsigned pitch ; unsigned width ; unsigned height ; unsigned num_levels ; unsigned cpp ; unsigned tex_coord_type ; unsigned txdepth ; unsigned width_11 ; unsigned height_11 ; bool use_pitch ; bool enabled ; bool roundup_w ; bool roundup_h ; unsigned compress_format ; } ;

struct r100_cs_track_limits { unsigned num_cb ; unsigned num_texture ; unsigned max_levels ; } ;

struct r100_cs_track { struct radeon_device * rdev ; unsigned num_cb ; unsigned num_texture ; unsigned maxy ; unsigned vtx_size ; unsigned vap_vf_cntl ; unsigned immd_dwords ; unsigned num_arrays ; unsigned max_indx ; unsigned color_channel_mask ; struct r100_cs_track_array arrays [ 11 ] ; struct r100_cs_track_cb cb [ 4 ] ; struct r100_cs_track_cb zb ; struct r100_cs_track_texture textures [ 16 ] ; bool z_enabled ; bool separate_cube ; bool fastfill ; bool blend_read_enable ; } ;

bool r100_hpd_sense ( struct radeon_device * rdev , enum radeon_hpd_id hpd ) ;

void r100_hpd_set_polarity ( struct radeon_device * rdev , enum radeon_hpd_id hpd ) ;

void r100_hpd_init ( struct radeon_device * rdev ) ;

void r100_hpd_fini ( struct radeon_device * rdev ) ;

void r100_pci_gart_tlb_flush ( struct radeon_device * rdev ) ;

int r100_pci_gart_init ( struct radeon_device * rdev ) ;

void r100_enable_bm ( struct radeon_device * rdev ) ;

int r100_pci_gart_enable ( struct radeon_device * rdev ) ;

void r100_pci_gart_disable ( struct radeon_device * rdev ) ;

int r100_pci_gart_set_page ( struct radeon_device * rdev , int i , uint64_t addr ) ;

void r100_pci_gart_fini ( struct radeon_device * rdev ) ;

int r100_irq_set ( struct radeon_device * rdev ) ;

void r100_irq_disable ( struct radeon_device * rdev ) ;

int r100_irq_process ( struct radeon_device * rdev ) ;

u32 r100_get_vblank_counter ( struct radeon_device * rdev , int crtc ) ;

void r100_fence_ring_emit ( struct radeon_device * rdev , struct radeon_fence * fence ) ;

int r100_wb_init ( struct radeon_device * rdev ) ;

void r100_wb_disable ( struct radeon_device * rdev ) ;

void r100_wb_fini ( struct radeon_device * rdev ) ;

int r100_copy_blit ( struct radeon_device * rdev , uint64_t src_offset , uint64_t dst_offset , unsigned num_pages , struct radeon_fence * fence ) ;

void r100_ring_start ( struct radeon_device * rdev ) ;

int r100_cp_init ( struct radeon_device * rdev , unsigned ring_size ) ;

void r100_cp_fini ( struct radeon_device * rdev ) ;

void r100_cp_disable ( struct radeon_device * rdev ) ;

int r100_cp_reset ( struct radeon_device * rdev ) ;

void r100_cp_commit ( struct radeon_device * rdev ) ;

int r100_cs_parse_packet0 ( struct radeon_cs_parser * p , struct radeon_cs_packet * pkt , const unsigned * auth , unsigned n , radeon_packet0_check_t check ) ;

void r100_cs_dump_packet ( struct radeon_cs_parser * p , struct radeon_cs_packet * pkt ) ;

int r100_cs_packet_parse ( struct radeon_cs_parser * p , struct radeon_cs_packet * pkt , unsigned idx ) ;

int r100_cs_packet_parse_vline ( struct radeon_cs_parser * p ) ;

int r100_cs_packet_next_reloc ( struct radeon_cs_parser * p , struct radeon_cs_reloc * * cs_reloc ) ;

int r100_cs_track_check_pkt3_indx_buffer ( struct radeon_cs_parser * p , struct radeon_cs_packet * pkt , struct radeon_bo * robj ) ;

int r100_cs_parse ( struct radeon_cs_parser * p ) ;

void r100_errata ( struct radeon_device * rdev ) ;

void r100_gpu_wait_for_vsync ( struct radeon_device * rdev ) ;

void r100_gpu_wait_for_vsync2 ( struct radeon_device * rdev ) ;

int r100_rbbm_fifo_wait_for_entry ( struct radeon_device * rdev , unsigned n ) ;

int r100_gui_wait_for_idle ( struct radeon_device * rdev ) ;

int r100_mc_wait_for_idle ( struct radeon_device * rdev ) ;

void r100_gpu_init ( struct radeon_device * rdev ) ;

void r100_hdp_reset ( struct radeon_device * rdev ) ;

int r100_rb2d_reset ( struct radeon_device * rdev ) ;

int r100_gpu_reset ( struct radeon_device * rdev ) ;

void r100_set_common_regs ( struct radeon_device * rdev ) ;

void r100_vram_init_sizes ( struct radeon_device * rdev ) ;

void r100_vga_set_state ( struct radeon_device * rdev , bool state ) ;

void r100_vram_info ( struct radeon_device * rdev ) ;

void r100_pll_errata_after_index ( struct radeon_device * rdev ) ;

uint32_t r100_pll_rreg ( struct radeon_device * rdev , uint32_t reg ) ;

void r100_pll_wreg ( struct radeon_device * rdev , uint32_t reg , uint32_t v ) ;

void r100_set_safe_registers ( struct radeon_device * rdev ) ;

int r100_debugfs_rbbm_init ( struct radeon_device * rdev ) ;

int r100_debugfs_cp_init ( struct radeon_device * rdev ) ;

int r100_debugfs_mc_info_init ( struct radeon_device * rdev ) ;

int r100_set_surface_reg ( struct radeon_device * rdev , int reg , uint32_t tiling_flags , uint32_t pitch , uint32_t offset , uint32_t obj_size ) ;

void r100_clear_surface_reg ( struct radeon_device * rdev , int reg ) ;

void r100_bandwidth_update ( struct radeon_device * rdev ) ;

int r100_cs_track_check ( struct radeon_device * rdev , struct r100_cs_track * track ) ;

void r100_cs_track_clear ( struct radeon_device * rdev , struct r100_cs_track * track ) ;

int r100_ring_test ( struct radeon_device * rdev ) ;

void r100_ring_ib_execute ( struct radeon_device * rdev , struct radeon_ib * ib ) ;

int r100_ib_test ( struct radeon_device * rdev ) ;

void r100_ib_fini ( struct radeon_device * rdev ) ;

int r100_ib_init ( struct radeon_device * rdev ) ;

void r100_mc_stop ( struct radeon_device * rdev , struct r100_mc_save * save ) ;

void r100_mc_resume ( struct radeon_device * rdev , struct r100_mc_save * save ) ;

void r100_vga_render_disable ( struct radeon_device * rdev ) ;

void r100_clock_startup ( struct radeon_device * rdev ) ;

int r100_resume ( struct radeon_device * rdev ) ;

int r100_suspend ( struct radeon_device * rdev ) ;

void r100_fini ( struct radeon_device * rdev ) ;

int r100_mc_init ( struct radeon_device * rdev ) ;

int r100_init ( struct radeon_device * rdev ) ;

void rv370_pcie_gart_tlb_flush ( struct radeon_device * rdev ) ;

int rv370_pcie_gart_set_page ( struct radeon_device * rdev , int i , uint64_t addr ) ;

int rv370_pcie_gart_init ( struct radeon_device * rdev ) ;

int rv370_pcie_gart_enable ( struct radeon_device * rdev ) ;

void rv370_pcie_gart_disable ( struct radeon_device * rdev ) ;

void rv370_pcie_gart_fini ( struct radeon_device * rdev ) ;

void r300_fence_ring_emit ( struct radeon_device * rdev , struct radeon_fence * fence ) ;

int r300_copy_dma ( struct radeon_device * rdev , uint64_t src_offset , uint64_t dst_offset , unsigned num_pages , struct radeon_fence * fence ) ;

void r300_ring_start ( struct radeon_device * rdev ) ;

void r300_errata ( struct radeon_device * rdev ) ;

int r300_mc_wait_for_idle ( struct radeon_device * rdev ) ;

void r300_gpu_init ( struct radeon_device * rdev ) ;

int r300_ga_reset ( struct radeon_device * rdev ) ;

int r300_gpu_reset ( struct radeon_device * rdev ) ;

void r300_vram_info ( struct radeon_device * rdev ) ;

void rv370_set_pcie_lanes ( struct radeon_device * rdev , int lanes ) ;

int r300_cs_parse ( struct radeon_cs_parser * p ) ;

void r300_set_reg_safe ( struct radeon_device * rdev ) ;

void r300_mc_program ( struct radeon_device * rdev ) ;

void r300_clock_startup ( struct radeon_device * rdev ) ;

int r300_resume ( struct radeon_device * rdev ) ;

int r300_suspend ( struct radeon_device * rdev ) ;

void r300_fini ( struct radeon_device * rdev ) ;

int r300_init ( struct radeon_device * rdev ) ;

int r420_mc_init ( struct radeon_device * rdev ) ;

void r420_pipes_init ( struct radeon_device * rdev ) ;

u32 r420_mc_rreg ( struct radeon_device * rdev , u32 reg ) ;

void r420_mc_wreg ( struct radeon_device * rdev , u32 reg , u32 v ) ;

int r420_resume ( struct radeon_device * rdev ) ;

int r420_suspend ( struct radeon_device * rdev ) ;

void r420_fini ( struct radeon_device * rdev ) ;

int r420_init ( struct radeon_device * rdev ) ;

int r420_debugfs_pipes_info_init ( struct radeon_device * rdev ) ;

void rs400_gart_adjust_size ( struct radeon_device * rdev ) ;

void rs400_gart_tlb_flush ( struct radeon_device * rdev ) ;

int rs400_gart_init ( struct radeon_device * rdev ) ;

int rs400_gart_enable ( struct radeon_device * rdev ) ;

void rs400_gart_disable ( struct radeon_device * rdev ) ;

void rs400_gart_fini ( struct radeon_device * rdev ) ;

int rs400_gart_set_page ( struct radeon_device * rdev , int i , uint64_t addr ) ;

int rs400_mc_wait_for_idle ( struct radeon_device * rdev ) ;

void rs400_gpu_init ( struct radeon_device * rdev ) ;

void rs400_vram_info ( struct radeon_device * rdev ) ;

uint32_t rs400_mc_rreg ( struct radeon_device * rdev , uint32_t reg ) ;

void rs400_mc_wreg ( struct radeon_device * rdev , uint32_t reg , uint32_t v ) ;

void rs400_mc_program ( struct radeon_device * rdev ) ;

int rs400_resume ( struct radeon_device * rdev ) ;

int rs400_suspend ( struct radeon_device * rdev ) ;

void rs400_fini ( struct radeon_device * rdev ) ;

int rs400_init ( struct radeon_device * rdev ) ;

int rs600_mc_init ( struct radeon_device * rdev ) ;

bool rs600_hpd_sense ( struct radeon_device * rdev , enum radeon_hpd_id hpd ) ;

void rs600_hpd_set_polarity ( struct radeon_device * rdev , enum radeon_hpd_id hpd ) ;

void rs600_hpd_init ( struct radeon_device * rdev ) ;

void rs600_hpd_fini ( struct radeon_device * rdev ) ;

void rs600_gart_tlb_flush ( struct radeon_device * rdev ) ;

int rs600_gart_init ( struct radeon_device * rdev ) ;

int rs600_gart_enable ( struct radeon_device * rdev ) ;

void rs600_gart_disable ( struct radeon_device * rdev ) ;

void rs600_gart_fini ( struct radeon_device * rdev ) ;

int rs600_gart_set_page ( struct radeon_device * rdev , int i , uint64_t addr ) ;

int rs600_irq_set ( struct radeon_device * rdev ) ;

void rs600_irq_disable ( struct radeon_device * rdev ) ;

int rs600_irq_process ( struct radeon_device * rdev ) ;

u32 rs600_get_vblank_counter ( struct radeon_device * rdev , int crtc ) ;

int rs600_mc_wait_for_idle ( struct radeon_device * rdev ) ;

void rs600_gpu_init ( struct radeon_device * rdev ) ;

void rs600_vram_info ( struct radeon_device * rdev ) ;

void rs600_bandwidth_update ( struct radeon_device * rdev ) ;

uint32_t rs600_mc_rreg ( struct radeon_device * rdev , uint32_t reg ) ;

void rs600_mc_wreg ( struct radeon_device * rdev , uint32_t reg , uint32_t v ) ;

void rs600_debugfs ( struct radeon_device * rdev ) ;

void rs600_set_safe_registers ( struct radeon_device * rdev ) ;

int rs600_resume ( struct radeon_device * rdev ) ;

int rs600_suspend ( struct radeon_device * rdev ) ;

void rs600_fini ( struct radeon_device * rdev ) ;

int rs600_init ( struct radeon_device * rdev ) ;

void rs690_pm_info ( struct radeon_device * rdev ) ;

void rs690_vram_info ( struct radeon_device * rdev ) ;

void rs690_line_buffer_adjust ( struct radeon_device * rdev , struct drm_display_mode * mode1 , struct drm_display_mode * mode2 ) ;

struct rs690_watermark { u32 lb_request_fifo_depth ; fixed20_12 num_line_pair ; fixed20_12 estimated_width ; fixed20_12 worst_case_latency ; fixed20_12 consumption_rate ; fixed20_12 active_time ; fixed20_12 dbpp ; fixed20_12 priority_mark_max ; fixed20_12 priority_mark ; fixed20_12 sclk ; } ;

void rs690_crtc_bandwidth_compute ( struct radeon_device * rdev , struct radeon_crtc * crtc , struct rs690_watermark * wm ) ;

void rs690_bandwidth_update ( struct radeon_device * rdev ) ;

uint32_t rs690_mc_rreg ( struct radeon_device * rdev , uint32_t reg ) ;

void rs690_mc_wreg ( struct radeon_device * rdev , uint32_t reg , uint32_t v ) ;

void rs690_mc_program ( struct radeon_device * rdev ) ;

int rs690_resume ( struct radeon_device * rdev ) ;

int rs690_suspend ( struct radeon_device * rdev ) ;

void rs690_fini ( struct radeon_device * rdev ) ;

int rs690_init ( struct radeon_device * rdev ) ;

void rv515_debugfs ( struct radeon_device * rdev ) ;

void rv515_ring_start ( struct radeon_device * rdev ) ;

int rv515_mc_wait_for_idle ( struct radeon_device * rdev ) ;

void rv515_vga_render_disable ( struct radeon_device * rdev ) ;

void rv515_gpu_init ( struct radeon_device * rdev ) ;

int rv515_ga_reset ( struct radeon_device * rdev ) ;

int rv515_gpu_reset ( struct radeon_device * rdev ) ;

void rv515_vram_info ( struct radeon_device * rdev ) ;

uint32_t rv515_mc_rreg ( struct radeon_device * rdev , uint32_t reg ) ;

void rv515_mc_wreg ( struct radeon_device * rdev , uint32_t reg , uint32_t v ) ;

int rv515_debugfs_pipes_info_init ( struct radeon_device * rdev ) ;

int rv515_debugfs_ga_info_init ( struct radeon_device * rdev ) ;

void rv515_mc_stop ( struct radeon_device * rdev , struct rv515_mc_save * save ) ;

void rv515_mc_resume ( struct radeon_device * rdev , struct rv515_mc_save * save ) ;

void rv515_mc_program ( struct radeon_device * rdev ) ;

void rv515_clock_startup ( struct radeon_device * rdev ) ;

int rv515_resume ( struct radeon_device * rdev ) ;

int rv515_suspend ( struct radeon_device * rdev ) ;

void rv515_set_safe_registers ( struct radeon_device * rdev ) ;

void rv515_fini ( struct radeon_device * rdev ) ;

int rv515_init ( struct radeon_device * rdev ) ;

void atom_rv515_force_tv_scaler ( struct radeon_device * rdev , struct radeon_crtc * crtc ) ;

struct rv515_watermark { u32 lb_request_fifo_depth ; fixed20_12 num_line_pair ; fixed20_12 estimated_width ; fixed20_12 worst_case_latency ; fixed20_12 consumption_rate ; fixed20_12 active_time ; fixed20_12 dbpp ; fixed20_12 priority_mark_max ; fixed20_12 priority_mark ; fixed20_12 sclk ; } ;

void rv515_crtc_bandwidth_compute ( struct radeon_device * rdev , struct radeon_crtc * crtc , struct rv515_watermark * wm ) ;

void rv515_bandwidth_avivo_update ( struct radeon_device * rdev ) ;

void rv515_bandwidth_update ( struct radeon_device * rdev ) ;

void r520_vram_info ( struct radeon_device * rdev ) ;

void r520_mc_program ( struct radeon_device * rdev ) ;

int r520_resume ( struct radeon_device * rdev ) ;

int r520_init ( struct radeon_device * rdev ) ;

bool r600_hpd_sense ( struct radeon_device * rdev , enum radeon_hpd_id hpd ) ;

void r600_hpd_set_polarity ( struct radeon_device * rdev , enum radeon_hpd_id hpd ) ;

void r600_hpd_init ( struct radeon_device * rdev ) ;

void r600_hpd_fini ( struct radeon_device * rdev ) ;

int r600_gart_clear_page ( struct radeon_device * rdev , int i ) ;

void r600_pcie_gart_tlb_flush ( struct radeon_device * rdev ) ;

int r600_pcie_gart_init ( struct radeon_device * rdev ) ;

int r600_pcie_gart_enable ( struct radeon_device * rdev ) ;

void r600_pcie_gart_disable ( struct radeon_device * rdev ) ;

void r600_pcie_gart_fini ( struct radeon_device * rdev ) ;

void r600_agp_enable ( struct radeon_device * rdev ) ;

int r600_mc_wait_for_idle ( struct radeon_device * rdev ) ;

int r600_mc_init ( struct radeon_device * rdev ) ;

int r600_gpu_soft_reset ( struct radeon_device * rdev ) ;

int r600_gpu_reset ( struct radeon_device * rdev ) ;

int r600_count_pipe_bits ( uint32_t val ) ;

void r600_gpu_init ( struct radeon_device * rdev ) ;

u32 r600_pciep_rreg ( struct radeon_device * rdev , u32 reg ) ;

void r600_pciep_wreg ( struct radeon_device * rdev , u32 reg , u32 v ) ;

void r600_cp_stop ( struct radeon_device * rdev ) ;

int r600_init_microcode ( struct radeon_device * rdev ) ;

int r600_cp_start ( struct radeon_device * rdev ) ;

int r600_cp_resume ( struct radeon_device * rdev ) ;

void r600_cp_commit ( struct radeon_device * rdev ) ;

void r600_ring_init ( struct radeon_device * rdev , unsigned ring_size ) ;

void r600_cp_fini ( struct radeon_device * rdev ) ;

void r600_scratch_init ( struct radeon_device * rdev ) ;

int r600_ring_test ( struct radeon_device * rdev ) ;

void r600_wb_disable ( struct radeon_device * rdev ) ;

void r600_wb_fini ( struct radeon_device * rdev ) ;

int r600_wb_enable ( struct radeon_device * rdev ) ;

void r600_fence_ring_emit ( struct radeon_device * rdev , struct radeon_fence * fence ) ;

int r600_copy_blit ( struct radeon_device * rdev , uint64_t src_offset , uint64_t dst_offset , unsigned num_pages , struct radeon_fence * fence ) ;

int r600_set_surface_reg ( struct radeon_device * rdev , int reg , uint32_t tiling_flags , uint32_t pitch , uint32_t offset , uint32_t obj_size ) ;

void r600_clear_surface_reg ( struct radeon_device * rdev , int reg ) ;

bool r600_card_posted ( struct radeon_device * rdev ) ;

int r600_startup ( struct radeon_device * rdev ) ;

void r600_vga_set_state ( struct radeon_device * rdev , bool state ) ;

int r600_resume ( struct radeon_device * rdev ) ;

int r600_suspend ( struct radeon_device * rdev ) ;

int r600_init ( struct radeon_device * rdev ) ;

void r600_fini ( struct radeon_device * rdev ) ;

void r600_ring_ib_execute ( struct radeon_device * rdev , struct radeon_ib * ib ) ;

int r600_ib_test ( struct radeon_device * rdev ) ;

void r600_ih_ring_init ( struct radeon_device * rdev , unsigned ring_size ) ;

int r600_irq_init ( struct radeon_device * rdev ) ;

void r600_irq_suspend ( struct radeon_device * rdev ) ;

void r600_irq_fini ( struct radeon_device * rdev ) ;

int r600_irq_set ( struct radeon_device * rdev ) ;

void r600_irq_disable ( struct radeon_device * rdev ) ;

int r600_irq_process ( struct radeon_device * rdev ) ;

int r600_debugfs_mc_info_init ( struct radeon_device * rdev ) ;

void r600_ioctl_wait_idle ( struct radeon_device * rdev , struct radeon_bo * bo ) ;

int rv770_pcie_gart_enable ( struct radeon_device * rdev ) ;

void rv770_pcie_gart_disable ( struct radeon_device * rdev ) ;

void rv770_pcie_gart_fini ( struct radeon_device * rdev ) ;

void rv770_agp_enable ( struct radeon_device * rdev ) ;

void r700_cp_stop ( struct radeon_device * rdev ) ;

int rv770_mc_init ( struct radeon_device * rdev ) ;

int rv770_gpu_reset ( struct radeon_device * rdev ) ;

int rv770_resume ( struct radeon_device * rdev ) ;

int rv770_suspend ( struct radeon_device * rdev ) ;

int rv770_init ( struct radeon_device * rdev ) ;

void rv770_fini ( struct radeon_device * rdev ) ;

void radeon_test_moves ( struct radeon_device * rdev ) ;

int r200_packet0_check ( struct radeon_cs_parser * p , struct radeon_cs_packet * pkt , unsigned idx , unsigned reg ) ;

void r200_set_safe_registers ( struct radeon_device * rdev ) ;

struct radeon_tv_mode_constants { uint16_t hor_resolution ; uint16_t ver_resolution ; enum radeon_tv_std standard ; uint16_t hor_total ; uint16_t ver_total ; uint16_t hor_start ; uint16_t hor_syncstart ; uint16_t ver_syncstart ; unsigned def_restart ; uint16_t crtcPLL_N ; uint8_t crtcPLL_M ; uint8_t crtcPLL_post_div ; unsigned pix_to_tv ; } ;

void radeon_legacy_tv_mode_set ( struct drm_encoder * encoder , struct drm_display_mode * mode , struct drm_display_mode * adjusted_mode ) ;

void radeon_legacy_tv_adjust_crtc_reg ( struct drm_encoder * encoder , uint32_t * h_total_disp , uint32_t * h_sync_strt_wid , uint32_t * v_total_disp , uint32_t * v_sync_strt_wid ) ;

void radeon_legacy_tv_adjust_pll1 ( struct drm_encoder * encoder , uint32_t * htotal_cntl , uint32_t * ppll_ref_div , uint32_t * ppll_div_3 , uint32_t * pixclks_cntl ) ;

void radeon_legacy_tv_adjust_pll2 ( struct drm_encoder * encoder , uint32_t * htotal2_cntl , uint32_t * p2pll_ref_div , uint32_t * p2pll_div_0 , uint32_t * pixclks_cntl ) ;

typedef int ( * next_reloc_t ) ( struct radeon_cs_parser * , struct radeon_cs_reloc * * ) ;
struct r600_cs_track { u32 cb_color0_base_last ; } ;

int r600_cs_packet_parse ( struct radeon_cs_parser * p , struct radeon_cs_packet * pkt , unsigned idx ) ;

int r600_cs_parse ( struct radeon_cs_parser * p ) ;

int r600_cs_legacy ( struct drm_device * dev , void * data , struct drm_file * filp , unsigned family , u32 * ib , int * l ) ;

void r600_cs_legacy_init ( void ) ;

int r600_prepare_blit_copy ( struct drm_device * dev , struct drm_file * file_priv ) ;

void r600_done_blit_copy ( struct drm_device * dev ) ;

void r600_blit_copy ( struct drm_device * dev , uint64_t src_gpu_addr , uint64_t dst_gpu_addr , int size_bytes ) ;

void r600_blit_swap ( struct drm_device * dev , uint64_t src_gpu_addr , uint64_t dst_gpu_addr , int sx , int sy , int dx , int dy , int w , int h , int src_pitch , int dst_pitch , int cpp ) ;

int r600_blit_init ( struct radeon_device * rdev ) ;

void r600_blit_fini ( struct radeon_device * rdev ) ;

int r600_vb_ib_get ( struct radeon_device * rdev ) ;

void r600_vb_ib_put ( struct radeon_device * rdev ) ;

int r600_blit_prepare_copy ( struct radeon_device * rdev , int size_bytes ) ;

void r600_blit_done_copy ( struct radeon_device * rdev , struct radeon_fence * fence ) ;

void r600_kms_blit_copy ( struct radeon_device * rdev , u64 src_gpu_addr , u64 dst_gpu_addr , int size_bytes ) ;

int radeon_pm_init ( struct radeon_device * rdev ) ;

int radeon_debugfs_pm_init ( struct radeon_device * rdev ) ;

int dp_mode_valid ( u8 dpcd [ 8 ] , int mode_clock ) ;

bool radeon_process_aux_ch ( struct radeon_i2c_chan * chan , u8 * req_bytes , int num_bytes , u8 * read_byte , u8 read_buf_len , u8 delay ) ;

bool radeon_dp_aux_native_write ( struct radeon_connector * radeon_connector , uint16_t address , uint8_t send_bytes , uint8_t * send ) ;

bool radeon_dp_aux_native_read ( struct radeon_connector * radeon_connector , uint16_t address , uint8_t delay , uint8_t expected_bytes , uint8_t * read_p ) ;

u8 radeon_dp_getsinktype ( struct radeon_connector * radeon_connector ) ;

bool radeon_dp_getdpcd ( struct radeon_connector * radeon_connector ) ;

void radeon_dp_set_link_config ( struct drm_connector * connector , struct drm_display_mode * mode ) ;

int radeon_dp_mode_valid_helper ( struct radeon_connector * radeon_connector , struct drm_display_mode * mode ) ;

bool radeon_dp_needs_link_train ( struct radeon_connector * radeon_connector ) ;

void dp_link_train ( struct drm_encoder * encoder , struct drm_connector * connector ) ;

int radeon_dp_i2c_aux_ch ( struct i2c_adapter * adapter , int mode , uint8_t write_byte , uint8_t * read_byte ) ;

int r600_audio_init ( struct radeon_device * rdev ) ;

int r600_audio_tmds_index ( struct drm_encoder * encoder ) ;

void r600_audio_set_clock ( struct drm_encoder * encoder , int clock ) ;

void r600_audio_fini ( struct radeon_device * rdev ) ;

enum r600_hdmi_color_format { RGB = 0 , YCC_422 = 1 , YCC_444 = 2 } ;

enum r600_hdmi_iec_status_bits { AUDIO_STATUS_DIG_ENABLE = 0x01 , AUDIO_STATUS_V = 0x02 , AUDIO_STATUS_VCFG = 0x04 , AUDIO_STATUS_EMPHASIS = 0x08 , AUDIO_STATUS_COPYRIGHT = 0x10 , AUDIO_STATUS_NONAUDIO = 0x20 , AUDIO_STATUS_PROFESSIONAL = 0x40 , AUDIO_STATUS_LEVEL = 0x80 } ;

int r600_hdmi_buffer_status_changed ( struct drm_encoder * encoder ) ;

void r600_hdmi_audio_workaround ( struct drm_encoder * encoder ) ;

void r600_hdmi_setmode ( struct drm_encoder * encoder , struct drm_display_mode * mode ) ;

void r600_hdmi_update_audio_settings ( struct drm_encoder * encoder , int channels , int rate , int bps , uint8_t status_bits , uint8_t category_code ) ;

void r600_hdmi_enable ( struct drm_encoder * encoder , int enable ) ;

void r600_hdmi_init ( struct drm_encoder * encoder ) ;


typedef struct drm_radeon_init32 { int func ; u32 sarea_priv_offset ; int is_pci ; int cp_mode ; int gart_size ; int ring_size ; int usec_timeout ; unsigned int fb_bpp ; unsigned int front_offset , front_pitch ; unsigned int back_offset , back_pitch ; unsigned int depth_bpp ; unsigned int depth_offset , depth_pitch ; u32 fb_offset ; u32 mmio_offset ; u32 ring_offset ; u32 ring_rptr_offset ; u32 buffers_offset ; u32 gart_textures_offset ; } drm_radeon_init32_t ;


typedef struct drm_radeon_clear32 { unsigned int flags ; unsigned int clear_color ; unsigned int clear_depth ; unsigned int color_mask ; unsigned int depth_mask ; u32 depth_boxes ; } drm_radeon_clear32_t ;


typedef struct drm_radeon_stipple32 { u32 mask ; } drm_radeon_stipple32_t ;


typedef struct drm_radeon_tex_image32 { unsigned int x , y ; unsigned int width , height ; u32 data ; } drm_radeon_tex_image32_t ;


typedef struct drm_radeon_texture32 { unsigned int offset ; int pitch ; int format ; int width ; int height ; u32 image ; } drm_radeon_texture32_t ;


typedef struct drm_radeon_vertex2_32 { int idx ; int discard ; int nr_states ; u32 state ; int nr_prims ; u32 prim ; } drm_radeon_vertex2_32_t ;


typedef struct drm_radeon_cmd_buffer32 { int bufsz ; u32 buf ; int nbox ; u32 boxes ; } drm_radeon_cmd_buffer32_t ;


typedef struct drm_radeon_getparam32 { int param ; u32 value ; } drm_radeon_getparam32_t ;


typedef struct drm_radeon_mem_alloc32 { int region ; int alignment ; int size ; u32 region_offset ; } drm_radeon_mem_alloc32_t ;


typedef struct drm_radeon_irq_emit32 { u32 irq_seq ; } drm_radeon_irq_emit32_t ;


typedef struct drm_radeon_setparam32 { int param ; u64 value ; } __attribute__ ( ( packed ) ) drm_radeon_setparam32_t ;

long radeon_compat_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

long radeon_kms_compat_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

struct ttm_agp_backend { struct ttm_backend backend ; struct agp_memory * mem ; struct agp_bridge_data * bridge ; } ;

struct ttm_backend * ttm_agp_backend_init ( struct ttm_bo_device * bdev , struct agp_bridge_data * bridge ) ;

struct ttm_mem_zone { struct kobject kobj ; struct ttm_mem_global * glob ; const char * name ; uint64_t zone_mem ; uint64_t emer_mem ; uint64_t max_mem ; uint64_t swap_limit ; uint64_t used_mem ; } ;
int ttm_mem_global_init ( struct ttm_mem_global * glob ) ;

void ttm_mem_global_release ( struct ttm_mem_global * glob ) ;

void ttm_mem_global_free ( struct ttm_mem_global * glob , uint64_t amount ) ;

int ttm_mem_global_alloc ( struct ttm_mem_global * glob , uint64_t memory , bool no_wait , bool interruptible ) ;

int ttm_mem_global_alloc_page ( struct ttm_mem_global * glob , struct page * page , bool no_wait , bool interruptible ) ;

void ttm_mem_global_free_page ( struct ttm_mem_global * glob , struct page * page ) ;

size_t ttm_round_pot ( size_t size ) ;

struct page * ttm_tt_get_page ( struct ttm_tt * ttm , int index ) ;

int ttm_tt_populate ( struct ttm_tt * ttm ) ;

int ttm_tt_set_placement_caching ( struct ttm_tt * ttm , uint32_t placement ) ;

void ttm_tt_destroy ( struct ttm_tt * ttm ) ;

int ttm_tt_set_user ( struct ttm_tt * ttm , struct task_struct * tsk , unsigned long start , unsigned long num_pages ) ;

struct ttm_tt * ttm_tt_create ( struct ttm_bo_device * bdev , unsigned long size , uint32_t page_flags , struct page * dummy_read_page ) ;

void ttm_tt_unbind ( struct ttm_tt * ttm ) ;

int ttm_tt_bind ( struct ttm_tt * ttm , struct ttm_mem_reg * bo_mem ) ;

int ttm_tt_swapout ( struct ttm_tt * ttm , struct file * persistant_swap_storage ) ;

int ttm_bo_wait_unreserved ( struct ttm_buffer_object * bo , bool interruptible ) ;

int ttm_bo_reserve_locked ( struct ttm_buffer_object * bo , bool interruptible , bool no_wait , bool use_sequence , uint32_t sequence ) ;

int ttm_bo_reserve ( struct ttm_buffer_object * bo , bool interruptible , bool no_wait , bool use_sequence , uint32_t sequence ) ;

void ttm_bo_unreserve ( struct ttm_buffer_object * bo ) ;

void ttm_bo_unref ( struct ttm_buffer_object * * p_bo ) ;

int ttm_bo_mem_space ( struct ttm_buffer_object * bo , struct ttm_placement * placement , struct ttm_mem_reg * mem , bool interruptible , bool no_wait ) ;

int ttm_bo_wait_cpu ( struct ttm_buffer_object * bo , bool no_wait ) ;

int ttm_bo_move_buffer ( struct ttm_buffer_object * bo , struct ttm_placement * placement , bool interruptible , bool no_wait ) ;

int ttm_bo_validate ( struct ttm_buffer_object * bo , struct ttm_placement * placement , bool interruptible , bool no_wait ) ;

int ttm_bo_check_placement ( struct ttm_buffer_object * bo , struct ttm_placement * placement ) ;

int ttm_bo_init ( struct ttm_bo_device * bdev , struct ttm_buffer_object * bo , unsigned long size , enum ttm_bo_type type , struct ttm_placement * placement , uint32_t page_alignment , unsigned long buffer_start , bool interruptible , struct file * persistant_swap_storage , size_t acc_size , void ( * destroy ) ( struct ttm_buffer_object * ) ) ;

int ttm_bo_create ( struct ttm_bo_device * bdev , unsigned long size , enum ttm_bo_type type , struct ttm_placement * placement , uint32_t page_alignment , unsigned long buffer_start , bool interruptible , struct file * persistant_swap_storage , struct ttm_buffer_object * * p_bo ) ;

int ttm_bo_clean_mm ( struct ttm_bo_device * bdev , unsigned mem_type ) ;

int ttm_bo_evict_mm ( struct ttm_bo_device * bdev , unsigned mem_type ) ;

int ttm_bo_init_mm ( struct ttm_bo_device * bdev , unsigned type , unsigned long p_size ) ;

void ttm_bo_global_release ( struct ttm_global_reference * ref ) ;

int ttm_bo_global_init ( struct ttm_global_reference * ref ) ;

int ttm_bo_device_release ( struct ttm_bo_device * bdev ) ;

int ttm_bo_device_init ( struct ttm_bo_device * bdev , struct ttm_bo_global * glob , struct ttm_bo_driver * driver , uint64_t file_page_offset , bool need_dma32 ) ;

bool ttm_mem_reg_is_pci ( struct ttm_bo_device * bdev , struct ttm_mem_reg * mem ) ;

int ttm_bo_pci_offset ( struct ttm_bo_device * bdev , struct ttm_mem_reg * mem , unsigned long * bus_base , unsigned long * bus_offset , unsigned long * bus_size ) ;

void ttm_bo_unmap_virtual ( struct ttm_buffer_object * bo ) ;

int ttm_bo_wait ( struct ttm_buffer_object * bo , bool lazy , bool interruptible , bool no_wait ) ;

void ttm_bo_unblock_reservation ( struct ttm_buffer_object * bo ) ;

int ttm_bo_block_reservation ( struct ttm_buffer_object * bo , bool interruptible , bool no_wait ) ;

int ttm_bo_synccpu_write_grab ( struct ttm_buffer_object * bo , bool no_wait ) ;

void ttm_bo_synccpu_write_release ( struct ttm_buffer_object * bo ) ;

void ttm_bo_swapout_all ( struct ttm_bo_device * bdev ) ;

void ttm_bo_free_old_node ( struct ttm_buffer_object * bo ) ;

int ttm_bo_move_ttm ( struct ttm_buffer_object * bo , bool evict , bool no_wait , struct ttm_mem_reg * new_mem ) ;

int ttm_mem_reg_ioremap ( struct ttm_bo_device * bdev , struct ttm_mem_reg * mem , void * * virtual ) ;

void ttm_mem_reg_iounmap ( struct ttm_bo_device * bdev , struct ttm_mem_reg * mem , void * virtual ) ;

int ttm_bo_move_memcpy ( struct ttm_buffer_object * bo , bool evict , bool no_wait , struct ttm_mem_reg * new_mem ) ;

pgprot_t ttm_io_prot ( uint32_t caching_flags , pgprot_t tmp ) ;

int ttm_bo_kmap ( struct ttm_buffer_object * bo , unsigned long start_page , unsigned long num_pages , struct ttm_bo_kmap_obj * map ) ;

void ttm_bo_kunmap ( struct ttm_bo_kmap_obj * map ) ;

int ttm_bo_pfn_prot ( struct ttm_buffer_object * bo , unsigned long dst_offset , unsigned long * pfn , pgprot_t * prot ) ;

int ttm_bo_move_accel_cleanup ( struct ttm_buffer_object * bo , void * sync_obj , void * sync_obj_arg , bool evict , bool no_wait , struct ttm_mem_reg * new_mem ) ;

int ttm_bo_mmap ( struct file * filp , struct vm_area_struct * vma , struct ttm_bo_device * bdev ) ;

int ttm_fbdev_mmap ( struct vm_area_struct * vma , struct ttm_buffer_object * bo ) ;

ssize_t ttm_bo_io ( struct ttm_bo_device * bdev , struct file * filp , const char * wbuf , char * rbuf , size_t count , loff_t * f_pos , bool write ) ;

ssize_t ttm_bo_fbdev_io ( struct ttm_buffer_object * bo , const char * wbuf , char * rbuf , size_t count , loff_t * f_pos , bool write ) ;

struct kobject * ttm_get_kobj ( void ) ;

struct ttm_global_item { struct mutex mutex ; void * object ; int refcount ; } ;

void ttm_global_init ( void ) ;

void ttm_global_release ( void ) ;

int ttm_global_item_ref ( struct ttm_global_reference * ref ) ;

void ttm_global_item_unref ( struct ttm_global_reference * ref ) ;

enum ttm_ref_type { TTM_REF_USAGE , TTM_REF_SYNCCPU_READ , TTM_REF_SYNCCPU_WRITE , TTM_REF_NUM } ;

enum ttm_object_type { ttm_fence_type , ttm_buffer_type , ttm_lock_type , ttm_driver_type0 = 256 , ttm_driver_type1 , ttm_driver_type2 , ttm_driver_type3 , ttm_driver_type4 , ttm_driver_type5 } ;

struct ttm_object_file ;

struct ttm_object_device ;

struct ttm_base_object { struct drm_hash_item hash ; enum ttm_object_type object_type ; bool shareable ; struct ttm_object_file * tfile ; struct kref refcount ; void ( * refcount_release ) ( struct ttm_base_object * * base ) ; void ( * ref_obj_release ) ( struct ttm_base_object * base , enum ttm_ref_type ref_type ) ; } ;

struct ttm_object_file { struct ttm_object_device * tdev ; rwlock_t lock ; struct list_head ref_list ; struct drm_open_hash ref_hash [ TTM_REF_NUM ] ; struct kref refcount ; } ;
struct ttm_object_device { rwlock_t object_lock ; struct drm_open_hash object_hash ; atomic_t object_count ; struct ttm_mem_global * mem_glob ; } ;
struct ttm_ref_object { struct drm_hash_item hash ; struct list_head head ; struct kref kref ; enum ttm_ref_type ref_type ; struct ttm_base_object * obj ; struct ttm_object_file * tfile ; } ;

int ttm_base_object_init ( struct ttm_object_file * tfile , struct ttm_base_object * base , bool shareable , enum ttm_object_type object_type , void ( * refcount_release ) ( struct ttm_base_object * * ) , void ( * ref_obj_release ) ( struct ttm_base_object * , enum ttm_ref_type ref_type ) ) ;

void ttm_base_object_unref ( struct ttm_base_object * * p_base ) ;

struct ttm_base_object * ttm_base_object_lookup ( struct ttm_object_file * tfile , uint32_t key ) ;

int ttm_ref_object_add ( struct ttm_object_file * tfile , struct ttm_base_object * base , enum ttm_ref_type ref_type , bool * existed ) ;

int ttm_ref_object_base_unref ( struct ttm_object_file * tfile , unsigned long key , enum ttm_ref_type ref_type ) ;

void ttm_object_file_release ( struct ttm_object_file * * p_tfile ) ;

struct ttm_object_file * ttm_object_file_init ( struct ttm_object_device * tdev , unsigned int hash_order ) ;

struct ttm_object_device * ttm_object_device_init ( struct ttm_mem_global * mem_glob , unsigned int hash_order ) ;

void ttm_object_device_release ( struct ttm_object_device * * p_tdev ) ;

struct ttm_lock { struct ttm_base_object base ; wait_queue_head_t queue ; spinlock_t lock ; int32_t rw ; uint32_t flags ; bool kill_takers ; int signal ; struct ttm_object_file * vt_holder ; } ;

void ttm_lock_init ( struct ttm_lock * lock ) ;

void ttm_read_unlock ( struct ttm_lock * lock ) ;

int ttm_read_lock ( struct ttm_lock * lock , bool interruptible ) ;

int ttm_read_trylock ( struct ttm_lock * lock , bool interruptible ) ;

void ttm_write_unlock ( struct ttm_lock * lock ) ;

int ttm_write_lock ( struct ttm_lock * lock , bool interruptible ) ;

void ttm_write_lock_downgrade ( struct ttm_lock * lock ) ;

int ttm_vt_lock ( struct ttm_lock * lock , bool interruptible , struct ttm_object_file * tfile ) ;

int ttm_vt_unlock ( struct ttm_lock * lock ) ;

void ttm_suspend_unlock ( struct ttm_lock * lock ) ;

void ttm_suspend_lock ( struct ttm_lock * lock ) ;

struct ttm_validate_buffer { struct list_head head ; struct ttm_buffer_object * bo ; void * new_sync_obj_arg ; bool reserved ; } ;

void ttm_eu_backoff_reservation ( struct list_head * list ) ;

int ttm_eu_reserve_buffers ( struct list_head * list , uint32_t val_seq ) ;

void ttm_eu_fence_buffer_objects ( struct list_head * list , void * sync_obj ) ;

int drm_getmagic ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_authmagic ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

resource_size_t drm_get_resource_start ( struct drm_device * dev , unsigned int resource ) ;

resource_size_t drm_get_resource_len ( struct drm_device * dev , unsigned int resource ) ;

int drm_addmap ( struct drm_device * dev , resource_size_t offset , unsigned int size , enum drm_map_type type , enum drm_map_flags flags , struct drm_local_map * * map_ptr ) ;

int drm_addmap_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_rmmap_locked ( struct drm_device * dev , struct drm_local_map * map ) ;

int drm_rmmap ( struct drm_device * dev , struct drm_local_map * map ) ;

int drm_rmmap_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_addbufs_agp ( struct drm_device * dev , struct drm_buf_desc * request ) ;

int drm_addbufs_pci ( struct drm_device * dev , struct drm_buf_desc * request ) ;

int drm_addbufs ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_infobufs ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_markbufs ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_freebufs ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mapbufs ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_order ( unsigned long size ) ;

void drm_clflush_pages ( struct page * pages [ ] , unsigned long num_pages ) ;

void drm_ctxbitmap_free ( struct drm_device * dev , int ctx_handle ) ;

int drm_ctxbitmap_init ( struct drm_device * dev ) ;

void drm_ctxbitmap_cleanup ( struct drm_device * dev ) ;

int drm_getsareactx ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_setsareactx ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_resctx ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_addctx ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_modctx ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_getctx ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_switchctx ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_newctx ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_rmctx ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_dma_setup ( struct drm_device * dev ) ;

void drm_dma_takedown ( struct drm_device * dev ) ;

void drm_free_buffer ( struct drm_device * dev , struct drm_buf * buf ) ;

void drm_core_reclaim_buffers ( struct drm_device * dev , struct drm_file * file_priv ) ;

int drm_adddraw ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_rmdraw ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_update_drawable_info ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

struct drm_drawable_info * drm_get_drawable_info ( struct drm_device * dev , drm_drawable_t id ) ;

void drm_drawable_free_all ( struct drm_device * dev ) ;

int drm_lastclose ( struct drm_device * dev ) ;

int drm_init ( struct drm_driver * driver ) ;

void drm_exit ( struct drm_driver * driver ) ;

long drm_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

struct drm_local_map * drm_getsarea ( struct drm_device * dev ) ;

int drm_open ( struct inode * inode , struct file * filp ) ;

int drm_stub_open ( struct inode * inode , struct file * filp ) ;

int drm_fasync ( int fd , struct file * filp , int on ) ;

int drm_release ( struct inode * inode , struct file * filp ) ;

ssize_t drm_read ( struct file * filp , char * buffer , size_t count , loff_t * offset ) ;

unsigned int drm_poll ( struct file * filp , struct poll_table_struct * wait ) ;

int drm_gem_init ( struct drm_device * dev ) ;

void drm_gem_destroy ( struct drm_device * dev ) ;

struct drm_gem_object * drm_gem_object_alloc ( struct drm_device * dev , size_t size ) ;

int drm_gem_handle_create ( struct drm_file * file_priv , struct drm_gem_object * obj , u32 * handlep ) ;

struct drm_gem_object * drm_gem_object_lookup ( struct drm_device * dev , struct drm_file * filp , u32 handle ) ;

int drm_gem_close_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_gem_flink_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_gem_open_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void drm_gem_open ( struct drm_device * dev , struct drm_file * file_private ) ;
void drm_gem_release ( struct drm_device * dev , struct drm_file * file_private ) ;

void drm_gem_object_free ( struct kref * kref ) ;

void drm_gem_object_handle_free ( struct kref * kref ) ;

void drm_gem_vm_open ( struct vm_area_struct * vma ) ;

void drm_gem_vm_close ( struct vm_area_struct * vma ) ;

int drm_gem_mmap ( struct file * filp , struct vm_area_struct * vma ) ;

int drm_getunique ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_setunique ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_getmap ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_getclient ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_getstats ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_setversion ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_noop ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_irq_by_busid ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void drm_vblank_cleanup ( struct drm_device * dev ) ;

int drm_vblank_init ( struct drm_device * dev , int num_crtcs ) ;

int drm_irq_install ( struct drm_device * dev ) ;

int drm_irq_uninstall ( struct drm_device * dev ) ;

int drm_control ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;
u32 drm_vblank_count ( struct drm_device * dev , int crtc ) ;

int drm_vblank_get ( struct drm_device * dev , int crtc ) ;

void drm_vblank_put ( struct drm_device * dev , int crtc ) ;

void drm_vblank_off ( struct drm_device * dev , int crtc ) ;

void drm_vblank_pre_modeset ( struct drm_device * dev , int crtc ) ;

void drm_vblank_post_modeset ( struct drm_device * dev , int crtc ) ;

int drm_modeset_ctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;
int drm_wait_vblank ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;
void drm_handle_vblank_events ( struct drm_device * dev , int crtc ) ;

void drm_handle_vblank ( struct drm_device * dev , int crtc ) ;

int drm_lock ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;
int drm_unlock ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_lock_take ( struct drm_lock_data * lock_data , unsigned int context ) ;

int drm_lock_free ( struct drm_lock_data * lock_data , unsigned int context ) ;

void drm_idlelock_take ( struct drm_lock_data * lock_data ) ;

void drm_idlelock_release ( struct drm_lock_data * lock_data ) ;

int drm_i_have_hw_lock ( struct drm_device * dev , struct drm_file * file_priv ) ;

int drm_mem_info ( char * buf , char * * start , off_t offset , int len , int * eof , void * data ) ;

struct agp_memory * drm_alloc_agp ( struct drm_device * dev , int pages , u32 type ) ;

int drm_free_agp ( struct agp_memory * handle , int pages ) ;

int drm_bind_agp ( struct agp_memory * handle , unsigned int start ) ;

int drm_unbind_agp ( struct agp_memory * handle ) ;

void drm_core_ioremap ( struct drm_local_map * map , struct drm_device * dev ) ;

void drm_core_ioremap_wc ( struct drm_local_map * map , struct drm_device * dev ) ;

void drm_core_ioremapfree ( struct drm_local_map * map , struct drm_device * dev ) ;

int drm_proc_create_files ( struct drm_info_list * files , int count , struct proc_dir_entry * root , struct drm_minor * minor ) ;

int drm_proc_init ( struct drm_minor * minor , int minor_id , struct proc_dir_entry * root ) ;

int drm_proc_remove_files ( struct drm_info_list * files , int count , struct drm_minor * minor ) ;

int drm_proc_cleanup ( struct drm_minor * minor , struct proc_dir_entry * root ) ;

void drm_ut_debug_printk ( unsigned int request_level , const char * prefix , const char * function_name , const char * format , ... ) ;

struct drm_master * drm_master_create ( struct drm_minor * minor ) ;

struct drm_master * drm_master_get ( struct drm_master * master ) ;

void drm_master_put ( struct drm_master * * master ) ;

int drm_setmaster_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_dropmaster_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_get_dev ( struct pci_dev * pdev , const struct pci_device_id * ent , struct drm_driver * driver ) ;

int drm_put_minor ( struct drm_minor * * minor_p ) ;

void drm_put_dev ( struct drm_device * dev ) ;

void drm_vm_open_locked ( struct vm_area_struct * vma ) ;

resource_size_t drm_core_get_map_ofs ( struct drm_local_map * map ) ;

resource_size_t drm_core_get_reg_ofs ( struct drm_device * dev ) ;

int drm_mmap_locked ( struct file * filp , struct vm_area_struct * vma ) ;

int drm_mmap ( struct file * filp , struct vm_area_struct * vma ) ;

int drm_agp_info ( struct drm_device * dev , struct drm_agp_info * info ) ;
int drm_agp_info_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_agp_acquire ( struct drm_device * dev ) ;

int drm_agp_acquire_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_agp_release ( struct drm_device * dev ) ;

int drm_agp_release_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_agp_enable ( struct drm_device * dev , struct drm_agp_mode mode ) ;

int drm_agp_enable_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_agp_alloc ( struct drm_device * dev , struct drm_agp_buffer * request ) ;

int drm_agp_alloc_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_agp_unbind ( struct drm_device * dev , struct drm_agp_binding * request ) ;

int drm_agp_unbind_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_agp_bind ( struct drm_device * dev , struct drm_agp_binding * request ) ;

int drm_agp_bind_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_agp_free ( struct drm_device * dev , struct drm_agp_buffer * request ) ;

int drm_agp_free_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

struct drm_agp_head * drm_agp_init ( struct drm_device * dev ) ;

struct agp_memory * drm_agp_allocate_memory ( struct agp_bridge_data * bridge , size_t pages , u32 type ) ;

int drm_agp_free_memory ( struct agp_memory * handle ) ;

int drm_agp_bind_memory ( struct agp_memory * handle , off_t start ) ;

int drm_agp_unbind_memory ( struct agp_memory * handle ) ;

struct agp_memory * drm_agp_bind_pages ( struct drm_device * dev , struct page * * pages , unsigned long num_pages , uint32_t gtt_offset , u32 type ) ;

void drm_agp_chipset_flush ( struct drm_device * dev ) ;

void drm_sg_cleanup ( struct drm_sg_mem * entry ) ;

int drm_sg_alloc ( struct drm_device * dev , struct drm_scatter_gather * request ) ;

int drm_sg_alloc_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_sg_free ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_ati_pcigart_cleanup ( struct drm_device * dev , struct drm_ati_pcigart_info * gart_info ) ;

int drm_ati_pcigart_init ( struct drm_device * dev , struct drm_ati_pcigart_info * gart_info ) ;

drm_dma_handle_t * drm_pci_alloc ( struct drm_device * dev , size_t size , size_t align ) ;

void __drm_pci_free ( struct drm_device * dev , drm_dma_handle_t * dmah ) ;

void drm_pci_free ( struct drm_device * dev , drm_dma_handle_t * dmah ) ;

struct class * drm_sysfs_create ( struct module * owner , char * name ) ;

void drm_sysfs_destroy ( void ) ;

int drm_sysfs_connector_add ( struct drm_connector * connector ) ;

void drm_sysfs_connector_remove ( struct drm_connector * connector ) ;

void drm_sysfs_hotplug_event ( struct drm_device * dev ) ;

int drm_sysfs_device_add ( struct drm_minor * minor ) ;

void drm_sysfs_device_remove ( struct drm_minor * minor ) ;

int drm_class_device_register ( struct device * dev ) ;

void drm_class_device_unregister ( struct device * dev ) ;

int drm_ht_create ( struct drm_open_hash * ht , unsigned int order ) ;

void drm_ht_verbose_list ( struct drm_open_hash * ht , unsigned long key ) ;

int drm_ht_insert_item ( struct drm_open_hash * ht , struct drm_hash_item * item ) ;

int drm_ht_just_insert_please ( struct drm_open_hash * ht , struct drm_hash_item * item , unsigned long seed , int bits , int shift , unsigned long add ) ;

int drm_ht_find_item ( struct drm_open_hash * ht , unsigned long key , struct drm_hash_item * * item ) ;

int drm_ht_remove_key ( struct drm_open_hash * ht , unsigned long key ) ;

int drm_ht_remove_item ( struct drm_open_hash * ht , struct drm_hash_item * item ) ;

void drm_ht_remove ( struct drm_open_hash * ht ) ;

struct drm_sman_mm { void * private ; void * ( * allocate ) ( void * private , unsigned long size , unsigned alignment ) ; void ( * free ) ( void * private , void * ref ) ; void ( * destroy ) ( void * private ) ; unsigned long ( * offset ) ( void * private , void * ref ) ; } ;

struct drm_memblock_item { struct list_head owner_list ; struct drm_hash_item user_hash ; void * mm_info ; struct drm_sman_mm * mm ; struct drm_sman * sman ; } ;

struct drm_sman { struct drm_sman_mm * mm ; int num_managers ; struct drm_open_hash owner_hash_tab ; struct drm_open_hash user_hash_tab ; struct list_head owner_items ; } ;

struct drm_owner_item { struct drm_hash_item owner_hash ; struct list_head sman_list ; struct list_head mem_blocks ; } ;

void drm_sman_takedown ( struct drm_sman * sman ) ;

int drm_sman_init ( struct drm_sman * sman , unsigned int num_managers , unsigned int user_order , unsigned int owner_order ) ;

int drm_sman_set_range ( struct drm_sman * sman , unsigned int manager , unsigned long start , unsigned long size ) ;

int drm_sman_set_manager ( struct drm_sman * sman , unsigned int manager , struct drm_sman_mm * allocator ) ;

struct drm_memblock_item * drm_sman_alloc ( struct drm_sman * sman , unsigned int manager , unsigned long size , unsigned alignment , unsigned long owner ) ;

int drm_sman_free_key ( struct drm_sman * sman , unsigned int key ) ;

int drm_sman_owner_clean ( struct drm_sman * sman , unsigned long owner ) ;

void drm_sman_owner_cleanup ( struct drm_sman * sman , unsigned long owner ) ;

void drm_sman_cleanup ( struct drm_sman * sman ) ;

unsigned long drm_mm_tail_space ( struct drm_mm * mm ) ;

int drm_mm_remove_space_from_tail ( struct drm_mm * mm , unsigned long size ) ;

int drm_mm_pre_get ( struct drm_mm * mm ) ;

int drm_mm_add_space_to_tail ( struct drm_mm * mm , unsigned long size , int atomic ) ;

struct drm_mm_node * drm_mm_get_block_generic ( struct drm_mm_node * node , unsigned long size , unsigned alignment , int atomic ) ;

struct drm_mm_node * drm_mm_get_block_range_generic ( struct drm_mm_node * node , unsigned long size , unsigned alignment , unsigned long start , unsigned long end , int atomic ) ;

void drm_mm_put_block ( struct drm_mm_node * cur ) ;

struct drm_mm_node * drm_mm_search_free ( const struct drm_mm * mm , unsigned long size , unsigned alignment , int best_match ) ;

struct drm_mm_node * drm_mm_search_free_in_range ( const struct drm_mm * mm , unsigned long size , unsigned alignment , unsigned long start , unsigned long end , int best_match ) ;

int drm_mm_clean ( struct drm_mm * mm ) ;

int drm_mm_init ( struct drm_mm * mm , unsigned long start , unsigned long size ) ;

void drm_mm_takedown ( struct drm_mm * mm ) ;

void drm_mm_debug_table ( struct drm_mm * mm , const char * prefix ) ;

int drm_mm_dump_table ( struct seq_file * m , struct drm_mm * mm ) ;

char * drm_get_dpms_name ( int val ) ;

char * drm_get_dvi_i_select_name ( int val ) ;

char * drm_get_dvi_i_subconnector_name ( int val ) ;

char * drm_get_tv_select_name ( int val ) ;

char * drm_get_tv_subconnector_name ( int val ) ;

char * drm_get_dirty_info_name ( int val ) ;

struct drm_conn_prop_enum_list { int type ; char * name ; int count ; } ;

char * drm_get_encoder_name ( struct drm_encoder * encoder ) ;

char * drm_get_connector_name ( struct drm_connector * connector ) ;

char * drm_get_connector_status_name ( enum drm_connector_status status ) ;

struct drm_mode_object * drm_mode_object_find ( struct drm_device * dev , uint32_t id , uint32_t type ) ;

int drm_framebuffer_init ( struct drm_device * dev , struct drm_framebuffer * fb , const struct drm_framebuffer_funcs * funcs ) ;

void drm_framebuffer_cleanup ( struct drm_framebuffer * fb ) ;

void drm_crtc_init ( struct drm_device * dev , struct drm_crtc * crtc , const struct drm_crtc_funcs * funcs ) ;

void drm_crtc_cleanup ( struct drm_crtc * crtc ) ;

void drm_mode_probed_add ( struct drm_connector * connector , struct drm_display_mode * mode ) ;

void drm_mode_remove ( struct drm_connector * connector , struct drm_display_mode * mode ) ;

void drm_connector_init ( struct drm_device * dev , struct drm_connector * connector , const struct drm_connector_funcs * funcs , int connector_type ) ;

void drm_connector_cleanup ( struct drm_connector * connector ) ;

void drm_encoder_init ( struct drm_device * dev , struct drm_encoder * encoder , const struct drm_encoder_funcs * funcs , int encoder_type ) ;

void drm_encoder_cleanup ( struct drm_encoder * encoder ) ;

struct drm_display_mode * drm_mode_create ( struct drm_device * dev ) ;

void drm_mode_destroy ( struct drm_device * dev , struct drm_display_mode * mode ) ;

int drm_mode_create_dvi_i_properties ( struct drm_device * dev ) ;

int drm_mode_create_tv_properties ( struct drm_device * dev , int num_modes , char * modes [ ] ) ;

int drm_mode_create_scaling_mode_property ( struct drm_device * dev ) ;

int drm_mode_create_dithering_property ( struct drm_device * dev ) ;

int drm_mode_create_dirty_info_property ( struct drm_device * dev ) ;

void drm_mode_config_init ( struct drm_device * dev ) ;

int drm_mode_group_init ( struct drm_device * dev , struct drm_mode_group * group ) ;

int drm_mode_group_init_legacy_group ( struct drm_device * dev , struct drm_mode_group * group ) ;

void drm_mode_config_cleanup ( struct drm_device * dev ) ;

void drm_crtc_convert_to_umode ( struct drm_mode_modeinfo * out , struct drm_display_mode * in ) ;

void drm_crtc_convert_umode ( struct drm_display_mode * out , struct drm_mode_modeinfo * in ) ;

int drm_mode_getresources ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_getcrtc ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_getconnector ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_getencoder ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_setcrtc ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_cursor_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_addfb ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_rmfb ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_getfb ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void drm_fb_release ( struct drm_file * priv ) ;

int drm_mode_attachmode_crtc ( struct drm_device * dev , struct drm_crtc * crtc , struct drm_display_mode * mode ) ;

int drm_mode_detachmode_crtc ( struct drm_device * dev , struct drm_display_mode * mode ) ;

int drm_mode_attachmode_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_detachmode_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

struct drm_property * drm_property_create ( struct drm_device * dev , int flags , const char * name , int num_values ) ;

int drm_property_add_enum ( struct drm_property * property , int index , uint64_t value , const char * name ) ;

void drm_property_destroy ( struct drm_device * dev , struct drm_property * property ) ;

int drm_connector_attach_property ( struct drm_connector * connector , struct drm_property * property , uint64_t init_val ) ;

int drm_connector_property_set_value ( struct drm_connector * connector , struct drm_property * property , uint64_t value ) ;

int drm_connector_property_get_value ( struct drm_connector * connector , struct drm_property * property , uint64_t * val ) ;

int drm_mode_getproperty_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_getblob_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_connector_update_edid_property ( struct drm_connector * connector , struct edid * edid ) ;

int drm_mode_connector_property_set_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_connector_attach_encoder ( struct drm_connector * connector , struct drm_encoder * encoder ) ;

void drm_mode_connector_detach_encoder ( struct drm_connector * connector , struct drm_encoder * encoder ) ;

bool drm_mode_crtc_set_gamma_size ( struct drm_crtc * crtc , int gamma_size ) ;

int drm_mode_gamma_set_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_gamma_get_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

int drm_mode_page_flip_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) ;

void drm_mode_debug_printmodeline ( struct drm_display_mode * mode ) ;

struct drm_display_mode * drm_cvt_mode ( struct drm_device * dev , int hdisplay , int vdisplay , int vrefresh , bool reduced , bool interlaced , bool margins ) ;

struct drm_display_mode * drm_gtf_mode ( struct drm_device * dev , int hdisplay , int vdisplay , int vrefresh , bool interlaced , int margins ) ;

void drm_mode_set_name ( struct drm_display_mode * mode ) ;

void drm_mode_list_concat ( struct list_head * head , struct list_head * new ) ;

int drm_mode_width ( struct drm_display_mode * mode ) ;

int drm_mode_height ( struct drm_display_mode * mode ) ;

int drm_mode_hsync ( struct drm_display_mode * mode ) ;

int drm_mode_vrefresh ( struct drm_display_mode * mode ) ;

void drm_mode_set_crtcinfo ( struct drm_display_mode * p , int adjust_flags ) ;

struct drm_display_mode * drm_mode_duplicate ( struct drm_device * dev , struct drm_display_mode * mode ) ;

bool drm_mode_equal ( struct drm_display_mode * mode1 , struct drm_display_mode * mode2 ) ;

void drm_mode_validate_size ( struct drm_device * dev , struct list_head * mode_list , int maxX , int maxY , int maxPitch ) ;

void drm_mode_validate_clocks ( struct drm_device * dev , struct list_head * mode_list , int * min , int * max , int n_ranges ) ;

void drm_mode_prune_invalid ( struct drm_device * dev , struct list_head * mode_list , bool verbose ) ;

void drm_mode_sort ( struct list_head * mode_list ) ;

void drm_mode_connector_list_update ( struct drm_connector * connector ) ;


struct drm_display_mode * drm_mode_std ( struct drm_device * dev , struct std_timing * t , int revision , int timing_level ) ;

int drm_do_probe_ddc_edid ( struct i2c_adapter * adapter , unsigned char * buf , int len ) ;

struct edid * drm_get_edid ( struct drm_connector * connector , struct i2c_adapter * adapter ) ;

bool drm_detect_hdmi_monitor ( struct edid * edid ) ;

int drm_add_edid_modes ( struct drm_connector * connector , struct edid * edid ) ;

int drm_add_modes_noedid ( struct drm_connector * connector , int hdisplay , int vdisplay ) ;

int drm_name_info ( struct seq_file * m , void * data ) ;

int drm_vm_info ( struct seq_file * m , void * data ) ;

int drm_queues_info ( struct seq_file * m , void * data ) ;

int drm_bufs_info ( struct seq_file * m , void * data ) ;

int drm_vblank_info ( struct seq_file * m , void * data ) ;

int drm_clients_info ( struct seq_file * m , void * data ) ;

int drm_gem_one_name_info ( int id , void * ptr , void * data ) ;

int drm_gem_name_info ( struct seq_file * m , void * data ) ;

int drm_gem_object_info ( struct seq_file * m , void * data ) ;

int drm_vma_info ( struct seq_file * m , void * data ) ;

int drm_debugfs_create_files ( struct drm_info_list * files , int count , struct dentry * root , struct drm_minor * minor ) ;

int drm_debugfs_init ( struct drm_minor * minor , int minor_id , struct dentry * root ) ;

int drm_debugfs_remove_files ( struct drm_info_list * files , int count , struct drm_minor * minor ) ;

int drm_debugfs_cleanup ( struct drm_minor * minor ) ;

int drm_i2c_encoder_init ( struct drm_device * dev , struct drm_encoder_slave * encoder , struct i2c_adapter * adap , const struct i2c_board_info * info ) ;

void drm_i2c_encoder_destroy ( struct drm_encoder * drm_encoder ) ;


typedef struct drm_version_32 { int version_major ; int version_minor ; int version_patchlevel ; u32 name_len ; u32 name ; u32 date_len ; u32 date ; u32 desc_len ; u32 desc ; } drm_version32_t ;


typedef struct drm_unique32 { u32 unique_len ; u32 unique ; } drm_unique32_t ;


typedef struct drm_map32 { u32 offset ; u32 size ; enum drm_map_type type ; enum drm_map_flags flags ; u32 handle ; int mtrr ; } drm_map32_t ;


typedef struct drm_client32 { int idx ; int auth ; u32 pid ; u32 uid ; u32 magic ; u32 iocs ; } drm_client32_t ;


typedef struct drm_stats32 { u32 count ; struct { u32 value ; enum drm_stat_type type ; } data [ 15 ] ; } drm_stats32_t ;


typedef struct drm_buf_desc32 { int count ; int size ; int low_mark ; int high_mark ; int flags ; u32 agp_start ; } drm_buf_desc32_t ;


typedef struct drm_buf_info32 { int count ; u32 list ; } drm_buf_info32_t ;


typedef struct drm_buf_pub32 { int idx ; int total ; int used ; u32 address ; } drm_buf_pub32_t ;


typedef struct drm_buf_map32 { int count ; u32 virtual ; u32 list ; } drm_buf_map32_t ;


typedef struct drm_buf_free32 { int count ; u32 list ; } drm_buf_free32_t ;


typedef struct drm_ctx_priv_map32 { unsigned int ctx_id ; u32 handle ; } drm_ctx_priv_map32_t ;


typedef struct drm_ctx_res32 { int count ; u32 contexts ; } drm_ctx_res32_t ;


typedef struct drm_dma32 { int context ; int send_count ; u32 send_indices ; u32 send_sizes ; enum drm_dma_flags flags ; int request_count ; int request_size ; u32 request_indices ; u32 request_sizes ; int granted_count ; } drm_dma32_t ;


typedef struct drm_agp_mode32 { u32 mode ; } drm_agp_mode32_t ;


typedef struct drm_agp_info32 { int agp_version_major ; int agp_version_minor ; u32 mode ; u32 aperture_base ; u32 aperture_size ; u32 memory_allowed ; u32 memory_used ; unsigned short id_vendor ; unsigned short id_device ; } drm_agp_info32_t ;


typedef struct drm_agp_buffer32 { u32 size ; u32 handle ; u32 type ; u32 physical ; } drm_agp_buffer32_t ;


typedef struct drm_agp_binding32 { u32 handle ; u32 offset ; } drm_agp_binding32_t ;


typedef struct drm_scatter_gather32 { u32 size ; u32 handle ; } drm_scatter_gather32_t ;


typedef struct drm_update_draw32 { drm_drawable_t handle ; unsigned int type ; unsigned int num ; u64 data ; } __attribute__ ( ( packed ) ) drm_update_draw32_t ;

struct drm_wait_vblank_request32 { enum drm_vblank_seq_type type ; unsigned int sequence ; u32 signal ; } ;

struct drm_wait_vblank_reply32 { enum drm_vblank_seq_type type ; unsigned int sequence ; s32 tval_sec ; s32 tval_usec ; } ;


typedef union drm_wait_vblank32 { struct drm_wait_vblank_request32 request ; struct drm_wait_vblank_reply32 reply ; } drm_wait_vblank32_t ;

long drm_compat_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) ;

int drm_fb_helper_add_connector ( struct drm_connector * connector ) ;

int drm_fb_helper_parse_command_line ( struct drm_device * dev ) ;

bool drm_fb_helper_force_kernel_mode ( void ) ;

int drm_fb_helper_panic ( struct notifier_block * n , unsigned long ununsed , void * panic_str ) ;

void drm_fb_helper_restore ( void ) ;

int drm_fb_helper_blank ( int blank , struct fb_info * info ) ;

int drm_fb_helper_init_crtc_count ( struct drm_fb_helper * helper , int crtc_count , int max_conn_count ) ;

int drm_fb_helper_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) ;

int drm_fb_helper_setcolreg ( unsigned regno , unsigned red , unsigned green , unsigned blue , unsigned transp , struct fb_info * info ) ;

int drm_fb_helper_check_var ( struct fb_var_screeninfo * var , struct fb_info * info ) ;

int drm_fb_helper_set_par ( struct fb_info * info ) ;

int drm_fb_helper_pan_display ( struct fb_var_screeninfo * var , struct fb_info * info ) ;

int drm_fb_helper_single_fb_probe ( struct drm_device * dev , int preferred_bpp , int ( * fb_create ) ( struct drm_device * dev , uint32_t fb_width , uint32_t fb_height , uint32_t surface_width , uint32_t surface_height , uint32_t surface_depth , uint32_t surface_bpp , struct drm_framebuffer * * fb_ptr ) ) ;

void drm_fb_helper_free ( struct drm_fb_helper * helper ) ;

void drm_fb_helper_fill_fix ( struct fb_info * info , uint32_t pitch , uint32_t depth ) ;

void drm_fb_helper_fill_var ( struct fb_info * info , struct drm_framebuffer * fb , uint32_t fb_width , uint32_t fb_height ) ;

int drm_helper_probe_single_connector_modes ( struct drm_connector * connector , uint32_t maxX , uint32_t maxY ) ;

int drm_helper_probe_connector_modes ( struct drm_device * dev , uint32_t maxX , uint32_t maxY ) ;

bool drm_helper_encoder_in_use ( struct drm_encoder * encoder ) ;

bool drm_helper_crtc_in_use ( struct drm_crtc * crtc ) ;

void drm_helper_disable_unused_functions ( struct drm_device * dev ) ;

bool drm_crtc_helper_set_mode ( struct drm_crtc * crtc , struct drm_display_mode * mode , int x , int y , struct drm_framebuffer * old_fb ) ;

int drm_crtc_helper_set_config ( struct drm_mode_set * set ) ;

bool drm_helper_plugged_event ( struct drm_device * dev ) ;

bool drm_helper_initial_config ( struct drm_device * dev ) ;

void drm_helper_connector_dpms ( struct drm_connector * connector , int mode ) ;

int drm_helper_hotplug_stage_two ( struct drm_device * dev ) ;

int drm_helper_mode_fill_fb_struct ( struct drm_framebuffer * fb , struct drm_mode_fb_cmd * mode_cmd ) ;

int drm_helper_resume_force_mode ( struct drm_device * dev ) ;

int i2c_dp_aux_add_bus ( struct i2c_adapter * adapter ) ;

struct vga_device { struct list_head list ; struct pci_dev * pdev ; unsigned int decodes ; unsigned int owns ; unsigned int locks ; unsigned int io_lock_cnt ; unsigned int mem_lock_cnt ; unsigned int io_norm_cnt ; unsigned int mem_norm_cnt ; void * cookie ; void ( * irq_set_state ) ( void * cookie , bool enable ) ; unsigned int ( * set_vga_decode ) ( void * cookie , bool decode ) ; } ;

struct pci_dev * vga_default_device ( void ) ;

int vga_get ( struct pci_dev * pdev , unsigned int rsrc , int interruptible ) ;

int vga_tryget ( struct pci_dev * pdev , unsigned int rsrc ) ;

void vga_put ( struct pci_dev * pdev , unsigned int rsrc ) ;

void __vga_set_legacy_decoding ( struct pci_dev * pdev , unsigned int decodes , bool userspace ) ;

void vga_set_legacy_decoding ( struct pci_dev * pdev , unsigned int decodes ) ;

int vga_client_register ( struct pci_dev * pdev , void * cookie , void ( * irq_set_state ) ( void * cookie , bool state ) , unsigned int ( * set_vga_decode ) ( void * cookie , bool decode ) ) ;

struct vga_arb_user_card { struct pci_dev * pdev ; unsigned int mem_cnt ; unsigned int io_cnt ; } ;

struct vga_arb_private { struct list_head list ; struct pci_dev * target ; struct vga_arb_user_card cards [ 16 ] ; spinlock_t lock ; } ;

struct device * hwmon_device_register ( struct device * dev ) ;

void hwmon_device_unregister ( struct device * dev ) ;

struct i2c_devinfo { struct list_head list ; int busnum ; struct i2c_board_info board_info ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) i2c_register_board_info ( int busnum , struct i2c_board_info const * info , unsigned len ) ;

struct i2c_client * i2c_verify_client ( struct device * dev ) ;

struct i2c_client * i2c_new_device ( struct i2c_adapter * adap , struct i2c_board_info const * info ) ;

void i2c_unregister_device ( struct i2c_client * client ) ;

struct i2c_client * i2c_new_dummy ( struct i2c_adapter * adapter , u16 address ) ;

int i2c_add_adapter ( struct i2c_adapter * adapter ) ;

int i2c_add_numbered_adapter ( struct i2c_adapter * adap ) ;

int i2c_del_adapter ( struct i2c_adapter * adap ) ;

int i2c_register_driver ( struct module * owner , struct i2c_driver * driver ) ;

void i2c_del_driver ( struct i2c_driver * driver ) ;

struct i2c_client * i2c_use_client ( struct i2c_client * client ) ;

void i2c_release_client ( struct i2c_client * client ) ;

struct i2c_cmd_arg { unsigned cmd ; void * arg ; } ;

void i2c_clients_command ( struct i2c_adapter * adap , unsigned int cmd , void * arg ) ;

int i2c_transfer ( struct i2c_adapter * adap , struct i2c_msg * msgs , int num ) ;

int i2c_master_send ( struct i2c_client * client , const char * buf , int count ) ;

int i2c_master_recv ( struct i2c_client * client , char * buf , int count ) ;

struct i2c_client * i2c_new_probed_device ( struct i2c_adapter * adap , struct i2c_board_info * info , unsigned short const * addr_list ) ;

struct i2c_adapter * i2c_get_adapter ( int id ) ;

void i2c_put_adapter ( struct i2c_adapter * adap ) ;

s32 i2c_smbus_read_byte ( struct i2c_client * client ) ;

s32 i2c_smbus_write_byte ( struct i2c_client * client , u8 value ) ;

s32 i2c_smbus_read_byte_data ( struct i2c_client * client , u8 command ) ;

s32 i2c_smbus_write_byte_data ( struct i2c_client * client , u8 command , u8 value ) ;

s32 i2c_smbus_read_word_data ( struct i2c_client * client , u8 command ) ;

s32 i2c_smbus_write_word_data ( struct i2c_client * client , u8 command , u16 value ) ;

s32 i2c_smbus_process_call ( struct i2c_client * client , u8 command , u16 value ) ;

s32 i2c_smbus_read_block_data ( struct i2c_client * client , u8 command , u8 * values ) ;

s32 i2c_smbus_write_block_data ( struct i2c_client * client , u8 command , u8 length , const u8 * values ) ;

s32 i2c_smbus_read_i2c_block_data ( struct i2c_client * client , u8 command , u8 length , u8 * values ) ;

s32 i2c_smbus_write_i2c_block_data ( struct i2c_client * client , u8 command , u8 length , const u8 * values ) ;

s32 i2c_smbus_xfer ( struct i2c_adapter * adapter , u16 addr , unsigned short flags , char read_write , u8 command , int protocol , union i2c_smbus_data * data ) ;

int i2c_bit_add_bus ( struct i2c_adapter * adap ) ;

int i2c_bit_add_numbered_bus ( struct i2c_adapter * adap ) ;

void input_event ( struct input_dev * dev , unsigned int type , unsigned int code , int value ) ;
void input_inject_event ( struct input_handle * handle , unsigned int type , unsigned int code , int value ) ;

int input_grab_device ( struct input_handle * handle ) ;

void input_release_device ( struct input_handle * handle ) ;

int input_filter_device ( struct input_handle * handle ) ;

void input_unfilter_device ( struct input_handle * handle ) ;

int input_open_device ( struct input_handle * handle ) ;

int input_flush_device ( struct input_handle * handle , struct file * file ) ;

void input_close_device ( struct input_handle * handle ) ;

int input_get_keycode ( struct input_dev * dev , int scancode , int * keycode ) ;

int input_set_keycode ( struct input_dev * dev , int scancode , int keycode ) ;

union input_seq_state { struct { unsigned short pos ; bool mutex_acquired ; } ; void * p ; } ;

struct input_dev * input_allocate_device ( void ) ;

void input_free_device ( struct input_dev * dev ) ;

void input_set_capability ( struct input_dev * dev , unsigned int type , unsigned int code ) ;

int input_register_device ( struct input_dev * dev ) ;

void input_unregister_device ( struct input_dev * dev ) ;

int input_register_handler ( struct input_handler * handler ) ;

void input_unregister_handler ( struct input_handler * handler ) ;

int input_register_handle ( struct input_handle * handle ) ;

void input_unregister_handle ( struct input_handle * handle ) ;

struct input_event_compat { struct compat_timeval time ; __u16 type ; __u16 code ; __s32 value ; } ;

struct ff_periodic_effect_compat { __u16 waveform ; __u16 period ; __s16 magnitude ; __s16 offset ; __u16 phase ; struct ff_envelope envelope ; __u32 custom_len ; compat_uptr_t custom_data ; } ;

struct ff_effect_compat { __u16 type ; __s16 id ; __u16 direction ; struct ff_trigger trigger ; struct ff_replay replay ; union { struct ff_constant_effect constant ; struct ff_ramp_effect ramp ; struct ff_periodic_effect_compat periodic ; struct ff_condition_effect condition [ 2 ] ; struct ff_rumble_effect rumble ; } u ; } ;

int input_event_from_user ( const char * buffer , struct input_event * event ) ;

int input_event_to_user ( char * buffer , const struct input_event * event ) ;

int input_ff_effect_from_user ( const char * buffer , size_t size , struct ff_effect * effect ) ;

int input_ff_upload ( struct input_dev * dev , struct ff_effect * effect , struct file * file ) ;

int input_ff_erase ( struct input_dev * dev , int effect_id , struct file * file ) ;

int input_ff_event ( struct input_dev * dev , unsigned int type , unsigned int code , int value ) ;

int input_ff_create ( struct input_dev * dev , int max_effects ) ;

void input_ff_destroy ( struct input_dev * dev ) ;

struct mousedev_hw_data { int dx , dy , dz ; int x , y ; int abs_event ; unsigned long buttons ; } ;

struct mousedev { int exist ; int open ; int minor ; struct input_handle handle ; wait_queue_head_t wait ; struct list_head client_list ; spinlock_t client_lock ; struct mutex mutex ; struct device dev ; struct list_head mixdev_node ; int mixdev_open ; struct mousedev_hw_data packet ; unsigned int pkt_count ; int old_x [ 4 ] , old_y [ 4 ] ; int frac_dx , frac_dy ; unsigned long touch ; } ;

enum mousedev_emul { MOUSEDEV_EMUL_PS2 , MOUSEDEV_EMUL_IMPS , MOUSEDEV_EMUL_EXPS } ;

struct mousedev_motion { int dx , dy , dz ; unsigned long buttons ; } ;

struct mousedev_client { struct fasync_struct * fasync ; struct mousedev * mousedev ; struct list_head node ; struct mousedev_motion packets [ 16 ] ; unsigned int head , tail ; spinlock_t packet_lock ; int pos_x , pos_y ; signed char ps2 [ 6 ] ; unsigned char ready , buffer , bufsiz ; unsigned char imexseq , impsseq ; enum mousedev_emul mode ; unsigned long last_buttons ; } ;

struct evdev { int exist ; int open ; int minor ; struct input_handle handle ; wait_queue_head_t wait ; struct evdev_client * grab ; struct list_head client_list ; spinlock_t client_lock ; struct mutex mutex ; struct device dev ; } ;

struct evdev_client { struct input_event buffer [ 64 ] ; int head ; int tail ; spinlock_t buffer_lock ; struct fasync_struct * fasync ; struct evdev * evdev ; struct list_head node ; } ;

struct serio { void * port_data ; char name [ 32 ] ; char phys [ 32 ] ; bool manual_bind ; bool registered ; struct serio_device_id id ; spinlock_t lock ; int ( * write ) ( struct serio * , unsigned char ) ; int ( * open ) ( struct serio * ) ; void ( * close ) ( struct serio * ) ; int ( * start ) ( struct serio * ) ; void ( * stop ) ( struct serio * ) ; struct serio * parent , * child ; unsigned int depth ; struct serio_driver * drv ; struct mutex drv_mutex ; struct device dev ; struct list_head node ; } ;

struct serio_driver { void * private ; char * description ; struct serio_device_id * id_table ; bool manual_bind ; void ( * write_wakeup ) ( struct serio * ) ; irqreturn_t ( * interrupt ) ( struct serio * , unsigned char , unsigned int ) ; int ( * connect ) ( struct serio * , struct serio_driver * drv ) ; int ( * reconnect ) ( struct serio * ) ; void ( * disconnect ) ( struct serio * ) ; void ( * cleanup ) ( struct serio * ) ; struct device_driver driver ; } ;

struct ps2dev { struct serio * serio ; struct mutex cmd_mutex ; wait_queue_head_t wait ; unsigned long flags ; unsigned char cmdbuf [ 6 ] ; unsigned char cmdcnt ; unsigned char nak ; } ;

struct atkbd { struct ps2dev ps2dev ; struct input_dev * dev ; char name [ 64 ] ; char phys [ 32 ] ; unsigned short id ; unsigned short keycode [ 512 ] ; unsigned long force_release_mask [ ( ( ( 512 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; unsigned char set ; unsigned char translated ; unsigned char extra ; unsigned char write ; unsigned char softrepeat ; unsigned char softraw ; unsigned char scroll ; unsigned char enabled ; unsigned char emul ; unsigned char resend ; unsigned char release ; unsigned long xl_bit ; unsigned int last ; unsigned long time ; unsigned long err_count ; struct delayed_work event_work ; unsigned long event_jiffies ; struct mutex event_mutex ; unsigned long event_mask ; } ;

enum psmouse_state { PSMOUSE_IGNORE , PSMOUSE_INITIALIZING , PSMOUSE_RESYNCING , PSMOUSE_CMD_MODE , PSMOUSE_ACTIVATED , } ;

typedef enum { PSMOUSE_BAD_DATA , PSMOUSE_GOOD_DATA , PSMOUSE_FULL_PACKET } psmouse_ret_t ;

struct psmouse { void * private ; struct input_dev * dev ; struct ps2dev ps2dev ; struct delayed_work resync_work ; char * vendor ; char * name ; unsigned char packet [ 8 ] ; unsigned char badbyte ; unsigned char pktcnt ; unsigned char pktsize ; unsigned char type ; bool acks_disable_command ; unsigned int model ; unsigned long last ; unsigned long out_of_sync_cnt ; unsigned long num_resyncs ; enum psmouse_state state ; char devname [ 64 ] ; char phys [ 32 ] ; unsigned int rate ; unsigned int resolution ; unsigned int resetafter ; unsigned int resync_time ; bool smartscroll ; psmouse_ret_t ( * protocol_handler ) ( struct psmouse * psmouse ) ; void ( * set_rate ) ( struct psmouse * psmouse , unsigned int rate ) ; void ( * set_resolution ) ( struct psmouse * psmouse , unsigned int resolution ) ; int ( * reconnect ) ( struct psmouse * psmouse ) ; void ( * disconnect ) ( struct psmouse * psmouse ) ; void ( * cleanup ) ( struct psmouse * psmouse ) ; int ( * poll ) ( struct psmouse * psmouse ) ; void ( * pt_activate ) ( struct psmouse * psmouse ) ; void ( * pt_deactivate ) ( struct psmouse * psmouse ) ; } ;

enum psmouse_type { PSMOUSE_NONE , PSMOUSE_PS2 , PSMOUSE_PS2PP , PSMOUSE_THINKPS , PSMOUSE_GENPS , PSMOUSE_IMPS , PSMOUSE_IMEX , PSMOUSE_SYNAPTICS , PSMOUSE_ALPS , PSMOUSE_LIFEBOOK , PSMOUSE_TRACKPOINT , PSMOUSE_TOUCHKIT_PS2 , PSMOUSE_CORTRON , PSMOUSE_HGPK , PSMOUSE_ELANTECH , PSMOUSE_FSP , PSMOUSE_AUTO } ;

struct psmouse_attribute { struct device_attribute dattr ; void * data ; ssize_t ( * show ) ( struct psmouse * psmouse , void * data , char * buf ) ; ssize_t ( * set ) ( struct psmouse * psmouse , void * data , const char * buf , size_t count ) ; bool protect ; } ;

struct synaptics_hw_state { int x ; int y ; int z ; int w ; unsigned int left : 1 ; unsigned int right : 1 ; unsigned int middle : 1 ; unsigned int up : 1 ; unsigned int down : 1 ; unsigned char ext_buttons ; signed char scroll ; } ;

struct synaptics_data { unsigned long int model_id ; unsigned long int capabilities ; unsigned long int ext_cap ; unsigned long int identity ; int x_res ; int y_res ; unsigned char pkt_type ; unsigned char mode ; int scroll ; struct synaptics_hw_state prev_hw ; } ;

struct alps_model_info { unsigned char signature [ 3 ] ; unsigned char byte0 , mask0 ; unsigned char flags ; } ;

struct alps_data { struct input_dev * dev2 ; char phys [ 32 ] ; const struct alps_model_info * i ; int prev_fin ; struct timer_list timer ; } ;

enum hgpk_model_t { HGPK_MODEL_PREA = 0x0a , HGPK_MODEL_A = 0x14 , HGPK_MODEL_B = 0x28 , HGPK_MODEL_C = 0x3c , HGPK_MODEL_D = 0x50 , } ;

struct hgpk_data { struct psmouse * psmouse ; bool powered ; int count , x_tally , y_tally ; unsigned long recalib_window ; struct delayed_work recalib_wq ; } ;

struct trackpoint_data { unsigned char sensitivity , speed , inertia , reach ; unsigned char draghys , mindrag ; unsigned char thresh , upthresh ; unsigned char ztime , jenks ; unsigned char press_to_select ; unsigned char skipback ; unsigned char ext_dev ; } ;

struct elantech_data { unsigned char reg_10 ; unsigned char reg_11 ; unsigned char reg_20 ; unsigned char reg_21 ; unsigned char reg_22 ; unsigned char reg_23 ; unsigned char reg_24 ; unsigned char reg_25 ; unsigned char reg_26 ; unsigned char debug ; unsigned char capabilities ; unsigned char fw_version_maj ; unsigned char fw_version_min ; unsigned char hw_version ; unsigned char paritycheck ; unsigned char jumpy_cursor ; unsigned char parity [ 256 ] ; } ;

struct fsp_data { unsigned char ver ; unsigned char rev ; unsigned char buttons ; unsigned int flags ; bool vscroll ; bool hscroll ; unsigned char last_reg ; unsigned char last_val ; } ;

struct psmouse_protocol { enum psmouse_type type ; bool maxproto ; const char * name ; const char * alias ; int ( * detect ) ( struct psmouse * , bool ) ; int ( * init ) ( struct psmouse * ) ; } ;

void psmouse_queue_work ( struct psmouse * psmouse , struct delayed_work * work , unsigned long delay ) ;

void psmouse_set_state ( struct psmouse * psmouse , enum psmouse_state new_state ) ;

int psmouse_sliced_command ( struct psmouse * psmouse , unsigned char command ) ;

int psmouse_reset ( struct psmouse * psmouse ) ;

void psmouse_set_resolution ( struct psmouse * psmouse , unsigned int resolution ) ;

ssize_t psmouse_attr_show_helper ( struct device * dev , struct device_attribute * devattr , char * buf ) ;

ssize_t psmouse_attr_set_helper ( struct device * dev , struct device_attribute * devattr , const char * buf , size_t count ) ;

int synaptics_detect ( struct psmouse * psmouse , bool set_properties ) ;

void synaptics_reset ( struct psmouse * psmouse ) ;

int synaptics_init ( struct psmouse * psmouse ) ;

int alps_init ( struct psmouse * psmouse ) ;

int alps_detect ( struct psmouse * psmouse , bool set_properties ) ;

struct elantech_attr_data { size_t field_offset ; unsigned char reg ; } ;

int elantech_detect ( struct psmouse * psmouse , bool set_properties ) ;

int elantech_init ( struct psmouse * psmouse ) ;

struct ps2pp_info { u8 model ; u8 kind ; u16 features ; } ;

int ps2pp_init ( struct psmouse * psmouse , bool set_properties ) ;

struct lifebook_data { struct input_dev * dev2 ; char phys [ 32 ] ; } ;

int lifebook_detect ( struct psmouse * psmouse , bool set_properties ) ;

int lifebook_init ( struct psmouse * psmouse ) ;

int fsp_detect ( struct psmouse * psmouse , bool set_properties ) ;

int fsp_init ( struct psmouse * psmouse ) ;

struct trackpoint_attr_data { size_t field_offset ; unsigned char command ; unsigned char mask ; unsigned char inverted ; } ;

int trackpoint_detect ( struct psmouse * psmouse , bool set_properties ) ;

enum serio_event_type { SERIO_RESCAN_PORT , SERIO_RECONNECT_PORT , SERIO_RECONNECT_CHAIN , SERIO_REGISTER_PORT , SERIO_ATTACH_DRIVER , } ;

struct serio_event { enum serio_event_type type ; void * object ; struct module * owner ; struct list_head node ; } ;

void serio_rescan ( struct serio * serio ) ;

void serio_reconnect ( struct serio * serio ) ;

void __serio_register_port ( struct serio * serio , struct module * owner ) ;

void serio_unregister_port ( struct serio * serio ) ;

void serio_unregister_child_port ( struct serio * serio ) ;

int __serio_register_driver ( struct serio_driver * drv , struct module * owner , const char * mod_name ) ;

void serio_unregister_driver ( struct serio_driver * drv ) ;

int serio_open ( struct serio * serio , struct serio_driver * drv ) ;

void serio_close ( struct serio * serio ) ;

irqreturn_t serio_interrupt ( struct serio * serio , unsigned char data , unsigned int dfl ) ;

struct serio ;
struct i8042_port { struct serio * serio ; int irq ; bool exists ; signed char mux ; } ;

void i8042_lock_chip ( void ) ;

void i8042_unlock_chip ( void ) ;

int i8042_command ( unsigned char * param , int command ) ;

bool i8042_check_port_owner ( const struct serio * port ) ;

; ; ; int ps2_sendbyte ( struct ps2dev * ps2dev , unsigned char byte , int timeout ) ;

void ps2_begin_command ( struct ps2dev * ps2dev ) ;

void ps2_end_command ( struct ps2dev * ps2dev ) ;

void ps2_drain ( struct ps2dev * ps2dev , int maxbytes , int timeout ) ;

int ps2_is_keyboard_id ( char id_byte ) ;

int __ps2_command ( struct ps2dev * ps2dev , unsigned char * param , int command ) ;

int ps2_command ( struct ps2dev * ps2dev , unsigned char * param , int command ) ;

void ps2_init ( struct ps2dev * ps2dev , struct serio * serio ) ;

int ps2_handle_ack ( struct ps2dev * ps2dev , unsigned char data ) ;

int ps2_handle_response ( struct ps2dev * ps2dev , unsigned char data ) ;

void ps2_cmd_aborted ( struct ps2dev * ps2dev ) ;

struct serio_raw { unsigned char queue [ 64 ] ; unsigned int tail , head ; char name [ 16 ] ; unsigned int refcnt ; struct serio * serio ; struct miscdevice dev ; wait_queue_head_t wait ; struct list_head list ; struct list_head node ; } ;

struct serio_raw_list { struct fasync_struct * fasync ; struct serio_raw * serio_raw ; struct list_head node ; } ;

ssize_t led_trigger_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) ;

ssize_t led_trigger_show ( struct device * dev , struct device_attribute * attr , char * buf ) ;

void led_trigger_set ( struct led_classdev * led_cdev , struct led_trigger * trigger ) ;

void led_trigger_remove ( struct led_classdev * led_cdev ) ;

void led_trigger_set_default ( struct led_classdev * led_cdev ) ;

int led_trigger_register ( struct led_trigger * trigger ) ;

void led_trigger_unregister ( struct led_trigger * trigger ) ;

void led_trigger_event ( struct led_trigger * trigger , enum led_brightness brightness ) ;

void led_trigger_register_simple ( const char * name , struct led_trigger * * tp ) ;

void led_trigger_unregister_simple ( struct led_trigger * trigger ) ;

int mac_hid_mouse_emulate_buttons ( int caller , unsigned int keycode , int down ) ;

struct dm_bio_vec_details { __u16 bv_len ; __u16 bv_offset ; } ;

struct dm_bio_details { sector_t bi_sector ; struct block_device * bi_bdev ; unsigned int bi_size ; unsigned short bi_idx ; unsigned long bi_flags ; struct dm_bio_vec_details bi_io_vec [ 256 ] ; } ;

struct dm_dev ;

struct dm_target ;

struct dm_table ;

struct mapped_device ;

typedef enum { STATUSTYPE_INFO , STATUSTYPE_TABLE } status_type_t ;

union map_info { void * ptr ; unsigned long long ll ; unsigned flush_request ; } ;

typedef int ( * dm_ctr_fn ) ( struct dm_target * target , unsigned int argc , char * * argv ) ;
typedef void ( * dm_dtr_fn ) ( struct dm_target * ti ) ;
typedef int ( * dm_map_fn ) ( struct dm_target * ti , struct bio * bio , union map_info * map_context ) ;
typedef int ( * dm_map_request_fn ) ( struct dm_target * ti , struct request * clone , union map_info * map_context ) ;
typedef int ( * dm_endio_fn ) ( struct dm_target * ti , struct bio * bio , int error , union map_info * map_context ) ;
typedef int ( * dm_request_endio_fn ) ( struct dm_target * ti , struct request * clone , int error , union map_info * map_context ) ;
typedef void ( * dm_flush_fn ) ( struct dm_target * ti ) ;
typedef void ( * dm_presuspend_fn ) ( struct dm_target * ti ) ;
typedef void ( * dm_postsuspend_fn ) ( struct dm_target * ti ) ;
typedef int ( * dm_preresume_fn ) ( struct dm_target * ti ) ;
typedef void ( * dm_resume_fn ) ( struct dm_target * ti ) ;
typedef int ( * dm_status_fn ) ( struct dm_target * ti , status_type_t status_type , char * result , unsigned int maxlen ) ;
typedef int ( * dm_message_fn ) ( struct dm_target * ti , unsigned argc , char * * argv ) ;
typedef int ( * dm_ioctl_fn ) ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) ;
typedef int ( * dm_merge_fn ) ( struct dm_target * ti , struct bvec_merge_data * bvm , struct bio_vec * biovec , int max_size ) ;
typedef int ( * iterate_devices_callout_fn ) ( struct dm_target * ti , struct dm_dev * dev , sector_t start , sector_t len , void * data ) ;
typedef int ( * dm_iterate_devices_fn ) ( struct dm_target * ti , iterate_devices_callout_fn fn , void * data ) ;
typedef void ( * dm_io_hints_fn ) ( struct dm_target * ti , struct queue_limits * limits ) ;
typedef int ( * dm_busy_fn ) ( struct dm_target * ti ) ;
struct dm_dev { struct block_device * bdev ; fmode_t mode ; char name [ 16 ] ; } ;
struct target_type { uint64_t features ; const char * name ; struct module * module ; unsigned version [ 3 ] ; dm_ctr_fn ctr ; dm_dtr_fn dtr ; dm_map_fn map ; dm_map_request_fn map_rq ; dm_endio_fn end_io ; dm_request_endio_fn rq_end_io ; dm_flush_fn flush ; dm_presuspend_fn presuspend ; dm_postsuspend_fn postsuspend ; dm_preresume_fn preresume ; dm_resume_fn resume ; dm_status_fn status ; dm_message_fn message ; dm_ioctl_fn ioctl ; dm_merge_fn merge ; dm_busy_fn busy ; dm_iterate_devices_fn iterate_devices ; dm_io_hints_fn io_hints ; struct list_head list ; } ;

struct dm_target { struct dm_table * table ; struct target_type * type ; sector_t begin ; sector_t len ; sector_t split_io ; unsigned num_flush_requests ; void * private ; char * error ; } ;
struct dm_io_region { struct block_device * bdev ; sector_t sector ; sector_t count ; } ;

struct page_list { struct page_list * next ; struct page * page ; } ;

typedef void ( * io_notify_fn ) ( unsigned long error , void * context ) ;
enum dm_io_mem_type { DM_IO_PAGE_LIST , DM_IO_BVEC , DM_IO_VMA , DM_IO_KMEM , } ;

struct dm_io_memory { enum dm_io_mem_type type ; union { struct page_list * pl ; struct bio_vec * bvec ; void * vma ; void * addr ; } ptr ; unsigned offset ; } ;

struct dm_io_notify { io_notify_fn fn ; void * context ; } ;

struct dm_io_client ;

struct dm_io_request { int bi_rw ; struct dm_io_memory mem ; struct dm_io_notify notify ; struct dm_io_client * client ; } ;

typedef sector_t region_t ;

struct dm_dirty_log_type ;

struct dm_dirty_log { struct dm_dirty_log_type * type ; void * context ; } ;

struct dm_dirty_log_type { const char * name ; struct module * module ; struct list_head list ; int ( * ctr ) ( struct dm_dirty_log * log , struct dm_target * ti , unsigned argc , char * * argv ) ; void ( * dtr ) ( struct dm_dirty_log * log ) ; int ( * presuspend ) ( struct dm_dirty_log * log ) ; int ( * postsuspend ) ( struct dm_dirty_log * log ) ; int ( * resume ) ( struct dm_dirty_log * log ) ; uint32_t ( * get_region_size ) ( struct dm_dirty_log * log ) ; int ( * is_clean ) ( struct dm_dirty_log * log , region_t region ) ; int ( * in_sync ) ( struct dm_dirty_log * log , region_t region , int can_block ) ; int ( * flush ) ( struct dm_dirty_log * log ) ; void ( * mark_region ) ( struct dm_dirty_log * log , region_t region ) ; void ( * clear_region ) ( struct dm_dirty_log * log , region_t region ) ; int ( * get_resync_work ) ( struct dm_dirty_log * log , region_t * region ) ; void ( * set_region_sync ) ( struct dm_dirty_log * log , region_t region , int in_sync ) ; region_t ( * get_sync_count ) ( struct dm_dirty_log * log ) ; int ( * status ) ( struct dm_dirty_log * log , status_type_t status_type , char * result , unsigned maxlen ) ; int ( * is_remote_recovering ) ( struct dm_dirty_log * log , region_t region ) ; } ;
struct dm_kcopyd_client ;

typedef void ( * dm_kcopyd_notify_fn ) ( int read_err , unsigned long write_err , void * context ) ;
struct dm_region_hash ;

struct dm_region ;

enum dm_rh_region_states { DM_RH_CLEAN = 0x01 , DM_RH_DIRTY = 0x02 , DM_RH_NOSYNC = 0x04 , DM_RH_RECOVERING = 0x08 , } ;

struct bio_list ;
enum dm_raid1_error { DM_RAID1_WRITE_ERROR , DM_RAID1_SYNC_ERROR , DM_RAID1_READ_ERROR } ;

struct mirror { struct mirror_set * ms ; atomic_t error_count ; unsigned long error_type ; struct dm_dev * dev ; sector_t offset ; } ;

struct mirror_set { struct dm_target * ti ; struct list_head list ; uint64_t features ; spinlock_t lock ; struct bio_list reads ; struct bio_list writes ; struct bio_list failures ; struct dm_region_hash * rh ; struct dm_kcopyd_client * kcopyd_client ; struct dm_io_client * io_client ; mempool_t * read_record_pool ; region_t nr_regions ; int in_sync ; int log_failure ; atomic_t suspend ; atomic_t default_mirror ; struct workqueue_struct * kmirrord_wq ; struct work_struct kmirrord_work ; struct timer_list timer ; unsigned long timer_pending ; struct work_struct trigger_event ; unsigned nr_mirrors ; struct mirror mirror [ 0 ] ; } ;

struct dm_raid1_read_record { struct mirror * m ; struct dm_bio_details details ; } ;

struct dm_ioctl { __u32 version [ 3 ] ; __u32 data_size ; __u32 data_start ; __u32 target_count ; __s32 open_count ; __u32 flags ; __u32 event_nr ; __u32 padding ; __u64 dev ; char name [ 128 ] ; char uuid [ 129 ] ; char data [ 7 ] ; } ;

struct dm_target_spec { __u64 sector_start ; __u64 length ; __s32 status ; __u32 next ; char target_type [ 16 ] ; } ;

struct dm_target_deps { __u32 count ; __u32 padding ; __u64 dev [ 0 ] ; } ;

struct dm_name_list { __u64 dev ; __u32 next ; char name [ 0 ] ; } ;

struct dm_target_versions { __u32 next ; __u32 version [ 3 ] ; char name [ 0 ] ; } ;

struct dm_target_msg { __u64 sector ; char message [ 0 ] ; } ;

enum { DM_VERSION_CMD = 0 , DM_REMOVE_ALL_CMD , DM_LIST_DEVICES_CMD , DM_DEV_CREATE_CMD , DM_DEV_REMOVE_CMD , DM_DEV_RENAME_CMD , DM_DEV_SUSPEND_CMD , DM_DEV_STATUS_CMD , DM_DEV_WAIT_CMD , DM_TABLE_LOAD_CMD , DM_TABLE_CLEAR_CMD , DM_TABLE_DEPS_CMD , DM_TABLE_STATUS_CMD , DM_LIST_VERSIONS_CMD , DM_TARGET_MSG_CMD , DM_DEV_SET_GEOMETRY_CMD } ;
struct dm_dev_internal { struct list_head list ; atomic_t count ; struct dm_dev dm_dev ; } ;

struct dm_md_mempools ;

enum dm_uevent_type { DM_UEVENT_PATH_FAILED , DM_UEVENT_PATH_REINSTATED , } ;

struct dm_uevent { struct mapped_device * md ; enum kobject_action action ; struct kobj_uevent_env ku_env ; struct list_head elist ; char name [ 128 ] ; char uuid [ 129 ] ; } ;

void dm_send_uevents ( struct list_head * events , struct kobject * kobj ) ;

void dm_path_uevent ( enum dm_uevent_type event_type , struct dm_target * ti , const char * path , unsigned nr_valid_paths ) ;

int dm_uevent_init ( void ) ;

void dm_uevent_exit ( void ) ;

struct dm_io { struct mapped_device * md ; int error ; atomic_t io_count ; struct bio * bio ; unsigned long start_time ; spinlock_t endio_lock ; } ;

struct dm_target_io { struct dm_io * io ; struct dm_target * ti ; union map_info info ; } ;

struct dm_rq_target_io { struct mapped_device * md ; struct dm_target * ti ; struct request * orig , clone ; int error ; union map_info info ; } ;

struct dm_rq_clone_bio_info { struct bio * orig ; struct dm_rq_target_io * tio ; } ;

union map_info * dm_get_mapinfo ( struct bio * bio ) ;

union map_info * dm_get_rq_mapinfo ( struct request * rq ) ;

struct mapped_device { struct rw_semaphore io_lock ; struct mutex suspend_lock ; rwlock_t map_lock ; atomic_t holders ; atomic_t open_count ; unsigned long flags ; struct request_queue * queue ; struct gendisk * disk ; char name [ 16 ] ; void * interface_ptr ; atomic_t pending [ 2 ] ; wait_queue_head_t wait ; struct work_struct work ; struct bio_list deferred ; spinlock_t deferred_lock ; int barrier_error ; struct workqueue_struct * wq ; struct dm_table * map ; mempool_t * io_pool ; mempool_t * tio_pool ; struct bio_set * bs ; atomic_t event_nr ; wait_queue_head_t eventq ; atomic_t uevent_seq ; struct list_head uevent_list ; spinlock_t uevent_lock ; struct super_block * frozen_sb ; struct block_device * bdev ; struct hd_geometry geometry ; struct request suspend_rq ; make_request_fn * saved_make_request_fn ; struct kobject kobj ; struct bio barrier_bio ; } ;
struct dm_md_mempools { mempool_t * io_pool ; mempool_t * tio_pool ; struct bio_set * bs ; } ;
int dm_open_count ( struct mapped_device * md ) ;

int dm_lock_for_deletion ( struct mapped_device * md ) ;

struct dm_table * dm_get_table ( struct mapped_device * md ) ;

int dm_get_geometry ( struct mapped_device * md , struct hd_geometry * geo ) ;

int dm_set_geometry ( struct mapped_device * md , struct hd_geometry * geo ) ;

void dm_requeue_unmapped_request ( struct request * clone ) ;

void dm_kill_unmapped_request ( struct request * clone , int error ) ;

struct clone_info { struct mapped_device * md ; struct dm_table * map ; struct bio * bio ; struct dm_io * io ; sector_t sector ; sector_t sector_count ; unsigned short idx ; } ;

void dm_dispatch_request ( struct request * rq ) ;

int dm_underlying_device_busy ( struct request_queue * q ) ;

int dm_create ( int minor , struct mapped_device * * result ) ;

struct mapped_device * dm_get_md ( dev_t dev ) ;

void * dm_get_mdptr ( struct mapped_device * md ) ;

void dm_set_mdptr ( struct mapped_device * md , void * ptr ) ;

void dm_get ( struct mapped_device * md ) ;

const char * dm_device_name ( struct mapped_device * md ) ;

void dm_put ( struct mapped_device * md ) ;

int dm_swap_table ( struct mapped_device * md , struct dm_table * table ) ;

int dm_suspend ( struct mapped_device * md , unsigned suspend_flags ) ;

int dm_resume ( struct mapped_device * md ) ;

void dm_kobject_uevent ( struct mapped_device * md , enum kobject_action action , unsigned cookie ) ;

uint32_t dm_next_uevent_seq ( struct mapped_device * md ) ;

uint32_t dm_get_event_nr ( struct mapped_device * md ) ;

int dm_wait_event ( struct mapped_device * md , int event_nr ) ;

void dm_uevent_add ( struct mapped_device * md , struct list_head * elist ) ;

struct gendisk * dm_disk ( struct mapped_device * md ) ;

struct kobject * dm_kobject ( struct mapped_device * md ) ;

struct mapped_device * dm_get_from_kobject ( struct kobject * kobj ) ;

int dm_suspended ( struct mapped_device * md ) ;

int dm_noflush_suspending ( struct dm_target * ti ) ;

struct dm_md_mempools * dm_alloc_md_mempools ( unsigned type ) ;

void dm_free_md_mempools ( struct dm_md_mempools * pools ) ;

struct dm_table { struct mapped_device * md ; atomic_t holders ; unsigned type ; unsigned int depth ; unsigned int counts [ 16 ] ; sector_t * index [ 16 ] ; unsigned int num_targets ; unsigned int num_allocated ; sector_t * highs ; struct dm_target * targets ; fmode_t mode ; struct list_head devices ; void ( * event_fn ) ( void * ) ; void * event_context ; struct dm_md_mempools * mempools ; } ;
void * dm_vcalloc ( unsigned long nmemb , unsigned long elem_size ) ;

int dm_table_create ( struct dm_table * * result , fmode_t mode , unsigned num_targets , struct mapped_device * md ) ;

void dm_table_destroy ( struct dm_table * t ) ;

void dm_table_get ( struct dm_table * t ) ;

void dm_table_put ( struct dm_table * t ) ;

int dm_set_device_limits ( struct dm_target * ti , struct dm_dev * dev , sector_t start , sector_t len , void * data ) ;

int dm_get_device ( struct dm_target * ti , const char * path , sector_t start , sector_t len , fmode_t mode , struct dm_dev * * result ) ;

void dm_put_device ( struct dm_target * ti , struct dm_dev * d ) ;

int dm_split_args ( int * argc , char * * * argvp , char * input ) ;

int dm_table_add_target ( struct dm_table * t , const char * type , sector_t start , sector_t len , char * params ) ;

int dm_table_set_type ( struct dm_table * t ) ;

unsigned dm_table_get_type ( struct dm_table * t ) ;

bool dm_table_request_based ( struct dm_table * t ) ;

int dm_table_alloc_md_mempools ( struct dm_table * t ) ;

void dm_table_free_md_mempools ( struct dm_table * t ) ;

struct dm_md_mempools * dm_table_get_md_mempools ( struct dm_table * t ) ;

int dm_table_complete ( struct dm_table * t ) ;

void dm_table_event_callback ( struct dm_table * t , void ( * fn ) ( void * ) , void * context ) ;

void dm_table_event ( struct dm_table * t ) ;

sector_t dm_table_get_size ( struct dm_table * t ) ;

struct dm_target * dm_table_get_target ( struct dm_table * t , unsigned int index ) ;

struct dm_target * dm_table_find_target ( struct dm_table * t , sector_t sector ) ;

int dm_calculate_queue_limits ( struct dm_table * table , struct queue_limits * limits ) ;

void dm_table_set_restrictions ( struct dm_table * t , struct request_queue * q , struct queue_limits * limits ) ;

unsigned int dm_table_get_num_targets ( struct dm_table * t ) ;

struct list_head * dm_table_get_devices ( struct dm_table * t ) ;

fmode_t dm_table_get_mode ( struct dm_table * t ) ;

void dm_table_presuspend_targets ( struct dm_table * t ) ;

void dm_table_postsuspend_targets ( struct dm_table * t ) ;

int dm_table_resume_targets ( struct dm_table * t ) ;

int dm_table_any_congested ( struct dm_table * t , int bdi_bits ) ;

int dm_table_any_busy_target ( struct dm_table * t ) ;

void dm_table_unplug_all ( struct dm_table * t ) ;

struct mapped_device * dm_table_get_md ( struct dm_table * t ) ;

struct target_type * dm_get_target_type ( const char * name ) ;

void dm_put_target_type ( struct target_type * tt ) ;

int dm_target_iterate ( void ( * iter_func ) ( struct target_type * tt , void * param ) , void * param ) ;

int dm_register_target ( struct target_type * tt ) ;

void dm_unregister_target ( struct target_type * tt ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dm_target_init ( void ) ;

void dm_target_exit ( void ) ;

struct linear_c { struct dm_dev * dev ; sector_t start ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dm_linear_init ( void ) ;

void dm_linear_exit ( void ) ;

struct stripe { struct dm_dev * dev ; sector_t physical_start ; atomic_t error_count ; } ;

struct stripe_c { uint32_t stripes ; sector_t stripe_width ; uint32_t chunk_shift ; sector_t chunk_mask ; struct dm_target * ti ; struct work_struct kstriped_ws ; struct stripe stripe [ 0 ] ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dm_stripe_init ( void ) ;

void dm_stripe_exit ( void ) ;

struct hash_cell { struct list_head name_list ; struct list_head uuid_list ; char * name ; char * uuid ; struct mapped_device * md ; struct dm_table * new_map ; } ;

struct vers_iter { size_t param_size ; struct dm_target_versions * vers , * old_vers ; char * end ; uint32_t flags ; } ;

typedef int ( * ioctl_fn ) ( struct dm_ioctl * param , size_t param_size ) ;
int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dm_interface_init ( void ) ;

void dm_interface_exit ( void ) ;

int dm_copy_name_and_uuid ( struct mapped_device * md , char * name , char * uuid ) ;

struct dm_io_client { mempool_t * pool ; struct bio_set * bios ; } ;
struct io { unsigned long error_bits ; unsigned long eopnotsupp_bits ; atomic_t count ; struct task_struct * sleeper ; struct dm_io_client * client ; io_notify_fn callback ; void * context ; } ;

struct dm_io_client * dm_io_client_create ( unsigned num_pages ) ;

int dm_io_client_resize ( unsigned num_pages , struct dm_io_client * client ) ;

void dm_io_client_destroy ( struct dm_io_client * client ) ;

struct dpages { void ( * get_page ) ( struct dpages * dp , struct page * * p , unsigned long * len , unsigned * offset ) ; void ( * next_page ) ( struct dpages * dp ) ; unsigned context_u ; void * context_ptr ; } ;

int dm_io ( struct dm_io_request * io_req , unsigned num_regions , struct dm_io_region * where , unsigned long * sync_error_bits ) ;

struct dm_kcopyd_client { spinlock_t lock ; struct page_list * pages ; unsigned int nr_pages ; unsigned int nr_free_pages ; struct dm_io_client * io_client ; wait_queue_head_t destroyq ; atomic_t nr_jobs ; mempool_t * job_pool ; struct workqueue_struct * kcopyd_wq ; struct work_struct kcopyd_work ; spinlock_t job_lock ; struct list_head complete_jobs ; struct list_head io_jobs ; struct list_head pages_jobs ; } ;
struct kcopyd_job { struct dm_kcopyd_client * kc ; struct list_head list ; unsigned long flags ; int read_err ; unsigned long write_err ; int rw ; struct dm_io_region source ; unsigned int num_dests ; struct dm_io_region dests [ 8 ] ; sector_t offset ; unsigned int nr_pages ; struct page_list * pages ; dm_kcopyd_notify_fn fn ; void * context ; struct mutex lock ; atomic_t sub_jobs ; sector_t progress ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dm_kcopyd_init ( void ) ;

void dm_kcopyd_exit ( void ) ;

int dm_kcopyd_copy ( struct dm_kcopyd_client * kc , struct dm_io_region * from , unsigned int num_dests , struct dm_io_region * dests , unsigned int flags , dm_kcopyd_notify_fn fn , void * context ) ;

int dm_kcopyd_client_create ( unsigned int nr_pages , struct dm_kcopyd_client * * result ) ;

void dm_kcopyd_client_destroy ( struct dm_kcopyd_client * kc ) ;

struct dm_sysfs_attr { struct attribute attr ; ssize_t ( * show ) ( struct mapped_device * , char * ) ; ssize_t ( * store ) ( struct mapped_device * , char * ) ; } ;

int dm_sysfs_init ( struct mapped_device * md ) ;

void dm_sysfs_exit ( struct mapped_device * md ) ;

struct dm_path { struct dm_dev * dev ; void * pscontext ; } ;

struct path_selector_type ;

struct path_selector { struct path_selector_type * type ; void * context ; } ;

struct path_selector_type { char * name ; struct module * module ; unsigned int table_args ; unsigned int info_args ; int ( * create ) ( struct path_selector * ps , unsigned argc , char * * argv ) ; void ( * destroy ) ( struct path_selector * ps ) ; int ( * add_path ) ( struct path_selector * ps , struct dm_path * path , int argc , char * * argv , char * * error ) ; struct dm_path * ( * select_path ) ( struct path_selector * ps , unsigned * repeat_count , size_t nr_bytes ) ; void ( * fail_path ) ( struct path_selector * ps , struct dm_path * p ) ; int ( * reinstate_path ) ( struct path_selector * ps , struct dm_path * p ) ; int ( * status ) ( struct path_selector * ps , struct dm_path * path , status_type_t type , char * result , unsigned int maxlen ) ; int ( * start_io ) ( struct path_selector * ps , struct dm_path * path , size_t nr_bytes ) ; int ( * end_io ) ( struct path_selector * ps , struct dm_path * path , size_t nr_bytes ) ; } ;
struct ps_internal { struct path_selector_type pst ; struct list_head list ; } ;

struct path_selector_type * dm_get_path_selector ( const char * name ) ;

void dm_put_path_selector ( struct path_selector_type * pst ) ;

int dm_register_path_selector ( struct path_selector_type * pst ) ;

int dm_unregister_path_selector ( struct path_selector_type * pst ) ;

enum { SCSI_DH_OK = 0 , SCSI_DH_DEV_FAILED , SCSI_DH_DEV_TEMP_BUSY , SCSI_DH_DEV_UNSUPP , SCSI_DH_DEVICE_MAX , SCSI_DH_NOTCONN = SCSI_DH_DEVICE_MAX + 1 , SCSI_DH_CONN_FAILURE , SCSI_DH_TRANSPORT_MAX , SCSI_DH_IO = SCSI_DH_TRANSPORT_MAX + 1 , SCSI_DH_INVALID_IO , SCSI_DH_RETRY , SCSI_DH_IMM_RETRY , SCSI_DH_TIMED_OUT , SCSI_DH_RES_TEMP_UNAVAIL , SCSI_DH_DEV_OFFLINED , SCSI_DH_NOSYS , SCSI_DH_DRIVER_MAX , } ;
struct pgpath { struct list_head list ; struct priority_group * pg ; unsigned is_active ; unsigned fail_count ; struct dm_path path ; struct work_struct deactivate_path ; struct work_struct activate_path ; } ;

struct priority_group { struct list_head list ; struct multipath * m ; struct path_selector ps ; unsigned pg_num ; unsigned bypassed ; unsigned nr_pgpaths ; struct list_head pgpaths ; } ;

struct multipath { struct list_head list ; struct dm_target * ti ; spinlock_t lock ; const char * hw_handler_name ; char * hw_handler_params ; unsigned nr_priority_groups ; struct list_head priority_groups ; unsigned pg_init_required ; unsigned pg_init_in_progress ; unsigned nr_valid_paths ; struct pgpath * current_pgpath ; struct priority_group * current_pg ; struct priority_group * next_pg ; unsigned repeat_count ; unsigned queue_io ; unsigned queue_if_no_path ; unsigned saved_queue_if_no_path ; unsigned pg_init_retries ; unsigned pg_init_count ; struct work_struct process_queued_ios ; struct list_head queued_ios ; unsigned queue_size ; struct work_struct trigger_event ; mempool_t * mpio_pool ; } ;

struct dm_mpath_io { struct pgpath * pgpath ; size_t nr_bytes ; } ;

typedef int ( * action_fn ) ( struct pgpath * pgpath ) ;
struct param { unsigned min ; unsigned max ; char * error ; } ;

struct arg_set { unsigned argc ; char * * argv ; } ;

typedef sector_t chunk_t ;

struct dm_snap_exception { struct list_head hash_list ; chunk_t old_chunk ; chunk_t new_chunk ; } ;

struct dm_exception_store ;

struct dm_exception_store_type { const char * name ; struct module * module ; int ( * ctr ) ( struct dm_exception_store * store , unsigned argc , char * * argv ) ; void ( * dtr ) ( struct dm_exception_store * store ) ; int ( * read_metadata ) ( struct dm_exception_store * store , int ( * callback ) ( void * callback_context , chunk_t old , chunk_t new ) , void * callback_context ) ; int ( * prepare_exception ) ( struct dm_exception_store * store , struct dm_snap_exception * e ) ; void ( * commit_exception ) ( struct dm_exception_store * store , struct dm_snap_exception * e , void ( * callback ) ( void * , int success ) , void * callback_context ) ; void ( * drop_snapshot ) ( struct dm_exception_store * store ) ; unsigned ( * status ) ( struct dm_exception_store * store , status_type_t status , char * result , unsigned maxlen ) ; void ( * fraction_full ) ( struct dm_exception_store * store , sector_t * numerator , sector_t * denominator ) ; struct list_head list ; } ;

struct dm_exception_store { struct dm_exception_store_type * type ; struct dm_target * ti ; struct dm_dev * cow ; unsigned chunk_size ; unsigned chunk_mask ; unsigned chunk_shift ; void * context ; } ;
struct exception_table { uint32_t hash_mask ; unsigned hash_shift ; struct list_head * table ; } ;

struct dm_snapshot { struct rw_semaphore lock ; struct dm_dev * origin ; struct list_head list ; int valid ; int active ; mempool_t * pending_pool ; atomic_t pending_exceptions_count ; struct exception_table pending ; struct exception_table complete ; spinlock_t pe_lock ; struct dm_exception_store * store ; struct dm_kcopyd_client * kcopyd_client ; struct bio_list queued_bios ; struct work_struct queued_bios_work ; mempool_t * tracked_chunk_pool ; spinlock_t tracked_chunk_lock ; struct hlist_head tracked_chunk_hash [ 16 ] ; } ;

struct dm_snap_pending_exception { struct dm_snap_exception e ; struct bio_list origin_bios ; struct bio_list snapshot_bios ; struct list_head list ; struct dm_snap_pending_exception * primary_pe ; atomic_t ref_count ; struct dm_snapshot * snap ; int started ; } ;

struct dm_snap_tracked_chunk { struct hlist_node node ; chunk_t chunk ; } ;

struct origin { struct block_device * bdev ; struct list_head hash_list ; struct list_head snapshots ; } ;

int dm_exception_store_type_register ( struct dm_exception_store_type * type ) ;

int dm_exception_store_type_unregister ( struct dm_exception_store_type * type ) ;

int dm_exception_store_set_chunk_size ( struct dm_exception_store * store , unsigned chunk_size , char * * error ) ;

int dm_exception_store_create ( struct dm_target * ti , int argc , char * * argv , unsigned * args_used , struct dm_exception_store * * store ) ;

void dm_exception_store_destroy ( struct dm_exception_store * store ) ;

int dm_exception_store_init ( void ) ;

void dm_exception_store_exit ( void ) ;

struct transient_c { sector_t next_free ; } ;

int dm_transient_snapshot_init ( void ) ;

void dm_transient_snapshot_exit ( void ) ;

struct disk_header { uint32_t magic ; uint32_t valid ; uint32_t version ; uint32_t chunk_size ; } ;

struct disk_exception { uint64_t old_chunk ; uint64_t new_chunk ; } ;

struct commit_callback { void ( * callback ) ( void * , int success ) ; void * context ; } ;

struct pstore { struct dm_exception_store * store ; int version ; int valid ; uint32_t exceptions_per_area ; void * area ; void * zero_area ; void * header_area ; chunk_t current_area ; chunk_t next_free ; uint32_t current_committed ; atomic_t pending_count ; uint32_t callback_count ; struct commit_callback * callbacks ; struct dm_io_client * io_client ; struct workqueue_struct * metadata_wq ; } ;

struct mdata_req { struct dm_io_region * where ; struct dm_io_request * io_req ; struct work_struct work ; int result ; } ;

int dm_persistent_snapshot_init ( void ) ;

void dm_persistent_snapshot_exit ( void ) ;

typedef struct mddev_s mddev_t ;

typedef struct mdk_rdev_s mdk_rdev_t ;

struct mdk_rdev_s { struct list_head same_set ; sector_t sectors ; mddev_t * mddev ; int last_events ; struct block_device * bdev ; struct page * sb_page ; int sb_loaded ; __u64 sb_events ; sector_t data_offset ; sector_t sb_start ; int sb_size ; int preferred_minor ; struct kobject kobj ; unsigned long flags ; wait_queue_head_t blocked_wait ; int desc_nr ; int raid_disk ; int saved_raid_disk ; sector_t recovery_offset ; atomic_t nr_pending ; atomic_t read_errors ; atomic_t corrected_errors ; struct work_struct del_work ; struct sysfs_dirent * sysfs_state ; } ;

struct mddev_s { void * private ; struct mdk_personality * pers ; dev_t unit ; int md_minor ; struct list_head disks ; unsigned long flags ; int suspended ; atomic_t active_io ; int ro ; struct gendisk * gendisk ; struct kobject kobj ; int hold_active ; int major_version , minor_version , patch_version ; int persistent ; int external ; char metadata_type [ 17 ] ; int chunk_sectors ; time_t ctime , utime ; int level , layout ; char clevel [ 16 ] ; int raid_disks ; int max_disks ; sector_t dev_sectors ; sector_t array_sectors ; int external_size ; __u64 events ; char uuid [ 16 ] ; sector_t reshape_position ; int delta_disks , new_level , new_layout ; int new_chunk_sectors ; struct mdk_thread_s * thread ; struct mdk_thread_s * sync_thread ; sector_t curr_resync ; sector_t curr_resync_completed ; unsigned long resync_mark ; sector_t resync_mark_cnt ; sector_t curr_mark_cnt ; sector_t resync_max_sectors ; sector_t resync_mismatches ; sector_t suspend_lo ; sector_t suspend_hi ; int sync_speed_min ; int sync_speed_max ; int parallel_resync ; int ok_start_degraded ; unsigned long recovery ; int recovery_disabled ; int in_sync ; struct mutex open_mutex ; struct mutex reconfig_mutex ; atomic_t active ; atomic_t openers ; int changed ; int degraded ; int barriers_work ; struct bio * biolist ; atomic_t recovery_active ; wait_queue_head_t recovery_wait ; sector_t recovery_cp ; sector_t resync_min ; sector_t resync_max ; struct sysfs_dirent * sysfs_state ; struct sysfs_dirent * sysfs_action ; struct work_struct del_work ; spinlock_t write_lock ; wait_queue_head_t sb_wait ; atomic_t pending_writes ; unsigned int safemode ; unsigned int safemode_delay ; struct timer_list safemode_timer ; atomic_t writes_pending ; struct request_queue * queue ; atomic_t write_behind ; unsigned int max_write_behind ; struct bitmap * bitmap ; struct file * bitmap_file ; long bitmap_offset ; long default_bitmap_offset ; struct mutex bitmap_mutex ; struct list_head all_mddevs ; } ;

struct mdk_personality { char * name ; int level ; struct list_head list ; struct module * owner ; int ( * make_request ) ( struct request_queue * q , struct bio * bio ) ; int ( * run ) ( mddev_t * mddev ) ; int ( * stop ) ( mddev_t * mddev ) ; void ( * status ) ( struct seq_file * seq , mddev_t * mddev ) ; void ( * error_handler ) ( mddev_t * mddev , mdk_rdev_t * rdev ) ; int ( * hot_add_disk ) ( mddev_t * mddev , mdk_rdev_t * rdev ) ; int ( * hot_remove_disk ) ( mddev_t * mddev , int number ) ; int ( * spare_active ) ( mddev_t * mddev ) ; sector_t ( * sync_request ) ( mddev_t * mddev , sector_t sector_nr , int * skipped , int go_faster ) ; int ( * resize ) ( mddev_t * mddev , sector_t sectors ) ; sector_t ( * size ) ( mddev_t * mddev , sector_t sectors , int raid_disks ) ; int ( * check_reshape ) ( mddev_t * mddev ) ; int ( * start_reshape ) ( mddev_t * mddev ) ; void ( * finish_reshape ) ( mddev_t * mddev ) ; void ( * quiesce ) ( mddev_t * mddev , int state ) ; void * ( * takeover ) ( mddev_t * mddev ) ; } ;

struct md_sysfs_entry { struct attribute attr ; ssize_t ( * show ) ( mddev_t * , char * ) ; ssize_t ( * store ) ( mddev_t * , const char * , size_t ) ; } ;


typedef struct mdk_thread_s { void ( * run ) ( mddev_t * mddev ) ; mddev_t * mddev ; wait_queue_head_t wqueue ; unsigned long flags ; struct task_struct * tsk ; unsigned long timeout ; } mdk_thread_t ;

typedef __u16 bitmap_counter_t ;

enum bitmap_state { BITMAP_STALE = 0x002 , BITMAP_WRITE_ERROR = 0x004 , BITMAP_HOSTENDIAN = 0x8000 , } ;


typedef struct bitmap_super_s { __le32 magic ; __le32 version ; __u8 uuid [ 16 ] ; __le64 events ; __le64 events_cleared ; __le64 sync_size ; __le32 state ; __le32 chunksize ; __le32 daemon_sleep ; __le32 write_behind ; __u8 pad [ 256 - 64 ] ; } bitmap_super_t ;

struct bitmap_page { char * map ; unsigned int hijacked : 1 ; unsigned int count : 31 ; } ;

struct page_list { struct list_head list ; struct page * page ; } ;
struct bitmap { struct bitmap_page * bp ; unsigned long pages ; unsigned long missing_pages ; mddev_t * mddev ; int counter_bits ; unsigned long chunksize ; unsigned long chunkshift ; unsigned long chunks ; unsigned long syncchunk ; __u64 events_cleared ; int need_sync ; spinlock_t lock ; long offset ; struct file * file ; struct page * sb_page ; struct page * * filemap ; unsigned long * filemap_attr ; unsigned long file_pages ; int last_page_size ; unsigned long flags ; int allclean ; unsigned long max_write_behind ; atomic_t behind_writes ; unsigned long daemon_lastrun ; unsigned long daemon_sleep ; unsigned long last_end_sync ; atomic_t pending_writes ; wait_queue_head_t write_wait ; wait_queue_head_t overflow_wait ; wait_queue_head_t behind_wait ; } ;

void md_new_event ( mddev_t * mddev ) ;

int mddev_congested ( mddev_t * mddev , int bits ) ;

void md_super_write ( mddev_t * mddev , mdk_rdev_t * rdev , sector_t sector , int size , struct page * page ) ;

void md_super_wait ( mddev_t * mddev ) ;

int sync_page_io ( struct block_device * bdev , sector_t sector , int size , struct page * page , int rw ) ;

struct super_type { char * name ; struct module * owner ; int ( * load_super ) ( mdk_rdev_t * rdev , mdk_rdev_t * refdev , int minor_version ) ; int ( * validate_super ) ( mddev_t * mddev , mdk_rdev_t * rdev ) ; void ( * sync_super ) ( mddev_t * mddev , mdk_rdev_t * rdev ) ; unsigned long long ( * rdev_size_change ) ( mdk_rdev_t * rdev , sector_t num_sectors ) ; } ;

int md_check_no_bitmap ( mddev_t * mddev ) ;

int md_integrity_register ( mddev_t * mddev ) ;

void md_integrity_add_rdev ( mdk_rdev_t * rdev , mddev_t * mddev ) ;

struct rdev_sysfs_entry { struct attribute attr ; ssize_t ( * show ) ( mdk_rdev_t * , char * ) ; ssize_t ( * store ) ( mdk_rdev_t * , const char * , size_t ) ; } ;

enum array_state { clear , inactive , suspended , readonly , read_auto , clean , active , write_pending , active_idle , bad_word } ;

void md_set_array_sectors ( mddev_t * mddev , sector_t array_sectors ) ;

void md_wakeup_thread ( mdk_thread_t * thread ) ;

mdk_thread_t * md_register_thread ( void ( * run ) ( mddev_t * ) , mddev_t * mddev , const char * name ) ;

void md_unregister_thread ( mdk_thread_t * thread ) ;

void md_error ( mddev_t * mddev , mdk_rdev_t * rdev ) ;

struct mdstat_info { int event ; } ;

int register_md_personality ( struct mdk_personality * p ) ;

int unregister_md_personality ( struct mdk_personality * p ) ;

void md_done_sync ( mddev_t * mddev , int blocks , int ok ) ;

void md_write_start ( mddev_t * mddev , struct bio * bi ) ;

void md_write_end ( mddev_t * mddev ) ;

int md_allow_write ( mddev_t * mddev ) ;

void md_do_sync ( mddev_t * mddev ) ;

void md_check_recovery ( mddev_t * mddev ) ;

void md_wait_for_blocked_rdev ( mdk_rdev_t * rdev , mddev_t * mddev ) ;

struct detected_devices_node { struct list_head list ; dev_t dev ; } ;

void md_autodetect_dev ( dev_t dev ) ;

void bitmap_update_sb ( struct bitmap * bitmap ) ;

void bitmap_print_sb ( struct bitmap * bitmap ) ;

enum bitmap_mask_op { MASK_SET , MASK_UNSET } ;

enum bitmap_page_attr { BITMAP_PAGE_DIRTY = 0 , BITMAP_PAGE_CLEAN = 1 , BITMAP_PAGE_NEEDWRITE = 2 , } ;

void bitmap_unplug ( struct bitmap * bitmap ) ;

void bitmap_write_all ( struct bitmap * bitmap ) ;

void bitmap_daemon_work ( mddev_t * mddev ) ;

int bitmap_startwrite ( struct bitmap * bitmap , sector_t offset , unsigned long sectors , int behind ) ;

void bitmap_endwrite ( struct bitmap * bitmap , sector_t offset , unsigned long sectors , int success , int behind ) ;

int bitmap_start_sync ( struct bitmap * bitmap , sector_t offset , int * blocks , int degraded ) ;

void bitmap_end_sync ( struct bitmap * bitmap , sector_t offset , int * blocks , int aborted ) ;

void bitmap_close_sync ( struct bitmap * bitmap ) ;

void bitmap_cond_end_sync ( struct bitmap * bitmap , sector_t sector ) ;

void bitmap_dirty_bits ( struct bitmap * bitmap , unsigned long s , unsigned long e ) ;

void bitmap_flush ( mddev_t * mddev ) ;

void bitmap_destroy ( mddev_t * mddev ) ;

int bitmap_create ( mddev_t * mddev ) ;

struct path_info { struct list_head list ; struct dm_path * path ; unsigned repeat_count ; } ;

struct selector { struct list_head valid_paths ; struct list_head invalid_paths ; } ;

int dm_dirty_log_type_register ( struct dm_dirty_log_type * type ) ;

int dm_dirty_log_type_unregister ( struct dm_dirty_log_type * type ) ;

struct dm_dirty_log * dm_dirty_log_create ( const char * type_name , struct dm_target * ti , unsigned int argc , char * * argv ) ;

void dm_dirty_log_destroy ( struct dm_dirty_log * log ) ;

struct log_header { uint32_t magic ; uint32_t version ; sector_t nr_regions ; } ;

struct log_c { struct dm_target * ti ; int touched ; uint32_t region_size ; unsigned int region_count ; region_t sync_count ; unsigned bitset_uint32_count ; uint32_t * clean_bits ; uint32_t * sync_bits ; uint32_t * recovering_bits ; int sync_search ; enum sync { DEFAULTSYNC , NOSYNC , FORCESYNC , } sync ; struct dm_io_request io_req ; int log_dev_failed ; struct dm_dev * log_dev ; struct log_header header ; struct dm_io_region header_location ; struct log_header * disk_header ; } ;

struct dm_region_hash { uint32_t region_size ; unsigned region_shift ; struct dm_dirty_log * log ; rwlock_t hash_lock ; mempool_t * region_pool ; unsigned mask ; unsigned nr_buckets ; unsigned prime ; unsigned shift ; struct list_head * buckets ; unsigned max_recovery ; spinlock_t region_lock ; atomic_t recovery_in_flight ; struct semaphore recovery_count ; struct list_head clean_regions ; struct list_head quiesced_regions ; struct list_head recovered_regions ; struct list_head failed_recovered_regions ; void * context ; sector_t target_begin ; void ( * dispatch_bios ) ( void * context , struct bio_list * bios ) ; void ( * wakeup_workers ) ( void * context ) ; void ( * wakeup_all_recovery_waiters ) ( void * context ) ; } ;
struct dm_region { struct dm_region_hash * rh ; region_t key ; int state ; struct list_head hash_list ; struct list_head list ; atomic_t pending ; struct bio_list delayed_bios ; } ;
sector_t dm_rh_region_to_sector ( struct dm_region_hash * rh , region_t region ) ;

region_t dm_rh_bio_to_region ( struct dm_region_hash * rh , struct bio * bio ) ;

void * dm_rh_region_context ( struct dm_region * reg ) ;

region_t dm_rh_get_region_key ( struct dm_region * reg ) ;

sector_t dm_rh_get_region_size ( struct dm_region_hash * rh ) ;

struct dm_region_hash * dm_region_hash_create ( void * context , void ( * dispatch_bios ) ( void * context , struct bio_list * bios ) , void ( * wakeup_workers ) ( void * context ) , void ( * wakeup_all_recovery_waiters ) ( void * context ) , sector_t target_begin , unsigned max_recovery , struct dm_dirty_log * log , uint32_t region_size , region_t nr_regions ) ;

void dm_region_hash_destroy ( struct dm_region_hash * rh ) ;

struct dm_dirty_log * dm_rh_dirty_log ( struct dm_region_hash * rh ) ;

int dm_rh_get_state ( struct dm_region_hash * rh , region_t region , int may_block ) ;

void dm_rh_mark_nosync ( struct dm_region_hash * rh , struct bio * bio , unsigned done , int error ) ;

void dm_rh_update_states ( struct dm_region_hash * rh , int errors_handled ) ;

void dm_rh_inc_pending ( struct dm_region_hash * rh , struct bio_list * bios ) ;

void dm_rh_dec ( struct dm_region_hash * rh , region_t region ) ;

void dm_rh_recovery_prepare ( struct dm_region_hash * rh ) ;

struct dm_region * dm_rh_recovery_start ( struct dm_region_hash * rh ) ;

void dm_rh_recovery_end ( struct dm_region * reg , int success ) ;

int dm_rh_recovery_in_flight ( struct dm_region_hash * rh ) ;

int dm_rh_flush ( struct dm_region_hash * rh ) ;

void dm_rh_delay ( struct dm_region_hash * rh , struct bio * bio ) ;

void dm_rh_stop_recovery ( struct dm_region_hash * rh ) ;

void dm_rh_start_recovery ( struct dm_region_hash * rh ) ;

struct clk ;

struct regulator ;

struct regulator_bulk_data { const char * supply ; struct regulator * consumer ; } ;

struct regulator_state { int uV ; unsigned int mode ; int enabled ; } ;

struct regulation_constraints { char * name ; int min_uV ; int max_uV ; int min_uA ; int max_uA ; unsigned int valid_modes_mask ; unsigned int valid_ops_mask ; int input_uV ; struct regulator_state state_disk ; struct regulator_state state_mem ; struct regulator_state state_standby ; suspend_state_t initial_state ; unsigned int initial_mode ; unsigned always_on : 1 ; unsigned boot_on : 1 ; unsigned apply_uV : 1 ; } ;

struct regulator_consumer_supply { struct device * dev ; const char * dev_name ; const char * supply ; } ;

struct regulator_init_data { struct device * supply_regulator_dev ; struct regulation_constraints constraints ; int num_consumer_supplies ; struct regulator_consumer_supply * consumer_supplies ; int ( * regulator_init ) ( void * driver_data ) ; void * driver_data ; } ;

struct matrix_keymap_data { const uint32_t * keymap ; unsigned int keymap_size ; } ;

struct matrix_keypad_platform_data { const struct matrix_keymap_data * keymap_data ; const unsigned int * row_gpios ; const unsigned int * col_gpios ; unsigned int num_row_gpios ; unsigned int num_col_gpios ; unsigned int col_scan_delay_us ; unsigned int debounce_ms ; bool active_low ; bool wakeup ; } ;

struct twl4030_bci_platform_data { int * battery_tmp_tbl ; unsigned int tblsize ; } ;

struct twl4030_gpio_platform_data { int gpio_base ; unsigned irq_base , irq_end ; bool use_leds ; u8 mmc_cd ; u32 debounce ; u32 pullups ; u32 pulldowns ; int ( * setup ) ( struct device * dev , unsigned gpio , unsigned ngpio ) ; int ( * teardown ) ( struct device * dev , unsigned gpio , unsigned ngpio ) ; } ;

struct twl4030_madc_platform_data { int irq_line ; } ;

struct twl4030_keypad_data { const struct matrix_keymap_data * keymap_data ; unsigned rows ; unsigned cols ; bool rep ; } ;

enum twl4030_usb_mode { T2_USB_MODE_ULPI = 1 , T2_USB_MODE_CEA2011_3PIN = 2 , } ;

struct twl4030_usb_data { enum twl4030_usb_mode usb_mode ; } ;

struct twl4030_ins { u16 pmb_message ; u8 delay ; } ;

struct twl4030_script { struct twl4030_ins * script ; unsigned size ; u8 flags ; } ;

struct twl4030_resconfig { u8 resource ; u8 devgroup ; u8 type ; u8 type2 ; } ;

struct twl4030_power_data { struct twl4030_script * * scripts ; unsigned num ; struct twl4030_resconfig * resource_config ; } ;

struct twl4030_platform_data { unsigned irq_base , irq_end ; struct twl4030_bci_platform_data * bci ; struct twl4030_gpio_platform_data * gpio ; struct twl4030_madc_platform_data * madc ; struct twl4030_keypad_data * keypad ; struct twl4030_usb_data * usb ; struct twl4030_power_data * power ; struct regulator_init_data * vdac ; struct regulator_init_data * vpll1 ; struct regulator_init_data * vpll2 ; struct regulator_init_data * vmmc1 ; struct regulator_init_data * vmmc2 ; struct regulator_init_data * vsim ; struct regulator_init_data * vaux1 ; struct regulator_init_data * vaux2 ; struct regulator_init_data * vaux3 ; struct regulator_init_data * vaux4 ; } ;

struct twl4030_client { struct i2c_client * client ; u8 address ; struct i2c_msg xfer_msg [ 2 ] ; struct mutex xfer_lock ; } ;

struct twl4030mapping { unsigned char sid ; unsigned char base ; } ;

int twl4030_i2c_write ( u8 mod_no , u8 * value , u8 reg , unsigned num_bytes ) ;

int twl4030_i2c_read ( u8 mod_no , u8 * value , u8 reg , unsigned num_bytes ) ;

int twl4030_i2c_write_u8 ( u8 mod_no , u8 value , u8 reg ) ;

int twl4030_i2c_read_u8 ( u8 mod_no , u8 * value , u8 reg ) ;

struct sih { char name [ 8 ] ; u8 module ; u8 control_offset ; bool set_cor ; u8 bits ; u8 bytes_ixr ; u8 edr_offset ; u8 bytes_edr ; struct irq_data { u8 isr_offset ; u8 imr_offset ; } mask [ 2 ] ; } ;

struct sih_agent { int irq_base ; const struct sih * sih ; u32 imr ; bool imr_change_pending ; struct work_struct mask_work ; u32 edge_change ; struct work_struct edge_work ; } ;

int twl4030_sih_setup ( int module ) ;

int twl_init_irq ( int irq_num , unsigned irq_base , unsigned irq_end ) ;

int twl_exit_irq ( void ) ;

enum { DA9030_ID_LED_1 , DA9030_ID_LED_2 , DA9030_ID_LED_3 , DA9030_ID_LED_4 , DA9030_ID_LED_PC , DA9030_ID_VIBRA , DA9030_ID_WLED , DA9030_ID_BUCK1 , DA9030_ID_BUCK2 , DA9030_ID_LDO1 , DA9030_ID_LDO2 , DA9030_ID_LDO3 , DA9030_ID_LDO4 , DA9030_ID_LDO5 , DA9030_ID_LDO6 , DA9030_ID_LDO7 , DA9030_ID_LDO8 , DA9030_ID_LDO9 , DA9030_ID_LDO10 , DA9030_ID_LDO11 , DA9030_ID_LDO12 , DA9030_ID_LDO13 , DA9030_ID_LDO14 , DA9030_ID_LDO15 , DA9030_ID_LDO16 , DA9030_ID_LDO17 , DA9030_ID_LDO18 , DA9030_ID_LDO19 , DA9030_ID_LDO_INT , DA9030_ID_BAT , DA9034_ID_LED_1 , DA9034_ID_LED_2 , DA9034_ID_VIBRA , DA9034_ID_WLED , DA9034_ID_TOUCH , DA9034_ID_BUCK1 , DA9034_ID_BUCK2 , DA9034_ID_LDO1 , DA9034_ID_LDO2 , DA9034_ID_LDO3 , DA9034_ID_LDO4 , DA9034_ID_LDO5 , DA9034_ID_LDO6 , DA9034_ID_LDO7 , DA9034_ID_LDO8 , DA9034_ID_LDO9 , DA9034_ID_LDO10 , DA9034_ID_LDO11 , DA9034_ID_LDO12 , DA9034_ID_LDO13 , DA9034_ID_LDO14 , DA9034_ID_LDO15 , DA9035_ID_BUCK3 , } ;
struct da9034_touch_pdata { int interval_ms ; int x_inverted ; int y_inverted ; } ;

struct power_supply_info ;
struct da9030_battery_info { struct power_supply_info * battery_info ; unsigned int charge_milliamp ; unsigned int charge_millivolt ; int vbat_low ; int vbat_crit ; int vbat_charge_start ; int vbat_charge_stop ; int vbat_charge_restart ; int vcharge_min ; int vcharge_max ; int tbat_low ; int tbat_high ; int tbat_restart ; unsigned int batmon_interval ; void ( * battery_low ) ( void ) ; void ( * battery_critical ) ( void ) ; } ;

struct da903x_subdev_info { int id ; const char * name ; void * platform_data ; } ;

struct da903x_platform_data { int num_subdevs ; struct da903x_subdev_info * subdevs ; } ;

struct da903x_chip ;

struct da903x_chip_ops { int ( * init_chip ) ( struct da903x_chip * ) ; int ( * unmask_events ) ( struct da903x_chip * , unsigned int events ) ; int ( * mask_events ) ( struct da903x_chip * , unsigned int events ) ; int ( * read_events ) ( struct da903x_chip * , unsigned int * events ) ; int ( * read_status ) ( struct da903x_chip * , unsigned int * status ) ; } ;

struct da903x_chip { struct i2c_client * client ; struct device * dev ; struct da903x_chip_ops * ops ; int type ; uint32_t events_mask ; struct mutex lock ; struct work_struct irq_work ; struct blocking_notifier_head notifier_list ; } ;
int da903x_register_notifier ( struct device * dev , struct notifier_block * nb , unsigned int events ) ;

int da903x_unregister_notifier ( struct device * dev , struct notifier_block * nb , unsigned int events ) ;

int da903x_write ( struct device * dev , int reg , uint8_t val ) ;

int da903x_writes ( struct device * dev , int reg , int len , uint8_t * val ) ;

int da903x_read ( struct device * dev , int reg , uint8_t * val ) ;

int da903x_reads ( struct device * dev , int reg , int len , uint8_t * val ) ;

int da903x_set_bits ( struct device * dev , int reg , uint8_t bit_mask ) ;

int da903x_clr_bits ( struct device * dev , int reg , uint8_t bit_mask ) ;

int da903x_update ( struct device * dev , int reg , uint8_t val , uint8_t mask ) ;

int da903x_query_status ( struct device * dev , unsigned int sbits ) ;

struct mmc_data ;

struct mmc_request ;

struct mmc_command { u32 opcode ; u32 arg ; u32 resp [ 4 ] ; unsigned int flags ; unsigned int retries ; unsigned int error ; struct mmc_data * data ; struct mmc_request * mrq ; } ;

struct mmc_data { unsigned int timeout_ns ; unsigned int timeout_clks ; unsigned int blksz ; unsigned int blocks ; unsigned int error ; unsigned int flags ; unsigned int bytes_xfered ; struct mmc_command * stop ; struct mmc_request * mrq ; unsigned int sg_len ; struct scatterlist * sg ; } ;
struct mmc_request { struct mmc_command * cmd ; struct mmc_data * data ; struct mmc_command * stop ; void * done_data ; void ( * done ) ( struct mmc_request * ) ; } ;
struct mmc_host ;

struct mmc_card ;

struct mmc_cid { unsigned int manfid ; char prod_name [ 8 ] ; unsigned int serial ; unsigned short oemid ; unsigned short year ; unsigned char hwrev ; unsigned char fwrev ; unsigned char month ; } ;

struct mmc_csd { unsigned char mmca_vsn ; unsigned short cmdclass ; unsigned short tacc_clks ; unsigned int tacc_ns ; unsigned int r2w_factor ; unsigned int max_dtr ; unsigned int read_blkbits ; unsigned int write_blkbits ; unsigned int capacity ; unsigned int read_partial : 1 , read_misalign : 1 , write_partial : 1 , write_misalign : 1 ; } ;

struct mmc_ext_csd { u8 rev ; unsigned int sa_timeout ; unsigned int hs_max_dtr ; unsigned int sectors ; } ;

struct sd_scr { unsigned char sda_vsn ; unsigned char bus_widths ; } ;

struct sd_switch_caps { unsigned int hs_max_dtr ; } ;

struct sdio_cccr { unsigned int sdio_vsn ; unsigned int sd_vsn ; unsigned int multi_block : 1 , low_speed : 1 , wide_bus : 1 , high_power : 1 , high_speed : 1 , disable_cd : 1 ; } ;

struct sdio_cis { unsigned short vendor ; unsigned short device ; unsigned short blksize ; unsigned int max_dtr ; } ;

struct sdio_func ;

struct sdio_func_tuple ;

struct mmc_card { struct mmc_host * host ; struct device dev ; unsigned int rca ; unsigned int type ; unsigned int state ; unsigned int quirks ; u32 raw_cid [ 4 ] ; u32 raw_csd [ 4 ] ; u32 raw_scr [ 2 ] ; struct mmc_cid cid ; struct mmc_csd csd ; struct mmc_ext_csd ext_csd ; struct sd_scr scr ; struct sd_switch_caps sw_caps ; unsigned int sdio_funcs ; struct sdio_cccr cccr ; struct sdio_cis cis ; struct sdio_func * sdio_func [ 7 ] ; unsigned num_info ; const char * * info ; struct sdio_func_tuple * tuples ; struct dentry * debugfs_root ; } ;
struct mmc_driver { struct device_driver drv ; int ( * probe ) ( struct mmc_card * ) ; void ( * remove ) ( struct mmc_card * ) ; int ( * suspend ) ( struct mmc_card * , pm_message_t ) ; int ( * resume ) ( struct mmc_card * ) ; } ;

struct mmc_ios { unsigned int clock ; unsigned short vdd ; unsigned char bus_mode ; unsigned char chip_select ; unsigned char power_mode ; unsigned char bus_width ; unsigned char timing ; } ;

struct mmc_host_ops { int ( * enable ) ( struct mmc_host * host ) ; int ( * disable ) ( struct mmc_host * host , int lazy ) ; void ( * request ) ( struct mmc_host * host , struct mmc_request * req ) ; void ( * set_ios ) ( struct mmc_host * host , struct mmc_ios * ios ) ; int ( * get_ro ) ( struct mmc_host * host ) ; int ( * get_cd ) ( struct mmc_host * host ) ; void ( * enable_sdio_irq ) ( struct mmc_host * host , int enable ) ; } ;

struct mmc_host { struct device * parent ; struct device class_dev ; int index ; const struct mmc_host_ops * ops ; unsigned int f_min ; unsigned int f_max ; u32 ocr_avail ; unsigned long caps ; unsigned int max_seg_size ; unsigned short max_hw_segs ; unsigned short max_phys_segs ; unsigned short unused ; unsigned int max_req_size ; unsigned int max_blk_size ; unsigned int max_blk_count ; spinlock_t lock ; struct mmc_ios ios ; u32 ocr ; unsigned int use_spi_crc : 1 ; unsigned int claimed : 1 ; unsigned int bus_dead : 1 ; int enabled ; int nesting_cnt ; int en_dis_recurs ; unsigned int disable_delay ; struct delayed_work disable ; struct mmc_card * card ; wait_queue_head_t wq ; struct task_struct * claimer ; int claim_cnt ; struct delayed_work detect ; const struct mmc_bus_ops * bus_ops ; unsigned int bus_refs ; unsigned int sdio_irqs ; struct task_struct * sdio_irq_thread ; atomic_t sdio_irq_thread_abort ; struct led_trigger * led ; struct dentry * debugfs_root ; unsigned long private [ 0 ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; } ;
struct _mmc_csd { u8 csd_structure ; u8 spec_vers ; u8 taac ; u8 nsac ; u8 tran_speed ; u16 ccc ; u8 read_bl_len ; u8 read_bl_partial ; u8 write_blk_misalign ; u8 read_blk_misalign ; u8 dsr_imp ; u16 c_size ; u8 vdd_r_curr_min ; u8 vdd_r_curr_max ; u8 vdd_w_curr_min ; u8 vdd_w_curr_max ; u8 c_size_mult ; union { struct { u8 erase_grp_size ; u8 erase_grp_mult ; } v31 ; struct { u8 sector_size ; u8 erase_grp_size ; } v22 ; } erase ; u8 wp_grp_size ; u8 wp_grp_enable ; u8 default_ecc ; u8 r2w_factor ; u8 write_bl_len ; u8 write_bl_partial ; u8 file_format_grp ; u8 copy ; u8 perm_write_protect ; u8 tmp_write_protect ; u8 file_format ; u8 ecc ; } ;

struct mmc_bus_ops { int ( * awake ) ( struct mmc_host * ) ; int ( * sleep ) ( struct mmc_host * ) ; void ( * remove ) ( struct mmc_host * ) ; void ( * detect ) ( struct mmc_host * ) ; int ( * suspend ) ( struct mmc_host * ) ; int ( * resume ) ( struct mmc_host * ) ; void ( * power_save ) ( struct mmc_host * ) ; void ( * power_restore ) ( struct mmc_host * ) ; } ;

void mmc_request_done ( struct mmc_host * host , struct mmc_request * mrq ) ;

void mmc_wait_for_req ( struct mmc_host * host , struct mmc_request * mrq ) ;

int mmc_wait_for_cmd ( struct mmc_host * host , struct mmc_command * cmd , int retries ) ;

void mmc_set_data_timeout ( struct mmc_data * data , const struct mmc_card * card ) ;

unsigned int mmc_align_data_size ( struct mmc_card * card , unsigned int sz ) ;

int mmc_host_enable ( struct mmc_host * host ) ;

int mmc_host_disable ( struct mmc_host * host ) ;

int __mmc_claim_host ( struct mmc_host * host , atomic_t * abort ) ;

int mmc_try_claim_host ( struct mmc_host * host ) ;

void mmc_host_deeper_disable ( struct work_struct * work ) ;

int mmc_host_lazy_disable ( struct mmc_host * host ) ;

void mmc_release_host ( struct mmc_host * host ) ;

void mmc_set_chip_select ( struct mmc_host * host , int mode ) ;

void mmc_set_clock ( struct mmc_host * host , unsigned int hz ) ;

void mmc_set_bus_mode ( struct mmc_host * host , unsigned int mode ) ;

void mmc_set_bus_width ( struct mmc_host * host , unsigned int width ) ;

u32 mmc_vddrange_to_ocrmask ( int vdd_min , int vdd_max ) ;

int mmc_regulator_get_ocrmask ( struct regulator * supply ) ;

int mmc_regulator_set_ocr ( struct regulator * supply , unsigned short vdd_bit ) ;

u32 mmc_select_voltage ( struct mmc_host * host , u32 ocr ) ;

void mmc_set_timing ( struct mmc_host * host , unsigned int timing ) ;

void mmc_attach_bus ( struct mmc_host * host , const struct mmc_bus_ops * ops ) ;

void mmc_detach_bus ( struct mmc_host * host ) ;

void mmc_detect_change ( struct mmc_host * host , unsigned long delay ) ;

void mmc_rescan ( struct work_struct * work ) ;

void mmc_start_host ( struct mmc_host * host ) ;

void mmc_stop_host ( struct mmc_host * host ) ;

void mmc_power_save_host ( struct mmc_host * host ) ;

void mmc_power_restore_host ( struct mmc_host * host ) ;

int mmc_card_awake ( struct mmc_host * host ) ;

int mmc_card_sleep ( struct mmc_host * host ) ;

int mmc_card_can_sleep ( struct mmc_host * host ) ;

int mmc_suspend_host ( struct mmc_host * host , pm_message_t state ) ;

int mmc_resume_host ( struct mmc_host * host ) ;

int mmc_register_bus ( void ) ;

void mmc_unregister_bus ( void ) ;

int mmc_register_driver ( struct mmc_driver * drv ) ;

void mmc_unregister_driver ( struct mmc_driver * drv ) ;

struct mmc_card * mmc_alloc_card ( struct mmc_host * host , struct device_type * type ) ;

int mmc_add_card ( struct mmc_card * card ) ;

void mmc_remove_card ( struct mmc_card * card ) ;

int mmc_register_host_class ( void ) ;

void mmc_unregister_host_class ( void ) ;

struct mmc_host * mmc_alloc_host ( int extra , struct device * dev ) ;

int mmc_add_host ( struct mmc_host * host ) ;

void mmc_remove_host ( struct mmc_host * host ) ;

void mmc_free_host ( struct mmc_host * host ) ;

int mmc_attach_mmc ( struct mmc_host * host , u32 ocr ) ;

int mmc_select_card ( struct mmc_card * card ) ;

int mmc_deselect_cards ( struct mmc_host * host ) ;

int mmc_card_sleepawake ( struct mmc_host * host , int sleep ) ;

int mmc_go_idle ( struct mmc_host * host ) ;

int mmc_send_op_cond ( struct mmc_host * host , u32 ocr , u32 * rocr ) ;

int mmc_all_send_cid ( struct mmc_host * host , u32 * cid ) ;

int mmc_set_relative_addr ( struct mmc_card * card ) ;

int mmc_send_csd ( struct mmc_card * card , u32 * csd ) ;

int mmc_send_cid ( struct mmc_host * host , u32 * cid ) ;

int mmc_send_ext_csd ( struct mmc_card * card , u8 * ext_csd ) ;

int mmc_spi_read_ocr ( struct mmc_host * host , int highcap , u32 * ocrp ) ;

int mmc_spi_set_crc ( struct mmc_host * host , int use_crc ) ;

int mmc_switch ( struct mmc_card * card , u8 set , u8 index , u8 value ) ;

int mmc_send_status ( struct mmc_card * card , u32 * status ) ;

int mmc_attach_sd ( struct mmc_host * host , u32 ocr ) ;

int mmc_wait_for_app_cmd ( struct mmc_host * host , struct mmc_card * card , struct mmc_command * cmd , int retries ) ;

int mmc_app_set_bus_width ( struct mmc_card * card , int width ) ;

int mmc_send_app_op_cond ( struct mmc_host * host , u32 ocr , u32 * rocr ) ;

int mmc_send_if_cond ( struct mmc_host * host , u32 ocr ) ;

int mmc_send_relative_addr ( struct mmc_host * host , unsigned int * rca ) ;

int mmc_app_send_scr ( struct mmc_card * card , u32 * scr ) ;

int mmc_sd_switch ( struct mmc_card * card , int mode , int group , u8 value , u8 * resp ) ;

typedef void ( sdio_irq_handler_t ) ( struct sdio_func * ) ;
struct sdio_func_tuple { struct sdio_func_tuple * next ; unsigned char code ; unsigned char size ; unsigned char data [ 0 ] ; } ;
struct sdio_func { struct mmc_card * card ; struct device dev ; sdio_irq_handler_t * irq_handler ; unsigned int num ; unsigned char class ; unsigned short vendor ; unsigned short device ; unsigned max_blksize ; unsigned cur_blksize ; unsigned enable_timeout ; unsigned int state ; u8 tmpbuf [ 4 ] ; unsigned num_info ; const char * * info ; struct sdio_func_tuple * tuples ; } ;
struct sdio_driver { char * name ; const struct sdio_device_id * id_table ; int ( * probe ) ( struct sdio_func * , const struct sdio_device_id * ) ; void ( * remove ) ( struct sdio_func * ) ; struct device_driver drv ; } ;

int mmc_attach_sdio ( struct mmc_host * host , u32 ocr ) ;

int mmc_send_io_op_cond ( struct mmc_host * host , u32 ocr , u32 * rocr ) ;

int mmc_io_rw_direct ( struct mmc_card * card , int write , unsigned fn , unsigned addr , u8 in , u8 * out ) ;

int mmc_io_rw_extended ( struct mmc_card * card , int write , unsigned fn , unsigned addr , int incr_addr , u8 * buf , unsigned blocks , unsigned blksz ) ;

int sdio_register_bus ( void ) ;

void sdio_unregister_bus ( void ) ;

int sdio_register_driver ( struct sdio_driver * drv ) ;

void sdio_unregister_driver ( struct sdio_driver * drv ) ;

struct sdio_func * sdio_alloc_func ( struct mmc_card * card ) ;

int sdio_add_func ( struct sdio_func * func ) ;

void sdio_remove_func ( struct sdio_func * func ) ;

typedef int ( tpl_parse_t ) ( struct mmc_card * , struct sdio_func * , const unsigned char * , unsigned ) ;
struct cis_tpl { unsigned char code ; unsigned char min_size ; tpl_parse_t * parse ; } ;

int sdio_read_common_cis ( struct mmc_card * card ) ;

void sdio_free_common_cis ( struct mmc_card * card ) ;

int sdio_read_func_cis ( struct sdio_func * func ) ;

void sdio_free_func_cis ( struct sdio_func * func ) ;

void sdio_claim_host ( struct sdio_func * func ) ;

void sdio_release_host ( struct sdio_func * func ) ;

int sdio_enable_func ( struct sdio_func * func ) ;

int sdio_disable_func ( struct sdio_func * func ) ;

int sdio_set_block_size ( struct sdio_func * func , unsigned blksz ) ;

unsigned int sdio_align_size ( struct sdio_func * func , unsigned int sz ) ;

u8 sdio_readb ( struct sdio_func * func , unsigned int addr , int * err_ret ) ;

void sdio_writeb ( struct sdio_func * func , u8 b , unsigned int addr , int * err_ret ) ;

int sdio_memcpy_fromio ( struct sdio_func * func , void * dst , unsigned int addr , int count ) ;

int sdio_memcpy_toio ( struct sdio_func * func , unsigned int addr , void * src , int count ) ;

int sdio_readsb ( struct sdio_func * func , void * dst , unsigned int addr , int count ) ;

int sdio_writesb ( struct sdio_func * func , unsigned int addr , void * src , int count ) ;

u16 sdio_readw ( struct sdio_func * func , unsigned int addr , int * err_ret ) ;

void sdio_writew ( struct sdio_func * func , u16 b , unsigned int addr , int * err_ret ) ;

u32 sdio_readl ( struct sdio_func * func , unsigned int addr , int * err_ret ) ;

void sdio_writel ( struct sdio_func * func , u32 b , unsigned int addr , int * err_ret ) ;

unsigned char sdio_f0_readb ( struct sdio_func * func , unsigned int addr , int * err_ret ) ;

void sdio_f0_writeb ( struct sdio_func * func , unsigned char b , unsigned int addr , int * err_ret ) ;

int sdio_claim_irq ( struct sdio_func * func , sdio_irq_handler_t * handler ) ;

int sdio_release_irq ( struct sdio_func * func ) ;

void mmc_add_host_debugfs ( struct mmc_host * host ) ;

void mmc_remove_host_debugfs ( struct mmc_host * host ) ;

void mmc_add_card_debugfs ( struct mmc_card * card ) ;

void mmc_remove_card_debugfs ( struct mmc_card * card ) ;

typedef union { unsigned long x [ ( ( ( 4 * 8 ) + 64 - 1 ) / 64 ) ] ; } map_word ;

struct map_info { const char * name ; unsigned long size ; resource_size_t phys ; void * virt ; void * cached ; int bankwidth ; map_word ( * read ) ( struct map_info * , unsigned long ) ; void ( * copy_from ) ( struct map_info * , void * , unsigned long , ssize_t ) ; void ( * write ) ( struct map_info * , const map_word , unsigned long ) ; void ( * copy_to ) ( struct map_info * , unsigned long , const void * , ssize_t ) ; void ( * inval_cache ) ( struct map_info * , unsigned long , ssize_t ) ; void ( * set_vpp ) ( struct map_info * , int ) ; unsigned long pfow_base ; unsigned long map_priv_1 ; unsigned long map_priv_2 ; void * fldrv_priv ; struct mtd_chip_driver * fldrv ; } ;
struct mtd_chip_driver { struct mtd_info * ( * probe ) ( struct map_info * map ) ; void ( * destroy ) ( struct mtd_info * ) ; struct module * module ; char * name ; struct list_head list ; } ;

void register_mtd_chip_driver ( struct mtd_chip_driver * drv ) ;

void unregister_mtd_chip_driver ( struct mtd_chip_driver * drv ) ;

struct mtd_info * do_map_probe ( const char * name , struct map_info * map ) ;

void map_destroy ( struct mtd_info * mtd ) ;

void simple_map_init ( struct map_info * map ) ;

int add_mtd_device ( struct mtd_info * mtd ) ;

int del_mtd_device ( struct mtd_info * mtd ) ;

void register_mtd_user ( struct mtd_notifier * new ) ;

int unregister_mtd_user ( struct mtd_notifier * old ) ;

struct mtd_info * get_mtd_device ( struct mtd_info * mtd , int num ) ;

struct mtd_info * get_mtd_device_nm ( const char * name ) ;

void put_mtd_device ( struct mtd_info * mtd ) ;

int default_mtd_writev ( struct mtd_info * mtd , const struct kvec * vecs , unsigned long count , loff_t to , size_t * retlen ) ;

int get_sb_mtd ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data , int ( * fill_super ) ( struct super_block * , void * , int ) , struct vfsmount * mnt ) ;

void kill_mtd_super ( struct super_block * sb ) ;

struct mtd_partition { char * name ; uint64_t size ; uint64_t offset ; uint32_t mask_flags ; struct nand_ecclayout * ecclayout ; } ;

struct mtd_part_parser { struct list_head list ; struct module * owner ; const char * name ; int ( * parse_fn ) ( struct mtd_info * , struct mtd_partition * * , unsigned long ) ; } ;

struct device_node ;

struct mtd_part { struct mtd_info mtd ; struct mtd_info * master ; uint64_t offset ; struct list_head list ; } ;

void mtd_erase_callback ( struct erase_info * instr ) ;

int del_mtd_partitions ( struct mtd_info * master ) ;

int add_mtd_partitions ( struct mtd_info * master , const struct mtd_partition * parts , int nbparts ) ;

int register_mtd_parser ( struct mtd_part_parser * p ) ;

int deregister_mtd_parser ( struct mtd_part_parser * p ) ;

int parse_mtd_partitions ( struct mtd_info * master , const char * * types , struct mtd_partition * * pparts , unsigned long origin ) ;

typedef enum { PHY_INTERFACE_MODE_MII , PHY_INTERFACE_MODE_GMII , PHY_INTERFACE_MODE_SGMII , PHY_INTERFACE_MODE_TBI , PHY_INTERFACE_MODE_RMII , PHY_INTERFACE_MODE_RGMII , PHY_INTERFACE_MODE_RGMII_ID , PHY_INTERFACE_MODE_RGMII_RXID , PHY_INTERFACE_MODE_RGMII_TXID , PHY_INTERFACE_MODE_RTBI } phy_interface_t ;

struct mii_bus { const char * name ; char id [ ( 20 - 3 ) ] ; void * priv ; int ( * read ) ( struct mii_bus * bus , int phy_id , int regnum ) ; int ( * write ) ( struct mii_bus * bus , int phy_id , int regnum , u16 val ) ; int ( * reset ) ( struct mii_bus * bus ) ; struct mutex mdio_lock ; struct device * parent ; enum { MDIOBUS_ALLOCATED = 1 , MDIOBUS_REGISTERED , MDIOBUS_UNREGISTERED , MDIOBUS_RELEASED , } state ; struct device dev ; struct phy_device * phy_map [ 32 ] ; u32 phy_mask ; int * irq ; } ;

enum phy_state { PHY_DOWN = 0 , PHY_STARTING , PHY_READY , PHY_PENDING , PHY_UP , PHY_AN , PHY_RUNNING , PHY_NOLINK , PHY_FORCING , PHY_CHANGELINK , PHY_HALTED , PHY_RESUMING } ;

struct phy_device { struct phy_driver * drv ; struct mii_bus * bus ; struct device dev ; u32 phy_id ; enum phy_state state ; u32 dev_flags ; phy_interface_t interface ; int addr ; int speed ; int duplex ; int pause ; int asym_pause ; int link ; u32 interrupts ; u32 supported ; u32 advertising ; int autoneg ; int link_timeout ; int irq ; void * priv ; struct work_struct phy_queue ; struct delayed_work state_queue ; atomic_t irq_disable ; struct mutex lock ; struct net_device * attached_dev ; void ( * adjust_link ) ( struct net_device * dev ) ; void ( * adjust_state ) ( struct net_device * dev ) ; } ;

struct phy_driver { u32 phy_id ; char * name ; unsigned int phy_id_mask ; u32 features ; u32 flags ; int ( * config_init ) ( struct phy_device * phydev ) ; int ( * probe ) ( struct phy_device * phydev ) ; int ( * suspend ) ( struct phy_device * phydev ) ; int ( * resume ) ( struct phy_device * phydev ) ; int ( * config_aneg ) ( struct phy_device * phydev ) ; int ( * read_status ) ( struct phy_device * phydev ) ; int ( * ack_interrupt ) ( struct phy_device * phydev ) ; int ( * config_intr ) ( struct phy_device * phydev ) ; int ( * did_interrupt ) ( struct phy_device * phydev ) ; void ( * remove ) ( struct phy_device * phydev ) ; struct device_driver driver ; } ;

struct phy_fixup { struct list_head list ; char bus_id [ 20 ] ; u32 phy_uid ; u32 phy_uid_mask ; int ( * run ) ( struct phy_device * phydev ) ; } ;

void phy_print_status ( struct phy_device * phydev ) ;

int phy_clear_interrupt ( struct phy_device * phydev ) ;

int phy_config_interrupt ( struct phy_device * phydev , u32 interrupts ) ;

struct phy_setting { int speed ; int duplex ; u32 setting ; } ;

void phy_sanitize_settings ( struct phy_device * phydev ) ;

int phy_ethtool_sset ( struct phy_device * phydev , struct ethtool_cmd * cmd ) ;

int phy_ethtool_gset ( struct phy_device * phydev , struct ethtool_cmd * cmd ) ;

int phy_mii_ioctl ( struct phy_device * phydev , struct mii_ioctl_data * mii_data , int cmd ) ;

int phy_start_aneg ( struct phy_device * phydev ) ;

void phy_start_machine ( struct phy_device * phydev , void ( * handler ) ( struct net_device * ) ) ;

void phy_stop_machine ( struct phy_device * phydev ) ;

int phy_enable_interrupts ( struct phy_device * phydev ) ;

int phy_disable_interrupts ( struct phy_device * phydev ) ;

int phy_start_interrupts ( struct phy_device * phydev ) ;

int phy_stop_interrupts ( struct phy_device * phydev ) ;

void phy_stop ( struct phy_device * phydev ) ;

void phy_start ( struct phy_device * phydev ) ;

void phy_device_free ( struct phy_device * phydev ) ;

int phy_register_fixup ( const char * bus_id , u32 phy_uid , u32 phy_uid_mask , int ( * run ) ( struct phy_device * ) ) ;

int phy_register_fixup_for_uid ( u32 phy_uid , u32 phy_uid_mask , int ( * run ) ( struct phy_device * ) ) ;

int phy_register_fixup_for_id ( const char * bus_id , int ( * run ) ( struct phy_device * ) ) ;

int phy_scan_fixups ( struct phy_device * phydev ) ;

struct phy_device * phy_device_create ( struct mii_bus * bus , int addr , int phy_id ) ;

int get_phy_id ( struct mii_bus * bus , int addr , u32 * phy_id ) ;

struct phy_device * get_phy_device ( struct mii_bus * bus , int addr ) ;

int phy_device_register ( struct phy_device * phydev ) ;

void phy_prepare_link ( struct phy_device * phydev , void ( * handler ) ( struct net_device * ) ) ;

int phy_connect_direct ( struct net_device * dev , struct phy_device * phydev , void ( * handler ) ( struct net_device * ) , u32 flags , phy_interface_t interface ) ;

struct phy_device * phy_connect ( struct net_device * dev , const char * bus_id , void ( * handler ) ( struct net_device * ) , u32 flags , phy_interface_t interface ) ;

void phy_disconnect ( struct phy_device * phydev ) ;

int phy_attach_direct ( struct net_device * dev , struct phy_device * phydev , u32 flags , phy_interface_t interface ) ;

struct phy_device * phy_attach ( struct net_device * dev , const char * bus_id , u32 flags , phy_interface_t interface ) ;

void phy_detach ( struct phy_device * phydev ) ;

int genphy_config_advert ( struct phy_device * phydev ) ;

int genphy_setup_forced ( struct phy_device * phydev ) ;

int genphy_restart_aneg ( struct phy_device * phydev ) ;

int genphy_config_aneg ( struct phy_device * phydev ) ;

int genphy_update_link ( struct phy_device * phydev ) ;

int genphy_read_status ( struct phy_device * phydev ) ;

int genphy_suspend ( struct phy_device * phydev ) ;

int genphy_resume ( struct phy_device * phydev ) ;

int phy_driver_register ( struct phy_driver * new_driver ) ;

void phy_driver_unregister ( struct phy_driver * drv ) ;

struct mii_bus * mdiobus_alloc ( void ) ;

int mdiobus_register ( struct mii_bus * bus ) ;

void mdiobus_unregister ( struct mii_bus * bus ) ;

void mdiobus_free ( struct mii_bus * bus ) ;

struct phy_device * mdiobus_scan ( struct mii_bus * bus , int addr ) ;

int mdiobus_read ( struct mii_bus * bus , int addr , u16 regnum ) ;

int mdiobus_write ( struct mii_bus * bus , int addr , u16 regnum , u16 val ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mdio_bus_init ( void ) ;

void mdio_bus_exit ( void ) ;

struct fixed_phy_status { int link ; int speed ; int duplex ; int pause ; int asym_pause ; } ;

struct fixed_mdio_bus { int irqs [ 32 ] ; struct mii_bus * mii_bus ; struct list_head phys ; } ;

struct fixed_phy { int id ; u16 regs [ 29 ] ; struct phy_device * phydev ; struct fixed_phy_status status ; int ( * link_update ) ( struct net_device * , struct fixed_phy_status * ) ; struct list_head node ; } ;

int fixed_phy_set_link_update ( struct phy_device * phydev , int ( * link_update ) ( struct net_device * , struct fixed_phy_status * ) ) ;

int fixed_phy_add ( unsigned int irq , int phy_id , struct fixed_phy_status * status ) ;

struct mdiobb_ctrl ;

struct mdiobb_ops { struct module * owner ; void ( * set_mdc ) ( struct mdiobb_ctrl * ctrl , int level ) ; void ( * set_mdio_dir ) ( struct mdiobb_ctrl * ctrl , int output ) ; void ( * set_mdio_data ) ( struct mdiobb_ctrl * ctrl , int value ) ; int ( * get_mdio_data ) ( struct mdiobb_ctrl * ctrl ) ; } ;

struct mdiobb_ctrl { const struct mdiobb_ops * ops ; } ;
struct mii_bus * alloc_mdio_bitbang ( struct mdiobb_ctrl * ctrl ) ;

void free_mdio_bitbang ( struct mii_bus * bus ) ;

struct mdio_gpio_platform_data { unsigned int mdc ; unsigned int mdio ; unsigned int phy_mask ; int irqs [ 32 ] ; } ;

struct mdio_gpio_info { struct mdiobb_ctrl ctrl ; int mdc , mdio ; } ;

enum hdx_loopback { hdx_loopback_on = 0 , hdx_loopback_off = 1 , } ;

struct trh_hdr { __u8 ac ; __u8 fc ; __u8 daddr [ 6 ] ; __u8 saddr [ 6 ] ; __be16 rcf ; __be16 rseg [ 8 ] ; } ;

struct trllc { __u8 dsap ; __u8 ssap ; __u8 llc ; __u8 protid [ 3 ] ; __be16 ethertype ; } ;

struct tr_statistics { unsigned long rx_packets ; unsigned long tx_packets ; unsigned long rx_bytes ; unsigned long tx_bytes ; unsigned long rx_errors ; unsigned long tx_errors ; unsigned long rx_dropped ; unsigned long tx_dropped ; unsigned long multicast ; unsigned long transmit_collision ; unsigned long line_errors ; unsigned long internal_errors ; unsigned long burst_errors ; unsigned long A_C_errors ; unsigned long abort_delimiters ; unsigned long lost_frames ; unsigned long recv_congest_count ; unsigned long frame_copied_errors ; unsigned long frequency_errors ; unsigned long token_errors ; unsigned long dummy1 ; } ;

struct devprobe2 { struct net_device * ( * probe ) ( int unit ) ; int status ; } ;

struct arpreq { struct sockaddr arp_pa ; struct sockaddr arp_ha ; int arp_flags ; struct sockaddr arp_netmask ; char arp_dev [ 16 ] ; } ;

struct arpreq_old { struct sockaddr arp_pa ; struct sockaddr arp_ha ; int arp_flags ; struct sockaddr arp_netmask ; } ;

struct arphdr { __be16 ar_hrd ; __be16 ar_pro ; unsigned char ar_hln ; unsigned char ar_pln ; __be16 ar_op ; } ;

struct pcpu_lstats { unsigned long packets ; unsigned long bytes ; unsigned long drops ; } ;

struct compressor { int compress_proto ; void * ( * comp_alloc ) ( unsigned char * options , int opt_len ) ; void ( * comp_free ) ( void * state ) ; int ( * comp_init ) ( void * state , unsigned char * options , int opt_len , int unit , int opthdr , int debug ) ; void ( * comp_reset ) ( void * state ) ; int ( * compress ) ( void * state , unsigned char * rptr , unsigned char * obuf , int isize , int osize ) ; void ( * comp_stat ) ( void * state , struct compstat * stats ) ; void * ( * decomp_alloc ) ( unsigned char * options , int opt_len ) ; void ( * decomp_free ) ( void * state ) ; int ( * decomp_init ) ( void * state , unsigned char * options , int opt_len , int unit , int opthdr , int mru , int debug ) ; void ( * decomp_reset ) ( void * state ) ; int ( * decompress ) ( void * state , unsigned char * ibuf , int isize , unsigned char * obuf , int osize ) ; void ( * incomp ) ( void * state , unsigned char * ibuf , int icnt ) ; void ( * decomp_stat ) ( void * state , struct compstat * stats ) ; struct module * owner ; unsigned int comp_extra ; } ;

typedef __u8 byte_t ;

typedef __u32 int32 ;

struct cstate { byte_t cs_this ; struct cstate * next ; struct iphdr cs_ip ; struct tcphdr cs_tcp ; unsigned char cs_ipopt [ 64 ] ; unsigned char cs_tcpopt [ 64 ] ; int cs_hsize ; } ;

struct slcompress { struct cstate * tstate ; struct cstate * rstate ; byte_t tslot_limit ; byte_t rslot_limit ; byte_t xmit_oldest ; byte_t xmit_current ; byte_t recv_current ; byte_t flags ; int32 sls_o_nontcp ; int32 sls_o_tcp ; int32 sls_o_uncompressed ; int32 sls_o_compressed ; int32 sls_o_searches ; int32 sls_o_misses ; int32 sls_i_uncompressed ; int32 sls_i_compressed ; int32 sls_i_error ; int32 sls_i_tossed ; int32 sls_i_runt ; int32 sls_i_badcheck ; } ;

struct net_generic { unsigned int len ; struct rcu_head rcu ; void * ptr [ 0 ] ; } ;
struct ppp_file { enum { INTERFACE = 1 , CHANNEL } kind ; struct sk_buff_head xq ; struct sk_buff_head rq ; wait_queue_head_t rwait ; atomic_t refcnt ; int hdrlen ; int index ; int dead ; } ;

struct ppp { struct ppp_file file ; struct file * owner ; struct list_head channels ; int n_channels ; spinlock_t rlock ; spinlock_t wlock ; int mru ; unsigned int flags ; unsigned int xstate ; unsigned int rstate ; int debug ; struct slcompress * vj ; enum NPmode npmode [ 6 ] ; struct sk_buff * xmit_pending ; struct compressor * xcomp ; void * xc_state ; struct compressor * rcomp ; void * rc_state ; unsigned long last_xmit ; unsigned long last_recv ; struct net_device * dev ; int closing ; int nxchan ; u32 nxseq ; int mrru ; u32 nextseq ; u32 minseq ; struct sk_buff_head mrq ; struct sock_filter * pass_filter ; struct sock_filter * active_filter ; unsigned pass_len , active_len ; struct net * ppp_net ; } ;

struct channel { struct ppp_file file ; struct list_head list ; struct ppp_channel * chan ; struct rw_semaphore chan_sem ; spinlock_t downl ; struct ppp * ppp ; struct net * chan_net ; struct list_head clist ; rwlock_t upl ; u8 avail ; u8 had_frag ; u32 lastseq ; int speed ; } ;

struct ppp_net { struct idr units_idr ; struct mutex all_ppp_mutex ; struct list_head all_channels ; struct list_head new_channels ; int last_channel_index ; spinlock_t all_channels_lock ; } ;

void ppp_input ( struct ppp_channel * chan , struct sk_buff * skb ) ;

void ppp_input_error ( struct ppp_channel * chan , int code ) ;

int ppp_register_channel ( struct ppp_channel * chan ) ;

int ppp_register_net_channel ( struct net * net , struct ppp_channel * chan ) ;

int ppp_channel_index ( struct ppp_channel * chan ) ;

int ppp_unit_number ( struct ppp_channel * chan ) ;

void ppp_unregister_channel ( struct ppp_channel * chan ) ;

void ppp_output_wakeup ( struct ppp_channel * chan ) ;

struct compressor_entry { struct list_head list ; struct compressor * comp ; } ;

int ppp_register_compressor ( struct compressor * cp ) ;

void ppp_unregister_compressor ( struct compressor * cp ) ;

struct net_protocol { int ( * handler ) ( struct sk_buff * skb ) ; void ( * err_handler ) ( struct sk_buff * skb , u32 info ) ; int ( * gso_send_check ) ( struct sk_buff * skb ) ; struct sk_buff * ( * gso_segment ) ( struct sk_buff * skb , int features ) ; struct sk_buff * * ( * gro_receive ) ( struct sk_buff * * head , struct sk_buff * skb ) ; int ( * gro_complete ) ( struct sk_buff * skb ) ; unsigned int no_policy : 1 , netns_ok : 1 ; } ;

struct inet6_protocol { int ( * handler ) ( struct sk_buff * skb ) ; void ( * err_handler ) ( struct sk_buff * skb , struct inet6_skb_parm * opt , u8 type , u8 code , int offset , __be32 info ) ; int ( * gso_send_check ) ( struct sk_buff * skb ) ; struct sk_buff * ( * gso_segment ) ( struct sk_buff * skb , int features ) ; struct sk_buff * * ( * gro_receive ) ( struct sk_buff * * head , struct sk_buff * skb ) ; int ( * gro_complete ) ( struct sk_buff * skb ) ; unsigned int flags ; } ;

struct inet_protosw { struct list_head list ; unsigned short type ; unsigned short protocol ; struct proto * prot ; const struct proto_ops * ops ; int capability ; char no_check ; unsigned char flags ; } ;

struct slcompress * slhc_init ( int rslots , int tslots ) ;

void slhc_free ( struct slcompress * comp ) ;

int slhc_compress ( struct slcompress * comp , unsigned char * icp , int isize , unsigned char * ocp , unsigned char * * cpp , int compress_cid ) ;

int slhc_uncompress ( struct slcompress * comp , unsigned char * icp , int isize ) ;

int slhc_remember ( struct slcompress * comp , unsigned char * icp , int isize ) ;

int slhc_toss ( struct slcompress * comp ) ;

struct virtio_net_config { __u8 mac [ 6 ] ; __u16 status ; } __attribute__ ( ( packed ) ) ;
struct virtio_net_hdr { __u8 flags ; __u8 gso_type ; __u16 hdr_len ; __u16 gso_size ; __u16 csum_start ; __u16 csum_offset ; } ;

struct virtio_net_hdr_mrg_rxbuf { struct virtio_net_hdr hdr ; __u16 num_buffers ; } ;

struct virtio_net_ctrl_hdr { __u8 class ; __u8 cmd ; } __attribute__ ( ( packed ) ) ;
typedef __u8 virtio_net_ctrl_ack ;

struct virtio_net_ctrl_mac { __u32 entries ; __u8 macs [ ] [ 6 ] ; } __attribute__ ( ( packed ) ) ;
struct tap_filter { unsigned int count ; u32 mask [ 2 ] ; unsigned char addr [ 8 ] [ 6 ] ; } ;

struct tun_file { atomic_t count ; struct tun_struct * tun ; struct net * net ; } ;

struct tun_sock ;

struct tun_struct { struct tun_file * tfile ; unsigned int flags ; uid_t owner ; gid_t group ; struct net_device * dev ; struct fasync_struct * fasync ; struct tap_filter txflt ; struct socket socket ; } ;

struct tun_sock { struct sock sk ; struct tun_struct * tun ; } ;
struct vlan_hdr { __be16 h_vlan_TCI ; __be16 h_vlan_encapsulated_proto ; } ;

struct vlan_ethhdr { unsigned char h_dest [ 6 ] ; unsigned char h_source [ 6 ] ; __be16 h_vlan_proto ; __be16 h_vlan_TCI ; __be16 h_vlan_encapsulated_proto ; } ;

struct vlan_group { struct net_device * real_dev ; unsigned int nr_vlans ; struct hlist_node hlist ; struct net_device * * vlan_devices_arrays [ 8 ] ; struct rcu_head rcu ; } ;
enum vlan_ioctl_cmds { ADD_VLAN_CMD , DEL_VLAN_CMD , SET_VLAN_INGRESS_PRIORITY_CMD , SET_VLAN_EGRESS_PRIORITY_CMD , GET_VLAN_INGRESS_PRIORITY_CMD , GET_VLAN_EGRESS_PRIORITY_CMD , SET_VLAN_NAME_TYPE_CMD , SET_VLAN_FLAG_CMD , GET_VLAN_REALDEV_NAME_CMD , GET_VLAN_VID_CMD } ;

enum vlan_flags { VLAN_FLAG_REORDER_HDR = 0x1 , VLAN_FLAG_GVRP = 0x2 , } ;

enum vlan_name_types { VLAN_NAME_TYPE_PLUS_VID , VLAN_NAME_TYPE_RAW_PLUS_VID , VLAN_NAME_TYPE_PLUS_VID_NO_PAD , VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD , VLAN_NAME_TYPE_HIGHEST } ;

struct vlan_ioctl_args { int cmd ; char device1 [ 24 ] ; union { char device2 [ 24 ] ; int VID ; unsigned int skb_priority ; unsigned int name_type ; unsigned int bind_type ; unsigned int flag ; } u ; short vlan_qos ; } ;

struct virtnet_info { struct virtio_device * vdev ; struct virtqueue * rvq , * svq , * cvq ; struct net_device * dev ; struct napi_struct napi ; unsigned int status ; unsigned int num , max ; bool big_packets ; bool mergeable_rx_bufs ; struct sk_buff_head recv ; struct sk_buff_head send ; struct delayed_work refill ; struct page * pages ; } ;

struct skb_vnet_hdr { union { struct virtio_net_hdr hdr ; struct virtio_net_hdr_mrg_rxbuf mhdr ; } ; unsigned int num_sg ; } ;

struct ppp_deflate_state { int seqno ; int w_size ; int unit ; int mru ; int debug ; z_stream strm ; struct compstat stats ; } ;

int parport_register_driver ( struct parport_driver * drv ) ;

void parport_unregister_driver ( struct parport_driver * drv ) ;

struct parport * parport_get_port ( struct parport * port ) ;

void parport_put_port ( struct parport * port ) ;

struct parport * parport_register_port ( unsigned long base , int irq , int dma , struct parport_operations * ops ) ;

void parport_announce_port ( struct parport * port ) ;

void parport_remove_port ( struct parport * port ) ;

struct pardevice * parport_register_device ( struct parport * port , const char * name , int ( * pf ) ( void * ) , void ( * kf ) ( void * ) , void ( * irq_func ) ( void * ) , int flags , void * handle ) ;

void parport_unregister_device ( struct pardevice * dev ) ;

struct parport * parport_find_number ( int number ) ;

struct parport * parport_find_base ( unsigned long base ) ;

int parport_claim ( struct pardevice * dev ) ;

int parport_claim_or_block ( struct pardevice * dev ) ;

void parport_release ( struct pardevice * dev ) ;

irqreturn_t parport_irq_handler ( int irq , void * dev_id ) ;

int parport_wait_event ( struct parport * port , signed long timeout ) ;

int parport_poll_peripheral ( struct parport * port , unsigned char mask , unsigned char result , int usec ) ;

int parport_wait_peripheral ( struct parport * port , unsigned char mask , unsigned char result ) ;

int parport_negotiate ( struct parport * port , int mode ) ;

void parport_ieee1284_interrupt ( void * handle ) ;

ssize_t parport_write ( struct parport * port , const void * buffer , size_t len ) ;

ssize_t parport_read ( struct parport * port , void * buffer , size_t len ) ;

long parport_set_timeout ( struct pardevice * dev , long inactivity ) ;

size_t parport_ieee1284_write_compat ( struct parport * port , const void * buffer , size_t len , int flags ) ;

size_t parport_ieee1284_read_nibble ( struct parport * port , void * buffer , size_t len , int flags ) ;

size_t parport_ieee1284_read_byte ( struct parport * port , void * buffer , size_t len , int flags ) ;

size_t parport_ieee1284_ecp_write_data ( struct parport * port , const void * buffer , size_t len , int flags ) ;

size_t parport_ieee1284_ecp_read_data ( struct parport * port , void * buffer , size_t len , int flags ) ;

size_t parport_ieee1284_ecp_write_addr ( struct parport * port , const void * buffer , size_t len , int flags ) ;

size_t parport_ieee1284_epp_write_data ( struct parport * port , const void * buffer , size_t len , int flags ) ;

size_t parport_ieee1284_epp_read_data ( struct parport * port , void * buffer , size_t len , int flags ) ;

size_t parport_ieee1284_epp_write_addr ( struct parport * port , const void * buffer , size_t len , int flags ) ;

size_t parport_ieee1284_epp_read_addr ( struct parport * port , void * buffer , size_t len , int flags ) ;

struct parport_sysctl_table { struct ctl_table_header * sysctl_header ; ctl_table vars [ 12 ] ; ctl_table device_dir [ 2 ] ; ctl_table port_dir [ 2 ] ; ctl_table parport_dir [ 2 ] ; ctl_table dev_dir [ 2 ] ; } ;

struct parport_device_sysctl_table { struct ctl_table_header * sysctl_header ; ctl_table vars [ 2 ] ; ctl_table device_dir [ 2 ] ; ctl_table devices_root_dir [ 2 ] ; ctl_table port_dir [ 2 ] ; ctl_table parport_dir [ 2 ] ; ctl_table dev_dir [ 2 ] ; } ;

struct parport_default_sysctl_table { struct ctl_table_header * sysctl_header ; ctl_table vars [ 3 ] ; ctl_table default_dir [ 2 ] ; ctl_table parport_dir [ 2 ] ; ctl_table dev_dir [ 2 ] ; } ;

int parport_proc_register ( struct parport * port ) ;

int parport_proc_unregister ( struct parport * port ) ;

int parport_device_proc_register ( struct pardevice * device ) ;

int parport_device_proc_unregister ( struct pardevice * device ) ;


int parport_daisy_init ( struct parport * port ) ;

void parport_daisy_fini ( struct parport * port ) ;

struct pardevice * parport_open ( int devnum , const char * name ) ;

void parport_close ( struct pardevice * dev ) ;

void parport_daisy_deselect_all ( struct parport * port ) ;

int parport_daisy_select ( struct parport * port , int daisy , int mode ) ;

ssize_t parport_device_id ( int devnum , char * buffer , size_t count ) ;


struct parport * parport_pc_probe_port ( unsigned long int base , unsigned long int base_hi , int irq , int dma , struct device * dev , int irqflags ) ;

void parport_pc_unregister_port ( struct parport * p ) ;

enum parport_pc_sio_types { sio_via_686a = 0 , sio_via_8231 , sio_ite_8872 , last_sio } ;


enum parport_pc_pci_cards { siig_1p_10x = last_sio , siig_2p_10x , siig_1p_20x , siig_2p_20x , lava_parallel , lava_parallel_dual_a , lava_parallel_dual_b , boca_ioppar , plx_9050 , timedia_4078a , timedia_4079h , timedia_4085h , timedia_4088a , timedia_4089a , timedia_4095a , timedia_4096a , timedia_4078u , timedia_4079a , timedia_4085u , timedia_4079r , timedia_4079s , timedia_4079d , timedia_4079e , timedia_4079f , timedia_9079a , timedia_9079b , timedia_9079c , timedia_4006a , timedia_4014 , timedia_4008a , timedia_4018 , timedia_9018a , syba_2p_epp , syba_1p_ecp , titan_010l , titan_1284p1 , titan_1284p2 , avlab_1p , avlab_2p , oxsemi_952 , oxsemi_954 , oxsemi_840 , oxsemi_pcie_pport , aks_0100 , mobility_pp , netmos_9705 , netmos_9715 , netmos_9755 , netmos_9805 , netmos_9815 , netmos_9901 , quatech_sppxp100 , } ;


struct pci_parport_data { int num ; struct parport * ports [ 2 ] ; } ;

struct pci_platform_pm_ops { bool ( * is_manageable ) ( struct pci_dev * dev ) ; int ( * set_state ) ( struct pci_dev * dev , pci_power_t state ) ; pci_power_t ( * choose_state ) ( struct pci_dev * dev ) ; bool ( * can_wakeup ) ( struct pci_dev * dev ) ; int ( * sleep_wake ) ( struct pci_dev * dev , bool enable ) ; } ;

struct pci_vpd_ops { ssize_t ( * read ) ( struct pci_dev * dev , loff_t pos , size_t count , void * buf ) ; ssize_t ( * write ) ( struct pci_dev * dev , loff_t pos , size_t count , const void * buf ) ; void ( * release ) ( struct pci_dev * dev ) ; } ;

struct pci_vpd { unsigned int len ; const struct pci_vpd_ops * ops ; struct bin_attribute * attr ; } ;
struct pci_slot_attribute { struct attribute attr ; ssize_t ( * show ) ( struct pci_slot * , char * ) ; ssize_t ( * store ) ( struct pci_slot * , const char * , size_t ) ; } ;

enum pci_bar_type { pci_bar_unknown , pci_bar_io , pci_bar_mem32 , pci_bar_mem64 , } ;

struct pci_sriov { int pos ; int nres ; u32 cap ; u16 ctrl ; u16 total ; u16 initial ; u16 nr_virtfn ; u16 offset ; u16 stride ; u32 pgsz ; u8 link ; struct pci_dev * dev ; struct pci_dev * self ; struct mutex lock ; struct work_struct mtask ; u8 * mstate ; } ;
struct pci_ats { int pos ; int stu ; int qdep ; int ref_cnt ; int is_enabled : 1 ; } ;
int pci_bus_read_config_byte ( struct pci_bus * bus , unsigned int devfn , int pos , u8 * value ) ;

int pci_bus_read_config_word ( struct pci_bus * bus , unsigned int devfn , int pos , u16 * value ) ;

int pci_bus_read_config_dword ( struct pci_bus * bus , unsigned int devfn , int pos , u32 * value ) ;

int pci_bus_write_config_byte ( struct pci_bus * bus , unsigned int devfn , int pos , u8 value ) ;

int pci_bus_write_config_word ( struct pci_bus * bus , unsigned int devfn , int pos , u16 value ) ;

int pci_bus_write_config_dword ( struct pci_bus * bus , unsigned int devfn , int pos , u32 value ) ;

struct pci_ops * pci_bus_set_ops ( struct pci_bus * bus , struct pci_ops * ops ) ;

ssize_t pci_read_vpd ( struct pci_dev * dev , loff_t pos , size_t count , void * buf ) ;

ssize_t pci_write_vpd ( struct pci_dev * dev , loff_t pos , size_t count , const void * buf ) ;

int pci_user_read_config_byte ( struct pci_dev * dev , int pos , u8 * val ) ;

int pci_user_read_config_word ( struct pci_dev * dev , int pos , u16 * val ) ;

int pci_user_read_config_dword ( struct pci_dev * dev , int pos , u32 * val ) ;

int pci_user_write_config_byte ( struct pci_dev * dev , int pos , u8 val ) ;

int pci_user_write_config_word ( struct pci_dev * dev , int pos , u16 val ) ;

int pci_user_write_config_dword ( struct pci_dev * dev , int pos , u32 val ) ;

struct pci_vpd_pci22 { struct pci_vpd base ; struct mutex lock ; u16 flag ; bool busy ; u8 cap ; } ;

int pci_vpd_pci22_init ( struct pci_dev * dev ) ;

int pci_vpd_truncate ( struct pci_dev * dev , size_t size ) ;

void pci_block_user_cfg_access ( struct pci_dev * dev ) ;

void pci_unblock_user_cfg_access ( struct pci_dev * dev ) ;

int pci_bus_alloc_resource ( struct pci_bus * bus , struct resource * res , resource_size_t size , resource_size_t align , resource_size_t min , unsigned int type_mask , void ( * alignf ) ( void * , struct resource * , resource_size_t , resource_size_t ) , void * alignf_data ) ;

int pci_bus_add_device ( struct pci_dev * dev ) ;

int pci_bus_add_child ( struct pci_bus * bus ) ;

void pci_bus_add_devices ( const struct pci_bus * bus ) ;

void pci_enable_bridges ( struct pci_bus * bus ) ;

void pci_walk_bus ( struct pci_bus * top , int ( * cb ) ( struct pci_dev * , void * ) , void * userdata ) ;

int no_pci_devices ( void ) ;

int __pci_read_base ( struct pci_dev * dev , enum pci_bar_type type , struct resource * res , unsigned int pos ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pci_read_bridge_bases ( struct pci_bus * child ) ;

struct pci_bus * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) pci_add_new_bus ( struct pci_bus * parent , struct pci_dev * dev , int busnr ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pci_scan_bridge ( struct pci_bus * bus , struct pci_dev * dev , int max , int pass ) ;

int pci_setup_device ( struct pci_dev * dev ) ;

int pci_cfg_space_size_ext ( struct pci_dev * dev ) ;

int pci_cfg_space_size ( struct pci_dev * dev ) ;

struct pci_dev * alloc_pci_dev ( void ) ;

void pci_device_add ( struct pci_dev * dev , struct pci_bus * bus ) ;

struct pci_dev * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) pci_scan_single_device ( struct pci_bus * bus , int devfn ) ;

int pci_scan_slot ( struct pci_bus * bus , int devfn ) ;

unsigned int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pci_scan_child_bus ( struct pci_bus * bus ) ;

struct pci_bus * pci_create_bus ( struct device * parent , int bus , struct pci_ops * ops , void * sysdata ) ;

struct pci_bus * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pci_scan_bus_parented ( struct device * parent , int bus , struct pci_ops * ops , void * sysdata ) ;

unsigned int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) pci_rescan_bus ( struct pci_bus * bus ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_sort_breadthfirst ( void ) ;

void pci_remove_bus ( struct pci_bus * pci_bus ) ;

void pci_remove_bus_device ( struct pci_dev * dev ) ;

void pci_remove_behind_bridge ( struct pci_dev * dev ) ;

void pci_stop_bus_device ( struct pci_dev * dev ) ;

unsigned char pci_bus_max_busnr ( struct pci_bus * bus ) ;

void * pci_ioremap_bar ( struct pci_dev * pdev , int bar ) ;

int pci_find_next_capability ( struct pci_dev * dev , u8 pos , int cap ) ;

int pci_find_capability ( struct pci_dev * dev , int cap ) ;

int pci_bus_find_capability ( struct pci_bus * bus , unsigned int devfn , int cap ) ;

int pci_find_ext_capability ( struct pci_dev * dev , int cap ) ;

int pci_find_next_ht_capability ( struct pci_dev * dev , int pos , int ht_cap ) ;

int pci_find_ht_capability ( struct pci_dev * dev , int ht_cap ) ;

struct resource * pci_find_parent_resource ( const struct pci_dev * dev , struct resource * res ) ;

int pci_set_platform_pm ( struct pci_platform_pm_ops * ops ) ;

void pci_update_current_state ( struct pci_dev * dev , pci_power_t state ) ;

int __pci_complete_power_transition ( struct pci_dev * dev , pci_power_t state ) ;

int pci_set_power_state ( struct pci_dev * dev , pci_power_t state ) ;

pci_power_t pci_choose_state ( struct pci_dev * dev , pm_message_t state ) ;

int pci_save_state ( struct pci_dev * dev ) ;

int pci_restore_state ( struct pci_dev * dev ) ;

int pci_reenable_device ( struct pci_dev * dev ) ;

int pci_enable_device_io ( struct pci_dev * dev ) ;

int pci_enable_device_mem ( struct pci_dev * dev ) ;

int pci_enable_device ( struct pci_dev * dev ) ;

struct pci_devres { unsigned int enabled : 1 ; unsigned int pinned : 1 ; unsigned int orig_intx : 1 ; unsigned int restore_intx : 1 ; u32 region_mask ; } ;

int pcim_enable_device ( struct pci_dev * pdev ) ;

void pcim_pin_device ( struct pci_dev * pdev ) ;

void __attribute__ ( ( weak ) ) pcibios_disable_device ( struct pci_dev * dev ) ;

void pci_disable_enabled_device ( struct pci_dev * dev ) ;

void pci_disable_device ( struct pci_dev * dev ) ;

int __attribute__ ( ( weak ) ) pcibios_set_pcie_reset_state ( struct pci_dev * dev , enum pcie_reset_state state ) ;

int pci_set_pcie_reset_state ( struct pci_dev * dev , enum pcie_reset_state state ) ;

bool pci_pme_capable ( struct pci_dev * dev , pci_power_t state ) ;

void pci_pme_active ( struct pci_dev * dev , bool enable ) ;

int pci_enable_wake ( struct pci_dev * dev , pci_power_t state , bool enable ) ;

int pci_wake_from_d3 ( struct pci_dev * dev , bool enable ) ;

pci_power_t pci_target_state ( struct pci_dev * dev ) ;

int pci_prepare_to_sleep ( struct pci_dev * dev ) ;

int pci_back_from_sleep ( struct pci_dev * dev ) ;

void pci_pm_init ( struct pci_dev * dev ) ;

void platform_pci_wakeup_init ( struct pci_dev * dev ) ;

void pci_allocate_cap_save_buffers ( struct pci_dev * dev ) ;

void pci_enable_ari ( struct pci_dev * dev ) ;

u8 pci_swizzle_interrupt_pin ( struct pci_dev * dev , u8 pin ) ;

int pci_get_interrupt_pin ( struct pci_dev * dev , struct pci_dev * * bridge ) ;

u8 pci_common_swizzle ( struct pci_dev * dev , u8 * pinp ) ;

void pci_release_region ( struct pci_dev * pdev , int bar ) ;

int pci_request_region ( struct pci_dev * pdev , int bar , const char * res_name ) ;

int pci_request_region_exclusive ( struct pci_dev * pdev , int bar , const char * res_name ) ;

void pci_release_selected_regions ( struct pci_dev * pdev , int bars ) ;

int __pci_request_selected_regions ( struct pci_dev * pdev , int bars , const char * res_name , int excl ) ;

int pci_request_selected_regions ( struct pci_dev * pdev , int bars , const char * res_name ) ;

int pci_request_selected_regions_exclusive ( struct pci_dev * pdev , int bars , const char * res_name ) ;

void pci_release_regions ( struct pci_dev * pdev ) ;

int pci_request_regions ( struct pci_dev * pdev , const char * res_name ) ;

int pci_request_regions_exclusive ( struct pci_dev * pdev , const char * res_name ) ;

void pci_set_master ( struct pci_dev * dev ) ;

void pci_clear_master ( struct pci_dev * dev ) ;

int pci_set_mwi ( struct pci_dev * dev ) ;

int pci_try_set_mwi ( struct pci_dev * dev ) ;

void pci_clear_mwi ( struct pci_dev * dev ) ;

void pci_intx ( struct pci_dev * pdev , int enable ) ;

void pci_msi_off ( struct pci_dev * dev ) ;

int pci_set_dma_mask ( struct pci_dev * dev , u64 mask ) ;

int pci_set_consistent_dma_mask ( struct pci_dev * dev , u64 mask ) ;

int pci_set_dma_max_seg_size ( struct pci_dev * dev , unsigned int size ) ;

int pci_set_dma_seg_boundary ( struct pci_dev * dev , unsigned long mask ) ;

int __pci_reset_function ( struct pci_dev * dev ) ;

int pci_probe_reset_function ( struct pci_dev * dev ) ;

int pci_reset_function ( struct pci_dev * dev ) ;

int pcix_get_max_mmrbc ( struct pci_dev * dev ) ;

int pcix_get_mmrbc ( struct pci_dev * dev ) ;

int pcix_set_mmrbc ( struct pci_dev * dev , int mmrbc ) ;

int pcie_get_readrq ( struct pci_dev * dev ) ;

int pcie_set_readrq ( struct pci_dev * dev , int rq ) ;

int pci_select_bars ( struct pci_dev * dev , unsigned long flags ) ;

int pci_resource_bar ( struct pci_dev * dev , int resno , enum pci_bar_type * type ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_register_set_vga_state ( arch_set_vga_state_t func ) ;

int pci_set_vga_state ( struct pci_dev * dev , bool decode , unsigned int command_bits , bool change_bridge ) ;

resource_size_t pci_specified_resource_alignment ( struct pci_dev * dev ) ;

int pci_is_reassigndev ( struct pci_dev * dev ) ;

ssize_t pci_set_resource_alignment_param ( const char * buf , size_t count ) ;

ssize_t pci_get_resource_alignment_param ( char * buf , size_t size ) ;

int __attribute__ ( ( weak ) ) pci_ext_cfg_avail ( struct pci_dev * dev ) ;

void __attribute__ ( ( weak ) ) pci_fixup_cardbus ( struct pci_bus * bus ) ;

void pci_fixup_device ( enum pci_fixup_pass pass , struct pci_dev * dev ) ;

struct pci_dynid { struct list_head node ; struct pci_device_id id ; } ;

int pci_add_dynid ( struct pci_driver * drv , unsigned int vendor , unsigned int device , unsigned int subvendor , unsigned int subdevice , unsigned int class , unsigned int class_mask , unsigned long driver_data ) ;

const struct pci_device_id * pci_match_id ( const struct pci_device_id * ids , struct pci_dev * dev ) ;

struct drv_dev_and_id { struct pci_driver * drv ; struct pci_dev * dev ; const struct pci_device_id * id ; } ;

int __pci_register_driver ( struct pci_driver * drv , struct module * owner , const char * mod_name ) ;

void pci_unregister_driver ( struct pci_driver * drv ) ;

struct pci_driver * pci_dev_driver ( const struct pci_dev * dev ) ;

struct pci_dev * pci_dev_get ( struct pci_dev * dev ) ;

void pci_dev_put ( struct pci_dev * dev ) ;

struct pci_dev * pci_find_upstream_pcie_bridge ( struct pci_dev * pdev ) ;

struct pci_bus * pci_find_bus ( int domain , int busnr ) ;

struct pci_bus * pci_find_next_bus ( const struct pci_bus * from ) ;

struct pci_dev * pci_get_slot ( struct pci_bus * bus , unsigned int devfn ) ;

struct pci_dev * pci_get_bus_and_slot ( unsigned int bus , unsigned int devfn ) ;

struct pci_dev * pci_get_subsys ( unsigned int vendor , unsigned int device , unsigned int ss_vendor , unsigned int ss_device , struct pci_dev * from ) ;

struct pci_dev * pci_get_device ( unsigned int vendor , unsigned int device , struct pci_dev * from ) ;

struct pci_dev * pci_get_class ( unsigned int class , struct pci_dev * from ) ;

int pci_dev_present ( const struct pci_device_id * ids ) ;

int pci_mmap_fits ( struct pci_dev * pdev , int resno , struct vm_area_struct * vma ) ;

int __attribute__ ( ( weak ) ) pcibios_add_platform_entries ( struct pci_dev * dev ) ;

int pci_create_sysfs_dev_files ( struct pci_dev * pdev ) ;

void pci_remove_sysfs_dev_files ( struct pci_dev * pdev ) ;

int pci_enable_rom ( struct pci_dev * pdev ) ;

void pci_disable_rom ( struct pci_dev * pdev ) ;

size_t pci_get_rom_size ( struct pci_dev * pdev , void * rom , size_t size ) ;

void * pci_map_rom ( struct pci_dev * pdev , size_t * size ) ;

void pci_unmap_rom ( struct pci_dev * pdev , void * rom ) ;

void pci_cleanup_rom ( struct pci_dev * pdev ) ;

void pci_update_resource ( struct pci_dev * dev , int resno ) ;

int pci_claim_resource ( struct pci_dev * dev , int resource ) ;

void pci_disable_bridge_window ( struct pci_dev * dev ) ;

int pci_assign_resource ( struct pci_dev * dev , int resno ) ;

void pdev_sort_resources ( struct pci_dev * dev , struct resource_list * head ) ;

int pci_enable_resources ( struct pci_dev * dev , int mask ) ;

enum pci_lost_interrupt_reason pci_lost_interrupt ( struct pci_dev * pdev ) ;

struct pci_filp_private { enum pci_mmap_state mmap_state ; int write_combine ; } ;

int pci_proc_attach_device ( struct pci_dev * dev ) ;

int pci_proc_detach_device ( struct pci_dev * dev ) ;

int pci_proc_detach_bus ( struct pci_bus * bus ) ;

struct pci_slot * pci_create_slot ( struct pci_bus * parent , int slot_nr , const char * name , struct hotplug_slot * hotplug ) ;

void pci_renumber_slot ( struct pci_slot * slot , int slot_nr ) ;

void pci_destroy_slot ( struct pci_slot * slot ) ;

enum pci_bus_speed { PCI_SPEED_33MHz = 0x00 , PCI_SPEED_66MHz = 0x01 , PCI_SPEED_66MHz_PCIX = 0x02 , PCI_SPEED_100MHz_PCIX = 0x03 , PCI_SPEED_133MHz_PCIX = 0x04 , PCI_SPEED_66MHz_PCIX_ECC = 0x05 , PCI_SPEED_100MHz_PCIX_ECC = 0x06 , PCI_SPEED_133MHz_PCIX_ECC = 0x07 , PCI_SPEED_66MHz_PCIX_266 = 0x09 , PCI_SPEED_100MHz_PCIX_266 = 0x0a , PCI_SPEED_133MHz_PCIX_266 = 0x0b , PCI_SPEED_66MHz_PCIX_533 = 0x11 , PCI_SPEED_100MHz_PCIX_533 = 0x12 , PCI_SPEED_133MHz_PCIX_533 = 0x13 , PCI_SPEED_UNKNOWN = 0xff , } ;

enum pcie_link_width { PCIE_LNK_WIDTH_RESRV = 0x00 , PCIE_LNK_X1 = 0x01 , PCIE_LNK_X2 = 0x02 , PCIE_LNK_X4 = 0x04 , PCIE_LNK_X8 = 0x08 , PCIE_LNK_X12 = 0x0C , PCIE_LNK_X16 = 0x10 , PCIE_LNK_X32 = 0x20 , PCIE_LNK_WIDTH_UNKNOWN = 0xFF , } ;

enum pcie_link_speed { PCIE_2_5GB = 0x14 , PCIE_5_0GB = 0x15 , PCIE_LNK_SPEED_UNKNOWN = 0xFF , } ;

struct hotplug_slot_ops { struct module * owner ; const char * mod_name ; int ( * enable_slot ) ( struct hotplug_slot * slot ) ; int ( * disable_slot ) ( struct hotplug_slot * slot ) ; int ( * set_attention_status ) ( struct hotplug_slot * slot , u8 value ) ; int ( * hardware_test ) ( struct hotplug_slot * slot , u32 value ) ; int ( * get_power_status ) ( struct hotplug_slot * slot , u8 * value ) ; int ( * get_attention_status ) ( struct hotplug_slot * slot , u8 * value ) ; int ( * get_latch_status ) ( struct hotplug_slot * slot , u8 * value ) ; int ( * get_adapter_status ) ( struct hotplug_slot * slot , u8 * value ) ; int ( * get_max_bus_speed ) ( struct hotplug_slot * slot , enum pci_bus_speed * value ) ; int ( * get_cur_bus_speed ) ( struct hotplug_slot * slot , enum pci_bus_speed * value ) ; } ;

struct hotplug_slot_info { u8 power_status ; u8 attention_status ; u8 latch_status ; u8 adapter_status ; enum pci_bus_speed max_bus_speed ; enum pci_bus_speed cur_bus_speed ; } ;

struct hotplug_slot { struct hotplug_slot_ops * ops ; struct hotplug_slot_info * info ; void ( * release ) ( struct hotplug_slot * slot ) ; void * private ; struct list_head slot_list ; struct pci_slot * pci_slot ; } ;

struct hpp_type0 { u32 revision ; u8 cache_line_size ; u8 latency_timer ; u8 enable_serr ; u8 enable_perr ; } ;

struct hpp_type1 { u32 revision ; u8 max_mem_read ; u8 avg_max_split ; u16 tot_max_split ; } ;

struct hpp_type2 { u32 revision ; u32 unc_err_mask_and ; u32 unc_err_mask_or ; u32 unc_err_sever_and ; u32 unc_err_sever_or ; u32 cor_err_mask_and ; u32 cor_err_mask_or ; u32 adv_err_cap_and ; u32 adv_err_cap_or ; u16 pci_exp_devctl_and ; u16 pci_exp_devctl_or ; u16 pci_exp_lnkctl_and ; u16 pci_exp_lnkctl_or ; u32 sec_unc_err_sever_and ; u32 sec_unc_err_sever_or ; u32 sec_unc_err_mask_and ; u32 sec_unc_err_mask_or ; } ;

struct hotplug_params { struct hpp_type0 * t0 ; struct hpp_type1 * t1 ; struct hpp_type2 * t2 ; struct hpp_type0 type0_data ; struct hpp_type1 type1_data ; struct hpp_type2 type2_data ; } ;

void pci_hp_create_module_link ( struct pci_slot * pci_slot ) ;

void pci_hp_remove_module_link ( struct pci_slot * pci_slot ) ;

struct pci_dev * pci_find_device ( unsigned int vendor , unsigned int device , struct pci_dev * from ) ;

int __pci_hp_register ( struct hotplug_slot * slot , struct pci_bus * bus , int devnr , const char * name , struct module * owner , const char * mod_name ) ;

int pci_hp_deregister ( struct hotplug_slot * hotplug ) ;

int pci_hp_change_slot_info ( struct hotplug_slot * hotplug , struct hotplug_slot_info * info ) ;

void pci_configure_slot ( struct pci_dev * dev ) ;

struct slot { u8 number ; unsigned int devfn ; struct pci_bus * bus ; struct pci_dev * dev ; unsigned int extracting ; struct hotplug_slot * hotplug_slot ; struct list_head slot_list ; } ;

struct cpci_hp_controller_ops { int ( * query_enum ) ( void ) ; int ( * enable_irq ) ( void ) ; int ( * disable_irq ) ( void ) ; int ( * check_irq ) ( void * dev_id ) ; int ( * hardware_test ) ( struct slot * slot , u32 value ) ; u8 ( * get_power ) ( struct slot * slot ) ; int ( * set_power ) ( struct slot * slot , int value ) ; } ;

struct cpci_hp_controller { unsigned int irq ; unsigned long irq_flags ; char * devname ; void * dev_id ; char * name ; struct cpci_hp_controller_ops * ops ; } ;

int cpci_hp_register_bus ( struct pci_bus * bus , u8 first , u8 last ) ;

int cpci_hp_unregister_bus ( struct pci_bus * bus ) ;

int cpci_hp_register_controller ( struct cpci_hp_controller * new_controller ) ;

int cpci_hp_unregister_controller ( struct cpci_hp_controller * old_controller ) ;

int cpci_hp_start ( void ) ;

int cpci_hp_stop ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) cpci_hotplug_init ( int debug ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __used__ ) ) __attribute__ ( ( __cold__ ) ) cpci_hotplug_exit ( void ) ;

u8 cpci_get_attention_status ( struct slot * slot ) ;

int cpci_set_attention_status ( struct slot * slot , int status ) ;

u16 cpci_get_hs_csr ( struct slot * slot ) ;

int cpci_check_and_clear_ins ( struct slot * slot ) ;

int cpci_check_ext ( struct slot * slot ) ;

int cpci_clear_ext ( struct slot * slot ) ;

int cpci_led_on ( struct slot * slot ) ;

int cpci_led_off ( struct slot * slot ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) cpci_configure_slot ( struct slot * slot ) ;

int cpci_unconfigure_slot ( struct slot * slot ) ;

int pci_get_hp_params ( struct pci_dev * dev , struct hotplug_params * hpp ) ;

int acpi_get_hp_hw_control_from_firmware ( struct pci_dev * pdev , u32 flags ) ;

int acpi_pci_check_ejectable ( struct pci_bus * pbus , acpi_handle handle ) ;

int acpi_pci_detect_ejectable ( acpi_handle handle ) ;

struct pcie_port_data { int port_type ; int port_irq_mode ; } ;

struct pcie_device { int irq ; struct pci_dev * port ; u32 service ; void * priv_data ; struct device device ; } ;

struct pcie_port_service_driver { const char * name ; int ( * probe ) ( struct pcie_device * dev ) ; void ( * remove ) ( struct pcie_device * dev ) ; int ( * suspend ) ( struct pcie_device * dev ) ; int ( * resume ) ( struct pcie_device * dev ) ; struct pci_error_handlers * err_handler ; pci_ers_result_t ( * reset_link ) ( struct pci_dev * dev ) ; int port_type ; u32 service ; struct device_driver driver ; } ;

struct slot { u8 state ; struct controller * ctrl ; struct hotplug_slot * hotplug_slot ; struct delayed_work work ; struct mutex lock ; } ;
struct event_info { u32 event_type ; struct slot * p_slot ; struct work_struct work ; } ;

struct controller { struct mutex ctrl_lock ; struct pcie_device * pcie ; struct slot * slot ; wait_queue_head_t queue ; u32 slot_cap ; u8 cap_base ; struct timer_list poll_timer ; unsigned int cmd_busy : 1 ; unsigned int no_cmd_complete : 1 ; unsigned int link_active_reporting : 1 ; unsigned int notification_enabled : 1 ; unsigned int power_fault_detected ; } ;

u8 pciehp_handle_attention_button ( struct slot * p_slot ) ;

u8 pciehp_handle_switch_change ( struct slot * p_slot ) ;

u8 pciehp_handle_presence_change ( struct slot * p_slot ) ;

u8 pciehp_handle_power_fault ( struct slot * p_slot ) ;

struct power_work_info { struct slot * p_slot ; struct work_struct work ; } ;

void pciehp_queue_pushbutton_work ( struct work_struct * work ) ;

int pciehp_enable_slot ( struct slot * p_slot ) ;

int pciehp_disable_slot ( struct slot * p_slot ) ;

int pciehp_sysfs_enable_slot ( struct slot * p_slot ) ;

int pciehp_sysfs_disable_slot ( struct slot * p_slot ) ;

int pciehp_configure_device ( struct slot * p_slot ) ;

int pciehp_unconfigure_device ( struct slot * p_slot ) ;

int pciehp_check_link_status ( struct controller * ctrl ) ;

int pciehp_get_attention_status ( struct slot * slot , u8 * status ) ;

int pciehp_get_power_status ( struct slot * slot , u8 * status ) ;

int pciehp_get_latch_status ( struct slot * slot , u8 * status ) ;

int pciehp_get_adapter_status ( struct slot * slot , u8 * status ) ;

int pciehp_query_power_fault ( struct slot * slot ) ;

int pciehp_set_attention_status ( struct slot * slot , u8 value ) ;

void pciehp_green_led_on ( struct slot * slot ) ;

void pciehp_green_led_off ( struct slot * slot ) ;

void pciehp_green_led_blink ( struct slot * slot ) ;

int pciehp_power_on_slot ( struct slot * slot ) ;

int pciehp_power_off_slot ( struct slot * slot ) ;

int pciehp_get_max_link_speed ( struct slot * slot , enum pci_bus_speed * value ) ;

int pciehp_get_max_lnk_width ( struct slot * slot , enum pcie_link_width * value ) ;

int pciehp_get_cur_link_speed ( struct slot * slot , enum pci_bus_speed * value ) ;

int pciehp_get_cur_lnk_width ( struct slot * slot , enum pcie_link_width * value ) ;

int pcie_enable_notification ( struct controller * ctrl ) ;

int pcie_init_notification ( struct controller * ctrl ) ;

struct controller * pcie_init ( struct pcie_device * dev ) ;

void pciehp_release_ctrl ( struct controller * ctrl ) ;

struct dummy_slot { u32 number ; struct list_head list ; } ;

int pciehp_acpi_slot_detection_check ( struct pci_dev * dev ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pciehp_acpi_slot_detection_init ( void ) ;

int pcie_port_device_probe ( struct pci_dev * dev ) ;

int pcie_port_device_register ( struct pci_dev * dev ) ;

int pcie_port_device_suspend ( struct device * dev ) ;

int pcie_port_device_resume ( struct device * dev ) ;

void pcie_port_device_remove ( struct pci_dev * dev ) ;

int pcie_port_service_register ( struct pcie_port_service_driver * new ) ;

void pcie_port_service_unregister ( struct pcie_port_service_driver * drv ) ;

struct header_log_regs { unsigned int dw0 ; unsigned int dw1 ; unsigned int dw2 ; unsigned int dw3 ; } ;

struct aer_err_info { struct pci_dev * dev [ 5 ] ; int error_dev_num ; unsigned int id : 16 ; unsigned int severity : 2 ; unsigned int __pad1 : 5 ; unsigned int multi_error_valid : 1 ; unsigned int first_error : 5 ; unsigned int __pad2 : 2 ; unsigned int tlp_header_valid : 1 ; unsigned int status ; unsigned int mask ; struct header_log_regs tlp ; } ;

struct aer_err_source { unsigned int status ; unsigned int id ; } ;

struct aer_rpc { struct pcie_device * rpd ; struct work_struct dpc_handler ; struct aer_err_source e_sources [ 100 ] ; unsigned short prod_idx ; unsigned short cons_idx ; int isr ; spinlock_t e_lock ; struct mutex rpc_mutex ; wait_queue_head_t wait_release ; } ;

struct aer_broadcast_data { enum pci_channel_state state ; enum pci_ers_result result ; } ;

int pcie_port_bus_register ( void ) ;

void pcie_port_bus_unregister ( void ) ;

void aer_print_error ( struct pci_dev * dev , struct aer_err_info * info ) ;

void aer_print_port_info ( struct pci_dev * dev , struct aer_err_info * info ) ;

int pci_enable_pcie_error_reporting ( struct pci_dev * dev ) ;

int pci_disable_pcie_error_reporting ( struct pci_dev * dev ) ;

int pci_cleanup_aer_uncorrect_error_status ( struct pci_dev * dev ) ;

struct find_aer_service_data { struct pcie_port_service_driver * aer_driver ; int is_downstream ; } ;

void aer_enable_rootport ( struct aer_rpc * rpc ) ;

void aer_isr ( struct work_struct * work ) ;

void aer_delete_rootport ( struct aer_rpc * rpc ) ;

int aer_init ( struct pcie_device * dev ) ;

void pci_no_aer ( void ) ;

irqreturn_t aer_irq ( int irq , void * context ) ;

int aer_osc_setup ( struct pcie_device * pciedev ) ;

int pci_uevent ( struct device * dev , struct kobj_uevent_env * env ) ;

unsigned int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pci_do_scan_bus ( struct pci_bus * bus ) ;

int arch_msi_check_device ( struct pci_dev * dev , int nvec , int type ) ;

void arch_teardown_msi_irqs ( struct pci_dev * dev ) ;

void mask_msi_irq ( unsigned int irq ) ;

void unmask_msi_irq ( unsigned int irq ) ;

void read_msi_msg_desc ( struct irq_desc * desc , struct msi_msg * msg ) ;

void read_msi_msg ( unsigned int irq , struct msi_msg * msg ) ;

void write_msi_msg_desc ( struct irq_desc * desc , struct msi_msg * msg ) ;

void write_msi_msg ( unsigned int irq , struct msi_msg * msg ) ;

void pci_restore_msi_state ( struct pci_dev * dev ) ;

int pci_enable_msi_block ( struct pci_dev * dev , unsigned int nvec ) ;

void pci_msi_shutdown ( struct pci_dev * dev ) ;

void pci_disable_msi ( struct pci_dev * dev ) ;

int pci_msix_table_size ( struct pci_dev * dev ) ;

int pci_enable_msix ( struct pci_dev * dev , struct msix_entry * entries , int nvec ) ;

void pci_msix_shutdown ( struct pci_dev * dev ) ;

void pci_disable_msix ( struct pci_dev * dev ) ;

void msi_remove_pci_irq_vectors ( struct pci_dev * dev ) ;

void pci_no_msi ( void ) ;

int pci_msi_enabled ( void ) ;

void pci_msi_init_pci_dev ( struct pci_dev * dev ) ;

struct ht_irq_cfg { struct pci_dev * dev ; ht_irq_update_t * update ; unsigned pos ; unsigned idx ; struct ht_irq_msg msg ; } ;

void write_ht_irq_msg ( unsigned int irq , struct ht_irq_msg * msg ) ;

void fetch_ht_irq_msg ( unsigned int irq , struct ht_irq_msg * msg ) ;

void mask_ht_irq ( unsigned int irq ) ;

void unmask_ht_irq ( unsigned int irq ) ;

int __ht_create_irq ( struct pci_dev * dev , int idx , ht_irq_update_t * update ) ;

int ht_create_irq ( struct pci_dev * dev , int idx ) ;

void ht_destroy_irq ( unsigned int irq ) ;

int pci_iov_init ( struct pci_dev * dev ) ;

void pci_iov_release ( struct pci_dev * dev ) ;

int pci_iov_resource_bar ( struct pci_dev * dev , int resno , enum pci_bar_type * type ) ;

int pci_sriov_resource_alignment ( struct pci_dev * dev , int resno ) ;

void pci_restore_iov_state ( struct pci_dev * dev ) ;

int pci_iov_bus_range ( struct pci_bus * bus ) ;

int pci_enable_sriov ( struct pci_dev * dev , int nr_virtfn ) ;

void pci_disable_sriov ( struct pci_dev * dev ) ;

irqreturn_t pci_sriov_migration ( struct pci_dev * dev ) ;

int pci_enable_ats ( struct pci_dev * dev , int ps ) ;

void pci_disable_ats ( struct pci_dev * dev ) ;

int pci_ats_queue_depth ( struct pci_dev * dev ) ;

void pci_setup_cardbus ( struct pci_bus * bus ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) pci_bus_size_bridges ( struct pci_bus * bus ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) pci_bus_assign_resources ( const struct pci_bus * bus ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_assign_unassigned_resources ( void ) ;

struct guid_block { char guid [ 16 ] ; union { char object_id [ 2 ] ; struct { unsigned char notify_id ; unsigned char reserved ; } ; } ; u8 instance_count ; u8 flags ; } ;

struct wmi_block { struct list_head list ; struct guid_block gblock ; acpi_handle handle ; wmi_notify_handler handler ; void * handler_data ; } ;

acpi_status wmi_evaluate_method ( const char * guid_string , u8 instance , u32 method_id , const struct acpi_buffer * in , struct acpi_buffer * out ) ;

acpi_status wmi_query_block ( const char * guid_string , u8 instance , struct acpi_buffer * out ) ;

acpi_status wmi_set_block ( const char * guid_string , u8 instance , const struct acpi_buffer * in ) ;

acpi_status wmi_install_notify_handler ( const char * guid , wmi_notify_handler handler , void * data ) ;

acpi_status wmi_remove_notify_handler ( const char * guid ) ;

acpi_status wmi_get_event_data ( u32 event , struct acpi_buffer * out ) ;

bool wmi_has_guid ( const char * guid_string ) ;

struct pnp_port { resource_size_t min ; resource_size_t max ; resource_size_t align ; resource_size_t size ; unsigned char flags ; } ;

typedef struct { unsigned long bits [ ( ( ( 256 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } pnp_irq_mask_t ;

struct pnp_irq { pnp_irq_mask_t map ; unsigned char flags ; } ;

struct pnp_dma { unsigned char map ; unsigned char flags ; } ;

struct pnp_mem { resource_size_t min ; resource_size_t max ; resource_size_t align ; resource_size_t size ; unsigned char flags ; } ;

struct pnp_option { struct list_head list ; unsigned int flags ; unsigned long type ; union { struct pnp_port port ; struct pnp_irq irq ; struct pnp_dma dma ; struct pnp_mem mem ; } u ; } ;

struct pnp_resource { struct list_head list ; struct resource res ; } ;

void * pnp_alloc ( long size ) ;

int pnp_register_protocol ( struct pnp_protocol * protocol ) ;

void pnp_unregister_protocol ( struct pnp_protocol * protocol ) ;

void pnp_free_resource ( struct pnp_resource * pnp_res ) ;

void pnp_free_resources ( struct pnp_dev * dev ) ;

struct pnp_dev * pnp_alloc_dev ( struct pnp_protocol * protocol , int id , char * pnpid ) ;

int __pnp_add_device ( struct pnp_dev * dev ) ;

int pnp_add_device ( struct pnp_dev * dev ) ;

void __pnp_remove_device ( struct pnp_dev * dev ) ;

struct pnp_card * pnp_alloc_card ( struct pnp_protocol * protocol , int id , char * pnpid ) ;

int pnp_add_card ( struct pnp_card * card ) ;

void pnp_remove_card ( struct pnp_card * card ) ;

int pnp_add_card_device ( struct pnp_card * card , struct pnp_dev * dev ) ;

void pnp_remove_card_device ( struct pnp_dev * dev ) ;

struct pnp_dev * pnp_request_card_device ( struct pnp_card_link * clink , const char * id , struct pnp_dev * from ) ;

void pnp_release_card_device ( struct pnp_dev * dev ) ;

int pnp_register_card_driver ( struct pnp_card_driver * drv ) ;

void pnp_unregister_card_driver ( struct pnp_card_driver * drv ) ;

int compare_pnp_id ( struct pnp_id * pos , const char * id ) ;

int pnp_device_attach ( struct pnp_dev * pnp_dev ) ;

void pnp_device_detach ( struct pnp_dev * pnp_dev ) ;

int pnp_register_driver ( struct pnp_driver * drv ) ;

void pnp_unregister_driver ( struct pnp_driver * drv ) ;

struct pnp_id * pnp_add_id ( struct pnp_dev * dev , char * id ) ;

struct pnp_option * pnp_build_option ( struct pnp_dev * dev , unsigned long type , unsigned int option_flags ) ;

int pnp_register_irq_resource ( struct pnp_dev * dev , unsigned int option_flags , pnp_irq_mask_t * map , unsigned char flags ) ;

int pnp_register_dma_resource ( struct pnp_dev * dev , unsigned int option_flags , unsigned char map , unsigned char flags ) ;

int pnp_register_port_resource ( struct pnp_dev * dev , unsigned int option_flags , resource_size_t min , resource_size_t max , resource_size_t align , resource_size_t size , unsigned char flags ) ;

int pnp_register_mem_resource ( struct pnp_dev * dev , unsigned int option_flags , resource_size_t min , resource_size_t max , resource_size_t align , resource_size_t size , unsigned char flags ) ;

void pnp_free_options ( struct pnp_dev * dev ) ;

int pnp_check_port ( struct pnp_dev * dev , struct resource * res ) ;

int pnp_check_mem ( struct pnp_dev * dev , struct resource * res ) ;

int pnp_check_irq ( struct pnp_dev * dev , struct resource * res ) ;

int pnp_check_dma ( struct pnp_dev * dev , struct resource * res ) ;

unsigned long pnp_resource_type ( struct resource * res ) ;

struct resource * pnp_get_resource ( struct pnp_dev * dev , unsigned long type , unsigned int num ) ;

struct pnp_resource * pnp_add_irq_resource ( struct pnp_dev * dev , int irq , int flags ) ;

struct pnp_resource * pnp_add_dma_resource ( struct pnp_dev * dev , int dma , int flags ) ;

struct pnp_resource * pnp_add_io_resource ( struct pnp_dev * dev , resource_size_t start , resource_size_t end , int flags ) ;

struct pnp_resource * pnp_add_mem_resource ( struct pnp_dev * dev , resource_size_t start , resource_size_t end , int flags ) ;

int pnp_possible_config ( struct pnp_dev * dev , int type , resource_size_t start , resource_size_t size ) ;

int pnp_range_reserved ( resource_size_t start , resource_size_t end ) ;

void pnp_init_resources ( struct pnp_dev * dev ) ;

int pnp_auto_config_dev ( struct pnp_dev * dev ) ;

int pnp_start_dev ( struct pnp_dev * dev ) ;

int pnp_stop_dev ( struct pnp_dev * dev ) ;

int pnp_activate_dev ( struct pnp_dev * dev ) ;

int pnp_disable_dev ( struct pnp_dev * dev ) ;

int pnp_is_active ( struct pnp_dev * dev ) ;

void pnp_eisa_id_to_string ( u32 id , char * str ) ;

char * pnp_resource_type_name ( struct resource * res ) ;

void dbg_pnp_show_resources ( struct pnp_dev * dev , char * desc ) ;

char * pnp_option_priority_name ( struct pnp_option * option ) ;

void dbg_pnp_show_option ( struct pnp_dev * dev , struct pnp_option * option ) ;

struct pnp_info_buffer { char * buffer ; char * curr ; unsigned long size ; unsigned long len ; int stop ; int error ; } ;

typedef struct pnp_info_buffer pnp_info_buffer_t ;

void pnp_fixup_device ( struct pnp_dev * dev ) ;

int pnpacpi_parse_allocated_resource ( struct pnp_dev * dev ) ;

struct acpipnp_parse_option_s { struct pnp_dev * dev ; unsigned int option_flags ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pnpacpi_parse_resource_option_data ( struct pnp_dev * dev ) ;

int pnpacpi_build_resource_template ( struct pnp_dev * dev , struct acpi_buffer * buffer ) ;

int pnpacpi_encode_resources ( struct pnp_dev * dev , struct acpi_buffer * buffer ) ;

void power_supply_changed ( struct power_supply * psy ) ;

int power_supply_am_i_supplied ( struct power_supply * psy ) ;

int power_supply_is_system_supplied ( void ) ;

int power_supply_set_battery_charged ( struct power_supply * psy ) ;

struct power_supply * power_supply_get_by_name ( char * name ) ;

int power_supply_register ( struct device * parent , struct power_supply * psy ) ;

void power_supply_unregister ( struct power_supply * psy ) ;

int power_supply_create_attrs ( struct power_supply * psy ) ;

void power_supply_remove_attrs ( struct power_supply * psy ) ;

int power_supply_uevent ( struct device * dev , struct kobj_uevent_env * env ) ;

void power_supply_update_leds ( struct power_supply * psy ) ;

int power_supply_create_triggers ( struct power_supply * psy ) ;

void power_supply_remove_triggers ( struct power_supply * psy ) ;

struct regulator_dev ;

struct regulator_init_data ;
enum regulator_status { REGULATOR_STATUS_OFF , REGULATOR_STATUS_ON , REGULATOR_STATUS_ERROR , REGULATOR_STATUS_FAST , REGULATOR_STATUS_NORMAL , REGULATOR_STATUS_IDLE , REGULATOR_STATUS_STANDBY , } ;

struct regulator_ops { int ( * list_voltage ) ( struct regulator_dev * , unsigned selector ) ; int ( * set_voltage ) ( struct regulator_dev * , int min_uV , int max_uV ) ; int ( * get_voltage ) ( struct regulator_dev * ) ; int ( * set_current_limit ) ( struct regulator_dev * , int min_uA , int max_uA ) ; int ( * get_current_limit ) ( struct regulator_dev * ) ; int ( * enable ) ( struct regulator_dev * ) ; int ( * disable ) ( struct regulator_dev * ) ; int ( * is_enabled ) ( struct regulator_dev * ) ; int ( * set_mode ) ( struct regulator_dev * , unsigned int mode ) ; unsigned int ( * get_mode ) ( struct regulator_dev * ) ; int ( * get_status ) ( struct regulator_dev * ) ; unsigned int ( * get_optimum_mode ) ( struct regulator_dev * , int input_uV , int output_uV , int load_uA ) ; int ( * set_suspend_voltage ) ( struct regulator_dev * , int uV ) ; int ( * set_suspend_enable ) ( struct regulator_dev * ) ; int ( * set_suspend_disable ) ( struct regulator_dev * ) ; int ( * set_suspend_mode ) ( struct regulator_dev * , unsigned int mode ) ; } ;

enum regulator_type { REGULATOR_VOLTAGE , REGULATOR_CURRENT , } ;

struct regulator_desc { const char * name ; int id ; unsigned n_voltages ; struct regulator_ops * ops ; int irq ; enum regulator_type type ; struct module * owner ; } ;

struct regulator_dev { struct regulator_desc * desc ; int use_count ; int open_count ; int exclusive ; struct list_head list ; struct list_head slist ; struct list_head consumer_list ; struct list_head supply_list ; struct blocking_notifier_head notifier ; struct mutex mutex ; struct module * owner ; struct device dev ; struct regulation_constraints * constraints ; struct regulator_dev * supply ; void * reg_data ; } ;
struct regulator_map { struct list_head list ; const char * dev_name ; const char * supply ; struct regulator_dev * regulator ; } ;

struct regulator { struct device * dev ; struct list_head list ; int uA_load ; int min_uV ; int max_uV ; char * supply_name ; struct device_attribute dev_attr ; struct regulator_dev * rdev ; } ;
struct regulator * regulator_get ( struct device * dev , const char * id ) ;

struct regulator * regulator_get_exclusive ( struct device * dev , const char * id ) ;

void regulator_put ( struct regulator * regulator ) ;

int regulator_enable ( struct regulator * regulator ) ;

int regulator_disable ( struct regulator * regulator ) ;

int regulator_force_disable ( struct regulator * regulator ) ;

int regulator_is_enabled ( struct regulator * regulator ) ;

int regulator_count_voltages ( struct regulator * regulator ) ;

int regulator_list_voltage ( struct regulator * regulator , unsigned selector ) ;

int regulator_is_supported_voltage ( struct regulator * regulator , int min_uV , int max_uV ) ;

int regulator_set_voltage ( struct regulator * regulator , int min_uV , int max_uV ) ;

int regulator_get_voltage ( struct regulator * regulator ) ;

int regulator_set_current_limit ( struct regulator * regulator , int min_uA , int max_uA ) ;

int regulator_get_current_limit ( struct regulator * regulator ) ;

int regulator_set_mode ( struct regulator * regulator , unsigned int mode ) ;

unsigned int regulator_get_mode ( struct regulator * regulator ) ;

int regulator_set_optimum_mode ( struct regulator * regulator , int uA_load ) ;

int regulator_register_notifier ( struct regulator * regulator , struct notifier_block * nb ) ;

int regulator_unregister_notifier ( struct regulator * regulator , struct notifier_block * nb ) ;

int regulator_bulk_get ( struct device * dev , int num_consumers , struct regulator_bulk_data * consumers ) ;

int regulator_bulk_enable ( int num_consumers , struct regulator_bulk_data * consumers ) ;

int regulator_bulk_disable ( int num_consumers , struct regulator_bulk_data * consumers ) ;

void regulator_bulk_free ( int num_consumers , struct regulator_bulk_data * consumers ) ;

int regulator_notifier_call_chain ( struct regulator_dev * rdev , unsigned long event , void * data ) ;

int regulator_mode_to_status ( unsigned int mode ) ;

struct regulator_dev * regulator_register ( struct regulator_desc * regulator_desc , struct device * dev , struct regulator_init_data * init_data , void * driver_data ) ;

void regulator_unregister ( struct regulator_dev * rdev ) ;

int regulator_suspend_prepare ( suspend_state_t state ) ;

void regulator_has_full_constraints ( void ) ;

void * rdev_get_drvdata ( struct regulator_dev * rdev ) ;

void * regulator_get_drvdata ( struct regulator * regulator ) ;

void regulator_set_drvdata ( struct regulator * regulator , void * data ) ;

int rdev_get_id ( struct regulator_dev * rdev ) ;

struct device * rdev_get_dev ( struct regulator_dev * rdev ) ;

void * regulator_get_init_drvdata ( struct regulator_init_data * reg_init_data ) ;

struct twlreg_info { u8 base ; u8 id ; u8 table_len ; const u16 * table ; u16 min_mV ; struct regulator_desc desc ; } ;

int rtc_month_days ( unsigned int month , unsigned int year ) ;

int rtc_year_days ( unsigned int day , unsigned int month , unsigned int year ) ;

void rtc_time_to_tm ( unsigned long time , struct rtc_time * tm ) ;

int rtc_valid_tm ( struct rtc_time * tm ) ;

int rtc_tm_to_time ( struct rtc_time * tm , unsigned long * time ) ;

struct rtc_device * rtc_device_register ( const char * name , struct device * dev , const struct rtc_class_ops * ops , struct module * owner ) ;

void rtc_device_unregister ( struct rtc_device * rtc ) ;

int rtc_read_time ( struct rtc_device * rtc , struct rtc_time * tm ) ;

int rtc_set_time ( struct rtc_device * rtc , struct rtc_time * tm ) ;

int rtc_set_mmss ( struct rtc_device * rtc , unsigned long secs ) ;

int rtc_read_alarm ( struct rtc_device * rtc , struct rtc_wkalrm * alarm ) ;

int rtc_set_alarm ( struct rtc_device * rtc , struct rtc_wkalrm * alarm ) ;

int rtc_alarm_irq_enable ( struct rtc_device * rtc , unsigned int enabled ) ;

int rtc_update_irq_enable ( struct rtc_device * rtc , unsigned int enabled ) ;

void rtc_update_irq ( struct rtc_device * rtc , unsigned long num , unsigned long events ) ;

struct rtc_device * rtc_class_open ( char * name ) ;

void rtc_class_close ( struct rtc_device * rtc ) ;

int rtc_irq_register ( struct rtc_device * rtc , struct rtc_task * task ) ;

void rtc_irq_unregister ( struct rtc_device * rtc , struct rtc_task * task ) ;

int rtc_irq_set_state ( struct rtc_device * rtc , struct rtc_task * task , int enabled ) ;

int rtc_irq_set_freq ( struct rtc_device * rtc , struct rtc_task * task , int freq ) ;

int rtc_dev_update_irq_enable_emul ( struct rtc_device * rtc , unsigned int enabled ) ;

void rtc_dev_prepare ( struct rtc_device * rtc ) ;

void rtc_dev_add_device ( struct rtc_device * rtc ) ;

void rtc_dev_del_device ( struct rtc_device * rtc ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rtc_dev_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __used__ ) ) __attribute__ ( ( __cold__ ) ) rtc_dev_exit ( void ) ;

void rtc_proc_add_device ( struct rtc_device * rtc ) ;

void rtc_proc_del_device ( struct rtc_device * rtc ) ;

void rtc_sysfs_add_device ( struct rtc_device * rtc ) ;

void rtc_sysfs_del_device ( struct rtc_device * rtc ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rtc_sysfs_init ( struct class * rtc_class ) ;

struct cmos_rtc { struct rtc_device * rtc ; struct device * dev ; int irq ; struct resource * iomem ; void ( * wake_on ) ( struct device * ) ; void ( * wake_off ) ( struct device * ) ; u8 enabled_wake ; u8 suspend_ctrl ; u8 day_alrm ; u8 mon_alrm ; u8 century ; } ;

struct scsi_host_template ;
struct scsi_nl_hdr ;

enum { SCSI_DEVINFO_GLOBAL = 0 , SCSI_DEVINFO_SPI , } ;
const char * scsi_device_type ( unsigned type ) ;

struct scsi_host_cmd_pool { struct kmem_cache * cmd_slab ; struct kmem_cache * sense_slab ; unsigned int users ; char * cmd_name ; char * sense_name ; unsigned int slab_flags ; gfp_t gfp_mask ; } ;
struct scsi_cmnd * __scsi_get_command ( struct Scsi_Host * shost , gfp_t gfp_mask ) ;

struct scsi_cmnd * scsi_get_command ( struct scsi_device * dev , gfp_t gfp_mask ) ;

void __scsi_put_command ( struct Scsi_Host * shost , struct scsi_cmnd * cmd , struct device * dev ) ;

void scsi_put_command ( struct scsi_cmnd * cmd ) ;

struct scsi_cmnd * scsi_allocate_command ( gfp_t gfp_mask ) ;

void scsi_free_command ( gfp_t gfp_mask , struct scsi_cmnd * cmd ) ;

int scsi_setup_command_freelist ( struct Scsi_Host * shost ) ;

void scsi_destroy_command_freelist ( struct Scsi_Host * shost ) ;

void scsi_log_send ( struct scsi_cmnd * cmd ) ;

void scsi_log_completion ( struct scsi_cmnd * cmd , int disposition ) ;

int scsi_dispatch_cmd ( struct scsi_cmnd * cmd ) ;

void scsi_finish_command ( struct scsi_cmnd * cmd ) ;

void scsi_adjust_queue_depth ( struct scsi_device * sdev , int tagged , int tags ) ;

int scsi_track_queue_full ( struct scsi_device * sdev , int depth ) ;

unsigned char * scsi_get_vpd_page ( struct scsi_device * sdev , u8 page ) ;

int scsi_device_get ( struct scsi_device * sdev ) ;

void scsi_device_put ( struct scsi_device * sdev ) ;

struct scsi_device * __scsi_iterate_devices ( struct Scsi_Host * shost , struct scsi_device * prev ) ;

void starget_for_each_device ( struct scsi_target * starget , void * data , void ( * fn ) ( struct scsi_device * , void * ) ) ;

void __starget_for_each_device ( struct scsi_target * starget , void * data , void ( * fn ) ( struct scsi_device * , void * ) ) ;

struct scsi_device * __scsi_device_lookup_by_target ( struct scsi_target * starget , uint lun ) ;

struct scsi_device * scsi_device_lookup_by_target ( struct scsi_target * starget , uint lun ) ;

struct scsi_device * __scsi_device_lookup ( struct Scsi_Host * shost , uint channel , uint id , uint lun ) ;

struct scsi_device * scsi_device_lookup ( struct Scsi_Host * shost , uint channel , uint id , uint lun ) ;

int scsi_host_set_state ( struct Scsi_Host * shost , enum scsi_host_state state ) ;

void scsi_remove_host ( struct Scsi_Host * shost ) ;

int scsi_add_host_with_dma ( struct Scsi_Host * shost , struct device * dev , struct device * dma_dev ) ;

struct Scsi_Host * scsi_host_alloc ( struct scsi_host_template * sht , int privsize ) ;

struct Scsi_Host * scsi_register ( struct scsi_host_template * sht , int privsize ) ;

void scsi_unregister ( struct Scsi_Host * shost ) ;

struct Scsi_Host * scsi_host_lookup ( unsigned short hostnum ) ;

struct Scsi_Host * scsi_host_get ( struct Scsi_Host * shost ) ;

void scsi_host_put ( struct Scsi_Host * shost ) ;

int scsi_init_hosts ( void ) ;

void scsi_exit_hosts ( void ) ;

int scsi_is_host_device ( const struct device * dev ) ;

int scsi_queue_work ( struct Scsi_Host * shost , struct work_struct * work ) ;

void scsi_flush_work ( struct Scsi_Host * shost ) ;

int scsi_set_medium_removal ( struct scsi_device * sdev , char state ) ;

int scsi_ioctl ( struct scsi_device * sdev , int cmd , void * arg ) ;

int scsi_nonblockable_ioctl ( struct scsi_device * sdev , int cmd , void * arg , int ndelay ) ;

struct value_name_pair { int value ; const char * name ; } ;

void __scsi_print_command ( unsigned char * cdb ) ;

void scsi_print_command ( struct scsi_cmnd * cmd ) ;

void scsi_print_status ( unsigned char scsi_status ) ;

struct error_info { unsigned short code12 ; const char * text ; } ;

struct error_info2 { unsigned char code1 , code2_min , code2_max ; const char * fmt ; } ;

const char * scsi_sense_key_string ( unsigned char key ) ;

const char * scsi_extd_sense_format ( unsigned char asc , unsigned char ascq ) ;

void scsi_show_extd_sense ( unsigned char asc , unsigned char ascq ) ;

void scsi_show_sense_hdr ( struct scsi_sense_hdr * sshdr ) ;

void scsi_print_sense_hdr ( const char * name , struct scsi_sense_hdr * sshdr ) ;

void scsi_cmd_print_sense_hdr ( struct scsi_cmnd * scmd , const char * desc , struct scsi_sense_hdr * sshdr ) ;

void __scsi_print_sense ( const char * name , const unsigned char * sense_buffer , int sense_len ) ;

void scsi_print_sense ( char * name , struct scsi_cmnd * cmd ) ;

void scsi_show_result ( int result ) ;

void scsi_print_result ( struct scsi_cmnd * cmd ) ;

unsigned char * scsi_bios_ptable ( struct block_device * dev ) ;

int scsicam_bios_param ( struct block_device * bdev , sector_t capacity , int * ip ) ;

int scsi_partsize ( unsigned char * buf , unsigned long capacity , unsigned int * cyls , unsigned int * hds , unsigned int * secs ) ;

void scsi_eh_wakeup ( struct Scsi_Host * shost ) ;

void scsi_schedule_eh ( struct Scsi_Host * shost ) ;

int scsi_eh_scmd_add ( struct scsi_cmnd * scmd , int eh_flag ) ;

enum blk_eh_timer_return scsi_times_out ( struct request * req ) ;

int scsi_block_when_processing_errors ( struct scsi_device * sdev ) ;

void scsi_eh_prep_cmnd ( struct scsi_cmnd * scmd , struct scsi_eh_save * ses , unsigned char * cmnd , int cmnd_size , unsigned sense_bytes ) ;

void scsi_eh_restore_cmnd ( struct scsi_cmnd * scmd , struct scsi_eh_save * ses ) ;

void scsi_eh_finish_cmd ( struct scsi_cmnd * scmd , struct list_head * done_q ) ;

int scsi_eh_get_sense ( struct list_head * work_q , struct list_head * done_q ) ;

int scsi_noretry_cmd ( struct scsi_cmnd * scmd ) ;

int scsi_decide_disposition ( struct scsi_cmnd * scmd ) ;

void scsi_eh_ready_devs ( struct Scsi_Host * shost , struct list_head * work_q , struct list_head * done_q ) ;

void scsi_eh_flush_done_q ( struct list_head * done_q ) ;

int scsi_error_handler ( void * data ) ;

void scsi_report_bus_reset ( struct Scsi_Host * shost , int channel ) ;

void scsi_report_device_reset ( struct Scsi_Host * shost , int channel , int target ) ;

int scsi_reset_provider ( struct scsi_device * dev , int flag ) ;

int scsi_normalize_sense ( const u8 * sense_buffer , int sb_len , struct scsi_sense_hdr * sshdr ) ;

int scsi_command_normalize_sense ( struct scsi_cmnd * cmd , struct scsi_sense_hdr * sshdr ) ;

const u8 * scsi_sense_desc_find ( const u8 * sense_buffer , int sb_len , int desc_type ) ;

int scsi_get_sense_info_fld ( const u8 * sense_buffer , int sb_len , u64 * info_out ) ;

void scsi_build_sense_buffer ( int desc , u8 * buf , u8 key , u8 asc , u8 ascq ) ;

struct scsi_host_sg_pool { size_t size ; char * name ; struct kmem_cache * slab ; mempool_t * pool ; } ;

int scsi_queue_insert ( struct scsi_cmnd * cmd , int reason ) ;

int scsi_execute ( struct scsi_device * sdev , const unsigned char * cmd , int data_direction , void * buffer , unsigned bufflen , unsigned char * sense , int timeout , int retries , int flags , int * resid ) ;

int scsi_execute_req ( struct scsi_device * sdev , const unsigned char * cmd , int data_direction , void * buffer , unsigned bufflen , struct scsi_sense_hdr * sshdr , int timeout , int retries , int * resid ) ;

void scsi_device_unbusy ( struct scsi_device * sdev ) ;

void scsi_next_command ( struct scsi_cmnd * cmd ) ;

void scsi_run_host_queues ( struct Scsi_Host * shost ) ;

void scsi_release_buffers ( struct scsi_cmnd * cmd ) ;

void scsi_io_completion ( struct scsi_cmnd * cmd , unsigned int good_bytes ) ;

int scsi_init_io ( struct scsi_cmnd * cmd , gfp_t gfp_mask ) ;

int scsi_setup_blk_pc_cmnd ( struct scsi_device * sdev , struct request * req ) ;

int scsi_setup_fs_cmnd ( struct scsi_device * sdev , struct request * req ) ;

int scsi_prep_state_check ( struct scsi_device * sdev , struct request * req ) ;

int scsi_prep_return ( struct request_queue * q , struct request * req , int ret ) ;

int scsi_prep_fn ( struct request_queue * q , struct request * req ) ;

u64 scsi_calculate_bounce_limit ( struct Scsi_Host * shost ) ;

struct request_queue * __scsi_alloc_queue ( struct Scsi_Host * shost , request_fn_proc * request_fn ) ;

struct request_queue * scsi_alloc_queue ( struct scsi_device * sdev ) ;

void scsi_free_queue ( struct request_queue * q ) ;

void scsi_block_requests ( struct Scsi_Host * shost ) ;

void scsi_unblock_requests ( struct Scsi_Host * shost ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) scsi_init_queue ( void ) ;

void scsi_exit_queue ( void ) ;

int scsi_mode_select ( struct scsi_device * sdev , int pf , int sp , int modepage , unsigned char * buffer , int len , int timeout , int retries , struct scsi_mode_data * data , struct scsi_sense_hdr * sshdr ) ;

int scsi_mode_sense ( struct scsi_device * sdev , int dbd , int modepage , unsigned char * buffer , int len , int timeout , int retries , struct scsi_mode_data * data , struct scsi_sense_hdr * sshdr ) ;

int scsi_test_unit_ready ( struct scsi_device * sdev , int timeout , int retries , struct scsi_sense_hdr * sshdr_external ) ;

int scsi_device_set_state ( struct scsi_device * sdev , enum scsi_device_state state ) ;

void scsi_evt_thread ( struct work_struct * work ) ;

void sdev_evt_send ( struct scsi_device * sdev , struct scsi_event * evt ) ;

struct scsi_event * sdev_evt_alloc ( enum scsi_device_event evt_type , gfp_t gfpflags ) ;

void sdev_evt_send_simple ( struct scsi_device * sdev , enum scsi_device_event evt_type , gfp_t gfpflags ) ;

int scsi_device_quiesce ( struct scsi_device * sdev ) ;

void scsi_device_resume ( struct scsi_device * sdev ) ;

void scsi_target_quiesce ( struct scsi_target * starget ) ;

void scsi_target_resume ( struct scsi_target * starget ) ;

int scsi_internal_device_block ( struct scsi_device * sdev ) ;

int scsi_internal_device_unblock ( struct scsi_device * sdev ) ;

void scsi_target_block ( struct device * dev ) ;

void scsi_target_unblock ( struct device * dev ) ;

void * scsi_kmap_atomic_sg ( struct scatterlist * sgl , int sg_count , size_t * offset , size_t * len ) ;

void scsi_kunmap_atomic_sg ( void * virt ) ;

int scsi_dma_map ( struct scsi_cmnd * cmd ) ;

void scsi_dma_unmap ( struct scsi_cmnd * cmd ) ;

struct async_scan_data { struct list_head list ; struct Scsi_Host * shost ; struct completion prev_finished ; } ;

int scsi_complete_async_scans ( void ) ;

int scsi_is_target_device ( const struct device * dev ) ;

void scsi_target_reap ( struct scsi_target * starget ) ;

int scsilun_to_int ( struct scsi_lun * scsilun ) ;

void int_to_scsilun ( unsigned int lun , struct scsi_lun * scsilun ) ;

struct scsi_device * __scsi_add_device ( struct Scsi_Host * shost , uint channel , uint id , uint lun , void * hostdata ) ;

int scsi_add_device ( struct Scsi_Host * host , uint channel , uint target , uint lun ) ;

void scsi_rescan_device ( struct device * dev ) ;

void scsi_scan_target ( struct device * parent , unsigned int channel , unsigned int id , unsigned int lun , int rescan ) ;

int scsi_scan_host_selected ( struct Scsi_Host * shost , unsigned int channel , unsigned int id , unsigned int lun , int rescan ) ;

void scsi_scan_host ( struct Scsi_Host * shost ) ;

void scsi_forget_host ( struct Scsi_Host * shost ) ;

struct scsi_device * scsi_get_host_dev ( struct Scsi_Host * shost ) ;

void scsi_free_host_dev ( struct scsi_device * sdev ) ;

const char * scsi_device_state_name ( enum scsi_device_state state ) ;

const char * scsi_host_state_name ( enum scsi_host_state state ) ;

int scsi_sysfs_register ( void ) ;

void scsi_sysfs_unregister ( void ) ;

int scsi_sysfs_add_sdev ( struct scsi_device * sdev ) ;

void __scsi_remove_device ( struct scsi_device * sdev ) ;

void scsi_remove_device ( struct scsi_device * sdev ) ;

void scsi_remove_target ( struct device * dev ) ;

int scsi_register_driver ( struct device_driver * drv ) ;

int scsi_register_interface ( struct class_interface * intf ) ;

int scsi_sysfs_add_host ( struct Scsi_Host * shost ) ;

void scsi_sysfs_device_initialize ( struct scsi_device * sdev ) ;

int scsi_is_sdev_device ( const struct device * dev ) ;

struct scsi_dev_info_list { struct list_head dev_info_list ; char vendor [ 8 ] ; char model [ 16 ] ; unsigned flags ; unsigned compatible ; } ;

struct scsi_dev_info_list_table { struct list_head node ; struct list_head scsi_dev_info_list ; const char * name ; int key ; } ;

int scsi_dev_info_list_add_keyed ( int compatible , char * vendor , char * model , char * strflags , int flags , int key ) ;

int scsi_get_device_flags ( struct scsi_device * sdev , const unsigned char * vendor , const unsigned char * model ) ;

int scsi_get_device_flags_keyed ( struct scsi_device * sdev , const unsigned char * vendor , const unsigned char * model , int key ) ;

struct double_list { struct list_head * top ; struct list_head * bottom ; } ;

void scsi_exit_devinfo ( void ) ;

int scsi_dev_info_add_list ( int key , const char * name ) ;

int scsi_dev_info_remove_list ( int key ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) scsi_init_devinfo ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) scsi_init_sysctl ( void ) ;

void scsi_exit_sysctl ( void ) ;

void scsi_proc_hostdir_add ( struct scsi_host_template * sht ) ;

void scsi_proc_hostdir_rm ( struct scsi_host_template * sht ) ;

void scsi_proc_host_add ( struct Scsi_Host * shost ) ;

void scsi_proc_host_rm ( struct Scsi_Host * shost ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) scsi_init_procfs ( void ) ;

void scsi_exit_procfs ( void ) ;

enum string_size_units { STRING_UNITS_10 , STRING_UNITS_2 , } ;

enum { SD_EXT_CDB_SIZE = 32 , SD_MEMPOOL_SIZE = 2 , } ;
struct scsi_disk { struct scsi_driver * driver ; struct scsi_device * device ; struct device dev ; struct gendisk * disk ; unsigned int openers ; sector_t capacity ; u32 index ; unsigned short hw_sector_size ; u8 media_present ; u8 write_prot ; u8 protection_type ; unsigned previous_state : 1 ; unsigned ATO : 1 ; unsigned WCE : 1 ; unsigned RCD : 1 ; unsigned DPOFUA : 1 ; unsigned first_scan : 1 ; } ;

enum sd_dif_target_protection_types { SD_DIF_TYPE0_PROTECTION = 0x0 , SD_DIF_TYPE1_PROTECTION = 0x1 , SD_DIF_TYPE2_PROTECTION = 0x2 , SD_DIF_TYPE3_PROTECTION = 0x3 , } ;

struct sd_dif_tuple { __be16 guard_tag ; __be16 app_tag ; __be32 ref_tag ; } ;

void sd_read_protection_type ( struct scsi_disk * sdkp , unsigned char * buffer ) ;

void sd_read_app_tag_own ( struct scsi_disk * sdkp , unsigned char * buffer ) ;

typedef __u16 ( csum_fn ) ( void * , unsigned int ) ;

void sd_dif_config_host ( struct scsi_disk * sdkp ) ;

int sd_dif_prepare ( struct request * rq , sector_t hw_sector , unsigned int sector_sz ) ;

void sd_dif_complete ( struct scsi_cmnd * scmd , unsigned int good_bytes ) ;


typedef struct scsi_cd { struct scsi_driver * driver ; unsigned capacity ; struct scsi_device * device ; unsigned int vendor ; unsigned long ms_offset ; unsigned use : 1 ; unsigned xa_flag : 1 ; unsigned readcd_known : 1 ; unsigned readcd_cdda : 1 ; unsigned previous_state : 1 ; struct cdrom_device_info cdi ; struct kref kref ; struct gendisk * disk ; } Scsi_CD ;

int sr_test_unit_ready ( struct scsi_device * sdev , struct scsi_sense_hdr * sshdr ) ;

int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) ;

int sr_tray_move ( struct cdrom_device_info * cdi , int pos ) ;

int sr_lock_door ( struct cdrom_device_info * cdi , int lock ) ;

int sr_drive_status ( struct cdrom_device_info * cdi , int slot ) ;

int sr_disk_status ( struct cdrom_device_info * cdi ) ;

int sr_get_last_session ( struct cdrom_device_info * cdi , struct cdrom_multisession * ms_info ) ;

int sr_get_mcn ( struct cdrom_device_info * cdi , struct cdrom_mcn * mcn ) ;

int sr_reset ( struct cdrom_device_info * cdi ) ;

int sr_select_speed ( struct cdrom_device_info * cdi , int speed ) ;

int sr_audio_ioctl ( struct cdrom_device_info * cdi , unsigned int cmd , void * arg ) ;

int sr_is_xa ( Scsi_CD * cd ) ;

void sr_vendor_init ( Scsi_CD * cd ) ;

int sr_set_blocklength ( Scsi_CD * cd , int blocklength ) ;

int sr_cd_check ( struct cdrom_device_info * cdi ) ;

struct spi_transport_attrs { int period ; int min_period ; int offset ; int max_offset ; unsigned int width : 1 ; unsigned int max_width : 1 ; unsigned int iu : 1 ; unsigned int max_iu : 1 ; unsigned int dt : 1 ; unsigned int qas : 1 ; unsigned int max_qas : 1 ; unsigned int wr_flow : 1 ; unsigned int rd_strm : 1 ; unsigned int rti : 1 ; unsigned int pcomp_en : 1 ; unsigned int hold_mcs : 1 ; unsigned int initial_dv : 1 ; unsigned long flags ; unsigned int support_sync : 1 ; unsigned int support_wide : 1 ; unsigned int support_dt : 1 ; unsigned int support_dt_only ; unsigned int support_ius ; unsigned int support_qas ; unsigned int dv_pending : 1 ; unsigned int dv_in_progress : 1 ; struct mutex dv_mutex ; } ;

enum spi_signal_type { SPI_SIGNAL_UNKNOWN = 1 , SPI_SIGNAL_SE , SPI_SIGNAL_LVD , SPI_SIGNAL_HVD , } ;

struct spi_host_attrs { enum spi_signal_type signalling ; } ;

struct spi_function_template { void ( * get_period ) ( struct scsi_target * ) ; void ( * set_period ) ( struct scsi_target * , int ) ; void ( * get_offset ) ( struct scsi_target * ) ; void ( * set_offset ) ( struct scsi_target * , int ) ; void ( * get_width ) ( struct scsi_target * ) ; void ( * set_width ) ( struct scsi_target * , int ) ; void ( * get_iu ) ( struct scsi_target * ) ; void ( * set_iu ) ( struct scsi_target * , int ) ; void ( * get_dt ) ( struct scsi_target * ) ; void ( * set_dt ) ( struct scsi_target * , int ) ; void ( * get_qas ) ( struct scsi_target * ) ; void ( * set_qas ) ( struct scsi_target * , int ) ; void ( * get_wr_flow ) ( struct scsi_target * ) ; void ( * set_wr_flow ) ( struct scsi_target * , int ) ; void ( * get_rd_strm ) ( struct scsi_target * ) ; void ( * set_rd_strm ) ( struct scsi_target * , int ) ; void ( * get_rti ) ( struct scsi_target * ) ; void ( * set_rti ) ( struct scsi_target * , int ) ; void ( * get_pcomp_en ) ( struct scsi_target * ) ; void ( * set_pcomp_en ) ( struct scsi_target * , int ) ; void ( * get_hold_mcs ) ( struct scsi_target * ) ; void ( * set_hold_mcs ) ( struct scsi_target * , int ) ; void ( * get_signalling ) ( struct Scsi_Host * ) ; void ( * set_signalling ) ( struct Scsi_Host * , enum spi_signal_type ) ; int ( * deny_binding ) ( struct scsi_target * ) ; unsigned long show_period : 1 ; unsigned long show_offset : 1 ; unsigned long show_width : 1 ; unsigned long show_iu : 1 ; unsigned long show_dt : 1 ; unsigned long show_qas : 1 ; unsigned long show_wr_flow : 1 ; unsigned long show_rd_strm : 1 ; unsigned long show_rti : 1 ; unsigned long show_pcomp_en : 1 ; unsigned long show_hold_mcs : 1 ; } ;

enum { SPI_BLIST_NOIUS = 0x1 , } ;
struct spi_internal { struct scsi_transport_template t ; struct spi_function_template * f ; } ;

enum spi_compare_returns { SPI_COMPARE_SUCCESS , SPI_COMPARE_FAILURE , SPI_COMPARE_SKIP_TEST , } ;

void spi_dv_device ( struct scsi_device * sdev ) ;

struct work_queue_wrapper { struct work_struct work ; struct scsi_device * sdev ; } ;

void spi_schedule_dv_device ( struct scsi_device * sdev ) ;

void spi_display_xfer_agreement ( struct scsi_target * starget ) ;

int spi_populate_width_msg ( unsigned char * msg , int width ) ;

int spi_populate_sync_msg ( unsigned char * msg , int period , int offset ) ;

int spi_populate_ppr_msg ( unsigned char * msg , int period , int offset , int width , int options ) ;

int spi_print_msg ( const unsigned char * msg ) ;

struct scsi_transport_template * spi_attach_transport ( struct spi_function_template * ft ) ;

void spi_release_transport ( struct scsi_transport_template * t ) ;

struct scsi_dh_devinfo_list { struct list_head node ; char vendor [ 9 ] ; char model [ 17 ] ; struct scsi_device_handler * handler ; } ;

int scsi_register_device_handler ( struct scsi_device_handler * scsi_dh ) ;

int scsi_unregister_device_handler ( struct scsi_device_handler * scsi_dh ) ;

int scsi_dh_activate ( struct request_queue * q ) ;

int scsi_dh_set_params ( struct request_queue * q , const char * params ) ;

int scsi_dh_handler_exist ( const char * name ) ;

int scsi_dh_attach ( struct request_queue * q , const char * name ) ;

void scsi_dh_detach ( struct request_queue * q ) ;

struct sym_driver_setup { u_short max_tag ; u_char burst_order ; u_char scsi_led ; u_char scsi_diff ; u_char irq_mode ; u_char scsi_bus_check ; u_char host_id ; u_char verbose ; u_char settle_delay ; u_char use_nvram ; u_long excludes [ 8 ] ; } ;

struct sym_chip { u_short device_id ; u_short revision_id ; char * name ; u_char burst_max ; u_char offset_max ; u_char nr_divisor ; u_char lp_probe_bit ; u_int features ; } ;

struct sym_reg { u8 nc_scntl0 ; u8 nc_scntl1 ; u8 nc_scntl2 ; u8 nc_scntl3 ; u8 nc_scid ; u8 nc_sxfer ; u8 nc_sdid ; u8 nc_gpreg ; u8 nc_sfbr ; u8 nc_socl ; u8 nc_ssid ; u8 nc_sbcl ; u8 nc_dstat ; u8 nc_sstat0 ; u8 nc_sstat1 ; u8 nc_sstat2 ; u8 nc_dsa ; u8 nc_dsa1 ; u8 nc_dsa2 ; u8 nc_dsa3 ; u8 nc_istat ; u8 nc_istat1 ; u8 nc_mbox0 ; u8 nc_mbox1 ; u8 nc_ctest0 ; u8 nc_ctest1 ; u8 nc_ctest2 ; u8 nc_ctest3 ; u32 nc_temp ; u8 nc_dfifo ; u8 nc_ctest4 ; u8 nc_ctest5 ; u8 nc_ctest6 ; u32 nc_dbc ; u32 nc_dnad ; u32 nc_dsp ; u32 nc_dsps ; u8 nc_scratcha ; u8 nc_scratcha1 ; u8 nc_scratcha2 ; u8 nc_scratcha3 ; u8 nc_dmode ; u8 nc_dien ; u8 nc_sbr ; u8 nc_dcntl ; u32 nc_adder ; u16 nc_sien ; u16 nc_sist ; u8 nc_slpar ; u8 nc_swide ; u8 nc_macntl ; u8 nc_gpcntl ; u8 nc_stime0 ; u8 nc_stime1 ; u16 nc_respid ; u8 nc_stest0 ; u8 nc_stest1 ; u8 nc_stest2 ; u8 nc_stest3 ; u16 nc_sidl ; u8 nc_stest4 ; u8 nc_53_ ; u16 nc_sodl ; u8 nc_ccntl0 ; u8 nc_ccntl1 ; u16 nc_sbdl ; u16 nc_5a_ ; u8 nc_scr0 ; u8 nc_scr1 ; u8 nc_scr2 ; u8 nc_scr3 ; u8 nc_scrx [ 64 ] ; u32 nc_mmrs ; u32 nc_mmws ; u32 nc_sfs ; u32 nc_drs ; u32 nc_sbms ; u32 nc_dbms ; u32 nc_dnad64 ; u16 nc_scntl4 ; u8 nc_aipcntl0 ; u8 nc_aipcntl1 ; u32 nc_pmjad1 ; u32 nc_pmjad2 ; u8 nc_rbc ; u8 nc_rbc1 ; u8 nc_rbc2 ; u8 nc_rbc3 ; u8 nc_ua ; u8 nc_ua1 ; u8 nc_ua2 ; u8 nc_ua3 ; u32 nc_esa ; u8 nc_ia ; u8 nc_ia1 ; u8 nc_ia2 ; u8 nc_ia3 ; u32 nc_sbc ; u32 nc_csbc ; u16 nc_crcpad ; u8 nc_crccntl0 ; u8 nc_crccntl1 ; u32 nc_crcdata ; u32 nc_e8_ ; u32 nc_ec_ ; u16 nc_dfbc ; } ;

struct sym_tblmove { u32 size ; u32 addr ; } ;

struct sym_tblsel { u_char sel_scntl4 ; u_char sel_sxfer ; u_char sel_id ; u_char sel_scntl3 ; } ;


typedef struct sym_quehead { struct sym_quehead * flink ; struct sym_quehead * blink ; } SYM_QUEHEAD ;

struct sym_slcb { u_short reqtags ; u_short scdev_depth ; } ;

struct sym_shcb { int unit ; char inst_name [ 16 ] ; char chip_name [ 8 ] ; struct Scsi_Host * host ; void * ioaddr ; void * ramaddr ; struct timer_list timer ; u_long lasttime ; u_long settle_time ; u_char settle_time_valid ; } ;

struct sym_nvram ;

struct sym_device { struct pci_dev * pdev ; unsigned long mmio_base ; unsigned long ram_base ; struct { void * ioaddr ; void * ramaddr ; } s ; struct sym_chip chip ; struct sym_nvram * nvram ; u_char host_id ; } ;

struct sym_data { struct sym_hcb * ncb ; struct completion * io_reset ; struct pci_dev * pdev ; } ;

struct sym_fwa_ofs { u_short start ; u_short getjob_begin ; u_short getjob_end ; u_short select ; u_short wf_sel_done ; u_short send_ident ; u_short dispatch ; u_short init ; u_short clrack ; u_short complete_error ; u_short done ; u_short done_end ; u_short idle ; u_short ungetjob ; u_short reselect ; u_short resel_tag ; u_short resel_dsa ; u_short resel_no_tag ; u_short data_in ; u_short data_in2 ; u_short data_out ; u_short data_out2 ; u_short pm0_data ; u_short pm1_data ; } ;

struct sym_fwb_ofs { u_short no_data ; u_short sel_for_abort ; u_short sel_for_abort_1 ; u_short msg_bad ; u_short msg_weird ; u_short wdtr_resp ; u_short send_wdtr ; u_short sdtr_resp ; u_short send_sdtr ; u_short ppr_resp ; u_short send_ppr ; u_short nego_bad_phase ; u_short ident_break ; u_short ident_break_atn ; u_short sdata_in ; u_short resel_bad_lun ; u_short bad_i_t_l ; u_short bad_i_t_l_q ; u_short wsr_ma_helper ; u_short start64 ; u_short pm_handle ; } ;

struct sym_fwz_ofs { u_short snooptest ; u_short snoopend ; } ;

struct sym_fwa_ba { u32 start ; u32 getjob_begin ; u32 getjob_end ; u32 select ; u32 wf_sel_done ; u32 send_ident ; u32 dispatch ; u32 init ; u32 clrack ; u32 complete_error ; u32 done ; u32 done_end ; u32 idle ; u32 ungetjob ; u32 reselect ; u32 resel_tag ; u32 resel_dsa ; u32 resel_no_tag ; u32 data_in ; u32 data_in2 ; u32 data_out ; u32 data_out2 ; u32 pm0_data ; u32 pm1_data ; } ;

struct sym_fwb_ba { u32 no_data ; u32 sel_for_abort ; u32 sel_for_abort_1 ; u32 msg_bad ; u32 msg_weird ; u32 wdtr_resp ; u32 send_wdtr ; u32 sdtr_resp ; u32 send_sdtr ; u32 ppr_resp ; u32 send_ppr ; u32 nego_bad_phase ; u32 ident_break ; u32 ident_break_atn ; u32 sdata_in ; u32 resel_bad_lun ; u32 bad_i_t_l ; u32 bad_i_t_l_q ; u32 wsr_ma_helper ; u32 start64 ; ; u32 pm_handle ; ; } ;

struct sym_fwz_ba { u32 snooptest ; u32 snoopend ; } ;

struct sym_hcb ;

struct sym_fw { char * name ; u32 * a_base ; int a_size ; struct sym_fwa_ofs * a_ofs ; u32 * b_base ; int b_size ; struct sym_fwb_ofs * b_ofs ; u32 * z_base ; int z_size ; struct sym_fwz_ofs * z_ofs ; void ( * setup ) ( struct sym_hcb * , struct sym_fw * ) ; void ( * patch ) ( struct Scsi_Host * ) ; } ;

struct sym_trans { u8 period ; u8 offset ; unsigned int width : 1 ; unsigned int iu : 1 ; unsigned int dt : 1 ; unsigned int qas : 1 ; unsigned int check_nego : 1 ; unsigned int renego : 2 ; } ;

struct sym_tcbh { u32 luntbl_sa ; u32 lun0_sa ; u_char uval ; u_char sval ; u_char filler1 ; u_char wval ; } ;

struct sym_tcb { struct sym_tcbh head ; u32 * luntbl ; int nlcb ; struct sym_lcb * lun0p ; struct sym_lcb * * lunmp ; struct sym_trans tgoal ; struct sym_trans tprint ; struct sym_ccb * nego_cp ; u_char to_reset ; unsigned char usrflags ; unsigned char usr_period ; unsigned char usr_width ; unsigned short usrtags ; struct scsi_target * starget ; } ;

struct sym_lcbh { u32 resel_sa ; u32 itl_task_sa ; u32 itlq_tbl_sa ; } ;

struct sym_lcb { struct sym_lcbh head ; u32 * itlq_tbl ; u_short busy_itlq ; u_short busy_itl ; u_short ia_tag ; u_short if_tag ; u_char * cb_tags ; struct sym_slcb s ; u_char tags_si ; u_short tags_sum [ 2 ] ; u_short tags_since ; u_char to_clear ; u_char user_flags ; u_char curr_flags ; } ;

struct sym_actscr { u32 start ; u32 restart ; } ;

struct sym_pmc { struct sym_tblmove sg ; u32 ret ; } ;

struct sym_ccbh { struct sym_actscr go ; u32 savep ; u32 lastp ; u8 status [ 4 ] ; } ;

struct sym_dsb { struct sym_ccbh head ; struct sym_pmc pm0 ; struct sym_pmc pm1 ; struct sym_tblsel select ; struct sym_tblmove smsg ; struct sym_tblmove smsg_ext ; struct sym_tblmove cmd ; struct sym_tblmove sense ; struct sym_tblmove wresid ; struct sym_tblmove data [ ( 96 ) ] ; } ;

struct sym_ccb { struct sym_dsb phys ; struct scsi_cmnd * cmd ; u8 cdb_buf [ 16 ] ; u8 sns_bbuf [ 32 ] ; int data_len ; int segments ; u8 order ; unsigned char odd_byte_adjustment ; u_char nego_status ; u_char xerr_status ; u32 extra_bytes ; u_char scsi_smsg [ 12 ] ; u_char scsi_smsg2 [ 12 ] ; u_char sensecmd [ 6 ] ; u_char sv_scsi_status ; u_char sv_xerr_status ; int sv_resid ; u32 ccb_ba ; u_short tag ; u_char target ; u_char lun ; struct sym_ccb * link_ccbh ; SYM_QUEHEAD link_ccbq ; u32 startp ; u32 goalp ; int ext_sg ; int ext_ofs ; u_char to_abort ; u_char tags_si ; } ;

typedef struct device * m_pool_ident_t ;

struct sym_hcb { struct sym_ccbh ccb_head ; struct sym_tcbh tcb_head ; struct sym_lcbh lcb_head ; struct sym_actscr idletask , notask , bad_itl , bad_itlq ; u32 idletask_ba , notask_ba , bad_itl_ba , bad_itlq_ba ; u32 * badluntbl ; u32 badlun_sa ; u32 hcb_ba ; u32 scr_ram_seg ; u_char sv_scntl0 , sv_scntl3 , sv_dmode , sv_dcntl , sv_ctest3 , sv_ctest4 , sv_ctest5 , sv_gpcntl , sv_stest2 , sv_stest4 , sv_scntl4 , sv_stest1 ; u_char rv_scntl0 , rv_scntl3 , rv_dmode , rv_dcntl , rv_ctest3 , rv_ctest4 , rv_ctest5 , rv_stest2 , rv_ccntl0 , rv_ccntl1 , rv_scntl4 ; struct sym_tcb target [ ( 16 ) ] ; u32 * targtbl ; u32 targtbl_ba ; m_pool_ident_t bus_dmat ; struct sym_shcb s ; u32 mmio_ba ; u32 ram_ba ; u_char * scripta0 ; u_char * scriptb0 ; u_char * scriptz0 ; u32 scripta_ba ; u32 scriptb_ba ; u32 scriptz_ba ; u_short scripta_sz ; u_short scriptb_sz ; u_short scriptz_sz ; struct sym_fwa_ba fwa_bas ; struct sym_fwb_ba fwb_bas ; struct sym_fwz_ba fwz_bas ; void ( * fw_setup ) ( struct sym_hcb * np , struct sym_fw * fw ) ; void ( * fw_patch ) ( struct Scsi_Host * ) ; char * fw_name ; u_int features ; u_char myaddr ; u_char maxburst ; u_char maxwide ; u_char minsync ; u_char maxsync ; u_char maxoffs ; u_char minsync_dt ; u_char maxsync_dt ; u_char maxoffs_dt ; u_char multiplier ; u_char clock_divn ; u32 clock_khz ; u32 pciclk_khz ; volatile u32 * squeue ; u32 squeue_ba ; u_short squeueput ; u_short actccbs ; u_short dqueueget ; volatile u32 * dqueue ; u32 dqueue_ba ; u_char msgout [ 8 ] ; u_char msgin [ 8 ] ; u32 lastmsg ; u32 scratch ; u_char usrflags ; u_char scsi_mode ; u_char verbose ; struct sym_ccb * * ccbh ; SYM_QUEHEAD free_ccbq ; SYM_QUEHEAD busy_ccbq ; SYM_QUEHEAD comp_ccbq ; u_char abrt_msg [ 4 ] ; struct sym_tblmove abrt_tbl ; struct sym_tblsel abrt_sel ; u_char istat_sem ; u_char use_dac ; } ;

typedef struct sym_m_link { struct sym_m_link * next ; } * m_link_p ;


typedef struct sym_m_vtob { struct sym_m_vtob * next ; void * vaddr ; dma_addr_t baddr ; } * m_vtob_p ;


typedef struct sym_m_pool { m_pool_ident_t dev_dmat ; void * ( * get_mem_cluster ) ( struct sym_m_pool * ) ; void ( * free_mem_cluster ) ( struct sym_m_pool * , void * ) ; int nump ; m_vtob_p vtob [ ( 1UL << 5 ) ] ; struct sym_m_pool * next ; struct sym_m_link h [ ( 12 + 0 ) - 4 + 1 ] ; } * m_pool_p ;

struct sym_fw1a_scr { u32 start [ 11 ] ; u32 getjob_begin [ 4 ] ; u32 _sms_a10 [ 5 ] ; u32 getjob_end [ 4 ] ; u32 _sms_a20 [ 4 ] ; u32 select [ 6 ] ; u32 _sms_a30 [ 5 ] ; u32 wf_sel_done [ 2 ] ; u32 send_ident [ 2 ] ; u32 select2 [ 2 ] ; u32 command [ 2 ] ; u32 dispatch [ 28 ] ; u32 sel_no_cmd [ 10 ] ; u32 init [ 6 ] ; u32 clrack [ 4 ] ; u32 datai_done [ 11 ] ; u32 datai_done_wsr [ 20 ] ; u32 datao_done [ 11 ] ; u32 datao_done_wss [ 6 ] ; u32 datai_phase [ 5 ] ; u32 datao_phase [ 5 ] ; u32 msg_in [ 2 ] ; u32 msg_in2 [ 10 ] ; u32 status [ 10 ] ; u32 complete [ 6 ] ; u32 complete2 [ 8 ] ; u32 _sms_a40 [ 12 ] ; u32 done [ 5 ] ; u32 _sms_a50 [ 5 ] ; u32 _sms_a60 [ 2 ] ; u32 done_end [ 4 ] ; u32 complete_error [ 5 ] ; u32 save_dp [ 11 ] ; u32 restore_dp [ 7 ] ; u32 disconnect [ 11 ] ; u32 disconnect2 [ 5 ] ; u32 _sms_a65 [ 3 ] ; u32 idle [ 2 ] ; u32 ungetjob [ 5 ] ; u32 reselect [ 2 ] ; u32 reselected [ 19 ] ; u32 _sms_a70 [ 6 ] ; u32 _sms_a80 [ 4 ] ; u32 reselected1 [ 25 ] ; u32 _sms_a90 [ 4 ] ; u32 resel_lun0 [ 7 ] ; u32 _sms_a100 [ 4 ] ; u32 resel_tag [ 8 ] ; u32 _sms_a110 [ 13 ] ; u32 _sms_a120 [ 2 ] ; u32 resel_go [ 4 ] ; u32 _sms_a130 [ 7 ] ; u32 resel_dsa [ 2 ] ; u32 resel_dsa1 [ 4 ] ; u32 _sms_a140 [ 7 ] ; u32 resel_no_tag [ 4 ] ; u32 _sms_a145 [ 7 ] ; u32 data_in [ ( 96 ) * 2 ] ; u32 data_in2 [ 4 ] ; u32 data_out [ ( 96 ) * 2 ] ; u32 data_out2 [ 4 ] ; u32 pm0_data [ 12 ] ; u32 pm0_data_out [ 6 ] ; u32 pm0_data_end [ 7 ] ; u32 pm_data_end [ 4 ] ; u32 _sms_a150 [ 4 ] ; u32 pm1_data [ 12 ] ; u32 pm1_data_out [ 6 ] ; u32 pm1_data_end [ 9 ] ; } ;

struct sym_fw1b_scr { u32 no_data [ 2 ] ; u32 sel_for_abort [ 16 ] ; u32 sel_for_abort_1 [ 2 ] ; u32 msg_in_etc [ 12 ] ; u32 msg_received [ 5 ] ; u32 msg_weird_seen [ 5 ] ; u32 msg_extended [ 17 ] ; u32 _sms_b10 [ 4 ] ; u32 msg_bad [ 6 ] ; u32 msg_weird [ 4 ] ; u32 msg_weird1 [ 8 ] ; u32 wdtr_resp [ 6 ] ; u32 send_wdtr [ 4 ] ; u32 sdtr_resp [ 6 ] ; u32 send_sdtr [ 4 ] ; u32 ppr_resp [ 6 ] ; u32 send_ppr [ 4 ] ; u32 nego_bad_phase [ 4 ] ; u32 msg_out [ 4 ] ; u32 msg_out_done [ 4 ] ; u32 data_ovrun [ 3 ] ; u32 data_ovrun1 [ 22 ] ; u32 data_ovrun2 [ 8 ] ; u32 abort_resel [ 16 ] ; u32 resend_ident [ 4 ] ; u32 ident_break [ 4 ] ; u32 ident_break_atn [ 4 ] ; u32 sdata_in [ 6 ] ; u32 resel_bad_lun [ 4 ] ; u32 bad_i_t_l [ 4 ] ; u32 bad_i_t_l_q [ 4 ] ; u32 bad_status [ 7 ] ; u32 wsr_ma_helper [ 4 ] ; u32 zero [ 1 ] ; u32 scratch [ 1 ] ; u32 scratch1 [ 1 ] ; u32 prev_done [ 1 ] ; u32 done_pos [ 1 ] ; u32 nextjob [ 1 ] ; u32 startpos [ 1 ] ; u32 targtbl [ 1 ] ; } ;

struct sym_fw1z_scr { u32 snooptest [ 9 ] ; u32 snoopend [ 2 ] ; } ;

struct sym_fw2a_scr { u32 start [ 14 ] ; u32 getjob_begin [ 4 ] ; u32 getjob_end [ 4 ] ; u32 select [ 4 ] ; u32 wf_sel_done [ 2 ] ; u32 sel_done [ 2 ] ; u32 send_ident [ 2 ] ; u32 select2 [ 2 ] ; u32 command [ 2 ] ; u32 dispatch [ 28 ] ; u32 sel_no_cmd [ 10 ] ; u32 init [ 6 ] ; u32 clrack [ 4 ] ; u32 datai_done [ 10 ] ; u32 datai_done_wsr [ 20 ] ; u32 datao_done [ 10 ] ; u32 datao_done_wss [ 6 ] ; u32 datai_phase [ 4 ] ; u32 datao_phase [ 6 ] ; u32 msg_in [ 2 ] ; u32 msg_in2 [ 10 ] ; u32 status [ 10 ] ; u32 complete [ 6 ] ; u32 complete2 [ 12 ] ; u32 done [ 14 ] ; u32 done_end [ 2 ] ; u32 complete_error [ 4 ] ; u32 save_dp [ 12 ] ; u32 restore_dp [ 8 ] ; u32 disconnect [ 12 ] ; u32 idle [ 2 ] ; u32 ungetjob [ 4 ] ; u32 reselect [ 2 ] ; u32 reselected [ 22 ] ; u32 resel_scntl4 [ 20 ] ; u32 resel_lun0 [ 6 ] ; u32 resel_tag [ 16 ] ; u32 resel_dsa [ 2 ] ; u32 resel_dsa1 [ 4 ] ; u32 resel_no_tag [ 6 ] ; u32 data_in [ ( 96 ) * 2 ] ; u32 data_in2 [ 4 ] ; u32 data_out [ ( 96 ) * 2 ] ; u32 data_out2 [ 4 ] ; u32 pm0_data [ 12 ] ; u32 pm0_data_out [ 6 ] ; u32 pm0_data_end [ 6 ] ; u32 pm1_data [ 12 ] ; u32 pm1_data_out [ 6 ] ; u32 pm1_data_end [ 6 ] ; } ;

struct sym_fw2b_scr { u32 start64 [ 2 ] ; u32 no_data [ 2 ] ; u32 sel_for_abort [ 16 ] ; u32 sel_for_abort_1 [ 2 ] ; u32 msg_in_etc [ 12 ] ; u32 msg_received [ 4 ] ; u32 msg_weird_seen [ 4 ] ; u32 msg_extended [ 20 ] ; u32 msg_bad [ 6 ] ; u32 msg_weird [ 4 ] ; u32 msg_weird1 [ 8 ] ; u32 wdtr_resp [ 6 ] ; u32 send_wdtr [ 4 ] ; u32 sdtr_resp [ 6 ] ; u32 send_sdtr [ 4 ] ; u32 ppr_resp [ 6 ] ; u32 send_ppr [ 4 ] ; u32 nego_bad_phase [ 4 ] ; u32 msg_out [ 4 ] ; u32 msg_out_done [ 4 ] ; u32 data_ovrun [ 2 ] ; u32 data_ovrun1 [ 22 ] ; u32 data_ovrun2 [ 8 ] ; u32 abort_resel [ 16 ] ; u32 resend_ident [ 4 ] ; u32 ident_break [ 4 ] ; u32 ident_break_atn [ 4 ] ; u32 sdata_in [ 6 ] ; u32 resel_bad_lun [ 4 ] ; u32 bad_i_t_l [ 4 ] ; u32 bad_i_t_l_q [ 4 ] ; u32 bad_status [ 6 ] ; u32 pm_handle [ 20 ] ; u32 pm_handle1 [ 4 ] ; u32 pm_save [ 4 ] ; u32 pm0_save [ 12 ] ; u32 pm_save_end [ 4 ] ; u32 pm1_save [ 14 ] ; u32 pm_wsr_handle [ 38 ] ; u32 wsr_ma_helper [ 4 ] ; u32 zero [ 1 ] ; u32 scratch [ 1 ] ; u32 pm0_data_addr [ 1 ] ; u32 pm1_data_addr [ 1 ] ; u32 done_pos [ 1 ] ; u32 startpos [ 1 ] ; u32 targtbl [ 1 ] ; } ;

struct sym_fw2z_scr { u32 snooptest [ 6 ] ; u32 snoopend [ 2 ] ; } ;

struct sym_fw * sym_find_firmware ( struct sym_chip * chip ) ;

void sym_fw_bind_script ( struct sym_hcb * np , u32 * start , int len ) ;

struct Symbios_nvram { u_short type ; u_short byte_count ; u_short checksum ; u_char v_major ; u_char v_minor ; u32 boot_crc ; u_short flags ; u_short flags1 ; u_short term_state ; u_short rmvbl_flags ; u_char host_id ; u_char num_hba ; u_char num_devices ; u_char max_scam_devices ; u_char num_valid_scam_devices ; u_char flags2 ; struct Symbios_host { u_short type ; u_short device_id ; u_short vendor_id ; u_char bus_nr ; u_char device_fn ; u_short word8 ; u_short flags ; u_short io_port ; } host [ 4 ] ; struct Symbios_target { u_char flags ; u_char rsvd ; u_char bus_width ; u_char sync_offset ; u_short sync_period ; u_short timeout ; } target [ 16 ] ; struct Symbios_scam { u_short id ; u_short method ; u_short status ; u_char target_id ; u_char rsvd ; } scam [ 4 ] ; u_char spare_devices [ 15 * 8 ] ; u_char trailer [ 6 ] ; } ;

typedef struct Symbios_nvram Symbios_nvram ;

typedef struct Symbios_host Symbios_host ;

typedef struct Symbios_target Symbios_target ;

typedef struct Symbios_scam Symbios_scam ;

struct Tekram_nvram { struct Tekram_target { u_char flags ; u_char sync_index ; u_short word2 ; } target [ 16 ] ; u_char host_id ; u_char flags ; u_char boot_delay_index ; u_char max_tags_index ; u_short flags1 ; u_short spare [ 29 ] ; } ;

typedef struct Tekram_nvram Tekram_nvram ;

typedef struct Tekram_target Tekram_target ;

struct pdc_initiator { int dummy ; } ;

struct sym_nvram { int type ; union { Symbios_nvram Symbios ; Tekram_nvram Tekram ; struct pdc_initiator parisc ; } data ; } ;
struct sym_ucmd { struct completion * eh_done ; } ;

void sym_xpt_done ( struct sym_hcb * np , struct scsi_cmnd * cmd ) ;

void sym_xpt_async_bus_reset ( struct sym_hcb * np ) ;

void sym_set_cam_result_error ( struct sym_hcb * np , struct sym_ccb * cp , int resid ) ;

int sym_setup_data_and_start ( struct sym_hcb * np , struct scsi_cmnd * cmd , struct sym_ccb * cp ) ;

void sym_log_bus_error ( struct Scsi_Host * shost ) ;

struct sym_usrcmd { u_long target ; u_long lun ; u_long data ; u_long cmd ; } ;

struct info_str { char * buffer ; int length ; int offset ; int pos ; } ;

void sym_print_xerr ( struct scsi_cmnd * cmd , int x_status ) ;

int sym_reset_scsi_bus ( struct sym_hcb * np , int enab_int ) ;

void sym_dump_registers ( struct Scsi_Host * shost ) ;

struct sym_chip * sym_lookup_chip_table ( u_short device_id , u_char revision ) ;

void sym_put_start_queue ( struct sym_hcb * np , struct sym_ccb * cp ) ;

void sym_start_up ( struct Scsi_Host * shost , int reason ) ;

irqreturn_t sym_interrupt ( struct Scsi_Host * shost ) ;

int sym_clear_tasks ( struct sym_hcb * np , int cam_status , int target , int lun , int task ) ;

int sym_compute_residual ( struct sym_hcb * np , struct sym_ccb * cp ) ;

struct sym_ccb * sym_get_ccb ( struct sym_hcb * np , struct scsi_cmnd * cmd , u_char tag_order ) ;

void sym_free_ccb ( struct sym_hcb * np , struct sym_ccb * cp ) ;

struct sym_lcb * sym_alloc_lcb ( struct sym_hcb * np , u_char tn , u_char ln ) ;

int sym_free_lcb ( struct sym_hcb * np , u_char tn , u_char ln ) ;

int sym_queue_scsiio ( struct sym_hcb * np , struct scsi_cmnd * cmd , struct sym_ccb * cp ) ;

int sym_reset_scsi_target ( struct sym_hcb * np , int target ) ;

int sym_abort_scsiio ( struct sym_hcb * np , struct scsi_cmnd * cmd , int timed_out ) ;

void sym_complete_error ( struct sym_hcb * np , struct sym_ccb * cp ) ;

void sym_complete_ok ( struct sym_hcb * np , struct sym_ccb * cp ) ;

int sym_hcb_attach ( struct Scsi_Host * shost , struct sym_fw * fw , struct sym_nvram * nvram ) ;

void sym_hcb_free ( struct sym_hcb * np ) ;

void * __sym_calloc_dma ( m_pool_ident_t dev_dmat , int size , char * name ) ;

void __sym_mfree_dma ( m_pool_ident_t dev_dmat , void * m , int size , char * name ) ;

dma_addr_t __vtobus ( m_pool_ident_t dev_dmat , void * m ) ;

void sym_nvram_setup_host ( struct Scsi_Host * shost , struct sym_hcb * np , struct sym_nvram * nvram ) ;

void sym_nvram_setup_target ( struct sym_tcb * tp , int target , struct sym_nvram * nvp ) ;

int sym_read_nvram ( struct sym_device * np , struct sym_nvram * nvp ) ;

char * sym_nvram_type ( struct sym_nvram * nvp ) ;

typedef struct scsi_cmnd Scsi_Cmnd ;


typedef struct sg_scatter_hold { unsigned short k_use_sg ; unsigned sglist_len ; unsigned bufflen ; struct page * * pages ; int page_order ; char dio_in_use ; unsigned char cmd_opcode ; } Sg_scatter_hold ;

struct sg_device ;

struct sg_fd ;


typedef struct sg_request { struct sg_request * nextrp ; struct sg_fd * parentfp ; Sg_scatter_hold data ; sg_io_hdr_t header ; unsigned char sense_b [ 96 ] ; char res_used ; char orphan ; char sg_io_owned ; volatile char done ; struct request * rq ; struct bio * bio ; struct execute_work ew ; } Sg_request ;

typedef struct sg_fd { struct list_head sfd_siblings ; struct sg_device * parentdp ; wait_queue_head_t read_wait ; rwlock_t rq_list_lock ; int timeout ; int timeout_user ; Sg_scatter_hold reserve ; unsigned save_scat_len ; Sg_request * headrp ; struct fasync_struct * async_qp ; Sg_request req_arr [ 16 ] ; char low_dma ; char force_packid ; volatile char closed ; char cmd_q ; char next_cmd_len ; char keep_orphan ; char mmap_called ; struct kref f_ref ; struct execute_work ew ; } Sg_fd ;

typedef struct sg_device { struct scsi_device * device ; wait_queue_head_t o_excl_wait ; int sg_tablesize ; u32 index ; struct list_head sfds ; volatile char detached ; volatile char exclude ; char sgdebug ; struct gendisk * disk ; struct cdev * cdev ; struct kref d_ref ; } Sg_device ;

struct sg_proc_leaf { const char * name ; const struct file_operations * fops ; } ;

struct sg_proc_deviter { loff_t index ; size_t max ; } ;

void uart_write_wakeup ( struct uart_port * port ) ;

void uart_update_timeout ( struct uart_port * port , unsigned int cflag , unsigned int baud ) ;

unsigned int uart_get_baud_rate ( struct uart_port * port , struct ktermios * termios , struct ktermios * old , unsigned int min , unsigned int max ) ;

unsigned int uart_get_divisor ( struct uart_port * port , unsigned int baud ) ;

void uart_console_write ( struct uart_port * port , const char * s , unsigned int count , void ( * putchar ) ( struct uart_port * , int ) ) ;

struct uart_port * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) uart_get_console ( struct uart_port * ports , int nr , struct console * co ) ;

void uart_parse_options ( char * options , int * baud , int * parity , int * bits , int * flow ) ;

struct baud_rates { unsigned int rate ; unsigned int cflag ; } ;

int uart_set_options ( struct uart_port * port , struct console * co , int baud , int parity , int bits , int flow ) ;

struct uart_match { struct uart_port * port ; struct uart_driver * driver ; } ;

int uart_suspend_port ( struct uart_driver * drv , struct uart_port * uport ) ;

int uart_resume_port ( struct uart_driver * drv , struct uart_port * uport ) ;

int uart_register_driver ( struct uart_driver * drv ) ;

void uart_unregister_driver ( struct uart_driver * drv ) ;

struct tty_driver * uart_console_device ( struct console * co , int * index ) ;

int uart_add_one_port ( struct uart_driver * drv , struct uart_port * uport ) ;

int uart_remove_one_port ( struct uart_driver * drv , struct uart_port * uport ) ;

int uart_match_port ( struct uart_port * port1 , struct uart_port * port2 ) ;

struct old_serial_port { unsigned int uart ; unsigned int baud_base ; unsigned int port ; unsigned int irq ; unsigned int flags ; unsigned char hub6 ; unsigned char io_type ; unsigned char * iomem_base ; unsigned short iomem_reg_shift ; unsigned long irqflags ; } ;

struct serial8250_config { const char * name ; unsigned short fifo_size ; unsigned short tx_loadsz ; unsigned char fcr ; unsigned int flags ; } ;

struct uart_8250_port { struct uart_port port ; struct timer_list timer ; struct list_head list ; unsigned short capabilities ; unsigned short bugs ; unsigned int tx_loadsz ; unsigned char acr ; unsigned char ier ; unsigned char lcr ; unsigned char mcr ; unsigned char mcr_mask ; unsigned char mcr_force ; unsigned char cur_iotype ; unsigned char lsr_saved_flags ; unsigned char msr_saved_flags ; void ( * pm ) ( struct uart_port * port , unsigned int state , unsigned int old ) ; } ;

struct irq_info { struct hlist_node node ; int irq ; spinlock_t lock ; struct list_head * head ; } ;

int serial8250_find_port ( struct uart_port * p ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) early_serial_setup ( struct uart_port * port ) ;

void serial8250_suspend_port ( int line ) ;

void serial8250_resume_port ( int line ) ;

int serial8250_register_port ( struct uart_port * port ) ;

void serial8250_unregister_port ( int line ) ;

struct pciserial_board { unsigned int flags ; unsigned int num_ports ; unsigned int base_baud ; unsigned int uart_offset ; unsigned int reg_shift ; unsigned int first_offset ; } ;

struct serial_private ;

struct pci_serial_quirk { u32 vendor ; u32 device ; u32 subvendor ; u32 subdevice ; int ( * init ) ( struct pci_dev * dev ) ; int ( * setup ) ( struct serial_private * , const struct pciserial_board * , struct uart_port * , int ) ; void ( * exit ) ( struct pci_dev * dev ) ; } ;

struct serial_private { struct pci_dev * dev ; unsigned int nr ; void * remapped_bar [ 6 ] ; struct pci_serial_quirk * quirk ; int line [ 0 ] ; } ;

enum pci_board_num_t { pbn_default = 0 , pbn_b0_1_115200 , pbn_b0_2_115200 , pbn_b0_4_115200 , pbn_b0_5_115200 , pbn_b0_8_115200 , pbn_b0_1_921600 , pbn_b0_2_921600 , pbn_b0_4_921600 , pbn_b0_2_1130000 , pbn_b0_4_1152000 , pbn_b0_2_1843200 , pbn_b0_4_1843200 , pbn_b0_2_1843200_200 , pbn_b0_4_1843200_200 , pbn_b0_8_1843200_200 , pbn_b0_1_4000000 , pbn_b0_bt_1_115200 , pbn_b0_bt_2_115200 , pbn_b0_bt_8_115200 , pbn_b0_bt_1_460800 , pbn_b0_bt_2_460800 , pbn_b0_bt_4_460800 , pbn_b0_bt_1_921600 , pbn_b0_bt_2_921600 , pbn_b0_bt_4_921600 , pbn_b0_bt_8_921600 , pbn_b1_1_115200 , pbn_b1_2_115200 , pbn_b1_4_115200 , pbn_b1_8_115200 , pbn_b1_16_115200 , pbn_b1_1_921600 , pbn_b1_2_921600 , pbn_b1_4_921600 , pbn_b1_8_921600 , pbn_b1_2_1250000 , pbn_b1_bt_1_115200 , pbn_b1_bt_2_115200 , pbn_b1_bt_4_115200 , pbn_b1_bt_2_921600 , pbn_b1_1_1382400 , pbn_b1_2_1382400 , pbn_b1_4_1382400 , pbn_b1_8_1382400 , pbn_b2_1_115200 , pbn_b2_2_115200 , pbn_b2_4_115200 , pbn_b2_8_115200 , pbn_b2_1_460800 , pbn_b2_4_460800 , pbn_b2_8_460800 , pbn_b2_16_460800 , pbn_b2_1_921600 , pbn_b2_4_921600 , pbn_b2_8_921600 , pbn_b2_bt_1_115200 , pbn_b2_bt_2_115200 , pbn_b2_bt_4_115200 , pbn_b2_bt_2_921600 , pbn_b2_bt_4_921600 , pbn_b3_2_115200 , pbn_b3_4_115200 , pbn_b3_8_115200 , pbn_panacom , pbn_panacom2 , pbn_panacom4 , pbn_exsys_4055 , pbn_plx_romulus , pbn_oxsemi , pbn_oxsemi_1_4000000 , pbn_oxsemi_2_4000000 , pbn_oxsemi_4_4000000 , pbn_oxsemi_8_4000000 , pbn_intel_i960 , pbn_sgi_ioc3 , pbn_computone_4 , pbn_computone_6 , pbn_computone_8 , pbn_sbsxrsio , pbn_exar_XR17C152 , pbn_exar_XR17C154 , pbn_exar_XR17C158 , pbn_exar_ibm_saturn , pbn_pasemi_1682M , pbn_ni8430_2 , pbn_ni8430_4 , pbn_ni8430_8 , pbn_ni8430_16 , pbn_ADDIDATA_PCIe_1_3906250 , pbn_ADDIDATA_PCIe_2_3906250 , pbn_ADDIDATA_PCIe_4_3906250 , pbn_ADDIDATA_PCIe_8_3906250 , } ;

struct serial_private * pciserial_init_ports ( struct pci_dev * dev , const struct pciserial_board * board ) ;

void pciserial_remove_ports ( struct serial_private * priv ) ;

void pciserial_suspend_ports ( struct serial_private * priv ) ;

void pciserial_resume_ports ( struct serial_private * priv ) ;

struct early_serial8250_device { struct uart_port port ; char options [ 16 ] ; unsigned int baud ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) setup_early_serial8250_console ( char * cmdline ) ;

int serial8250_find_port_for_earlycon ( void ) ;

struct sfi_table_key { char * sig ; char * oem_id ; char * oem_table_id ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sfi_acpi_init ( void ) ;

int sfi_acpi_table_parse ( char * signature , char * oem_id , char * oem_table_id , int ( * handler ) ( struct acpi_table_header * ) ) ;

struct sfi_table_header * sfi_map_table ( u64 pa ) ;

void sfi_unmap_table ( struct sfi_table_header * th ) ;

struct sfi_table_header * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( noinline ) ) sfi_check_table ( u64 pa , struct sfi_table_key * key ) ;

struct sfi_table_header * sfi_get_table ( struct sfi_table_key * key ) ;

void sfi_put_table ( struct sfi_table_header * th ) ;

int sfi_table_parse ( char * signature , char * oem_id , char * oem_table_id , sfi_table_handler handler ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sfi_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sfi_init_late ( void ) ;

struct spi_device { struct device dev ; struct spi_master * master ; u32 max_speed_hz ; u8 chip_select ; u8 mode ; u8 bits_per_word ; int irq ; void * controller_state ; void * controller_data ; char modalias [ 32 ] ; } ;

struct spi_message ;

struct spi_driver { const struct spi_device_id * id_table ; int ( * probe ) ( struct spi_device * spi ) ; int ( * remove ) ( struct spi_device * spi ) ; void ( * shutdown ) ( struct spi_device * spi ) ; int ( * suspend ) ( struct spi_device * spi , pm_message_t mesg ) ; int ( * resume ) ( struct spi_device * spi ) ; struct device_driver driver ; } ;

struct spi_master { struct device dev ; s16 bus_num ; u16 num_chipselect ; u16 dma_alignment ; u16 mode_bits ; u16 flags ; int ( * setup ) ( struct spi_device * spi ) ; int ( * transfer ) ( struct spi_device * spi , struct spi_message * mesg ) ; void ( * cleanup ) ( struct spi_device * spi ) ; } ;

struct spi_transfer { const void * tx_buf ; void * rx_buf ; unsigned len ; dma_addr_t tx_dma ; dma_addr_t rx_dma ; unsigned cs_change : 1 ; u8 bits_per_word ; u16 delay_usecs ; u32 speed_hz ; struct list_head transfer_list ; } ;

struct spi_message { struct list_head transfers ; struct spi_device * spi ; unsigned is_dma_mapped : 1 ; void ( * complete ) ( void * context ) ; void * context ; unsigned actual_length ; int status ; struct list_head queue ; void * state ; } ;
struct spi_board_info { char modalias [ 32 ] ; const void * platform_data ; void * controller_data ; int irq ; u32 max_speed_hz ; u16 bus_num ; u16 chip_select ; u8 mode ; } ;

const struct spi_device_id * spi_get_device_id ( const struct spi_device * sdev ) ;

int spi_register_driver ( struct spi_driver * sdrv ) ;

struct boardinfo { struct list_head list ; unsigned n_board_info ; struct spi_board_info board_info [ 0 ] ; } ;

struct spi_device * spi_alloc_device ( struct spi_master * master ) ;

int spi_add_device ( struct spi_device * spi ) ;

struct spi_device * spi_new_device ( struct spi_master * master , struct spi_board_info * chip ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) spi_register_board_info ( struct spi_board_info const * info , unsigned n ) ;

struct spi_master * spi_alloc_master ( struct device * dev , unsigned size ) ;

int spi_register_master ( struct spi_master * master ) ;

void spi_unregister_master ( struct spi_master * master ) ;

struct spi_master * spi_busnum_to_master ( u16 bus_num ) ;

int spi_setup ( struct spi_device * spi ) ;

int spi_async ( struct spi_device * spi , struct spi_message * message ) ;

int spi_sync ( struct spi_device * spi , struct spi_message * message ) ;

int spi_write_then_read ( struct spi_device * spi , const u8 * txbuf , unsigned n_tx , u8 * rxbuf , unsigned n_rx ) ;

; ; ; struct thermal_cooling_device_instance { int id ; char name [ 20 ] ; struct thermal_zone_device * tz ; struct thermal_cooling_device * cdev ; int trip ; char attr_name [ 20 ] ; struct device_attribute attr ; struct list_head node ; } ;

int thermal_zone_bind_cooling_device ( struct thermal_zone_device * tz , int trip , struct thermal_cooling_device * cdev ) ;

int thermal_zone_unbind_cooling_device ( struct thermal_zone_device * tz , int trip , struct thermal_cooling_device * cdev ) ;

struct thermal_cooling_device * thermal_cooling_device_register ( char * type , void * devdata , struct thermal_cooling_device_ops * ops ) ;

void thermal_cooling_device_unregister ( struct thermal_cooling_device * cdev ) ;

void thermal_zone_device_update ( struct thermal_zone_device * tz ) ;

struct thermal_zone_device * thermal_zone_device_register ( char * type , int trips , void * devdata , struct thermal_zone_device_ops * ops , int tc1 , int tc2 , int passive_delay , int polling_delay ) ;

void thermal_zone_device_unregister ( struct thermal_zone_device * tz ) ;

struct usb_hcd { struct usb_bus self ; struct kref kref ; const char * product_desc ; char irq_descr [ 24 ] ; struct timer_list rh_timer ; struct urb * status_urb ; struct work_struct wakeup_work ; const struct hc_driver * driver ; unsigned long flags ; unsigned rh_registered : 1 ; unsigned uses_new_polling : 1 ; unsigned poll_rh : 1 ; unsigned poll_pending : 1 ; unsigned wireless : 1 ; unsigned authorized_default : 1 ; unsigned has_tt : 1 ; int irq ; void * regs ; u64 rsrc_start ; u64 rsrc_len ; unsigned power_budget ; struct dma_pool * pool [ 4 ] ; int state ; unsigned long hcd_priv [ 0 ] __attribute__ ( ( aligned ( sizeof ( unsigned long ) ) ) ) ; } ;

struct hcd_timeout { struct list_head timeout_list ; struct timer_list timer ; } ;

struct hc_driver { const char * description ; const char * product_desc ; size_t hcd_priv_size ; irqreturn_t ( * irq ) ( struct usb_hcd * hcd ) ; int flags ; int ( * reset ) ( struct usb_hcd * hcd ) ; int ( * start ) ( struct usb_hcd * hcd ) ; int ( * pci_suspend ) ( struct usb_hcd * hcd ) ; int ( * pci_resume ) ( struct usb_hcd * hcd , bool hibernated ) ; void ( * stop ) ( struct usb_hcd * hcd ) ; void ( * shutdown ) ( struct usb_hcd * hcd ) ; int ( * get_frame_number ) ( struct usb_hcd * hcd ) ; int ( * urb_enqueue ) ( struct usb_hcd * hcd , struct urb * urb , gfp_t mem_flags ) ; int ( * urb_dequeue ) ( struct usb_hcd * hcd , struct urb * urb , int status ) ; void ( * endpoint_disable ) ( struct usb_hcd * hcd , struct usb_host_endpoint * ep ) ; void ( * endpoint_reset ) ( struct usb_hcd * hcd , struct usb_host_endpoint * ep ) ; int ( * hub_status_data ) ( struct usb_hcd * hcd , char * buf ) ; int ( * hub_control ) ( struct usb_hcd * hcd , u16 typeReq , u16 wValue , u16 wIndex , char * buf , u16 wLength ) ; int ( * bus_suspend ) ( struct usb_hcd * ) ; int ( * bus_resume ) ( struct usb_hcd * ) ; int ( * start_port_reset ) ( struct usb_hcd * , unsigned port_num ) ; void ( * relinquish_port ) ( struct usb_hcd * , int ) ; int ( * port_handed_over ) ( struct usb_hcd * , int ) ; void ( * clear_tt_buffer_complete ) ( struct usb_hcd * , struct usb_host_endpoint * ) ; int ( * alloc_dev ) ( struct usb_hcd * , struct usb_device * ) ; void ( * free_dev ) ( struct usb_hcd * , struct usb_device * ) ; int ( * add_endpoint ) ( struct usb_hcd * , struct usb_device * , struct usb_host_endpoint * ) ; int ( * drop_endpoint ) ( struct usb_hcd * , struct usb_device * , struct usb_host_endpoint * ) ; int ( * check_bandwidth ) ( struct usb_hcd * , struct usb_device * ) ; void ( * reset_bandwidth ) ( struct usb_hcd * , struct usb_device * ) ; int ( * address_device ) ( struct usb_hcd * , struct usb_device * udev ) ; int ( * update_hub_device ) ( struct usb_hcd * , struct usb_device * hdev , struct usb_tt * tt , gfp_t mem_flags ) ; } ;

struct pci_device_id ;
struct usb_port_status { __le16 wPortStatus ; __le16 wPortChange ; } __attribute__ ( ( packed ) ) ;
struct usb_hub_status { __le16 wHubStatus ; __le16 wHubChange ; } __attribute__ ( ( packed ) ) ;
struct usb_hub_descriptor { __u8 bDescLength ; __u8 bDescriptorType ; __u8 bNbrPorts ; __le16 wHubCharacteristics ; __u8 bPwrOn2PwrGood ; __u8 bHubContrCurrent ; __u8 DeviceRemovable [ ( ( 31 ) + 1 + 7 ) / 8 ] ; __u8 PortPwrCtrlMask [ ( ( 31 ) + 1 + 7 ) / 8 ] ; } __attribute__ ( ( packed ) ) ;
enum hub_led_mode { INDICATOR_AUTO = 0 , INDICATOR_CYCLE , INDICATOR_GREEN_BLINK , INDICATOR_GREEN_BLINK_OFF , INDICATOR_AMBER_BLINK , INDICATOR_AMBER_BLINK_OFF , INDICATOR_ALT_BLINK , INDICATOR_ALT_BLINK_OFF } __attribute__ ( ( packed ) ) ;
struct usb_tt { struct usb_device * hub ; int multi ; unsigned think_time ; spinlock_t lock ; struct list_head clear_list ; struct work_struct clear_work ; } ;
struct usb_tt_clear { struct list_head clear_list ; unsigned tt ; u16 devinfo ; struct usb_hcd * hcd ; struct usb_host_endpoint * ep ; } ;

struct usb_mon_operations { void ( * urb_submit ) ( struct usb_bus * bus , struct urb * urb ) ; void ( * urb_submit_error ) ( struct usb_bus * bus , struct urb * urb , int err ) ; void ( * urb_complete ) ( struct usb_bus * bus , struct urb * urb , int status ) ; } ;

struct usb_interface * usb_ifnum_to_if ( const struct usb_device * dev , unsigned ifnum ) ;

struct usb_host_interface * usb_altnum_to_altsetting ( const struct usb_interface * intf , unsigned int altnum ) ;

struct find_interface_arg { int minor ; struct device_driver * drv ; } ;

struct usb_interface * usb_find_interface ( struct usb_driver * drv , int minor ) ;

struct usb_device * usb_alloc_dev ( struct usb_device * parent , struct usb_bus * bus , unsigned port1 ) ;

struct usb_device * usb_get_dev ( struct usb_device * dev ) ;

void usb_put_dev ( struct usb_device * dev ) ;

struct usb_interface * usb_get_intf ( struct usb_interface * intf ) ;

void usb_put_intf ( struct usb_interface * intf ) ;

int usb_lock_device_for_reset ( struct usb_device * udev , const struct usb_interface * iface ) ;

struct usb_device * usb_find_device ( u16 vendor_id , u16 product_id ) ;

int usb_get_current_frame_number ( struct usb_device * dev ) ;

int __usb_get_extra_descriptor ( char * buffer , unsigned size , unsigned char type , void * * ptr ) ;

void * usb_buffer_alloc ( struct usb_device * dev , size_t size , gfp_t mem_flags , dma_addr_t * dma ) ;

void usb_buffer_free ( struct usb_device * dev , size_t size , void * addr , dma_addr_t dma ) ;

int usb_buffer_map_sg ( const struct usb_device * dev , int is_in , struct scatterlist * sg , int nents ) ;

void usb_buffer_unmap_sg ( const struct usb_device * dev , int is_in , struct scatterlist * sg , int n_hw_ents ) ;

int usb_disabled ( void ) ;

struct usb_hub { struct device * intfdev ; struct usb_device * hdev ; struct kref kref ; struct urb * urb ; char ( * buffer ) [ 8 ] ; dma_addr_t buffer_dma ; union { struct usb_hub_status hub ; struct usb_port_status port ; } * status ; struct mutex status_mutex ; int error ; int nerrors ; struct list_head event_list ; unsigned long event_bits [ 1 ] ; unsigned long change_bits [ 1 ] ; unsigned long busy_bits [ 1 ] ; struct usb_hub_descriptor * descriptor ; struct usb_tt tt ; unsigned mA_per_port ; unsigned limited_power : 1 ; unsigned quiescing : 1 ; unsigned disconnected : 1 ; unsigned has_indicators : 1 ; u8 indicator [ ( 31 ) ] ; struct delayed_work leds ; struct delayed_work init_work ; void * * port_owners ; } ;

void usb_kick_khubd ( struct usb_device * hdev ) ;

int usb_hub_clear_tt_buffer ( struct urb * urb ) ;

enum hub_activation_type { HUB_INIT , HUB_INIT2 , HUB_INIT3 , HUB_POST_RESET , HUB_RESUME , HUB_RESET_RESUME , } ;

enum hub_quiescing_type { HUB_DISCONNECT , HUB_PRE_RESET , HUB_SUSPEND } ;

int usb_hub_claim_port ( struct usb_device * hdev , unsigned port1 , void * owner ) ;

int usb_hub_release_port ( struct usb_device * hdev , unsigned port1 , void * owner ) ;

void usb_hub_release_all_ports ( struct usb_device * hdev , void * owner ) ;

bool usb_device_is_owned ( struct usb_device * udev ) ;

void usb_set_device_state ( struct usb_device * udev , enum usb_device_state new_state ) ;

void usb_disconnect ( struct usb_device * * pdev ) ;

int usb_new_device ( struct usb_device * udev ) ;

int usb_deauthorize_device ( struct usb_device * usb_dev ) ;

int usb_authorize_device ( struct usb_device * usb_dev ) ;

int usb_port_suspend ( struct usb_device * udev , pm_message_t msg ) ;

int usb_port_resume ( struct usb_device * udev , pm_message_t msg ) ;

void usb_root_hub_lost_power ( struct usb_device * rhdev ) ;

void usb_ep0_reinit ( struct usb_device * udev ) ;

int usb_hub_init ( void ) ;

void usb_hub_cleanup ( void ) ;

int usb_reset_device ( struct usb_device * udev ) ;

void usb_queue_reset_device ( struct usb_interface * iface ) ;

struct usb_busmap { unsigned long busmap [ 64 / ( 8 * sizeof ( unsigned long ) ) ] ; } ;

void usb_hcd_poll_rh_status ( struct usb_hcd * hcd ) ;

long usb_calc_bus_time ( int speed , int is_input , int isoc , int bytecount ) ;

int usb_hcd_link_urb_to_ep ( struct usb_hcd * hcd , struct urb * urb ) ;

int usb_hcd_check_unlink_urb ( struct usb_hcd * hcd , struct urb * urb , int status ) ;

void usb_hcd_unlink_urb_from_ep ( struct usb_hcd * hcd , struct urb * urb ) ;

int usb_hcd_submit_urb ( struct urb * urb , gfp_t mem_flags ) ;

int usb_hcd_unlink_urb ( struct urb * urb , int status ) ;

void usb_hcd_giveback_urb ( struct usb_hcd * hcd , struct urb * urb , int status ) ;

void usb_hcd_flush_endpoint ( struct usb_device * udev , struct usb_host_endpoint * ep ) ;

int usb_hcd_check_bandwidth ( struct usb_device * udev , struct usb_host_config * new_config , struct usb_interface * new_intf ) ;

void usb_hcd_disable_endpoint ( struct usb_device * udev , struct usb_host_endpoint * ep ) ;

void usb_hcd_reset_endpoint ( struct usb_device * udev , struct usb_host_endpoint * ep ) ;

void usb_hcd_synchronize_unlinks ( struct usb_device * udev ) ;

int usb_hcd_get_frame_number ( struct usb_device * udev ) ;

int hcd_bus_suspend ( struct usb_device * rhdev , pm_message_t msg ) ;

int hcd_bus_resume ( struct usb_device * rhdev , pm_message_t msg ) ;

void usb_hcd_resume_root_hub ( struct usb_hcd * hcd ) ;

irqreturn_t usb_hcd_irq ( int irq , void * __hcd ) ;

void usb_hc_died ( struct usb_hcd * hcd ) ;

struct usb_hcd * usb_create_hcd ( const struct hc_driver * driver , struct device * dev , const char * bus_name ) ;

struct usb_hcd * usb_get_hcd ( struct usb_hcd * hcd ) ;

void usb_put_hcd ( struct usb_hcd * hcd ) ;

int usb_add_hcd ( struct usb_hcd * hcd , unsigned int irqnum , unsigned long irqflags ) ;

void usb_remove_hcd ( struct usb_hcd * hcd ) ;

void usb_hcd_platform_shutdown ( struct platform_device * dev ) ;

int usb_mon_register ( struct usb_mon_operations * ops ) ;

void usb_mon_deregister ( void ) ;

void usb_init_urb ( struct urb * urb ) ;

struct urb * usb_alloc_urb ( int iso_packets , gfp_t mem_flags ) ;

void usb_free_urb ( struct urb * urb ) ;

struct urb * usb_get_urb ( struct urb * urb ) ;

void usb_anchor_urb ( struct urb * urb , struct usb_anchor * anchor ) ;

void usb_unanchor_urb ( struct urb * urb ) ;

int usb_submit_urb ( struct urb * urb , gfp_t mem_flags ) ;

int usb_unlink_urb ( struct urb * urb ) ;

void usb_kill_urb ( struct urb * urb ) ;

void usb_poison_urb ( struct urb * urb ) ;

void usb_unpoison_urb ( struct urb * urb ) ;

void usb_kill_anchored_urbs ( struct usb_anchor * anchor ) ;

void usb_poison_anchored_urbs ( struct usb_anchor * anchor ) ;

void usb_unpoison_anchored_urbs ( struct usb_anchor * anchor ) ;

void usb_unlink_anchored_urbs ( struct usb_anchor * anchor ) ;

int usb_wait_anchor_empty_timeout ( struct usb_anchor * anchor , unsigned int timeout ) ;

struct urb * usb_get_from_anchor ( struct usb_anchor * anchor ) ;

void usb_scuttle_anchored_urbs ( struct usb_anchor * anchor ) ;

int usb_anchor_empty ( struct usb_anchor * anchor ) ;

struct api_context { struct completion done ; int status ; } ;

int usb_control_msg ( struct usb_device * dev , unsigned int pipe , __u8 request , __u8 requesttype , __u16 value , __u16 index , void * data , __u16 size , int timeout ) ;

int usb_interrupt_msg ( struct usb_device * usb_dev , unsigned int pipe , void * data , int len , int * actual_length , int timeout ) ;

int usb_bulk_msg ( struct usb_device * usb_dev , unsigned int pipe , void * data , int len , int * actual_length , int timeout ) ;

int usb_sg_init ( struct usb_sg_request * io , struct usb_device * dev , unsigned pipe , unsigned period , struct scatterlist * sg , int nents , size_t length , gfp_t mem_flags ) ;

void usb_sg_wait ( struct usb_sg_request * io ) ;

void usb_sg_cancel ( struct usb_sg_request * io ) ;

int usb_get_descriptor ( struct usb_device * dev , unsigned char type , unsigned char index , void * buf , int size ) ;

int usb_string ( struct usb_device * dev , int index , char * buf , size_t size ) ;

char * usb_cache_string ( struct usb_device * udev , int index ) ;

int usb_get_device_descriptor ( struct usb_device * dev , unsigned int size ) ;

int usb_get_status ( struct usb_device * dev , int type , int target , void * data ) ;

int usb_clear_halt ( struct usb_device * dev , int pipe ) ;

void usb_disable_endpoint ( struct usb_device * dev , unsigned int epaddr , bool reset_hardware ) ;

void usb_reset_endpoint ( struct usb_device * dev , unsigned int epaddr ) ;

void usb_disable_interface ( struct usb_device * dev , struct usb_interface * intf , bool reset_hardware ) ;

void usb_disable_device ( struct usb_device * dev , int skip_ep0 ) ;

void usb_enable_endpoint ( struct usb_device * dev , struct usb_host_endpoint * ep , bool reset_ep ) ;

void usb_enable_interface ( struct usb_device * dev , struct usb_interface * intf , bool reset_eps ) ;

int usb_set_interface ( struct usb_device * dev , int interface , int alternate ) ;

int usb_reset_configuration ( struct usb_device * dev ) ;

void __usb_queue_reset_device ( struct work_struct * ws ) ;

int usb_set_configuration ( struct usb_device * dev , int configuration ) ;

struct set_config_request { struct usb_device * udev ; int config ; struct work_struct work ; struct list_head node ; } ;

int usb_driver_set_configuration ( struct usb_device * udev , int config ) ;

ssize_t usb_store_new_id ( struct usb_dynids * dynids , struct device_driver * driver , const char * buf , size_t count ) ;

int usb_driver_claim_interface ( struct usb_driver * driver , struct usb_interface * iface , void * priv ) ;

void usb_driver_release_interface ( struct usb_driver * driver , struct usb_interface * iface ) ;

int usb_match_device ( struct usb_device * dev , const struct usb_device_id * id ) ;

int usb_match_one_id ( struct usb_interface * interface , const struct usb_device_id * id ) ;

const struct usb_device_id * usb_match_id ( struct usb_interface * interface , const struct usb_device_id * id ) ;

int usb_register_device_driver ( struct usb_device_driver * new_udriver , struct module * owner ) ;

void usb_deregister_device_driver ( struct usb_device_driver * udriver ) ;

int usb_register_driver ( struct usb_driver * new_driver , struct module * owner , const char * mod_name ) ;

void usb_deregister ( struct usb_driver * driver ) ;

void usb_forced_unbind_intf ( struct usb_interface * intf ) ;

void usb_rebind_intf ( struct usb_interface * intf ) ;

void usb_autosuspend_work ( struct work_struct * work ) ;

void usb_autoresume_work ( struct work_struct * work ) ;

void usb_autosuspend_device ( struct usb_device * udev ) ;

void usb_try_autosuspend_device ( struct usb_device * udev ) ;

int usb_autoresume_device ( struct usb_device * udev ) ;

void usb_autopm_put_interface ( struct usb_interface * intf ) ;

void usb_autopm_put_interface_async ( struct usb_interface * intf ) ;

int usb_autopm_get_interface ( struct usb_interface * intf ) ;

int usb_autopm_get_interface_async ( struct usb_interface * intf ) ;

int usb_autopm_set_interface ( struct usb_interface * intf ) ;

int usb_external_suspend_device ( struct usb_device * udev , pm_message_t msg ) ;

int usb_external_resume_device ( struct usb_device * udev , pm_message_t msg ) ;

int usb_suspend ( struct device * dev , pm_message_t msg ) ;

int usb_resume ( struct device * dev , pm_message_t msg ) ;

void usb_release_interface_cache ( struct kref * ref ) ;

void usb_destroy_configuration ( struct usb_device * dev ) ;

int usb_get_configuration ( struct usb_device * dev ) ;


int usb_major_init ( void ) ;

void usb_major_cleanup ( void ) ;

int usb_register_dev ( struct usb_interface * intf , struct usb_class_driver * class_driver ) ;

void usb_deregister_dev ( struct usb_interface * intf , struct usb_class_driver * class_driver ) ;

int hcd_buffer_create ( struct usb_hcd * hcd ) ;

void hcd_buffer_destroy ( struct usb_hcd * hcd ) ;

void * hcd_buffer_alloc ( struct usb_bus * bus , size_t size , gfp_t mem_flags , dma_addr_t * dma ) ;

void hcd_buffer_free ( struct usb_bus * bus , size_t size , void * addr , dma_addr_t dma ) ;

int usb_create_sysfs_dev_files ( struct usb_device * udev ) ;

void usb_remove_sysfs_dev_files ( struct usb_device * udev ) ;

int usb_create_sysfs_intf_files ( struct usb_interface * intf ) ;

void usb_remove_sysfs_intf_files ( struct usb_interface * intf ) ;

struct ep_device { struct usb_endpoint_descriptor * desc ; struct usb_device * udev ; struct device dev ; } ;
struct ep_attribute { struct attribute attr ; ssize_t ( * show ) ( struct usb_device * , struct usb_endpoint_descriptor * , char * ) ; } ;

int usb_create_ep_devs ( struct device * parent , struct usb_host_endpoint * endpoint , struct usb_device * udev ) ;

void usb_remove_ep_devs ( struct usb_host_endpoint * endpoint ) ;

struct dev_state { struct list_head list ; struct usb_device * dev ; struct file * file ; spinlock_t lock ; struct list_head async_pending ; struct list_head async_completed ; wait_queue_head_t wait ; unsigned int discsignr ; struct pid * disc_pid ; uid_t disc_uid , disc_euid ; void * disccontext ; unsigned long ifclaimed ; u32 secid ; u32 disabled_bulk_eps ; } ;

struct async { struct list_head asynclist ; struct dev_state * ps ; struct pid * pid ; uid_t uid , euid ; unsigned int signr ; unsigned int ifnum ; void * userbuffer ; void * userurb ; struct urb * urb ; int status ; u32 secid ; u8 bulk_addr ; u8 bulk_status ; } ;

enum snoop_when { SUBMIT , COMPLETE } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) usb_devio_init ( void ) ;

void usb_devio_cleanup ( void ) ;

void usb_register_notify ( struct notifier_block * nb ) ;

void usb_unregister_notify ( struct notifier_block * nb ) ;

void usb_notify_add_device ( struct usb_device * udev ) ;

void usb_notify_remove_device ( struct usb_device * udev ) ;

void usb_notify_add_bus ( struct usb_bus * ubus ) ;

void usb_notify_remove_bus ( struct usb_bus * ubus ) ;

int usb_choose_configuration ( struct usb_device * udev ) ;

void usb_detect_quirks ( struct usb_device * udev ) ;

struct usb_device_status { unsigned int lastev ; } ;

struct class_info { int class ; char * class_name ; } ;

void usbfs_conn_disc_event ( void ) ;

int usb_hcd_pci_probe ( struct pci_dev * dev , const struct pci_device_id * id ) ;

void usb_hcd_pci_remove ( struct pci_dev * dev ) ;

void usb_hcd_pci_shutdown ( struct pci_dev * dev ) ;

void uhci_reset_hc ( struct pci_dev * pdev , unsigned long base ) ;

int uhci_check_and_reset_hc ( struct pci_dev * pdev , unsigned long base ) ;

struct ehci_stats { unsigned long normal ; unsigned long error ; unsigned long reclaim ; unsigned long lost_iaa ; unsigned long complete ; unsigned long unlink ; } ;

struct ehci_hcd { struct ehci_caps * caps ; struct ehci_regs * regs ; struct ehci_dbg_port * debug ; __u32 hcs_params ; spinlock_t lock ; struct ehci_qh * async ; struct ehci_qh * reclaim ; unsigned scanning : 1 ; unsigned periodic_size ; __le32 * periodic ; dma_addr_t periodic_dma ; unsigned i_thresh ; union ehci_shadow * pshadow ; int next_uframe ; unsigned periodic_sched ; struct list_head cached_itd_list ; struct list_head cached_sitd_list ; unsigned clock_frame ; unsigned long reset_done [ 15 ] ; unsigned long bus_suspended ; unsigned long companion_ports ; unsigned long owned_ports ; unsigned long port_c_suspend ; unsigned long suspended_ports ; struct dma_pool * qh_pool ; struct dma_pool * qtd_pool ; struct dma_pool * itd_pool ; struct dma_pool * sitd_pool ; struct timer_list iaa_watchdog ; struct timer_list watchdog ; unsigned long actions ; unsigned stamp ; unsigned random_frame ; unsigned long next_statechange ; ktime_t last_periodic_enable ; u32 command ; unsigned no_selective_suspend : 1 ; unsigned has_fsl_port_bug : 1 ; unsigned big_endian_mmio : 1 ; unsigned big_endian_desc : 1 ; unsigned has_amcc_usb23 : 1 ; unsigned need_io_watchdog : 1 ; unsigned broken_periodic : 1 ; __le32 * ohci_hcctrl_reg ; unsigned has_hostpc : 1 ; u8 sbrn ; } ;

enum ehci_timer_action { TIMER_IO_WATCHDOG , TIMER_ASYNC_SHRINK , TIMER_ASYNC_OFF , } ;

struct ehci_qtd { __le32 hw_next ; __le32 hw_alt_next ; __le32 hw_token ; __le32 hw_buf [ 5 ] ; __le32 hw_buf_hi [ 5 ] ; dma_addr_t qtd_dma ; struct list_head qtd_list ; struct urb * urb ; size_t length ; } __attribute__ ( ( aligned ( 32 ) ) ) ;
union ehci_shadow { struct ehci_qh * qh ; struct ehci_itd * itd ; struct ehci_sitd * sitd ; struct ehci_fstn * fstn ; __le32 * hw_next ; void * ptr ; } ;

struct ehci_qh_hw { __le32 hw_next ; __le32 hw_info1 ; __le32 hw_info2 ; __le32 hw_current ; __le32 hw_qtd_next ; __le32 hw_alt_next ; __le32 hw_token ; __le32 hw_buf [ 5 ] ; __le32 hw_buf_hi [ 5 ] ; } __attribute__ ( ( aligned ( 32 ) ) ) ;
struct ehci_qh { struct ehci_qh_hw * hw ; dma_addr_t qh_dma ; union ehci_shadow qh_next ; struct list_head qtd_list ; struct ehci_qtd * dummy ; struct ehci_qh * reclaim ; struct ehci_hcd * ehci ; u32 refcount ; unsigned stamp ; u8 needs_rescan ; u8 qh_state ; u8 xacterrs ; u8 usecs ; u8 gap_uf ; u8 c_usecs ; u16 tt_usecs ; unsigned short period ; unsigned short start ; struct usb_device * dev ; unsigned clearing_tt : 1 ; } ;

struct ehci_iso_packet { u64 bufp ; __le32 transaction ; u8 cross ; u32 buf1 ; } ;

struct ehci_iso_sched { struct list_head td_list ; unsigned span ; struct ehci_iso_packet packet [ 0 ] ; } ;

struct ehci_iso_stream { struct ehci_qh_hw * hw ; u32 refcount ; u8 bEndpointAddress ; u8 highspeed ; u16 depth ; struct list_head td_list ; struct list_head free_list ; struct usb_device * udev ; struct usb_host_endpoint * ep ; unsigned long start ; unsigned long rescheduled ; int next_uframe ; __le32 splits ; u8 usecs , c_usecs ; u16 interval ; u16 tt_usecs ; u16 maxp ; u16 raw_mask ; unsigned bandwidth ; __le32 buf0 ; __le32 buf1 ; __le32 buf2 ; __le32 address ; } ;

struct ehci_itd { __le32 hw_next ; __le32 hw_transaction [ 8 ] ; __le32 hw_bufp [ 7 ] ; __le32 hw_bufp_hi [ 7 ] ; dma_addr_t itd_dma ; union ehci_shadow itd_next ; struct urb * urb ; struct ehci_iso_stream * stream ; struct list_head itd_list ; unsigned frame ; unsigned pg ; unsigned index [ 8 ] ; } __attribute__ ( ( aligned ( 32 ) ) ) ;
struct ehci_sitd { __le32 hw_next ; __le32 hw_fullspeed_ep ; __le32 hw_uframe ; __le32 hw_results ; __le32 hw_buf [ 2 ] ; __le32 hw_backpointer ; __le32 hw_buf_hi [ 2 ] ; dma_addr_t sitd_dma ; union ehci_shadow sitd_next ; struct urb * urb ; struct ehci_iso_stream * stream ; struct list_head sitd_list ; unsigned frame ; unsigned index ; } __attribute__ ( ( aligned ( 32 ) ) ) ;
struct ehci_fstn { __le32 hw_next ; __le32 hw_prev ; dma_addr_t fstn_dma ; union ehci_shadow fstn_next ; } __attribute__ ( ( aligned ( 32 ) ) ) ;
enum usb_otg_state { OTG_STATE_UNDEFINED = 0 , OTG_STATE_B_IDLE , OTG_STATE_B_SRP_INIT , OTG_STATE_B_PERIPHERAL , OTG_STATE_B_WAIT_ACON , OTG_STATE_B_HOST , OTG_STATE_A_IDLE , OTG_STATE_A_WAIT_VRISE , OTG_STATE_A_WAIT_BCON , OTG_STATE_A_HOST , OTG_STATE_A_SUSPEND , OTG_STATE_A_PERIPHERAL , OTG_STATE_A_WAIT_VFALL , OTG_STATE_A_VBUS_ERR , } ;

struct otg_transceiver { struct device * dev ; const char * label ; u8 default_a ; enum usb_otg_state state ; struct usb_bus * host ; struct usb_gadget * gadget ; u16 port_status ; u16 port_change ; int ( * set_host ) ( struct otg_transceiver * otg , struct usb_bus * host ) ; int ( * set_peripheral ) ( struct otg_transceiver * otg , struct usb_gadget * gadget ) ; int ( * set_power ) ( struct otg_transceiver * otg , unsigned mA ) ; int ( * set_suspend ) ( struct otg_transceiver * otg , int suspend ) ; int ( * start_srp ) ( struct otg_transceiver * otg ) ; int ( * start_hnp ) ( struct otg_transceiver * otg ) ; } ;

typedef __u32 __hc32 ;

typedef __u16 __hc16 ;

struct ed { __hc32 hwINFO ; __hc32 hwTailP ; __hc32 hwHeadP ; __hc32 hwNextED ; dma_addr_t dma ; struct td * dummy ; struct ed * ed_next ; struct ed * ed_prev ; struct list_head td_list ; u8 state ; u8 type ; u8 branch ; u16 interval ; u16 load ; u16 last_iso ; u16 tick ; } __attribute__ ( ( aligned ( 16 ) ) ) ;
struct td { __hc32 hwINFO ; __hc32 hwCBP ; __hc32 hwNextTD ; __hc32 hwBE ; __hc16 hwPSW [ 2 ] ; __u8 index ; struct ed * ed ; struct td * td_hash ; struct td * next_dl_td ; struct urb * urb ; dma_addr_t td_dma ; dma_addr_t data_dma ; struct list_head td_list ; } __attribute__ ( ( aligned ( 32 ) ) ) ;
struct ohci_hcca { __hc32 int_table [ 32 ] ; __hc32 frame_no ; __hc32 done_head ; u8 reserved_for_hc [ 116 ] ; u8 what [ 4 ] ; } __attribute__ ( ( aligned ( 256 ) ) ) ;
struct ohci_regs { __hc32 revision ; __hc32 control ; __hc32 cmdstatus ; __hc32 intrstatus ; __hc32 intrenable ; __hc32 intrdisable ; __hc32 hcca ; __hc32 ed_periodcurrent ; __hc32 ed_controlhead ; __hc32 ed_controlcurrent ; __hc32 ed_bulkhead ; __hc32 ed_bulkcurrent ; __hc32 donehead ; __hc32 fminterval ; __hc32 fmremaining ; __hc32 fmnumber ; __hc32 periodicstart ; __hc32 lsthresh ; struct ohci_roothub_regs { __hc32 a ; __hc32 b ; __hc32 status ; __hc32 portstatus [ 15 ] ; } roothub ; } __attribute__ ( ( aligned ( 32 ) ) ) ;

typedef struct urb_priv { struct ed * ed ; u16 length ; u16 td_cnt ; struct list_head pending ; struct td * td [ 0 ] ; } urb_priv_t ;

struct ohci_hcd { spinlock_t lock ; struct ohci_regs * regs ; struct ohci_hcca * hcca ; dma_addr_t hcca_dma ; struct ed * ed_rm_list ; struct ed * ed_bulktail ; struct ed * ed_controltail ; struct ed * periodic [ 32 ] ; struct otg_transceiver * transceiver ; void ( * start_hnp ) ( struct ohci_hcd * ohci ) ; struct dma_pool * td_cache ; struct dma_pool * ed_cache ; struct td * td_hash [ 64 ] ; struct list_head pending ; int num_ports ; int load [ 32 ] ; u32 hc_control ; unsigned long next_statechange ; u32 fminterval ; unsigned autostop : 1 ; unsigned long flags ; struct work_struct nec_work ; struct timer_list unlink_watchdog ; unsigned eds_scheduled ; struct ed * ed_to_check ; unsigned zf_delay ; } ;

struct uhci_qh { __le32 link ; __le32 element ; dma_addr_t dma_handle ; struct list_head node ; struct usb_host_endpoint * hep ; struct usb_device * udev ; struct list_head queue ; struct uhci_td * dummy_td ; struct uhci_td * post_td ; struct usb_iso_packet_descriptor * iso_packet_desc ; unsigned long advance_jiffies ; unsigned int unlink_frame ; unsigned int period ; short phase ; short load ; unsigned int iso_frame ; int state ; int type ; int skel ; unsigned int initial_toggle : 1 ; unsigned int needs_fixup : 1 ; unsigned int is_stopped : 1 ; unsigned int wait_expired : 1 ; unsigned int bandwidth_reserved : 1 ; } __attribute__ ( ( aligned ( 16 ) ) ) ;
struct uhci_td { __le32 link ; __le32 status ; __le32 token ; __le32 buffer ; dma_addr_t dma_handle ; struct list_head list ; int frame ; struct list_head fl_list ; } __attribute__ ( ( aligned ( 16 ) ) ) ;
enum uhci_rh_state { UHCI_RH_RESET , UHCI_RH_SUSPENDED , UHCI_RH_AUTO_STOPPED , UHCI_RH_RESUMING , UHCI_RH_SUSPENDING , UHCI_RH_RUNNING , UHCI_RH_RUNNING_NODEVS , } ;

struct uhci_hcd { struct dentry * dentry ; unsigned long io_addr ; struct dma_pool * qh_pool ; struct dma_pool * td_pool ; struct uhci_td * term_td ; struct uhci_qh * skelqh [ 11 ] ; struct uhci_qh * next_qh ; spinlock_t lock ; dma_addr_t frame_dma_handle ; __le32 * frame ; void * * frame_cpu ; enum uhci_rh_state rh_state ; unsigned long auto_stop_time ; unsigned int frame_number ; unsigned int is_stopped ; unsigned int last_iso_frame ; unsigned int cur_iso_frame ; unsigned int scan_in_progress : 1 ; unsigned int need_rescan : 1 ; unsigned int dead : 1 ; unsigned int RD_enable : 1 ; unsigned int is_initialized : 1 ; unsigned int fsbr_is_on : 1 ; unsigned int fsbr_is_wanted : 1 ; unsigned int fsbr_expiring : 1 ; struct timer_list fsbr_timer ; unsigned long port_c_suspend ; unsigned long resuming_ports ; unsigned long ports_timeout ; struct list_head idle_qh_list ; int rh_numports ; wait_queue_head_t waitqh ; int num_waiting ; int total_load ; short load [ 32 ] ; } ;

struct urb_priv { struct list_head node ; struct urb * urb ; struct uhci_qh * qh ; struct list_head td_list ; unsigned fsbr : 1 ; } ;
struct SiS_St { unsigned char St_ModeID ; unsigned short St_ModeFlag ; unsigned char St_StTableIndex ; unsigned char St_CRT2CRTC ; unsigned char St_ResInfo ; unsigned char VB_StTVFlickerIndex ; unsigned char VB_StTVEdgeIndex ; unsigned char VB_StTVYFilterIndex ; unsigned char St_PDC ; } ;

struct SiS_StandTable { unsigned char CRT_COLS ; unsigned char ROWS ; unsigned char CHAR_HEIGHT ; unsigned short CRT_LEN ; unsigned char SR [ 4 ] ; unsigned char MISC ; unsigned char CRTC [ 0x19 ] ; unsigned char ATTR [ 0x14 ] ; unsigned char GRC [ 9 ] ; } ;

struct SiS_StResInfo_S { unsigned short HTotal ; unsigned short VTotal ; } ;

struct SiS_Ext { unsigned char Ext_ModeID ; unsigned short Ext_ModeFlag ; unsigned short Ext_VESAID ; unsigned char Ext_RESINFO ; unsigned char VB_ExtTVFlickerIndex ; unsigned char VB_ExtTVEdgeIndex ; unsigned char VB_ExtTVYFilterIndex ; unsigned char VB_ExtTVYFilterIndexROM661 ; unsigned char REFindex ; char ROMMODEIDX661 ; } ;

struct SiS_Ext2 { unsigned short Ext_InfoFlag ; unsigned char Ext_CRT1CRTC ; unsigned char Ext_CRTVCLK ; unsigned char Ext_CRT2CRTC ; unsigned char Ext_CRT2CRTC_NS ; unsigned char ModeID ; unsigned short XRes ; unsigned short YRes ; unsigned char Ext_PDC ; unsigned char Ext_FakeCRT2CRTC ; unsigned char Ext_FakeCRT2Clk ; } ;

struct SiS_CRT1Table { unsigned char CR [ 17 ] ; } ;

struct SiS_VCLKData { unsigned char SR2B , SR2C ; unsigned short CLOCK ; } ;

struct SiS_ModeResInfo { unsigned short HTotal ; unsigned short VTotal ; unsigned char XChar ; unsigned char YChar ; } ;

struct SiS_Private { void * sisusb ; unsigned long IOAddress ; unsigned long SiS_P3c4 ; unsigned long SiS_P3d4 ; unsigned long SiS_P3c0 ; unsigned long SiS_P3ce ; unsigned long SiS_P3c2 ; unsigned long SiS_P3ca ; unsigned long SiS_P3c6 ; unsigned long SiS_P3c7 ; unsigned long SiS_P3c8 ; unsigned long SiS_P3c9 ; unsigned long SiS_P3cb ; unsigned long SiS_P3cc ; unsigned long SiS_P3cd ; unsigned long SiS_P3da ; unsigned long SiS_Part1Port ; unsigned char SiS_MyCR63 ; unsigned short SiS_CRT1Mode ; unsigned short SiS_ModeType ; unsigned short SiS_SetFlag ; const struct SiS_StandTable * SiS_StandTable ; const struct SiS_St * SiS_SModeIDTable ; const struct SiS_Ext * SiS_EModeIDTable ; const struct SiS_Ext2 * SiS_RefIndex ; const struct SiS_CRT1Table * SiS_CRT1Table ; const struct SiS_VCLKData * SiS_VCLKData ; const struct SiS_ModeResInfo * SiS_ModeResInfo ; } ;

struct sisusb_usb_data ;

struct sisusb_urb_context { struct sisusb_usb_data * sisusb ; int urbindex ; int * actual_length ; } ;

struct sisusb_usb_data { struct usb_device * sisusb_dev ; struct usb_interface * interface ; struct kref kref ; wait_queue_head_t wait_q ; struct mutex lock ; unsigned int ifnum ; int minor ; int isopen ; int present ; int ready ; int numobufs ; char * obuf [ 8 ] , * ibuf ; int obufsize , ibufsize ; struct urb * sisurbout [ 8 ] ; struct urb * sisurbin ; unsigned char urbstatus [ 8 ] ; unsigned char completein ; struct sisusb_urb_context urbout_context [ 8 ] ; unsigned long flagb0 ; unsigned long vrambase ; unsigned int vramsize ; unsigned long mmiobase ; unsigned int mmiosize ; unsigned long ioportbase ; unsigned char devinit ; unsigned char gfxinit ; unsigned short chipid , chipvendor ; unsigned short chiprevision ; } ;
struct sisusb_packet { unsigned short header ; u32 address ; u32 data ; } __attribute__ ( ( __packed__ ) ) ;
struct sisusb_info { __u32 sisusb_id ; __u8 sisusb_version ; __u8 sisusb_revision ; __u8 sisusb_patchlevel ; __u8 sisusb_gfxinit ; __u32 sisusb_vrambase ; __u32 sisusb_mmiobase ; __u32 sisusb_iobase ; __u32 sisusb_pcibase ; __u32 sisusb_vramsize ; __u32 sisusb_minor ; __u32 sisusb_fbdevactive ; __u32 sisusb_conactive ; __u8 sisusb_reserved [ 28 ] ; } ;

struct sisusb_command { __u8 operation ; __u8 data0 ; __u8 data1 ; __u8 data2 ; __u32 data3 ; __u32 data4 ; } ;

int sisusb_setidxreg ( struct sisusb_usb_data * sisusb , int port , u8 index , u8 data ) ;

int sisusb_getidxreg ( struct sisusb_usb_data * sisusb , int port , u8 index , u8 * data ) ;

int sisusb_setidxregandor ( struct sisusb_usb_data * sisusb , int port , u8 idx , u8 myand , u8 myor ) ;

int sisusb_setidxregor ( struct sisusb_usb_data * sisusb , int port , u8 index , u8 myor ) ;

int sisusb_setidxregand ( struct sisusb_usb_data * sisusb , int port , u8 idx , u8 myand ) ;

void sisusb_delete ( struct kref * kref ) ;

struct mon_bus { struct list_head bus_link ; spinlock_t lock ; struct usb_bus * u_bus ; int text_inited ; int bin_inited ; struct dentry * dent_s ; struct dentry * dent_t ; struct dentry * dent_u ; struct device * classdev ; int nreaders ; struct list_head r_list ; struct kref ref ; unsigned int cnt_events ; unsigned int cnt_text_lost ; } ;

struct mon_reader { struct list_head r_link ; struct mon_bus * m_bus ; void * r_data ; void ( * rnf_submit ) ( void * data , struct urb * urb ) ; void ( * rnf_error ) ( void * data , struct urb * urb , int error ) ; void ( * rnf_complete ) ( void * data , struct urb * urb , int status ) ; } ;

void mon_reader_add ( struct mon_bus * mbus , struct mon_reader * r ) ;

void mon_reader_del ( struct mon_bus * mbus , struct mon_reader * r ) ;

struct mon_bus * mon_bus_lookup ( unsigned int num ) ;

struct snap { int slen ; char str [ 80 ] ; } ;

struct mon_iso_desc { int status ; unsigned int offset ; unsigned int length ; } ;

struct mon_event_text { struct list_head e_link ; int type ; unsigned long id ; unsigned int tstamp ; int busnum ; char devnum ; char epnum ; char is_in ; char xfertype ; int length ; int status ; int interval ; int start_frame ; int error_count ; char setup_flag ; char data_flag ; int numdesc ; struct mon_iso_desc isodesc [ 5 ] ; unsigned char setup [ 8 ] ; unsigned char data [ 32 ] ; } ;

struct mon_reader_text { struct kmem_cache * e_slab ; int nevents ; struct list_head e_list ; struct mon_reader r ; wait_queue_head_t wait ; int printf_size ; char * printf_buf ; struct mutex printf_lock ; char slab_name [ 30 ] ; } ;

struct mon_text_ptr { int cnt , limit ; char * pbuf ; } ;

int mon_text_add ( struct mon_bus * mbus , const struct usb_bus * ubus ) ;

void mon_text_del ( struct mon_bus * mbus ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mon_text_init ( void ) ;

void mon_text_exit ( void ) ;

struct mon_bin_hdr { u64 id ; unsigned char type ; unsigned char xfer_type ; unsigned char epnum ; unsigned char devnum ; unsigned short busnum ; char flag_setup ; char flag_data ; s64 ts_sec ; s32 ts_usec ; int status ; unsigned int len_urb ; unsigned int len_cap ; union { unsigned char setup [ 8 ] ; struct iso_rec { int error_count ; int numdesc ; } iso ; } s ; int interval ; int start_frame ; unsigned int xfer_flags ; unsigned int ndesc ; } ;

struct mon_bin_isodesc { int iso_status ; unsigned int iso_off ; unsigned int iso_len ; u32 _pad ; } ;

struct mon_bin_stats { u32 queued ; u32 dropped ; } ;

struct mon_bin_get { struct mon_bin_hdr * hdr ; void * data ; size_t alloc ; } ;

struct mon_bin_mfetch { u32 * offvec ; u32 nfetch ; u32 nflush ; } ;

struct mon_bin_get32 { u32 hdr32 ; u32 data32 ; u32 alloc32 ; } ;

struct mon_bin_mfetch32 { u32 offvec32 ; u32 nfetch32 ; u32 nflush32 ; } ;

struct mon_pgmap { struct page * pg ; unsigned char * ptr ; } ;

struct mon_reader_bin { spinlock_t b_lock ; unsigned int b_size ; unsigned int b_cnt ; unsigned int b_in , b_out ; unsigned int b_read ; struct mon_pgmap * b_vec ; wait_queue_head_t b_wait ; struct mutex fetch_lock ; int mmap_active ; struct mon_reader r ; unsigned int cnt_lost ; } ;

int mon_bin_add ( struct mon_bus * mbus , const struct usb_bus * ubus ) ;

void mon_bin_del ( struct mon_bus * mbus ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) mon_bin_init ( void ) ;

void mon_bin_exit ( void ) ;

struct usb_ep ;

struct usb_request { void * buf ; unsigned length ; dma_addr_t dma ; unsigned no_interrupt : 1 ; unsigned zero : 1 ; unsigned short_not_ok : 1 ; void ( * complete ) ( struct usb_ep * ep , struct usb_request * req ) ; void * context ; struct list_head list ; int status ; unsigned actual ; } ;

struct usb_ep_ops { int ( * enable ) ( struct usb_ep * ep , const struct usb_endpoint_descriptor * desc ) ; int ( * disable ) ( struct usb_ep * ep ) ; struct usb_request * ( * alloc_request ) ( struct usb_ep * ep , gfp_t gfp_flags ) ; void ( * free_request ) ( struct usb_ep * ep , struct usb_request * req ) ; int ( * queue ) ( struct usb_ep * ep , struct usb_request * req , gfp_t gfp_flags ) ; int ( * dequeue ) ( struct usb_ep * ep , struct usb_request * req ) ; int ( * set_halt ) ( struct usb_ep * ep , int value ) ; int ( * set_wedge ) ( struct usb_ep * ep ) ; int ( * fifo_status ) ( struct usb_ep * ep ) ; void ( * fifo_flush ) ( struct usb_ep * ep ) ; } ;

struct usb_ep { void * driver_data ; const char * name ; const struct usb_ep_ops * ops ; struct list_head ep_list ; unsigned maxpacket : 16 ; } ;
struct usb_gadget ;

struct usb_gadget_ops { int ( * get_frame ) ( struct usb_gadget * ) ; int ( * wakeup ) ( struct usb_gadget * ) ; int ( * set_selfpowered ) ( struct usb_gadget * , int is_selfpowered ) ; int ( * vbus_session ) ( struct usb_gadget * , int is_active ) ; int ( * vbus_draw ) ( struct usb_gadget * , unsigned mA ) ; int ( * pullup ) ( struct usb_gadget * , int is_on ) ; int ( * ioctl ) ( struct usb_gadget * , unsigned code , unsigned long param ) ; } ;

struct usb_gadget { const struct usb_gadget_ops * ops ; struct usb_ep * ep0 ; struct list_head ep_list ; enum usb_device_speed speed ; unsigned is_dualspeed : 1 ; unsigned is_otg : 1 ; unsigned is_a_peripheral : 1 ; unsigned b_hnp_enable : 1 ; unsigned a_hnp_support : 1 ; unsigned a_alt_hnp_support : 1 ; const char * name ; struct device dev ; } ;
struct usb_gadget_driver { char * function ; enum usb_device_speed speed ; int ( * bind ) ( struct usb_gadget * ) ; void ( * unbind ) ( struct usb_gadget * ) ; int ( * setup ) ( struct usb_gadget * , const struct usb_ctrlrequest * ) ; void ( * disconnect ) ( struct usb_gadget * ) ; void ( * suspend ) ( struct usb_gadget * ) ; void ( * resume ) ( struct usb_gadget * ) ; struct device_driver driver ; } ;

struct usb_string { u8 id ; const char * s ; } ;
struct usb_gadget_strings { u16 language ; struct usb_string * strings ; } ;

struct dummy_ep { struct list_head queue ; unsigned long last_io ; struct usb_gadget * gadget ; const struct usb_endpoint_descriptor * desc ; struct usb_ep ep ; unsigned halted : 1 ; unsigned wedged : 1 ; unsigned already_seen : 1 ; unsigned setup_stage : 1 ; } ;

struct dummy_request { struct list_head queue ; struct usb_request req ; } ;

struct urbp { struct urb * urb ; struct list_head urbp_list ; } ;

enum dummy_rh_state { DUMMY_RH_RESET , DUMMY_RH_SUSPENDED , DUMMY_RH_RUNNING } ;

struct dummy { spinlock_t lock ; struct dummy_ep ep [ ( sizeof ( ep_name ) / sizeof ( ( ep_name ) [ 0 ] ) + ( sizeof ( struct { int : - ! ! ( __builtin_types_compatible_p ( typeof ( ep_name ) , typeof ( & ep_name [ 0 ] ) ) ) ; } ) ) ) ] ; int address ; struct usb_gadget gadget ; struct usb_gadget_driver * driver ; struct dummy_request fifo_req ; u8 fifo_buf [ 64 ] ; u16 devstatus ; unsigned udc_suspended : 1 ; unsigned pullup : 1 ; unsigned active : 1 ; unsigned old_active : 1 ; enum dummy_rh_state rh_state ; struct timer_list timer ; u32 port_status ; u32 old_status ; unsigned resuming : 1 ; unsigned long re_timeout ; struct usb_device * udev ; struct list_head urbp_list ; } ;

int usb_gadget_register_driver ( struct usb_gadget_driver * driver ) ;

int usb_gadget_unregister_driver ( struct usb_gadget_driver * driver ) ;

int net2280_set_fifo_mode ( struct usb_gadget * gadget , int mode ) ;

int fb_register_client ( struct notifier_block * nb ) ;

int fb_unregister_client ( struct notifier_block * nb ) ;

int fb_notifier_call_chain ( unsigned long val , void * v ) ;

struct linux_logo { int type ; unsigned int width ; unsigned int height ; unsigned int clutsize ; const unsigned char * clut ; const unsigned char * data ; } ;

int lock_fb_info ( struct fb_info * info ) ;

int fb_get_color_depth ( struct fb_var_screeninfo * var , struct fb_fix_screeninfo * fix ) ;

void fb_pad_aligned_buffer ( u8 * dst , u32 d_pitch , u8 * src , u32 s_pitch , u32 height ) ;

void fb_pad_unaligned_buffer ( u8 * dst , u32 d_pitch , u8 * src , u32 idx , u32 height , u32 shift_high , u32 shift_low , u32 mod ) ;

char * fb_get_buffer_offset ( struct fb_info * info , struct fb_pixmap * buf , u32 size ) ;

int fb_prepare_logo ( struct fb_info * info , int rotate ) ;

int fb_show_logo ( struct fb_info * info , int rotate ) ;

int fb_pan_display ( struct fb_info * info , struct fb_var_screeninfo * var ) ;

int fb_set_var ( struct fb_info * info , struct fb_var_screeninfo * var ) ;

int fb_blank ( struct fb_info * info , int blank ) ;

struct fb_fix_screeninfo32 { char id [ 16 ] ; compat_caddr_t smem_start ; u32 smem_len ; u32 type ; u32 type_aux ; u32 visual ; u16 xpanstep ; u16 ypanstep ; u16 ywrapstep ; u32 line_length ; compat_caddr_t mmio_start ; u32 mmio_len ; u32 accel ; u16 reserved [ 3 ] ; } ;

struct fb_cmap32 { u32 start ; u32 len ; compat_caddr_t red ; compat_caddr_t green ; compat_caddr_t blue ; compat_caddr_t transp ; } ;

int register_framebuffer ( struct fb_info * fb_info ) ;

int unregister_framebuffer ( struct fb_info * fb_info ) ;

void fb_set_suspend ( struct fb_info * info , int state ) ;

int fb_new_modelist ( struct fb_info * info ) ;

int fb_get_options ( char * name , char * * option ) ;

struct broken_edid { u8 manufacturer [ 4 ] ; u32 model ; u32 fix ; } ;

void fb_destroy_modedb ( struct fb_videomode * modedb ) ;

int fb_parse_edid ( unsigned char * edid , struct fb_var_screeninfo * var ) ;

void fb_edid_to_monspecs ( unsigned char * edid , struct fb_monspecs * specs ) ;

struct __fb_timings { u32 dclk ; u32 hfreq ; u32 vfreq ; u32 hactive ; u32 vactive ; u32 hblank ; u32 vblank ; u32 htotal ; u32 vtotal ; } ;

int fb_get_mode ( int flags , u32 val , struct fb_var_screeninfo * var , struct fb_info * info ) ;

int fb_validate_mode ( const struct fb_var_screeninfo * var , struct fb_info * info ) ;

const unsigned char * fb_firmware_edid ( struct device * device ) ;

int fb_alloc_cmap ( struct fb_cmap * cmap , int len , int transp ) ;

void fb_dealloc_cmap ( struct fb_cmap * cmap ) ;

int fb_copy_cmap ( const struct fb_cmap * from , struct fb_cmap * to ) ;

int fb_cmap_to_user ( const struct fb_cmap * from , struct fb_cmap_user * to ) ;

int fb_set_cmap ( struct fb_cmap * cmap , struct fb_info * info ) ;

int fb_set_user_cmap ( struct fb_cmap_user * cmap , struct fb_info * info ) ;

const struct fb_cmap * fb_default_cmap ( int len ) ;

void fb_invert_cmaps ( void ) ;

struct fb_info * framebuffer_alloc ( size_t size , struct device * dev ) ;

void framebuffer_release ( struct fb_info * info ) ;

int fb_init_device ( struct fb_info * fb_info ) ;

void fb_cleanup_device ( struct fb_info * fb_info ) ;

void fb_bl_default_curve ( struct fb_info * fb_info , u8 off , u8 min , u8 max ) ;

int fb_find_mode ( struct fb_var_screeninfo * var , struct fb_info * info , const char * mode_option , const struct fb_videomode * db , unsigned int dbsize , const struct fb_videomode * default_mode , unsigned int default_bpp ) ;

void fb_var_to_videomode ( struct fb_videomode * mode , const struct fb_var_screeninfo * var ) ;

void fb_videomode_to_var ( struct fb_var_screeninfo * var , const struct fb_videomode * mode ) ;

int fb_mode_is_equal ( const struct fb_videomode * mode1 , const struct fb_videomode * mode2 ) ;

const struct fb_videomode * fb_find_best_mode ( const struct fb_var_screeninfo * var , struct list_head * head ) ;

const struct fb_videomode * fb_find_nearest_mode ( const struct fb_videomode * mode , struct list_head * head ) ;

const struct fb_videomode * fb_match_mode ( const struct fb_var_screeninfo * var , struct list_head * head ) ;

int fb_add_videomode ( const struct fb_videomode * mode , struct list_head * head ) ;

void fb_delete_videomode ( const struct fb_videomode * mode , struct list_head * head ) ;

void fb_destroy_modelist ( struct list_head * head ) ;

void fb_videomode_to_modelist ( const struct fb_videomode * modedb , int num , struct list_head * head ) ;

const struct fb_videomode * fb_find_best_display ( const struct fb_monspecs * specs , struct list_head * head ) ;

struct fb_cvt_data { u32 xres ; u32 yres ; u32 refresh ; u32 f_refresh ; u32 pixclock ; u32 hperiod ; u32 hblank ; u32 hfreq ; u32 htotal ; u32 vtotal ; u32 vsync ; u32 hsync ; u32 h_front_porch ; u32 h_back_porch ; u32 v_front_porch ; u32 v_back_porch ; u32 h_margin ; u32 v_margin ; u32 interlace ; u32 aspect_ratio ; u32 active_pixels ; u32 flags ; u32 status ; } ;

int fb_find_mode_cvt ( struct fb_videomode * mode , int margins , int rb ) ;

void backlight_force_update ( struct backlight_device * bd , enum backlight_update_reason reason ) ;

struct backlight_device * backlight_device_register ( const char * name , struct device * parent , void * devdata , struct backlight_ops * ops ) ;

void backlight_device_unregister ( struct backlight_device * bd ) ;

struct vgastate { void * vgabase ; unsigned long membase ; __u32 memsize ; __u32 flags ; __u32 depth ; __u32 num_attr ; __u32 num_crtc ; __u32 num_gfx ; __u32 num_seq ; void * vidstate ; } ;

bool vgacon_text_force ( void ) ;

struct display { const u_char * fontdata ; int userfont ; u_short scrollmode ; u_short inverse ; short yscroll ; int vrows ; int cursor_shape ; int con_rotate ; u32 xres_virtual ; u32 yres_virtual ; u32 height ; u32 width ; u32 bits_per_pixel ; u32 grayscale ; u32 nonstd ; u32 accel_flags ; u32 rotate ; struct fb_bitfield red ; struct fb_bitfield green ; struct fb_bitfield blue ; struct fb_bitfield transp ; const struct fb_videomode * mode ; } ;

struct fbcon_ops { void ( * bmove ) ( struct vc_data * vc , struct fb_info * info , int sy , int sx , int dy , int dx , int height , int width ) ; void ( * clear ) ( struct vc_data * vc , struct fb_info * info , int sy , int sx , int height , int width ) ; void ( * putcs ) ( struct vc_data * vc , struct fb_info * info , const unsigned short * s , int count , int yy , int xx , int fg , int bg ) ; void ( * clear_margins ) ( struct vc_data * vc , struct fb_info * info , int bottom_only ) ; void ( * cursor ) ( struct vc_data * vc , struct fb_info * info , int mode , int softback_lines , int fg , int bg ) ; int ( * update_start ) ( struct fb_info * info ) ; int ( * rotate_font ) ( struct fb_info * info , struct vc_data * vc ) ; struct fb_var_screeninfo var ; struct timer_list cursor_timer ; struct fb_cursor cursor_state ; struct display * p ; int currcon ; int cursor_flash ; int cursor_reset ; int blank_state ; int graphics ; int flags ; int rotate ; int cur_rotate ; char * cursor_data ; u8 * fontbuffer ; u8 * fontdata ; u8 * cursor_src ; u32 cursor_size ; u32 fd_size ; } ;

enum { FBCON_LOGO_CANSHOW = - 1 , FBCON_LOGO_DRAW = - 2 , FBCON_LOGO_DONTSHOW = - 3 } ;
void fbcon_set_bitops ( struct fbcon_ops * ops ) ;

const struct font_desc * find_font ( const char * name ) ;

const struct font_desc * get_default_font ( int xres , int yres , u32 font_w , u32 font_h ) ;

int soft_cursor ( struct fb_info * info , struct fb_cursor * cursor ) ;

void fbcon_set_tileops ( struct vc_data * vc , struct fb_info * info ) ;

typedef struct { int bitsPerPixel ; int depth ; int displayWidth ; int weight ; } NVFBLayout ;

struct nvidia_par ;

struct nvidia_i2c_chan { struct nvidia_par * par ; unsigned long ddc_base ; struct i2c_adapter adapter ; struct i2c_algo_bit_data algo ; } ;


typedef struct _riva_hw_state { u8 attr [ 0x15 ] ; u8 crtc [ 0x41 ] ; u8 gra [ 0x09 ] ; u8 seq [ 0x05 ] ; u8 misc_output ; u32 bpp ; u32 width ; u32 height ; u32 interlace ; u32 repaint0 ; u32 repaint1 ; u32 screen ; u32 scale ; u32 dither ; u32 extra ; u32 fifo ; u32 pixel ; u32 horiz ; u32 arbitration0 ; u32 arbitration1 ; u32 pll ; u32 pllB ; u32 vpll ; u32 vpll2 ; u32 vpllB ; u32 vpll2B ; u32 pllsel ; u32 general ; u32 crtcOwner ; u32 head ; u32 head2 ; u32 config ; u32 cursorConfig ; u32 cursor0 ; u32 cursor1 ; u32 cursor2 ; u32 timingH ; u32 timingV ; u32 displayV ; u32 crtcSync ; u32 control ; } RIVA_HW_STATE ;

struct riva_regs { RIVA_HW_STATE ext ; } ;

struct nvidia_par { RIVA_HW_STATE SavedReg ; RIVA_HW_STATE ModeReg ; RIVA_HW_STATE initial_state ; RIVA_HW_STATE * CurrentState ; struct vgastate vgastate ; u32 pseudo_palette [ 16 ] ; struct pci_dev * pci_dev ; u32 Architecture ; u32 CursorStart ; int Chipset ; unsigned long FbAddress ; u8 * FbStart ; u32 FbMapSize ; u32 FbUsableSize ; u32 ScratchBufferSize ; u32 ScratchBufferStart ; int FpScale ; u32 MinVClockFreqKHz ; u32 MaxVClockFreqKHz ; u32 CrystalFreqKHz ; u32 RamAmountKBytes ; u32 IOBase ; NVFBLayout CurrentLayout ; int cursor_reset ; int lockup ; int videoKey ; int FlatPanel ; int FPDither ; int Television ; int CRTCnumber ; int alphaCursor ; int twoHeads ; int twoStagePLL ; int fpScaler ; int fpWidth ; int fpHeight ; int PanelTweak ; int paneltweak ; int LVDS ; int pm_state ; int reverse_i2c ; u32 crtcSync_read ; u32 fpSyncs ; u32 dmaPut ; u32 dmaCurrent ; u32 dmaFree ; u32 dmaMax ; u32 * dmaBase ; u32 currentRop ; int WaitVSyncPossible ; int BlendingPossible ; u32 paletteEnabled ; u32 forceCRTC ; u32 open_count ; u8 DDCBase ; struct { int vram ; int vram_valid ; } mtrr ; struct nvidia_i2c_chan chan [ 3 ] ; volatile u32 * REGS ; volatile u32 * PCRTC0 ; volatile u32 * PCRTC ; volatile u32 * PRAMDAC0 ; volatile u32 * PFB ; volatile u32 * PFIFO ; volatile u32 * PGRAPH ; volatile u32 * PEXTDEV ; volatile u32 * PTIMER ; volatile u32 * PMC ; volatile u32 * PRAMIN ; volatile u32 * FIFO ; volatile u32 * CURSOR ; volatile u8 * PCIO0 ; volatile u8 * PCIO ; volatile u8 * PVIO ; volatile u8 * PDIO0 ; volatile u8 * PDIO ; volatile u32 * PRAMDAC ; } ;
void NVLockUnlock ( struct nvidia_par * par , int Lock ) ;

int NVShowHideCursor ( struct nvidia_par * par , int ShowHide ) ;

typedef struct { int graphics_lwm ; int video_lwm ; int graphics_burst_size ; int video_burst_size ; int valid ; } nv4_fifo_info ;

typedef struct { int pclk_khz ; int mclk_khz ; int nvclk_khz ; char mem_page_miss ; char mem_latency ; int memory_width ; char enable_video ; char gr_during_vid ; char pix_bpp ; char mem_aligned ; char enable_mp ; } nv4_sim_state ;

typedef struct { int graphics_lwm ; int video_lwm ; int graphics_burst_size ; int video_burst_size ; int valid ; } nv10_fifo_info ;

typedef struct { int pclk_khz ; int mclk_khz ; int nvclk_khz ; char mem_page_miss ; char mem_latency ; u32 memory_type ; int memory_width ; char enable_video ; char gr_during_vid ; char pix_bpp ; char mem_aligned ; char enable_mp ; } nv10_sim_state ;

void NVCalcStateExt ( struct nvidia_par * par , RIVA_HW_STATE * state , int bpp , int width , int hDisplaySize , int height , int dotClock , int flags ) ;

void NVLoadStateExt ( struct nvidia_par * par , RIVA_HW_STATE * state ) ;

void NVUnloadStateExt ( struct nvidia_par * par , RIVA_HW_STATE * state ) ;

void NVSetStartAddress ( struct nvidia_par * par , u32 start ) ;

void NVWriteCrtc ( struct nvidia_par * par , u8 index , u8 value ) ;

u8 NVReadCrtc ( struct nvidia_par * par , u8 index ) ;

void NVWriteGr ( struct nvidia_par * par , u8 index , u8 value ) ;

u8 NVReadGr ( struct nvidia_par * par , u8 index ) ;

void NVWriteSeq ( struct nvidia_par * par , u8 index , u8 value ) ;

u8 NVReadSeq ( struct nvidia_par * par , u8 index ) ;

void NVWriteAttr ( struct nvidia_par * par , u8 index , u8 value ) ;

u8 NVReadAttr ( struct nvidia_par * par , u8 index ) ;

void NVWriteMiscOut ( struct nvidia_par * par , u8 value ) ;

u8 NVReadMiscOut ( struct nvidia_par * par ) ;

void NVWriteDacMask ( struct nvidia_par * par , u8 value ) ;

void NVWriteDacReadAddr ( struct nvidia_par * par , u8 value ) ;

void NVWriteDacWriteAddr ( struct nvidia_par * par , u8 value ) ;

void NVWriteDacData ( struct nvidia_par * par , u8 value ) ;

u8 NVReadDacData ( struct nvidia_par * par ) ;

int NVCommonSetup ( struct fb_info * info ) ;

void NVResetGraphics ( struct fb_info * info ) ;

int nvidiafb_sync ( struct fb_info * info ) ;

void nvidiafb_copyarea ( struct fb_info * info , const struct fb_copyarea * region ) ;

void nvidiafb_fillrect ( struct fb_info * info , const struct fb_fillrect * rect ) ;

void nvidiafb_imageblit ( struct fb_info * info , const struct fb_image * image ) ;

void nvidia_create_i2c_busses ( struct nvidia_par * par ) ;

void nvidia_delete_i2c_busses ( struct nvidia_par * par ) ;

int nvidia_probe_i2c_connector ( struct fb_info * info , int conn , u8 * * out_edid ) ;

void nvidia_bl_init ( struct nvidia_par * par ) ;

void nvidia_bl_exit ( struct nvidia_par * par ) ;

typedef int Bool ;

typedef unsigned char U008 ;

typedef unsigned short U016 ;

typedef unsigned int U032 ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop ; U032 reserved01 [ 0x0BB ] ; U032 Rop3 ; } RivaRop ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop ; U032 reserved01 [ 0x0BD ] ; U032 Shape ; U032 reserved03 [ 0x001 ] ; U032 Color0 ; U032 Color1 ; U032 Monochrome [ 2 ] ; } RivaPattern ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop ; U032 reserved01 [ 0x0BB ] ; U032 TopLeft ; U032 WidthHeight ; } RivaClip ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop [ 1 ] ; U032 reserved01 [ 0x0BC ] ; U032 Color ; U032 reserved03 [ 0x03E ] ; U032 TopLeft ; U032 WidthHeight ; } RivaRectangle ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop ; U032 reserved01 [ 0x0BB ] ; U032 TopLeftSrc ; U032 TopLeftDst ; U032 WidthHeight ; } RivaScreenBlt ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop [ 1 ] ; U032 reserved01 [ 0x0BC ] ; U032 TopLeft ; U032 WidthHeight ; U032 WidthHeightIn ; U032 reserved02 [ 0x03C ] ; U032 Pixels ; } RivaPixmap ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop ; U032 reserved01 [ 0x0BB ] ; U032 reserved03 [ ( 0x040 ) - 1 ] ; U032 Color1A ; struct { U032 TopLeft ; U032 WidthHeight ; } UnclippedRectangle [ 64 ] ; U032 reserved04 [ ( 0x080 ) - 3 ] ; struct { U032 TopLeft ; U032 BottomRight ; } ClipB ; U032 Color1B ; struct { U032 TopLeft ; U032 BottomRight ; } ClippedRectangle [ 64 ] ; U032 reserved05 [ ( 0x080 ) - 5 ] ; struct { U032 TopLeft ; U032 BottomRight ; } ClipC ; U032 Color1C ; U032 WidthHeightC ; U032 PointC ; U032 MonochromeData1C ; U032 reserved06 [ ( 0x080 ) + 121 ] ; struct { U032 TopLeft ; U032 BottomRight ; } ClipD ; U032 Color1D ; U032 WidthHeightInD ; U032 WidthHeightOutD ; U032 PointD ; U032 MonochromeData1D ; U032 reserved07 [ ( 0x080 ) + 120 ] ; struct { U032 TopLeft ; U032 BottomRight ; } ClipE ; U032 Color0E ; U032 Color1E ; U032 WidthHeightInE ; U032 WidthHeightOutE ; U032 PointE ; U032 MonochromeData01E ; } RivaBitmap ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop ; U032 reserved01 [ 0x0BC ] ; U032 TextureOffset ; U032 TextureFormat ; U032 TextureFilter ; U032 FogColor ; U032 Control ; U032 AlphaTest ; U032 reserved02 [ 0x339 ] ; U032 FogAndIndex ; U032 Color ; float ScreenX ; float ScreenY ; float ScreenZ ; float EyeM ; float TextureS ; float TextureT ; } RivaTexturedTriangle03 ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop ; U032 reserved01 [ 0x0BB ] ; U032 ColorKey ; U032 TextureOffset ; U032 TextureFormat ; U032 TextureFilter ; U032 Blend ; U032 Control ; U032 FogColor ; U032 reserved02 [ 0x39 ] ; struct { float ScreenX ; float ScreenY ; float ScreenZ ; float EyeM ; U032 Color ; U032 Specular ; float TextureS ; float TextureT ; } Vertex [ 16 ] ; U032 DrawTriangle3D ; } RivaTexturedTriangle05 ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop [ 1 ] ; U032 reserved01 [ 0x0BC ] ; U032 Color ; U032 Reserved02 [ 0x03e ] ; struct { U032 point0 ; U032 point1 ; } Lin [ 16 ] ; struct { U032 point0X ; U032 point0Y ; U032 point1X ; U032 point1Y ; } Lin32 [ 8 ] ; U032 PolyLin [ 32 ] ; struct { U032 x ; U032 y ; } PolyLin32 [ 16 ] ; struct { U032 color ; U032 point ; } ColorPolyLin [ 16 ] ; } RivaLine ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop ; U032 reserved01 [ 0x0BE ] ; U032 Offset ; } RivaSurface ;

typedef volatile struct { U032 reserved00 [ 4 ] ; U016 FifoFree ; U016 Nop ; U032 reserved01 [ 0x0BD ] ; U032 Pitch ; U032 RenderBufferOffset ; U032 ZBufferOffset ; } RivaSurface3D ;

struct _riva_hw_inst ;

struct _riva_hw_state ;
typedef struct _riva_hw_inst { U032 Architecture ; U032 Version ; U032 Chipset ; U032 CrystalFreqKHz ; U032 RamAmountKBytes ; U032 MaxVClockFreqKHz ; U032 RamBandwidthKBytesPerSec ; U032 EnableIRQ ; U032 IO ; U032 VBlankBit ; U032 FifoFreeCount ; U032 FifoEmptyCount ; U032 CursorStart ; U032 flatPanel ; Bool twoHeads ; volatile U032 * PCRTC0 ; volatile U032 * PCRTC ; volatile U032 * PRAMDAC0 ; volatile U032 * PFB ; volatile U032 * PFIFO ; volatile U032 * PGRAPH ; volatile U032 * PEXTDEV ; volatile U032 * PTIMER ; volatile U032 * PMC ; volatile U032 * PRAMIN ; volatile U032 * FIFO ; volatile U032 * CURSOR ; volatile U008 * PCIO0 ; volatile U008 * PCIO ; volatile U008 * PVIO ; volatile U008 * PDIO0 ; volatile U008 * PDIO ; volatile U032 * PRAMDAC ; int ( * Busy ) ( struct _riva_hw_inst * ) ; void ( * LoadStateExt ) ( struct _riva_hw_inst * , struct _riva_hw_state * ) ; void ( * UnloadStateExt ) ( struct _riva_hw_inst * , struct _riva_hw_state * ) ; void ( * SetStartAddress ) ( struct _riva_hw_inst * , U032 ) ; void ( * SetSurfaces2D ) ( struct _riva_hw_inst * , U032 , U032 ) ; void ( * SetSurfaces3D ) ( struct _riva_hw_inst * , U032 , U032 ) ; int ( * ShowHideCursor ) ( struct _riva_hw_inst * , int ) ; void ( * LockUnlock ) ( struct _riva_hw_inst * , int ) ; struct _riva_hw_state * CurrentState ; RivaRop * Rop ; RivaPattern * Patt ; RivaClip * Clip ; RivaPixmap * Pixmap ; RivaScreenBlt * Blt ; RivaBitmap * Bitmap ; RivaLine * Line ; RivaTexturedTriangle03 * Tri03 ; RivaTexturedTriangle05 * Tri05 ; } RIVA_HW_INST ;

typedef struct _riva_hw_state { U032 bpp ; U032 width ; U032 height ; U032 interlace ; U032 repaint0 ; U032 repaint1 ; U032 screen ; U032 scale ; U032 dither ; U032 extra ; U032 pixel ; U032 horiz ; U032 arbitration0 ; U032 arbitration1 ; U032 vpll ; U032 vpll2 ; U032 pllsel ; U032 general ; U032 crtcOwner ; U032 head ; U032 head2 ; U032 config ; U032 cursorConfig ; U032 cursor0 ; U032 cursor1 ; U032 cursor2 ; U032 offset0 ; U032 offset1 ; U032 offset2 ; U032 offset3 ; U032 pitch0 ; U032 pitch1 ; U032 pitch2 ; U032 pitch3 ; } RIVA_HW_STATE ;
struct riva_regs { u8 attr [ 0x15 ] ; u8 crtc [ 0x41 ] ; u8 gra [ 0x09 ] ; u8 seq [ 0x05 ] ; u8 misc_output ; RIVA_HW_STATE ext ; } ;
struct riva_par ;

struct riva_i2c_chan { struct riva_par * par ; unsigned long ddc_base ; struct i2c_adapter adapter ; struct i2c_algo_bit_data algo ; } ;

struct riva_par { RIVA_HW_INST riva ; u32 pseudo_palette [ 16 ] ; u32 palette [ 16 ] ; u8 * ctrl_base ; unsigned dclk_max ; struct riva_regs initial_state ; struct riva_regs current_state ; struct vgastate state ; struct mutex open_lock ; unsigned int ref_count ; unsigned char * EDID ; unsigned int Chipset ; int forceCRTC ; Bool SecondCRTC ; int FlatPanel ; struct pci_dev * pdev ; int cursor_reset ; struct { int vram ; int vram_valid ; } mtrr ; struct riva_i2c_chan chan [ 3 ] ; } ;
typedef enum { NV1 , NV3 , NV4 , NumNVChips } NVChipType ;

typedef struct { int gdrain_rate ; int vdrain_rate ; int mdrain_rate ; int gburst_size ; int vburst_size ; char vid_en ; char gr_en ; int wcmocc , wcgocc , wcvocc , wcvlwm , wcglwm ; int by_gfacc ; char vid_only_once ; char gr_only_once ; char first_vacc ; char first_gacc ; char first_macc ; int vocc ; int gocc ; int mocc ; char cur ; char engine_en ; char converged ; int priority ; } nv3_arb_info ;

typedef struct { int graphics_lwm ; int video_lwm ; int graphics_burst_size ; int video_burst_size ; int graphics_hi_priority ; int media_hi_priority ; int rtl_values ; int valid ; } nv3_fifo_info ;

typedef struct { char pix_bpp ; char enable_video ; char gr_during_vid ; char enable_mp ; int memory_width ; int video_scale ; int pclk_khz ; int mclk_khz ; int mem_page_miss ; int mem_latency ; char mem_aligned ; } nv3_sim_state ;

int CalcStateExt ( RIVA_HW_INST * chip , RIVA_HW_STATE * state , int bpp , int width , int hDisplaySize , int height , int dotClock ) ;

int RivaGetConfig ( RIVA_HW_INST * chip , unsigned int chipset ) ;

unsigned long riva_get_memlen ( struct riva_par * par ) ;

unsigned long riva_get_maxdclk ( struct riva_par * par ) ;

void riva_common_setup ( struct riva_par * par ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) riva_create_i2c_busses ( struct riva_par * par ) ;

void riva_delete_i2c_busses ( struct riva_par * par ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) riva_probe_i2c_connector ( struct riva_par * par , int conn , u8 * * out_edid ) ;

typedef enum { S3_UNKNOWN = 0 , S3_SAVAGE3D , S3_SAVAGE_MX , S3_SAVAGE4 , S3_PROSAVAGE , S3_SUPERSAVAGE , S3_SAVAGE2000 , S3_LAST } savage_chipset ;

struct xtimings { unsigned int Clock ; unsigned int HDisplay ; unsigned int HSyncStart ; unsigned int HSyncEnd ; unsigned int HTotal ; unsigned int HAdjusted ; unsigned int VDisplay ; unsigned int VSyncStart ; unsigned int VSyncEnd ; unsigned int VTotal ; unsigned int sync ; int dblscan ; int interlaced ; } ;

struct savage_reg { unsigned char MiscOutReg ; unsigned char CRTC [ 25 ] ; unsigned char Sequencer [ 5 ] ; unsigned char Graphics [ 9 ] ; unsigned char Attribute [ 21 ] ; unsigned int mode , refresh ; unsigned char SR08 , SR0E , SR0F ; unsigned char SR10 , SR11 , SR12 , SR13 , SR15 , SR18 , SR29 , SR30 ; unsigned char SR54 [ 8 ] ; unsigned char Clock ; unsigned char CR31 , CR32 , CR33 , CR34 , CR36 , CR3A , CR3B , CR3C ; unsigned char CR40 , CR41 , CR42 , CR43 , CR45 ; unsigned char CR50 , CR51 , CR53 , CR55 , CR58 , CR5B , CR5D , CR5E ; unsigned char CR60 , CR63 , CR65 , CR66 , CR67 , CR68 , CR69 , CR6D , CR6F ; unsigned char CR86 , CR88 ; unsigned char CR90 , CR91 , CRB0 ; unsigned int STREAMS [ 22 ] ; unsigned int MMPR0 , MMPR1 , MMPR2 , MMPR3 ; } ;

struct savagefb_par ;

struct savagefb_i2c_chan { struct savagefb_par * par ; struct i2c_adapter adapter ; struct i2c_algo_bit_data algo ; volatile u8 * ioaddr ; u32 reg ; } ;

struct savagefb_par { struct pci_dev * pcidev ; savage_chipset chip ; struct savagefb_i2c_chan chan ; struct savage_reg state ; struct savage_reg save ; struct savage_reg initial ; struct vgastate vgastate ; struct mutex open_lock ; unsigned char * edid ; u32 pseudo_palette [ 16 ] ; u32 open_count ; int paletteEnabled ; int pm_state ; int display_type ; int dvi ; int crtonly ; int dacSpeedBpp ; int maxClock ; int minClock ; int numClocks ; int clock [ 4 ] ; int MCLK , REFCLK , LCDclk ; struct { void * vbase ; u32 pbase ; u32 len ; int mtrr ; } video ; struct { void * vbase ; u32 pbase ; u32 len ; } mmio ; volatile u32 * bci_base ; unsigned int bci_ptr ; u32 cob_offset ; u32 cob_size ; int cob_index ; void ( * SavageWaitIdle ) ( struct savagefb_par * par ) ; void ( * SavageWaitFifo ) ( struct savagefb_par * par , int space ) ; int HorizScaleFactor ; int SavagePanelWidth ; int SavagePanelHeight ; struct { u16 red , green , blue , transp ; } palette [ 256 ] ; int depth ; int vwidth ; } ;
void savagefb_create_i2c_busses ( struct fb_info * info ) ;

void savagefb_delete_i2c_busses ( struct fb_info * info ) ;

int savagefb_probe_i2c_connector ( struct fb_info * info , u8 * * out_edid ) ;

int savagefb_sync ( struct fb_info * info ) ;

void savagefb_copyarea ( struct fb_info * info , const struct fb_copyarea * region ) ;

void savagefb_fillrect ( struct fb_info * info , const struct fb_fillrect * rect ) ;

void savagefb_imageblit ( struct fb_info * info , const struct fb_image * image ) ;

void cfb_fillrect ( struct fb_info * p , const struct fb_fillrect * rect ) ;

void cfb_copyarea ( struct fb_info * p , const struct fb_copyarea * area ) ;

void cfb_imageblit ( struct fb_info * p , const struct fb_image * image ) ;

enum { S1SA = 0 , S2SA = 1 , SP = 2 , DSA = 3 , CNT = 4 , DP_OCTL = 5 , CLR = 6 , BI = 8 , MBC = 9 , BLTCTL = 10 , HES = 12 , HEB = 13 , HSB = 14 , HT = 15 , VES = 16 , VEB = 17 , VSB = 18 , VT = 19 , HCIV = 20 , VCIV = 21 , TCDR = 22 , VIL = 23 , STGCTL = 24 , SSR = 25 , HRIR = 26 , SPR = 27 , CMR = 28 , SRGCTL = 29 , RRCIV = 30 , RRSC = 31 , RRCR = 34 , GIOE = 32 , GIO = 33 , SCR = 35 , SSTATUS = 36 , PRC = 37 , } ;
enum { PADDRW = 0x00 , PDATA = 0x04 , PPMASK = 0x08 , PADDRR = 0x0c , PIDXLO = 0x10 , PIDXHI = 0x14 , PIDXDATA = 0x18 , PIDXCTL = 0x1c } ;
enum { CLKCTL = 0x02 , SYNCCTL = 0x03 , HSYNCPOS = 0x04 , PWRMNGMT = 0x05 , DACOP = 0x06 , PALETCTL = 0x07 , SYSCLKCTL = 0x08 , PIXFMT = 0x0a , BPP8 = 0x0b , BPP16 = 0x0c , BPP24 = 0x0d , BPP32 = 0x0e , PIXCTL1 = 0x10 , PIXCTL2 = 0x11 , SYSCLKN = 0x15 , SYSCLKM = 0x16 , SYSCLKP = 0x17 , SYSCLKC = 0x18 , PIXM0 = 0x20 , PIXN0 = 0x21 , PIXP0 = 0x22 , PIXC0 = 0x23 , CURSCTL = 0x30 , CURSXLO = 0x31 , CURSXHI = 0x32 , CURSYLO = 0x33 , CURSYHI = 0x34 , CURSHOTX = 0x35 , CURSHOTY = 0x36 , CURSACCTL = 0x37 , CURSACATTR = 0x38 , CURS1R = 0x40 , CURS1G = 0x41 , CURS1B = 0x42 , CURS2R = 0x43 , CURS2G = 0x44 , CURS2B = 0x45 , CURS3R = 0x46 , CURS3G = 0x47 , CURS3B = 0x48 , BORDR = 0x60 , BORDG = 0x61 , BORDB = 0x62 , MISCTL1 = 0x70 , MISCTL2 = 0x71 , MISCTL3 = 0x72 , KEYCTL = 0x78 } ;
enum { TVPADDRW = 0x00 , TVPPDATA = 0x04 , TVPPMASK = 0x08 , TVPPADRR = 0x0c , TVPCADRW = 0x10 , TVPCDATA = 0x14 , TVPCADRR = 0x1c , TVPDCCTL = 0x24 , TVPIDATA = 0x28 , TVPCRDAT = 0x2c , TVPCXPOL = 0x30 , TVPCXPOH = 0x34 , TVPCYPOL = 0x38 , TVPCYPOH = 0x3c , } ;
enum { TVPIRREV = 0x01 , TVPIRICC = 0x06 , TVPIRBRC = 0x07 , TVPIRLAC = 0x0f , TVPIRTCC = 0x18 , TVPIRMXC = 0x19 , TVPIRCLS = 0x1a , TVPIRPPG = 0x1c , TVPIRGEC = 0x1d , TVPIRMIC = 0x1e , TVPIRPLA = 0x2c , TVPIRPPD = 0x2d , TVPIRMPD = 0x2e , TVPIRLPD = 0x2f , TVPIRCKL = 0x30 , TVPIRCKH = 0x31 , TVPIRCRL = 0x32 , TVPIRCRH = 0x33 , TVPIRCGL = 0x34 , TVPIRCGH = 0x35 , TVPIRCBL = 0x36 , TVPIRCBH = 0x37 , TVPIRCKC = 0x38 , TVPIRMLC = 0x39 , TVPIRSEN = 0x3a , TVPIRTMD = 0x3b , TVPIRRML = 0x3c , TVPIRRMM = 0x3d , TVPIRRMS = 0x3e , TVPIRDID = 0x3f , TVPIRRES = 0xff } ;
struct initvalues { __u8 addr , value ; } ;

struct imstt_regvals { __u32 pitch ; __u16 hes , heb , hsb , ht , ves , veb , vsb , vt , vil ; __u8 pclk_m , pclk_n , pclk_p ; __u8 mlc [ 3 ] ; __u8 lckl_p [ 3 ] ; } ;

struct imstt_par { struct imstt_regvals init ; __u32 * dc_regs ; unsigned long cmap_regs_phys ; __u8 * cmap_regs ; __u32 ramdac ; __u32 palette [ 16 ] ; } ;

enum { IBM = 0 , TVP = 1 } ;
struct chips_init_reg { unsigned char addr ; unsigned char data ; } ;

enum { M_I17 , M_I20 , M_I20_SR , M_I24 , M_MINI , M_MB , M_MB_2 , M_MB_3 , M_MB_SR , M_MBA , M_MBP , M_MBP_2 , M_MBP_SR , M_MBP_4 , M_UNKNOWN } ;

struct regstate { __u8 * vga_font0 ; __u8 * vga_font1 ; __u8 * vga_text ; __u8 * vga_cmap ; __u8 * attr ; __u8 * crtc ; __u8 * gfx ; __u8 * seq ; __u8 misc ; } ;

int save_vga ( struct vgastate * state ) ;

int restore_vga ( struct vgastate * state ) ;

struct vga_regset { u8 regnum ; u8 lowbit ; u8 highbit ; } ;

struct svga_fb_format { u32 bits_per_pixel ; struct fb_bitfield red ; struct fb_bitfield green ; struct fb_bitfield blue ; struct fb_bitfield transp ; u32 nonstd ; u32 type ; u32 type_aux ; u32 visual ; u32 xpanstep ; u32 xresstep ; } ;

struct svga_timing_regs { const struct vga_regset * h_total_regs ; const struct vga_regset * h_display_regs ; const struct vga_regset * h_blank_start_regs ; const struct vga_regset * h_blank_end_regs ; const struct vga_regset * h_sync_start_regs ; const struct vga_regset * h_sync_end_regs ; const struct vga_regset * v_total_regs ; const struct vga_regset * v_display_regs ; const struct vga_regset * v_blank_start_regs ; const struct vga_regset * v_blank_end_regs ; const struct vga_regset * v_sync_start_regs ; const struct vga_regset * v_sync_end_regs ; } ;

struct svga_pll { u16 m_min ; u16 m_max ; u16 n_min ; u16 n_max ; u16 r_min ; u16 r_max ; u32 f_vco_min ; u32 f_vco_max ; u32 f_base ; } ;

void svga_wcrt_multi ( const struct vga_regset * regset , u32 value ) ;

void svga_wseq_multi ( const struct vga_regset * regset , u32 value ) ;

void svga_set_default_gfx_regs ( void ) ;

void svga_set_default_atc_regs ( void ) ;

void svga_set_default_seq_regs ( void ) ;

void svga_set_default_crt_regs ( void ) ;

void svga_set_textmode_vga_regs ( void ) ;

void svga_settile ( struct fb_info * info , struct fb_tilemap * map ) ;

void svga_tilecopy ( struct fb_info * info , struct fb_tilearea * area ) ;

void svga_tilefill ( struct fb_info * info , struct fb_tilerect * rect ) ;

void svga_tileblit ( struct fb_info * info , struct fb_tileblit * blit ) ;

void svga_tilecursor ( struct fb_info * info , struct fb_tilecursor * cursor ) ;

int svga_get_tilemax ( struct fb_info * info ) ;

void svga_get_caps ( struct fb_info * info , struct fb_blit_caps * caps , struct fb_var_screeninfo * var ) ;

int svga_compute_pll ( const struct svga_pll * pll , u32 f_wanted , u16 * m , u16 * n , u16 * r , int node ) ;

int svga_check_timings ( const struct svga_timing_regs * tm , struct fb_var_screeninfo * var , int node ) ;

void svga_set_timings ( const struct svga_timing_regs * tm , struct fb_var_screeninfo * var , u32 hmul , u32 hdiv , u32 vmul , u32 vdiv , u32 hborder , int node ) ;

int svga_match_format ( const struct svga_fb_format * frm , struct fb_var_screeninfo * var , struct fb_fix_screeninfo * fix ) ;

unsigned char * fb_ddc_read ( struct i2c_adapter * adapter ) ;

typedef volatile struct { __u32 bltStat ; __u32 bltCntl ; __u32 xpColor ; __u32 fgColor ; __u32 bgColor ; __u32 pitch ; __u32 clipLT ; __u32 clipRB ; __u32 srcBitOffset ; __u32 srcStart ; __u32 reserved0 ; __u32 dstStart ; __u32 xyExt ; __u32 reserved1 [ 19 ] ; __u32 pageCntl ; __u32 pageBase ; __u32 postBase ; __u32 postPtr ; __u32 dataPtr ; } Neo2200 ;

struct neofb_par { struct vgastate state ; unsigned int ref_count ; unsigned char MiscOutReg ; unsigned char CRTC [ 25 ] ; unsigned char Sequencer [ 5 ] ; unsigned char Graphics [ 9 ] ; unsigned char Attribute [ 21 ] ; unsigned char GeneralLockReg ; unsigned char ExtCRTDispAddr ; unsigned char ExtCRTOffset ; unsigned char SysIfaceCntl1 ; unsigned char SysIfaceCntl2 ; unsigned char ExtColorModeSelect ; unsigned char biosMode ; unsigned char PanelDispCntlReg1 ; unsigned char PanelDispCntlReg2 ; unsigned char PanelDispCntlReg3 ; unsigned char PanelDispCntlRegRead ; unsigned char PanelVertCenterReg1 ; unsigned char PanelVertCenterReg2 ; unsigned char PanelVertCenterReg3 ; unsigned char PanelVertCenterReg4 ; unsigned char PanelVertCenterReg5 ; unsigned char PanelHorizCenterReg1 ; unsigned char PanelHorizCenterReg2 ; unsigned char PanelHorizCenterReg3 ; unsigned char PanelHorizCenterReg4 ; unsigned char PanelHorizCenterReg5 ; int ProgramVCLK ; unsigned char VCLK3NumeratorLow ; unsigned char VCLK3NumeratorHigh ; unsigned char VCLK3Denominator ; unsigned char VerticalExt ; int mtrr ; u8 * mmio_vbase ; u8 cursorOff ; u8 * cursorPad ; Neo2200 * neo2200 ; int NeoPanelWidth ; int NeoPanelHeight ; int maxClock ; int pci_burst ; int lcd_stretch ; int internal_display ; int external_display ; int libretto ; u32 palette [ 16 ] ; } ;

typedef struct { int x_res ; int y_res ; int mode ; } biosMode ;

struct vt8623fb_info { char * mmio_base ; int mtrr_reg ; struct vgastate state ; struct mutex open_lock ; unsigned int ref_count ; u32 pseudo_palette [ 16 ] ; } ;

struct s3fb_info { int chip , rev , mclk_freq ; int mtrr_reg ; struct vgastate state ; struct mutex open_lock ; unsigned int ref_count ; u32 pseudo_palette [ 16 ] ; } ;

struct arkfb_info { int mclk_freq ; int mtrr_reg ; struct dac_info * dac ; struct vgastate state ; struct mutex open_lock ; unsigned int ref_count ; u32 pseudo_palette [ 16 ] ; } ;

enum { DAC_PSEUDO8_8 , DAC_RGB1555_8 , DAC_RGB0565_8 , DAC_RGB0888_8 , DAC_RGB8888_8 , DAC_PSEUDO8_16 , DAC_RGB1555_16 , DAC_RGB0565_16 , DAC_RGB0888_16 , DAC_RGB8888_16 , DAC_MAX } ;
struct dac_ops { int ( * dac_get_mode ) ( struct dac_info * info ) ; int ( * dac_set_mode ) ( struct dac_info * info , int mode ) ; int ( * dac_get_freq ) ( struct dac_info * info , int channel ) ; int ( * dac_set_freq ) ( struct dac_info * info , int channel , u32 freq ) ; void ( * dac_release ) ( struct dac_info * info ) ; } ;

typedef void ( * dac_read_regs_t ) ( void * data , u8 * code , int count ) ;
typedef void ( * dac_write_regs_t ) ( void * data , u8 * code , int count ) ;
struct dac_info { struct dac_ops * dacops ; dac_read_regs_t dac_read_regs ; dac_write_regs_t dac_write_regs ; void * data ; } ;

struct ics5342_info { struct dac_info dac ; u8 mode ; } ;

struct vga16fb_par { struct { unsigned char SeqCtrlIndex ; unsigned char CrtCtrlIndex ; unsigned char CrtMiscIO ; unsigned char HorizontalTotal ; unsigned char HorizDisplayEnd ; unsigned char StartHorizRetrace ; unsigned char EndHorizRetrace ; unsigned char Overflow ; unsigned char StartVertRetrace ; unsigned char EndVertRetrace ; unsigned char ModeControl ; unsigned char ClockingMode ; } vga_state ; struct vgastate state ; unsigned int ref_count ; int palette_blanked , vesa_blanked , mode , isVGA ; u8 misc , pel_msk , vss , clkdiv ; u8 crtc [ 0x19 ] ; } ;

struct output_device * video_output_register ( const char * name , struct device * dev , void * devdata , struct output_properties * op ) ;

void video_output_unregister ( struct output_device * dev ) ;

void virtio_check_driver_offered_feature ( const struct virtio_device * vdev , unsigned int fbit ) ;

int register_virtio_driver ( struct virtio_driver * driver ) ;

void unregister_virtio_driver ( struct virtio_driver * driver ) ;

int register_virtio_device ( struct virtio_device * dev ) ;

void unregister_virtio_device ( struct virtio_device * dev ) ;

struct vring_desc { __u64 addr ; __u32 len ; __u16 flags ; __u16 next ; } ;

struct vring_avail { __u16 flags ; __u16 idx ; __u16 ring [ ] ; } ;

struct vring_used_elem { __u32 id ; __u32 len ; } ;

struct vring_used { __u16 flags ; __u16 idx ; struct vring_used_elem ring [ ] ; } ;

struct vring { unsigned int num ; struct vring_desc * desc ; struct vring_avail * avail ; struct vring_used * used ; } ;

struct virtio_device ;
struct virtqueue ;
struct vring_virtqueue { struct virtqueue vq ; struct vring vring ; bool broken ; bool indirect ; unsigned int num_free ; unsigned int free_head ; unsigned int num_added ; u16 last_used_idx ; void ( * notify ) ( struct virtqueue * vq ) ; void * data [ ] ; } ;

irqreturn_t vring_interrupt ( int irq , void * _vq ) ;

struct virtqueue * vring_new_virtqueue ( unsigned int num , unsigned int vring_align , struct virtio_device * vdev , void * pages , void ( * notify ) ( struct virtqueue * ) , void ( * callback ) ( struct virtqueue * ) , const char * name ) ;

void vring_del_virtqueue ( struct virtqueue * vq ) ;

void vring_transport_features ( struct virtio_device * vdev ) ;

struct virtio_pci_device { struct virtio_device vdev ; struct pci_dev * pci_dev ; void * ioaddr ; spinlock_t lock ; struct list_head virtqueues ; int msix_enabled ; int intx_enabled ; struct msix_entry * msix_entries ; char ( * msix_names ) [ 256 ] ; unsigned msix_vectors ; unsigned msix_used_vectors ; bool per_vq_vectors ; } ;

enum { VP_MSIX_CONFIG_VECTOR = 0 , VP_MSIX_VQ_VECTOR = 1 , } ;
struct virtio_pci_vq_info { struct virtqueue * vq ; int num ; int queue_index ; void * queue ; struct list_head node ; unsigned msix_vector ; } ;

void gnttab_grant_foreign_access_ref ( grant_ref_t ref , domid_t domid , unsigned long frame , int readonly ) ;

int gnttab_grant_foreign_access ( domid_t domid , unsigned long frame , int readonly ) ;

int gnttab_query_foreign_access ( grant_ref_t ref ) ;

int gnttab_end_foreign_access_ref ( grant_ref_t ref , int readonly ) ;

void gnttab_end_foreign_access ( grant_ref_t ref , int readonly , unsigned long page ) ;

int gnttab_grant_foreign_transfer ( domid_t domid , unsigned long pfn ) ;

void gnttab_grant_foreign_transfer_ref ( grant_ref_t ref , domid_t domid , unsigned long pfn ) ;

unsigned long gnttab_end_foreign_transfer_ref ( grant_ref_t ref ) ;

unsigned long gnttab_end_foreign_transfer ( grant_ref_t ref ) ;

void gnttab_free_grant_reference ( grant_ref_t ref ) ;

void gnttab_free_grant_references ( grant_ref_t head ) ;

int gnttab_alloc_grant_references ( u16 count , grant_ref_t * head ) ;

int gnttab_empty_grant_references ( const grant_ref_t * private_head ) ;

int gnttab_claim_grant_reference ( grant_ref_t * private_head ) ;

void gnttab_release_grant_reference ( grant_ref_t * private_head , grant_ref_t release ) ;

void gnttab_request_free_callback ( struct gnttab_free_callback * callback , void ( * fn ) ( void * ) , void * arg , u16 count ) ;

void gnttab_cancel_free_callback ( struct gnttab_free_callback * callback ) ;

int gnttab_resume ( void ) ;

int gnttab_suspend ( void ) ;

void xen_setup_features ( void ) ;

enum xen_irq_type { IRQT_UNBOUND = 0 , IRQT_PIRQ , IRQT_VIRQ , IRQT_IPI , IRQT_EVTCHN } ;

struct irq_info { enum xen_irq_type type ; unsigned short evtchn ; unsigned short cpu ; union { unsigned short virq ; enum ipi_vector ipi ; struct { unsigned short gsi ; unsigned short vector ; } pirq ; } u ; } ;
struct cpu_evtchn_s { unsigned long bits [ ( sizeof ( unsigned long ) * sizeof ( unsigned long ) * 64 ) / 64 ] ; } ;

unsigned irq_from_evtchn ( unsigned int evtchn ) ;

void notify_remote_via_irq ( int irq ) ;

int bind_evtchn_to_irq ( unsigned int evtchn ) ;

int bind_evtchn_to_irqhandler ( unsigned int evtchn , irq_handler_t handler , unsigned long irqflags , const char * devname , void * dev_id ) ;

int bind_virq_to_irqhandler ( unsigned int virq , unsigned int cpu , irq_handler_t handler , unsigned long irqflags , const char * devname , void * dev_id ) ;

int bind_ipi_to_irqhandler ( enum ipi_vector ipi , unsigned int cpu , irq_handler_t handler , unsigned long irqflags , const char * devname , void * dev_id ) ;

void unbind_from_irqhandler ( unsigned int irq , void * dev_id ) ;

void xen_send_IPI_one ( unsigned int cpu , enum ipi_vector vector ) ;

irqreturn_t xen_debug_interrupt ( int irq , void * dev_id ) ;

void xen_evtchn_do_upcall ( struct pt_regs * regs ) ;

void rebind_evtchn_irq ( int evtchn , int irq ) ;

int resend_irq_on_evtchn ( unsigned int irq ) ;

void xen_clear_irq_pending ( int irq ) ;

void xen_set_irq_pending ( int irq ) ;

bool xen_test_irq_pending ( int irq ) ;

void xen_poll_irq ( int irq ) ;

void xen_irq_resume ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) xen_init_IRQ ( void ) ;

enum xenbus_state { XenbusStateUnknown = 0 , XenbusStateInitialising = 1 , XenbusStateInitWait = 2 , XenbusStateInitialised = 3 , XenbusStateConnected = 4 , XenbusStateClosing = 5 , XenbusStateClosed = 6 } ;

enum xsd_sockmsg_type { XS_DEBUG , XS_DIRECTORY , XS_READ , XS_GET_PERMS , XS_WATCH , XS_UNWATCH , XS_TRANSACTION_START , XS_TRANSACTION_END , XS_INTRODUCE , XS_RELEASE , XS_GET_DOMAIN_PATH , XS_WRITE , XS_MKDIR , XS_RM , XS_SET_PERMS , XS_WATCH_EVENT , XS_ERROR , XS_IS_DOMAIN_INTRODUCED } ;

struct xsd_errors { int errnum ; const char * errstring ; } ;

struct xsd_sockmsg { uint32_t type ; uint32_t req_id ; uint32_t tx_id ; uint32_t len ; } ;

enum xs_watch_type { XS_WATCH_PATH = 0 , XS_WATCH_TOKEN } ;

typedef uint32_t XENSTORE_RING_IDX ;

struct xenstore_domain_interface { char req [ 1024 ] ; char rsp [ 1024 ] ; XENSTORE_RING_IDX req_cons , req_prod ; XENSTORE_RING_IDX rsp_cons , rsp_prod ; } ;

struct xenbus_watch { struct list_head list ; const char * node ; void ( * callback ) ( struct xenbus_watch * , const char * * vec , unsigned int len ) ; } ;

struct xenbus_device { const char * devicetype ; const char * nodename ; const char * otherend ; int otherend_id ; struct xenbus_watch otherend_watch ; struct device dev ; enum xenbus_state state ; struct completion down ; } ;

struct xenbus_device_id { char devicetype [ 32 ] ; } ;

struct xenbus_driver { char * name ; struct module * owner ; const struct xenbus_device_id * ids ; int ( * probe ) ( struct xenbus_device * dev , const struct xenbus_device_id * id ) ; void ( * otherend_changed ) ( struct xenbus_device * dev , enum xenbus_state backend_state ) ; int ( * remove ) ( struct xenbus_device * dev ) ; int ( * suspend ) ( struct xenbus_device * dev , pm_message_t state ) ; int ( * resume ) ( struct xenbus_device * dev ) ; int ( * uevent ) ( struct xenbus_device * , char * * , int , char * , int ) ; struct device_driver driver ; int ( * read_otherend_details ) ( struct xenbus_device * dev ) ; int ( * is_ready ) ( struct xenbus_device * dev ) ; } ;

struct xenbus_transaction { u32 id ; } ;

enum shutdown_state { SHUTDOWN_INVALID = - 1 , SHUTDOWN_POWEROFF = 0 , SHUTDOWN_SUSPEND = 2 , SHUTDOWN_HALT = 4 , } ;

const char * xenbus_strstate ( enum xenbus_state state ) ;

int xenbus_watch_path ( struct xenbus_device * dev , const char * path , struct xenbus_watch * watch , void ( * callback ) ( struct xenbus_watch * , const char * * , unsigned int ) ) ;

int xenbus_watch_pathfmt ( struct xenbus_device * dev , struct xenbus_watch * watch , void ( * callback ) ( struct xenbus_watch * , const char * * , unsigned int ) , const char * pathfmt , ... ) ;

int xenbus_switch_state ( struct xenbus_device * dev , enum xenbus_state state ) ;

int xenbus_frontend_closed ( struct xenbus_device * dev ) ;

void xenbus_dev_error ( struct xenbus_device * dev , int err , const char * fmt , ... ) ;

void xenbus_dev_fatal ( struct xenbus_device * dev , int err , const char * fmt , ... ) ;

int xenbus_grant_ring ( struct xenbus_device * dev , unsigned long ring_mfn ) ;

int xenbus_alloc_evtchn ( struct xenbus_device * dev , int * port ) ;

int xenbus_bind_evtchn ( struct xenbus_device * dev , int remote_port , int * port ) ;

int xenbus_free_evtchn ( struct xenbus_device * dev , int port ) ;

int xenbus_map_ring_valloc ( struct xenbus_device * dev , int gnt_ref , void * * vaddr ) ;

int xenbus_map_ring ( struct xenbus_device * dev , int gnt_ref , grant_handle_t * handle , void * vaddr ) ;

int xenbus_unmap_ring_vfree ( struct xenbus_device * dev , void * vaddr ) ;

int xenbus_unmap_ring ( struct xenbus_device * dev , grant_handle_t handle , void * vaddr ) ;

enum xenbus_state xenbus_read_driver_state ( const char * path ) ;

int xb_write ( const void * data , unsigned len ) ;

int xb_data_to_read ( void ) ;

int xb_wait_for_data_to_read ( void ) ;

int xb_read ( void * data , unsigned len ) ;

int xb_init_comms ( void ) ;

struct xs_stored_msg { struct list_head list ; struct xsd_sockmsg hdr ; union { struct { char * body ; } reply ; struct { struct xenbus_watch * handle ; char * * vec ; unsigned int vec_size ; } watch ; } u ; } ;

struct xs_handle { struct list_head reply_list ; spinlock_t reply_lock ; wait_queue_head_t reply_waitq ; struct mutex request_mutex ; struct mutex response_mutex ; struct rw_semaphore transaction_mutex ; struct rw_semaphore watch_mutex ; } ;

void * xenbus_dev_request_and_reply ( struct xsd_sockmsg * msg ) ;

char * * xenbus_directory ( struct xenbus_transaction t , const char * dir , const char * node , unsigned int * num ) ;

int xenbus_exists ( struct xenbus_transaction t , const char * dir , const char * node ) ;

void * xenbus_read ( struct xenbus_transaction t , const char * dir , const char * node , unsigned int * len ) ;

int xenbus_write ( struct xenbus_transaction t , const char * dir , const char * node , const char * string ) ;

int xenbus_mkdir ( struct xenbus_transaction t , const char * dir , const char * node ) ;

int xenbus_rm ( struct xenbus_transaction t , const char * dir , const char * node ) ;

int xenbus_transaction_start ( struct xenbus_transaction * t ) ;

int xenbus_transaction_end ( struct xenbus_transaction t , int abort ) ;

int xenbus_scanf ( struct xenbus_transaction t , const char * dir , const char * node , const char * fmt , ... ) ;

int xenbus_printf ( struct xenbus_transaction t , const char * dir , const char * node , const char * fmt , ... ) ;

int xenbus_gather ( struct xenbus_transaction t , const char * dir , ... ) ;

int register_xenbus_watch ( struct xenbus_watch * watch ) ;

void unregister_xenbus_watch ( struct xenbus_watch * watch ) ;

void xs_suspend ( void ) ;

void xs_resume ( void ) ;

void xs_suspend_cancel ( void ) ;

int xs_init ( void ) ;

struct xen_bus_type { char * root ; unsigned int levels ; int ( * get_bus_id ) ( char bus_id [ 20 ] , const char * nodename ) ; int ( * probe ) ( const char * type , const char * dir ) ; struct bus_type bus ; } ;

int xenbus_match ( struct device * _dev , struct device_driver * _drv ) ;

int read_otherend_details ( struct xenbus_device * xendev , char * id_node , char * path_node ) ;

int xenbus_dev_probe ( struct device * _dev ) ;

int xenbus_dev_remove ( struct device * _dev ) ;

int xenbus_register_driver_common ( struct xenbus_driver * drv , struct xen_bus_type * bus , struct module * owner , const char * mod_name ) ;

int __xenbus_register_frontend ( struct xenbus_driver * drv , struct module * owner , const char * mod_name ) ;

void xenbus_unregister_driver ( struct xenbus_driver * drv ) ;

struct xb_find_info { struct xenbus_device * dev ; const char * nodename ; } ;

struct xenbus_device * xenbus_device_find ( const char * nodename , struct bus_type * bus ) ;

int xenbus_probe_node ( struct xen_bus_type * bus , const char * type , const char * nodename ) ;

int xenbus_probe_devices ( struct xen_bus_type * bus ) ;

void xenbus_dev_changed ( const char * node , struct xen_bus_type * bus ) ;

int register_xenstore_notifier ( struct notifier_block * nb ) ;

void unregister_xenstore_notifier ( struct notifier_block * nb ) ;

void xenbus_probe ( struct work_struct * unused ) ;

struct xen_memory_reservation { __guest_handle_ulong extent_start ; unsigned long nr_extents ; unsigned int extent_order ; unsigned int address_bits ; domid_t domid ; } ;

typedef struct xen_memory_reservation * __guest_handle_xen_memory_reservation ;

struct xen_machphys_mfn_list { unsigned int max_extents ; __guest_handle_ulong extent_start ; unsigned int nr_extents ; } ;

typedef struct xen_machphys_mfn_list * __guest_handle_xen_machphys_mfn_list ;

struct xen_add_to_physmap { domid_t domid ; unsigned int space ; unsigned long idx ; unsigned long gpfn ; } ;

typedef struct xen_add_to_physmap * __guest_handle_xen_add_to_physmap ;

struct xen_translate_gpfn_list { domid_t domid ; unsigned long nr_gpfns ; __guest_handle_ulong gpfn_list ; __guest_handle_ulong mfn_list ; } ;

typedef struct xen_translate_gpfn_list * __guest_handle_xen_translate_gpfn_list ;

struct balloon_stats { unsigned long current_pages ; unsigned long target_pages ; unsigned long driver_pages ; unsigned long balloon_low ; unsigned long balloon_high ; } ;

struct hyp_sysfs_attr { struct attribute attr ; ssize_t ( * show ) ( struct hyp_sysfs_attr * , char * ) ; ssize_t ( * store ) ( struct hyp_sysfs_attr * , const char * , size_t ) ; void * hyp_attr_data ; } ;

void pcibios_align_resource ( void * data , struct resource * res , resource_size_t size , resource_size_t align ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pcibios_resource_survey ( void ) ;

void __attribute__ ( ( weak ) ) x86_pci_root_bus_res_quirks ( struct pci_bus * b ) ;

void pcibios_set_master ( struct pci_dev * dev ) ;

int pci_mmap_page_range ( struct pci_dev * dev , struct vm_area_struct * vma , enum pci_mmap_state mmap_state , int write_combine ) ;

struct mmcfg_virt { struct acpi_mcfg_allocation * cfg ; char * virt ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_mmcfg_arch_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_mmcfg_arch_free ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_direct_init ( int type ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_direct_probe ( void ) ;

struct pci_mmcfg_hostbridge_probe { u32 bus ; u32 devfn ; u32 vendor ; u32 device ; const char * ( * probe ) ( void ) ; } ;

typedef int ( * check_reserved_t ) ( u64 start , u64 end , unsigned type ) ;
void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_mmcfg_early_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_mmcfg_late_init ( void ) ;

struct pci_root_info { char * name ; unsigned int res_num ; struct resource * res ; struct pci_bus * bus ; int busnum ; } ;

struct pci_bus * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pci_acpi_scan_root ( struct acpi_device * device , int domain , int busnum ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_acpi_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pci_subsys_init ( void ) ;

struct irq_router { char * name ; u16 vendor , device ; int ( * get ) ( struct pci_dev * router , struct pci_dev * dev , int pirq ) ; int ( * set ) ( struct pci_dev * router , struct pci_dev * dev , int pirq , int new ) ; } ;

struct irq_router_handler { u16 vendor ; int ( * probe ) ( struct irq_router * r , struct pci_dev * router , u16 device ) ; } ;

void eisa_set_level_irq ( unsigned int irq ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pcibios_irq_init ( void ) ;

void pcibios_penalize_isa_irq ( int irq , int active ) ;

int raw_pci_read ( unsigned int domain , unsigned int bus , unsigned int devfn , int reg , int len , u32 * val ) ;

int raw_pci_write ( unsigned int domain , unsigned int bus , unsigned int devfn , int reg , int len , u32 val ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dmi_check_skip_isa_align ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pcibios_fixup_bus ( struct pci_bus * b ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dmi_check_pciprobe ( void ) ;

struct pci_bus * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pcibios_scan_root ( int busnum ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) pcibios_init ( void ) ;

char * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pcibios_setup ( char * str ) ;

unsigned int pcibios_assign_all_busses ( void ) ;

int pcibios_enable_device ( struct pci_dev * dev , int mask ) ;

void pcibios_disable_device ( struct pci_dev * dev ) ;
int pci_ext_cfg_avail ( struct pci_dev * dev ) ;
struct pci_bus * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pci_scan_bus_on_node ( int busno , struct pci_ops * ops , int node ) ;

struct pci_bus * __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) pci_scan_bus_with_sysdata ( int busno ) ;

void set_mp_bus_to_node ( int busnum , int node ) ;

int get_mp_bus_to_node ( int busnum ) ;

u32 read_pci_config ( u8 bus , u8 slot , u8 func , u8 offset ) ;

u8 read_pci_config_byte ( u8 bus , u8 slot , u8 func , u8 offset ) ;

u16 read_pci_config_16 ( u8 bus , u8 slot , u8 func , u8 offset ) ;

void write_pci_config ( u8 bus , u8 slot , u8 func , u8 offset , u32 val ) ;

void write_pci_config_byte ( u8 bus , u8 slot , u8 func , u8 offset , u8 val ) ;

void write_pci_config_16 ( u8 bus , u8 slot , u8 func , u8 offset , u16 val ) ;

int early_pci_allowed ( void ) ;

void early_dump_pci_device ( u8 bus , u8 slot , u8 func ) ;

void early_dump_pci_devices ( void ) ;

struct pci_root_info { char name [ 12 ] ; unsigned int res_num ; struct resource res [ 16 ] ; int bus_min ; int bus_max ; int node ; int link ; } ;
void x86_pci_root_bus_res_quirks ( struct pci_bus * b ) ;
struct res_range { size_t start ; size_t end ; } ;
void save_processor_state ( void ) ;

void restore_processor_state ( void ) ;

int swsusp_arch_resume ( void ) ;

int pfn_is_nosave ( unsigned long pfn ) ;

struct restore_data_record { unsigned long jump_address ; unsigned long cr3 ; unsigned long magic ; } ;

int arch_hibernation_header_save ( void * addr , unsigned int max_size ) ;

int arch_hibernation_header_restore ( void * addr ) ;

enum router_ioctls { ROUTER_SETUP = 'W' << 8 , ROUTER_DOWN , ROUTER_STAT , ROUTER_IFNEW , ROUTER_IFDEL , ROUTER_IFSTAT , ROUTER_USER = ( 'W' << 8 ) + 16 , ROUTER_USER_MAX = ( 'W' << 8 ) + 31 } ;


typedef struct wan_x25_conf { unsigned lo_pvc ; unsigned hi_pvc ; unsigned lo_svc ; unsigned hi_svc ; unsigned hdlc_window ; unsigned pkt_window ; unsigned t1 ; unsigned t2 ; unsigned t4 ; unsigned n2 ; unsigned t10_t20 ; unsigned t11_t21 ; unsigned t12_t22 ; unsigned t13_t23 ; unsigned t16_t26 ; unsigned t28 ; unsigned r10_r20 ; unsigned r12_r22 ; unsigned r13_r23 ; unsigned ccitt_compat ; unsigned x25_conf_opt ; unsigned char LAPB_hdlc_only ; unsigned char logging ; unsigned char oob_on_modem ; } wan_x25_conf_t ;


typedef struct wan_fr_conf { unsigned signalling ; unsigned t391 ; unsigned t392 ; unsigned n391 ; unsigned n392 ; unsigned n393 ; unsigned dlci_num ; unsigned dlci [ 100 ] ; } wan_fr_conf_t ;


typedef struct wan_ppp_conf { unsigned restart_tmr ; unsigned auth_rsrt_tmr ; unsigned auth_wait_tmr ; unsigned mdm_fail_tmr ; unsigned dtr_drop_tmr ; unsigned connect_tmout ; unsigned conf_retry ; unsigned term_retry ; unsigned fail_retry ; unsigned auth_retry ; unsigned auth_options ; unsigned ip_options ; char authenticator ; char ip_mode ; } wan_ppp_conf_t ;


typedef struct wan_chdlc_conf { unsigned char ignore_dcd ; unsigned char ignore_cts ; unsigned char ignore_keepalive ; unsigned char hdlc_streaming ; unsigned char receive_only ; unsigned keepalive_tx_tmr ; unsigned keepalive_rx_tmr ; unsigned keepalive_err_margin ; unsigned slarp_timer ; } wan_chdlc_conf_t ;


typedef struct wandev_conf { unsigned magic ; unsigned config_id ; unsigned ioport ; unsigned long maddr ; unsigned msize ; int irq ; int dma ; char S514_CPU_no [ 1 ] ; unsigned PCI_slot_no ; char auto_pci_cfg ; char comm_port ; unsigned bps ; unsigned mtu ; unsigned udp_port ; unsigned char ttl ; unsigned char ft1 ; char interface ; char clocking ; char line_coding ; char station ; char connection ; char read_mode ; char receive_only ; char tty ; unsigned tty_major ; unsigned tty_minor ; unsigned tty_mode ; char backup ; unsigned hw_opt [ 4 ] ; unsigned reserved [ 4 ] ; unsigned data_size ; void * data ; union { wan_x25_conf_t x25 ; wan_ppp_conf_t ppp ; wan_fr_conf_t fr ; wan_chdlc_conf_t chdlc ; } u ; } wandev_conf_t ;


typedef struct wandev_stat { unsigned state ; unsigned ndev ; unsigned connection ; unsigned media_type ; unsigned mtu ; unsigned modem_status ; unsigned rx_frames ; unsigned rx_overruns ; unsigned rx_crc_err ; unsigned rx_aborts ; unsigned rx_bad_length ; unsigned rx_dropped ; unsigned tx_frames ; unsigned tx_underruns ; unsigned tx_timeouts ; unsigned tx_rejects ; unsigned rx_bad_format ; unsigned rx_bad_addr ; unsigned tx_retries ; unsigned reserved [ 16 ] ; } wandev_stat_t ;

enum wan_states { WAN_UNCONFIGURED , WAN_DISCONNECTED , WAN_CONNECTING , WAN_CONNECTED , WAN_LIMIT , WAN_DUALPORT , WAN_DISCONNECTING , WAN_FT1_READY } ;

enum { WAN_LOCAL_IP , WAN_POINTOPOINT_IP , WAN_NETMASK_IP , WAN_BROADCAST_IP } ;

typedef struct wanif_conf { unsigned magic ; unsigned config_id ; char name [ 15 + 1 ] ; char addr [ 31 + 1 ] ; char usedby [ 8 ] ; unsigned idle_timeout ; unsigned hold_timeout ; unsigned cir ; unsigned bc ; unsigned be ; unsigned char enable_IPX ; unsigned char inarp ; unsigned inarp_interval ; unsigned long network_number ; char mc ; char local_addr [ 31 + 1 ] ; unsigned char port ; unsigned char protocol ; char pap ; char chap ; unsigned char userid [ 511 ] ; unsigned char passwd [ 511 ] ; unsigned char sysname [ 31 ] ; unsigned char ignore_dcd ; unsigned char ignore_cts ; unsigned char ignore_keepalive ; unsigned char hdlc_streaming ; unsigned keepalive_tx_tmr ; unsigned keepalive_rx_tmr ; unsigned keepalive_err_margin ; unsigned slarp_timer ; unsigned char ttl ; char interface ; char clocking ; unsigned bps ; unsigned mtu ; unsigned char if_down ; unsigned char gateway ; unsigned char true_if_encoding ; unsigned char asy_data_trans ; unsigned char rts_hs_for_receive ; unsigned char xon_xoff_hs_for_receive ; unsigned char xon_xoff_hs_for_transmit ; unsigned char dcd_hs_for_transmit ; unsigned char cts_hs_for_transmit ; unsigned char async_mode ; unsigned tx_bits_per_char ; unsigned rx_bits_per_char ; unsigned stop_bits ; unsigned char parity ; unsigned break_timer ; unsigned inter_char_timer ; unsigned rx_complete_length ; unsigned xon_char ; unsigned xoff_char ; unsigned char receive_only ; } wanif_conf_t ;

struct wan_device { unsigned magic ; char * name ; void * private ; unsigned config_id ; unsigned ioport ; char S514_cpu_no [ 1 ] ; unsigned char S514_slot_no ; unsigned long maddr ; unsigned msize ; int irq ; int dma ; unsigned bps ; unsigned mtu ; unsigned udp_port ; unsigned char ttl ; unsigned enable_tx_int ; char interface ; char clocking ; char line_coding ; char station ; char connection ; char signalling ; char read_mode ; char new_if_cnt ; char del_if_cnt ; unsigned char piggyback ; unsigned hw_opt [ 4 ] ; char state ; char api_status ; struct net_device_stats stats ; unsigned reserved [ 16 ] ; unsigned long critical ; spinlock_t lock ; int ( * setup ) ( struct wan_device * wandev , wandev_conf_t * conf ) ; int ( * shutdown ) ( struct wan_device * wandev ) ; int ( * update ) ( struct wan_device * wandev ) ; int ( * ioctl ) ( struct wan_device * wandev , unsigned cmd , unsigned long arg ) ; int ( * new_if ) ( struct wan_device * wandev , struct net_device * dev , wanif_conf_t * conf ) ; int ( * del_if ) ( struct wan_device * wandev , struct net_device * dev ) ; struct wan_device * next ; struct net_device * dev ; unsigned ndev ; struct proc_dir_entry * dent ; } ;

struct dlci_add { char devname [ 16 ] ; short dlci ; } ;

struct dlci_conf { short flags ; short CIR_fwd ; short Bc_fwd ; short Be_fwd ; short CIR_bwd ; short Bc_bwd ; short Be_bwd ; short Tc_fwd ; short Tc_bwd ; short Tf_max ; short Tb_max ; } ;

struct frad_conf { short station ; short flags ; short kbaud ; short clocking ; short mtu ; short T391 ; short T392 ; short N391 ; short N392 ; short N393 ; short CIR_fwd ; short Bc_fwd ; short Be_fwd ; short CIR_bwd ; short Bc_bwd ; short Be_bwd ; } ;

struct iw_param { __s32 value ; __u8 fixed ; __u8 disabled ; __u16 flags ; } ;

struct iw_point { void * pointer ; __u16 length ; __u16 flags ; } ;

struct compat_iw_point { compat_caddr_t pointer ; __u16 length ; __u16 flags ; } ;

struct iw_freq { __s32 m ; __s16 e ; __u8 i ; __u8 flags ; } ;

struct iw_quality { __u8 qual ; __u8 level ; __u8 noise ; __u8 updated ; } ;

struct iw_discarded { __u32 nwid ; __u32 code ; __u32 fragment ; __u32 retries ; __u32 misc ; } ;

struct iw_missed { __u32 beacon ; } ;

struct iw_thrspy { struct sockaddr addr ; struct iw_quality qual ; struct iw_quality low ; struct iw_quality high ; } ;

struct iw_scan_req { __u8 scan_type ; __u8 essid_len ; __u8 num_channels ; __u8 flags ; struct sockaddr bssid ; __u8 essid [ 32 ] ; __u32 min_channel_time ; __u32 max_channel_time ; struct iw_freq channel_list [ 32 ] ; } ;

struct iw_encode_ext { __u32 ext_flags ; __u8 tx_seq [ 8 ] ; __u8 rx_seq [ 8 ] ; struct sockaddr addr ; __u16 alg ; __u16 key_len ; __u8 key [ 0 ] ; } ;

struct iw_mlme { __u16 cmd ; __u16 reason_code ; struct sockaddr addr ; } ;

struct iw_pmksa { __u32 cmd ; struct sockaddr bssid ; __u8 pmkid [ 16 ] ; } ;

struct iw_michaelmicfailure { __u32 flags ; struct sockaddr src_addr ; __u8 tsc [ 8 ] ; } ;

struct iw_pmkid_cand { __u32 flags ; __u32 index ; struct sockaddr bssid ; } ;

struct iw_statistics { __u16 status ; struct iw_quality qual ; struct iw_discarded discard ; struct iw_missed miss ; } ;

union iwreq_data { char name [ 16 ] ; struct iw_point essid ; struct iw_param nwid ; struct iw_freq freq ; struct iw_param sens ; struct iw_param bitrate ; struct iw_param txpower ; struct iw_param rts ; struct iw_param frag ; __u32 mode ; struct iw_param retry ; struct iw_point encoding ; struct iw_param power ; struct iw_quality qual ; struct sockaddr ap_addr ; struct sockaddr addr ; struct iw_param param ; struct iw_point data ; } ;

struct iwreq { union { char ifrn_name [ 16 ] ; } ifr_ifrn ; union iwreq_data u ; } ;

struct iw_range { __u32 throughput ; __u32 min_nwid ; __u32 max_nwid ; __u16 old_num_channels ; __u8 old_num_frequency ; __u8 scan_capa ; __u32 event_capa [ 6 ] ; __s32 sensitivity ; struct iw_quality max_qual ; struct iw_quality avg_qual ; __u8 num_bitrates ; __s32 bitrate [ 32 ] ; __s32 min_rts ; __s32 max_rts ; __s32 min_frag ; __s32 max_frag ; __s32 min_pmp ; __s32 max_pmp ; __s32 min_pmt ; __s32 max_pmt ; __u16 pmp_flags ; __u16 pmt_flags ; __u16 pm_capa ; __u16 encoding_size [ 8 ] ; __u8 num_encoding_sizes ; __u8 max_encoding_tokens ; __u8 encoding_login_index ; __u16 txpower_capa ; __u8 num_txpower ; __s32 txpower [ 8 ] ; __u8 we_version_compiled ; __u8 we_version_source ; __u16 retry_capa ; __u16 retry_flags ; __u16 r_time_flags ; __s32 min_retry ; __s32 max_retry ; __s32 min_r_time ; __s32 max_r_time ; __u16 num_channels ; __u8 num_frequency ; struct iw_freq freq [ 32 ] ; __u32 enc_capa ; } ;

struct iw_priv_args { __u32 cmd ; __u16 set_args ; __u16 get_args ; char name [ 16 ] ; } ;

struct iw_event { __u16 len ; __u16 cmd ; union iwreq_data u ; } ;

struct __compat_iw_event { __u16 len ; __u16 cmd ; compat_caddr_t pointer ; } ;

struct compat_msghdr { compat_uptr_t msg_name ; compat_int_t msg_namelen ; compat_uptr_t msg_iov ; compat_size_t msg_iovlen ; compat_uptr_t msg_control ; compat_size_t msg_controllen ; compat_uint_t msg_flags ; } ;

struct compat_cmsghdr { compat_size_t cmsg_len ; compat_int_t cmsg_level ; compat_int_t cmsg_type ; } ;

int move_addr_to_kernel ( void * uaddr , int ulen , struct sockaddr * kaddr ) ;

int move_addr_to_user ( struct sockaddr * kaddr , int klen , void * uaddr , int * ulen ) ;

int sock_map_fd ( struct socket * sock , int flags ) ;

struct socket * sockfd_lookup ( int fd , int * err ) ;

void sock_release ( struct socket * sock ) ;

int sock_tx_timestamp ( struct msghdr * msg , struct sock * sk , union skb_shared_tx * shtx ) ;

int sock_sendmsg ( struct socket * sock , struct msghdr * msg , size_t size ) ;

int kernel_sendmsg ( struct socket * sock , struct msghdr * msg , struct kvec * vec , size_t num , size_t size ) ;

void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) ;

int sock_recvmsg ( struct socket * sock , struct msghdr * msg , size_t size , int flags ) ;

int kernel_recvmsg ( struct socket * sock , struct msghdr * msg , struct kvec * vec , size_t num , size_t size , int flags ) ;

void brioctl_set ( int ( * hook ) ( struct net * , unsigned int , void * ) ) ;

void vlan_ioctl_set ( int ( * hook ) ( struct net * , void * ) ) ;

void dlci_ioctl_set ( int ( * hook ) ( unsigned int , void * ) ) ;

int sock_create_lite ( int family , int type , int protocol , struct socket * * res ) ;

int sock_wake_async ( struct socket * sock , int how , int band ) ;

int sock_create ( int family , int type , int protocol , struct socket * * res ) ;

int sock_create_kern ( int family , int type , int protocol , struct socket * * res ) ;

long sys_socket ( int family , int type , int protocol ) ;

long sys_socketpair ( int family , int type , int protocol , int * usockvec ) ;

long sys_bind ( int fd , struct sockaddr * umyaddr , int addrlen ) ;

long sys_listen ( int fd , int backlog ) ;

long sys_accept4 ( int fd , struct sockaddr * upeer_sockaddr , int * upeer_addrlen , int flags ) ;

long sys_accept ( int fd , struct sockaddr * upeer_sockaddr , int * upeer_addrlen ) ;

long sys_connect ( int fd , struct sockaddr * uservaddr , int addrlen ) ;

long sys_getsockname ( int fd , struct sockaddr * usockaddr , int * usockaddr_len ) ;

long sys_getpeername ( int fd , struct sockaddr * usockaddr , int * usockaddr_len ) ;

long sys_sendto ( int fd , void * buff , size_t len , unsigned flags , struct sockaddr * addr , int addr_len ) ;

long sys_send ( int fd , void * buff , size_t len , unsigned flags ) ;

long sys_recvfrom ( int fd , void * ubuf , size_t size , unsigned flags , struct sockaddr * addr , int * addr_len ) ;

long sys_recv ( int fd , void * ubuf , size_t size , unsigned flags ) ;

long sys_setsockopt ( int fd , int level , int optname , char * optval , int optlen ) ;

long sys_getsockopt ( int fd , int level , int optname , char * optval , int * optlen ) ;

long sys_shutdown ( int fd , int how ) ;

long sys_sendmsg ( int fd , struct msghdr * msg , unsigned flags ) ;

long sys_recvmsg ( int fd , struct msghdr * msg , unsigned int flags ) ;

long sys_socketcall ( int call , unsigned long * args ) ;

int sock_register ( const struct net_proto_family * ops ) ;

void sock_unregister ( int family ) ;

void socket_seq_show ( struct seq_file * seq ) ;

int kernel_bind ( struct socket * sock , struct sockaddr * addr , int addrlen ) ;

int kernel_listen ( struct socket * sock , int backlog ) ;

int kernel_accept ( struct socket * sock , struct socket * * newsock , int flags ) ;

int kernel_connect ( struct socket * sock , struct sockaddr * addr , int addrlen , int flags ) ;

int kernel_getsockname ( struct socket * sock , struct sockaddr * addr , int * addrlen ) ;

int kernel_getpeername ( struct socket * sock , struct sockaddr * addr , int * addrlen ) ;

int kernel_getsockopt ( struct socket * sock , int level , int optname , char * optval , int * optlen ) ;

int kernel_setsockopt ( struct socket * sock , int level , int optname , char * optval , unsigned int optlen ) ;

int kernel_sendpage ( struct socket * sock , struct page * page , int offset , size_t size , int flags ) ;

int kernel_sock_ioctl ( struct socket * sock , int cmd , unsigned long arg ) ;

int kernel_sock_shutdown ( struct socket * sock , enum sock_shutdown_cmd how ) ;

struct datalink_proto { unsigned char type [ 8 ] ; struct llc_sap * sap ; unsigned short header_length ; int ( * rcvfunc ) ( struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ; int ( * request ) ( struct datalink_proto * , struct sk_buff * , unsigned char * ) ; struct list_head node ; } ;

struct llc_addr { unsigned char lsap ; unsigned char mac [ 6 ] ; } ;

struct llc_sap { unsigned char state ; unsigned char p_bit ; unsigned char f_bit ; atomic_t refcnt ; int ( * rcv_func ) ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) ; struct llc_addr laddr ; struct list_head node ; struct { rwlock_t lock ; struct hlist_head list ; } sk_list ; } ;

struct datalink_proto * register_8022_client ( unsigned char type , int ( * func ) ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) ) ;

void unregister_8022_client ( struct datalink_proto * proto ) ;

struct datalink_proto * register_snap_client ( const unsigned char * desc , int ( * rcvfunc ) ( struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ) ;

void unregister_snap_client ( struct datalink_proto * proto ) ;

struct rif_cache { unsigned char addr [ 6 ] ; int iface ; __be16 rcf ; __be16 rseg [ 8 ] ; struct rif_cache * next ; unsigned long last_used ; unsigned char local_ring ; } ;

__be16 tr_type_trans ( struct sk_buff * skb , struct net_device * dev ) ;

void tr_source_route ( struct sk_buff * skb , struct trh_hdr * trh , struct net_device * dev ) ;

struct net_device * alloc_trdev ( int sizeof_priv ) ;

struct fch_hdr { __u8 daddr [ 6 ] ; __u8 saddr [ 6 ] ; } ;

struct fcllc { __u8 dsap ; __u8 ssap ; __u8 llc ; __u8 protid [ 3 ] ; __be16 ethertype ; } ;

struct net_device * alloc_fcdev ( int sizeof_priv ) ;

struct fddi_8022_1_hdr { __u8 dsap ; __u8 ssap ; __u8 ctrl ; } __attribute__ ( ( packed ) ) ;
struct fddi_8022_2_hdr { __u8 dsap ; __u8 ssap ; __u8 ctrl_1 ; __u8 ctrl_2 ; } __attribute__ ( ( packed ) ) ;
struct fddi_snap_hdr { __u8 dsap ; __u8 ssap ; __u8 ctrl ; __u8 oui [ 3 ] ; __be16 ethertype ; } __attribute__ ( ( packed ) ) ;
struct fddihdr { __u8 fc ; __u8 daddr [ 6 ] ; __u8 saddr [ 6 ] ; union { struct fddi_8022_1_hdr llc_8022_1 ; struct fddi_8022_2_hdr llc_8022_2 ; struct fddi_snap_hdr llc_snap ; } hdr ; } __attribute__ ( ( packed ) ) ;
struct fddi_statistics { struct net_device_stats gen ; __u8 smt_station_id [ 8 ] ; __u32 smt_op_version_id ; __u32 smt_hi_version_id ; __u32 smt_lo_version_id ; __u8 smt_user_data [ 32 ] ; __u32 smt_mib_version_id ; __u32 smt_mac_cts ; __u32 smt_non_master_cts ; __u32 smt_master_cts ; __u32 smt_available_paths ; __u32 smt_config_capabilities ; __u32 smt_config_policy ; __u32 smt_connection_policy ; __u32 smt_t_notify ; __u32 smt_stat_rpt_policy ; __u32 smt_trace_max_expiration ; __u32 smt_bypass_present ; __u32 smt_ecm_state ; __u32 smt_cf_state ; __u32 smt_remote_disconnect_flag ; __u32 smt_station_status ; __u32 smt_peer_wrap_flag ; __u32 smt_time_stamp ; __u32 smt_transition_time_stamp ; __u32 mac_frame_status_functions ; __u32 mac_t_max_capability ; __u32 mac_tvx_capability ; __u32 mac_available_paths ; __u32 mac_current_path ; __u8 mac_upstream_nbr [ 6 ] ; __u8 mac_downstream_nbr [ 6 ] ; __u8 mac_old_upstream_nbr [ 6 ] ; __u8 mac_old_downstream_nbr [ 6 ] ; __u32 mac_dup_address_test ; __u32 mac_requested_paths ; __u32 mac_downstream_port_type ; __u8 mac_smt_address [ 6 ] ; __u32 mac_t_req ; __u32 mac_t_neg ; __u32 mac_t_max ; __u32 mac_tvx_value ; __u32 mac_frame_cts ; __u32 mac_copied_cts ; __u32 mac_transmit_cts ; __u32 mac_error_cts ; __u32 mac_lost_cts ; __u32 mac_frame_error_threshold ; __u32 mac_frame_error_ratio ; __u32 mac_rmt_state ; __u32 mac_da_flag ; __u32 mac_una_da_flag ; __u32 mac_frame_error_flag ; __u32 mac_ma_unitdata_available ; __u32 mac_hardware_present ; __u32 mac_ma_unitdata_enable ; __u32 path_tvx_lower_bound ; __u32 path_t_max_lower_bound ; __u32 path_max_t_req ; __u32 path_configuration [ 8 ] ; __u32 port_my_type [ 2 ] ; __u32 port_neighbor_type [ 2 ] ; __u32 port_connection_policies [ 2 ] ; __u32 port_mac_indicated [ 2 ] ; __u32 port_current_path [ 2 ] ; __u8 port_requested_paths [ 3 * 2 ] ; __u32 port_mac_placement [ 2 ] ; __u32 port_available_paths [ 2 ] ; __u32 port_pmd_class [ 2 ] ; __u32 port_connection_capabilities [ 2 ] ; __u32 port_bs_flag [ 2 ] ; __u32 port_lct_fail_cts [ 2 ] ; __u32 port_ler_estimate [ 2 ] ; __u32 port_lem_reject_cts [ 2 ] ; __u32 port_lem_cts [ 2 ] ; __u32 port_ler_cutoff [ 2 ] ; __u32 port_ler_alarm [ 2 ] ; __u32 port_connect_state [ 2 ] ; __u32 port_pcm_state [ 2 ] ; __u32 port_pc_withhold [ 2 ] ; __u32 port_ler_flag [ 2 ] ; __u32 port_hardware_present [ 2 ] ; } ;

__be16 fddi_type_trans ( struct sk_buff * skb , struct net_device * dev ) ;

int fddi_change_mtu ( struct net_device * dev , int new_mtu ) ;

struct net_device * alloc_fddidev ( int sizeof_priv ) ;

struct hipnet_statistics { int rx_packets ; int tx_packets ; int rx_errors ; int tx_errors ; int rx_dropped ; int tx_dropped ; int rx_length_errors ; int rx_over_errors ; int rx_crc_errors ; int rx_frame_errors ; int rx_fifo_errors ; int rx_missed_errors ; int tx_aborted_errors ; int tx_carrier_errors ; int tx_fifo_errors ; int tx_heartbeat_errors ; int tx_window_errors ; } ;

struct hippi_fp_hdr { __be32 fixed ; __be32 d2_size ; } __attribute__ ( ( packed ) ) ;
struct hippi_le_hdr { __u8 message_type : 4 ; __u8 double_wide : 1 ; __u8 fc : 3 ; __u8 dest_switch_addr [ 3 ] ; __u8 src_addr_type : 4 , dest_addr_type : 4 ; __u8 src_switch_addr [ 3 ] ; __u16 reserved ; __u8 daddr [ 6 ] ; __u16 locally_administered ; __u8 saddr [ 6 ] ; } __attribute__ ( ( packed ) ) ;
struct hippi_snap_hdr { __u8 dsap ; __u8 ssap ; __u8 ctrl ; __u8 oui [ 3 ] ; __be16 ethertype ; } __attribute__ ( ( packed ) ) ;
struct hippi_hdr { struct hippi_fp_hdr fp ; struct hippi_le_hdr le ; struct hippi_snap_hdr snap ; } __attribute__ ( ( packed ) ) ;
struct hippi_cb { __u32 ifield ; } ;

__be16 hippi_type_trans ( struct sk_buff * skb , struct net_device * dev ) ;

int hippi_change_mtu ( struct net_device * dev , int new_mtu ) ;

int hippi_mac_addr ( struct net_device * dev , void * p ) ;

int hippi_neigh_setup_dev ( struct net_device * dev , struct neigh_parms * p ) ;

struct net_device * alloc_hippi_dev ( int sizeof_priv ) ;

enum { SOF_TIMESTAMPING_TX_HARDWARE = ( 1 << 0 ) , SOF_TIMESTAMPING_TX_SOFTWARE = ( 1 << 1 ) , SOF_TIMESTAMPING_RX_HARDWARE = ( 1 << 2 ) , SOF_TIMESTAMPING_RX_SOFTWARE = ( 1 << 3 ) , SOF_TIMESTAMPING_SOFTWARE = ( 1 << 4 ) , SOF_TIMESTAMPING_SYS_HARDWARE = ( 1 << 5 ) , SOF_TIMESTAMPING_RAW_HARDWARE = ( 1 << 6 ) , SOF_TIMESTAMPING_MASK = ( SOF_TIMESTAMPING_RAW_HARDWARE - 1 ) | SOF_TIMESTAMPING_RAW_HARDWARE } ;
struct hwtstamp_config { int flags ; int tx_type ; int rx_filter ; } ;

enum { HWTSTAMP_TX_OFF , HWTSTAMP_TX_ON , } ;
enum { HWTSTAMP_FILTER_NONE , HWTSTAMP_FILTER_ALL , HWTSTAMP_FILTER_SOME , HWTSTAMP_FILTER_PTP_V1_L4_EVENT , HWTSTAMP_FILTER_PTP_V1_L4_SYNC , HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ , HWTSTAMP_FILTER_PTP_V2_L4_EVENT , HWTSTAMP_FILTER_PTP_V2_L4_SYNC , HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ , HWTSTAMP_FILTER_PTP_V2_L2_EVENT , HWTSTAMP_FILTER_PTP_V2_L2_SYNC , HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ , HWTSTAMP_FILTER_PTP_V2_EVENT , HWTSTAMP_FILTER_PTP_V2_SYNC , HWTSTAMP_FILTER_PTP_V2_DELAY_REQ , } ;
struct sadb_msg { __u8 sadb_msg_version ; __u8 sadb_msg_type ; __u8 sadb_msg_errno ; __u8 sadb_msg_satype ; __u16 sadb_msg_len ; __u16 sadb_msg_reserved ; __u32 sadb_msg_seq ; __u32 sadb_msg_pid ; } __attribute__ ( ( packed ) ) ;
struct sadb_ext { __u16 sadb_ext_len ; __u16 sadb_ext_type ; } __attribute__ ( ( packed ) ) ;
struct sadb_sa { __u16 sadb_sa_len ; __u16 sadb_sa_exttype ; __be32 sadb_sa_spi ; __u8 sadb_sa_replay ; __u8 sadb_sa_state ; __u8 sadb_sa_auth ; __u8 sadb_sa_encrypt ; __u32 sadb_sa_flags ; } __attribute__ ( ( packed ) ) ;
struct sadb_lifetime { __u16 sadb_lifetime_len ; __u16 sadb_lifetime_exttype ; __u32 sadb_lifetime_allocations ; __u64 sadb_lifetime_bytes ; __u64 sadb_lifetime_addtime ; __u64 sadb_lifetime_usetime ; } __attribute__ ( ( packed ) ) ;
struct sadb_address { __u16 sadb_address_len ; __u16 sadb_address_exttype ; __u8 sadb_address_proto ; __u8 sadb_address_prefixlen ; __u16 sadb_address_reserved ; } __attribute__ ( ( packed ) ) ;
struct sadb_key { __u16 sadb_key_len ; __u16 sadb_key_exttype ; __u16 sadb_key_bits ; __u16 sadb_key_reserved ; } __attribute__ ( ( packed ) ) ;
struct sadb_ident { __u16 sadb_ident_len ; __u16 sadb_ident_exttype ; __u16 sadb_ident_type ; __u16 sadb_ident_reserved ; __u64 sadb_ident_id ; } __attribute__ ( ( packed ) ) ;
struct sadb_sens { __u16 sadb_sens_len ; __u16 sadb_sens_exttype ; __u32 sadb_sens_dpd ; __u8 sadb_sens_sens_level ; __u8 sadb_sens_sens_len ; __u8 sadb_sens_integ_level ; __u8 sadb_sens_integ_len ; __u32 sadb_sens_reserved ; } __attribute__ ( ( packed ) ) ;
struct sadb_prop { __u16 sadb_prop_len ; __u16 sadb_prop_exttype ; __u8 sadb_prop_replay ; __u8 sadb_prop_reserved [ 3 ] ; } __attribute__ ( ( packed ) ) ;
struct sadb_comb { __u8 sadb_comb_auth ; __u8 sadb_comb_encrypt ; __u16 sadb_comb_flags ; __u16 sadb_comb_auth_minbits ; __u16 sadb_comb_auth_maxbits ; __u16 sadb_comb_encrypt_minbits ; __u16 sadb_comb_encrypt_maxbits ; __u32 sadb_comb_reserved ; __u32 sadb_comb_soft_allocations ; __u32 sadb_comb_hard_allocations ; __u64 sadb_comb_soft_bytes ; __u64 sadb_comb_hard_bytes ; __u64 sadb_comb_soft_addtime ; __u64 sadb_comb_hard_addtime ; __u64 sadb_comb_soft_usetime ; __u64 sadb_comb_hard_usetime ; } __attribute__ ( ( packed ) ) ;
struct sadb_supported { __u16 sadb_supported_len ; __u16 sadb_supported_exttype ; __u32 sadb_supported_reserved ; } __attribute__ ( ( packed ) ) ;
struct sadb_alg { __u8 sadb_alg_id ; __u8 sadb_alg_ivlen ; __u16 sadb_alg_minbits ; __u16 sadb_alg_maxbits ; __u16 sadb_alg_reserved ; } __attribute__ ( ( packed ) ) ;
struct sadb_spirange { __u16 sadb_spirange_len ; __u16 sadb_spirange_exttype ; __u32 sadb_spirange_min ; __u32 sadb_spirange_max ; __u32 sadb_spirange_reserved ; } __attribute__ ( ( packed ) ) ;
struct sadb_x_kmprivate { __u16 sadb_x_kmprivate_len ; __u16 sadb_x_kmprivate_exttype ; __u32 sadb_x_kmprivate_reserved ; } __attribute__ ( ( packed ) ) ;
struct sadb_x_sa2 { __u16 sadb_x_sa2_len ; __u16 sadb_x_sa2_exttype ; __u8 sadb_x_sa2_mode ; __u8 sadb_x_sa2_reserved1 ; __u16 sadb_x_sa2_reserved2 ; __u32 sadb_x_sa2_sequence ; __u32 sadb_x_sa2_reqid ; } __attribute__ ( ( packed ) ) ;
struct sadb_x_policy { __u16 sadb_x_policy_len ; __u16 sadb_x_policy_exttype ; __u16 sadb_x_policy_type ; __u8 sadb_x_policy_dir ; __u8 sadb_x_policy_reserved ; __u32 sadb_x_policy_id ; __u32 sadb_x_policy_priority ; } __attribute__ ( ( packed ) ) ;
struct sadb_x_ipsecrequest { __u16 sadb_x_ipsecrequest_len ; __u16 sadb_x_ipsecrequest_proto ; __u8 sadb_x_ipsecrequest_mode ; __u8 sadb_x_ipsecrequest_level ; __u16 sadb_x_ipsecrequest_reserved1 ; __u32 sadb_x_ipsecrequest_reqid ; __u32 sadb_x_ipsecrequest_reserved2 ; } __attribute__ ( ( packed ) ) ;
struct sadb_x_nat_t_type { __u16 sadb_x_nat_t_type_len ; __u16 sadb_x_nat_t_type_exttype ; __u8 sadb_x_nat_t_type_type ; __u8 sadb_x_nat_t_type_reserved [ 3 ] ; } __attribute__ ( ( packed ) ) ;
struct sadb_x_nat_t_port { __u16 sadb_x_nat_t_port_len ; __u16 sadb_x_nat_t_port_exttype ; __be16 sadb_x_nat_t_port_port ; __u16 sadb_x_nat_t_port_reserved ; } __attribute__ ( ( packed ) ) ;
struct sadb_x_sec_ctx { __u16 sadb_x_sec_len ; __u16 sadb_x_sec_exttype ; __u8 sadb_x_ctx_alg ; __u8 sadb_x_ctx_doi ; __u16 sadb_x_ctx_len ; } __attribute__ ( ( packed ) ) ;
struct sadb_x_kmaddress { __u16 sadb_x_kmaddress_len ; __u16 sadb_x_kmaddress_exttype ; __u32 sadb_x_kmaddress_reserved ; } __attribute__ ( ( packed ) ) ;
enum { IPSEC_MODE_ANY = 0 , IPSEC_MODE_TRANSPORT = 1 , IPSEC_MODE_TUNNEL = 2 , IPSEC_MODE_BEET = 3 } ;
enum { IPSEC_DIR_ANY = 0 , IPSEC_DIR_INBOUND = 1 , IPSEC_DIR_OUTBOUND = 2 , IPSEC_DIR_FWD = 3 , IPSEC_DIR_MAX = 4 , IPSEC_DIR_INVALID = 5 } ;
enum { IPSEC_POLICY_DISCARD = 0 , IPSEC_POLICY_NONE = 1 , IPSEC_POLICY_IPSEC = 2 , IPSEC_POLICY_ENTRUST = 3 , IPSEC_POLICY_BYPASS = 4 } ;
enum { IPSEC_LEVEL_DEFAULT = 0 , IPSEC_LEVEL_USE = 1 , IPSEC_LEVEL_REQUIRE = 2 , IPSEC_LEVEL_UNIQUE = 3 } ;
struct rt6_info ;

struct fib6_config { u32 fc_table ; u32 fc_metric ; int fc_dst_len ; int fc_src_len ; int fc_ifindex ; u32 fc_flags ; u32 fc_protocol ; struct in6_addr fc_dst ; struct in6_addr fc_src ; struct in6_addr fc_gateway ; unsigned long fc_expires ; struct nlattr * fc_mx ; int fc_mx_len ; struct nl_info fc_nlinfo ; } ;

struct fib6_node { struct fib6_node * parent ; struct fib6_node * left ; struct fib6_node * right ; struct rt6_info * leaf ; __u16 fn_bit ; __u16 fn_flags ; __u32 fn_sernum ; struct rt6_info * rr_ptr ; } ;

struct rt6key { struct in6_addr addr ; int plen ; } ;

struct fib6_table ;

struct rt6_info { union { struct dst_entry dst ; } u ; struct inet6_dev * rt6i_idev ; struct fib6_node * rt6i_node ; struct in6_addr rt6i_gateway ; u32 rt6i_flags ; u32 rt6i_metric ; atomic_t rt6i_ref ; unsigned short rt6i_nfheader_len ; u8 rt6i_protocol ; struct fib6_table * rt6i_table ; struct rt6key rt6i_dst ; struct rt6key rt6i_src ; } ;
struct fib6_walker_t { struct fib6_walker_t * prev , * next ; struct fib6_node * root , * node ; struct rt6_info * leaf ; unsigned char state ; unsigned char prune ; int ( * func ) ( struct fib6_walker_t * ) ; void * args ; } ;

struct rt6_statistics { __u32 fib_nodes ; __u32 fib_route_nodes ; __u32 fib_rt_alloc ; __u32 fib_rt_entries ; __u32 fib_rt_cache ; __u32 fib_discarded_routes ; } ;

struct fib6_table { struct hlist_node tb6_hlist ; u32 tb6_id ; rwlock_t tb6_lock ; struct fib6_node tb6_root ; } ;
typedef struct rt6_info * ( * pol_lookup_t ) ( struct net * , struct fib6_table * , struct flowi * , int ) ;
struct xfrm_state_walk { struct list_head all ; u8 state ; union { u8 dying ; u8 proto ; } ; u32 seq ; } ;

struct xfrm_state { struct net * xs_net ; union { struct hlist_node gclist ; struct hlist_node bydst ; } ; struct hlist_node bysrc ; struct hlist_node byspi ; atomic_t refcnt ; spinlock_t lock ; struct xfrm_id id ; struct xfrm_selector sel ; u32 genid ; struct xfrm_state_walk km ; struct { u32 reqid ; u8 mode ; u8 replay_window ; u8 aalgo , ealgo , calgo ; u8 flags ; u16 family ; xfrm_address_t saddr ; int header_len ; int trailer_len ; } props ; struct xfrm_lifetime_cfg lft ; struct xfrm_algo * aalg ; struct xfrm_algo * ealg ; struct xfrm_algo * calg ; struct xfrm_algo_aead * aead ; struct xfrm_encap_tmpl * encap ; xfrm_address_t * coaddr ; struct xfrm_state * tunnel ; atomic_t tunnel_users ; struct xfrm_replay_state replay ; struct xfrm_replay_state preplay ; u32 xflags ; u32 replay_maxage ; u32 replay_maxdiff ; struct timer_list rtimer ; struct xfrm_stats stats ; struct xfrm_lifetime_cur curlft ; struct timer_list timer ; unsigned long lastused ; const struct xfrm_type * type ; struct xfrm_mode * inner_mode ; struct xfrm_mode * inner_mode_iaf ; struct xfrm_mode * outer_mode ; struct xfrm_sec_ctx * security ; void * data ; } ;
enum { XFRM_STATE_VOID , XFRM_STATE_ACQ , XFRM_STATE_VALID , XFRM_STATE_ERROR , XFRM_STATE_EXPIRED , XFRM_STATE_DEAD } ;
struct km_event { union { u32 hard ; u32 proto ; u32 byid ; u32 aevent ; u32 type ; } data ; u32 seq ; u32 pid ; u32 event ; struct net * net ; } ;

struct xfrm_type ;

struct xfrm_dst ;

struct xfrm_policy_afinfo { unsigned short family ; struct dst_ops * dst_ops ; void ( * garbage_collect ) ( struct net * net ) ; struct dst_entry * ( * dst_lookup ) ( struct net * net , int tos , xfrm_address_t * saddr , xfrm_address_t * daddr ) ; int ( * get_saddr ) ( struct net * net , xfrm_address_t * saddr , xfrm_address_t * daddr ) ; struct dst_entry * ( * find_bundle ) ( struct flowi * fl , struct xfrm_policy * policy ) ; void ( * decode_session ) ( struct sk_buff * skb , struct flowi * fl , int reverse ) ; int ( * get_tos ) ( struct flowi * fl ) ; int ( * init_path ) ( struct xfrm_dst * path , struct dst_entry * dst , int nfheader_len ) ; int ( * fill_dst ) ( struct xfrm_dst * xdst , struct net_device * dev ) ; } ;

struct xfrm_tmpl ;

struct xfrm_state_afinfo { unsigned int family ; unsigned int proto ; __be16 eth_proto ; struct module * owner ; const struct xfrm_type * type_map [ IPPROTO_MAX ] ; struct xfrm_mode * mode_map [ 5 ] ; int ( * init_flags ) ( struct xfrm_state * x ) ; void ( * init_tempsel ) ( struct xfrm_state * x , struct flowi * fl , struct xfrm_tmpl * tmpl , xfrm_address_t * daddr , xfrm_address_t * saddr ) ; int ( * tmpl_sort ) ( struct xfrm_tmpl * * dst , struct xfrm_tmpl * * src , int n ) ; int ( * state_sort ) ( struct xfrm_state * * dst , struct xfrm_state * * src , int n ) ; int ( * output ) ( struct sk_buff * skb ) ; int ( * extract_input ) ( struct xfrm_state * x , struct sk_buff * skb ) ; int ( * extract_output ) ( struct xfrm_state * x , struct sk_buff * skb ) ; int ( * transport_finish ) ( struct sk_buff * skb , int async ) ; } ;

struct xfrm_type { char * description ; struct module * owner ; __u8 proto ; __u8 flags ; int ( * init_state ) ( struct xfrm_state * x ) ; void ( * destructor ) ( struct xfrm_state * ) ; int ( * input ) ( struct xfrm_state * , struct sk_buff * skb ) ; int ( * output ) ( struct xfrm_state * , struct sk_buff * pskb ) ; int ( * reject ) ( struct xfrm_state * , struct sk_buff * , struct flowi * ) ; int ( * hdr_offset ) ( struct xfrm_state * , struct sk_buff * , u8 * * ) ; u32 ( * get_mtu ) ( struct xfrm_state * , int size ) ; } ;
struct xfrm_mode { int ( * input2 ) ( struct xfrm_state * x , struct sk_buff * skb ) ; int ( * input ) ( struct xfrm_state * x , struct sk_buff * skb ) ; int ( * output2 ) ( struct xfrm_state * x , struct sk_buff * skb ) ; int ( * output ) ( struct xfrm_state * x , struct sk_buff * skb ) ; struct xfrm_state_afinfo * afinfo ; struct module * owner ; unsigned int encap ; int flags ; } ;

enum { XFRM_MODE_FLAG_TUNNEL = 1 , } ;
struct xfrm_tmpl { struct xfrm_id id ; xfrm_address_t saddr ; unsigned short encap_family ; __u32 reqid ; __u8 mode ; __u8 share ; __u8 optional ; __u8 allalgs ; __u32 aalgos ; __u32 ealgos ; __u32 calgos ; } ;
struct xfrm_policy_walk_entry { struct list_head all ; u8 dead ; } ;

struct xfrm_policy_walk { struct xfrm_policy_walk_entry walk ; u8 type ; u32 seq ; } ;

struct xfrm_policy { struct net * xp_net ; struct hlist_node bydst ; struct hlist_node byidx ; rwlock_t lock ; atomic_t refcnt ; struct timer_list timer ; u32 priority ; u32 index ; struct xfrm_selector selector ; struct xfrm_lifetime_cfg lft ; struct xfrm_lifetime_cur curlft ; struct dst_entry * bundles ; struct xfrm_policy_walk_entry walk ; u8 type ; u8 action ; u8 flags ; u8 xfrm_nr ; u16 family ; struct xfrm_sec_ctx * security ; struct xfrm_tmpl xfrm_vec [ 6 ] ; } ;
struct xfrm_kmaddress { xfrm_address_t local ; xfrm_address_t remote ; u32 reserved ; u16 family ; } ;

struct xfrm_migrate { xfrm_address_t old_daddr ; xfrm_address_t old_saddr ; xfrm_address_t new_daddr ; xfrm_address_t new_saddr ; u8 proto ; u8 mode ; u16 reserved ; u32 reqid ; u16 old_family ; u16 new_family ; } ;

struct xfrm_mgr { struct list_head list ; char * id ; int ( * notify ) ( struct xfrm_state * x , struct km_event * c ) ; int ( * acquire ) ( struct xfrm_state * x , struct xfrm_tmpl * , struct xfrm_policy * xp , int dir ) ; struct xfrm_policy * ( * compile_policy ) ( struct sock * sk , int opt , u8 * data , int len , int * dir ) ; int ( * new_mapping ) ( struct xfrm_state * x , xfrm_address_t * ipaddr , __be16 sport ) ; int ( * notify_policy ) ( struct xfrm_policy * x , int dir , struct km_event * c ) ; int ( * report ) ( struct net * net , u8 proto , struct xfrm_selector * sel , xfrm_address_t * addr ) ; int ( * migrate ) ( struct xfrm_selector * sel , u8 dir , u8 type , struct xfrm_migrate * m , int num_bundles , struct xfrm_kmaddress * k ) ; } ;

struct xfrm_skb_cb { union { struct inet_skb_parm h4 ; struct inet6_skb_parm h6 ; } header ; union { u64 output ; __be32 input ; } seq ; } ;

struct xfrm_mode_skb_cb { union { struct inet_skb_parm h4 ; struct inet6_skb_parm h6 ; } header ; __be16 id ; __be16 frag_off ; u8 ihl ; u8 tos ; u8 ttl ; u8 protocol ; u8 optlen ; u8 flow_lbl [ 3 ] ; } ;

struct xfrm_spi_skb_cb { union { struct inet_skb_parm h4 ; struct inet6_skb_parm h6 ; } header ; unsigned int daddroff ; unsigned int family ; } ;

struct xfrm_audit { u32 secid ; uid_t loginuid ; u32 sessionid ; } ;

struct xfrm_dst { union { struct dst_entry dst ; struct rtable rt ; struct rt6_info rt6 ; } u ; struct dst_entry * route ; u32 genid ; u32 route_mtu_cached ; u32 child_mtu_cached ; u32 route_cookie ; u32 path_cookie ; } ;
struct sec_path { atomic_t refcnt ; int len ; struct xfrm_state * xvec [ 6 ] ; } ;

struct xfrm_algo_aead_info { u16 icv_truncbits ; } ;

struct xfrm_algo_auth_info { u16 icv_truncbits ; u16 icv_fullbits ; } ;

struct xfrm_algo_encr_info { u16 blockbits ; u16 defkeybits ; } ;

struct xfrm_algo_comp_info { u16 threshold ; } ;

struct xfrm_algo_desc { char * name ; char * compat ; u8 available : 1 ; union { struct xfrm_algo_aead_info aead ; struct xfrm_algo_auth_info auth ; struct xfrm_algo_encr_info encr ; struct xfrm_algo_comp_info comp ; } uinfo ; struct sadb_alg desc ; } ;

struct xfrm_tunnel { int ( * handler ) ( struct sk_buff * skb ) ; int ( * err_handler ) ( struct sk_buff * skb , __u32 info ) ; struct xfrm_tunnel * next ; int priority ; } ;

struct xfrm6_tunnel { int ( * handler ) ( struct sk_buff * skb ) ; int ( * err_handler ) ( struct sk_buff * skb , struct inet6_skb_parm * opt , u8 type , u8 code , int offset , __be32 info ) ; struct xfrm6_tunnel * next ; int priority ; } ;

struct xfrmk_sadinfo { u32 sadhcnt ; u32 sadhmcnt ; u32 sadcnt ; } ;

struct xfrmk_spdinfo { u32 incnt ; u32 outcnt ; u32 fwdcnt ; u32 inscnt ; u32 outscnt ; u32 fwdscnt ; u32 spdhcnt ; u32 spdhmcnt ; } ;

struct hash_desc ;
typedef int ( icv_update_fn_t ) ( struct hash_desc * , struct scatterlist * , unsigned int ) ;
int sock_queue_rcv_skb ( struct sock * sk , struct sk_buff * skb ) ;

int sk_receive_skb ( struct sock * sk , struct sk_buff * skb , const int nested ) ;

struct dst_entry * __sk_dst_check ( struct sock * sk , u32 cookie ) ;

struct dst_entry * sk_dst_check ( struct sock * sk , u32 cookie ) ;

int sock_setsockopt ( struct socket * sock , int level , int optname , char * optval , unsigned int optlen ) ;

int sock_getsockopt ( struct socket * sock , int level , int optname , char * optval , int * optlen ) ;

struct sock * sk_alloc ( struct net * net , int family , gfp_t priority , struct proto * prot ) ;

void sk_free ( struct sock * sk ) ;

void sk_release_kernel ( struct sock * sk ) ;

struct sock * sk_clone ( const struct sock * sk , const gfp_t priority ) ;

void sk_setup_caps ( struct sock * sk , struct dst_entry * dst ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) sk_init ( void ) ;

void sock_wfree ( struct sk_buff * skb ) ;

void sock_rfree ( struct sk_buff * skb ) ;

int sock_i_uid ( struct sock * sk ) ;

unsigned long sock_i_ino ( struct sock * sk ) ;

struct sk_buff * sock_wmalloc ( struct sock * sk , unsigned long size , int force , gfp_t priority ) ;

struct sk_buff * sock_rmalloc ( struct sock * sk , unsigned long size , int force , gfp_t priority ) ;

void * sock_kmalloc ( struct sock * sk , int size , gfp_t priority ) ;

void sock_kfree_s ( struct sock * sk , void * mem , int size ) ;

struct sk_buff * sock_alloc_send_pskb ( struct sock * sk , unsigned long header_len , unsigned long data_len , int noblock , int * errcode ) ;

struct sk_buff * sock_alloc_send_skb ( struct sock * sk , unsigned long size , int noblock , int * errcode ) ;

int sk_wait_data ( struct sock * sk , long * timeo ) ;

int __sk_mem_schedule ( struct sock * sk , int size , int kind ) ;

void __sk_mem_reclaim ( struct sock * sk ) ;

int sock_no_bind ( struct socket * sock , struct sockaddr * saddr , int len ) ;

int sock_no_connect ( struct socket * sock , struct sockaddr * saddr , int len , int flags ) ;

int sock_no_socketpair ( struct socket * sock1 , struct socket * sock2 ) ;

int sock_no_accept ( struct socket * sock , struct socket * newsock , int flags ) ;

int sock_no_getname ( struct socket * sock , struct sockaddr * saddr , int * len , int peer ) ;

unsigned int sock_no_poll ( struct file * file , struct socket * sock , poll_table * pt ) ;

int sock_no_ioctl ( struct socket * sock , unsigned int cmd , unsigned long arg ) ;

int sock_no_listen ( struct socket * sock , int backlog ) ;

int sock_no_shutdown ( struct socket * sock , int how ) ;

int sock_no_setsockopt ( struct socket * sock , int level , int optname , char * optval , unsigned int optlen ) ;

int sock_no_getsockopt ( struct socket * sock , int level , int optname , char * optval , int * optlen ) ;

int sock_no_sendmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len ) ;

int sock_no_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) ;

int sock_no_mmap ( struct file * file , struct socket * sock , struct vm_area_struct * vma ) ;

ssize_t sock_no_sendpage ( struct socket * sock , struct page * page , int offset , size_t size , int flags ) ;

void sk_send_sigurg ( struct sock * sk ) ;

void sk_reset_timer ( struct sock * sk , struct timer_list * timer , unsigned long expires ) ;

void sk_stop_timer ( struct sock * sk , struct timer_list * timer ) ;

void sock_init_data ( struct socket * sock , struct sock * sk ) ;

void lock_sock_nested ( struct sock * sk , int subclass ) ;

void release_sock ( struct sock * sk ) ;

int sock_get_timestamp ( struct sock * sk , struct timeval * userstamp ) ;

int sock_get_timestampns ( struct sock * sk , struct timespec * userstamp ) ;

void sock_enable_timestamp ( struct sock * sk , int flag ) ;

int sock_common_getsockopt ( struct socket * sock , int level , int optname , char * optval , int * optlen ) ;

int compat_sock_common_getsockopt ( struct socket * sock , int level , int optname , char * optval , int * optlen ) ;

int sock_common_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) ;

int sock_common_setsockopt ( struct socket * sock , int level , int optname , char * optval , unsigned int optlen ) ;

int compat_sock_common_setsockopt ( struct socket * sock , int level , int optname , char * optval , unsigned int optlen ) ;

void sk_common_release ( struct sock * sk ) ;

struct prot_inuse { int val [ 64 ] ; } ;
void sock_prot_inuse_add ( struct net * net , struct proto * prot , int val ) ;

int sock_prot_inuse_get ( struct net * net , struct proto * prot ) ;

int proto_register ( struct proto * prot , int alloc_slab ) ;

void proto_unregister ( struct proto * prot ) ;

int reqsk_queue_alloc ( struct request_sock_queue * queue , unsigned int nr_table_entries ) ;

void __reqsk_queue_destroy ( struct request_sock_queue * queue ) ;

void reqsk_queue_destroy ( struct request_sock_queue * queue ) ;

struct tc_stats { __u64 bytes ; __u32 packets ; __u32 drops ; __u32 overlimits ; __u32 bps ; __u32 pps ; __u32 qlen ; __u32 backlog ; } ;

struct tc_estimator { signed char interval ; unsigned char ewma_log ; } ;

struct tc_ratespec { unsigned char cell_log ; unsigned char __reserved ; unsigned short overhead ; short cell_align ; unsigned short mpu ; __u32 rate ; } ;

struct tc_sizespec { unsigned char cell_log ; unsigned char size_log ; short cell_align ; int overhead ; unsigned int linklayer ; unsigned int mpu ; unsigned int mtu ; unsigned int tsize ; } ;

enum { TCA_STAB_UNSPEC , TCA_STAB_BASE , TCA_STAB_DATA , __TCA_STAB_MAX } ;
struct tc_fifo_qopt { __u32 limit ; } ;

struct tc_prio_qopt { int bands ; __u8 priomap [ 15 + 1 ] ; } ;

struct tc_multiq_qopt { __u16 bands ; __u16 max_bands ; } ;

struct tc_tbf_qopt { struct tc_ratespec rate ; struct tc_ratespec peakrate ; __u32 limit ; __u32 buffer ; __u32 mtu ; } ;

enum { TCA_TBF_UNSPEC , TCA_TBF_PARMS , TCA_TBF_RTAB , TCA_TBF_PTAB , __TCA_TBF_MAX , } ;
struct tc_sfq_qopt { unsigned quantum ; int perturb_period ; __u32 limit ; unsigned divisor ; unsigned flows ; } ;

struct tc_sfq_xstats { __s32 allot ; } ;

enum { TCA_RED_UNSPEC , TCA_RED_PARMS , TCA_RED_STAB , __TCA_RED_MAX , } ;
struct tc_red_qopt { __u32 limit ; __u32 qth_min ; __u32 qth_max ; unsigned char Wlog ; unsigned char Plog ; unsigned char Scell_log ; unsigned char flags ; } ;

struct tc_red_xstats { __u32 early ; __u32 pdrop ; __u32 other ; __u32 marked ; } ;

enum { TCA_GRED_UNSPEC , TCA_GRED_PARMS , TCA_GRED_STAB , TCA_GRED_DPS , __TCA_GRED_MAX , } ;
struct tc_gred_qopt { __u32 limit ; __u32 qth_min ; __u32 qth_max ; __u32 DP ; __u32 backlog ; __u32 qave ; __u32 forced ; __u32 early ; __u32 other ; __u32 pdrop ; __u8 Wlog ; __u8 Plog ; __u8 Scell_log ; __u8 prio ; __u32 packets ; __u32 bytesin ; } ;

struct tc_gred_sopt { __u32 DPs ; __u32 def_DP ; __u8 grio ; __u8 flags ; __u16 pad1 ; } ;

struct tc_htb_opt { struct tc_ratespec rate ; struct tc_ratespec ceil ; __u32 buffer ; __u32 cbuffer ; __u32 quantum ; __u32 level ; __u32 prio ; } ;

struct tc_htb_glob { __u32 version ; __u32 rate2quantum ; __u32 defcls ; __u32 debug ; __u32 direct_pkts ; } ;

enum { TCA_HTB_UNSPEC , TCA_HTB_PARMS , TCA_HTB_INIT , TCA_HTB_CTAB , TCA_HTB_RTAB , __TCA_HTB_MAX , } ;
struct tc_htb_xstats { __u32 lends ; __u32 borrows ; __u32 giants ; __u32 tokens ; __u32 ctokens ; } ;

struct tc_hfsc_qopt { __u16 defcls ; } ;

struct tc_service_curve { __u32 m1 ; __u32 d ; __u32 m2 ; } ;

struct tc_hfsc_stats { __u64 work ; __u64 rtwork ; __u32 period ; __u32 level ; } ;

enum { TCA_HFSC_UNSPEC , TCA_HFSC_RSC , TCA_HFSC_FSC , TCA_HFSC_USC , __TCA_HFSC_MAX , } ;
struct tc_cbq_lssopt { unsigned char change ; unsigned char flags ; unsigned char ewma_log ; unsigned char level ; __u32 maxidle ; __u32 minidle ; __u32 offtime ; __u32 avpkt ; } ;

struct tc_cbq_wrropt { unsigned char flags ; unsigned char priority ; unsigned char cpriority ; unsigned char __reserved ; __u32 allot ; __u32 weight ; } ;

struct tc_cbq_ovl { unsigned char strategy ; unsigned char priority2 ; __u16 pad ; __u32 penalty ; } ;

struct tc_cbq_police { unsigned char police ; unsigned char __res1 ; unsigned short __res2 ; } ;

struct tc_cbq_fopt { __u32 split ; __u32 defmap ; __u32 defchange ; } ;

struct tc_cbq_xstats { __u32 borrows ; __u32 overactions ; __s32 avgidle ; __s32 undertime ; } ;

enum { TCA_CBQ_UNSPEC , TCA_CBQ_LSSOPT , TCA_CBQ_WRROPT , TCA_CBQ_FOPT , TCA_CBQ_OVL_STRATEGY , TCA_CBQ_RATE , TCA_CBQ_RTAB , TCA_CBQ_POLICE , __TCA_CBQ_MAX , } ;
enum { TCA_DSMARK_UNSPEC , TCA_DSMARK_INDICES , TCA_DSMARK_DEFAULT_INDEX , TCA_DSMARK_SET_TC_INDEX , TCA_DSMARK_MASK , TCA_DSMARK_VALUE , __TCA_DSMARK_MAX , } ;
enum { TCA_ATM_UNSPEC , TCA_ATM_FD , TCA_ATM_PTR , TCA_ATM_HDR , TCA_ATM_EXCESS , TCA_ATM_ADDR , TCA_ATM_STATE , __TCA_ATM_MAX , } ;
enum { TCA_NETEM_UNSPEC , TCA_NETEM_CORR , TCA_NETEM_DELAY_DIST , TCA_NETEM_REORDER , TCA_NETEM_CORRUPT , __TCA_NETEM_MAX , } ;
struct tc_netem_qopt { __u32 latency ; __u32 limit ; __u32 loss ; __u32 gap ; __u32 duplicate ; __u32 jitter ; } ;

struct tc_netem_corr { __u32 delay_corr ; __u32 loss_corr ; __u32 dup_corr ; } ;

struct tc_netem_reorder { __u32 probability ; __u32 correlation ; } ;

struct tc_netem_corrupt { __u32 probability ; __u32 correlation ; } ;

enum { TCA_DRR_UNSPEC , TCA_DRR_QUANTUM , __TCA_DRR_MAX } ;
struct tc_drr_stats { __u32 deficit ; } ;

enum { TCA_ACT_UNSPEC , TCA_ACT_KIND , TCA_ACT_OPTIONS , TCA_ACT_INDEX , TCA_ACT_STATS , __TCA_ACT_MAX } ;
enum { TCA_ID_UNSPEC = 0 , TCA_ID_POLICE = 1 , __TCA_ID_MAX = 255 } ;
struct tc_police { __u32 index ; int action ; __u32 limit ; __u32 burst ; __u32 mtu ; struct tc_ratespec rate ; struct tc_ratespec peakrate ; int refcnt ; int bindcnt ; __u32 capab ; } ;

struct tcf_t { __u64 install ; __u64 lastuse ; __u64 expires ; } ;

struct tc_cnt { int refcnt ; int bindcnt ; } ;

enum { TCA_POLICE_UNSPEC , TCA_POLICE_TBF , TCA_POLICE_RATE , TCA_POLICE_PEAKRATE , TCA_POLICE_AVRATE , TCA_POLICE_RESULT , __TCA_POLICE_MAX } ;
enum { TCA_U32_UNSPEC , TCA_U32_CLASSID , TCA_U32_HASH , TCA_U32_LINK , TCA_U32_DIVISOR , TCA_U32_SEL , TCA_U32_POLICE , TCA_U32_ACT , TCA_U32_INDEV , TCA_U32_PCNT , TCA_U32_MARK , __TCA_U32_MAX } ;
struct tc_u32_key { __be32 mask ; __be32 val ; int off ; int offmask ; } ;

struct tc_u32_sel { unsigned char flags ; unsigned char offshift ; unsigned char nkeys ; __be16 offmask ; __u16 off ; short offoff ; short hoff ; __be32 hmask ; struct tc_u32_key keys [ 0 ] ; } ;

struct tc_u32_mark { __u32 val ; __u32 mask ; __u32 success ; } ;

struct tc_u32_pcnt { __u64 rcnt ; __u64 rhit ; __u64 kcnts [ 0 ] ; } ;

enum { TCA_RSVP_UNSPEC , TCA_RSVP_CLASSID , TCA_RSVP_DST , TCA_RSVP_SRC , TCA_RSVP_PINFO , TCA_RSVP_POLICE , TCA_RSVP_ACT , __TCA_RSVP_MAX } ;
struct tc_rsvp_gpi { __u32 key ; __u32 mask ; int offset ; } ;

struct tc_rsvp_pinfo { struct tc_rsvp_gpi dpi ; struct tc_rsvp_gpi spi ; __u8 protocol ; __u8 tunnelid ; __u8 tunnelhdr ; __u8 pad ; } ;

enum { TCA_ROUTE4_UNSPEC , TCA_ROUTE4_CLASSID , TCA_ROUTE4_TO , TCA_ROUTE4_FROM , TCA_ROUTE4_IIF , TCA_ROUTE4_POLICE , TCA_ROUTE4_ACT , __TCA_ROUTE4_MAX } ;
enum { TCA_FW_UNSPEC , TCA_FW_CLASSID , TCA_FW_POLICE , TCA_FW_INDEV , TCA_FW_ACT , TCA_FW_MASK , __TCA_FW_MAX } ;
enum { TCA_TCINDEX_UNSPEC , TCA_TCINDEX_HASH , TCA_TCINDEX_MASK , TCA_TCINDEX_SHIFT , TCA_TCINDEX_FALL_THROUGH , TCA_TCINDEX_CLASSID , TCA_TCINDEX_POLICE , TCA_TCINDEX_ACT , __TCA_TCINDEX_MAX } ;
enum { FLOW_KEY_SRC , FLOW_KEY_DST , FLOW_KEY_PROTO , FLOW_KEY_PROTO_SRC , FLOW_KEY_PROTO_DST , FLOW_KEY_IIF , FLOW_KEY_PRIORITY , FLOW_KEY_MARK , FLOW_KEY_NFCT , FLOW_KEY_NFCT_SRC , FLOW_KEY_NFCT_DST , FLOW_KEY_NFCT_PROTO_SRC , FLOW_KEY_NFCT_PROTO_DST , FLOW_KEY_RTCLASSID , FLOW_KEY_SKUID , FLOW_KEY_SKGID , FLOW_KEY_VLAN_TAG , __FLOW_KEY_MAX , } ;
enum { FLOW_MODE_MAP , FLOW_MODE_HASH , } ;
enum { TCA_FLOW_UNSPEC , TCA_FLOW_KEYS , TCA_FLOW_MODE , TCA_FLOW_BASECLASS , TCA_FLOW_RSHIFT , TCA_FLOW_ADDEND , TCA_FLOW_MASK , TCA_FLOW_XOR , TCA_FLOW_DIVISOR , TCA_FLOW_ACT , TCA_FLOW_POLICE , TCA_FLOW_EMATCHES , TCA_FLOW_PERTURB , __TCA_FLOW_MAX } ;
enum { TCA_BASIC_UNSPEC , TCA_BASIC_CLASSID , TCA_BASIC_EMATCHES , TCA_BASIC_ACT , TCA_BASIC_POLICE , __TCA_BASIC_MAX } ;
enum { TCA_CGROUP_UNSPEC , TCA_CGROUP_ACT , TCA_CGROUP_POLICE , TCA_CGROUP_EMATCHES , __TCA_CGROUP_MAX , } ;
struct tcf_ematch_tree_hdr { __u16 nmatches ; __u16 progid ; } ;

enum { TCA_EMATCH_TREE_UNSPEC , TCA_EMATCH_TREE_HDR , TCA_EMATCH_TREE_LIST , __TCA_EMATCH_TREE_MAX } ;
struct tcf_ematch_hdr { __u16 matchid ; __u16 kind ; __u16 flags ; __u16 pad ; } ;

enum { TCF_LAYER_LINK , TCF_LAYER_NETWORK , TCF_LAYER_TRANSPORT , __TCF_LAYER_MAX } ;
enum { TCF_EM_PROG_TC } ;
enum { TCF_EM_OPND_EQ , TCF_EM_OPND_GT , TCF_EM_OPND_LT } ;
enum { TCA_STATS_UNSPEC , TCA_STATS_BASIC , TCA_STATS_RATE_EST , TCA_STATS_QUEUE , TCA_STATS_APP , __TCA_STATS_MAX , } ;
struct gnet_stats_basic { __u64 bytes ; __u32 packets ; } ;

struct gnet_stats_basic_packed { __u64 bytes ; __u32 packets ; } __attribute__ ( ( packed ) ) ;
struct gnet_stats_rate_est { __u32 bps ; __u32 pps ; } ;

struct gnet_stats_queue { __u32 qlen ; __u32 backlog ; __u32 drops ; __u32 requeues ; __u32 overlimits ; } ;

struct gnet_estimator { signed char interval ; unsigned char ewma_log ; } ;

struct gnet_dump { spinlock_t * lock ; struct sk_buff * skb ; struct nlattr * tail ; int compat_tc_stats ; int compat_xstats ; void * xstats ; int xstats_len ; struct tc_stats tc_stats ; } ;

struct Qdisc_ops ;

struct qdisc_walker ;

struct tcf_walker ;

struct qdisc_rate_table { struct tc_ratespec rate ; u32 data [ 256 ] ; struct qdisc_rate_table * next ; int refcnt ; } ;

enum qdisc_state_t { __QDISC_STATE_RUNNING , __QDISC_STATE_SCHED , __QDISC_STATE_DEACTIVATED , } ;

struct qdisc_size_table { struct list_head list ; struct tc_sizespec szopts ; int refcnt ; u16 data [ ] ; } ;

struct Qdisc { int ( * enqueue ) ( struct sk_buff * skb , struct Qdisc * dev ) ; struct sk_buff * ( * dequeue ) ( struct Qdisc * dev ) ; unsigned flags ; int padded ; struct Qdisc_ops * ops ; struct qdisc_size_table * stab ; struct list_head list ; u32 handle ; u32 parent ; atomic_t refcnt ; struct gnet_stats_rate_est rate_est ; int ( * reshape_fail ) ( struct sk_buff * skb , struct Qdisc * q ) ; void * u32_node ; struct Qdisc * __parent ; struct netdev_queue * dev_queue ; struct Qdisc * next_sched ; struct sk_buff * gso_skb ; unsigned long state ; struct sk_buff_head q ; struct gnet_stats_basic_packed bstats ; struct gnet_stats_queue qstats ; } ;

struct Qdisc_class_ops { struct netdev_queue * ( * select_queue ) ( struct Qdisc * , struct tcmsg * ) ; int ( * graft ) ( struct Qdisc * , unsigned long cl , struct Qdisc * , struct Qdisc * * ) ; struct Qdisc * ( * leaf ) ( struct Qdisc * , unsigned long cl ) ; void ( * qlen_notify ) ( struct Qdisc * , unsigned long ) ; unsigned long ( * get ) ( struct Qdisc * , u32 classid ) ; void ( * put ) ( struct Qdisc * , unsigned long ) ; int ( * change ) ( struct Qdisc * , u32 , u32 , struct nlattr * * , unsigned long * ) ; int ( * delete ) ( struct Qdisc * , unsigned long ) ; void ( * walk ) ( struct Qdisc * , struct qdisc_walker * arg ) ; struct tcf_proto * * ( * tcf_chain ) ( struct Qdisc * , unsigned long ) ; unsigned long ( * bind_tcf ) ( struct Qdisc * , unsigned long , u32 classid ) ; void ( * unbind_tcf ) ( struct Qdisc * , unsigned long ) ; int ( * dump ) ( struct Qdisc * , unsigned long , struct sk_buff * skb , struct tcmsg * ) ; int ( * dump_stats ) ( struct Qdisc * , unsigned long , struct gnet_dump * ) ; } ;

struct Qdisc_ops { struct Qdisc_ops * next ; const struct Qdisc_class_ops * cl_ops ; char id [ 16 ] ; int priv_size ; int ( * enqueue ) ( struct sk_buff * , struct Qdisc * ) ; struct sk_buff * ( * dequeue ) ( struct Qdisc * ) ; struct sk_buff * ( * peek ) ( struct Qdisc * ) ; unsigned int ( * drop ) ( struct Qdisc * ) ; int ( * init ) ( struct Qdisc * , struct nlattr * arg ) ; void ( * reset ) ( struct Qdisc * ) ; void ( * destroy ) ( struct Qdisc * ) ; int ( * change ) ( struct Qdisc * , struct nlattr * arg ) ; void ( * attach ) ( struct Qdisc * ) ; int ( * dump ) ( struct Qdisc * , struct sk_buff * ) ; int ( * dump_stats ) ( struct Qdisc * , struct gnet_dump * ) ; struct module * owner ; } ;
struct tcf_result { unsigned long class ; u32 classid ; } ;

struct tcf_proto_ops { struct tcf_proto_ops * next ; char kind [ 16 ] ; int ( * classify ) ( struct sk_buff * , struct tcf_proto * , struct tcf_result * ) ; int ( * init ) ( struct tcf_proto * ) ; void ( * destroy ) ( struct tcf_proto * ) ; unsigned long ( * get ) ( struct tcf_proto * , u32 handle ) ; void ( * put ) ( struct tcf_proto * , unsigned long ) ; int ( * change ) ( struct tcf_proto * , unsigned long , u32 handle , struct nlattr * * , unsigned long * ) ; int ( * delete ) ( struct tcf_proto * , unsigned long ) ; void ( * walk ) ( struct tcf_proto * , struct tcf_walker * arg ) ; int ( * dump ) ( struct tcf_proto * , unsigned long , struct sk_buff * skb , struct tcmsg * ) ; struct module * owner ; } ;

struct tcf_proto { struct tcf_proto * next ; void * root ; int ( * classify ) ( struct sk_buff * , struct tcf_proto * , struct tcf_result * ) ; __be16 protocol ; u32 prio ; u32 classid ; struct Qdisc * q ; void * data ; struct tcf_proto_ops * ops ; } ;

struct qdisc_skb_cb { unsigned int pkt_len ; char data [ ] ; } ;

struct Qdisc_class_common { u32 classid ; struct hlist_node hnode ; } ;

struct Qdisc_class_hash { struct hlist_head * hash ; unsigned int hashsize ; unsigned int hashmask ; unsigned int hashelems ; } ;

enum net_xmit_qdisc_t { __NET_XMIT_STOLEN = 0x00010000 , __NET_XMIT_BYPASS = 0x00020000 , } ;

struct qdisc_walker { int stop ; int skip ; int count ; int ( * fn ) ( struct Qdisc * , unsigned long cl , struct qdisc_walker * ) ; } ;
typedef u64 psched_time_t ;

typedef long psched_tdiff_t ;

struct qdisc_watchdog { struct hrtimer timer ; struct Qdisc * qdisc ; } ;

struct sock_extended_err { __u32 ee_errno ; __u8 ee_origin ; __u8 ee_type ; __u8 ee_code ; __u8 ee_pad ; __u32 ee_info ; __u32 ee_data ; } ;

struct sock_exterr_skb { union { struct inet_skb_parm h4 ; struct inet6_skb_parm h6 ; } header ; struct sock_extended_err ee ; u16 addr_offset ; __be16 port ; } ;

void skb_over_panic ( struct sk_buff * skb , int sz , void * here ) ;

void skb_under_panic ( struct sk_buff * skb , int sz , void * here ) ;

struct sk_buff * __alloc_skb ( unsigned int size , gfp_t gfp_mask , int fclone , int node ) ;

struct sk_buff * __netdev_alloc_skb ( struct net_device * dev , unsigned int length , gfp_t gfp_mask ) ;

struct page * __netdev_alloc_page ( struct net_device * dev , gfp_t gfp_mask ) ;

void skb_add_rx_frag ( struct sk_buff * skb , int i , struct page * page , int off , int size ) ;

struct sk_buff * dev_alloc_skb ( unsigned int length ) ;

void __kfree_skb ( struct sk_buff * skb ) ;

void kfree_skb ( struct sk_buff * skb ) ;

void consume_skb ( struct sk_buff * skb ) ;

int skb_recycle_check ( struct sk_buff * skb , int skb_size ) ;

struct sk_buff * skb_morph ( struct sk_buff * dst , struct sk_buff * src ) ;

struct sk_buff * skb_clone ( struct sk_buff * skb , gfp_t gfp_mask ) ;

struct sk_buff * skb_copy ( const struct sk_buff * skb , gfp_t gfp_mask ) ;

struct sk_buff * pskb_copy ( struct sk_buff * skb , gfp_t gfp_mask ) ;

int pskb_expand_head ( struct sk_buff * skb , int nhead , int ntail , gfp_t gfp_mask ) ;

struct sk_buff * skb_realloc_headroom ( struct sk_buff * skb , unsigned int headroom ) ;

struct sk_buff * skb_copy_expand ( const struct sk_buff * skb , int newheadroom , int newtailroom , gfp_t gfp_mask ) ;

int skb_pad ( struct sk_buff * skb , int pad ) ;

unsigned char * skb_put ( struct sk_buff * skb , unsigned int len ) ;

unsigned char * skb_push ( struct sk_buff * skb , unsigned int len ) ;

unsigned char * skb_pull ( struct sk_buff * skb , unsigned int len ) ;

void skb_trim ( struct sk_buff * skb , unsigned int len ) ;

int ___pskb_trim ( struct sk_buff * skb , unsigned int len ) ;

unsigned char * __pskb_pull_tail ( struct sk_buff * skb , int delta ) ;

int skb_copy_bits ( const struct sk_buff * skb , int offset , void * to , int len ) ;

int skb_splice_bits ( struct sk_buff * skb , unsigned int offset , struct pipe_inode_info * pipe , unsigned int tlen , unsigned int flags ) ;

int skb_store_bits ( struct sk_buff * skb , int offset , const void * from , int len ) ;

__wsum skb_checksum ( const struct sk_buff * skb , int offset , int len , __wsum csum ) ;

__wsum skb_copy_and_csum_bits ( const struct sk_buff * skb , int offset , u8 * to , int len , __wsum csum ) ;

void skb_copy_and_csum_dev ( const struct sk_buff * skb , u8 * to ) ;

struct sk_buff * skb_dequeue ( struct sk_buff_head * list ) ;

struct sk_buff * skb_dequeue_tail ( struct sk_buff_head * list ) ;

void skb_queue_purge ( struct sk_buff_head * list ) ;

void skb_queue_head ( struct sk_buff_head * list , struct sk_buff * newsk ) ;

void skb_queue_tail ( struct sk_buff_head * list , struct sk_buff * newsk ) ;

void skb_unlink ( struct sk_buff * skb , struct sk_buff_head * list ) ;

void skb_append ( struct sk_buff * old , struct sk_buff * newsk , struct sk_buff_head * list ) ;

void skb_insert ( struct sk_buff * old , struct sk_buff * newsk , struct sk_buff_head * list ) ;

void skb_split ( struct sk_buff * skb , struct sk_buff * skb1 , const u32 len ) ;

int skb_shift ( struct sk_buff * tgt , struct sk_buff * skb , int shiftlen ) ;

void skb_prepare_seq_read ( struct sk_buff * skb , unsigned int from , unsigned int to , struct skb_seq_state * st ) ;

unsigned int skb_seq_read ( unsigned int consumed , const u8 * * data , struct skb_seq_state * st ) ;

void skb_abort_seq_read ( struct skb_seq_state * st ) ;

unsigned int skb_find_text ( struct sk_buff * skb , unsigned int from , unsigned int to , struct ts_config * config , struct ts_state * state ) ;

int skb_append_datato_frags ( struct sock * sk , struct sk_buff * skb , int ( * getfrag ) ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length ) ;

unsigned char * skb_pull_rcsum ( struct sk_buff * skb , unsigned int len ) ;

struct sk_buff * skb_segment ( struct sk_buff * skb , int features ) ;

int skb_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) skb_init ( void ) ;

int skb_to_sgvec ( struct sk_buff * skb , struct scatterlist * sg , int offset , int len ) ;

int skb_cow_data ( struct sk_buff * skb , int tailbits , struct sk_buff * * trailer ) ;

void skb_tstamp_tx ( struct sk_buff * orig_skb , struct skb_shared_hwtstamps * hwtstamps ) ;

bool skb_partial_csum_set ( struct sk_buff * skb , u16 start , u16 off ) ;

void __skb_warn_lro_forwarding ( const struct sk_buff * skb ) ;

int verify_iovec ( struct msghdr * m , struct iovec * iov , struct sockaddr * address , int mode ) ;

int memcpy_toiovec ( struct iovec * iov , unsigned char * kdata , int len ) ;

int memcpy_toiovecend ( const struct iovec * iov , unsigned char * kdata , int offset , int len ) ;

int memcpy_fromiovec ( unsigned char * kdata , struct iovec * iov , int len ) ;

int memcpy_fromiovecend ( unsigned char * kdata , const struct iovec * iov , int offset , int len ) ;

int csum_partial_copy_fromiovecend ( unsigned char * kdata , struct iovec * iov , int offset , unsigned int len , __wsum * csump ) ;

struct sk_buff * __skb_recv_datagram ( struct sock * sk , unsigned flags , int * peeked , int * err ) ;

struct sk_buff * skb_recv_datagram ( struct sock * sk , unsigned flags , int noblock , int * err ) ;

void skb_free_datagram ( struct sock * sk , struct sk_buff * skb ) ;

void skb_free_datagram_locked ( struct sock * sk , struct sk_buff * skb ) ;

int skb_kill_datagram ( struct sock * sk , struct sk_buff * skb , unsigned int flags ) ;

int skb_copy_datagram_iovec ( const struct sk_buff * skb , int offset , struct iovec * to , int len ) ;

int skb_copy_datagram_const_iovec ( const struct sk_buff * skb , int offset , const struct iovec * to , int to_offset , int len ) ;

int skb_copy_datagram_from_iovec ( struct sk_buff * skb , int offset , const struct iovec * from , int from_offset , int len ) ;

__sum16 __skb_checksum_complete_head ( struct sk_buff * skb , int len ) ;

__sum16 __skb_checksum_complete ( struct sk_buff * skb ) ;

int skb_copy_and_csum_datagram_iovec ( struct sk_buff * skb , int hlen , struct iovec * iov ) ;

unsigned int datagram_poll ( struct file * file , struct socket * sock , poll_table * wait ) ;

void sk_stream_write_space ( struct sock * sk ) ;

int sk_stream_wait_connect ( struct sock * sk , long * timeo_p ) ;

void sk_stream_wait_close ( struct sock * sk , long timeout ) ;

int sk_stream_wait_memory ( struct sock * sk , long * timeo_p ) ;

int sk_stream_error ( struct sock * sk , int flags , int err ) ;

void sk_stream_kill_queues ( struct sock * sk ) ;

struct scm_fp_list { struct list_head list ; int count ; struct file * fp [ 255 ] ; } ;

struct scm_cookie { struct ucred creds ; struct scm_fp_list * fp ; u32 secid ; } ;

void __scm_destroy ( struct scm_cookie * scm ) ;

int __scm_send ( struct socket * sock , struct msghdr * msg , struct scm_cookie * p ) ;

int put_cmsg ( struct msghdr * msg , int level , int type , int len , void * data ) ;

void scm_detach_fds ( struct msghdr * msg , struct scm_cookie * scm ) ;

struct scm_fp_list * scm_fp_dup ( struct scm_fp_list * fpl ) ;

int gnet_stats_start_copy_compat ( struct sk_buff * skb , int type , int tc_stats_type , int xstats_type , spinlock_t * lock , struct gnet_dump * d ) ;

int gnet_stats_start_copy ( struct sk_buff * skb , int type , spinlock_t * lock , struct gnet_dump * d ) ;

int gnet_stats_copy_basic ( struct gnet_dump * d , struct gnet_stats_basic_packed * b ) ;

int gnet_stats_copy_rate_est ( struct gnet_dump * d , struct gnet_stats_rate_est * r ) ;

int gnet_stats_copy_queue ( struct gnet_dump * d , struct gnet_stats_queue * q ) ;

int gnet_stats_copy_app ( struct gnet_dump * d , void * st , int len ) ;

int gnet_stats_finish_copy ( struct gnet_dump * d ) ;

struct gen_estimator { struct list_head list ; struct gnet_stats_basic_packed * bstats ; struct gnet_stats_rate_est * rate_est ; spinlock_t * stats_lock ; int ewma_log ; u64 last_bytes ; u64 avbps ; u32 last_packets ; u32 avpps ; struct rcu_head e_rcu ; struct rb_node node ; } ;

struct gen_estimator_head { struct timer_list timer ; struct list_head list ; } ;

int gen_new_estimator ( struct gnet_stats_basic_packed * bstats , struct gnet_stats_rate_est * rate_est , spinlock_t * stats_lock , struct nlattr * opt ) ;

void gen_kill_estimator ( struct gnet_stats_basic_packed * bstats , struct gnet_stats_rate_est * rate_est ) ;

int gen_replace_estimator ( struct gnet_stats_basic_packed * bstats , struct gnet_stats_rate_est * rate_est , spinlock_t * stats_lock , struct nlattr * opt ) ;

bool gen_estimator_active ( const struct gnet_stats_basic_packed * bstats , const struct gnet_stats_rate_est * rate_est ) ;

struct net * copy_net_ns ( unsigned long flags , struct net * old_net ) ;

void __put_net ( struct net * net ) ;

struct net * get_net_ns_by_pid ( pid_t pid ) ;

int register_pernet_subsys ( struct pernet_operations * ops ) ;

void unregister_pernet_subsys ( struct pernet_operations * module ) ;

int register_pernet_gen_subsys ( int * id , struct pernet_operations * ops ) ;

void unregister_pernet_gen_subsys ( int id , struct pernet_operations * ops ) ;

int register_pernet_device ( struct pernet_operations * ops ) ;

int register_pernet_gen_device ( int * id , struct pernet_operations * ops ) ;

void unregister_pernet_device ( struct pernet_operations * ops ) ;

void unregister_pernet_gen_device ( int id , struct pernet_operations * ops ) ;

int net_assign_generic ( struct net * net , int id , void * data ) ;

int skb_dma_map ( struct device * dev , struct sk_buff * skb , enum dma_data_direction dir ) ;

void skb_dma_unmap ( struct device * dev , struct sk_buff * skb , enum dma_data_direction dir ) ;

struct netpoll { struct net_device * dev ; char dev_name [ 16 ] ; const char * name ; void ( * rx_hook ) ( struct netpoll * , int , char * , int ) ; __be32 local_ip , remote_ip ; u16 local_port , remote_port ; u8 remote_mac [ 6 ] ; } ;

struct netpoll_info { atomic_t refcnt ; int rx_flags ; spinlock_t rx_lock ; struct netpoll * rx_np ; struct sk_buff_head arp_tx ; struct sk_buff_head txq ; struct delayed_work tx_work ; } ;
struct iw_request_info { __u16 cmd ; __u16 flags ; } ;

typedef int ( * iw_handler ) ( struct net_device * dev , struct iw_request_info * info , union iwreq_data * wrqu , char * extra ) ;
struct iw_handler_def { __u16 num_standard ; __u16 num_private ; __u16 num_private_args ; const iw_handler * standard ; const iw_handler * private ; const struct iw_priv_args * private_args ; struct iw_statistics * ( * get_wireless_stats ) ( struct net_device * dev ) ; } ;

struct iw_ioctl_description { __u8 header_type ; __u8 token_type ; __u16 token_size ; __u16 min_tokens ; __u16 max_tokens ; __u32 flags ; } ;

struct iw_spy_data { int spy_number ; u_char spy_address [ 8 ] [ 6 ] ; struct iw_quality spy_stat [ 8 ] ; struct iw_quality spy_thr_low ; struct iw_quality spy_thr_high ; u_char spy_thr_under [ 8 ] ; } ;

struct libipw_device ;

struct iw_public_data { struct iw_spy_data * spy_data ; struct libipw_device * libipw ; } ;

void dev_add_pack ( struct packet_type * pt ) ;

void __dev_remove_pack ( struct packet_type * pt ) ;

void dev_remove_pack ( struct packet_type * pt ) ;

int netdev_boot_setup_check ( struct net_device * dev ) ;

unsigned long netdev_boot_base ( const char * prefix , int unit ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netdev_boot_setup ( char * str ) ;
struct net_device * __dev_get_by_name ( struct net * net , const char * name ) ;

struct net_device * dev_get_by_name ( struct net * net , const char * name ) ;

struct net_device * __dev_get_by_index ( struct net * net , int ifindex ) ;

struct net_device * dev_get_by_index ( struct net * net , int ifindex ) ;

struct net_device * dev_getbyhwaddr ( struct net * net , unsigned short type , char * ha ) ;

struct net_device * __dev_getfirstbyhwtype ( struct net * net , unsigned short type ) ;

struct net_device * dev_getfirstbyhwtype ( struct net * net , unsigned short type ) ;

struct net_device * dev_get_by_flags ( struct net * net , unsigned short if_flags , unsigned short mask ) ;

int dev_valid_name ( const char * name ) ;

int dev_alloc_name ( struct net_device * dev , const char * name ) ;

int dev_change_name ( struct net_device * dev , const char * newname ) ;

int dev_set_alias ( struct net_device * dev , const char * alias , size_t len ) ;

void netdev_features_change ( struct net_device * dev ) ;

void netdev_state_change ( struct net_device * dev ) ;

void netdev_bonding_change ( struct net_device * dev , unsigned long event ) ;

void dev_load ( struct net * net , const char * name ) ;

int dev_open ( struct net_device * dev ) ;

int dev_close ( struct net_device * dev ) ;

void dev_disable_lro ( struct net_device * dev ) ;

int register_netdevice_notifier ( struct notifier_block * nb ) ;

int unregister_netdevice_notifier ( struct notifier_block * nb ) ;

int call_netdevice_notifiers ( unsigned long val , struct net_device * dev ) ;

void net_enable_timestamp ( void ) ;

void net_disable_timestamp ( void ) ;

void __netif_schedule ( struct Qdisc * q ) ;

void dev_kfree_skb_irq ( struct sk_buff * skb ) ;

void dev_kfree_skb_any ( struct sk_buff * skb ) ;

void netif_device_detach ( struct net_device * dev ) ;

void netif_device_attach ( struct net_device * dev ) ;

int skb_checksum_help ( struct sk_buff * skb ) ;

struct sk_buff * skb_gso_segment ( struct sk_buff * skb , int features ) ;

void netdev_rx_csum_fault ( struct net_device * dev ) ;

struct dev_gso_cb { void ( * destructor ) ( struct sk_buff * skb ) ; } ;

int dev_hard_start_xmit ( struct sk_buff * skb , struct net_device * dev , struct netdev_queue * txq ) ;

u16 skb_tx_hash ( const struct net_device * dev , const struct sk_buff * skb ) ;

int dev_queue_xmit ( struct sk_buff * skb ) ;

int netif_rx ( struct sk_buff * skb ) ;

int netif_rx_ni ( struct sk_buff * skb ) ;

void netif_nit_deliver ( struct sk_buff * skb ) ;

int netif_receive_skb ( struct sk_buff * skb ) ;

void napi_gro_flush ( struct napi_struct * napi ) ;

enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) ;

gro_result_t napi_skb_finish ( gro_result_t ret , struct sk_buff * skb ) ;

void skb_gro_reset_offset ( struct sk_buff * skb ) ;

gro_result_t napi_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) ;

void napi_reuse_skb ( struct napi_struct * napi , struct sk_buff * skb ) ;

struct sk_buff * napi_get_frags ( struct napi_struct * napi ) ;

gro_result_t napi_frags_finish ( struct napi_struct * napi , struct sk_buff * skb , gro_result_t ret ) ;

struct sk_buff * napi_frags_skb ( struct napi_struct * napi ) ;

gro_result_t napi_gro_frags ( struct napi_struct * napi ) ;

void __napi_schedule ( struct napi_struct * n ) ;

void __napi_complete ( struct napi_struct * n ) ;

void napi_complete ( struct napi_struct * n ) ;

void netif_napi_add ( struct net_device * dev , struct napi_struct * napi , int ( * poll ) ( struct napi_struct * , int ) , int weight ) ;

void netif_napi_del ( struct napi_struct * napi ) ;

int register_gifconf ( unsigned int family , gifconf_func_t * gifconf ) ;

void * dev_seq_start ( struct seq_file * seq , loff_t * pos ) ;

void * dev_seq_next ( struct seq_file * seq , void * v , loff_t * pos ) ;

void dev_seq_stop ( struct seq_file * seq , void * v ) ;

int netdev_set_master ( struct net_device * slave , struct net_device * master ) ;

int dev_set_promiscuity ( struct net_device * dev , int inc ) ;

int dev_set_allmulti ( struct net_device * dev , int inc ) ;

void __dev_set_rx_mode ( struct net_device * dev ) ;

void dev_set_rx_mode ( struct net_device * dev ) ;

int dev_addr_add ( struct net_device * dev , unsigned char * addr , unsigned char addr_type ) ;

int dev_addr_del ( struct net_device * dev , unsigned char * addr , unsigned char addr_type ) ;

int dev_addr_add_multiple ( struct net_device * to_dev , struct net_device * from_dev , unsigned char addr_type ) ;

int dev_addr_del_multiple ( struct net_device * to_dev , struct net_device * from_dev , unsigned char addr_type ) ;

int __dev_addr_delete ( struct dev_addr_list * * list , int * count , void * addr , int alen , int glbl ) ;

int __dev_addr_add ( struct dev_addr_list * * list , int * count , void * addr , int alen , int glbl ) ;

int dev_unicast_delete ( struct net_device * dev , void * addr ) ;

int dev_unicast_add ( struct net_device * dev , void * addr ) ;

int __dev_addr_sync ( struct dev_addr_list * * to , int * to_count , struct dev_addr_list * * from , int * from_count ) ;

void __dev_addr_unsync ( struct dev_addr_list * * to , int * to_count , struct dev_addr_list * * from , int * from_count ) ;

int dev_unicast_sync ( struct net_device * to , struct net_device * from ) ;

void dev_unicast_unsync ( struct net_device * to , struct net_device * from ) ;

unsigned dev_get_flags ( const struct net_device * dev ) ;

int dev_change_flags ( struct net_device * dev , unsigned flags ) ;

int dev_set_mtu ( struct net_device * dev , int new_mtu ) ;

int dev_set_mac_address ( struct net_device * dev , struct sockaddr * sa ) ;

int dev_ioctl ( struct net * net , unsigned int cmd , void * arg ) ;

unsigned long netdev_fix_features ( unsigned long features , const char * name ) ;

int register_netdevice ( struct net_device * dev ) ;

int init_dummy_netdev ( struct net_device * dev ) ;

int register_netdev ( struct net_device * dev ) ;

void netdev_run_todo ( void ) ;

const struct net_device_stats * dev_get_stats ( struct net_device * dev ) ;

struct net_device * alloc_netdev_mq ( int sizeof_priv , const char * name , void ( * setup ) ( struct net_device * ) , unsigned int queue_count ) ;

void free_netdev ( struct net_device * dev ) ;

void synchronize_net ( void ) ;

void unregister_netdevice ( struct net_device * dev ) ;

void unregister_netdev ( struct net_device * dev ) ;

int dev_change_net_namespace ( struct net_device * dev , struct net * net , const char * pat ) ;

unsigned long netdev_increment_features ( unsigned long all , unsigned long one , unsigned long mask ) ;

char * netdev_drivername ( const struct net_device * dev , char * buffer , int len ) ;

u32 ethtool_op_get_link ( struct net_device * dev ) ;

u32 ethtool_op_get_rx_csum ( struct net_device * dev ) ;

u32 ethtool_op_get_tx_csum ( struct net_device * dev ) ;

int ethtool_op_set_tx_csum ( struct net_device * dev , u32 data ) ;

int ethtool_op_set_tx_hw_csum ( struct net_device * dev , u32 data ) ;

int ethtool_op_set_tx_ipv6_csum ( struct net_device * dev , u32 data ) ;

u32 ethtool_op_get_sg ( struct net_device * dev ) ;

int ethtool_op_set_sg ( struct net_device * dev , u32 data ) ;

u32 ethtool_op_get_tso ( struct net_device * dev ) ;

int ethtool_op_set_tso ( struct net_device * dev , u32 data ) ;

u32 ethtool_op_get_ufo ( struct net_device * dev ) ;

int ethtool_op_set_ufo ( struct net_device * dev , u32 data ) ;

u32 ethtool_op_get_flags ( struct net_device * dev ) ;

int ethtool_op_set_flags ( struct net_device * dev , u32 data ) ;

int dev_ethtool ( struct net * net , struct ifreq * ifr ) ;

int dev_mc_delete ( struct net_device * dev , void * addr , int alen , int glbl ) ;

int dev_mc_add ( struct net_device * dev , void * addr , int alen , int glbl ) ;

int dev_mc_sync ( struct net_device * to , struct net_device * from ) ;

void dev_mc_unsync ( struct net_device * to , struct net_device * from ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dev_mcast_init ( void ) ;

int dst_discard ( struct sk_buff * skb ) ;

void * dst_alloc ( struct dst_ops * ops ) ;

void __dst_free ( struct dst_entry * dst ) ;

struct dst_entry * dst_destroy ( struct dst_entry * dst ) ;

void dst_release ( struct dst_entry * dst ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) dst_init ( void ) ;

struct netevent_redirect { struct dst_entry * old ; struct dst_entry * new ; } ;

enum netevent_notif_type { NETEVENT_NEIGH_UPDATE = 1 , NETEVENT_PMTU_UPDATE , NETEVENT_REDIRECT , } ;

int register_netevent_notifier ( struct notifier_block * nb ) ;

int unregister_netevent_notifier ( struct notifier_block * nb ) ;

int call_netevent_notifiers ( unsigned long val , void * v ) ;

unsigned long neigh_rand_reach_time ( unsigned long base ) ;

void neigh_changeaddr ( struct neigh_table * tbl , struct net_device * dev ) ;

int neigh_ifdown ( struct neigh_table * tbl , struct net_device * dev ) ;

struct neighbour * neigh_lookup ( struct neigh_table * tbl , const void * pkey , struct net_device * dev ) ;

struct neighbour * neigh_lookup_nodev ( struct neigh_table * tbl , struct net * net , const void * pkey ) ;

struct neighbour * neigh_create ( struct neigh_table * tbl , const void * pkey , struct net_device * dev ) ;

struct pneigh_entry * __pneigh_lookup ( struct neigh_table * tbl , struct net * net , const void * pkey , struct net_device * dev ) ;

struct pneigh_entry * pneigh_lookup ( struct neigh_table * tbl , struct net * net , const void * pkey , struct net_device * dev , int creat ) ;

int pneigh_delete ( struct neigh_table * tbl , struct net * net , const void * pkey , struct net_device * dev ) ;

void neigh_destroy ( struct neighbour * neigh ) ;

int __neigh_event_send ( struct neighbour * neigh , struct sk_buff * skb ) ;

int neigh_update ( struct neighbour * neigh , const u8 * lladdr , u8 new , u32 flags ) ;

struct neighbour * neigh_event_ns ( struct neigh_table * tbl , u8 * lladdr , void * saddr , struct net_device * dev ) ;

int neigh_compat_output ( struct sk_buff * skb ) ;

int neigh_resolve_output ( struct sk_buff * skb ) ;

int neigh_connected_output ( struct sk_buff * skb ) ;

void pneigh_enqueue ( struct neigh_table * tbl , struct neigh_parms * p , struct sk_buff * skb ) ;

struct neigh_parms * neigh_parms_alloc ( struct net_device * dev , struct neigh_table * tbl ) ;

void neigh_parms_release ( struct neigh_table * tbl , struct neigh_parms * parms ) ;

void neigh_table_init_no_netlink ( struct neigh_table * tbl ) ;

void neigh_table_init ( struct neigh_table * tbl ) ;

int neigh_table_clear ( struct neigh_table * tbl ) ;

void neigh_for_each ( struct neigh_table * tbl , void ( * cb ) ( struct neighbour * , void * ) , void * cookie ) ;

void __neigh_for_each_release ( struct neigh_table * tbl , int ( * cb ) ( struct neighbour * ) ) ;

void * neigh_seq_start ( struct seq_file * seq , loff_t * pos , struct neigh_table * tbl , unsigned int neigh_seq_flags ) ;

void * neigh_seq_next ( struct seq_file * seq , void * v , loff_t * pos ) ;

void neigh_seq_stop ( struct seq_file * seq , void * v ) ;


int neigh_sysctl_register ( struct net_device * dev , struct neigh_parms * p , int p_id , int pdev_id , char * p_name , proc_handler * handler , ctl_handler * strategy ) ;

void neigh_sysctl_unregister ( struct neigh_parms * p ) ;

struct udp_skb_cb { union { struct inet_skb_parm h4 ; struct inet6_skb_parm h6 ; } header ; __u16 cscov ; __u8 partial_cov ; } ;

struct udp_hslot { struct hlist_nulls_head head ; spinlock_t lock ; } __attribute__ ( ( aligned ( 2 * sizeof ( long ) ) ) ) ;
struct udp_table { struct udp_hslot hash [ 128 ] ; } ;

struct udp_seq_afinfo { char * name ; sa_family_t family ; struct udp_table * udp_table ; struct file_operations seq_fops ; struct seq_operations seq_ops ; } ;

struct udp_iter_state { struct seq_net_private p ; sa_family_t family ; int bucket ; struct udp_table * udp_table ; } ;

struct fib_rule_hdr { __u8 family ; __u8 dst_len ; __u8 src_len ; __u8 tos ; __u8 table ; __u8 res1 ; __u8 res2 ; __u8 action ; __u32 flags ; } ;

enum { FRA_UNSPEC , FRA_DST , FRA_SRC , FRA_IFNAME , FRA_GOTO , FRA_UNUSED2 , FRA_PRIORITY , FRA_UNUSED3 , FRA_UNUSED4 , FRA_UNUSED5 , FRA_FWMARK , FRA_FLOW , FRA_UNUSED6 , FRA_UNUSED7 , FRA_UNUSED8 , FRA_TABLE , FRA_FWMASK , __FRA_MAX } ;
enum { FR_ACT_UNSPEC , FR_ACT_TO_TBL , FR_ACT_GOTO , FR_ACT_NOP , FR_ACT_RES3 , FR_ACT_RES4 , FR_ACT_BLACKHOLE , FR_ACT_UNREACHABLE , FR_ACT_PROHIBIT , __FR_ACT_MAX , } ;
struct fib_rule { struct list_head list ; atomic_t refcnt ; int ifindex ; char ifname [ 16 ] ; u32 mark ; u32 mark_mask ; u32 pref ; u32 flags ; u32 table ; u8 action ; u32 target ; struct fib_rule * ctarget ; struct rcu_head rcu ; struct net * fr_net ; } ;

struct fib_lookup_arg { void * lookup_ptr ; void * result ; struct fib_rule * rule ; } ;

struct fib_rules_ops { int family ; struct list_head list ; int rule_size ; int addr_size ; int unresolved_rules ; int nr_goto_rules ; int ( * action ) ( struct fib_rule * , struct flowi * , int , struct fib_lookup_arg * ) ; int ( * match ) ( struct fib_rule * , struct flowi * , int ) ; int ( * configure ) ( struct fib_rule * , struct sk_buff * , struct fib_rule_hdr * , struct nlattr * * ) ; int ( * compare ) ( struct fib_rule * , struct fib_rule_hdr * , struct nlattr * * ) ; int ( * fill ) ( struct fib_rule * , struct sk_buff * , struct fib_rule_hdr * ) ; u32 ( * default_pref ) ( struct fib_rules_ops * ops ) ; size_t ( * nlmsg_payload ) ( struct fib_rule * ) ; void ( * flush_cache ) ( struct fib_rules_ops * ops ) ; int nlgroup ; const struct nla_policy * policy ; struct list_head rules_list ; struct module * owner ; struct net * fro_net ; } ;
struct rtnl_link { rtnl_doit_func doit ; rtnl_dumpit_func dumpit ; } ;

void rtnl_lock ( void ) ;

void __rtnl_unlock ( void ) ;

void rtnl_unlock ( void ) ;

int rtnl_trylock ( void ) ;

int rtnl_is_locked ( void ) ;

int __rtnl_register ( int protocol , int msgtype , rtnl_doit_func doit , rtnl_dumpit_func dumpit ) ;

void rtnl_register ( int protocol , int msgtype , rtnl_doit_func doit , rtnl_dumpit_func dumpit ) ;

int rtnl_unregister ( int protocol , int msgtype ) ;

void rtnl_unregister_all ( int protocol ) ;

int __rtnl_link_register ( struct rtnl_link_ops * ops ) ;

int rtnl_link_register ( struct rtnl_link_ops * ops ) ;

void rtnl_kill_links ( struct net * net , struct rtnl_link_ops * ops ) ;

void __rtnl_link_unregister ( struct rtnl_link_ops * ops ) ;

void rtnl_link_unregister ( struct rtnl_link_ops * ops ) ;

void __rta_fill ( struct sk_buff * skb , int attrtype , int attrlen , const void * data ) ;

int rtnetlink_send ( struct sk_buff * skb , struct net * net , u32 pid , unsigned group , int echo ) ;

int rtnl_unicast ( struct sk_buff * skb , struct net * net , u32 pid ) ;

void rtnl_notify ( struct sk_buff * skb , struct net * net , u32 pid , u32 group , struct nlmsghdr * nlh , gfp_t flags ) ;

void rtnl_set_sk_err ( struct net * net , u32 group , int error ) ;

int rtnetlink_put_metrics ( struct sk_buff * skb , u32 * metrics ) ;

int rtnl_put_cacheinfo ( struct sk_buff * skb , struct dst_entry * dst , u32 id , u32 ts , u32 tsage , long expires , u32 error ) ;

struct net_device * rtnl_create_link ( struct net * net , char * ifname , const struct rtnl_link_ops * ops , struct nlattr * tb [ ] ) ;

void rtmsg_ifinfo ( int type , struct net_device * dev , unsigned change ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rtnetlink_init ( void ) ;

int net_ratelimit ( void ) ;

__be32 in_aton ( const char * str ) ;

int in4_pton ( const char * src , int srclen , u8 * dst , int delim , const char * * end ) ;

int in6_pton ( const char * src , int srclen , u8 * dst , int delim , const char * * end ) ;

void inet_proto_csum_replace4 ( __sum16 * sum , struct sk_buff * skb , __be32 from , __be32 to , int pseudohdr ) ;

enum lw_bits { LW_URGENT = 0 , } ;

void linkwatch_run_queue ( void ) ;

void linkwatch_fire_event ( struct net_device * dev ) ;

int sk_filter ( struct sock * sk , struct sk_buff * skb ) ;
unsigned int sk_run_filter ( struct sk_buff * skb , struct sock_filter * filter , int flen ) ;

int sk_chk_filter ( struct sock_filter * filter , int flen ) ;

int sk_attach_filter ( struct sock_fprog * fprog , struct sock * sk ) ;

int sk_detach_filter ( struct sock * sk ) ;

void netdev_unregister_kobject ( struct net_device * net ) ;

int netdev_register_kobject ( struct net_device * net ) ;

int netdev_class_create_file ( struct class_attribute * class_attr ) ;

void netdev_class_remove_file ( struct class_attribute * class_attr ) ;

void netdev_initialize_kobject ( struct net_device * net ) ;

int netdev_kobject_init ( void ) ;

int fib_default_rule_add ( struct fib_rules_ops * ops , u32 pref , u32 table , u32 flags ) ;

int fib_rules_register ( struct fib_rules_ops * ops ) ;

void fib_rules_cleanup_ops ( struct fib_rules_ops * ops ) ;

void fib_rules_unregister ( struct fib_rules_ops * ops ) ;

int fib_rules_lookup ( struct fib_rules_ops * ops , struct flowi * fl , int flags , struct fib_lookup_arg * arg ) ;

struct ipv4_devconf { void * sysctl ; int data [ __NET_IPV4_CONF_MAX - 1 ] ; unsigned long state [ ( ( ( __NET_IPV4_CONF_MAX - 1 ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; } ;
struct in_device { struct net_device * dev ; atomic_t refcnt ; int dead ; struct in_ifaddr * ifa_list ; rwlock_t mc_list_lock ; struct ip_mc_list * mc_list ; int mc_count ; spinlock_t mc_tomb_lock ; struct ip_mc_list * mc_tomb ; unsigned long mr_v1_seen ; unsigned long mr_v2_seen ; unsigned long mr_maxdelay ; unsigned char mr_qrv ; unsigned char mr_gq_running ; unsigned char mr_ifc_count ; struct timer_list mr_gq_timer ; struct timer_list mr_ifc_timer ; struct neigh_parms * arp_parms ; struct ipv4_devconf cnf ; struct rcu_head rcu_head ; } ;
struct in_ifaddr { struct in_ifaddr * ifa_next ; struct in_device * ifa_dev ; struct rcu_head rcu_head ; __be32 ifa_local ; __be32 ifa_address ; __be32 ifa_mask ; __be32 ifa_broadcast ; unsigned char ifa_scope ; unsigned char ifa_flags ; unsigned char ifa_prefixlen ; char ifa_label [ 16 ] ; } ;
struct net_dm_drop_point { __u8 pc [ 8 ] ; __u32 count ; } ;

struct net_dm_config_entry { __u32 type ; __u64 data __attribute__ ( ( aligned ( 8 ) ) ) ; } ;

struct net_dm_config_msg { __u32 entries ; struct net_dm_config_entry options [ 0 ] ; } ;

struct net_dm_alert_msg { __u32 entries ; struct net_dm_drop_point points [ 0 ] ; } ;

struct net_dm_user_msg { union { struct net_dm_config_msg user ; struct net_dm_alert_msg alert ; } u ; } ;

enum { NET_DM_CMD_UNSPEC = 0 , NET_DM_CMD_ALERT , NET_DM_CMD_CONFIG , NET_DM_CMD_START , NET_DM_CMD_STOP , _NET_DM_CMD_MAX , } ;
struct ftrace_raw_kfree_skb { struct trace_entry ent ; void * skbaddr ; unsigned short protocol ; void * location ; char __data [ 0 ] ; } ;

struct ftrace_raw_skb_copy_datagram_iovec { struct trace_entry ent ; const void * skbaddr ; int len ; char __data [ 0 ] ; } ;

struct ftrace_data_offsets_kfree_skb { ; } ;

struct ftrace_data_offsets_skb_copy_datagram_iovec { ; } ;

struct dcbmsg { __u8 dcb_family ; __u8 cmd ; __u16 dcb_pad ; } ;

enum dcbnl_commands { DCB_CMD_UNDEFINED , DCB_CMD_GSTATE , DCB_CMD_SSTATE , DCB_CMD_PGTX_GCFG , DCB_CMD_PGTX_SCFG , DCB_CMD_PGRX_GCFG , DCB_CMD_PGRX_SCFG , DCB_CMD_PFC_GCFG , DCB_CMD_PFC_SCFG , DCB_CMD_SET_ALL , DCB_CMD_GPERM_HWADDR , DCB_CMD_GCAP , DCB_CMD_GNUMTCS , DCB_CMD_SNUMTCS , DCB_CMD_PFC_GSTATE , DCB_CMD_PFC_SSTATE , DCB_CMD_BCN_GCFG , DCB_CMD_BCN_SCFG , DCB_CMD_GAPP , DCB_CMD_SAPP , __DCB_CMD_ENUM_MAX , DCB_CMD_MAX = __DCB_CMD_ENUM_MAX - 1 , } ;

enum dcbnl_attrs { DCB_ATTR_UNDEFINED , DCB_ATTR_IFNAME , DCB_ATTR_STATE , DCB_ATTR_PFC_STATE , DCB_ATTR_PFC_CFG , DCB_ATTR_NUM_TC , DCB_ATTR_PG_CFG , DCB_ATTR_SET_ALL , DCB_ATTR_PERM_HWADDR , DCB_ATTR_CAP , DCB_ATTR_NUMTCS , DCB_ATTR_BCN , DCB_ATTR_APP , __DCB_ATTR_ENUM_MAX , DCB_ATTR_MAX = __DCB_ATTR_ENUM_MAX - 1 , } ;

enum dcbnl_pfc_up_attrs { DCB_PFC_UP_ATTR_UNDEFINED , DCB_PFC_UP_ATTR_0 , DCB_PFC_UP_ATTR_1 , DCB_PFC_UP_ATTR_2 , DCB_PFC_UP_ATTR_3 , DCB_PFC_UP_ATTR_4 , DCB_PFC_UP_ATTR_5 , DCB_PFC_UP_ATTR_6 , DCB_PFC_UP_ATTR_7 , DCB_PFC_UP_ATTR_ALL , __DCB_PFC_UP_ATTR_ENUM_MAX , DCB_PFC_UP_ATTR_MAX = __DCB_PFC_UP_ATTR_ENUM_MAX - 1 , } ;

enum dcbnl_pg_attrs { DCB_PG_ATTR_UNDEFINED , DCB_PG_ATTR_TC_0 , DCB_PG_ATTR_TC_1 , DCB_PG_ATTR_TC_2 , DCB_PG_ATTR_TC_3 , DCB_PG_ATTR_TC_4 , DCB_PG_ATTR_TC_5 , DCB_PG_ATTR_TC_6 , DCB_PG_ATTR_TC_7 , DCB_PG_ATTR_TC_MAX , DCB_PG_ATTR_TC_ALL , DCB_PG_ATTR_BW_ID_0 , DCB_PG_ATTR_BW_ID_1 , DCB_PG_ATTR_BW_ID_2 , DCB_PG_ATTR_BW_ID_3 , DCB_PG_ATTR_BW_ID_4 , DCB_PG_ATTR_BW_ID_5 , DCB_PG_ATTR_BW_ID_6 , DCB_PG_ATTR_BW_ID_7 , DCB_PG_ATTR_BW_ID_MAX , DCB_PG_ATTR_BW_ID_ALL , __DCB_PG_ATTR_ENUM_MAX , DCB_PG_ATTR_MAX = __DCB_PG_ATTR_ENUM_MAX - 1 , } ;

enum dcbnl_tc_attrs { DCB_TC_ATTR_PARAM_UNDEFINED , DCB_TC_ATTR_PARAM_PGID , DCB_TC_ATTR_PARAM_UP_MAPPING , DCB_TC_ATTR_PARAM_STRICT_PRIO , DCB_TC_ATTR_PARAM_BW_PCT , DCB_TC_ATTR_PARAM_ALL , __DCB_TC_ATTR_PARAM_ENUM_MAX , DCB_TC_ATTR_PARAM_MAX = __DCB_TC_ATTR_PARAM_ENUM_MAX - 1 , } ;

enum dcbnl_cap_attrs { DCB_CAP_ATTR_UNDEFINED , DCB_CAP_ATTR_ALL , DCB_CAP_ATTR_PG , DCB_CAP_ATTR_PFC , DCB_CAP_ATTR_UP2TC , DCB_CAP_ATTR_PG_TCS , DCB_CAP_ATTR_PFC_TCS , DCB_CAP_ATTR_GSP , DCB_CAP_ATTR_BCN , __DCB_CAP_ATTR_ENUM_MAX , DCB_CAP_ATTR_MAX = __DCB_CAP_ATTR_ENUM_MAX - 1 , } ;

enum dcbnl_numtcs_attrs { DCB_NUMTCS_ATTR_UNDEFINED , DCB_NUMTCS_ATTR_ALL , DCB_NUMTCS_ATTR_PG , DCB_NUMTCS_ATTR_PFC , __DCB_NUMTCS_ATTR_ENUM_MAX , DCB_NUMTCS_ATTR_MAX = __DCB_NUMTCS_ATTR_ENUM_MAX - 1 , } ;

enum dcbnl_bcn_attrs { DCB_BCN_ATTR_UNDEFINED = 0 , DCB_BCN_ATTR_RP_0 , DCB_BCN_ATTR_RP_1 , DCB_BCN_ATTR_RP_2 , DCB_BCN_ATTR_RP_3 , DCB_BCN_ATTR_RP_4 , DCB_BCN_ATTR_RP_5 , DCB_BCN_ATTR_RP_6 , DCB_BCN_ATTR_RP_7 , DCB_BCN_ATTR_RP_ALL , DCB_BCN_ATTR_BCNA_0 , DCB_BCN_ATTR_BCNA_1 , DCB_BCN_ATTR_ALPHA , DCB_BCN_ATTR_BETA , DCB_BCN_ATTR_GD , DCB_BCN_ATTR_GI , DCB_BCN_ATTR_TMAX , DCB_BCN_ATTR_TD , DCB_BCN_ATTR_RMIN , DCB_BCN_ATTR_W , DCB_BCN_ATTR_RD , DCB_BCN_ATTR_RU , DCB_BCN_ATTR_WRTT , DCB_BCN_ATTR_RI , DCB_BCN_ATTR_C , DCB_BCN_ATTR_ALL , __DCB_BCN_ATTR_ENUM_MAX , DCB_BCN_ATTR_MAX = __DCB_BCN_ATTR_ENUM_MAX - 1 , } ;

enum dcb_general_attr_values { DCB_ATTR_VALUE_UNDEFINED = 0xff } ;

enum dcbnl_app_attrs { DCB_APP_ATTR_UNDEFINED , DCB_APP_ATTR_IDTYPE , DCB_APP_ATTR_ID , DCB_APP_ATTR_PRIORITY , __DCB_APP_ATTR_ENUM_MAX , DCB_APP_ATTR_MAX = __DCB_APP_ATTR_ENUM_MAX - 1 , } ;

struct dsa_switch { struct dsa_switch_tree * dst ; int index ; struct dsa_chip_data * pd ; struct dsa_switch_driver * drv ; struct mii_bus * master_mii_bus ; u32 dsa_port_mask ; u32 phys_port_mask ; struct mii_bus * slave_mii_bus ; struct net_device * ports [ 12 ] ; } ;

struct dsa_switch_tree { struct dsa_platform_data * pd ; struct net_device * master_netdev ; __be16 tag_protocol ; s8 cpu_switch ; s8 cpu_port ; int link_poll_needed ; struct work_struct link_poll_work ; struct timer_list link_poll_timer ; struct dsa_switch * ds [ 4 ] ; } ;

struct dsa_slave_priv { struct net_device * dev ; struct dsa_switch * parent ; u8 port ; struct phy_device * phy ; } ;

struct dsa_switch_driver { struct list_head list ; __be16 tag_protocol ; int priv_size ; char * ( * probe ) ( struct mii_bus * bus , int sw_addr ) ; int ( * setup ) ( struct dsa_switch * ds ) ; int ( * set_addr ) ( struct dsa_switch * ds , u8 * addr ) ; int ( * phy_read ) ( struct dsa_switch * ds , int port , int regnum ) ; int ( * phy_write ) ( struct dsa_switch * ds , int port , int regnum , u16 val ) ; void ( * poll_link ) ( struct dsa_switch * ds ) ; void ( * get_strings ) ( struct dsa_switch * ds , int port , uint8_t * data ) ; void ( * get_ethtool_stats ) ( struct dsa_switch * ds , int port , uint64_t * data ) ; int ( * get_sset_count ) ( struct dsa_switch * ds ) ; } ;

netdev_tx_t dsa_xmit ( struct sk_buff * skb , struct net_device * dev ) ;

netdev_tx_t edsa_xmit ( struct sk_buff * skb , struct net_device * dev ) ;

netdev_tx_t trailer_xmit ( struct sk_buff * skb , struct net_device * dev ) ;

struct mv88e6xxx_priv_state { struct mutex smi_mutex ; struct mutex ppu_mutex ; int ppu_disabled ; struct work_struct ppu_work ; struct timer_list ppu_timer ; struct mutex stats_mutex ; } ;

struct mv88e6xxx_hw_stat { char string [ 32 ] ; int sizeof_stat ; int reg ; } ;

int __mv88e6xxx_reg_read ( struct mii_bus * bus , int sw_addr , int addr , int reg ) ;

int mv88e6xxx_reg_read ( struct dsa_switch * ds , int addr , int reg ) ;

int __mv88e6xxx_reg_write ( struct mii_bus * bus , int sw_addr , int addr , int reg , u16 val ) ;

int mv88e6xxx_reg_write ( struct dsa_switch * ds , int addr , int reg , u16 val ) ;

int mv88e6xxx_config_prio ( struct dsa_switch * ds ) ;

int mv88e6xxx_set_addr_direct ( struct dsa_switch * ds , u8 * addr ) ;

int mv88e6xxx_set_addr_indirect ( struct dsa_switch * ds , u8 * addr ) ;

int mv88e6xxx_phy_read ( struct dsa_switch * ds , int addr , int regnum ) ;

int mv88e6xxx_phy_write ( struct dsa_switch * ds , int addr , int regnum , u16 val ) ;

void mv88e6xxx_ppu_state_init ( struct dsa_switch * ds ) ;

int mv88e6xxx_phy_read_ppu ( struct dsa_switch * ds , int addr , int regnum ) ;

int mv88e6xxx_phy_write_ppu ( struct dsa_switch * ds , int addr , int regnum , u16 val ) ;

void mv88e6xxx_poll_link ( struct dsa_switch * ds ) ;

void mv88e6xxx_get_strings ( struct dsa_switch * ds , int nr_stats , struct mv88e6xxx_hw_stat * stats , int port , uint8_t * data ) ;

void mv88e6xxx_get_ethtool_stats ( struct dsa_switch * ds , int nr_stats , struct mv88e6xxx_hw_stat * stats , int port , uint64_t * data ) ;

void register_switch_driver ( struct dsa_switch_driver * drv ) ;

void unregister_switch_driver ( struct dsa_switch_driver * drv ) ;

bool dsa_uses_dsa_tags ( void * dsa_ptr ) ;

bool dsa_uses_trailer_tags ( void * dsa_ptr ) ;

void dsa_slave_mii_bus_init ( struct dsa_switch * ds ) ;

struct net_device * dsa_slave_create ( struct dsa_switch * ds , struct device * parent , int port , char * name ) ;

int eth_header ( struct sk_buff * skb , struct net_device * dev , unsigned short type , const void * daddr , const void * saddr , unsigned len ) ;

int eth_rebuild_header ( struct sk_buff * skb ) ;

__be16 eth_type_trans ( struct sk_buff * skb , struct net_device * dev ) ;

int eth_header_parse ( const struct sk_buff * skb , unsigned char * haddr ) ;

int eth_header_cache ( const struct neighbour * neigh , struct hh_cache * hh ) ;

void eth_header_cache_update ( struct hh_cache * hh , const struct net_device * dev , const unsigned char * haddr ) ;

int eth_mac_addr ( struct net_device * dev , void * p ) ;

int eth_change_mtu ( struct net_device * dev , int new_mtu ) ;

int eth_validate_addr ( struct net_device * dev ) ;

void ether_setup ( struct net_device * dev ) ;

struct net_device * alloc_etherdev_mq ( int sizeof_priv , unsigned int queue_count ) ;

ssize_t sysfs_format_mac ( char * buf , const unsigned char * addr , int len ) ;

char * print_mac ( char * buf , const unsigned char * addr ) ;

struct igmphdr { __u8 type ; __u8 code ; __sum16 csum ; __be32 group ; } ;

struct igmpv3_grec { __u8 grec_type ; __u8 grec_auxwords ; __be16 grec_nsrcs ; __be32 grec_mca ; __be32 grec_src [ 0 ] ; } ;

struct igmpv3_report { __u8 type ; __u8 resv1 ; __be16 csum ; __be16 resv2 ; __be16 ngrec ; struct igmpv3_grec grec [ 0 ] ; } ;

struct igmpv3_query { __u8 type ; __u8 code ; __be16 csum ; __be32 group ; __u8 qrv : 3 , suppress : 1 , resv : 4 ; __u8 qqic ; __be16 nsrcs ; __be32 srcs [ 0 ] ; } ;

struct ip_sf_socklist { unsigned int sl_max ; unsigned int sl_count ; __be32 sl_addr [ 0 ] ; } ;

struct ip_mc_socklist { struct ip_mc_socklist * next ; struct ip_mreqn multi ; unsigned int sfmode ; struct ip_sf_socklist * sflist ; } ;
struct ip_sf_list { struct ip_sf_list * sf_next ; __be32 sf_inaddr ; unsigned long sf_count [ 2 ] ; unsigned char sf_gsresp ; unsigned char sf_oldin ; unsigned char sf_crcount ; } ;

struct ip_mc_list { struct in_device * interface ; __be32 multiaddr ; struct ip_sf_list * sources ; struct ip_sf_list * tomb ; unsigned int sfmode ; unsigned long sfcount [ 2 ] ; struct ip_mc_list * next ; struct timer_list timer ; int users ; atomic_t refcnt ; spinlock_t lock ; char tm_running ; char reporter ; char unsolicit_count ; char loaded ; unsigned char gsquery ; unsigned char crcount ; } ;

typedef unsigned long vifbitmap_t ;

typedef unsigned short vifi_t ;

struct vifctl { vifi_t vifc_vifi ; unsigned char vifc_flags ; unsigned char vifc_threshold ; unsigned int vifc_rate_limit ; struct in_addr vifc_lcl_addr ; struct in_addr vifc_rmt_addr ; } ;

struct mfcctl { struct in_addr mfcc_origin ; struct in_addr mfcc_mcastgrp ; vifi_t mfcc_parent ; unsigned char mfcc_ttls [ 32 ] ; unsigned int mfcc_pkt_cnt ; unsigned int mfcc_byte_cnt ; unsigned int mfcc_wrong_if ; int mfcc_expire ; } ;

struct sioc_sg_req { struct in_addr src ; struct in_addr grp ; unsigned long pktcnt ; unsigned long bytecnt ; unsigned long wrong_if ; } ;

struct sioc_vif_req { vifi_t vifi ; unsigned long icount ; unsigned long ocount ; unsigned long ibytes ; unsigned long obytes ; } ;

struct igmpmsg { __u32 unused1 , unused2 ; unsigned char im_msgtype ; unsigned char im_mbz ; unsigned char im_vif ; unsigned char unused3 ; struct in_addr im_src , im_dst ; } ;

struct pimreghdr { __u8 type ; __u8 reserved ; __be16 csum ; __be32 flags ; } ;

struct vif_device { struct net_device * dev ; unsigned long bytes_in , bytes_out ; unsigned long pkt_in , pkt_out ; unsigned long rate_limit ; unsigned char threshold ; unsigned short flags ; __be32 local , remote ; int link ; } ;

struct mfc_cache { struct mfc_cache * next ; struct net * mfc_net ; __be32 mfc_mcastgrp ; __be32 mfc_origin ; vifi_t mfc_parent ; int mfc_flags ; union { struct { unsigned long expires ; struct sk_buff_head unresolved ; } unres ; struct { unsigned long last_assert ; int minvif ; int maxvif ; unsigned long bytes ; unsigned long pkt ; unsigned long wrong_if ; unsigned char ttls [ 32 ] ; } res ; } mfc_un ; } ;

struct rtmsg ;
struct fib_config { u8 fc_dst_len ; u8 fc_tos ; u8 fc_protocol ; u8 fc_scope ; u8 fc_type ; u32 fc_table ; __be32 fc_dst ; __be32 fc_gw ; int fc_oif ; u32 fc_flags ; u32 fc_priority ; __be32 fc_prefsrc ; struct nlattr * fc_mx ; struct rtnexthop * fc_mp ; int fc_mx_len ; int fc_mp_len ; u32 fc_flow ; u32 fc_nlflags ; struct nl_info fc_nlinfo ; } ;

struct fib_info ;

struct fib_nh { struct net_device * nh_dev ; struct hlist_node nh_hash ; struct fib_info * nh_parent ; unsigned nh_flags ; unsigned char nh_scope ; int nh_weight ; int nh_power ; int nh_oif ; __be32 nh_gw ; } ;
struct fib_info { struct hlist_node fib_hash ; struct hlist_node fib_lhash ; struct net * fib_net ; int fib_treeref ; atomic_t fib_clntref ; int fib_dead ; unsigned fib_flags ; int fib_protocol ; __be32 fib_prefsrc ; u32 fib_priority ; u32 fib_metrics [ ( __RTAX_MAX - 1 ) ] ; int fib_nhs ; int fib_power ; struct fib_nh fib_nh [ 0 ] ; } ;
struct fib_rule ;
struct fib_result { unsigned char prefixlen ; unsigned char nh_sel ; unsigned char type ; unsigned char scope ; struct fib_info * fi ; struct fib_rule * r ; } ;

struct fib_result_nl { __be32 fl_addr ; u32 fl_mark ; unsigned char fl_tos ; unsigned char fl_scope ; unsigned char tb_id_in ; unsigned char tb_id ; unsigned char prefixlen ; unsigned char nh_sel ; unsigned char type ; unsigned char scope ; int err ; } ;

struct fib_table { struct hlist_node tb_hlist ; u32 tb_id ; int tb_default ; int ( * tb_lookup ) ( struct fib_table * tb , const struct flowi * flp , struct fib_result * res ) ; int ( * tb_insert ) ( struct fib_table * , struct fib_config * ) ; int ( * tb_delete ) ( struct fib_table * , struct fib_config * ) ; int ( * tb_dump ) ( struct fib_table * table , struct sk_buff * skb , struct netlink_callback * cb ) ; int ( * tb_flush ) ( struct fib_table * table ) ; void ( * tb_select_default ) ( struct fib_table * table , const struct flowi * flp , struct fib_result * res ) ; unsigned char tb_data [ 0 ] ; } ;

struct rt_hash_bucket { struct rtable * chain ; } ;

struct rt_cache_iter_state { struct seq_net_private p ; int bucket ; int genid ; } ;

void rt_cache_flush ( struct net * net , int delay ) ;

void rt_bind_peer ( struct rtable * rt , int create ) ;

void __ip_select_ident ( struct iphdr * iph , struct dst_entry * dst , int more ) ;

void ip_rt_redirect ( __be32 old_gw , __be32 daddr , __be32 new_gw , __be32 saddr , struct net_device * dev ) ;

void ip_rt_send_redirect ( struct sk_buff * skb ) ;

unsigned short ip_rt_frag_needed ( struct net * net , struct iphdr * iph , unsigned short new_mtu , struct net_device * dev ) ;

void ip_rt_get_source ( u8 * addr , struct rtable * rt ) ;

int ip_route_input ( struct sk_buff * skb , __be32 daddr , __be32 saddr , u8 tos , struct net_device * dev ) ;

int __ip_route_output_key ( struct net * net , struct rtable * * rp , const struct flowi * flp ) ;

int ip_route_output_flow ( struct net * net , struct rtable * * rp , struct flowi * flp , struct sock * sk , int flags ) ;

int ip_route_output_key ( struct net * net , struct rtable * * rp , struct flowi * flp ) ;

int ip_rt_dump ( struct sk_buff * skb , struct netlink_callback * cb ) ;

void ip_rt_multicast_event ( struct in_device * in_dev ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ip_rt_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ip_static_sysctl_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) inet_initpeers ( void ) ;

struct inet_peer * inet_getpeer ( __be32 daddr , int create ) ;

void inet_putpeer ( struct inet_peer * p ) ;

int inet_add_protocol ( const struct net_protocol * prot , unsigned char protocol ) ;

int inet_del_protocol ( const struct net_protocol * prot , unsigned char protocol ) ;

struct raw_hashinfo { rwlock_t lock ; struct hlist_head ht [ 256 ] ; } ;
struct raw_iter_state { struct seq_net_private p ; int bucket ; struct raw_hashinfo * h ; } ;

int ip_call_ra_chain ( struct sk_buff * skb ) ;

int ip_local_deliver ( struct sk_buff * skb ) ;

int ip_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) ;

struct ipfrag_skb_cb { struct inet_skb_parm h ; int offset ; } ;

struct ipq { struct inet_frag_queue q ; u32 user ; __be32 saddr ; __be32 daddr ; __be16 id ; u8 protocol ; int iif ; unsigned int rid ; struct inet_peer * peer ; } ;

int ip_frag_nqueues ( struct net * net ) ;

int ip_frag_mem ( struct net * net ) ;

struct ip4_create_arg { struct iphdr * iph ; u32 user ; } ;

int ip_defrag ( struct sk_buff * skb , u32 user ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ipfrag_init ( void ) ;

int ip_forward ( struct sk_buff * skb ) ;

void ip_options_build ( struct sk_buff * skb , struct ip_options * opt , __be32 daddr , struct rtable * rt , int is_frag ) ;

int ip_options_echo ( struct ip_options * dopt , struct sk_buff * skb ) ;

void ip_options_fragment ( struct sk_buff * skb ) ;

int ip_options_compile ( struct net * net , struct ip_options * opt , struct sk_buff * skb ) ;

void ip_options_undo ( struct ip_options * opt ) ;

int ip_options_get_from_user ( struct net * net , struct ip_options * * optp , unsigned char * data , int optlen ) ;

int ip_options_get ( struct net * net , struct ip_options * * optp , unsigned char * data , int optlen ) ;

void ip_forward_options ( struct sk_buff * skb ) ;

int ip_options_rcv_srr ( struct sk_buff * skb ) ;

enum nf_br_hook_priorities { NF_BR_PRI_FIRST = ( - ( ( int ) ( ~ 0U >> 1 ) ) - 1 ) , NF_BR_PRI_NAT_DST_BRIDGED = - 300 , NF_BR_PRI_FILTER_BRIDGED = - 200 , NF_BR_PRI_BRNF = 0 , NF_BR_PRI_NAT_DST_OTHER = 100 , NF_BR_PRI_FILTER_OTHER = 200 , NF_BR_PRI_NAT_SRC = 300 , NF_BR_PRI_LAST = ( ( int ) ( ~ 0U >> 1 ) ) , } ;

int __ip_local_out ( struct sk_buff * skb ) ;

int ip_local_out ( struct sk_buff * skb ) ;

int ip_build_and_send_pkt ( struct sk_buff * skb , struct sock * sk , __be32 saddr , __be32 daddr , struct ip_options * opt ) ;

int ip_mc_output ( struct sk_buff * skb ) ;

int ip_output ( struct sk_buff * skb ) ;

int ip_queue_xmit ( struct sk_buff * skb , int ipfragok ) ;

int ip_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) ;

int ip_generic_getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) ;

int ip_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , struct ipcm_cookie * ipc , struct rtable * * rtp , unsigned int flags ) ;

ssize_t ip_append_page ( struct sock * sk , struct page * page , int offset , size_t size , int flags ) ;

int ip_push_pending_frames ( struct sock * sk ) ;

void ip_flush_pending_frames ( struct sock * sk ) ;

void ip_send_reply ( struct sock * sk , struct sk_buff * skb , struct ip_reply_arg * arg , unsigned int len ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ip_init ( void ) ;

void ip_cmsg_recv ( struct msghdr * msg , struct sk_buff * skb ) ;

int ip_cmsg_send ( struct net * net , struct msghdr * msg , struct ipcm_cookie * ipc ) ;

int ip_ra_control ( struct sock * sk , unsigned char on , void ( * destructor ) ( struct sock * ) ) ;

void ip_icmp_error ( struct sock * sk , struct sk_buff * skb , int err , __be16 port , u32 info , u8 * payload ) ;

void ip_local_error ( struct sock * sk , int err , __be32 daddr , __be16 port , u32 info ) ;

int ip_recv_error ( struct sock * sk , struct msghdr * msg , int len ) ;

int ip_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

int compat_ip_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

int ip_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

int compat_ip_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

struct inet_bind_bucket * inet_bind_bucket_create ( struct kmem_cache * cachep , struct net * net , struct inet_bind_hashbucket * head , const unsigned short snum ) ;

void inet_bind_bucket_destroy ( struct kmem_cache * cachep , struct inet_bind_bucket * tb ) ;

void inet_bind_hash ( struct sock * sk , struct inet_bind_bucket * tb , const unsigned short snum ) ;

void inet_put_port ( struct sock * sk ) ;

void __inet_inherit_port ( struct sock * sk , struct sock * child ) ;

struct sock * __inet_lookup_listener ( struct net * net , struct inet_hashinfo * hashinfo , const __be32 daddr , const unsigned short hnum , const int dif ) ;

struct sock * __inet_lookup_established ( struct net * net , struct inet_hashinfo * hashinfo , const __be32 saddr , const __be16 sport , const __be32 daddr , const u16 hnum , const int dif ) ;

void __inet_hash_nolisten ( struct sock * sk ) ;

void inet_hash ( struct sock * sk ) ;

void inet_unhash ( struct sock * sk ) ;

int __inet_hash_connect ( struct inet_timewait_death_row * death_row , struct sock * sk , u32 port_offset , int ( * check_established ) ( struct inet_timewait_death_row * , struct sock * , __u16 , struct inet_timewait_sock * * ) , void ( * hash ) ( struct sock * sk ) ) ;

int inet_hash_connect ( struct inet_timewait_death_row * death_row , struct sock * sk ) ;

void inet_hashinfo_init ( struct inet_hashinfo * h ) ;

void inet_twsk_put ( struct inet_timewait_sock * tw ) ;

void __inet_twsk_hashdance ( struct inet_timewait_sock * tw , struct sock * sk , struct inet_hashinfo * hashinfo ) ;

struct inet_timewait_sock * inet_twsk_alloc ( const struct sock * sk , const int state ) ;

void inet_twdr_hangman ( unsigned long data ) ;

void inet_twdr_twkill_work ( struct work_struct * work ) ;

void inet_twsk_deschedule ( struct inet_timewait_sock * tw , struct inet_timewait_death_row * twdr ) ;

void inet_twsk_schedule ( struct inet_timewait_sock * tw , struct inet_timewait_death_row * twdr , const int timeo , const int timewait_len ) ;

void inet_twdr_twcal_tick ( unsigned long data ) ;

void inet_twsk_purge ( struct net * net , struct inet_hashinfo * hashinfo , struct inet_timewait_death_row * twdr , int family ) ;

void inet_get_local_port_range ( int * low , int * high ) ;

int inet_csk_bind_conflict ( const struct sock * sk , const struct inet_bind_bucket * tb ) ;

int inet_csk_get_port ( struct sock * sk , unsigned short snum ) ;

struct sock * inet_csk_accept ( struct sock * sk , int flags , int * err ) ;

void inet_csk_init_xmit_timers ( struct sock * sk , void ( * retransmit_handler ) ( unsigned long ) , void ( * delack_handler ) ( unsigned long ) , void ( * keepalive_handler ) ( unsigned long ) ) ;

void inet_csk_clear_xmit_timers ( struct sock * sk ) ;

void inet_csk_delete_keepalive_timer ( struct sock * sk ) ;

void inet_csk_reset_keepalive_timer ( struct sock * sk , unsigned long len ) ;

struct dst_entry * inet_csk_route_req ( struct sock * sk , const struct request_sock * req ) ;

struct request_sock * inet_csk_search_req ( const struct sock * sk , struct request_sock * * * prevp , const __be16 rport , const __be32 raddr , const __be32 laddr ) ;

void inet_csk_reqsk_queue_hash_add ( struct sock * sk , struct request_sock * req , unsigned long timeout ) ;

void inet_csk_reqsk_queue_prune ( struct sock * parent , const unsigned long interval , const unsigned long timeout , const unsigned long max_rto ) ;

struct sock * inet_csk_clone ( struct sock * sk , const struct request_sock * req , const gfp_t priority ) ;

void inet_csk_destroy_sock ( struct sock * sk ) ;

int inet_csk_listen_start ( struct sock * sk , const int nr_table_entries ) ;

void inet_csk_listen_stop ( struct sock * sk ) ;

void inet_csk_addr2sockaddr ( struct sock * sk , struct sockaddr * uaddr ) ;

int inet_csk_compat_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

int inet_csk_compat_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;


struct tcp_splice_state { struct pipe_inode_info * pipe ; size_t len ; unsigned int flags ; } ;

void tcp_enter_memory_pressure ( struct sock * sk ) ;

unsigned int tcp_poll ( struct file * file , struct socket * sock , poll_table * wait ) ;

int tcp_ioctl ( struct sock * sk , int cmd , unsigned long arg ) ;

ssize_t tcp_splice_read ( struct socket * sock , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) ;

struct sk_buff * sk_stream_alloc_skb ( struct sock * sk , int size , gfp_t gfp ) ;

ssize_t tcp_sendpage ( struct socket * sock , struct page * page , int offset , size_t size , int flags ) ;

int tcp_sendmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size ) ;

void tcp_cleanup_rbuf ( struct sock * sk , int copied ) ;

int tcp_read_sock ( struct sock * sk , read_descriptor_t * desc , sk_read_actor_t recv_actor ) ;

int tcp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int nonblock , int flags , int * addr_len ) ;

void tcp_set_state ( struct sock * sk , int state ) ;

void tcp_shutdown ( struct sock * sk , int how ) ;

void tcp_close ( struct sock * sk , long timeout ) ;

int tcp_disconnect ( struct sock * sk , int flags ) ;

int tcp_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

int compat_tcp_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

void tcp_get_info ( struct sock * sk , struct tcp_info * info ) ;

int tcp_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

int compat_tcp_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

struct sk_buff * tcp_tso_segment ( struct sk_buff * skb , int features ) ;

struct sk_buff * * tcp_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) ;

int tcp_gro_complete ( struct sk_buff * skb ) ;

void tcp_free_md5sig_pool ( void ) ;

struct tcp_md5sig_pool * * tcp_alloc_md5sig_pool ( struct sock * sk ) ;

struct tcp_md5sig_pool * __tcp_get_md5sig_pool ( int cpu ) ;

void __tcp_put_md5sig_pool ( void ) ;

int tcp_md5_hash_header ( struct tcp_md5sig_pool * hp , struct tcphdr * th ) ;

int tcp_md5_hash_skb_data ( struct tcp_md5sig_pool * hp , struct sk_buff * skb , unsigned header_len ) ;

int tcp_md5_hash_key ( struct tcp_md5sig_pool * hp , struct tcp_md5sig_key * key ) ;

void tcp_done ( struct sock * sk ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) tcp_init ( void ) ;

void tcp_enter_quickack_mode ( struct sock * sk ) ;

void tcp_initialize_rcv_mss ( struct sock * sk ) ;

void tcp_rcv_space_adjust ( struct sock * sk ) ;

void tcp_update_metrics ( struct sock * sk ) ;

__u32 tcp_init_cwnd ( struct tcp_sock * tp , struct dst_entry * dst ) ;

void tcp_enter_cwr ( struct sock * sk , const int set_ssthresh ) ;

struct tcp_sacktag_state { int reord ; int fack_count ; int flag ; } ;

int tcp_use_frto ( struct sock * sk ) ;

void tcp_enter_frto ( struct sock * sk ) ;

void tcp_clear_retrans ( struct tcp_sock * tp ) ;

void tcp_enter_loss ( struct sock * sk , int how ) ;

void tcp_simple_retransmit ( struct sock * sk ) ;

void tcp_parse_options ( struct sk_buff * skb , struct tcp_options_received * opt_rx , int estab ) ;

u8 * tcp_parse_md5sig_option ( struct tcphdr * th ) ;

void tcp_cwnd_application_limited ( struct sock * sk ) ;

int tcp_rcv_established ( struct sock * sk , struct sk_buff * skb , struct tcphdr * th , unsigned len ) ;

int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , struct tcphdr * th , unsigned len ) ;

void tcp_select_initial_window ( int __space , __u32 mss , __u32 * rcv_wnd , __u32 * window_clamp , int wscale_ok , __u8 * rcv_wscale ) ;

struct tcp_out_options { u8 options ; u8 ws ; u8 num_sack_blocks ; u16 mss ; __u32 tsval , tsecr ; } ;

int tcp_fragment ( struct sock * sk , struct sk_buff * skb , u32 len , unsigned int mss_now ) ;

int tcp_trim_head ( struct sock * sk , struct sk_buff * skb , u32 len ) ;

int tcp_mtu_to_mss ( struct sock * sk , int pmtu ) ;

int tcp_mss_to_mtu ( struct sock * sk , int mss ) ;

void tcp_mtup_init ( struct sock * sk ) ;

unsigned int tcp_sync_mss ( struct sock * sk , u32 pmtu ) ;

unsigned int tcp_current_mss ( struct sock * sk ) ;

int tcp_may_send_now ( struct sock * sk ) ;

void __tcp_push_pending_frames ( struct sock * sk , unsigned int cur_mss , int nonagle ) ;

void tcp_push_one ( struct sock * sk , unsigned int mss_now ) ;

u32 __tcp_select_window ( struct sock * sk ) ;

int tcp_retransmit_skb ( struct sock * sk , struct sk_buff * skb ) ;

void tcp_xmit_retransmit_queue ( struct sock * sk ) ;

void tcp_send_fin ( struct sock * sk ) ;

void tcp_send_active_reset ( struct sock * sk , gfp_t priority ) ;

int tcp_send_synack ( struct sock * sk ) ;

struct sk_buff * tcp_make_synack ( struct sock * sk , struct dst_entry * dst , struct request_sock * req ) ;

int tcp_connect ( struct sock * sk ) ;

void tcp_send_delayed_ack ( struct sock * sk ) ;

void tcp_send_ack ( struct sock * sk ) ;

int tcp_write_wakeup ( struct sock * sk ) ;

void tcp_send_probe0 ( struct sock * sk ) ;

void tcp_init_xmit_timers ( struct sock * sk ) ;

void tcp_retransmit_timer ( struct sock * sk ) ;

void tcp_set_keepalive ( struct sock * sk , int val ) ;

int tcp_twsk_unique ( struct sock * sk , struct sock * sktw , void * twp ) ;

int tcp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) ;

void tcp_v4_err ( struct sk_buff * icmp_skb , u32 info ) ;

void tcp_v4_send_check ( struct sock * sk , int len , struct sk_buff * skb ) ;

int tcp_v4_gso_send_check ( struct sk_buff * skb ) ;

struct tcp_md5sig_key * tcp_v4_md5_lookup ( struct sock * sk , struct sock * addr_sk ) ;

int tcp_v4_md5_do_add ( struct sock * sk , __be32 addr , u8 * newkey , u8 newkeylen ) ;

int tcp_v4_md5_do_del ( struct sock * sk , __be32 addr ) ;

int tcp_v4_md5_hash_skb ( char * md5_hash , struct tcp_md5sig_key * key , struct sock * sk , struct request_sock * req , struct sk_buff * skb ) ;

int tcp_v4_conn_request ( struct sock * sk , struct sk_buff * skb ) ;

struct sock * tcp_v4_syn_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) ;

int tcp_v4_do_rcv ( struct sock * sk , struct sk_buff * skb ) ;

int tcp_v4_rcv ( struct sk_buff * skb ) ;

int tcp_v4_remember_stamp ( struct sock * sk ) ;

int tcp_v4_tw_remember_stamp ( struct inet_timewait_sock * tw ) ;

void tcp_v4_destroy_sock ( struct sock * sk ) ;

int tcp_proc_register ( struct net * net , struct tcp_seq_afinfo * afinfo ) ;

void tcp_proc_unregister ( struct net * net , struct tcp_seq_afinfo * afinfo ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) tcp4_proc_init ( void ) ;

void tcp4_proc_exit ( void ) ;

struct sk_buff * * tcp4_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) ;

int tcp4_gro_complete ( struct sk_buff * skb ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) tcp_v4_init ( void ) ;

enum tcp_tw_status tcp_timewait_state_process ( struct inet_timewait_sock * tw , struct sk_buff * skb , const struct tcphdr * th ) ;

void tcp_time_wait ( struct sock * sk , int state , int timeo ) ;

void tcp_twsk_destructor ( struct sock * sk ) ;

struct sock * tcp_create_openreq_child ( struct sock * sk , struct request_sock * req , struct sk_buff * skb ) ;

struct sock * tcp_check_req ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct request_sock * * prev ) ;

int tcp_child_process ( struct sock * parent , struct sock * child , struct sk_buff * skb ) ;

int tcp_register_congestion_control ( struct tcp_congestion_ops * ca ) ;

void tcp_unregister_congestion_control ( struct tcp_congestion_ops * ca ) ;

void tcp_init_congestion_control ( struct sock * sk ) ;

void tcp_cleanup_congestion_control ( struct sock * sk ) ;

int tcp_set_default_congestion_control ( const char * name ) ;

void tcp_get_available_congestion_control ( char * buf , size_t maxlen ) ;

void tcp_get_default_congestion_control ( char * name ) ;

void tcp_get_allowed_congestion_control ( char * buf , size_t maxlen ) ;

int tcp_set_allowed_congestion_control ( char * val ) ;

int tcp_set_congestion_control ( struct sock * sk , const char * name ) ;

int tcp_is_cwnd_limited ( const struct sock * sk , u32 in_flight ) ;

void tcp_slow_start ( struct tcp_sock * tp ) ;

void tcp_cong_avoid_ai ( struct tcp_sock * tp , u32 w ) ;

void tcp_reno_cong_avoid ( struct sock * sk , u32 ack , u32 in_flight ) ;

u32 tcp_reno_ssthresh ( struct sock * sk ) ;

u32 tcp_reno_min_cwnd ( const struct sock * sk ) ;

int ip4_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) ;

void raw_hash_sk ( struct sock * sk ) ;

void raw_unhash_sk ( struct sock * sk ) ;

int raw_local_deliver ( struct sk_buff * skb , int protocol ) ;

void raw_icmp_error ( struct sk_buff * skb , int protocol , u32 info ) ;

int raw_rcv ( struct sock * sk , struct sk_buff * skb ) ;

void * raw_seq_start ( struct seq_file * seq , loff_t * pos ) ;

void * raw_seq_next ( struct seq_file * seq , void * v , loff_t * pos ) ;

void raw_seq_stop ( struct seq_file * seq , void * v ) ;

int raw_seq_open ( struct inode * ino , struct file * file , struct raw_hashinfo * h , const struct seq_operations * ops ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) raw_proc_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) raw_proc_exit ( void ) ;

int udp_lib_get_port ( struct sock * sk , unsigned short snum , int ( * saddr_comp ) ( const struct sock * sk1 , const struct sock * sk2 ) ) ;

int udp_v4_get_port ( struct sock * sk , unsigned short snum ) ;

struct sock * udp4_lib_lookup ( struct net * net , __be32 saddr , __be16 sport , __be32 daddr , __be16 dport , int dif ) ;

void __udp4_lib_err ( struct sk_buff * skb , u32 info , struct udp_table * udptable ) ;

void udp_err ( struct sk_buff * skb , u32 info ) ;

void udp_flush_pending_frames ( struct sock * sk ) ;

int udp_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) ;

int udp_sendpage ( struct sock * sk , struct page * page , int offset , size_t size , int flags ) ;

int udp_ioctl ( struct sock * sk , int cmd , unsigned long arg ) ;

int udp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) ;

int udp_disconnect ( struct sock * sk , int flags ) ;

void udp_lib_unhash ( struct sock * sk ) ;

int udp_queue_rcv_skb ( struct sock * sk , struct sk_buff * skb ) ;

int __udp4_lib_rcv ( struct sk_buff * skb , struct udp_table * udptable , int proto ) ;

int udp_rcv ( struct sk_buff * skb ) ;

void udp_destroy_sock ( struct sock * sk ) ;

int udp_lib_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen , int ( * push_pending_frames ) ( struct sock * ) ) ;

int udp_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

int compat_udp_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

int udp_lib_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

int udp_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

int compat_udp_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

unsigned int udp_poll ( struct file * file , struct socket * sock , poll_table * wait ) ;

int udp_proc_register ( struct net * net , struct udp_seq_afinfo * afinfo ) ;

void udp_proc_unregister ( struct net * net , struct udp_seq_afinfo * afinfo ) ;

int udp4_seq_show ( struct seq_file * seq , void * v ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) udp4_proc_init ( void ) ;

void udp4_proc_exit ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) udp_table_init ( struct udp_table * table ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) udp_init ( void ) ;

int udp4_ufo_send_check ( struct sk_buff * skb ) ;

struct sk_buff * udp4_ufo_fragment ( struct sk_buff * skb , int features ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) udplite4_register ( void ) ;

typedef struct { char ax25_call [ 7 ] ; } ax25_address ;

struct sockaddr_ax25 { sa_family_t sax25_family ; ax25_address sax25_call ; int sax25_ndigis ; } ;

struct full_sockaddr_ax25 { struct sockaddr_ax25 fsa_ax25 ; ax25_address fsa_digipeater [ 8 ] ; } ;

struct ax25_routes_struct { ax25_address port_addr ; ax25_address dest_addr ; unsigned char digi_count ; ax25_address digi_addr [ 8 ] ; } ;

struct ax25_route_opt_struct { ax25_address port_addr ; ax25_address dest_addr ; int cmd ; int arg ; } ;

struct ax25_ctl_struct { ax25_address port_addr ; ax25_address source_addr ; ax25_address dest_addr ; unsigned int cmd ; unsigned long arg ; unsigned char digi_count ; ax25_address digi_addr [ 8 ] ; } ;

struct ax25_info_struct_deprecated { unsigned int n2 , n2count ; unsigned int t1 , t1timer ; unsigned int t2 , t2timer ; unsigned int t3 , t3timer ; unsigned int idle , idletimer ; unsigned int state ; unsigned int rcv_q , snd_q ; } ;

struct ax25_info_struct { unsigned int n2 , n2count ; unsigned int t1 , t1timer ; unsigned int t2 , t2timer ; unsigned int t3 , t3timer ; unsigned int idle , idletimer ; unsigned int state ; unsigned int rcv_q , snd_q ; unsigned int vs , vr , va , vs_max ; unsigned int paclen ; unsigned int window ; } ;

struct ax25_fwd_struct { ax25_address port_from ; ax25_address port_to ; } ;

enum { AX25_STATE_0 , AX25_STATE_1 , AX25_STATE_2 , AX25_STATE_3 , AX25_STATE_4 } ;
enum { AX25_PROTO_STD_SIMPLEX , AX25_PROTO_STD_DUPLEX , __AX25_PROTO_MAX , AX25_PROTO_MAX = __AX25_PROTO_MAX - 1 } ;
enum { AX25_VALUES_IPDEFMODE , AX25_VALUES_AXDEFMODE , AX25_VALUES_BACKOFF , AX25_VALUES_CONMODE , AX25_VALUES_WINDOW , AX25_VALUES_EWINDOW , AX25_VALUES_T1 , AX25_VALUES_T2 , AX25_VALUES_T3 , AX25_VALUES_IDLE , AX25_VALUES_N2 , AX25_VALUES_PACLEN , AX25_VALUES_PROTOCOL , AX25_VALUES_DS_TIMEOUT , AX25_MAX_VALUES } ;

typedef struct ax25_uid_assoc { struct hlist_node uid_node ; atomic_t refcount ; uid_t uid ; ax25_address call ; } ax25_uid_assoc ;

typedef struct { ax25_address calls [ 8 ] ; unsigned char repeated [ 8 ] ; unsigned char ndigi ; signed char lastrepeat ; } ax25_digi ;


typedef struct ax25_route { struct ax25_route * next ; atomic_t refcount ; ax25_address callsign ; struct net_device * dev ; ax25_digi * digipeat ; char ip_mode ; } ax25_route ;

typedef struct { char slave ; struct timer_list slave_timer ; unsigned short slave_timeout ; } ax25_dama_info ;


typedef struct ax25_dev { struct ax25_dev * next ; struct net_device * dev ; struct net_device * forward ; struct ctl_table * systable ; int values [ AX25_MAX_VALUES ] ; } ax25_dev ;


typedef struct ax25_cb { struct hlist_node ax25_node ; ax25_address source_addr , dest_addr ; ax25_digi * digipeat ; ax25_dev * ax25_dev ; unsigned char iamdigi ; unsigned char state , modulus , pidincl ; unsigned short vs , vr , va ; unsigned char condition , backoff ; unsigned char n2 , n2count ; struct timer_list t1timer , t2timer , t3timer , idletimer ; unsigned long t1 , t2 , t3 , idle , rtt ; unsigned short paclen , fragno , fraglen ; struct sk_buff_head write_queue ; struct sk_buff_head reseq_queue ; struct sk_buff_head ack_queue ; struct sk_buff_head frag_queue ; unsigned char window ; struct timer_list timer , dtimer ; struct sock * sk ; atomic_t refcount ; } ax25_cb ;

struct ax25_protocol { struct ax25_protocol * next ; unsigned int pid ; int ( * func ) ( struct sk_buff * , ax25_cb * ) ; } ;

struct ax25_linkfail { struct hlist_node lf_node ; void ( * func ) ( ax25_cb * , int ) ; } ;

struct nr_route_struct { int type ; ax25_address callsign ; char device [ 16 ] ; unsigned int quality ; char mnemonic [ 7 ] ; ax25_address neighbour ; unsigned int obs_count ; unsigned int ndigis ; ax25_address digipeaters [ 8 ] ; } ;

enum { NR_STATE_0 , NR_STATE_1 , NR_STATE_2 , NR_STATE_3 } ;
struct nr_sock { struct sock sock ; ax25_address user_addr , source_addr , dest_addr ; struct net_device * device ; unsigned char my_index , my_id ; unsigned char your_index , your_id ; unsigned char state , condition , bpqext , window ; unsigned short vs , vr , va , vl ; unsigned char n2 , n2count ; unsigned long t1 , t2 , t4 , idle ; unsigned short fraglen ; struct timer_list t1timer ; struct timer_list t2timer ; struct timer_list t4timer ; struct timer_list idletimer ; struct sk_buff_head ack_queue ; struct sk_buff_head reseq_queue ; struct sk_buff_head frag_queue ; } ;

struct nr_neigh { struct hlist_node neigh_node ; ax25_address callsign ; ax25_digi * digipeat ; ax25_cb * ax25 ; struct net_device * dev ; unsigned char quality ; unsigned char locked ; unsigned short count ; unsigned int number ; unsigned char failed ; atomic_t refcount ; } ;

struct nr_route { unsigned char quality ; unsigned char obs_count ; struct nr_neigh * neighbour ; } ;

struct nr_node { struct hlist_node node_node ; ax25_address callsign ; char mnemonic [ 7 ] ; unsigned char which ; unsigned char count ; struct nr_route routes [ 3 ] ; atomic_t refcount ; spinlock_t node_lock ; } ;

int arp_mc_map ( __be32 addr , u8 * haddr , struct net_device * dev , int dir ) ;

int arp_find ( unsigned char * haddr , struct sk_buff * skb ) ;

int arp_bind_neighbour ( struct dst_entry * dst ) ;

struct sk_buff * arp_create ( int type , int ptype , __be32 dest_ip , struct net_device * dev , __be32 src_ip , const unsigned char * dest_hw , const unsigned char * src_hw , const unsigned char * target_hw ) ;

void arp_xmit ( struct sk_buff * skb ) ;

void arp_send ( int type , int ptype , __be32 dest_ip , struct net_device * dev , __be32 src_ip , const unsigned char * dest_hw , const unsigned char * src_hw , const unsigned char * target_hw ) ;

int arp_ioctl ( struct net * net , unsigned int cmd , void * arg ) ;

void arp_ifdown ( struct net_device * dev ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) arp_init ( void ) ;

struct icmp_bxm { struct sk_buff * skb ; int offset ; int data_len ; struct { struct icmphdr icmph ; __be32 times [ 3 ] ; } data ; int head_len ; struct ip_options replyopts ; unsigned char optbuf [ 40 ] ; } ;

struct icmp_control { void ( * handler ) ( struct sk_buff * skb ) ; short error ; } ;

int xrlim_allow ( struct dst_entry * dst , int timeout ) ;

void icmp_out_count ( struct net * net , unsigned char type ) ;

void icmp_send ( struct sk_buff * skb_in , int type , int code , __be32 info ) ;

int icmp_rcv ( struct sk_buff * skb ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) icmp_init ( void ) ;

void in_dev_finish_destroy ( struct in_device * idev ) ;

int inet_addr_onlink ( struct in_device * in_dev , __be32 a , __be32 b ) ;

struct in_device * inetdev_by_index ( struct net * net , int ifindex ) ;

struct in_ifaddr * inet_ifa_byprefix ( struct in_device * in_dev , __be32 prefix , __be32 mask ) ;

int devinet_ioctl ( struct net * net , unsigned int cmd , void * arg ) ;

__be32 inet_select_addr ( const struct net_device * dev , __be32 dst , int scope ) ;

__be32 inet_confirm_addr ( struct in_device * in_dev , __be32 dst , __be32 local , int scope ) ;

int register_inetaddr_notifier ( struct notifier_block * nb ) ;

int unregister_inetaddr_notifier ( struct notifier_block * nb ) ;

int ipv4_doint_and_flush ( ctl_table * ctl , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int ipv4_doint_and_flush_strategy ( ctl_table * table , void * oldval , size_t * oldlenp , void * newval , size_t newlen ) ;


void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) devinet_init ( void ) ;

struct ip_tunnel_parm { char name [ 16 ] ; int link ; __be16 i_flags ; __be16 o_flags ; __be32 i_key ; __be32 o_key ; struct iphdr iph ; } ;

struct ip_tunnel_prl { __be32 addr ; __u16 flags ; __u16 __reserved ; __u32 datalen ; __u32 __reserved2 ; } ;

enum { IFLA_GRE_UNSPEC , IFLA_GRE_LINK , IFLA_GRE_IFLAGS , IFLA_GRE_OFLAGS , IFLA_GRE_IKEY , IFLA_GRE_OKEY , IFLA_GRE_LOCAL , IFLA_GRE_REMOTE , IFLA_GRE_TTL , IFLA_GRE_TOS , IFLA_GRE_PMTUDISC , __IFLA_GRE_MAX , } ;
struct ip_tunnel { struct ip_tunnel * next ; struct net_device * dev ; int err_count ; unsigned long err_time ; __u32 i_seqno ; __u32 o_seqno ; int hlen ; int mlink ; struct ip_tunnel_parm parms ; struct ip_tunnel_prl_entry * prl ; unsigned int prl_count ; } ;

struct ip_tunnel_prl_entry { struct ip_tunnel_prl_entry * next ; __be32 addr ; u16 flags ; } ;

void inet_sock_destruct ( struct sock * sk ) ;

int inet_listen ( struct socket * sock , int backlog ) ;

void build_ehash_secret ( void ) ;

int inet_release ( struct socket * sock ) ;

int inet_bind ( struct socket * sock , struct sockaddr * uaddr , int addr_len ) ;

int inet_dgram_connect ( struct socket * sock , struct sockaddr * uaddr , int addr_len , int flags ) ;

int inet_stream_connect ( struct socket * sock , struct sockaddr * uaddr , int addr_len , int flags ) ;

int inet_accept ( struct socket * sock , struct socket * newsock , int flags ) ;

int inet_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) ;

int inet_sendmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size ) ;

int inet_shutdown ( struct socket * sock , int how ) ;

int inet_ioctl ( struct socket * sock , unsigned int cmd , unsigned long arg ) ;

void inet_register_protosw ( struct inet_protosw * p ) ;

void inet_unregister_protosw ( struct inet_protosw * p ) ;

int inet_sk_rebuild_header ( struct sock * sk ) ;

int inet_ctl_sock_create ( struct sock * * sk , unsigned short family , unsigned short type , unsigned char protocol , struct net * net ) ;

unsigned long snmp_fold_field ( void * mib [ ] , int offt ) ;

int snmp_mib_init ( void * ptr [ 2 ] , size_t mibsize ) ;

void snmp_mib_free ( void * ptr [ 2 ] ) ;

int igmp_rcv ( struct sk_buff * skb ) ;

void ip_mc_inc_group ( struct in_device * in_dev , __be32 addr ) ;

void ip_mc_rejoin_group ( struct ip_mc_list * im ) ;

void ip_mc_dec_group ( struct in_device * in_dev , __be32 addr ) ;

void ip_mc_unmap ( struct in_device * in_dev ) ;

void ip_mc_remap ( struct in_device * in_dev ) ;

void ip_mc_down ( struct in_device * in_dev ) ;

void ip_mc_init_dev ( struct in_device * in_dev ) ;

void ip_mc_up ( struct in_device * in_dev ) ;

void ip_mc_destroy_dev ( struct in_device * in_dev ) ;

int ip_mc_join_group ( struct sock * sk , struct ip_mreqn * imr ) ;

int ip_mc_leave_group ( struct sock * sk , struct ip_mreqn * imr ) ;

int ip_mc_source ( int add , int omode , struct sock * sk , struct ip_mreq_source * mreqs , int ifindex ) ;

int ip_mc_msfilter ( struct sock * sk , struct ip_msfilter * msf , int ifindex ) ;

int ip_mc_msfget ( struct sock * sk , struct ip_msfilter * msf , struct ip_msfilter * optval , int * optlen ) ;

int ip_mc_gsfget ( struct sock * sk , struct group_filter * gsf , struct group_filter * optval , int * optlen ) ;

int ip_mc_sf_allow ( struct sock * sk , __be32 loc_addr , __be32 rmt_addr , int dif ) ;

void ip_mc_drop_socket ( struct sock * sk ) ;

int ip_check_mc ( struct in_device * in_dev , __be32 mc_addr , __be32 src_addr , u16 proto ) ;

struct igmp_mc_iter_state { struct seq_net_private p ; struct net_device * dev ; struct in_device * in_dev ; } ;

struct igmp_mcf_iter_state { struct seq_net_private p ; struct net_device * dev ; struct in_device * idev ; struct ip_mc_list * im ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) igmp_mc_proc_init ( void ) ;

struct fib_table * fib_new_table ( struct net * net , u32 id ) ;

struct fib_table * fib_get_table ( struct net * net , u32 id ) ;

void fib_select_default ( struct net * net , const struct flowi * flp , struct fib_result * res ) ;

struct net_device * ip_dev_find ( struct net * net , __be32 addr ) ;

unsigned int inet_addr_type ( struct net * net , __be32 addr ) ;

unsigned int inet_dev_addr_type ( struct net * net , const struct net_device * dev , __be32 addr ) ;

int fib_validate_source ( __be32 src , __be32 dst , u8 tos , int oif , struct net_device * dev , __be32 * spec_dst , u32 * itag , u32 mark ) ;

int ip_rt_ioctl ( struct net * net , unsigned int cmd , void * arg ) ;

void fib_add_ifaddr ( struct in_ifaddr * ifa ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ip_fib_init ( void ) ;

struct fib_alias { struct list_head fa_list ; struct fib_info * fa_info ; u8 fa_tos ; u8 fa_type ; u8 fa_scope ; u8 fa_state ; } ;

void free_fib_info ( struct fib_info * fi ) ;

void fib_release_info ( struct fib_info * fi ) ;

int ip_fib_check_default ( __be32 gw , struct net_device * dev ) ;

void rtmsg_fib ( int event , __be32 key , struct fib_alias * fa , int dst_len , u32 tb_id , struct nl_info * info , unsigned int nlm_flags ) ;

struct fib_alias * fib_find_alias ( struct list_head * fah , u8 tos , u32 prio ) ;

int fib_detect_death ( struct fib_info * fi , int order , struct fib_info * * last_resort , int * last_idx , int dflt ) ;

int fib_nh_match ( struct fib_config * cfg , struct fib_info * fi ) ;

struct fib_info * fib_create_info ( struct fib_config * cfg ) ;

int fib_semantic_match ( struct list_head * head , const struct flowi * flp , struct fib_result * res , int prefixlen ) ;

__be32 __fib_res_prefsrc ( struct fib_result * res ) ;

int fib_dump_info ( struct sk_buff * skb , u32 pid , u32 seq , int event , u32 tb_id , u8 type , u8 scope , __be32 dst , int dst_len , u8 tos , struct fib_info * fi , unsigned int flags ) ;

int fib_sync_down_addr ( struct net * net , __be32 local ) ;

int fib_sync_down_dev ( struct net_device * dev , int force ) ;

int fib_sync_up ( struct net_device * dev ) ;

void fib_select_multipath ( const struct flowi * flp , struct fib_result * res ) ;

void inet_frags_init ( struct inet_frags * f ) ;

void inet_frags_init_net ( struct netns_frags * nf ) ;

void inet_frags_fini ( struct inet_frags * f ) ;

void inet_frags_exit_net ( struct netns_frags * nf , struct inet_frags * f ) ;

void inet_frag_kill ( struct inet_frag_queue * fq , struct inet_frags * f ) ;

void inet_frag_destroy ( struct inet_frag_queue * q , struct inet_frags * f , int * work ) ;

int inet_frag_evictor ( struct netns_frags * nf , struct inet_frags * f ) ;

struct inet_frag_queue * inet_frag_find ( struct netns_frags * nf , struct inet_frags * f , void * key , unsigned int hash ) ;

struct fib_node { struct hlist_node fn_hash ; struct list_head fn_alias ; __be32 fn_key ; struct fib_alias fn_embedded_alias ; } ;

struct fn_zone { struct fn_zone * fz_next ; struct hlist_head * fz_hash ; int fz_nent ; int fz_divisor ; u32 fz_hashmask ; int fz_order ; __be32 fz_mask ; } ;

struct fn_hash { struct fn_zone * fn_zones [ 33 ] ; struct fn_zone * fn_zone_list ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) fib_hash_init ( void ) ;

struct fib_table * fib_hash_table ( u32 id ) ;

struct fib_iter_state { struct seq_net_private p ; struct fn_zone * zone ; int bucket ; struct hlist_head * hash_head ; struct fib_node * fn ; struct fib_alias * fa ; loff_t pos ; unsigned int genid ; int valid ; } ;

int fib_proc_init ( struct net * net ) ;

void fib_proc_exit ( struct net * net ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ip_misc_proc_init ( void ) ;

struct fib4_rule { struct fib_rule common ; u8 dst_len ; u8 src_len ; u8 tos ; __be32 src ; __be32 srcmask ; __be32 dst ; __be32 dstmask ; } ;

int fib_lookup ( struct net * net , struct flowi * flp , struct fib_result * res ) ;

int fib4_rules_init ( struct net * net ) ;

void fib4_rules_exit ( struct net * net ) ;

int ip_mroute_setsockopt ( struct sock * sk , int optname , char * optval , unsigned int optlen ) ;

int ip_mroute_getsockopt ( struct sock * sk , int optname , char * optval , int * optlen ) ;

int ipmr_ioctl ( struct sock * sk , int cmd , void * arg ) ;

int ip_mr_input ( struct sk_buff * skb ) ;

int pim_rcv_v1 ( struct sk_buff * skb ) ;

int ipmr_get_route ( struct net * net , struct sk_buff * skb , struct rtmsg * rtm , int nowait ) ;

struct ipmr_vif_iter { struct seq_net_private p ; int ct ; } ;

struct ipmr_mfc_iter { struct seq_net_private p ; struct mfc_cache * * cache ; int ct ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ip_mr_init ( void ) ;

__u32 cookie_init_timestamp ( struct request_sock * req ) ;

__u32 cookie_v4_init_sequence ( struct sock * sk , struct sk_buff * skb , __u16 * mssp ) ;

void cookie_check_timestamp ( struct tcp_options_received * tcp_opt ) ;

struct sock * cookie_v4_check ( struct sock * sk , struct sk_buff * skb , struct ip_options * opt ) ;

struct net_lro_stats { unsigned long aggregated ; unsigned long flushed ; unsigned long no_desc ; } ;

struct net_lro_desc { struct sk_buff * parent ; struct sk_buff * last_skb ; struct skb_frag_struct * next_frag ; struct iphdr * iph ; struct tcphdr * tcph ; struct vlan_group * vgrp ; __wsum data_csum ; __be32 tcp_rcv_tsecr ; __be32 tcp_rcv_tsval ; __be32 tcp_ack ; u32 tcp_next_seq ; u32 skb_tot_frags_len ; u16 ip_tot_len ; u16 tcp_saw_tstamp ; __be16 tcp_window ; u16 vlan_tag ; int pkt_aggr_cnt ; int vlan_packet ; int mss ; int active ; } ;

struct net_lro_mgr { struct net_device * dev ; struct net_lro_stats stats ; unsigned long features ; u32 ip_summed ; u32 ip_summed_aggr ; int max_desc ; int max_aggr ; int frag_align_pad ; struct net_lro_desc * lro_arr ; int ( * get_skb_header ) ( struct sk_buff * skb , void * * ip_hdr , void * * tcpudp_hdr , u64 * hdr_flags , void * priv ) ; int ( * get_frag_header ) ( struct skb_frag_struct * frag , void * * mac_hdr , void * * ip_hdr , void * * tcpudp_hdr , u64 * hdr_flags , void * priv ) ; } ;

void lro_receive_skb ( struct net_lro_mgr * lro_mgr , struct sk_buff * skb , void * priv ) ;

void lro_vlan_hwaccel_receive_skb ( struct net_lro_mgr * lro_mgr , struct sk_buff * skb , struct vlan_group * vgrp , u16 vlan_tag , void * priv ) ;

void lro_receive_frags ( struct net_lro_mgr * lro_mgr , struct skb_frag_struct * frags , int len , int true_size , void * priv , __wsum sum ) ;

void lro_vlan_hwaccel_receive_frags ( struct net_lro_mgr * lro_mgr , struct skb_frag_struct * frags , int len , int true_size , struct vlan_group * vgrp , u16 vlan_tag , void * priv , __wsum sum ) ;

void lro_flush_all ( struct net_lro_mgr * lro_mgr ) ;

void lro_flush_pkt ( struct net_lro_mgr * lro_mgr , struct iphdr * iph , struct tcphdr * tcph ) ;

struct nf_queue_entry { struct list_head list ; struct sk_buff * skb ; unsigned int id ; struct nf_hook_ops * elem ; u_int8_t pf ; unsigned int hook ; struct net_device * indev ; struct net_device * outdev ; int ( * okfn ) ( struct sk_buff * ) ; } ;
struct nf_queue_handler { int ( * outfn ) ( struct nf_queue_entry * entry , unsigned int queuenum ) ; char * name ; } ;

int ip_route_me_harder ( struct sk_buff * skb , unsigned addr_type ) ;

struct ip_rt_info { __be32 daddr ; __be32 saddr ; u_int8_t tos ; u_int32_t mark ; } ;

__sum16 nf_ip_checksum ( struct sk_buff * skb , unsigned int hook , unsigned int dataoff , u_int8_t protocol ) ;

struct inet_diag_entry { __be32 * saddr ; __be32 * daddr ; u16 sport ; u16 dport ; u16 family ; u16 userlocks ; } ;

int inet_diag_register ( const struct inet_diag_handler * h ) ;

void inet_diag_unregister ( const struct inet_diag_handler * h ) ;

struct bictcp { u32 cnt ; u32 last_max_cwnd ; u32 loss_cwnd ; u32 last_cwnd ; u32 last_time ; u32 bic_origin_point ; u32 bic_K ; u32 delay_min ; u32 epoch_start ; u32 ack_cnt ; u32 tcp_cwnd ; u16 delayed_ack ; u8 sample_cnt ; u8 found ; u32 round_start ; u32 end_seq ; u32 last_jiffies ; u32 curr_rtt ; } ;

struct cipso_v4_map_cache_bkt { spinlock_t lock ; u32 size ; struct list_head list ; } ;

struct cipso_v4_map_cache_entry { u32 hash ; unsigned char * key ; size_t key_len ; struct netlbl_lsm_cache * lsm_data ; u32 activity ; struct list_head list ; } ;

void cipso_v4_cache_invalidate ( void ) ;

int cipso_v4_cache_add ( const struct sk_buff * skb , const struct netlbl_lsm_secattr * secattr ) ;

int cipso_v4_doi_add ( struct cipso_v4_doi * doi_def , struct netlbl_audit * audit_info ) ;

void cipso_v4_doi_free ( struct cipso_v4_doi * doi_def ) ;

int cipso_v4_doi_remove ( u32 doi , struct netlbl_audit * audit_info ) ;

struct cipso_v4_doi * cipso_v4_doi_getdef ( u32 doi ) ;

void cipso_v4_doi_putdef ( struct cipso_v4_doi * doi_def ) ;

int cipso_v4_doi_walk ( u32 * skip_cnt , int ( * callback ) ( struct cipso_v4_doi * doi_def , void * arg ) , void * cb_arg ) ;

int cipso_v4_validate ( const struct sk_buff * skb , unsigned char * * option ) ;

void cipso_v4_error ( struct sk_buff * skb , int error , u32 gateway ) ;

int cipso_v4_sock_setattr ( struct sock * sk , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) ;

int cipso_v4_req_setattr ( struct request_sock * req , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) ;

int cipso_v4_delopt ( struct ip_options * * opt_ptr ) ;

void cipso_v4_sock_delattr ( struct sock * sk ) ;

void cipso_v4_req_delattr ( struct request_sock * req ) ;

int cipso_v4_sock_getattr ( struct sock * sk , struct netlbl_lsm_secattr * secattr ) ;

int cipso_v4_skbuff_setattr ( struct sk_buff * skb , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) ;

int cipso_v4_skbuff_delattr ( struct sk_buff * skb ) ;

int cipso_v4_skbuff_getattr ( const struct sk_buff * skb , struct netlbl_lsm_secattr * secattr ) ;

struct route_info { __u8 type ; __u8 length ; __u8 prefix_len ; __u8 reserved_l : 3 , route_pref : 2 , reserved_h : 3 ; __be32 lifetime ; __u8 prefix [ 0 ] ; } ;

struct netlink_callback ;
struct rt6_rtnl_dump_arg { struct sk_buff * skb ; struct netlink_callback * cb ; struct net * net ; } ;

struct prefix_info { __u8 type ; __u8 length ; __u8 prefix_len ; __u8 reserved : 6 , autoconf : 1 , onlink : 1 ; __be32 valid ; __be32 prefered ; __be32 reserved2 ; struct in6_addr prefix ; } ;

typedef unsigned long mifbitmap_t ;

typedef unsigned short mifi_t ;

typedef __u32 if_mask ;


typedef struct if_set { if_mask ifs_bits [ ( ( ( 256 ) + ( ( sizeof ( if_mask ) * 8 ) ) - 1 ) / ( ( sizeof ( if_mask ) * 8 ) ) ) ] ; } if_set ;

struct mif6ctl { mifi_t mif6c_mifi ; unsigned char mif6c_flags ; unsigned char vifc_threshold ; __u16 mif6c_pifi ; unsigned int vifc_rate_limit ; } ;

struct mf6cctl { struct sockaddr_in6 mf6cc_origin ; struct sockaddr_in6 mf6cc_mcastgrp ; mifi_t mf6cc_parent ; struct if_set mf6cc_ifset ; } ;

struct sioc_sg_req6 { struct sockaddr_in6 src ; struct sockaddr_in6 grp ; unsigned long pktcnt ; unsigned long bytecnt ; unsigned long wrong_if ; } ;

struct sioc_mif_req6 { mifi_t mifi ; unsigned long icount ; unsigned long ocount ; unsigned long ibytes ; unsigned long obytes ; } ;

struct mif_device { struct net_device * dev ; unsigned long bytes_in , bytes_out ; unsigned long pkt_in , pkt_out ; unsigned long rate_limit ; unsigned char threshold ; unsigned short flags ; int link ; } ;

struct mfc6_cache { struct mfc6_cache * next ; struct net * mfc6_net ; struct in6_addr mf6c_mcastgrp ; struct in6_addr mf6c_origin ; mifi_t mf6c_parent ; int mfc_flags ; union { struct { unsigned long expires ; struct sk_buff_head unresolved ; } unres ; struct { unsigned long last_assert ; int minvif ; int maxvif ; unsigned long bytes ; unsigned long pkt ; unsigned long wrong_if ; unsigned char ttls [ 32 ] ; } res ; } mfc_un ; } ;

struct mrt6msg { __u8 im6_mbz ; __u8 im6_msgtype ; __u16 im6_mif ; __u32 im6_pad ; struct in6_addr im6_src , im6_dst ; } ;

int inet6_bind ( struct socket * sock , struct sockaddr * uaddr , int addr_len ) ;

int inet6_release ( struct socket * sock ) ;

void inet6_destroy_sock ( struct sock * sk ) ;

int inet6_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) ;

int inet6_ioctl ( struct socket * sock , unsigned int cmd , unsigned long arg ) ;

int inet6_register_protosw ( struct inet_protosw * p ) ;

void inet6_unregister_protosw ( struct inet_protosw * p ) ;

int inet6_sk_rebuild_header ( struct sock * sk ) ;

int ipv6_opt_accepted ( struct sock * sk , struct sk_buff * skb ) ;

struct ipv6_gro_cb { struct napi_gro_cb napi ; int proto ; } ;

int ipv6_sock_ac_join ( struct sock * sk , int ifindex , struct in6_addr * addr ) ;

int ipv6_sock_ac_drop ( struct sock * sk , int ifindex , struct in6_addr * addr ) ;

void ipv6_sock_ac_close ( struct sock * sk ) ;

int ipv6_dev_ac_inc ( struct net_device * dev , struct in6_addr * addr ) ;

int __ipv6_dev_ac_dec ( struct inet6_dev * idev , struct in6_addr * addr ) ;

int ipv6_chk_acast_addr ( struct net * net , struct net_device * dev , struct in6_addr * addr ) ;

struct ac6_iter_state { struct seq_net_private p ; struct net_device * dev ; struct inet6_dev * idev ; } ;

int ac6_proc_init ( struct net * net ) ;

void ac6_proc_exit ( struct net * net ) ;

int __ip6_local_out ( struct sk_buff * skb ) ;

int ip6_local_out ( struct sk_buff * skb ) ;

int ip6_output ( struct sk_buff * skb ) ;

int ip6_xmit ( struct sock * sk , struct sk_buff * skb , struct flowi * fl , struct ipv6_txoptions * opt , int ipfragok ) ;

int ip6_nd_hdr ( struct sock * sk , struct sk_buff * skb , struct net_device * dev , const struct in6_addr * saddr , const struct in6_addr * daddr , int proto , int len ) ;

int ip6_forward ( struct sk_buff * skb ) ;

int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) ;

int ip6_dst_lookup ( struct sock * sk , struct dst_entry * * dst , struct flowi * fl ) ;

int ip6_sk_dst_lookup ( struct sock * sk , struct dst_entry * * dst , struct flowi * fl ) ;

int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi * fl , struct rt6_info * rt , unsigned int flags ) ;

int ip6_push_pending_frames ( struct sock * sk ) ;

void ip6_flush_pending_frames ( struct sock * sk ) ;

int ipv6_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) ;

int ip6_input ( struct sk_buff * skb ) ;

int ip6_mc_input ( struct sk_buff * skb ) ;

struct arc_rfc1201 { __u8 proto ; __u8 split_flag ; __be16 sequence ; __u8 payload [ 0 ] ; } ;

struct arc_rfc1051 { __u8 proto ; __u8 payload [ 0 ] ; } ;

struct arc_eth_encap { __u8 proto ; struct ethhdr eth ; __u8 payload [ 0 ] ; } ;

struct arc_cap { __u8 proto ; __u8 cookie [ sizeof ( int ) ] ; union { __u8 ack ; __u8 raw [ 0 ] ; } mes ; } ;

struct arc_hardware { __u8 source , dest , offset [ 2 ] ; } ;

struct archdr { struct arc_hardware hard ; union { struct arc_rfc1201 rfc1201 ; struct arc_rfc1051 rfc1051 ; struct arc_eth_encap eth_encap ; struct arc_cap cap ; __u8 raw [ 0 ] ; } soft ; } ;

enum addrconf_timer_t { AC_NONE , AC_DAD , AC_RS , } ;

void in6_dev_finish_destroy ( struct inet6_dev * idev ) ;

void inet6_ifa_finish_destroy ( struct inet6_ifaddr * ifp ) ;

enum { IPV6_SADDR_RULE_INIT = 0 , IPV6_SADDR_RULE_LOCAL , IPV6_SADDR_RULE_SCOPE , IPV6_SADDR_RULE_PREFERRED , IPV6_SADDR_RULE_OIF , IPV6_SADDR_RULE_LABEL , IPV6_SADDR_RULE_PRIVACY , IPV6_SADDR_RULE_ORCHID , IPV6_SADDR_RULE_PREFIX , IPV6_SADDR_RULE_MAX } ;
struct ipv6_saddr_score { int rule ; int addr_type ; struct inet6_ifaddr * ifa ; unsigned long scorebits [ ( ( ( IPV6_SADDR_RULE_MAX ) + ( 8 * sizeof ( long ) ) - 1 ) / ( 8 * sizeof ( long ) ) ) ] ; int scopedist ; int matchlen ; } ;

struct ipv6_saddr_dst { const struct in6_addr * addr ; int ifindex ; int scope ; int label ; unsigned int prefs ; } ;

int ipv6_dev_get_saddr ( struct net * net , struct net_device * dst_dev , const struct in6_addr * daddr , unsigned int prefs , struct in6_addr * saddr ) ;

int ipv6_get_lladdr ( struct net_device * dev , struct in6_addr * addr , unsigned char banned_flags ) ;

int ipv6_chk_addr ( struct net * net , struct in6_addr * addr , struct net_device * dev , int strict ) ;

int ipv6_chk_prefix ( struct in6_addr * addr , struct net_device * dev ) ;

struct inet6_ifaddr * ipv6_get_ifaddr ( struct net * net , const struct in6_addr * addr , struct net_device * dev , int strict ) ;

void addrconf_dad_failure ( struct inet6_ifaddr * ifp ) ;

void addrconf_join_solict ( struct net_device * dev , struct in6_addr * addr ) ;

void addrconf_leave_solict ( struct inet6_dev * idev , struct in6_addr * addr ) ;

int __ipv6_isatap_ifid ( u8 * eui , __be32 addr ) ;

void addrconf_prefix_rcv ( struct net_device * dev , u8 * opt , int len ) ;

int addrconf_set_dstaddr ( struct net * net , void * arg ) ;

int addrconf_add_ifaddr ( struct net * net , void * arg ) ;

int addrconf_del_ifaddr ( struct net * net , void * arg ) ;

struct if6_iter_state { struct seq_net_private p ; int bucket ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) if6_proc_init ( void ) ;

void if6_proc_exit ( void ) ;

enum addr_type_t { UNICAST_ADDR , MULTICAST_ADDR , ANYCAST_ADDR , } ;

void inet6_ifinfo_notify ( int event , struct inet6_dev * idev ) ;


int register_inet6addr_notifier ( struct notifier_block * nb ) ;

int unregister_inet6addr_notifier ( struct notifier_block * nb ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) addrconf_init ( void ) ;

void addrconf_cleanup ( void ) ;

struct ifaddrlblmsg { __u8 ifal_family ; __u8 __ifal_reserved ; __u8 ifal_prefixlen ; __u8 ifal_flags ; __u32 ifal_index ; __u32 ifal_seq ; } ;

enum { IFAL_ADDRESS = 1 , IFAL_LABEL = 2 , __IFAL_MAX } ;
struct ip6addrlbl_entry { struct net * lbl_net ; struct in6_addr prefix ; int prefixlen ; int ifindex ; int addrtype ; u32 label ; struct hlist_node list ; atomic_t refcnt ; struct rcu_head rcu ; } ;



u32 ipv6_addr_label ( struct net * net , const struct in6_addr * addr , int type , int ifindex ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ipv6_addr_label_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ipv6_addr_label_rtnl_register ( void ) ;

struct rt6_info * rt6_lookup ( struct net * net , const struct in6_addr * daddr , const struct in6_addr * saddr , int oif , int strict ) ;

int ip6_ins_rt ( struct rt6_info * rt ) ;

void ip6_route_input ( struct sk_buff * skb ) ;

struct dst_entry * ip6_route_output ( struct net * net , struct sock * sk , struct flowi * fl ) ;

int ip6_dst_blackhole ( struct sock * sk , struct dst_entry * * dstp , struct flowi * fl ) ;

struct dst_entry * icmp6_dst_alloc ( struct net_device * dev , struct neighbour * neigh , const struct in6_addr * addr ) ;

int icmp6_dst_gc ( void ) ;

int ip6_dst_hoplimit ( struct dst_entry * dst ) ;

int ip6_route_add ( struct fib6_config * cfg ) ;

int ip6_del_rt ( struct rt6_info * rt ) ;

struct ip6rd_flowi { struct flowi fl ; struct in6_addr gateway ; } ;

void rt6_redirect ( struct in6_addr * dest , struct in6_addr * src , struct in6_addr * saddr , struct neighbour * neigh , u8 * lladdr , int on_link ) ;

void rt6_pmtu_discovery ( struct in6_addr * daddr , struct in6_addr * saddr , struct net_device * dev , u32 pmtu ) ;

struct rt6_info * rt6_get_dflt_router ( struct in6_addr * addr , struct net_device * dev ) ;

struct rt6_info * rt6_add_dflt_router ( struct in6_addr * gwaddr , struct net_device * dev , unsigned int pref ) ;

void rt6_purge_dflt_routers ( struct net * net ) ;

int ipv6_route_ioctl ( struct net * net , unsigned int cmd , void * arg ) ;

struct rt6_info * addrconf_dst_alloc ( struct inet6_dev * idev , const struct in6_addr * addr , int anycast ) ;

struct arg_dev_net { struct net_device * dev ; struct net * net ; } ;

void rt6_ifdown ( struct net * net , struct net_device * dev ) ;

struct rt6_mtu_change_arg { struct net_device * dev ; unsigned mtu ; } ;

void rt6_mtu_change ( struct net_device * dev , unsigned mtu ) ;

int rt6_dump_route ( struct rt6_info * rt , void * p_arg ) ;

void inet6_rt_notify ( int event , struct rt6_info * rt , struct nl_info * info ) ;

struct rt6_proc_arg { char * buffer ; int offset ; int length ; int skip ; int len ; } ;

struct ctl_table * ipv6_route_sysctl_init ( struct net * net ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ip6_route_init ( void ) ;

void ip6_route_cleanup ( void ) ;

enum fib_walk_state_t { FWS_L , FWS_R , FWS_C , FWS_U } ;

struct fib6_cleaner_t { struct fib6_walker_t w ; struct net * net ; int ( * func ) ( struct rt6_info * , void * arg ) ; void * arg ; } ;

struct fib6_table * fib6_new_table ( struct net * net , u32 id ) ;

struct fib6_table * fib6_get_table ( struct net * net , u32 id ) ;

void fib6_force_start_gc ( struct net * net ) ;

int fib6_add ( struct fib6_node * root , struct rt6_info * rt , struct nl_info * info ) ;

struct lookup_args { int offset ; struct in6_addr * addr ; } ;

struct fib6_node * fib6_lookup ( struct fib6_node * root , struct in6_addr * daddr , struct in6_addr * saddr ) ;

struct fib6_node * fib6_locate ( struct fib6_node * root , struct in6_addr * daddr , int dst_len , struct in6_addr * saddr , int src_len ) ;

int fib6_del ( struct rt6_info * rt , struct nl_info * info ) ;

void fib6_clean_all ( struct net * net , int ( * func ) ( struct rt6_info * , void * arg ) , int prune , void * arg ) ;


void fib6_run_gc ( unsigned long expires , struct net * net ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) fib6_init ( void ) ;

void fib6_gc_cleanup ( void ) ;

int ip6_ra_control ( struct sock * sk , int sel ) ;

int ipv6_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

int compat_ipv6_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

int ipv6_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

int compat_ipv6_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

struct ndisc_options { struct nd_opt_hdr * nd_opt_array [ __ND_OPT_ARRAY_MAX ] ; struct nd_opt_hdr * nd_useropts ; struct nd_opt_hdr * nd_useropts_end ; } ;

int ndisc_mc_map ( struct in6_addr * addr , char * buf , struct net_device * dev , int dir ) ;

struct sk_buff * ndisc_build_skb ( struct net_device * dev , const struct in6_addr * daddr , const struct in6_addr * saddr , struct icmp6hdr * icmp6h , const struct in6_addr * target , int llinfo ) ;

void ndisc_send_skb ( struct sk_buff * skb , struct net_device * dev , struct neighbour * neigh , const struct in6_addr * daddr , const struct in6_addr * saddr , struct icmp6hdr * icmp6h ) ;

void ndisc_send_ns ( struct net_device * dev , struct neighbour * neigh , const struct in6_addr * solicit , const struct in6_addr * daddr , const struct in6_addr * saddr ) ;

void ndisc_send_rs ( struct net_device * dev , const struct in6_addr * saddr , const struct in6_addr * daddr ) ;

void ndisc_send_redirect ( struct sk_buff * skb , struct neighbour * neigh , const struct in6_addr * target ) ;

int ndisc_rcv ( struct sk_buff * skb ) ;

int ndisc_ifinfo_sysctl_change ( struct ctl_table * ctl , int write , void * buffer , size_t * lenp , loff_t * ppos ) ;

int ndisc_ifinfo_sysctl_strategy ( ctl_table * ctl , void * oldval , size_t * oldlenp , void * newval , size_t newlen ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ndisc_init ( void ) ;

void ndisc_cleanup ( void ) ;

int ipv6_rcv_saddr_equal ( const struct sock * sk , const struct sock * sk2 ) ;

int udp_v6_get_port ( struct sock * sk , unsigned short snum ) ;

int udpv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) ;

void __udp6_lib_err ( struct sk_buff * skb , struct inet6_skb_parm * opt , u8 type , u8 code , int offset , __be32 info , struct udp_table * udptable ) ;

int udpv6_queue_rcv_skb ( struct sock * sk , struct sk_buff * skb ) ;

int __udp6_lib_rcv ( struct sk_buff * skb , struct udp_table * udptable , int proto ) ;

int udpv6_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) ;

void udpv6_destroy_sock ( struct sock * sk ) ;

int udpv6_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

int compat_udpv6_setsockopt ( struct sock * sk , int level , int optname , char * optval , unsigned int optlen ) ;

int udpv6_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

int compat_udpv6_getsockopt ( struct sock * sk , int level , int optname , char * optval , int * optlen ) ;

int udp6_seq_show ( struct seq_file * seq , void * v ) ;

int udp6_proc_init ( struct net * net ) ;

void udp6_proc_exit ( struct net * net ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) udpv6_init ( void ) ;

void udpv6_exit ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) udplitev6_init ( void ) ;

void udplitev6_exit ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) udplite6_proc_init ( void ) ;

void udplite6_proc_exit ( void ) ;

int raw6_local_deliver ( struct sk_buff * skb , int nexthdr ) ;

void raw6_icmp_error ( struct sk_buff * skb , int nexthdr , u8 type , u8 code , int inner_offset , __be32 info ) ;

int rawv6_rcv ( struct sock * sk , struct sk_buff * skb ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) raw6_proc_init ( void ) ;

void raw6_proc_exit ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rawv6_init ( void ) ;

void rawv6_exit ( void ) ;

int inet6_add_protocol ( const struct inet6_protocol * prot , unsigned char protocol ) ;

int inet6_del_protocol ( const struct inet6_protocol * prot , unsigned char protocol ) ;

void icmpv6_param_prob ( struct sk_buff * skb , u8 code , int pos ) ;

struct icmpv6_msg { struct sk_buff * skb ; int offset ; uint8_t type ; } ;

void icmpv6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , struct net_device * dev ) ;

void icmpv6_flow_init ( struct sock * sk , struct flowi * fl , u8 type , const struct in6_addr * saddr , const struct in6_addr * daddr , int oif ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) icmpv6_init ( void ) ;

void icmpv6_cleanup ( void ) ;


int icmpv6_err_convert ( u8 type , u8 code , int * err ) ;

struct ctl_table * ipv6_icmp_sysctl_init ( struct net * net ) ;

struct mld2_grec { __u8 grec_type ; __u8 grec_auxwords ; __be16 grec_nsrcs ; struct in6_addr grec_mca ; struct in6_addr grec_src [ 0 ] ; } ;

struct mld2_report { __u8 type ; __u8 resv1 ; __sum16 csum ; __be16 resv2 ; __be16 ngrec ; struct mld2_grec grec [ 0 ] ; } ;

struct mld2_query { __u8 type ; __u8 code ; __sum16 csum ; __be16 mrc ; __be16 resv1 ; struct in6_addr mca ; __u8 qrv : 3 , suppress : 1 , resv2 : 4 ; __u8 qqic ; __be16 nsrcs ; struct in6_addr srcs [ 0 ] ; } ;

int ipv6_sock_mc_join ( struct sock * sk , int ifindex , const struct in6_addr * addr ) ;

int ipv6_sock_mc_drop ( struct sock * sk , int ifindex , const struct in6_addr * addr ) ;

void ipv6_sock_mc_close ( struct sock * sk ) ;

int ip6_mc_source ( int add , int omode , struct sock * sk , struct group_source_req * pgsr ) ;

int ip6_mc_msfilter ( struct sock * sk , struct group_filter * gsf ) ;

int ip6_mc_msfget ( struct sock * sk , struct group_filter * gsf , struct group_filter * optval , int * optlen ) ;

int inet6_mc_check ( struct sock * sk , const struct in6_addr * mc_addr , const struct in6_addr * src_addr ) ;

int ipv6_dev_mc_inc ( struct net_device * dev , const struct in6_addr * addr ) ;

int __ipv6_dev_mc_dec ( struct inet6_dev * idev , const struct in6_addr * addr ) ;

int ipv6_dev_mc_dec ( struct net_device * dev , const struct in6_addr * addr ) ;

int ipv6_is_mld ( struct sk_buff * skb , int nexthdr ) ;

int ipv6_chk_mcast_addr ( struct net_device * dev , const struct in6_addr * group , const struct in6_addr * src_addr ) ;

int igmp6_event_query ( struct sk_buff * skb ) ;

int igmp6_event_report ( struct sk_buff * skb ) ;

void ipv6_mc_unmap ( struct inet6_dev * idev ) ;

void ipv6_mc_remap ( struct inet6_dev * idev ) ;

void ipv6_mc_down ( struct inet6_dev * idev ) ;

void ipv6_mc_up ( struct inet6_dev * idev ) ;

void ipv6_mc_init_dev ( struct inet6_dev * idev ) ;

void ipv6_mc_destroy_dev ( struct inet6_dev * idev ) ;

struct igmp6_mc_iter_state { struct seq_net_private p ; struct net_device * dev ; struct inet6_dev * idev ; } ;

struct igmp6_mcf_iter_state { struct seq_net_private p ; struct net_device * dev ; struct inet6_dev * idev ; struct ifmcaddr6 * im ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) igmp6_init ( void ) ;

void igmp6_cleanup ( void ) ;

struct ip6frag_skb_cb { struct inet6_skb_parm h ; int offset ; } ;

struct frag_queue { struct inet_frag_queue q ; __be32 id ; u32 user ; struct in6_addr saddr ; struct in6_addr daddr ; int iif ; unsigned int csum ; __u16 nhoffset ; } ;

int ip6_frag_nqueues ( struct net * net ) ;

int ip6_frag_mem ( struct net * net ) ;

unsigned int inet6_hash_frag ( __be32 id , const struct in6_addr * saddr , const struct in6_addr * daddr , u32 rnd ) ;

int ip6_frag_match ( struct inet_frag_queue * q , void * a ) ;

void ip6_frag_init ( struct inet_frag_queue * q , void * a ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ipv6_frag_init ( void ) ;

void ipv6_frag_exit ( void ) ;

int tcp6_proc_init ( struct net * net ) ;

void tcp6_proc_exit ( struct net * net ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) tcpv6_init ( void ) ;

void tcpv6_exit ( void ) ;

int ipv6_find_tlv ( struct sk_buff * skb , int offset , int type ) ;

struct tlvtype_proc { int type ; int ( * func ) ( struct sk_buff * skb , int offset ) ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ipv6_exthdrs_init ( void ) ;

void ipv6_exthdrs_exit ( void ) ;

int ipv6_parse_hopopts ( struct sk_buff * skb ) ;

void ipv6_push_nfrag_opts ( struct sk_buff * skb , struct ipv6_txoptions * opt , u8 * proto , struct in6_addr * * daddr ) ;

void ipv6_push_frag_opts ( struct sk_buff * skb , struct ipv6_txoptions * opt , u8 * proto ) ;

struct ipv6_txoptions * ipv6_dup_options ( struct sock * sk , struct ipv6_txoptions * opt ) ;

struct ipv6_txoptions * ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , int newtype , struct ipv6_opt_hdr * newopt , int newoptlen ) ;

struct ipv6_txoptions * ipv6_fixup_options ( struct ipv6_txoptions * opt_space , struct ipv6_txoptions * opt ) ;

int ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) ;

void ipv6_icmp_error ( struct sock * sk , struct sk_buff * skb , int err , __be16 port , u32 info , u8 * payload ) ;

void ipv6_local_error ( struct sock * sk , int err , struct flowi * fl , u32 info ) ;

int ipv6_recv_error ( struct sock * sk , struct msghdr * msg , int len ) ;

int datagram_recv_ctl ( struct sock * sk , struct msghdr * msg , struct sk_buff * skb ) ;

int datagram_send_ctl ( struct net * net , struct msghdr * msg , struct flowi * fl , struct ipv6_txoptions * opt , int * hlimit , int * tclass ) ;

struct ip6_flowlabel * fl6_sock_lookup ( struct sock * sk , __be32 label ) ;

void fl6_free_socklist ( struct sock * sk ) ;

struct ipv6_txoptions * fl6_merge_options ( struct ipv6_txoptions * opt_space , struct ip6_flowlabel * fl , struct ipv6_txoptions * fopt ) ;

int ipv6_flowlabel_opt ( struct sock * sk , char * optval , int optlen ) ;

struct ip6fl_iter_state { struct seq_net_private p ; int bucket ; } ;

int ip6_flowlabel_init ( void ) ;

void ip6_flowlabel_cleanup ( void ) ;

int inet6_csk_bind_conflict ( const struct sock * sk , const struct inet_bind_bucket * tb ) ;

struct request_sock * inet6_csk_search_req ( const struct sock * sk , struct request_sock * * * prevp , const __be16 rport , const struct in6_addr * raddr , const struct in6_addr * laddr , const int iif ) ;

void inet6_csk_reqsk_queue_hash_add ( struct sock * sk , struct request_sock * req , const unsigned long timeout ) ;

void inet6_csk_addr2sockaddr ( struct sock * sk , struct sockaddr * uaddr ) ;

int inet6_csk_xmit ( struct sk_buff * skb , int ipfragok ) ;

int ipv6_sysctl_register ( void ) ;

void ipv6_sysctl_unregister ( void ) ;

int ipv6_static_sysctl_register ( void ) ;

void ipv6_static_sysctl_unregister ( void ) ;

int ip6_route_me_harder ( struct sk_buff * skb ) ;

struct ip6_rt_info { struct in6_addr daddr ; struct in6_addr saddr ; u_int32_t mark ; } ;

__sum16 nf_ip6_checksum ( struct sk_buff * skb , unsigned int hook , unsigned int dataoff , u_int8_t protocol ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ipv6_netfilter_init ( void ) ;

void ipv6_netfilter_fini ( void ) ;

struct fib6_rule { struct fib_rule common ; struct rt6key src ; struct rt6key dst ; u8 tclass ; } ;

struct dst_entry * fib6_rule_lookup ( struct net * net , struct flowi * fl , int flags , pol_lookup_t lookup ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) fib6_rules_init ( void ) ;

void fib6_rules_cleanup ( void ) ;

int snmp6_register_dev ( struct inet6_dev * idev ) ;

int snmp6_unregister_dev ( struct inet6_dev * idev ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) ipv6_misc_proc_init ( void ) ;

void ipv6_misc_proc_exit ( void ) ;

__u32 cookie_v6_init_sequence ( struct sock * sk , struct sk_buff * skb , __u16 * mssp ) ;

struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) ;

int __ipv6_addr_type ( const struct in6_addr * addr ) ;

int ipv6_ext_hdr ( u8 nexthdr ) ;

int ipv6_skip_exthdr ( const struct sk_buff * skb , int start , u8 * nexthdrp ) ;

void __inet6_hash ( struct sock * sk ) ;

struct sock * __inet6_lookup_established ( struct net * net , struct inet_hashinfo * hashinfo , const struct in6_addr * saddr , const __be16 sport , const struct in6_addr * daddr , const u16 hnum , const int dif ) ;

struct sock * inet6_lookup_listener ( struct net * net , struct inet_hashinfo * hashinfo , const struct in6_addr * daddr , const unsigned short hnum , const int dif ) ;

struct sock * inet6_lookup ( struct net * net , struct inet_hashinfo * hashinfo , const struct in6_addr * saddr , const __be16 sport , const struct in6_addr * daddr , const __be16 dport , const int dif ) ;

int inet6_hash_connect ( struct inet_timewait_death_row * death_row , struct sock * sk ) ;

struct llc_sap * llc_sap_find ( unsigned char sap_value ) ;

struct llc_sap * llc_sap_open ( unsigned char lsap , int ( * func ) ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) ) ;

void llc_sap_close ( struct llc_sap * sap ) ;

struct llc_pdu_sn { u8 dsap ; u8 ssap ; u8 ctrl_1 ; u8 ctrl_2 ; } ;

struct llc_pdu_un { u8 dsap ; u8 ssap ; u8 ctrl_1 ; } ;

struct llc_xid_info { u8 fmt_id ; u8 type ; u8 rw ; } ;

struct llc_frmr_info { u16 rej_pdu_ctrl ; u8 curr_ssv ; u8 curr_rsv ; u8 ind_bits ; } ;

struct llc_sap ;
void llc_add_pack ( int type , void ( * handler ) ( struct llc_sap * sap , struct sk_buff * skb ) ) ;

void llc_remove_pack ( int type ) ;

void llc_set_station_handler ( void ( * handler ) ( struct sk_buff * skb ) ) ;

int llc_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) ;

int llc_mac_hdr_init ( struct sk_buff * skb , const unsigned char * sa , const unsigned char * da ) ;

int llc_build_and_send_ui_pkt ( struct llc_sap * sap , struct sk_buff * skb , unsigned char * dmac , unsigned char dsap ) ;

int nf_register_afinfo ( const struct nf_afinfo * afinfo ) ;

void nf_unregister_afinfo ( const struct nf_afinfo * afinfo ) ;

int nf_register_hook ( struct nf_hook_ops * reg ) ;

void nf_unregister_hook ( struct nf_hook_ops * reg ) ;

int nf_register_hooks ( struct nf_hook_ops * reg , unsigned int n ) ;

void nf_unregister_hooks ( struct nf_hook_ops * reg , unsigned int n ) ;

unsigned int nf_iterate ( struct list_head * head , struct sk_buff * skb , unsigned int hook , const struct net_device * indev , const struct net_device * outdev , struct list_head * * i , int ( * okfn ) ( struct sk_buff * ) , int hook_thresh ) ;

int nf_hook_slow ( u_int8_t pf , unsigned int hook , struct sk_buff * skb , struct net_device * indev , struct net_device * outdev , int ( * okfn ) ( struct sk_buff * ) , int hook_thresh ) ;

int skb_make_writable ( struct sk_buff * skb , unsigned int writable_len ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netfilter_init ( void ) ;

struct nf_loginfo { u_int8_t type ; union { struct { u_int32_t copy_len ; u_int16_t group ; u_int16_t qthreshold ; } ulog ; struct { u_int8_t level ; u_int8_t logflags ; } log ; } u ; } ;

typedef void nf_logfn ( u_int8_t pf , unsigned int hooknum , const struct sk_buff * skb , const struct net_device * in , const struct net_device * out , const struct nf_loginfo * li , const char * prefix ) ;

struct nf_logger { struct module * me ; nf_logfn * logfn ; char * name ; struct list_head list [ NFPROTO_NUMPROTO ] ; } ;

int nf_log_register ( u_int8_t pf , struct nf_logger * logger ) ;

void nf_log_unregister ( struct nf_logger * logger ) ;

int nf_log_bind_pf ( u_int8_t pf , const struct nf_logger * logger ) ;

void nf_log_unbind_pf ( u_int8_t pf ) ;

void nf_log_packet ( u_int8_t pf , unsigned int hooknum , const struct sk_buff * skb , const struct net_device * in , const struct net_device * out , const struct nf_loginfo * loginfo , const char * fmt , ... ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netfilter_log_init ( void ) ;

int nf_register_queue_handler ( u_int8_t pf , const struct nf_queue_handler * qh ) ;

int nf_unregister_queue_handler ( u_int8_t pf , const struct nf_queue_handler * qh ) ;

void nf_unregister_queue_handlers ( const struct nf_queue_handler * qh ) ;

int nf_queue ( struct sk_buff * skb , struct list_head * elem , u_int8_t pf , unsigned int hook , struct net_device * indev , struct net_device * outdev , int ( * okfn ) ( struct sk_buff * ) , unsigned int queuenum ) ;

void nf_reinject ( struct nf_queue_entry * entry , unsigned int verdict ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netfilter_queue_init ( void ) ;

int nf_register_sockopt ( struct nf_sockopt_ops * reg ) ;

void nf_unregister_sockopt ( struct nf_sockopt_ops * reg ) ;

int nf_setsockopt ( struct sock * sk , u_int8_t pf , int val , char * opt , unsigned int len ) ;

int nf_getsockopt ( struct sock * sk , u_int8_t pf , int val , char * opt , int * len ) ;

int compat_nf_setsockopt ( struct sock * sk , u_int8_t pf , int val , char * opt , unsigned int len ) ;

int compat_nf_getsockopt ( struct sock * sk , u_int8_t pf , int val , char * opt , int * len ) ;

enum { NLBL_MGMT_C_UNSPEC , NLBL_MGMT_C_ADD , NLBL_MGMT_C_REMOVE , NLBL_MGMT_C_LISTALL , NLBL_MGMT_C_ADDDEF , NLBL_MGMT_C_REMOVEDEF , NLBL_MGMT_C_LISTDEF , NLBL_MGMT_C_PROTOCOLS , NLBL_MGMT_C_VERSION , __NLBL_MGMT_C_MAX , } ;
enum { NLBL_MGMT_A_UNSPEC , NLBL_MGMT_A_DOMAIN , NLBL_MGMT_A_PROTOCOL , NLBL_MGMT_A_VERSION , NLBL_MGMT_A_CV4DOI , NLBL_MGMT_A_IPV6ADDR , NLBL_MGMT_A_IPV6MASK , NLBL_MGMT_A_IPV4ADDR , NLBL_MGMT_A_IPV4MASK , NLBL_MGMT_A_ADDRSELECTOR , NLBL_MGMT_A_SELECTORLIST , __NLBL_MGMT_A_MAX , } ;
enum { NLBL_UNLABEL_C_UNSPEC , NLBL_UNLABEL_C_ACCEPT , NLBL_UNLABEL_C_LIST , NLBL_UNLABEL_C_STATICADD , NLBL_UNLABEL_C_STATICREMOVE , NLBL_UNLABEL_C_STATICLIST , NLBL_UNLABEL_C_STATICADDDEF , NLBL_UNLABEL_C_STATICREMOVEDEF , NLBL_UNLABEL_C_STATICLISTDEF , __NLBL_UNLABEL_C_MAX , } ;
enum { NLBL_UNLABEL_A_UNSPEC , NLBL_UNLABEL_A_ACPTFLG , NLBL_UNLABEL_A_IPV6ADDR , NLBL_UNLABEL_A_IPV6MASK , NLBL_UNLABEL_A_IPV4ADDR , NLBL_UNLABEL_A_IPV4MASK , NLBL_UNLABEL_A_IFACE , NLBL_UNLABEL_A_SECCTX , __NLBL_UNLABEL_A_MAX , } ;
enum { NLBL_CIPSOV4_C_UNSPEC , NLBL_CIPSOV4_C_ADD , NLBL_CIPSOV4_C_REMOVE , NLBL_CIPSOV4_C_LIST , NLBL_CIPSOV4_C_LISTALL , __NLBL_CIPSOV4_C_MAX , } ;
enum { NLBL_CIPSOV4_A_UNSPEC , NLBL_CIPSOV4_A_DOI , NLBL_CIPSOV4_A_MTYPE , NLBL_CIPSOV4_A_TAG , NLBL_CIPSOV4_A_TAGLST , NLBL_CIPSOV4_A_MLSLVLLOC , NLBL_CIPSOV4_A_MLSLVLREM , NLBL_CIPSOV4_A_MLSLVL , NLBL_CIPSOV4_A_MLSLVLLST , NLBL_CIPSOV4_A_MLSCATLOC , NLBL_CIPSOV4_A_MLSCATREM , NLBL_CIPSOV4_A_MLSCAT , NLBL_CIPSOV4_A_MLSCATLST , __NLBL_CIPSOV4_A_MAX , } ;
int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netlbl_netlink_init ( void ) ;

struct audit_buffer * netlbl_audit_start_common ( int type , struct netlbl_audit * audit_info ) ;

struct netlbl_af4list { __be32 addr ; __be32 mask ; u32 valid ; struct list_head list ; } ;

struct netlbl_af6list { struct in6_addr addr ; struct in6_addr mask ; u32 valid ; struct list_head list ; } ;

struct netlbl_domaddr4_map { u32 type ; union { struct cipso_v4_doi * cipsov4 ; } type_def ; struct netlbl_af4list list ; } ;

struct netlbl_domaddr6_map { u32 type ; struct netlbl_af6list list ; } ;

struct netlbl_domaddr_map { struct list_head list4 ; struct list_head list6 ; } ;

struct netlbl_dom_map { char * domain ; u32 type ; union { struct cipso_v4_doi * cipsov4 ; struct netlbl_domaddr_map * addrsel ; } type_def ; u32 valid ; struct list_head list ; struct rcu_head rcu ; } ;

int netlbl_cfg_map_del ( const char * domain , u16 family , const void * addr , const void * mask , struct netlbl_audit * audit_info ) ;

int netlbl_cfg_unlbl_map_add ( const char * domain , u16 family , const void * addr , const void * mask , struct netlbl_audit * audit_info ) ;

int netlbl_cfg_unlbl_static_add ( struct net * net , const char * dev_name , const void * addr , const void * mask , u16 family , u32 secid , struct netlbl_audit * audit_info ) ;

int netlbl_cfg_unlbl_static_del ( struct net * net , const char * dev_name , const void * addr , const void * mask , u16 family , struct netlbl_audit * audit_info ) ;

int netlbl_cfg_cipsov4_add ( struct cipso_v4_doi * doi_def , struct netlbl_audit * audit_info ) ;

void netlbl_cfg_cipsov4_del ( u32 doi , struct netlbl_audit * audit_info ) ;

int netlbl_cfg_cipsov4_map_add ( u32 doi , const char * domain , const struct in_addr * addr , const struct in_addr * mask , struct netlbl_audit * audit_info ) ;

int netlbl_secattr_catmap_walk ( struct netlbl_lsm_secattr_catmap * catmap , u32 offset ) ;

int netlbl_secattr_catmap_walk_rng ( struct netlbl_lsm_secattr_catmap * catmap , u32 offset ) ;

int netlbl_secattr_catmap_setbit ( struct netlbl_lsm_secattr_catmap * catmap , u32 bit , gfp_t flags ) ;

int netlbl_secattr_catmap_setrng ( struct netlbl_lsm_secattr_catmap * catmap , u32 start , u32 end , gfp_t flags ) ;

int netlbl_enabled ( void ) ;

int netlbl_sock_setattr ( struct sock * sk , u16 family , const struct netlbl_lsm_secattr * secattr ) ;

void netlbl_sock_delattr ( struct sock * sk ) ;

int netlbl_sock_getattr ( struct sock * sk , struct netlbl_lsm_secattr * secattr ) ;

int netlbl_conn_setattr ( struct sock * sk , struct sockaddr * addr , const struct netlbl_lsm_secattr * secattr ) ;

int netlbl_req_setattr ( struct request_sock * req , const struct netlbl_lsm_secattr * secattr ) ;

void netlbl_req_delattr ( struct request_sock * req ) ;

int netlbl_skbuff_setattr ( struct sk_buff * skb , u16 family , const struct netlbl_lsm_secattr * secattr ) ;

int netlbl_skbuff_getattr ( const struct sk_buff * skb , u16 family , struct netlbl_lsm_secattr * secattr ) ;

void netlbl_skbuff_err ( struct sk_buff * skb , int error , int gateway ) ;

void netlbl_cache_invalidate ( void ) ;

int netlbl_cache_add ( const struct sk_buff * skb , const struct netlbl_lsm_secattr * secattr ) ;

struct audit_buffer * netlbl_audit_start ( int type , struct netlbl_audit * audit_info ) ;

struct netlbl_domhsh_tbl { struct list_head * tbl ; u32 size ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netlbl_domhsh_init ( u32 size ) ;

int netlbl_domhsh_add ( struct netlbl_dom_map * entry , struct netlbl_audit * audit_info ) ;

int netlbl_domhsh_add_default ( struct netlbl_dom_map * entry , struct netlbl_audit * audit_info ) ;

int netlbl_domhsh_remove_entry ( struct netlbl_dom_map * entry , struct netlbl_audit * audit_info ) ;

int netlbl_domhsh_remove_af4 ( const char * domain , const struct in_addr * addr , const struct in_addr * mask , struct netlbl_audit * audit_info ) ;

int netlbl_domhsh_remove ( const char * domain , struct netlbl_audit * audit_info ) ;

int netlbl_domhsh_remove_default ( struct netlbl_audit * audit_info ) ;

struct netlbl_dom_map * netlbl_domhsh_getentry ( const char * domain ) ;

struct netlbl_domaddr4_map * netlbl_domhsh_getentry_af4 ( const char * domain , __be32 addr ) ;

struct netlbl_domaddr6_map * netlbl_domhsh_getentry_af6 ( const char * domain , const struct in6_addr * addr ) ;

int netlbl_domhsh_walk ( u32 * skip_bkt , u32 * skip_chain , int ( * callback ) ( struct netlbl_dom_map * entry , void * arg ) , void * cb_arg ) ;

struct netlbl_af4list * netlbl_af4list_search ( __be32 addr , struct list_head * head ) ;

struct netlbl_af4list * netlbl_af4list_search_exact ( __be32 addr , __be32 mask , struct list_head * head ) ;

struct netlbl_af6list * netlbl_af6list_search ( const struct in6_addr * addr , struct list_head * head ) ;

struct netlbl_af6list * netlbl_af6list_search_exact ( const struct in6_addr * addr , const struct in6_addr * mask , struct list_head * head ) ;

int netlbl_af4list_add ( struct netlbl_af4list * entry , struct list_head * head ) ;

int netlbl_af6list_add ( struct netlbl_af6list * entry , struct list_head * head ) ;

void netlbl_af4list_remove_entry ( struct netlbl_af4list * entry ) ;

struct netlbl_af4list * netlbl_af4list_remove ( __be32 addr , __be32 mask , struct list_head * head ) ;

void netlbl_af6list_remove_entry ( struct netlbl_af6list * entry ) ;

struct netlbl_af6list * netlbl_af6list_remove ( const struct in6_addr * addr , const struct in6_addr * mask , struct list_head * head ) ;

void netlbl_af4list_audit_addr ( struct audit_buffer * audit_buf , int src , const char * dev , __be32 addr , __be32 mask ) ;

void netlbl_af6list_audit_addr ( struct audit_buffer * audit_buf , int src , const char * dev , const struct in6_addr * addr , const struct in6_addr * mask ) ;

struct netlbl_domhsh_walk_arg { struct netlink_callback * nl_cb ; struct sk_buff * skb ; u32 seq ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netlbl_mgmt_genl_init ( void ) ;

struct netlbl_unlhsh_tbl { struct list_head * tbl ; u32 size ; } ;

struct netlbl_unlhsh_addr4 { u32 secid ; struct netlbl_af4list list ; struct rcu_head rcu ; } ;

struct netlbl_unlhsh_addr6 { u32 secid ; struct netlbl_af6list list ; struct rcu_head rcu ; } ;

struct netlbl_unlhsh_iface { int ifindex ; struct list_head addr4_list ; struct list_head addr6_list ; u32 valid ; struct list_head list ; struct rcu_head rcu ; } ;

struct netlbl_unlhsh_walk_arg { struct netlink_callback * nl_cb ; struct sk_buff * skb ; u32 seq ; } ;

int netlbl_unlhsh_add ( struct net * net , const char * dev_name , const void * addr , const void * mask , u32 addr_len , u32 secid , struct netlbl_audit * audit_info ) ;

int netlbl_unlhsh_remove ( struct net * net , const char * dev_name , const void * addr , const void * mask , u32 addr_len , struct netlbl_audit * audit_info ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netlbl_unlabel_genl_init ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netlbl_unlabel_init ( u32 size ) ;

int netlbl_unlabel_getattr ( const struct sk_buff * skb , u16 family , struct netlbl_lsm_secattr * secattr ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netlbl_unlabel_defconf ( void ) ;

struct netlbl_cipsov4_doiwalk_arg { struct netlink_callback * nl_cb ; struct sk_buff * skb ; u32 seq ; } ;

struct netlbl_domhsh_walk_arg { struct netlbl_audit * audit_info ; u32 doi ; } ;
int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) netlbl_cipsov4_genl_init ( void ) ;

struct netlink_sock { struct sock sk ; u32 pid ; u32 dst_pid ; u32 dst_group ; u32 flags ; u32 subscriptions ; u32 ngroups ; unsigned long * groups ; unsigned long state ; wait_queue_head_t wait ; struct netlink_callback * cb ; struct mutex * cb_mutex ; struct mutex cb_def_mutex ; void ( * netlink_rcv ) ( struct sk_buff * skb ) ; struct module * module ; } ;

struct listeners_rcu_head { struct rcu_head rcu_head ; void * ptr ; } ;

struct nl_pid_hash { struct hlist_head * table ; unsigned long rehash_time ; unsigned int mask ; unsigned int shift ; unsigned int entries ; unsigned int max_shift ; u32 rnd ; } ;

struct netlink_table { struct nl_pid_hash hash ; struct hlist_head mc_list ; unsigned long * listeners ; unsigned int nl_nonroot ; unsigned int groups ; struct mutex * cb_mutex ; struct module * module ; int registered ; } ;

void netlink_table_grab ( void ) ;

void netlink_table_ungrab ( void ) ;

struct sock * netlink_getsockbyfilp ( struct file * filp ) ;

int netlink_attachskb ( struct sock * sk , struct sk_buff * skb , long * timeo , struct sock * ssk ) ;

int netlink_sendskb ( struct sock * sk , struct sk_buff * skb ) ;

void netlink_detachskb ( struct sock * sk , struct sk_buff * skb ) ;

int netlink_unicast ( struct sock * ssk , struct sk_buff * skb , u32 pid , int nonblock ) ;

int netlink_has_listeners ( struct sock * sk , unsigned int group ) ;

struct netlink_broadcast_data { struct sock * exclude_sk ; struct net * net ; u32 pid ; u32 group ; int failure ; int delivery_failure ; int congested ; int delivered ; gfp_t allocation ; struct sk_buff * skb , * skb2 ; } ;

int netlink_broadcast ( struct sock * ssk , struct sk_buff * skb , u32 pid , u32 group , gfp_t allocation ) ;

struct netlink_set_err_data { struct sock * exclude_sk ; u32 pid ; u32 group ; int code ; } ;

void netlink_set_err ( struct sock * ssk , u32 pid , u32 group , int code ) ;

struct sock * netlink_kernel_create ( struct net * net , int unit , unsigned int groups , void ( * input ) ( struct sk_buff * skb ) , struct mutex * cb_mutex , struct module * module ) ;

void netlink_kernel_release ( struct sock * sk ) ;

int __netlink_change_ngroups ( struct sock * sk , unsigned int groups ) ;

int netlink_change_ngroups ( struct sock * sk , unsigned int groups ) ;

void __netlink_clear_multicast_users ( struct sock * ksk , unsigned int group ) ;

void netlink_clear_multicast_users ( struct sock * ksk , unsigned int group ) ;

void netlink_set_nonroot ( int protocol , unsigned int flags ) ;

int netlink_dump_start ( struct sock * ssk , struct sk_buff * skb , const struct nlmsghdr * nlh , int ( * dump ) ( struct sk_buff * skb , struct netlink_callback * ) , int ( * done ) ( struct netlink_callback * ) ) ;

void netlink_ack ( struct sk_buff * in_skb , struct nlmsghdr * nlh , int err ) ;

int netlink_rcv_skb ( struct sk_buff * skb , int ( * cb ) ( struct sk_buff * , struct nlmsghdr * ) ) ;

int nlmsg_notify ( struct sock * sk , struct sk_buff * skb , u32 pid , unsigned int group , int report , gfp_t flags ) ;

struct nl_seq_iter { struct seq_net_private p ; int link ; int hash_idx ; } ;

int netlink_register_notifier ( struct notifier_block * nb ) ;

int netlink_unregister_notifier ( struct notifier_block * nb ) ;

int genl_register_mc_group ( struct genl_family * family , struct genl_multicast_group * grp ) ;

void genl_unregister_mc_group ( struct genl_family * family , struct genl_multicast_group * grp ) ;

int genl_register_ops ( struct genl_family * family , struct genl_ops * ops ) ;

int genl_unregister_ops ( struct genl_family * family , struct genl_ops * ops ) ;

int genl_register_family ( struct genl_family * family ) ;

int genl_register_family_with_ops ( struct genl_family * family , struct genl_ops * ops , size_t n_ops ) ;

int genl_unregister_family ( struct genl_family * family ) ;

int genlmsg_multicast_allns ( struct sk_buff * skb , u32 pid , unsigned int group , gfp_t flags ) ;

struct packet_mclist { struct packet_mclist * next ; int ifindex ; int count ; unsigned short type ; unsigned short alen ; unsigned char addr [ 32 ] ; } ;

struct packet_mreq_max { int mr_ifindex ; unsigned short mr_type ; unsigned short mr_alen ; unsigned char mr_address [ 32 ] ; } ;

struct packet_ring_buffer { char * * pg_vec ; unsigned int head ; unsigned int frames_per_block ; unsigned int frame_size ; unsigned int frame_max ; unsigned int pg_vec_order ; unsigned int pg_vec_pages ; unsigned int pg_vec_len ; atomic_t pending ; } ;

struct packet_sock ;

struct packet_sock { struct sock sk ; struct tpacket_stats stats ; struct packet_ring_buffer rx_ring ; struct packet_ring_buffer tx_ring ; int copy_thresh ; struct packet_type prot_hook ; spinlock_t bind_lock ; struct mutex pg_vec_lock ; unsigned int running : 1 , auxdata : 1 , origdev : 1 ; int ifindex ; __be16 num ; struct packet_mclist * mclist ; atomic_t mapped ; enum tpacket_versions tp_version ; unsigned int tp_hdrlen ; unsigned int tp_reserve ; unsigned int tp_loss : 1 ; } ;
struct packet_skb_cb { unsigned int origlen ; union { struct sockaddr_pkt pkt ; struct sockaddr_ll ll ; } sa ; } ;

enum rfkill_type { RFKILL_TYPE_ALL = 0 , RFKILL_TYPE_WLAN , RFKILL_TYPE_BLUETOOTH , RFKILL_TYPE_UWB , RFKILL_TYPE_WIMAX , RFKILL_TYPE_WWAN , RFKILL_TYPE_GPS , NUM_RFKILL_TYPES , } ;

enum rfkill_operation { RFKILL_OP_ADD = 0 , RFKILL_OP_DEL , RFKILL_OP_CHANGE , RFKILL_OP_CHANGE_ALL , } ;

struct rfkill_event { __u32 idx ; __u8 type ; __u8 op ; __u8 soft , hard ; } __attribute__ ( ( packed ) ) ;
enum rfkill_user_states { RFKILL_USER_STATE_SOFT_BLOCKED = 0 , RFKILL_USER_STATE_UNBLOCKED = 1 , RFKILL_USER_STATE_HARD_BLOCKED = 2 , } ;

struct rfkill ;

struct rfkill_ops { void ( * poll ) ( struct rfkill * rfkill , void * data ) ; void ( * query ) ( struct rfkill * rfkill , void * data ) ; int ( * set_block ) ( void * data , bool blocked ) ; } ;

struct rfkill { spinlock_t lock ; const char * name ; enum rfkill_type type ; unsigned long state ; u32 idx ; bool registered ; bool persistent ; const struct rfkill_ops * ops ; void * data ; struct led_trigger led_trigger ; const char * ledtrigname ; struct device dev ; struct list_head node ; struct delayed_work poll_work ; struct work_struct uevent_work ; struct work_struct sync_work ; } ;
struct rfkill_int_event { struct list_head list ; struct rfkill_event ev ; } ;

struct rfkill_data { struct list_head list ; struct list_head events ; struct mutex mtx ; wait_queue_head_t read_wait ; bool input_handler ; } ;

const char * rfkill_get_led_trigger_name ( struct rfkill * rfkill ) ;

void rfkill_set_led_trigger_name ( struct rfkill * rfkill , const char * name ) ;

void rfkill_switch_all ( enum rfkill_type type , bool blocked ) ;

void rfkill_epo ( void ) ;

void rfkill_restore_states ( void ) ;

void rfkill_remove_epo_lock ( void ) ;

bool rfkill_is_epo_lock_active ( void ) ;

bool rfkill_get_global_sw_state ( const enum rfkill_type type ) ;

bool rfkill_set_hw_state ( struct rfkill * rfkill , bool blocked ) ;

bool rfkill_set_sw_state ( struct rfkill * rfkill , bool blocked ) ;

void rfkill_init_sw_state ( struct rfkill * rfkill , bool blocked ) ;

void rfkill_set_states ( struct rfkill * rfkill , bool sw , bool hw ) ;

void rfkill_pause_polling ( struct rfkill * rfkill ) ;

void rfkill_resume_polling ( struct rfkill * rfkill ) ;

bool rfkill_blocked ( struct rfkill * rfkill ) ;

struct rfkill * rfkill_alloc ( const char * name , struct device * parent , const enum rfkill_type type , const struct rfkill_ops * ops , void * ops_data ) ;

int rfkill_register ( struct rfkill * rfkill ) ;

void rfkill_unregister ( struct rfkill * rfkill ) ;

void rfkill_destroy ( struct rfkill * rfkill ) ;

enum rfkill_input_master_mode { RFKILL_INPUT_MASTER_UNLOCK = 0 , RFKILL_INPUT_MASTER_RESTORE = 1 , RFKILL_INPUT_MASTER_UNBLOCKALL = 2 , NUM_RFKILL_INPUT_MASTER_MODES } ;

enum rfkill_sched_op { RFKILL_GLOBAL_OP_EPO = 0 , RFKILL_GLOBAL_OP_RESTORE , RFKILL_GLOBAL_OP_UNLOCK , RFKILL_GLOBAL_OP_UNBLOCK , } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rfkill_handler_init ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __used__ ) ) __attribute__ ( ( __cold__ ) ) rfkill_handler_exit ( void ) ;

int sch_direct_xmit ( struct sk_buff * skb , struct Qdisc * q , struct net_device * dev , struct netdev_queue * txq , spinlock_t * root_lock ) ;

void __qdisc_run ( struct Qdisc * q ) ;

unsigned long dev_trans_start ( struct net_device * dev ) ;

void __netdev_watchdog_up ( struct net_device * dev ) ;

void netif_carrier_on ( struct net_device * dev ) ;

void netif_carrier_off ( struct net_device * dev ) ;

void netif_notify_peers ( struct net_device * dev ) ;

struct pfifo_fast_priv { u32 bitmap ; struct sk_buff_head q [ 3 ] ; } ;

struct Qdisc * qdisc_alloc ( struct netdev_queue * dev_queue , struct Qdisc_ops * ops ) ;

struct Qdisc * qdisc_create_dflt ( struct net_device * dev , struct netdev_queue * dev_queue , struct Qdisc_ops * ops , unsigned int parentid ) ;

void qdisc_reset ( struct Qdisc * qdisc ) ;

void qdisc_destroy ( struct Qdisc * qdisc ) ;

struct Qdisc * dev_graft_qdisc ( struct netdev_queue * dev_queue , struct Qdisc * qdisc ) ;

void dev_activate ( struct net_device * dev ) ;

void dev_deactivate ( struct net_device * dev ) ;

void dev_init_scheduler ( struct net_device * dev ) ;

void dev_shutdown ( struct net_device * dev ) ;

struct mq_sched { struct Qdisc * * qdiscs ; } ;

int register_qdisc ( struct Qdisc_ops * qops ) ;

int unregister_qdisc ( struct Qdisc_ops * qops ) ;

void qdisc_list_del ( struct Qdisc * q ) ;

struct Qdisc * qdisc_lookup ( struct net_device * dev , u32 handle ) ;

struct qdisc_rate_table * qdisc_get_rtab ( struct tc_ratespec * r , struct nlattr * tab ) ;

void qdisc_put_rtab ( struct qdisc_rate_table * tab ) ;

void qdisc_put_stab ( struct qdisc_size_table * tab ) ;

void qdisc_calculate_pkt_len ( struct sk_buff * skb , struct qdisc_size_table * stab ) ;

void qdisc_warn_nonwc ( char * txt , struct Qdisc * qdisc ) ;

void qdisc_watchdog_init ( struct qdisc_watchdog * wd , struct Qdisc * qdisc ) ;

void qdisc_watchdog_schedule ( struct qdisc_watchdog * wd , psched_time_t expires ) ;

void qdisc_watchdog_cancel ( struct qdisc_watchdog * wd ) ;

void qdisc_class_hash_grow ( struct Qdisc * sch , struct Qdisc_class_hash * clhash ) ;

int qdisc_class_hash_init ( struct Qdisc_class_hash * clhash ) ;

void qdisc_class_hash_destroy ( struct Qdisc_class_hash * clhash ) ;

void qdisc_class_hash_insert ( struct Qdisc_class_hash * clhash , struct Qdisc_class_common * cl ) ;

void qdisc_class_hash_remove ( struct Qdisc_class_hash * clhash , struct Qdisc_class_common * cl ) ;

void qdisc_tree_decrease_qlen ( struct Qdisc * sch , unsigned int n ) ;

struct check_loop_arg { struct qdisc_walker w ; struct Qdisc * p ; int depth ; } ;

struct qdisc_dump_args { struct qdisc_walker w ; struct sk_buff * skb ; struct netlink_callback * cb ; } ;

int tc_classify_compat ( struct sk_buff * skb , struct tcf_proto * tp , struct tcf_result * res ) ;

int tc_classify ( struct sk_buff * skb , struct tcf_proto * tp , struct tcf_result * res ) ;

void tcf_destroy ( struct tcf_proto * tp ) ;

void tcf_destroy_chain ( struct tcf_proto * * fl ) ;

struct tcf_common { struct tcf_common * tcfc_next ; u32 tcfc_index ; int tcfc_refcnt ; int tcfc_bindcnt ; u32 tcfc_capab ; int tcfc_action ; struct tcf_t tcfc_tm ; struct gnet_stats_basic_packed tcfc_bstats ; struct gnet_stats_queue tcfc_qstats ; struct gnet_stats_rate_est tcfc_rate_est ; spinlock_t tcfc_lock ; } ;

struct tcf_police { struct tcf_common common ; int tcfp_result ; u32 tcfp_ewma_rate ; u32 tcfp_burst ; u32 tcfp_mtu ; u32 tcfp_toks ; u32 tcfp_ptoks ; psched_time_t tcfp_t_c ; struct qdisc_rate_table * tcfp_R_tab ; struct qdisc_rate_table * tcfp_P_tab ; } ;

struct tcf_hashinfo { struct tcf_common * * htab ; unsigned int hmask ; rwlock_t * lock ; } ;

struct tcf_act_hdr { struct tcf_common common ; } ;

struct tc_action { void * priv ; struct tc_action_ops * ops ; __u32 type ; __u32 order ; struct tc_action * next ; } ;

struct tc_action_ops { struct tc_action_ops * next ; struct tcf_hashinfo * hinfo ; char kind [ 16 ] ; __u32 type ; __u32 capab ; struct module * owner ; int ( * act ) ( struct sk_buff * , struct tc_action * , struct tcf_result * ) ; int ( * get_stats ) ( struct sk_buff * , struct tc_action * ) ; int ( * dump ) ( struct sk_buff * , struct tc_action * , int , int ) ; int ( * cleanup ) ( struct tc_action * , int bind ) ; int ( * lookup ) ( struct tc_action * , u32 ) ; int ( * init ) ( struct nlattr * , struct nlattr * , struct tc_action * , int , int ) ; int ( * walk ) ( struct sk_buff * , struct netlink_callback * , int , struct tc_action * ) ; } ;

struct tcf_walker { int stop ; int skip ; int count ; int ( * fn ) ( struct tcf_proto * , unsigned long node , struct tcf_walker * ) ; } ;
struct tcf_exts { struct tc_action * action ; } ;

struct tcf_ext_map { int action ; int police ; } ;

struct tcf_pkt_info { unsigned char * ptr ; int nexthdr ; } ;

struct tcf_ematch_ops ;

struct tcf_ematch { struct tcf_ematch_ops * ops ; unsigned long data ; unsigned int datalen ; u16 matchid ; u16 flags ; } ;

struct tcf_ematch_tree { struct tcf_ematch_tree_hdr hdr ; struct tcf_ematch * matches ; } ;

struct tcf_ematch_ops { int kind ; int datalen ; int ( * change ) ( struct tcf_proto * , void * , int , struct tcf_ematch * ) ; int ( * match ) ( struct sk_buff * , struct tcf_ematch * , struct tcf_pkt_info * ) ; void ( * destroy ) ( struct tcf_proto * , struct tcf_ematch * ) ; int ( * dump ) ( struct sk_buff * , struct tcf_ematch * ) ; struct module * owner ; struct list_head link ; } ;
int register_tcf_proto_ops ( struct tcf_proto_ops * ops ) ;

int unregister_tcf_proto_ops ( struct tcf_proto_ops * ops ) ;

struct tcf_dump_args { struct tcf_walker w ; struct sk_buff * skb ; struct netlink_callback * cb ; } ;

void tcf_exts_destroy ( struct tcf_proto * tp , struct tcf_exts * exts ) ;

int tcf_exts_validate ( struct tcf_proto * tp , struct nlattr * * tb , struct nlattr * rate_tlv , struct tcf_exts * exts , const struct tcf_ext_map * map ) ;

void tcf_exts_change ( struct tcf_proto * tp , struct tcf_exts * dst , struct tcf_exts * src ) ;

int tcf_exts_dump ( struct sk_buff * skb , struct tcf_exts * exts , const struct tcf_ext_map * map ) ;

int tcf_exts_dump_stats ( struct sk_buff * skb , struct tcf_exts * exts , const struct tcf_ext_map * map ) ;

void tcf_hash_destroy ( struct tcf_common * p , struct tcf_hashinfo * hinfo ) ;

int tcf_hash_release ( struct tcf_common * p , int bind , struct tcf_hashinfo * hinfo ) ;

int tcf_generic_walker ( struct sk_buff * skb , struct netlink_callback * cb , int type , struct tc_action * a ) ;

struct tcf_common * tcf_hash_lookup ( u32 index , struct tcf_hashinfo * hinfo ) ;

u32 tcf_hash_new_index ( u32 * idx_gen , struct tcf_hashinfo * hinfo ) ;

int tcf_hash_search ( struct tc_action * a , u32 index ) ;

struct tcf_common * tcf_hash_check ( u32 index , struct tc_action * a , int bind , struct tcf_hashinfo * hinfo ) ;

struct tcf_common * tcf_hash_create ( u32 index , struct nlattr * est , struct tc_action * a , int size , int bind , u32 * idx_gen , struct tcf_hashinfo * hinfo ) ;

void tcf_hash_insert ( struct tcf_common * p , struct tcf_hashinfo * hinfo ) ;

int tcf_register_action ( struct tc_action_ops * act ) ;

int tcf_unregister_action ( struct tc_action_ops * act ) ;

int tcf_action_exec ( struct sk_buff * skb , struct tc_action * act , struct tcf_result * res ) ;

void tcf_action_destroy ( struct tc_action * act , int bind ) ;

int tcf_action_dump_old ( struct sk_buff * skb , struct tc_action * a , int bind , int ref ) ;

int tcf_action_dump_1 ( struct sk_buff * skb , struct tc_action * a , int bind , int ref ) ;

int tcf_action_dump ( struct sk_buff * skb , struct tc_action * act , int bind , int ref ) ;

struct tc_action * tcf_action_init_1 ( struct nlattr * nla , struct nlattr * est , char * name , int ovr , int bind ) ;

struct tc_action * tcf_action_init ( struct nlattr * nla , struct nlattr * est , char * name , int ovr , int bind ) ;

int tcf_action_copy_stats ( struct sk_buff * skb , struct tc_action * a , int compat_mode ) ;

struct fifo_sched_data { u32 limit ; } ;

int fifo_set_limit ( struct Qdisc * q , unsigned int limit ) ;

struct Qdisc * fifo_create_dflt ( struct Qdisc * sch , struct Qdisc_ops * ops , unsigned int limit ) ;

struct cgroup_cls_state { struct cgroup_subsys_state css ; u32 classid ; } ;

struct cls_cgroup_head { u32 handle ; struct tcf_exts exts ; struct tcf_ematch_tree ematches ; } ;

int tcf_em_register ( struct tcf_ematch_ops * ops ) ;

void tcf_em_unregister ( struct tcf_ematch_ops * ops ) ;

int tcf_em_tree_validate ( struct tcf_proto * tp , struct nlattr * nla , struct tcf_ematch_tree * tree ) ;

void tcf_em_tree_destroy ( struct tcf_proto * tp , struct tcf_ematch_tree * tree ) ;

int tcf_em_tree_dump ( struct sk_buff * skb , struct tcf_ematch_tree * tree , int tlv ) ;

int __tcf_em_tree_match ( struct sk_buff * skb , struct tcf_ematch_tree * tree , struct tcf_pkt_info * info ) ;

struct rpc_pipe_msg { struct list_head list ; void * data ; size_t len ; size_t copied ; int errno ; } ;

struct rpc_pipe_ops { ssize_t ( * upcall ) ( struct file * , struct rpc_pipe_msg * , char * , size_t ) ; ssize_t ( * downcall ) ( struct file * , const char * , size_t ) ; void ( * release_pipe ) ( struct inode * ) ; int ( * open_pipe ) ( struct inode * ) ; void ( * destroy_msg ) ( struct rpc_pipe_msg * ) ; } ;

struct rpc_inode { struct inode vfs_inode ; void * private ; struct list_head pipe ; struct list_head in_upcall ; struct list_head in_downcall ; int pipelen ; int nreaders ; int nwriters ; int nkern_readwriters ; wait_queue_head_t waitq ; int flags ; struct delayed_work queue_timeout ; const struct rpc_pipe_ops * ops ; } ;
struct rpc_clnt ;
struct cache_detail ;
struct rpc_iostats { unsigned long om_ops , om_ntrans , om_timeouts ; unsigned long long om_bytes_sent , om_bytes_recv ; unsigned long long om_queue , om_rtt , om_execute ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ;
struct rpc_buffer { size_t len ; char data [ ] ; } ;

struct rpc_clnt * rpc_create ( struct rpc_create_args * args ) ;

struct rpc_clnt * rpc_clone_client ( struct rpc_clnt * clnt ) ;

void rpc_shutdown_client ( struct rpc_clnt * clnt ) ;

void rpc_release_client ( struct rpc_clnt * clnt ) ;

struct rpc_clnt * rpc_bind_new_program ( struct rpc_clnt * old , struct rpc_program * program , u32 vers ) ;

struct rpc_task * rpc_run_task ( const struct rpc_task_setup * task_setup_data ) ;

int rpc_call_sync ( struct rpc_clnt * clnt , const struct rpc_message * msg , int flags ) ;

int rpc_call_async ( struct rpc_clnt * clnt , const struct rpc_message * msg , int flags , const struct rpc_call_ops * tk_ops , void * data ) ;

void rpc_call_start ( struct rpc_task * task ) ;

size_t rpc_peeraddr ( struct rpc_clnt * clnt , struct sockaddr * buf , size_t bufsize ) ;

const char * rpc_peeraddr2str ( struct rpc_clnt * clnt , enum rpc_display_format_t format ) ;

void rpc_setbufsize ( struct rpc_clnt * clnt , unsigned int sndsize , unsigned int rcvsize ) ;

size_t rpc_max_payload ( struct rpc_clnt * clnt ) ;

void rpc_force_rebind ( struct rpc_clnt * clnt ) ;

void rpc_restart_call_prepare ( struct rpc_task * task ) ;

void rpc_restart_call ( struct rpc_task * task ) ;

struct rpc_task * rpc_call_null ( struct rpc_clnt * clnt , struct rpc_cred * cred , int flags ) ;

void rpc_show_tasks ( void ) ;

int xprt_register_transport ( struct xprt_class * transport ) ;

int xprt_unregister_transport ( struct xprt_class * transport ) ;

int xprt_load_transport ( const char * transport_name ) ;

int xprt_reserve_xprt ( struct rpc_task * task ) ;

int xprt_reserve_xprt_cong ( struct rpc_task * task ) ;

void xprt_release_xprt ( struct rpc_xprt * xprt , struct rpc_task * task ) ;

void xprt_release_xprt_cong ( struct rpc_xprt * xprt , struct rpc_task * task ) ;

void xprt_release_rqst_cong ( struct rpc_task * task ) ;

void xprt_adjust_cwnd ( struct rpc_task * task , int result ) ;

void xprt_wake_pending_tasks ( struct rpc_xprt * xprt , int status ) ;

void xprt_wait_for_buffer_space ( struct rpc_task * task , rpc_action action ) ;

void xprt_write_space ( struct rpc_xprt * xprt ) ;

void xprt_set_retrans_timeout_def ( struct rpc_task * task ) ;

void xprt_set_retrans_timeout_rtt ( struct rpc_task * task ) ;

int xprt_adjust_timeout ( struct rpc_rqst * req ) ;

void xprt_disconnect_done ( struct rpc_xprt * xprt ) ;

void xprt_force_disconnect ( struct rpc_xprt * xprt ) ;

void xprt_conditional_disconnect ( struct rpc_xprt * xprt , unsigned int cookie ) ;

void xprt_connect ( struct rpc_task * task ) ;

struct rpc_rqst * xprt_lookup_rqst ( struct rpc_xprt * xprt , __be32 xid ) ;

void xprt_update_rtt ( struct rpc_task * task ) ;

void xprt_complete_rqst ( struct rpc_task * task , int copied ) ;

int xprt_prepare_transmit ( struct rpc_task * task ) ;

void xprt_end_transmit ( struct rpc_task * task ) ;

void xprt_transmit ( struct rpc_task * task ) ;

void xprt_reserve ( struct rpc_task * task ) ;

void xprt_release ( struct rpc_task * task ) ;

struct rpc_xprt * xprt_create_transport ( struct xprt_create * args ) ;

void xprt_put ( struct rpc_xprt * xprt ) ;

struct rpc_xprt * xprt_get ( struct rpc_xprt * xprt ) ;

size_t xdr_skb_read_bits ( struct xdr_skb_reader * desc , void * to , size_t len ) ;

ssize_t xdr_partial_copy_from_skb ( struct xdr_buf * xdr , unsigned int base , struct xdr_skb_reader * desc , xdr_skb_read_actor copy_actor ) ;

int csum_partial_copy_to_xdr ( struct xdr_buf * xdr , struct sk_buff * skb ) ;

struct sock_xprt { struct rpc_xprt xprt ; struct socket * sock ; struct sock * inet ; __be32 tcp_fraghdr , tcp_xid , tcp_calldir ; u32 tcp_offset , tcp_reclen ; unsigned long tcp_copied , tcp_flags ; struct delayed_work connect_worker ; struct __kernel_sockaddr_storage srcaddr ; unsigned short srcport ; size_t rcvsize , sndsize ; void ( * old_data_ready ) ( struct sock * , int ) ; void ( * old_state_change ) ( struct sock * ) ; void ( * old_write_space ) ( struct sock * ) ; void ( * old_error_report ) ( struct sock * ) ; } ;

void * bc_malloc ( struct rpc_task * task , size_t size ) ;

void bc_free ( void * buffer ) ;

int init_socket_xprt ( void ) ;

void cleanup_socket_xprt ( void ) ;

void rpc_init_priority_wait_queue ( struct rpc_wait_queue * queue , const char * qname ) ;

void rpc_init_wait_queue ( struct rpc_wait_queue * queue , const char * qname ) ;

void rpc_destroy_wait_queue ( struct rpc_wait_queue * queue ) ;

int __rpc_wait_for_completion_task ( struct rpc_task * task , int ( * action ) ( void * ) ) ;

void rpc_sleep_on ( struct rpc_wait_queue * q , struct rpc_task * task , rpc_action action ) ;

void rpc_wake_up_queued_task ( struct rpc_wait_queue * queue , struct rpc_task * task ) ;

struct rpc_task * rpc_wake_up_next ( struct rpc_wait_queue * queue ) ;

void rpc_wake_up ( struct rpc_wait_queue * queue ) ;

void rpc_wake_up_status ( struct rpc_wait_queue * queue , int status ) ;

void rpc_delay ( struct rpc_task * task , unsigned long delay ) ;

void rpc_prepare_task ( struct rpc_task * task ) ;

void rpc_exit_task ( struct rpc_task * task ) ;

void rpc_release_calldata ( const struct rpc_call_ops * ops , void * calldata ) ;

void rpc_execute ( struct rpc_task * task ) ;

void * rpc_malloc ( struct rpc_task * task , size_t size ) ;

void rpc_free ( void * buffer ) ;

struct rpc_task * rpc_new_task ( const struct rpc_task_setup * setup_data ) ;

void rpc_put_task ( struct rpc_task * task ) ;

void rpc_killall_tasks ( struct rpc_clnt * clnt ) ;

int rpciod_up ( void ) ;

void rpciod_down ( void ) ;

void rpc_destroy_mempool ( void ) ;

int rpc_init_mempool ( void ) ;

int rpcauth_register ( const struct rpc_authops * ops ) ;

int rpcauth_unregister ( const struct rpc_authops * ops ) ;

struct rpc_auth * rpcauth_create ( rpc_authflavor_t pseudoflavor , struct rpc_clnt * clnt ) ;

void rpcauth_release ( struct rpc_auth * auth ) ;

int rpcauth_init_credcache ( struct rpc_auth * auth ) ;

void rpcauth_clear_credcache ( struct rpc_cred_cache * cache ) ;

void rpcauth_destroy_credcache ( struct rpc_auth * auth ) ;

struct rpc_cred * rpcauth_lookup_credcache ( struct rpc_auth * auth , struct auth_cred * acred , int flags ) ;

struct rpc_cred * rpcauth_lookupcred ( struct rpc_auth * auth , int flags ) ;

void rpcauth_init_cred ( struct rpc_cred * cred , const struct auth_cred * acred , struct rpc_auth * auth , const struct rpc_credops * ops ) ;

void rpcauth_generic_bind_cred ( struct rpc_task * task , struct rpc_cred * cred , int lookupflags ) ;

void rpcauth_bindcred ( struct rpc_task * task , struct rpc_cred * cred , int flags ) ;

void put_rpccred ( struct rpc_cred * cred ) ;

void rpcauth_unbindcred ( struct rpc_task * task ) ;

__be32 * rpcauth_marshcred ( struct rpc_task * task , __be32 * p ) ;

__be32 * rpcauth_checkverf ( struct rpc_task * task , __be32 * p ) ;

int rpcauth_wrap_req ( struct rpc_task * task , kxdrproc_t encode , void * rqstp , __be32 * data , void * obj ) ;

int rpcauth_unwrap_resp ( struct rpc_task * task , kxdrproc_t decode , void * rqstp , __be32 * data , void * obj ) ;

int rpcauth_refreshcred ( struct rpc_task * task ) ;

void rpcauth_invalcred ( struct rpc_task * task ) ;

int rpcauth_uptodatecred ( struct rpc_task * task ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rpcauth_init_module ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) rpcauth_remove_module ( void ) ;

struct unx_cred { struct rpc_cred uc_base ; gid_t uc_gid ; gid_t uc_gids [ 16 ] ; } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rpc_init_authunix ( void ) ;

struct generic_cred { struct rpc_cred gc_base ; struct auth_cred acred ; } ;

struct rpc_cred * rpc_lookup_cred ( void ) ;

struct rpc_cred * rpc_lookup_machine_cred ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) rpc_init_generic_auth ( void ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) rpc_destroy_generic_auth ( void ) ;

enum { SVC_POOL_AUTO = - 1 , SVC_POOL_GLOBAL , SVC_POOL_PERCPU , SVC_POOL_PERNODE } ;

struct svc_pool * svc_pool_for_cpu ( struct svc_serv * serv , int cpu ) ;

struct svc_serv * svc_create ( struct svc_program * prog , unsigned int bufsize , void ( * shutdown ) ( struct svc_serv * serv ) ) ;

struct svc_serv * svc_create_pooled ( struct svc_program * prog , unsigned int bufsize , void ( * shutdown ) ( struct svc_serv * serv ) , svc_thread_fn func , struct module * mod ) ;

void svc_destroy ( struct svc_serv * serv ) ;

struct svc_rqst * svc_prepare_thread ( struct svc_serv * serv , struct svc_pool * pool ) ;

int svc_set_num_threads ( struct svc_serv * serv , struct svc_pool * pool , int nrservs ) ;

void svc_exit_thread ( struct svc_rqst * rqstp ) ;

int svc_register ( const struct svc_serv * serv , const int family , const unsigned short proto , const unsigned short port ) ;

int svc_process ( struct svc_rqst * rqstp ) ;

u32 svc_max_payload ( const struct svc_rqst * rqstp ) ;

union svc_pktinfo_u { struct in_pktinfo pkti ; struct in6_pktinfo pkti6 ; } ;

int svc_send_common ( struct socket * sock , struct xdr_buf * xdr , struct page * headpage , unsigned long headoffset , struct page * tailpage , unsigned long tailoffset ) ;

int svc_sock_names ( struct svc_serv * serv , char * buf , const size_t buflen , const char * toclose ) ;

void svc_init_xprt_sock ( void ) ;

void svc_cleanup_xprt_sock ( void ) ;

void svc_sock_update_bufs ( struct svc_serv * serv ) ;

int svc_addsock ( struct svc_serv * serv , const int fd , char * name_return , const size_t len ) ;

struct svc_xprt * svc_sock_create ( struct svc_serv * serv , int prot ) ;

void svc_sock_destroy ( struct svc_xprt * xprt ) ;

int svc_authenticate ( struct svc_rqst * rqstp , __be32 * authp ) ;

int svc_set_client ( struct svc_rqst * rqstp ) ;

int svc_authorise ( struct svc_rqst * rqstp ) ;

int svc_auth_register ( rpc_authflavor_t flavor , struct auth_ops * aops ) ;

void svc_auth_unregister ( rpc_authflavor_t flavor ) ;

void auth_domain_put ( struct auth_domain * dom ) ;

struct auth_domain * auth_domain_lookup ( char * name , struct auth_domain * new ) ;

struct auth_domain * auth_domain_find ( char * name ) ;

struct unix_domain { struct auth_domain h ; int addr_changes ; } ;

struct auth_domain * unix_domain_find ( char * name ) ;

struct ip_map { struct cache_head h ; char m_class [ 8 ] ; struct in6_addr m_addr ; struct unix_domain * m_client ; int m_add_change ; } ;

int auth_unix_add_addr ( struct in6_addr * addr , struct auth_domain * dom ) ;

int auth_unix_forget_old ( struct auth_domain * dom ) ;

struct auth_domain * auth_unix_lookup ( struct in6_addr * addr ) ;

void svcauth_unix_purge ( void ) ;

void svcauth_unix_info_release ( void * info ) ;

struct unix_gid { struct cache_head h ; uid_t uid ; struct group_info * gi ; } ;

int svcauth_unix_set_client ( struct svc_rqst * rqstp ) ;

size_t rpc_ntop ( const struct sockaddr * sap , char * buf , const size_t buflen ) ;

size_t rpc_pton ( const char * buf , const size_t buflen , struct sockaddr * sap , const size_t salen ) ;

char * rpc_sockaddr2uaddr ( const struct sockaddr * sap ) ;

size_t rpc_uaddr2sockaddr ( const char * uaddr , const size_t uaddr_len , struct sockaddr * sap , const size_t salen ) ;

enum { RPCBPROC_NULL , RPCBPROC_SET , RPCBPROC_UNSET , RPCBPROC_GETPORT , RPCBPROC_GETADDR = 3 , RPCBPROC_DUMP , RPCBPROC_CALLIT , RPCBPROC_BCAST = 5 , RPCBPROC_GETTIME , RPCBPROC_UADDR2TADDR , RPCBPROC_TADDR2UADDR , RPCBPROC_GETVERSADDR , RPCBPROC_INDIRECT , RPCBPROC_GETADDRLIST , RPCBPROC_GETSTAT , } ;
struct rpcbind_args { struct rpc_xprt * r_xprt ; u32 r_prog ; u32 r_vers ; u32 r_prot ; unsigned short r_port ; const char * r_netid ; const char * r_addr ; const char * r_owner ; int r_status ; } ;

struct rpcb_info { u32 rpc_vers ; struct rpc_procinfo * rpc_proc ; } ;

int rpcb_register ( u32 prog , u32 vers , int prot , unsigned short port ) ;

int rpcb_v4_register ( const u32 program , const u32 version , const struct sockaddr * address , const char * netid ) ;

int rpcb_getport_sync ( struct sockaddr_in * sin , u32 prog , u32 vers , int prot ) ;

void rpcb_getport_async ( struct rpc_task * task ) ;

void rpc_init_rtt ( struct rpc_rtt * rt , unsigned long timeo ) ;

void rpc_update_rtt ( struct rpc_rtt * rt , unsigned timer , long m ) ;

unsigned long rpc_calc_rto ( struct rpc_rtt * rt , unsigned timer ) ;

__be32 * xdr_encode_netobj ( __be32 * p , const struct xdr_netobj * obj ) ;

__be32 * xdr_decode_netobj ( __be32 * p , struct xdr_netobj * obj ) ;

__be32 * xdr_encode_opaque_fixed ( __be32 * p , const void * ptr , unsigned int nbytes ) ;

__be32 * xdr_encode_opaque ( __be32 * p , const void * ptr , unsigned int nbytes ) ;

__be32 * xdr_encode_string ( __be32 * p , const char * string ) ;

__be32 * xdr_decode_string_inplace ( __be32 * p , char * * sp , unsigned int * lenp , unsigned int maxlen ) ;

void xdr_encode_pages ( struct xdr_buf * xdr , struct page * * pages , unsigned int base , unsigned int len ) ;

void xdr_inline_pages ( struct xdr_buf * xdr , unsigned int offset , struct page * * pages , unsigned int base , unsigned int len ) ;

void xdr_shift_buf ( struct xdr_buf * buf , size_t len ) ;

void xdr_init_encode ( struct xdr_stream * xdr , struct xdr_buf * buf , __be32 * p ) ;

__be32 * xdr_reserve_space ( struct xdr_stream * xdr , size_t nbytes ) ;

void xdr_write_pages ( struct xdr_stream * xdr , struct page * * pages , unsigned int base , unsigned int len ) ;

void xdr_init_decode ( struct xdr_stream * xdr , struct xdr_buf * buf , __be32 * p ) ;

__be32 * xdr_inline_decode ( struct xdr_stream * xdr , size_t nbytes ) ;

void xdr_read_pages ( struct xdr_stream * xdr , unsigned int len ) ;

void xdr_enter_page ( struct xdr_stream * xdr , unsigned int len ) ;

void xdr_buf_from_iov ( struct kvec * iov , struct xdr_buf * buf ) ;

int xdr_buf_subsegment ( struct xdr_buf * buf , struct xdr_buf * subbuf , unsigned int base , unsigned int len ) ;

int read_bytes_from_xdr_buf ( struct xdr_buf * buf , unsigned int base , void * obj , unsigned int len ) ;

int write_bytes_to_xdr_buf ( struct xdr_buf * buf , unsigned int base , void * obj , unsigned int len ) ;

int xdr_decode_word ( struct xdr_buf * buf , unsigned int base , u32 * obj ) ;

int xdr_encode_word ( struct xdr_buf * buf , unsigned int base , u32 obj ) ;

int xdr_buf_read_netobj ( struct xdr_buf * buf , struct xdr_netobj * obj , unsigned int offset ) ;

int xdr_decode_array2 ( struct xdr_buf * buf , unsigned int base , struct xdr_array2_desc * desc ) ;

int xdr_encode_array2 ( struct xdr_buf * buf , unsigned int base , struct xdr_array2_desc * desc ) ;

int xdr_process_buf ( struct xdr_buf * buf , unsigned int offset , unsigned int len , int ( * actor ) ( struct scatterlist * , void * ) , void * data ) ;

struct cache_head * sunrpc_cache_lookup ( struct cache_detail * detail , struct cache_head * key , int hash ) ;

struct cache_head * sunrpc_cache_update ( struct cache_detail * detail , struct cache_head * new , struct cache_head * old , int hash ) ;

int cache_check ( struct cache_detail * detail , struct cache_head * h , struct cache_req * rqstp ) ;

void cache_flush ( void ) ;

void cache_purge ( struct cache_detail * detail ) ;

void cache_clean_deferred ( void * owner ) ;

struct cache_queue { struct list_head list ; int reader ; } ;

struct cache_request { struct cache_queue q ; struct cache_head * item ; char * buf ; int len ; int readers ; } ;

struct cache_reader { struct cache_queue q ; int offset ; } ;

void qword_add ( char * * bpp , int * lp , char * str ) ;

void qword_addhex ( char * * bpp , int * lp , char * buf , int blen ) ;

int sunrpc_cache_pipe_upcall ( struct cache_detail * detail , struct cache_head * h , void ( * cache_request ) ( struct cache_detail * , struct cache_head * , char * * , int * ) ) ;

int qword_get ( char * * bpp , char * dest , int bufsize ) ;

struct handle { struct cache_detail * cd ; } ;

int cache_register ( struct cache_detail * cd ) ;

void cache_unregister ( struct cache_detail * cd ) ;

int sunrpc_cache_register_pipefs ( struct dentry * parent , const char * name , mode_t umode , struct cache_detail * cd ) ;

void sunrpc_cache_unregister_pipefs ( struct cache_detail * cd ) ;

int rpc_queue_upcall ( struct inode * inode , struct rpc_pipe_msg * msg ) ;

struct rpc_filelist { const char * name ; const struct file_operations * i_fop ; umode_t mode ; } ;

struct vfsmount * rpc_get_mount ( void ) ;

void rpc_put_mount ( void ) ;

struct dentry * rpc_mkpipe ( struct dentry * parent , const char * name , void * private , const struct rpc_pipe_ops * ops , int flags ) ;

int rpc_unlink ( struct dentry * dentry ) ;

enum { RPCAUTH_info , RPCAUTH_EOF } ;
struct dentry * rpc_create_client_dir ( struct dentry * dentry , struct qstr * name , struct rpc_clnt * rpc_client ) ;

int rpc_remove_client_dir ( struct dentry * dentry ) ;

struct dentry * rpc_create_cache_dir ( struct dentry * parent , struct qstr * name , mode_t umode , struct cache_detail * cd ) ;

void rpc_remove_cache_dir ( struct dentry * dentry ) ;

enum { RPCAUTH_lockd , RPCAUTH_mount , RPCAUTH_nfs , RPCAUTH_portmap , RPCAUTH_statd , RPCAUTH_nfsd4_cb , RPCAUTH_cache , RPCAUTH_RootEOF } ;
int register_rpc_pipefs ( void ) ;

void unregister_rpc_pipefs ( void ) ;

int svc_reg_xprt_class ( struct svc_xprt_class * xcl ) ;

void svc_unreg_xprt_class ( struct svc_xprt_class * xcl ) ;

int svc_print_xprts ( char * buf , int maxlen ) ;

void svc_xprt_put ( struct svc_xprt * xprt ) ;

void svc_xprt_init ( struct svc_xprt_class * xcl , struct svc_xprt * xprt , struct svc_serv * serv ) ;

int svc_create_xprt ( struct svc_serv * serv , const char * xprt_name , const int family , const unsigned short port , int flags ) ;

void svc_xprt_copy_addrs ( struct svc_rqst * rqstp , struct svc_xprt * xprt ) ;

char * svc_print_addr ( struct svc_rqst * rqstp , char * buf , size_t len ) ;

void svc_xprt_enqueue ( struct svc_xprt * xprt ) ;

void svc_xprt_received ( struct svc_xprt * xprt ) ;

void svc_reserve ( struct svc_rqst * rqstp , int space ) ;

void svc_wake_up ( struct svc_serv * serv ) ;

int svc_port_is_privileged ( struct sockaddr * sin ) ;

int svc_recv ( struct svc_rqst * rqstp , long timeout ) ;

void svc_drop ( struct svc_rqst * rqstp ) ;

int svc_send ( struct svc_rqst * rqstp ) ;

void svc_delete_xprt ( struct svc_xprt * xprt ) ;

void svc_close_xprt ( struct svc_xprt * xprt ) ;

void svc_close_all ( struct list_head * xprt_list ) ;

struct svc_xprt * svc_find_xprt ( struct svc_serv * serv , const char * xcl_name , const sa_family_t af , const unsigned short port ) ;

int svc_xprt_names ( struct svc_serv * serv , char * buf , const int buflen ) ;

int svc_pool_stats_open ( struct svc_serv * serv , struct file * file ) ;

void svc_seq_show ( struct seq_file * seq , const struct svc_stat * statp ) ;

struct rpc_iostats * rpc_alloc_iostats ( struct rpc_clnt * clnt ) ;

void rpc_free_iostats ( struct rpc_iostats * stats ) ;

void rpc_count_iostats ( struct rpc_task * task ) ;

void rpc_print_iostats ( struct seq_file * seq , struct rpc_clnt * clnt ) ;

struct proc_dir_entry * rpc_proc_register ( struct rpc_stat * statp ) ;

void rpc_proc_unregister ( const char * name ) ;

struct proc_dir_entry * svc_proc_register ( struct svc_stat * statp , const struct file_operations * fops ) ;

void svc_proc_unregister ( const char * name ) ;

void rpc_proc_init ( void ) ;

void rpc_proc_exit ( void ) ;

void rpc_register_sysctl ( void ) ;

void rpc_unregister_sysctl ( void ) ;

typedef unsigned int OM_uint32 ;

struct gss_auth { struct kref kref ; struct rpc_auth rpc_auth ; struct gss_api_mech * mech ; enum rpc_gss_svc service ; struct rpc_clnt * client ; struct dentry * dentry [ 2 ] ; } ;

struct gss_upcall_msg { atomic_t count ; uid_t uid ; struct rpc_pipe_msg msg ; struct list_head list ; struct gss_auth * auth ; struct rpc_inode * inode ; struct rpc_wait_queue rpc_waitqueue ; wait_queue_head_t waitqueue ; struct gss_cl_ctx * ctx ; char databuf [ 128 ] ; } ;
int g_token_size ( struct xdr_netobj * mech , unsigned int body_size ) ;

void g_make_token_header ( struct xdr_netobj * mech , int body_size , unsigned char * * buf ) ;

u32 g_verify_token_header ( struct xdr_netobj * mech , int * body_size , unsigned char * * buf_in , int toksize ) ;

int gss_mech_register ( struct gss_api_mech * gm ) ;

void gss_mech_unregister ( struct gss_api_mech * gm ) ;

struct gss_api_mech * gss_mech_get ( struct gss_api_mech * gm ) ;

struct gss_api_mech * gss_mech_get_by_name ( const char * name ) ;

struct gss_api_mech * gss_mech_get_by_pseudoflavor ( u32 pseudoflavor ) ;

u32 gss_svc_to_pseudoflavor ( struct gss_api_mech * gm , u32 service ) ;

u32 gss_pseudoflavor_to_service ( struct gss_api_mech * gm , u32 pseudoflavor ) ;

char * gss_service_to_auth_domain_name ( struct gss_api_mech * gm , u32 service ) ;

void gss_mech_put ( struct gss_api_mech * gm ) ;

int gss_import_sec_context ( const void * input_token , size_t bufsize , struct gss_api_mech * mech , struct gss_ctx * * ctx_id ) ;

u32 gss_get_mic ( struct gss_ctx * context_handle , struct xdr_buf * message , struct xdr_netobj * mic_token ) ;

u32 gss_verify_mic ( struct gss_ctx * context_handle , struct xdr_buf * message , struct xdr_netobj * mic_token ) ;

u32 gss_wrap ( struct gss_ctx * ctx_id , int offset , struct xdr_buf * buf , struct page * * inpages ) ;

u32 gss_unwrap ( struct gss_ctx * ctx_id , int offset , struct xdr_buf * buf ) ;

u32 gss_delete_sec_context ( struct gss_ctx * * context_handle ) ;

struct rsi { struct cache_head h ; struct xdr_netobj in_handle , in_token ; struct xdr_netobj out_handle , out_token ; int major_status , minor_status ; } ;

struct gss_svc_seq_data { int sd_max ; unsigned long sd_win [ 128 / 64 ] ; spinlock_t sd_lock ; } ;

struct rsc { struct cache_head h ; struct xdr_netobj handle ; struct svc_cred cred ; struct gss_svc_seq_data seqdata ; struct gss_ctx * mechctx ; char * client_name ; } ;

struct gss_domain { struct auth_domain h ; u32 pseudoflavor ; } ;

u32 svcauth_gss_flavor ( struct auth_domain * dom ) ;

int svcauth_gss_register_pseudoflavor ( u32 pseudoflavor , char * name ) ;

struct gss_svc_data { struct rpc_gss_wire_cred clcred ; __be32 * verf_start ; struct rsc * rsci ; } ;

char * svc_gss_principal ( struct svc_rqst * rqstp ) ;

int gss_svc_init ( void ) ;

void gss_svc_shutdown ( void ) ;

struct krb5_ctx { int initiate ; struct crypto_blkcipher * enc ; struct crypto_blkcipher * seq ; s32 endtime ; u32 seq_send ; struct xdr_netobj mech_used ; } ;

enum sgn_alg { SGN_ALG_DES_MAC_MD5 = 0x0000 , SGN_ALG_MD2_5 = 0x0001 , SGN_ALG_DES_MAC = 0x0002 , SGN_ALG_3 = 0x0003 , SGN_ALG_HMAC_MD5 = 0x0011 , SGN_ALG_HMAC_SHA1_DES3_KD = 0x0004 } ;

enum seal_alg { SEAL_ALG_NONE = 0xffff , SEAL_ALG_DES = 0x0000 , SEAL_ALG_1 = 0x0001 , SEAL_ALG_MICROSOFT_RC4 = 0x0010 , SEAL_ALG_DES3KD = 0x0002 } ;

u32 gss_get_mic_kerberos ( struct gss_ctx * gss_ctx , struct xdr_buf * text , struct xdr_netobj * token ) ;

u32 gss_verify_mic_kerberos ( struct gss_ctx * gss_ctx , struct xdr_buf * message_buffer , struct xdr_netobj * read_token ) ;

s32 krb5_make_seq_num ( struct crypto_blkcipher * key , int direction , u32 seqnum , unsigned char * cksum , unsigned char * buf ) ;

s32 krb5_get_seq_num ( struct crypto_blkcipher * key , unsigned char * cksum , unsigned char * buf , int * direction , u32 * seqnum ) ;

u32 gss_wrap_kerberos ( struct gss_ctx * ctx , int offset , struct xdr_buf * buf , struct page * * pages ) ;

u32 gss_unwrap_kerberos ( struct gss_ctx * ctx , int offset , struct xdr_buf * buf ) ;

u32 krb5_encrypt ( struct crypto_blkcipher * tfm , void * iv , void * in , void * out , int length ) ;

u32 krb5_decrypt ( struct crypto_blkcipher * tfm , void * iv , void * in , void * out , int length ) ;

s32 make_checksum ( char * cksumname , char * header , int hdrlen , struct xdr_buf * body , int body_offset , struct xdr_netobj * cksum ) ;

struct encryptor_desc { u8 iv [ 8 ] ; struct blkcipher_desc desc ; int pos ; struct xdr_buf * outbuf ; struct page * * pages ; struct scatterlist infrags [ 4 ] ; struct scatterlist outfrags [ 4 ] ; int fragno ; int fraglen ; } ;

int gss_encrypt_xdr_buf ( struct crypto_blkcipher * tfm , struct xdr_buf * buf , int offset , struct page * * pages ) ;

struct decryptor_desc { u8 iv [ 8 ] ; struct blkcipher_desc desc ; struct scatterlist frags [ 4 ] ; int fragno ; int fraglen ; } ;

int gss_decrypt_xdr_buf ( struct crypto_blkcipher * tfm , struct xdr_buf * buf , int offset ) ;

struct unix_iter_state { struct seq_net_private p ; int i ; } ;

void unix_inflight ( struct file * fp ) ;

void unix_notinflight ( struct file * fp ) ;

void wait_for_unix_gc ( void ) ;

void unix_gc ( void ) ;

int unix_sysctl_register ( struct net * net ) ;

void unix_sysctl_unregister ( struct net * net ) ;

struct iw_statistics * get_wireless_stats ( struct net_device * dev ) ;

int wext_proc_init ( struct net * net ) ;

void wext_proc_exit ( struct net * net ) ;

typedef int ( * wext_ioctl_func ) ( struct net_device * , struct iwreq * , unsigned int , struct iw_request_info * , iw_handler ) ;
int wext_handle_ioctl ( struct net * net , struct ifreq * ifr , unsigned int cmd , void * arg ) ;

int compat_wext_handle_ioctl ( struct net * net , unsigned int cmd , unsigned long arg ) ;

void wireless_send_event ( struct net_device * dev , unsigned int cmd , union iwreq_data * wrqu , const char * extra ) ;

int iw_handler_set_spy ( struct net_device * dev , struct iw_request_info * info , union iwreq_data * wrqu , char * extra ) ;

int iw_handler_get_spy ( struct net_device * dev , struct iw_request_info * info , union iwreq_data * wrqu , char * extra ) ;

int iw_handler_set_thrspy ( struct net_device * dev , struct iw_request_info * info , union iwreq_data * wrqu , char * extra ) ;

int iw_handler_get_thrspy ( struct net_device * dev , struct iw_request_info * info , union iwreq_data * wrqu , char * extra ) ;

void wireless_spy_update ( struct net_device * dev , unsigned char * address , struct iw_quality * wstats ) ;

int get_compat_msghdr ( struct msghdr * kmsg , struct compat_msghdr * umsg ) ;

int verify_compat_iovec ( struct msghdr * kern_msg , struct iovec * kern_iov , struct sockaddr * kern_address , int mode ) ;

int cmsghdr_from_user_compat_to_kern ( struct msghdr * kmsg , struct sock * sk , unsigned char * stackbuf , int stackbuf_size ) ;

int put_cmsg_compat ( struct msghdr * kmsg , int level , int type , int len , void * data ) ;

void scm_detach_fds_compat ( struct msghdr * kmsg , struct scm_cookie * scm ) ;

struct compat_sock_fprog { u16 len ; compat_uptr_t filter ; } ;

long compat_sys_setsockopt ( int fd , int level , int optname , char * optval , unsigned int optlen ) ;

int compat_sock_get_timestamp ( struct sock * sk , struct timeval * userstamp ) ;

int compat_sock_get_timestampns ( struct sock * sk , struct timespec * userstamp ) ;

long compat_sys_getsockopt ( int fd , int level , int optname , char * optval , int * optlen ) ;

struct compat_group_req { __u32 gr_interface ; struct __kernel_sockaddr_storage gr_group __attribute__ ( ( aligned ( 4 ) ) ) ; } __attribute__ ( ( packed ) ) ;
struct compat_group_source_req { __u32 gsr_interface ; struct __kernel_sockaddr_storage gsr_group __attribute__ ( ( aligned ( 4 ) ) ) ; struct __kernel_sockaddr_storage gsr_source __attribute__ ( ( aligned ( 4 ) ) ) ; } __attribute__ ( ( packed ) ) ;
struct compat_group_filter { __u32 gf_interface ; struct __kernel_sockaddr_storage gf_group __attribute__ ( ( aligned ( 4 ) ) ) ; __u32 gf_fmode ; __u32 gf_numsrc ; struct __kernel_sockaddr_storage gf_slist [ 1 ] __attribute__ ( ( aligned ( 4 ) ) ) ; } __attribute__ ( ( packed ) ) ;
int compat_mc_setsockopt ( struct sock * sock , int level , int optname , char * optval , unsigned int optlen , int ( * setsockopt ) ( struct sock * , int , int , char * , unsigned int ) ) ;

int compat_mc_getsockopt ( struct sock * sock , int level , int optname , char * optval , int * optlen , int ( * getsockopt ) ( struct sock * , int , int , char * , int * ) ) ;

long compat_sys_sendmsg ( int fd , struct compat_msghdr * msg , unsigned flags ) ;

long compat_sys_recvmsg ( int fd , struct compat_msghdr * msg , unsigned int flags ) ;

long compat_sys_recv ( int fd , void * buf , size_t len , unsigned flags ) ;

long compat_sys_recvfrom ( int fd , void * buf , size_t len , unsigned flags , struct sockaddr * addr , int * addrlen ) ;

long compat_sys_socketcall ( int call , u32 * args ) ;

struct ctl_table_header * register_net_sysctl_table ( struct net * net , const struct ctl_path * path , struct ctl_table * table ) ;

struct ctl_table_header * register_net_sysctl_rotable ( const struct ctl_path * path , struct ctl_table * table ) ;

void unregister_net_sysctl_table ( struct ctl_table_header * header ) ;

unsigned bcd2bin ( unsigned char val ) ;

unsigned char bin2bcd ( unsigned val ) ;

u32 iter_div_u64_rem ( u64 dividend , u32 divisor , u64 * remainder ) ;

void sort ( void * base , size_t num , size_t size , int ( * cmp_func ) ( const void * , const void * ) , void ( * swap_func ) ( void * , void * , int size ) ) ;

int match_token ( char * s , const match_table_t table , substring_t args [ ] ) ;
int match_int ( substring_t * s , int * result ) ;

int match_octal ( substring_t * s , int * result ) ;

int match_hex ( substring_t * s , int * result ) ;

size_t match_strlcpy ( char * dest , const substring_t * src , size_t size ) ;

char * match_strdup ( const substring_t * s ) ;

__u32 half_md4_transform ( __u32 buf [ 4 ] , __u32 const in [ 8 ] ) ;

int debug_locks_off ( void ) ;

struct rnd_state { u32 s1 , s2 , s3 ; } ;

u32 random32 ( void ) ;

void srandom32 ( u32 entropy ) ;

void __attribute__ ( ( weak ) ) bust_spinlocks ( int yes ) ;

void hex_dump_to_buffer ( const void * buf , size_t len , int rowsize , int groupsize , char * linebuf , size_t linebuflen , bool ascii ) ;

void print_hex_dump ( const char * level , const char * prefix_str , int prefix_type , int rowsize , int groupsize , const void * buf , size_t len , bool ascii ) ;

void print_hex_dump_bytes ( const char * prefix_str , int prefix_type , const void * buf , size_t len ) ;

char * kvasprintf ( gfp_t gfp , const char * fmt , va_list ap ) ;

char * kasprintf ( gfp_t gfp , const char * fmt , ... ) ;

int __bitmap_empty ( const unsigned long * bitmap , int bits ) ;

int __bitmap_full ( const unsigned long * bitmap , int bits ) ;

int __bitmap_equal ( const unsigned long * bitmap1 , const unsigned long * bitmap2 , int bits ) ;

void __bitmap_complement ( unsigned long * dst , const unsigned long * src , int bits ) ;

void __bitmap_shift_right ( unsigned long * dst , const unsigned long * src , int shift , int bits ) ;

void __bitmap_shift_left ( unsigned long * dst , const unsigned long * src , int shift , int bits ) ;

int __bitmap_and ( unsigned long * dst , const unsigned long * bitmap1 , const unsigned long * bitmap2 , int bits ) ;

void __bitmap_or ( unsigned long * dst , const unsigned long * bitmap1 , const unsigned long * bitmap2 , int bits ) ;

void __bitmap_xor ( unsigned long * dst , const unsigned long * bitmap1 , const unsigned long * bitmap2 , int bits ) ;

int __bitmap_andnot ( unsigned long * dst , const unsigned long * bitmap1 , const unsigned long * bitmap2 , int bits ) ;

int __bitmap_intersects ( const unsigned long * bitmap1 , const unsigned long * bitmap2 , int bits ) ;

int __bitmap_subset ( const unsigned long * bitmap1 , const unsigned long * bitmap2 , int bits ) ;

int __bitmap_weight ( const unsigned long * bitmap , int bits ) ;

int bitmap_scnprintf ( char * buf , unsigned int buflen , const unsigned long * maskp , int nmaskbits ) ;

int __bitmap_parse ( const char * buf , unsigned int buflen , int is_user , unsigned long * maskp , int nmaskbits ) ;

int bitmap_parse_user ( const char * ubuf , unsigned int ulen , unsigned long * maskp , int nmaskbits ) ;

int bitmap_scnlistprintf ( char * buf , unsigned int buflen , const unsigned long * maskp , int nmaskbits ) ;

int bitmap_parselist ( const char * bp , unsigned long * maskp , int nmaskbits ) ;

void bitmap_remap ( unsigned long * dst , const unsigned long * src , const unsigned long * old , const unsigned long * new , int bits ) ;

int bitmap_bitremap ( int oldbit , const unsigned long * old , const unsigned long * new , int bits ) ;

void bitmap_onto ( unsigned long * dst , const unsigned long * orig , const unsigned long * relmap , int bits ) ;

void bitmap_fold ( unsigned long * dst , const unsigned long * orig , int sz , int bits ) ;

enum { REG_OP_ISFREE , REG_OP_ALLOC , REG_OP_RELEASE , } ;
int bitmap_find_free_region ( unsigned long * bitmap , int bits , int order ) ;

void bitmap_release_region ( unsigned long * bitmap , int pos , int order ) ;

int bitmap_allocate_region ( unsigned long * bitmap , int pos , int order ) ;

void bitmap_copy_le ( void * dst , const unsigned long * src , int nbits ) ;

struct scatterlist * sg_next ( struct scatterlist * sg ) ;

struct scatterlist * sg_last ( struct scatterlist * sgl , unsigned int nents ) ;

void sg_init_table ( struct scatterlist * sgl , unsigned int nents ) ;

void sg_init_one ( struct scatterlist * sg , const void * buf , unsigned int buflen ) ;

void __sg_free_table ( struct sg_table * table , unsigned int max_ents , sg_free_fn * free_fn ) ;

void sg_free_table ( struct sg_table * table ) ;

int __sg_alloc_table ( struct sg_table * table , unsigned int nents , unsigned int max_ents , gfp_t gfp_mask , sg_alloc_fn * alloc_fn ) ;

int sg_alloc_table ( struct sg_table * table , unsigned int nents , gfp_t gfp_mask ) ;

void sg_miter_start ( struct sg_mapping_iter * miter , struct scatterlist * sgl , unsigned int nents , unsigned int flags ) ;

bool sg_miter_next ( struct sg_mapping_iter * miter ) ;

void sg_miter_stop ( struct sg_mapping_iter * miter ) ;

size_t sg_copy_from_buffer ( struct scatterlist * sgl , unsigned int nents , void * buf , size_t buflen ) ;

size_t sg_copy_to_buffer ( struct scatterlist * sgl , unsigned int nents , void * buf , size_t buflen ) ;

int string_get_size ( u64 size , const enum string_size_units units , char * buf , int len ) ;

unsigned long gcd ( unsigned long a , unsigned long b ) ;

void list_sort ( void * priv , struct list_head * head , int ( * cmp ) ( void * priv , struct list_head * a , struct list_head * b ) ) ;

unsigned long lcm ( unsigned long a , unsigned long b ) ;

unsigned int ioread8 ( void * addr ) ;

unsigned int ioread16 ( void * addr ) ;

unsigned int ioread16be ( void * addr ) ;

unsigned int ioread32 ( void * addr ) ;

unsigned int ioread32be ( void * addr ) ;

void iowrite8 ( u8 val , void * addr ) ;

void iowrite16 ( u16 val , void * addr ) ;

void iowrite16be ( u16 val , void * addr ) ;

void iowrite32 ( u32 val , void * addr ) ;

void iowrite32be ( u32 val , void * addr ) ;

void ioread8_rep ( void * addr , void * dst , unsigned long count ) ;

void ioread16_rep ( void * addr , void * dst , unsigned long count ) ;

void ioread32_rep ( void * addr , void * dst , unsigned long count ) ;

void iowrite8_rep ( void * addr , const void * src , unsigned long count ) ;

void iowrite16_rep ( void * addr , const void * src , unsigned long count ) ;

void iowrite32_rep ( void * addr , const void * src , unsigned long count ) ;

void * ioport_map ( unsigned long port , unsigned int nr ) ;

void ioport_unmap ( void * addr ) ;

void * pci_iomap ( struct pci_dev * dev , int bar , unsigned long maxlen ) ;

void pci_iounmap ( struct pci_dev * dev , void * addr ) ;

void __attribute__ ( ( weak ) ) __iowrite32_copy ( void * to , const void * from , size_t count ) ;

void __attribute__ ( ( weak ) ) __iowrite64_copy ( void * to , const void * from , size_t count ) ;

void devm_ioremap_release ( struct device * dev , void * res ) ;

void * devm_ioremap ( struct device * dev , resource_size_t offset , unsigned long size ) ;

void * devm_ioremap_nocache ( struct device * dev , resource_size_t offset , unsigned long size ) ;

void devm_iounmap ( struct device * dev , void * addr ) ;

void * devm_ioport_map ( struct device * dev , unsigned long port , unsigned int nr ) ;

void devm_ioport_unmap ( struct device * dev , void * addr ) ;

struct pcim_iomap_devres { void * table [ PCI_ROM_RESOURCE ] ; } ;

void * const * pcim_iomap_table ( struct pci_dev * pdev ) ;

void * pcim_iomap ( struct pci_dev * pdev , int bar , unsigned long maxlen ) ;

void pcim_iounmap ( struct pci_dev * pdev , void * addr ) ;

int pcim_iomap_regions ( struct pci_dev * pdev , u16 mask , const char * name ) ;

int pcim_iomap_regions_request_all ( struct pci_dev * pdev , u16 mask , const char * name ) ;

void pcim_iounmap_regions ( struct pci_dev * pdev , u16 mask ) ;

unsigned long find_last_bit ( const unsigned long * addr , unsigned long size ) ;

unsigned int hweight32 ( unsigned int w ) ;

unsigned int hweight16 ( unsigned int w ) ;

unsigned int hweight8 ( unsigned int w ) ;

unsigned long hweight64 ( __u64 w ) ;

int __attribute__ ( ( section ( ) ) ) __reacquire_kernel_lock ( void ) ;

void __attribute__ ( ( section ( ) ) ) __release_kernel_lock ( void ) ;

void __attribute__ ( ( section ( ) ) ) lock_kernel ( void ) ;

void __attribute__ ( ( section ( ) ) ) unlock_kernel ( void ) ;

u16 bitrev16 ( u16 x ) ;

u32 bitrev32 ( u32 x ) ;

u16 crc16 ( u16 crc , u8 const * buffer , size_t len ) ;

__u16 crc_t10dif ( const unsigned char * buffer , size_t len ) ;

typedef int __gwchar_t ;

typedef struct { long int quot ; long int rem ; } imaxdiv_t ;

u32 __attribute__ ( ( pure ) ) crc32_le ( u32 crc , unsigned char const * p , size_t len ) ;

u32 __attribute__ ( ( pure ) ) crc32_be ( u32 crc , unsigned char const * p , size_t len ) ;

int lzo1x_1_compress ( const unsigned char * in , size_t in_len , unsigned char * out , size_t * out_len , void * wrkmem ) ;

int lzo1x_decompress_safe ( const unsigned char * in , size_t in_len , unsigned char * out , size_t * out_len ) ;


typedef struct ct_data_s { union { ush freq ; ush code ; } fc ; union { ush dad ; ush len ; } dl ; } ct_data ;

typedef struct static_tree_desc_s static_tree_desc ;


typedef struct tree_desc_s { ct_data * dyn_tree ; int max_code ; static_tree_desc * stat_desc ; } tree_desc ;

typedef ush Pos ;

typedef unsigned IPos ;


typedef struct deflate_state { z_streamp strm ; int status ; Byte * pending_buf ; ulg pending_buf_size ; Byte * pending_out ; int pending ; int noheader ; Byte data_type ; Byte method ; int last_flush ; uInt w_size ; uInt w_bits ; uInt w_mask ; Byte * window ; ulg window_size ; Pos * prev ; Pos * head ; uInt ins_h ; uInt hash_size ; uInt hash_bits ; uInt hash_mask ; uInt hash_shift ; long block_start ; uInt match_length ; IPos prev_match ; int match_available ; uInt strstart ; uInt match_start ; uInt lookahead ; uInt prev_length ; uInt max_chain_length ; uInt max_lazy_match ; int level ; int strategy ; uInt good_match ; int nice_match ; struct ct_data_s dyn_ltree [ ( 2 * ( 256 + 1 + 29 ) + 1 ) ] ; struct ct_data_s dyn_dtree [ 2 * 30 + 1 ] ; struct ct_data_s bl_tree [ 2 * 19 + 1 ] ; struct tree_desc_s l_desc ; struct tree_desc_s d_desc ; struct tree_desc_s bl_desc ; ush bl_count [ 15 + 1 ] ; int heap [ 2 * ( 256 + 1 + 29 ) + 1 ] ; int heap_len ; int heap_max ; uch depth [ 2 * ( 256 + 1 + 29 ) + 1 ] ; uch * l_buf ; uInt lit_bufsize ; uInt last_lit ; ush * d_buf ; ulg opt_len ; ulg static_len ; ulg compressed_len ; uInt matches ; int last_eob_len ; ush bi_buf ; int bi_valid ; } deflate_state ;


typedef struct deflate_workspace { deflate_state deflate_memory ; Byte window_memory [ 2 * ( 1 << 15 ) ] ; Pos prev_memory [ 1 << 15 ] ; Pos head_memory [ 1 << ( 8 + 7 ) ] ; char overlay_memory [ ( 1 << ( 8 + 6 ) ) * ( sizeof ( ush ) + 2 ) ] ; } deflate_workspace ;

typedef enum { need_more , block_done , finish_started , finish_done } block_state ;

typedef block_state ( * compress_func ) ( deflate_state * s , int flush ) ;


typedef struct config_s { ush good_length ; ush max_lazy ; ush nice_length ; ush max_chain ; compress_func func ; } config ;

int zlib_deflateInit2 ( z_streamp strm , int level , int method , int windowBits , int memLevel , int strategy ) ;

int zlib_deflateReset ( z_streamp strm ) ;

int zlib_deflate ( z_streamp strm , int flush ) ;

int zlib_deflateEnd ( z_streamp strm ) ;

int zlib_deflate_workspacesize ( void ) ;

struct static_tree_desc_s { const ct_data * static_tree ; const int * extra_bits ; int extra_base ; int elems ; int max_length ; } ;

void zlib_tr_init ( deflate_state * s ) ;

void zlib_tr_stored_block ( deflate_state * s , char * buf , ulg stored_len , int eof ) ;

void zlib_tr_stored_type_only ( deflate_state * s ) ;

void zlib_tr_align ( deflate_state * s ) ;

ulg zlib_tr_flush_block ( deflate_state * s , char * buf , ulg stored_len , int eof ) ;

int zlib_tr_tally ( deflate_state * s , unsigned dist , unsigned lc ) ;

typedef struct { unsigned char op ; unsigned char bits ; unsigned short val ; } code ;

typedef enum { CODES , LENS , DISTS } codetype ;

typedef enum { HEAD , FLAGS , TIME , OS , EXLEN , EXTRA , NAME , COMMENT , HCRC , DICTID , DICT , TYPE , TYPEDO , STORED , COPY , TABLE , LENLENS , CODELENS , LEN , LENEXT , DIST , DISTEXT , MATCH , LIT , CHECK , LENGTH , DONE , BAD , MEM , SYNC } inflate_mode ;

struct inflate_state { inflate_mode mode ; int last ; int wrap ; int havedict ; int flags ; unsigned dmax ; unsigned long check ; unsigned long total ; unsigned wbits ; unsigned wsize ; unsigned whave ; unsigned write ; unsigned char * window ; unsigned long hold ; unsigned bits ; unsigned length ; unsigned offset ; unsigned extra ; code const * lencode ; code const * distcode ; unsigned lenbits ; unsigned distbits ; unsigned ncode ; unsigned nlen ; unsigned ndist ; unsigned have ; code * next ; unsigned short lens [ 320 ] ; unsigned short work [ 288 ] ; code codes [ 2048 ] ; } ;

void inflate_fast ( z_streamp strm , unsigned start ) ;

struct inflate_workspace { struct inflate_state inflate_state ; unsigned char working_window [ 1 << 15 ] ; } ;

int zlib_inflate_workspacesize ( void ) ;

int zlib_inflateReset ( z_streamp strm ) ;

int zlib_inflateInit2 ( z_streamp strm , int windowBits ) ;

int zlib_inflate ( z_streamp strm , int flush ) ;

int zlib_inflateEnd ( z_streamp strm ) ;

int zlib_inflateIncomp ( z_stream * z ) ;

int zlib_inflate_blob ( void * gunzip_buf , unsigned int sz , const void * buf , unsigned int len ) ;

int zlib_inflate_table ( codetype type , unsigned short * lens , unsigned codes , code * * table , unsigned * bits , unsigned short * work ) ;

void percpu_counter_set ( struct percpu_counter * fbc , s64 amount ) ;

void __percpu_counter_add ( struct percpu_counter * fbc , s64 amount , s32 batch ) ;

s64 __percpu_counter_sum ( struct percpu_counter * fbc ) ;

int __percpu_counter_init ( struct percpu_counter * fbc , s64 amount , struct lock_class_key * key ) ;

void percpu_counter_destroy ( struct percpu_counter * fbc ) ;

enum dma_sync_target { SYNC_FOR_CPU = 0 , SYNC_FOR_DEVICE = 1 , } ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) swiotlb_init_with_default_size ( size_t default_size ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) swiotlb_init ( void ) ;

int swiotlb_late_init_with_default_size ( size_t default_size ) ;

void * swiotlb_alloc_coherent ( struct device * hwdev , size_t size , dma_addr_t * dma_handle , gfp_t flags ) ;

void swiotlb_free_coherent ( struct device * hwdev , size_t size , void * vaddr , dma_addr_t dev_addr ) ;

dma_addr_t swiotlb_map_page ( struct device * dev , struct page * page , unsigned long offset , size_t size , enum dma_data_direction dir , struct dma_attrs * attrs ) ;

void swiotlb_unmap_page ( struct device * hwdev , dma_addr_t dev_addr , size_t size , enum dma_data_direction dir , struct dma_attrs * attrs ) ;

void swiotlb_sync_single_for_cpu ( struct device * hwdev , dma_addr_t dev_addr , size_t size , enum dma_data_direction dir ) ;

void swiotlb_sync_single_for_device ( struct device * hwdev , dma_addr_t dev_addr , size_t size , enum dma_data_direction dir ) ;

void swiotlb_sync_single_range_for_cpu ( struct device * hwdev , dma_addr_t dev_addr , unsigned long offset , size_t size , enum dma_data_direction dir ) ;

void swiotlb_sync_single_range_for_device ( struct device * hwdev , dma_addr_t dev_addr , unsigned long offset , size_t size , enum dma_data_direction dir ) ;

int swiotlb_map_sg_attrs ( struct device * hwdev , struct scatterlist * sgl , int nelems , enum dma_data_direction dir , struct dma_attrs * attrs ) ;

int swiotlb_map_sg ( struct device * hwdev , struct scatterlist * sgl , int nelems , int dir ) ;

void swiotlb_unmap_sg_attrs ( struct device * hwdev , struct scatterlist * sgl , int nelems , enum dma_data_direction dir , struct dma_attrs * attrs ) ;

void swiotlb_unmap_sg ( struct device * hwdev , struct scatterlist * sgl , int nelems , int dir ) ;

void swiotlb_sync_sg_for_cpu ( struct device * hwdev , struct scatterlist * sg , int nelems , enum dma_data_direction dir ) ;

void swiotlb_sync_sg_for_device ( struct device * hwdev , struct scatterlist * sg , int nelems , enum dma_data_direction dir ) ;

int swiotlb_dma_mapping_error ( struct device * hwdev , dma_addr_t dma_addr ) ;

int swiotlb_dma_supported ( struct device * hwdev , u64 mask ) ;

void iommu_area_reserve ( unsigned long * map , unsigned long i , int len ) ;

int iommu_is_span_boundary ( unsigned int index , unsigned int nr , unsigned long shift , unsigned long boundary_size ) ;

unsigned long iommu_area_alloc ( unsigned long * map , unsigned long size , unsigned long start , unsigned int nr , unsigned long shift , unsigned long boundary_size , unsigned long align_mask ) ;

void iommu_area_free ( unsigned long * map , unsigned long start , unsigned int nr ) ;

unsigned long iommu_num_pages ( unsigned long addr , unsigned long len , unsigned long io_page_size ) ;

int task_current_syscall ( struct task_struct * target , long * callno , unsigned long args [ 6 ] , unsigned int maxargs , unsigned long * sp , unsigned long * pc ) ;

int nla_validate ( struct nlattr * head , int len , int maxtype , const struct nla_policy * policy ) ;

int nla_policy_len ( const struct nla_policy * p , int n ) ;

int nla_parse ( struct nlattr * tb [ ] , int maxtype , struct nlattr * head , int len , const struct nla_policy * policy ) ;

struct nlattr * nla_find ( struct nlattr * head , int len , int attrtype ) ;

size_t nla_strlcpy ( char * dst , const struct nlattr * nla , size_t dstsize ) ;

int nla_memcpy ( void * dest , const struct nlattr * src , int count ) ;

int nla_memcmp ( const struct nlattr * nla , const void * data , size_t size ) ;

int nla_strcmp ( const struct nlattr * nla , const char * str ) ;

struct nlattr * __nla_reserve ( struct sk_buff * skb , int attrtype , int attrlen ) ;

void * __nla_reserve_nohdr ( struct sk_buff * skb , int attrlen ) ;

struct nlattr * nla_reserve ( struct sk_buff * skb , int attrtype , int attrlen ) ;

void * nla_reserve_nohdr ( struct sk_buff * skb , int attrlen ) ;

void __nla_put ( struct sk_buff * skb , int attrtype , int attrlen , const void * data ) ;

void __nla_put_nohdr ( struct sk_buff * skb , int attrlen , const void * data ) ;

int nla_put ( struct sk_buff * skb , int attrtype , int attrlen , const void * data ) ;

int nla_put_nohdr ( struct sk_buff * skb , int attrlen , const void * data ) ;

int nla_append ( struct sk_buff * skb , int attrlen , const void * data ) ;

void argv_free ( char * * argv ) ;

char * * argv_split ( gfp_t gfp , const char * str , int * argcp ) ;

int module_bug_finalize ( const Elf64_Ehdr * hdr , const Elf64_Shdr * sechdrs , struct module * mod ) ;

void module_bug_cleanup ( struct module * mod ) ;

const struct bug_entry * find_bug ( unsigned long bugaddr ) ;

enum bug_trap_type report_bug ( unsigned long bugaddr , struct pt_regs * regs ) ;

int get_option ( char * * str , int * pint ) ;

char * get_options ( const char * str , int nints , int * ints ) ;

unsigned long long memparse ( const char * ptr , char * * retptr ) ;

int __first_cpu ( const cpumask_t * srcp ) ;

int __next_cpu ( int n , const cpumask_t * srcp ) ;

int __any_online_cpu ( const cpumask_t * mask ) ;

int cpumask_next_and ( int n , const struct cpumask * src1p , const struct cpumask * src2p ) ;

int cpumask_any_but ( const struct cpumask * mask , unsigned int cpu ) ;

int _atomic_dec_and_lock ( atomic_t * atomic , spinlock_t * lock ) ;


decompress_fn decompress_method ( const unsigned char * inbuf , int len , const char * * name ) ;

struct group_data { int limit [ 20 + 1 ] ; int base [ 20 ] ; int permute [ 258 ] ; int minLen , maxLen ; } ;

struct bunzip_data { int writeCopies , writePos , writeRunCountdown , writeCount , writeCurrent ; int ( * fill ) ( void * , unsigned int ) ; int inbufCount , inbufPos ; unsigned char * inbuf ; unsigned int inbufBitCount , inbufBits ; unsigned int crc32Table [ 256 ] , headerCRC , totalCRC , writeCRC ; unsigned int * dbuf , dbufSize ; unsigned char selectors [ 32768 ] ; struct group_data groups [ 6 ] ; int io_error ; } ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) bunzip2 ( unsigned char * buf , int len , int ( * fill ) ( void * , unsigned int ) , int ( * flush ) ( void * , unsigned int ) , unsigned char * outbuf , int * pos , void ( * error_fn ) ( char * x ) ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) gunzip ( unsigned char * buf , int len , int ( * fill ) ( void * , unsigned int ) , int ( * flush ) ( void * , unsigned int ) , unsigned char * out_buf , int * pos , void ( * error_fn ) ( char * x ) ) ;

struct rc { int ( * fill ) ( void * , unsigned int ) ; uint8_t * ptr ; uint8_t * buffer ; uint8_t * buffer_end ; int buffer_size ; uint32_t code ; uint32_t range ; uint32_t bound ; } ;

struct lzma_header { uint8_t pos ; uint32_t dict_size ; uint64_t dst_size ; } __attribute__ ( ( packed ) ) ;
struct writer { uint8_t * buffer ; uint8_t previous_byte ; size_t buffer_pos ; int bufsize ; size_t global_pos ; int ( * flush ) ( void * , unsigned int ) ; struct lzma_header * header ; } ;

struct cstate { int state ; uint32_t rep0 , rep1 , rep2 , rep3 ; } ;
void sort_extable ( struct exception_table_entry * start , struct exception_table_entry * finish ) ;

void trim_init_extable ( struct module * m ) ;

unsigned long find_next_bit ( const unsigned long * addr , unsigned long size , unsigned long offset ) ;

unsigned long find_next_zero_bit ( const unsigned long * addr , unsigned long size , unsigned long offset ) ;

unsigned long find_first_bit ( const unsigned long * addr , unsigned long size ) ;

unsigned long find_first_zero_bit ( const unsigned long * addr , unsigned long size ) ;

struct flex_array_part ;

struct flex_array { union { struct { int element_size ; int total_nr_elements ; struct flex_array_part * parts [ ] ; } ; char padding [ ( ( 1UL ) << 12 ) ] ; } ; } ;

struct flex_array_part { char elements [ ( ( 1UL ) << 12 ) ] ; } ;
struct flex_array * flex_array_alloc ( int element_size , unsigned int total , gfp_t flags ) ;

void flex_array_free_parts ( struct flex_array * fa ) ;

void flex_array_free ( struct flex_array * fa ) ;

int flex_array_put ( struct flex_array * fa , unsigned int element_nr , void * src , gfp_t flags ) ;

int flex_array_clear ( struct flex_array * fa , unsigned int element_nr ) ;

int flex_array_prealloc ( struct flex_array * fa , unsigned int start , unsigned int end , gfp_t flags ) ;

void * flex_array_get ( struct flex_array * fa , unsigned int element_nr ) ;

int flex_array_shrink ( struct flex_array * fa ) ;

int idr_pre_get ( struct idr * idp , gfp_t gfp_mask ) ;

int idr_get_new_above ( struct idr * idp , void * ptr , int starting_id , int * id ) ;

int idr_get_new ( struct idr * idp , void * ptr , int * id ) ;

void idr_remove ( struct idr * idp , int id ) ;

void idr_remove_all ( struct idr * idp ) ;

void idr_destroy ( struct idr * idp ) ;

void * idr_find ( struct idr * idp , int id ) ;

int idr_for_each ( struct idr * idp , int ( * fn ) ( int id , void * p , void * data ) , void * data ) ;

void * idr_get_next ( struct idr * idp , int * nextidp ) ;

void * idr_replace ( struct idr * idp , void * ptr , int id ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) idr_init_cache ( void ) ;

void idr_init ( struct idr * idp ) ;

int ida_pre_get ( struct ida * ida , gfp_t gfp_mask ) ;

int ida_get_new_above ( struct ida * ida , int starting_id , int * p_id ) ;

int ida_get_new ( struct ida * ida , int * p_id ) ;

void ida_remove ( struct ida * ida , int id ) ;

void ida_destroy ( struct ida * ida ) ;

void ida_init ( struct ida * ida ) ;

unsigned long int_sqrt ( unsigned long x ) ;

int ioremap_page_range ( unsigned long addr , unsigned long end , unsigned long phys_addr , pgprot_t prot ) ;

bool current_is_single_threaded ( void ) ;

void klist_init ( struct klist * k , void ( * get ) ( struct klist_node * ) , void ( * put ) ( struct klist_node * ) ) ;

void klist_add_head ( struct klist_node * n , struct klist * k ) ;

void klist_add_tail ( struct klist_node * n , struct klist * k ) ;

void klist_add_after ( struct klist_node * n , struct klist_node * pos ) ;

void klist_add_before ( struct klist_node * n , struct klist_node * pos ) ;

struct klist_waiter { struct list_head list ; struct klist_node * node ; struct task_struct * process ; int woken ; } ;

void klist_del ( struct klist_node * n ) ;

void klist_remove ( struct klist_node * n ) ;

int klist_node_attached ( struct klist_node * n ) ;

void klist_iter_init_node ( struct klist * k , struct klist_iter * i , struct klist_node * n ) ;

void klist_iter_init ( struct klist * k , struct klist_iter * i ) ;

void klist_iter_exit ( struct klist_iter * i ) ;

struct klist_node * klist_next ( struct klist_iter * i ) ;

char * kobject_get_path ( struct kobject * kobj , gfp_t gfp_mask ) ;

int kobject_set_name_vargs ( struct kobject * kobj , const char * fmt , va_list vargs ) ;

int kobject_set_name ( struct kobject * kobj , const char * fmt , ... ) ;

void kobject_init ( struct kobject * kobj , struct kobj_type * ktype ) ;

int kobject_add ( struct kobject * kobj , struct kobject * parent , const char * fmt , ... ) ;

int kobject_init_and_add ( struct kobject * kobj , struct kobj_type * ktype , struct kobject * parent , const char * fmt , ... ) ;

int kobject_rename ( struct kobject * kobj , const char * new_name ) ;

int kobject_move ( struct kobject * kobj , struct kobject * new_parent ) ;

void kobject_del ( struct kobject * kobj ) ;

struct kobject * kobject_get ( struct kobject * kobj ) ;

void kobject_put ( struct kobject * kobj ) ;

struct kobject * kobject_create ( void ) ;

struct kobject * kobject_create_and_add ( const char * name , struct kobject * parent ) ;

void kset_init ( struct kset * k ) ;

int kset_register ( struct kset * k ) ;

void kset_unregister ( struct kset * k ) ;

struct kobject * kset_find_obj ( struct kset * kset , const char * name ) ;

struct kset * kset_create_and_add ( const char * name , struct kset_uevent_ops * uevent_ops , struct kobject * parent_kobj ) ;

int kobject_action_type ( const char * buf , size_t count , enum kobject_action * type ) ;

int kobject_uevent_env ( struct kobject * kobj , enum kobject_action action , char * envp_ext [ ] ) ;

int kobject_uevent ( struct kobject * kobj , enum kobject_action action ) ;

int add_uevent_var ( struct kobj_uevent_env * env , const char * format , ... ) ;

void kref_set ( struct kref * kref , int num ) ;

void kref_init ( struct kref * kref ) ;

void kref_get ( struct kref * kref ) ;

int kref_put ( struct kref * kref , void ( * release ) ( struct kref * kref ) ) ;

void plist_add ( struct plist_node * node , struct plist_head * head ) ;

void plist_del ( struct plist_node * node , struct plist_head * head ) ;

int heap_init ( struct ptr_heap * heap , size_t size , gfp_t gfp_mask , int ( * gt ) ( void * , void * ) ) ;

void heap_free ( struct ptr_heap * heap ) ;

void * heap_insert ( struct ptr_heap * heap , void * p ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) prio_tree_init ( void ) ;

struct prio_tree_node * prio_tree_replace ( struct prio_tree_root * root , struct prio_tree_node * old , struct prio_tree_node * node ) ;

struct prio_tree_node * prio_tree_insert ( struct prio_tree_root * root , struct prio_tree_node * node ) ;

void prio_tree_remove ( struct prio_tree_root * root , struct prio_tree_node * node ) ;

struct prio_tree_node * prio_tree_next ( struct prio_tree_iter * iter ) ;

int prop_descriptor_init ( struct prop_descriptor * pd , int shift ) ;

void prop_change_shift ( struct prop_descriptor * pd , int shift ) ;

int prop_local_init_percpu ( struct prop_local_percpu * pl ) ;

void prop_local_destroy_percpu ( struct prop_local_percpu * pl ) ;

void __prop_inc_percpu ( struct prop_descriptor * pd , struct prop_local_percpu * pl ) ;

void __prop_inc_percpu_max ( struct prop_descriptor * pd , struct prop_local_percpu * pl , long frac ) ;

void prop_fraction_percpu ( struct prop_descriptor * pd , struct prop_local_percpu * pl , long * numerator , long * denominator ) ;

int prop_local_init_single ( struct prop_local_single * pl ) ;

void prop_local_destroy_single ( struct prop_local_single * pl ) ;

void __prop_inc_single ( struct prop_descriptor * pd , struct prop_local_single * pl ) ;

void prop_fraction_single ( struct prop_descriptor * pd , struct prop_local_single * pl , long * numerator , long * denominator ) ;

struct radix_tree_node { unsigned int height ; unsigned int count ; struct rcu_head rcu_head ; void * slots [ ( 1UL << ( 0 ? 4 : 6 ) ) ] ; unsigned long tags [ 2 ] [ ( ( ( 1UL << ( 0 ? 4 : 6 ) ) + 64 - 1 ) / 64 ) ] ; } ;

struct radix_tree_path { struct radix_tree_node * node ; int offset ; } ;

struct radix_tree_preload { int nr ; struct radix_tree_node * nodes [ ( ( ( ( ( 8 * sizeof ( unsigned long ) ) ) + ( ( 0 ? 4 : 6 ) ) - 1 ) / ( ( 0 ? 4 : 6 ) ) ) ) ] ; } ;

int radix_tree_preload ( gfp_t gfp_mask ) ;
int radix_tree_insert ( struct radix_tree_root * root , unsigned long index , void * item ) ;

void * * radix_tree_lookup_slot ( struct radix_tree_root * root , unsigned long index ) ;

void * radix_tree_lookup ( struct radix_tree_root * root , unsigned long index ) ;

void * radix_tree_tag_set ( struct radix_tree_root * root , unsigned long index , unsigned int tag ) ;

void * radix_tree_tag_clear ( struct radix_tree_root * root , unsigned long index , unsigned int tag ) ;

int radix_tree_tag_get ( struct radix_tree_root * root , unsigned long index , unsigned int tag ) ;

unsigned long radix_tree_next_hole ( struct radix_tree_root * root , unsigned long index , unsigned long max_scan ) ;

unsigned long radix_tree_prev_hole ( struct radix_tree_root * root , unsigned long index , unsigned long max_scan ) ;

unsigned int radix_tree_gang_lookup ( struct radix_tree_root * root , void * * results , unsigned long first_index , unsigned int max_items ) ;

unsigned int radix_tree_gang_lookup_slot ( struct radix_tree_root * root , void * * * results , unsigned long first_index , unsigned int max_items ) ;

unsigned int radix_tree_gang_lookup_tag ( struct radix_tree_root * root , void * * results , unsigned long first_index , unsigned int max_items , unsigned int tag ) ;

unsigned int radix_tree_gang_lookup_tag_slot ( struct radix_tree_root * root , void * * * results , unsigned long first_index , unsigned int max_items , unsigned int tag ) ;

void * radix_tree_delete ( struct radix_tree_root * root , unsigned long index ) ;

int radix_tree_tagged ( struct radix_tree_root * root , unsigned int tag ) ;

void __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) __attribute__ ( ( no_instrument_function ) ) radix_tree_init ( void ) ;

int __ratelimit ( struct ratelimit_state * rs ) ;

void rb_insert_color ( struct rb_node * node , struct rb_root * root ) ;

void rb_erase ( struct rb_node * node , struct rb_root * root ) ;

struct rb_node * rb_first ( const struct rb_root * root ) ;

struct rb_node * rb_last ( const struct rb_root * root ) ;

struct rb_node * rb_next ( const struct rb_node * node ) ;

struct rb_node * rb_prev ( const struct rb_node * node ) ;

void rb_replace_node ( struct rb_node * victim , struct rb_node * new , struct rb_root * root ) ;

u32 reciprocal_value ( u32 k ) ;

void __init_rwsem ( struct rw_semaphore * sem , const char * name , struct lock_class_key * key ) ;

struct rwsem_waiter { struct list_head list ; struct task_struct * task ; unsigned int flags ; } ;
struct rw_semaphore __attribute__ ( ( __section__ ( ) ) ) * rwsem_down_read_failed ( struct rw_semaphore * sem ) ;

struct rw_semaphore __attribute__ ( ( __section__ ( ) ) ) * rwsem_down_write_failed ( struct rw_semaphore * sem ) ;

struct rw_semaphore * rwsem_wake ( struct rw_semaphore * sem ) ;

struct rw_semaphore * rwsem_downgrade_wake ( struct rw_semaphore * sem ) ;

void sha_transform ( __u32 * digest , const char * in , __u32 * W ) ;

void sha_init ( __u32 * buf ) ;

void show_mem ( void ) ;

int strnicmp ( const char * s1 , const char * s2 , size_t len ) ;

int strcasecmp ( const char * s1 , const char * s2 ) ;

int strncasecmp ( const char * s1 , const char * s2 , size_t n ) ;

char * strcpy ( char * dest , const char * src ) ;

char * strncpy ( char * dest , const char * src , size_t count ) ;

size_t strlcpy ( char * dest , const char * src , size_t size ) ;

char * strcat ( char * dest , const char * src ) ;

char * strncat ( char * dest , const char * src , size_t count ) ;

size_t strlcat ( char * dest , const char * src , size_t count ) ;

int strcmp ( const char * cs , const char * ct ) ;

int strncmp ( const char * cs , const char * ct , size_t count ) ;

char * strchr ( const char * s , int c ) ;

char * strrchr ( const char * s , int c ) ;

char * strnchr ( const char * s , size_t count , int c ) ;

char * strstrip ( char * s ) ;

size_t strlen ( const char * s ) ;

size_t strnlen ( const char * s , size_t count ) ;

size_t strspn ( const char * s , const char * accept ) ;

size_t strcspn ( const char * s , const char * reject ) ;

char * strpbrk ( const char * cs , const char * ct ) ;

char * strsep ( char * * s , const char * ct ) ;

bool sysfs_streq ( const char * s1 , const char * s2 ) ;

int memcmp ( const void * cs , const void * ct , size_t count ) ;

void * memscan ( void * addr , int c , size_t size ) ;

char * strstr ( const char * s1 , const char * s2 ) ;

void * memchr ( const void * s , int c , size_t n ) ;

unsigned long simple_strtoul ( const char * cp , char * * endp , unsigned int base ) ;

long simple_strtol ( const char * cp , char * * endp , unsigned int base ) ;

unsigned long long simple_strtoull ( const char * cp , char * * endp , unsigned int base ) ;

long long simple_strtoll ( const char * cp , char * * endp , unsigned int base ) ;

int strict_strtoul ( const char * cp , unsigned int base , unsigned long * res ) ;

int strict_strtol ( const char * cp , unsigned int base , long * res ) ;

int strict_strtoull ( const char * cp , unsigned int base , unsigned long long * res ) ;

int strict_strtoll ( const char * cp , unsigned int base , long long * res ) ;

enum format_type { FORMAT_TYPE_NONE , FORMAT_TYPE_WIDTH , FORMAT_TYPE_PRECISION , FORMAT_TYPE_CHAR , FORMAT_TYPE_STR , FORMAT_TYPE_PTR , FORMAT_TYPE_PERCENT_CHAR , FORMAT_TYPE_INVALID , FORMAT_TYPE_LONG_LONG , FORMAT_TYPE_ULONG , FORMAT_TYPE_LONG , FORMAT_TYPE_UBYTE , FORMAT_TYPE_BYTE , FORMAT_TYPE_USHORT , FORMAT_TYPE_SHORT , FORMAT_TYPE_UINT , FORMAT_TYPE_INT , FORMAT_TYPE_NRCHARS , FORMAT_TYPE_SIZE_T , FORMAT_TYPE_PTRDIFF } ;

struct printf_spec { enum format_type type ; int flags ; int field_width ; int base ; int precision ; int qualifier ; } ;

int vsnprintf ( char * buf , size_t size , const char * fmt , va_list args ) ;

int vscnprintf ( char * buf , size_t size , const char * fmt , va_list args ) ;

int snprintf ( char * buf , size_t size , const char * fmt , ... ) ;

int scnprintf ( char * buf , size_t size , const char * fmt , ... ) ;

int vsprintf ( char * buf , const char * fmt , va_list args ) ;

int sprintf ( char * buf , const char * fmt , ... ) ;

int vbin_printf ( u32 * bin_buf , size_t size , const char * fmt , va_list args ) ;

int bstr_printf ( char * buf , size_t size , const char * fmt , const u32 * bin_buf ) ;

int bprintf ( u32 * bin_buf , size_t size , const char * fmt , ... ) ;

int vsscanf ( const char * buf , const char * fmt , va_list args ) ;

int sscanf ( const char * buf , const char * fmt , ... ) ;

u32 crc32c ( u32 crc , const void * address , unsigned int length ) ;

int rdmsr_on_cpu ( unsigned int cpu , u32 msr_no , u32 * l , u32 * h ) ;

int wrmsr_on_cpu ( unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;

void rdmsr_on_cpus ( const struct cpumask * mask , u32 msr_no , struct msr * msrs ) ;

void wrmsr_on_cpus ( const struct cpumask * mask , u32 msr_no , struct msr * msrs ) ;

int rdmsr_safe_on_cpu ( unsigned int cpu , u32 msr_no , u32 * l , u32 * h ) ;

int wrmsr_safe_on_cpu ( unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;

int rdmsr_safe_regs_on_cpu ( unsigned int cpu , u32 * regs ) ;

int wrmsr_safe_regs_on_cpu ( unsigned int cpu , u32 * regs ) ;

void wbinvd_on_cpu ( int cpu ) ;

int wbinvd_on_all_cpus ( void ) ;

struct msr * msrs_alloc ( void ) ;

void msrs_free ( struct msr * msrs ) ;

void __memcpy_toio ( unsigned long dst , const void * src , unsigned len ) ;

void __memcpy_fromio ( void * dst , unsigned long src , unsigned len ) ;

void memset_io ( volatile void * a , int b , size_t c ) ;

__wsum csum_partial ( const void * buff , int len , __wsum sum ) ;

__sum16 ip_compute_csum ( const void * buff , int len ) ;

__wsum csum_partial_copy_from_user ( const void * src , void * dst , int len , __wsum isum , int * errp ) ;

__wsum csum_partial_copy_to_user ( const void * src , void * dst , int len , __wsum isum , int * errp ) ;

__wsum csum_partial_copy_nocheck ( const void * src , void * dst , int len , __wsum sum ) ;

__sum16 csum_ipv6_magic ( const struct in6_addr * saddr , const struct in6_addr * daddr , __u32 len , unsigned short proto , __wsum sum ) ;

void use_tsc_delay ( void ) ;

int __attribute__ ( ( __section__ ( ) ) ) __attribute__ ( ( __cold__ ) ) read_current_timer ( unsigned long * timer_val ) ;

void __delay ( unsigned long loops ) ;

void __udelay ( unsigned long usecs ) ;

void __ndelay ( unsigned long nsecs ) ;

void * memmove ( void * dest , const void * src , size_t count ) ;

long __strncpy_from_user ( char * dst , const char * src , long count ) ;

long strncpy_from_user ( char * dst , const char * src , long count ) ;

unsigned long __clear_user ( void * addr , unsigned long size ) ;

unsigned long clear_user ( void * to , unsigned long n ) ;

long __strnlen_user ( const char * s , long n ) ;

long strnlen_user ( const char * s , long n ) ;

long strlen_user ( const char * s ) ;

unsigned long copy_in_user ( void * to , const void * from , unsigned len ) ;

unsigned long copy_user_handle_tail ( char * to , char * from , unsigned len , unsigned zerorest ) ;

int enable_a20 ( void ) ;

int cmdline_find_option ( const char * option , char * buffer , int bufsize ) ;

int cmdline_find_option_bool ( const char * option ) ;

int validate_cpu ( void ) ;

int check_cpu ( int * cpu_level_ptr , int * req_level_ptr , u32 * * err_flags_ptr ) ;

void query_edd ( void ) ;

void * memcpy ( void * dest , const void * src , unsigned n ) ;

void decompress_kernel ( void * rmode , long heap , unsigned char * input_data , unsigned long input_len , unsigned char * output ) ;

int query_mca ( void ) ;

int detect_memory ( void ) ;

struct gdt_ptr { u16 len ; u32 ptr ; } __attribute__ ( ( packed ) ) ;
void go_to_protected_mode ( void ) ;

int printf ( const char * fmt , ... ) ;

int strcmp ( const char * str1 , const char * str2 ) ;
size_t strnlen ( const char * s , size_t maxlen ) ;
unsigned int atou ( const char * s ) ;

void __attribute__ ( ( section ( ) ) ) putchar ( int ch ) ;

void __attribute__ ( ( section ( ) ) ) puts ( const char * str ) ;

int getchar ( void ) ;

void kbd_flush ( void ) ;

int getchar_timeout ( void ) ;


void set_video ( void ) ;

void vesa_store_edid ( void ) ;

typedef unsigned long u32 ;
