/*
 * wrapper.hpp
 *
 *  Created on: 2012-04-17
 *      Author: akshayk
 */

#ifndef CFI_WRAPPERS_HPP_
#define CFI_WRAPPERS_HPP_

#include <stdarg.h>

extern "C" {
    #include "kernel_types.h"
}

// example:
// note: the & in the args section is needed to make the wrapper
//       able to modify the arguments by reference.
// int foo_func(char *bar, int baz);
// FUNC_WRAPPER(foo_func, (char *&bar, int &baz), {
//   pre_call {
//
//   }
// })
SET_TAINT_TRACKER(struct work_struct, func);
SET_TAINT_TRACKER(struct mii_bus, read);
SET_TAINT_TRACKER(struct device_driver, probe);
SET_TAINT_TRACKER(struct device, release);
SET_TAINT_TRACKER(struct file_operations, llseek);
SET_TAINT_TRACKER(struct file_system_type, get_sb);
SET_TAINT_TRACKER(struct super_operations, alloc_inode);

bool is_kernel_virtual_address_space(void *pc)
{
    unsigned long p = (unsigned long) pc;
    /* Taken from Documentation/x86/x86_64/mm.txt */
    return (p > 0x00007fffffffffff );
}

#define WRAP_RECURSIVE_KERNEL(arg)  \
    if(is_kernel_virtual_address_space((void*)arg)) \
    {   WRAP_RECURSIVE(arg);    }

<<<<<<< .mine

=======
>>>>>>> .r761
TYPE_WRAPPER(struct super_operations, {
    pre {
        D( kern_printk("    super_block\n"); )

        WRAP_FUNC(arg.alloc_inode);
        WRAP_FUNC(arg.destroy_inode);
        WRAP_FUNC(arg.dirty_inode);
        WRAP_FUNC(arg.write_inode);
        WRAP_FUNC(arg.drop_inode);
        WRAP_FUNC(arg.delete_inode);
        WRAP_FUNC(arg.put_super);
        WRAP_FUNC(arg.write_super);
        WRAP_FUNC(arg.sync_fs);
        WRAP_FUNC(arg.freeze_fs);
        WRAP_FUNC(arg.unfreeze_fs);
        WRAP_FUNC(arg.statfs);
        WRAP_FUNC(arg.remount_fs);
        WRAP_FUNC(arg.clear_inode);
        WRAP_FUNC(arg.umount_begin);
        WRAP_FUNC(arg.show_options);
        WRAP_FUNC(arg.show_stats);
        WRAP_FUNC(arg.quota_read);
        WRAP_FUNC(arg.quota_write);
        WRAP_FUNC(arg.bdev_try_to_free_page);
    }
    post { }
})

TYPE_WRAPPER(struct dquot_operations, {
    pre {
        D( kern_printk("    dquot_operations\n"); )

          WRAP_FUNC(arg.initialize);
          WRAP_FUNC(arg.drop);
          WRAP_FUNC(arg.alloc_space);
          WRAP_FUNC(arg.alloc_inode);
          WRAP_FUNC(arg.free_space);
          WRAP_FUNC(arg.free_inode);
          WRAP_FUNC(arg.transfer);
          WRAP_FUNC(arg.write_dquot);
          WRAP_FUNC(arg.alloc_dquot);
          WRAP_FUNC(arg.destroy_dquot);
          WRAP_FUNC(arg.acquire_dquot);
          WRAP_FUNC(arg.release_dquot);
          WRAP_FUNC(arg.mark_dirty);
          WRAP_FUNC(arg.write_info);
          WRAP_FUNC(arg.reserve_space);
          WRAP_FUNC(arg.claim_space);
          WRAP_FUNC(arg.release_rsv);
          WRAP_FUNC(arg.get_reserved_space);
    }
    post { }
})


TYPE_WRAPPER(struct quotactl_ops, {
    pre {
        D( kern_printk("    dquot_operations\n"); )

        WRAP_FUNC(arg.quota_on);
        WRAP_FUNC(arg.quota_off);
        WRAP_FUNC(arg.quota_sync);
        WRAP_FUNC(arg.get_info);
        WRAP_FUNC(arg.set_info);
        WRAP_FUNC(arg.get_dqblk);
        WRAP_FUNC(arg.set_dqblk);
        WRAP_FUNC(arg.get_xstate);
        WRAP_FUNC(arg.get_xquota);
        WRAP_FUNC(arg.set_xquota);
    }
    post { }
})

TYPE_WRAPPER(struct inode_operations, {
    pre {
        D( kern_printk("    dquot_operations\n"); )


        WRAP_FUNC(arg.create);
        WRAP_FUNC(arg.lookup);
        WRAP_FUNC(arg.link);
        WRAP_FUNC(arg.unlink);
        WRAP_FUNC(arg.symlink);
        WRAP_FUNC(arg.mkdir);
        WRAP_FUNC(arg.rmdir);
        WRAP_FUNC(arg.mknod);
        WRAP_FUNC(arg.rename);
        WRAP_FUNC(arg.readlink);
        WRAP_FUNC(arg.follow_link);
        WRAP_FUNC(arg.put_link);
        WRAP_FUNC(arg.truncate);
        WRAP_FUNC(arg.permission);
        WRAP_FUNC(arg.check_acl);
        WRAP_FUNC(arg.setattr);
        WRAP_FUNC(arg.getattr);
        WRAP_FUNC(arg.setxattr);
        WRAP_FUNC(arg.getxattr);
        WRAP_FUNC(arg.listxattr);
        WRAP_FUNC(arg.removexattr);
        WRAP_FUNC(arg.truncate_range);
        WRAP_FUNC(arg.fallocate);
        WRAP_FUNC(arg.fiemap);
    }
    post { }
})

TYPE_WRAPPER(struct export_operations, {
    pre {
        D( kern_printk("    export_operations\n"); )

          WRAP_FUNC(arg.encode_fh);
          WRAP_FUNC(arg.fh_to_dentry);
          WRAP_FUNC(arg.fh_to_parent);
          WRAP_FUNC(arg.get_name);
          WRAP_FUNC(arg.get_parent);
    }
    post { }
})

TYPE_WRAPPER(struct xattr_handler, {
    pre {
          D( kern_printk("    xattr_handler!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"); )
              WRAP_FUNC(arg.list);
              WRAP_FUNC(arg.get);
              WRAP_FUNC(arg.set);
    }
    post { }
})

<<<<<<< .mine

=======
>>>>>>> .r761
TYPE_WRAPPER(struct file_operations, {
    pre {
        D( kern_printk("    file_operations\n"); )

          WRAP_FUNC(arg.llseek);
          WRAP_FUNC(arg.read);
          WRAP_FUNC(arg.write);
          WRAP_FUNC(arg.aio_read);
          WRAP_FUNC(arg.aio_write);
          WRAP_FUNC(arg.readdir);
          WRAP_FUNC(arg.poll);
          WRAP_FUNC(arg.ioctl);
          WRAP_FUNC(arg.unlocked_ioctl);
          WRAP_FUNC(arg.compat_ioctl);
          WRAP_FUNC(arg.mmap);
          WRAP_FUNC(arg.open);
          WRAP_FUNC(arg.flush);
          WRAP_FUNC(arg.release);
          WRAP_FUNC(arg.fsync);
          WRAP_FUNC(arg.aio_fsync);
          WRAP_FUNC(arg.fasync);
          WRAP_FUNC(arg.lock);
          WRAP_FUNC(arg.sendpage);
          WRAP_FUNC(arg.get_unmapped_area);
          WRAP_FUNC(arg.check_flags);
          WRAP_FUNC(arg.flock);
          WRAP_FUNC(arg.splice_write);
          WRAP_FUNC(arg.splice_read);
          WRAP_FUNC(arg.setlease);
    }
    post { }
})


TYPE_WRAPPER(struct address_space_operations, {
    pre {
         D(kern_printk("    address_space_operations\n");)

            WRAP_FUNC(arg.writepage);
            WRAP_FUNC(arg.readpage);
            WRAP_FUNC(arg.sync_page);
            WRAP_FUNC(arg.writepages);
            WRAP_FUNC(arg.set_page_dirty);
            WRAP_FUNC(arg.readpages);
            WRAP_FUNC(arg.bmap);
            WRAP_FUNC(arg.invalidatepage);
            WRAP_FUNC(arg.releasepage);
            WRAP_FUNC(arg.direct_IO);
            WRAP_FUNC(arg.get_xip_mem);
            WRAP_FUNC(arg.migratepage);
            WRAP_FUNC(arg.launder_page);
            WRAP_FUNC(arg.is_partially_uptodate);
            WRAP_FUNC(arg.error_remove_page);
    }
    post { }
})


TYPE_WRAPPER(struct address_space, {
    pre {
        D( kern_printk("    address_space\n");)
        WRAP_RECURSIVE_KERNEL(arg.a_ops);
    }
    post { }
})

TYPE_WRAPPER(struct block_device , {
    pre {
        D( kern_printk("     block_device\n"); )

        WRAP_RECURSIVE_KERNEL(arg.bd_inode);
        WRAP_RECURSIVE_KERNEL(arg.bd_super);
    }
    post { }
})


#define LOOP_COUNT 5

TYPE_WRAPPER(struct super_block, {
    pre {
        D(kern_printk("    super_block\n");)

        WRAP_RECURSIVE_KERNEL(arg.s_type);
        WRAP_RECURSIVE_KERNEL(arg.s_op);
        WRAP_RECURSIVE_KERNEL(arg.s_export_op);
        WRAP_RECURSIVE_KERNEL(arg.dq_op);
        WRAP_RECURSIVE_KERNEL(arg.s_qcop);
       // WRAP_RECURSIVE(arg.s_bdev);

        if(0 != arg.s_xattr) {
            D(kern_printk("inside super_block 1 : %lx\n", arg.s_xattr); )
            struct xattr_handler *handler = *arg.s_xattr;
            for(int i=0; i < LOOP_COUNT ; i++) {
                D(kern_printk("inside super block 2 : %lx\n", handler);)
                WRAP_RECURSIVE_KERNEL(handler);
                ++handler;
            }
        }
    }
    post { }
})

/// set inodes to be structure tainted
ADD_TAINT_TRACKER(struct inode);

TYPE_WRAPPER(struct inode, {
    pre {
        WITH_STRUCT_TAINTED_DATA(arg, {
            D( kern_printk("    inode\n"); )

            WRAP_RECURSIVE_KERNEL(arg.i_sb);
            //WITH_TAINTED_DATA(arg.i_op, {
            //    kern_printk("check data is tainted\n");
            //});
            WRAP_RECURSIVE_KERNEL(arg.i_op);
            WRAP_RECURSIVE_KERNEL(arg.i_fop);
            WRAP_RECURSIVE_KERNEL(arg.i_mapping);
            //WRAP_RECURSIVE_KERNEL(arg.i_bdev);
        })
    }
    post { }
})

<<<<<<< .mine
/*SET_TAINT_TRACKER(struct buffer_head, b_end_io);
TYPE_WRAPPER(struct buffer_head, {
=======
TYPE_WRAPPER(struct buffer_head , {
>>>>>>> .r761
    pre {
        D( kern_printk("     buffer_head\n"); )

        WRAP_FUNC(arg.b_end_io);

        WRAP_RECURSIVE_KERNEL(arg.b_assoc_map);
    }
    post { }
})
*/
/*
TYPE_WRAPPER(struct journal_s , {
    pre {
        D( kern_printk("     journal_s\n"); )

        WRAP_RECURSIVE_KERNEL(arg.j_sb_buffer);
        WRAP_RECURSIVE_KERNEL(arg.j_dev);
        WRAP_RECURSIVE_KERNEL(arg.j_inode);

    }
    post { }
})
*/

// set kmem_cache structs to be function-pointer based taint-tracked
SET_TAINT_TRACKER(struct kmem_cache, ctor);

TYPE_WRAPPER(struct kmem_cache , {
    pre {
        WITH_FUNC_TAINTED_DATA(arg, {
            D( kern_printk("     kmem_cache\n"); )

            // if this is a new taint tracker, and if the size is right, then
            // extend the size; we don't want to re-extend the size every time
            // the tainted hashes are invalidated.
            if(IS_FIRST_TAINTING
            && (sizeof(struct inode) == arg.size
                || sizeof(struct inode) == arg.size)) {
                TAINT_EXTEND_SIZE(arg.size);
            }

            WRAP_FUNC(arg.ctor);
        });
    }
    post { }
})

<<<<<<< .mine
/*SET_TAINT_TRACKER(struct task_struct, notifier);
=======
>>>>>>> .r761
TYPE_WRAPPER(struct task_struct , {
    pre {
        D( kern_printk("     task_struct\n"); )

        WRAP_FUNC(arg.notifier);
    }
    post { }
})
*/


TYPE_WRAPPER(struct page , {
    pre {
        D( kern_printk("     page\n"); )

        WRAP_RECURSIVE_KERNEL(arg.mapping);
    }
    post { }
})

TYPE_WRAPPER(struct mb_cache_op , {
    pre {
        D( kern_printk("     mb_cache_op\n"); )

        WRAP_FUNC(arg.free);
    }
    post { }
})

<<<<<<< .mine

=======
>>>>>>> .r761
TYPE_WRAPPER(struct file_system_type, {
    pre {
        D( kern_printk("    file_system_type\n"); )
        WRAP_FUNC(arg.get_sb);
        WRAP_FUNC(arg.kill_sb);
    }
    post { }
})

TYPE_WRAPPER(struct __wait_queue, {
    pre {
        D( kern_printk("    __wait_queue\n"); )
        WRAP_FUNC(arg.func);
    }
    post { }
})


TYPE_WRAPPER(ctor, {
    pre {
        D( kern_printk("    ctor\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})


TYPE_WRAPPER(fill_super, {
    pre {
        D( kern_printk("    fill_super\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(read_actor_t, {
    pre {
        D( kern_printk("    read_actor_t\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(wait_queue_func_t, {
    pre {
        D( kern_printk("    wait_queue_func_t\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(get_block_t, {
    pre {
        D( kern_printk("    get_block_t\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(dio_iodone_t, {
    pre {
        D( kern_printk("    dio_iodone_t\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(bh_end_io_t, {
    pre {
        D( kern_printk("    bh_end_io_t\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

/*TYPE_WRAPPER(threadfn, {
    pre {
        D( kern_printk("    notifier\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})
*/
TYPE_WRAPPER(fn_scan, {
    pre {
        D( kern_printk("    fn_scan\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

FUNC_WRAPPER(kthread_create, ( threadfn thread_fun, void *data , const char namefmt[], ... ), {
        struct kthread_create_info *create(0);
        char format_buff[sizeof(create->result->comm)];
        va_list args;
        va_start(args, namefmt);
        kern_vsnprintf(&(format_buff[0]), sizeof(format_buff), namefmt, args);
        va_end(args);
        WRAP_FUNC(thread_fun);
        kern_printk(" kthread_create wrapped !!!!!!!!!!!!!!!!!!  : %lx",thread_fun);
        return kthread_create(thread_fun, data, format_buff);
})

/*
FUNC_WRAPPER(kmem_cache_create, ( const char * name , size_t size , size_t align , unsigned long flags , ctor ctor_var  ), {
        WRAP_FUNC(ctor_var);
        return kmem_cache_create(name, size+4, align, flags, ctor_var);
})
*/

TYPE_WRAPPER(notifier, {
    pre {
        D( kern_printk("    notifier\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(struct net_device_ops, {
    pre {
        D( kern_printk("    net_device_ops\n"); )
        WRAP_FUNC(arg.ndo_init);
        WRAP_FUNC(arg.ndo_uninit);
        WRAP_FUNC(arg.ndo_open);
        WRAP_FUNC(arg.ndo_stop);
<<<<<<< .mine
  //      WRAP_FUNC(arg.ndo_start_xmit);
  //      WRAP_FUNC(arg.ndo_select_queue);
=======
     //   WRAP_FUNC(arg.ndo_start_xmit);
     //   WRAP_FUNC(arg.ndo_select_queue);
>>>>>>> .r761
        WRAP_FUNC(arg.ndo_change_rx_flags);
        WRAP_FUNC(arg.ndo_set_rx_mode);
        WRAP_FUNC(arg.ndo_set_multicast_list);
        WRAP_FUNC(arg.ndo_set_mac_address);
        WRAP_FUNC(arg.ndo_validate_addr);
        WRAP_FUNC(arg.ndo_do_ioctl);
        WRAP_FUNC(arg.ndo_set_config);
        WRAP_FUNC(arg.ndo_change_mtu);
        WRAP_FUNC(arg.ndo_neigh_setup);
        WRAP_FUNC(arg.ndo_tx_timeout);
        WRAP_FUNC(arg.ndo_get_stats);
        WRAP_FUNC(arg.ndo_vlan_rx_register);
        WRAP_FUNC(arg.ndo_vlan_rx_add_vid);
        WRAP_FUNC(arg.ndo_vlan_rx_kill_vid);
        WRAP_FUNC(arg.ndo_poll_controller);
        WRAP_FUNC(arg.ndo_fcoe_enable);
        WRAP_FUNC(arg.ndo_fcoe_disable);
        WRAP_FUNC(arg.ndo_fcoe_ddp_setup);
        WRAP_FUNC(arg.ndo_fcoe_ddp_done);
    }
    post { }
})


TYPE_WRAPPER(struct ethtool_ops, {
    pre {
        D( kern_printk("    ethtool_ops\n"); )
        WRAP_FUNC(arg.get_settings);
        WRAP_FUNC(arg.set_settings);
        WRAP_FUNC(arg.get_drvinfo);
        WRAP_FUNC(arg.get_regs_len);
        WRAP_FUNC(arg.get_regs);
        WRAP_FUNC(arg.get_wol);
        WRAP_FUNC(arg.set_wol);
        WRAP_FUNC(arg.get_msglevel);
        WRAP_FUNC(arg.set_msglevel);
        WRAP_FUNC(arg.nway_reset);
     //   WRAP_FUNC(arg.get_link);
        WRAP_FUNC(arg.get_eeprom_len);
        WRAP_FUNC(arg.get_eeprom);
        WRAP_FUNC(arg.set_eeprom);
        WRAP_FUNC(arg.get_coalesce);
        WRAP_FUNC(arg.set_coalesce);
        WRAP_FUNC(arg.get_ringparam);
        WRAP_FUNC(arg.set_ringparam);
        WRAP_FUNC(arg.get_pauseparam);
        WRAP_FUNC(arg.set_pauseparam);
        WRAP_FUNC(arg.get_rx_csum);
        WRAP_FUNC(arg.set_rx_csum);
        WRAP_FUNC(arg.get_tx_csum);
        WRAP_FUNC(arg.set_tx_csum);
        WRAP_FUNC(arg.set_sg);
        WRAP_FUNC(arg.get_sg);
        WRAP_FUNC(arg.set_tso);
        WRAP_FUNC(arg.get_tso);
        WRAP_FUNC(arg.self_test);
        WRAP_FUNC(arg.get_strings);
        WRAP_FUNC(arg.phys_id);
        WRAP_FUNC(arg.get_ethtool_stats);
        WRAP_FUNC(arg.begin);
        WRAP_FUNC(arg.complete);
        WRAP_FUNC(arg.get_ufo);
        WRAP_FUNC(arg.set_ufo);
        WRAP_FUNC(arg.get_flags);
        WRAP_FUNC(arg.set_flags);
        WRAP_FUNC(arg.get_priv_flags);
        WRAP_FUNC(arg.set_priv_flags);
        WRAP_FUNC(arg.get_sset_count);
        WRAP_FUNC(arg.self_test_count);
        WRAP_FUNC(arg.get_stats_count);
        WRAP_FUNC(arg.get_rxnfc);
        WRAP_FUNC(arg.set_rxnfc);
        WRAP_FUNC(arg.flash_device);
        WRAP_FUNC(arg.reset);
    }
    post { }
})

<<<<<<< .mine
//SET_TAINT_TRACKER(struct timer_list, function); // watch out! lots of timers!
=======
>>>>>>> .r761
TYPE_WRAPPER(struct timer_list, {
    pre {
        D( kern_printk("    timer_list \n"); )
        WRAP_FUNC(arg.function);
    }
    post { }
})

<<<<<<< .mine
//SET_TAINT_TRACKER(struct net_device, destructor); // not required unless recursively wrapping
=======
>>>>>>> .r761
TYPE_WRAPPER(struct net_device, {
    pre {
        D( kern_printk("    net_device \n"); )
        //WRAP_FUNC(arg.destructor);

        WRAP_RECURSIVE(arg.netdev_ops);
        WRAP_RECURSIVE(arg.ethtool_ops);
    }
    post { }
})

/*
TYPE_WRAPPER(struct delayed_work, {
    pre {
        D( kern_printk("    delayed_work\n"); )

      //  WRAP_RECURSIVE(arg.work);
       // WRAP_RECURSIVE(arg.timer);
    }
    post { }
})
*/

<<<<<<< .mine


=======
>>>>>>> .r761
TYPE_WRAPPER(struct work_struct, {
    pre {
        D( kern_printk("    work_struct\n"); )
        WRAP_FUNC(arg.func);
    }
    post { }
})

/*
TYPE_WRAPPER(struct phy_device, {
    pre {
        D( kern_printk("    phy_device\n"); )

        //WRAP_RECURSIVE(arg.bus);
       // WRAP_RECURSIVE(arg.phy_queue);
       // WRAP_RECURSIVE(arg.state_queue);
      //  WRAP_RECURSIVE(arg.attached_dev);
    }
    post { }
})
*/
<<<<<<< .mine


SET_TAINT_TRACKER(struct pci_driver, probe);
=======
>>>>>>> .r761
TYPE_WRAPPER(struct pci_driver, {
    pre {
        D( kern_printk("    pci_driver\n"); )
        WRAP_FUNC(arg.probe);
        WRAP_FUNC(arg.remove);
        WRAP_FUNC(arg.suspend);
        WRAP_FUNC(arg.suspend_late);
        WRAP_FUNC(arg.resume_early);
        WRAP_FUNC(arg.resume);
        WRAP_FUNC(arg.shutdown);

       // WRAP_RECURSIVE(arg.driver);
        WRAP_RECURSIVE(arg.err_handler);
    }
    post { }
})

<<<<<<< .mine

=======
>>>>>>> .r761
TYPE_WRAPPER(struct mii_bus, {
    pre {
        D( kern_printk("    mii_bus\n"); )
        WRAP_FUNC(arg.read);
        WRAP_FUNC(arg.write);
        WRAP_FUNC(arg.reset);

       // WRAP_RECURSIVE(arg.parent);
       // WRAP_RECURSIVE(arg.dev);
    }
    post { }
})

TYPE_WRAPPER(struct phy_driver, {
    pre {
        D( kern_printk("    mii_bus\n"); )
        WRAP_FUNC(arg.config_init);
        WRAP_FUNC(arg.probe);
        WRAP_FUNC(arg.suspend);
        WRAP_FUNC(arg.resume);
        WRAP_FUNC(arg.config_aneg);
        WRAP_FUNC(arg.read_status);
        WRAP_FUNC(arg.ack_interrupt);
        WRAP_FUNC(arg.config_intr);
        WRAP_FUNC(arg.did_interrupt);
        WRAP_FUNC(arg.remove)

      //  WRAP_RECURSIVE_KERNAL(arg.driver);
    }
    post { }
})


TYPE_WRAPPER(struct napi_struct, {
    pre {
        D( kern_printk("    napi_struct\n"); )
        WRAP_FUNC(arg.poll);

       // WRAP_RECURSIVE(arg.dev);

    }
    post { }
})

<<<<<<< .mine

=======
>>>>>>> .r761
TYPE_WRAPPER(struct device_driver, {
    pre {
        D( kern_printk("    device_driver\n"); )
        WRAP_FUNC(arg.probe);
        WRAP_FUNC(arg.remove);
        WRAP_FUNC(arg.shutdown);
        WRAP_FUNC(arg.suspend);
        WRAP_FUNC(arg.resume);
    }
    post { }
})

TYPE_WRAPPER(struct dev_pm_ops, {
    pre { }
    post { }
})

TYPE_WRAPPER(struct pci_error_handlers, {
    pre {
        D( kern_printk("    pci_error_handlers\n"); )
        WRAP_FUNC(arg.error_detected);
        WRAP_FUNC(arg.mmio_enabled);
        WRAP_FUNC(arg.link_reset);
        WRAP_FUNC(arg.slot_reset);
        WRAP_FUNC(arg.resume);
    }
    post { }
})

typedef int (each_kallsym_callback)(void *, const char *, struct module *, unsigned long);

TYPE_WRAPPER(each_kallsym_callback *, {
    pre {
        D( kern_printk("    each_kallsym_callback\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})



TYPE_WRAPPER(poll, {
    pre {
        D( kern_printk("    poll\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(irq_handler_t, {
    pre {
        D( kern_printk("    irq_handler_t\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(handler, {
    pre {
        D( kern_printk("    handler\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

#endif /* CFI_WRAPPERS_HPP_ */
