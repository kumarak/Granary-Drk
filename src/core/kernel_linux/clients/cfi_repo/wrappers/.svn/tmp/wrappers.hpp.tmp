/*
 * wrapper.hpp
 *
 *  Created on: 2012-04-17
 *      Author: akshayk
 */

#ifndef CFI_WRAPPERS_HPP_
#define CFI_WRAPPERS_HPP_

extern "C" {
    #include "kernel_types.h"
}

// example:
// note: the & in the args section is needed to make the wrapper
//       able to modify the arguments by reference.
// int foo_func(char *bar, int baz);
// FUNC_WRAPPER(foo_func, (char *&bar, int &baz), {
//   pre_call {
// 
//   }
//   post_call {
// 
//   }
// })

TYPE_WRAPPER(struct super_operations, {
    pre {
        D( kern_printk("    super_block\n"); )

        WRAP_FUNC(arg.alloc_inode);
        WRAP_FUNC(arg.destroy_inode);
        WRAP_FUNC(arg.dirty_inode);
        WRAP_FUNC(arg.write_inode);
        WRAP_FUNC(arg.drop_inode);
        WRAP_FUNC(arg.delete_inode);
        WRAP_FUNC(arg.put_super);
        WRAP_FUNC(arg.write_super);
        WRAP_FUNC(arg.sync_fs);
        WRAP_FUNC(arg.freeze_fs);
        WRAP_FUNC(arg.unfreeze_fs);
        WRAP_FUNC(arg.statfs);
        WRAP_FUNC(arg.remount_fs);
        WRAP_FUNC(arg.clear_inode);
        WRAP_FUNC(arg.umount_begin);
        WRAP_FUNC(arg.show_options);
        WRAP_FUNC(arg.show_stats);
        WRAP_FUNC(arg.quota_read);
        WRAP_FUNC(arg.quota_write);
        WRAP_FUNC(arg.bdev_try_to_free_page);
    }
    post { }
})

TYPE_WRAPPER(struct dquot_operations, {
    pre {
        D( kern_printk("    dquot_operations\n"); )

       //   WRAP_FUNC(arg.initialize);
     //   WRAP_FUNC(arg.drop);
     //   WRAP_FUNC(arg.alloc_space);
     //   WRAP_FUNC(arg.alloc_inode);
     //   WRAP_FUNC(arg.free_space);
     //   WRAP_FUNC(arg.free_inode);
    //    WRAP_FUNC(arg.transfer);
     //   WRAP_FUNC(arg.write_dquot);
     //   WRAP_FUNC(arg.alloc_dquot);
     //   WRAP_FUNC(arg.destroy_dquot);
      //  WRAP_FUNC(arg.acquire_dquot);
      //  WRAP_FUNC(arg.release_dquot);
      //  WRAP_FUNC(arg.mark_dirty);
      //  WRAP_FUNC(arg.write_info);
      //  WRAP_FUNC(arg.reserve_space);
      //  WRAP_FUNC(arg.claim_space);
      //  WRAP_FUNC(arg.release_rsv);
      //  WRAP_FUNC(arg.get_reserved_space);
    }
    post { }
})


TYPE_WRAPPER(struct quotactl_ops, {
    pre {
        D( kern_printk("    dquot_operations\n"); )

      //  WRAP_FUNC(arg.quota_on);
       // WRAP_FUNC(arg.quota_off);
       // WRAP_FUNC(arg.quota_sync);
       // WRAP_FUNC(arg.get_info);
      //  WRAP_FUNC(arg.set_info);
      //  WRAP_FUNC(arg.get_dqblk);
      //  WRAP_FUNC(arg.set_dqblk);
      //  WRAP_FUNC(arg.get_xstate);
      //  WRAP_FUNC(arg.get_xquota);
      //  WRAP_FUNC(arg.set_xquota);
    }
    post { }
})

TYPE_WRAPPER(struct inode_operations, {
    pre {
        D( kern_printk("    dquot_operations\n"); )

        WRAP_FUNC(arg.create);
        WRAP_FUNC(arg.lookup);
        WRAP_FUNC(arg.link);
        WRAP_FUNC(arg.unlink);
        WRAP_FUNC(arg.symlink);
        WRAP_FUNC(arg.mkdir);
        WRAP_FUNC(arg.rmdir);
        WRAP_FUNC(arg.mknod);
        WRAP_FUNC(arg.rename);
        WRAP_FUNC(arg.readlink);
        WRAP_FUNC(arg.follow_link);
        WRAP_FUNC(arg.put_link);
        WRAP_FUNC(arg.truncate);
        WRAP_FUNC(arg.permission);
        WRAP_FUNC(arg.check_acl);
    	WRAP_FUNC(arg.setattr);
    	WRAP_FUNC(arg.getattr);
    	WRAP_FUNC(arg.setxattr);
    	WRAP_FUNC(arg.getxattr);
    	WRAP_FUNC(arg.listxattr);
    	WRAP_FUNC(arg.removexattr);
    	WRAP_FUNC(arg.truncate_range);
    	WRAP_FUNC(arg.fallocate);
    	WRAP_FUNC(arg.fiemap);
    }
    post { }
})

TYPE_WRAPPER(struct export_operations, {
    pre {
        D( kern_printk("    export_operations\n"); )

          WRAP_FUNC(arg.encode_fh);
          WRAP_FUNC(arg.fh_to_dentry);
          WRAP_FUNC(arg.fh_to_parent);
          WRAP_FUNC(arg.get_name);
          WRAP_FUNC(arg.get_parent);
    }
    post { }
})

TYPE_WRAPPER(struct file_operations, {
    pre {
        D( kern_printk("    file_operations\n"); )

          WRAP_FUNC(arg.llseek);
          WRAP_FUNC(arg.read);
          WRAP_FUNC(arg.write);
          WRAP_FUNC(arg.aio_read);
          WRAP_FUNC(arg.aio_write);
          WRAP_FUNC(arg.readdir);
          WRAP_FUNC(arg.poll);
          WRAP_FUNC(arg.ioctl);
          WRAP_FUNC(arg.unlocked_ioctl);
          WRAP_FUNC(arg.compat_ioctl);
          WRAP_FUNC(arg.mmap);
          WRAP_FUNC(arg.open);
          WRAP_FUNC(arg.flush);
          WRAP_FUNC(arg.release);
          WRAP_FUNC(arg.fsync);
          WRAP_FUNC(arg.aio_fsync);
          WRAP_FUNC(arg.fasync);
          WRAP_FUNC(arg.lock);
          WRAP_FUNC(arg.sendpage);
          WRAP_FUNC(arg.get_unmapped_area);
          WRAP_FUNC(arg.check_flags);
          WRAP_FUNC(arg.flock);
          WRAP_FUNC(arg.splice_write);
          WRAP_FUNC(arg.splice_read);
          WRAP_FUNC(arg.setlease);
    }
    post { }
})


TYPE_WRAPPER(struct address_space_operations, {
    pre {
        D( kern_printk("    address_space_operations\n"); )

          WRAP_FUNC(arg.writepage);
          WRAP_FUNC(arg.readpage);
          WRAP_FUNC(arg.sync_page);
          WRAP_FUNC(arg.writepages);
          WRAP_FUNC(arg.set_page_dirty);
          WRAP_FUNC(arg.readpages);
          WRAP_FUNC(arg.bmap);
          WRAP_FUNC(arg.invalidatepage);
          WRAP_FUNC(arg.releasepage);
          WRAP_FUNC(arg.direct_IO);
          WRAP_FUNC(arg.get_xip_mem);
          WRAP_FUNC(arg.migratepage);
          WRAP_FUNC(arg.launder_page);
          WRAP_FUNC(arg.is_partially_uptodate);
          WRAP_FUNC(arg.error_remove_page);
    }
    post { }
})


TYPE_WRAPPER(struct address_space, {
    pre {
        D( kern_printk("    address_space\n"); )

        WRAP_RECURSIVE(arg.a_ops);
    }
    post { }
})

TYPE_WRAPPER(struct super_block, {
    pre {
        D( kern_printk("    super_block\n"); )

		//WRAP_RECURSIVE(arg.s_type);
        WRAP_RECURSIVE(arg.s_op);
        WRAP_RECURSIVE(arg.s_export_op);
        WRAP_RECURSIVE(arg.dq_op);
        WRAP_RECURSIVE(arg.s_qcop);

        // maybe something like this?
        //for(struct xattr_handler **handler(args.s_xattr);
        //    0 != handler; ++handler) {
        //  WRAP_FUNC(*handler);
        //}
    }
    post { }
})

TYPE_WRAPPER(struct block_device, {
    pre {
        D( kern_printk("    block_device\ n"); )
    }
    post { }
})

TYPE_WRAPPER(struct inode , {
    pre {
        D( kern_printk("    inode\ n"); )

		WRAP_RECURSIVE(arg.i_sb);
        WRAP_RECURSIVE(arg.i_op);
        WRAP_RECURSIVE(arg.i_fop);
        WRAP_RECURSIVE(arg.i_mapping);
    }
    post { }
})

TYPE_WRAPPER(struct buffer_head , {
    pre {
        D( kern_printk("     buffer_head\ n"); )
    }
    post { }
})

TYPE_WRAPPER(struct file_system_type, {
    pre {
        D( kern_printk("    file_system_type\n"); )
        WRAP_FUNC(arg.get_sb);
        WRAP_FUNC(arg.kill_sb);
    }
    post { }
})

TYPE_WRAPPER(struct mb_cache_op, {
    pre {
        D( kern_printk("    mb_cache_op\n"); )
        WRAP_FUNC(arg.free);
    }
    post { }
})

TYPE_WRAPPER(ctor, {
    pre {
        D( kern_printk("    ctor\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(fill_super, {
    pre {
        D( kern_printk("    fill_super\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

<<<<<<< .mine
MAKE_WRAPPER(get_block_t, {
=======
/*TYPE_WRAPPER(get_block_t, {
>>>>>>> .r757
    pre {
        D( kern_printk("    get_block_t\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(bh_end_io_t, {
    pre {
        D( kern_printk("    bh_end_io_t\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(notifier, {
    pre {
        D( kern_printk("    notifier\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(struct net_device_ops, {
    pre {
        D( kern_printk("    net_device_ops\n"); )
        WRAP_FUNC(arg.ndo_init);
        WRAP_FUNC(arg.ndo_uninit);
        WRAP_FUNC(arg.ndo_open);
        WRAP_FUNC(arg.ndo_stop);
     //   WRAP_FUNC(arg.ndo_start_xmit);
     //   WRAP_FUNC(arg.ndo_select_queue);
        WRAP_FUNC(arg.ndo_change_rx_flags);
        WRAP_FUNC(arg.ndo_set_rx_mode);
        WRAP_FUNC(arg.ndo_set_multicast_list);
        WRAP_FUNC(arg.ndo_set_mac_address);
        WRAP_FUNC(arg.ndo_validate_addr);
        WRAP_FUNC(arg.ndo_do_ioctl);
        WRAP_FUNC(arg.ndo_set_config);
        WRAP_FUNC(arg.ndo_change_mtu);
        WRAP_FUNC(arg.ndo_neigh_setup);
        WRAP_FUNC(arg.ndo_tx_timeout);
        WRAP_FUNC(arg.ndo_get_stats);
        WRAP_FUNC(arg.ndo_vlan_rx_register);
        WRAP_FUNC(arg.ndo_vlan_rx_add_vid);
        WRAP_FUNC(arg.ndo_vlan_rx_kill_vid);
        WRAP_FUNC(arg.ndo_poll_controller);
        WRAP_FUNC(arg.ndo_fcoe_enable);
        WRAP_FUNC(arg.ndo_fcoe_disable);
        WRAP_FUNC(arg.ndo_fcoe_ddp_setup);
        WRAP_FUNC(arg.ndo_fcoe_ddp_done);
    }
    post { }
})


TYPE_WRAPPER(struct ethtool_ops, {
    pre {
        D( kern_printk("    ethtool_ops\n"); )
		WRAP_FUNC(arg.get_settings);
        WRAP_FUNC(arg.set_settings);
        WRAP_FUNC(arg.get_drvinfo);
        WRAP_FUNC(arg.get_regs_len);
        WRAP_FUNC(arg.get_regs);
        WRAP_FUNC(arg.get_wol);
        WRAP_FUNC(arg.set_wol);
        WRAP_FUNC(arg.get_msglevel);
        WRAP_FUNC(arg.set_msglevel);
        WRAP_FUNC(arg.nway_reset);
     //   WRAP_FUNC(arg.get_link);
        WRAP_FUNC(arg.get_eeprom_len);
        WRAP_FUNC(arg.get_eeprom);
        WRAP_FUNC(arg.set_eeprom);
        WRAP_FUNC(arg.get_coalesce);
        WRAP_FUNC(arg.set_coalesce);
        WRAP_FUNC(arg.get_ringparam);
        WRAP_FUNC(arg.set_ringparam);
        WRAP_FUNC(arg.get_pauseparam);
        WRAP_FUNC(arg.set_pauseparam);
        WRAP_FUNC(arg.get_rx_csum);
        WRAP_FUNC(arg.set_rx_csum);
        WRAP_FUNC(arg.get_tx_csum);
        WRAP_FUNC(arg.set_tx_csum);
        WRAP_FUNC(arg.set_sg);
        WRAP_FUNC(arg.get_sg);
        WRAP_FUNC(arg.set_tso);
        WRAP_FUNC(arg.get_tso);
        WRAP_FUNC(arg.self_test);
        WRAP_FUNC(arg.get_strings);
        WRAP_FUNC(arg.phys_id);
        WRAP_FUNC(arg.get_ethtool_stats);
        WRAP_FUNC(arg.begin);
        WRAP_FUNC(arg.complete);
        WRAP_FUNC(arg.get_ufo);
        WRAP_FUNC(arg.set_ufo);
        WRAP_FUNC(arg.get_flags);
        WRAP_FUNC(arg.set_flags);
        WRAP_FUNC(arg.get_priv_flags);
        WRAP_FUNC(arg.set_priv_flags);
        WRAP_FUNC(arg.get_sset_count);
        WRAP_FUNC(arg.self_test_count);
        WRAP_FUNC(arg.get_stats_count);
        WRAP_FUNC(arg.get_rxnfc);
        WRAP_FUNC(arg.set_rxnfc);
        WRAP_FUNC(arg.flash_device);
        WRAP_FUNC(arg.reset);
    }
    post { }
})

TYPE_WRAPPER(struct timer_list, {
    pre {
        D( kern_printk("    timer_list \n"); )
        WRAP_FUNC(arg.function);
    }
    post { }
})

TYPE_WRAPPER(struct net_device, {
    pre {
        D( kern_printk("    net_device \n"); )
        //WRAP_FUNC(arg.destructor);

        WRAP_RECURSIVE(arg.netdev_ops);
        WRAP_RECURSIVE(arg.ethtool_ops);
    }
    post { }
})

/*
TYPE_WRAPPER(struct delayed_work, {
    pre {
        D( kern_printk("    delayed_work\n"); )

      //  WRAP_RECURSIVE(arg.work);
       // WRAP_RECURSIVE(arg.timer);
    }
    post { }
})
*/

TYPE_WRAPPER(struct work_struct, {
    pre {
        D( kern_printk("    work_struct\n"); )
        WRAP_FUNC(arg.func);
    }
    post { }
})

/*
TYPE_WRAPPER(struct phy_device, {
    pre {
        D( kern_printk("    phy_device\n"); )

        //WRAP_RECURSIVE(arg.bus);
       // WRAP_RECURSIVE(arg.phy_queue);
       // WRAP_RECURSIVE(arg.state_queue);
      //  WRAP_RECURSIVE(arg.attached_dev);
    }
    post { }
})
*/
TYPE_WRAPPER(struct pci_driver, {
    pre {
        D( kern_printk("    pci_driver\n"); )
        WRAP_FUNC(arg.probe);
        WRAP_FUNC(arg.remove);
        WRAP_FUNC(arg.suspend);
        WRAP_FUNC(arg.suspend_late);
        WRAP_FUNC(arg.resume_early);
        WRAP_FUNC(arg.resume);
        WRAP_FUNC(arg.shutdown);

       // WRAP_RECURSIVE(arg.driver);
        WRAP_RECURSIVE(arg.err_handler);
    }
    post { }
})

TYPE_WRAPPER(struct mii_bus, {
    pre {
        D( kern_printk("    mii_bus\n"); )
        WRAP_FUNC(arg.read);
        WRAP_FUNC(arg.write);
        WRAP_FUNC(arg.reset);

       // WRAP_RECURSIVE(arg.parent);
       // WRAP_RECURSIVE(arg.dev);
    }
    post { }
})


TYPE_WRAPPER(struct napi_struct, {
    pre {
        D( kern_printk("    napi_struct\n"); )
        WRAP_FUNC(arg.poll);

       // WRAP_RECURSIVE(arg.dev);

    }
    post { }
})

TYPE_WRAPPER(struct device_driver, {
    pre {
        D( kern_printk("    device_driver\n"); )
        WRAP_FUNC(arg.probe);
        WRAP_FUNC(arg.remove);
        WRAP_FUNC(arg.shutdown);
        WRAP_FUNC(arg.suspend);
        WRAP_FUNC(arg.resume);
    }
    post { }
})
/*
TYPE_WRAPPER(struct dev_pm_ops, {
    pre { }
    post { }
})
*/
TYPE_WRAPPER(struct pci_error_handlers, {
    pre {
        D( kern_printk("    pci_error_handlers\n"); )
        WRAP_FUNC(arg.error_detected);
        WRAP_FUNC(arg.mmio_enabled);
        WRAP_FUNC(arg.link_reset);
        WRAP_FUNC(arg.slot_reset);
        WRAP_FUNC(arg.resume);
    }
    post { }
})

typedef int (each_kallsym_callback)(void *, const char *, struct module *, unsigned long);

TYPE_WRAPPER(each_kallsym_callback *, {
    pre {
        D( kern_printk("    each_kallsym_callback\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})



TYPE_WRAPPER(poll, {
    pre {
        D( kern_printk("    poll\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(irq_handler_t, {
    pre {
        D( kern_printk("    irq_handler_t\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

TYPE_WRAPPER(handler, {
    pre {
        D( kern_printk("    handler\n"); )
        WRAP_FUNC(arg);
    }
    post { }
})

#endif /* CFI_WRAPPERS_HPP_ */
